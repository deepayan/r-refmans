<!DOCTYPE html><html><head><title>Help for package asremlPlus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {asremlPlus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addBacktransforms.alldiffs'><p>Adds or recalculates the backtransforms component of an <code>alldiffs.object</code>.</p></a></li>
<li><a href='#addSpatialModel.asrtests'><p>Adds, to a supplied model, a spatial model that accounts for local spatial variation.</p></a></li>
<li><a href='#addSpatialModelOnIC.asrtests'><p>Uses information criteria to decide whether to add a spatial model to account for local spatial variation.</p></a></li>
<li><a href='#addto.test.summary'><p>Adds a row to a <code>test.summary</code> <code>data.frame</code>.</p></a></li>
<li><a href='#allDifferences.data.frame'><p>Using supplied predictions and standard errors of pairwise differences or the</p>
variance matrix of predictions, forms all pairwise differences between the
set of predictions, and p-values for the differences.</a></li>
<li><a href='#alldiffs.object'><p>Description of an alldiffs object</p></a></li>
<li><a href='#angular'><p>Applies the angular transformation to proportions.</p></a></li>
<li><a href='#angular.mod'><p>Applies the modified angular transformation to a vector of counts.</p></a></li>
<li><a href='#as.alldiffs'><p>Forms an <code>alldiffs.object</code> from the supplied predictions, along with those statistics,</p>
associated with the predictions and their pairwise differences, that have been supplied.</a></li>
<li><a href='#as.asrtests'><p>Forms an asrtests object that stores (i) a fitted asreml object,</p>
(ii) a pseudo-anova table for the fixed terms and (iii) a history of
changes and hypothesis testing used in obtaining the model.</a></li>
<li><a href='#as.predictions.frame'><p>Forms a <code>predictions.frame</code> from a <code>data.frame</code>, ensuring that the correct</p>
columns are present.</a></li>
<li><a href='#asremlPlus-deprecated'><p>Deprecated Functions in the Package asremlPlus</p></a></li>
<li><a href='#asremlPlus-package'>
<p>Augments 'ASReml-R' in Fitting Mixed Models and Packages</p>
Generally in Exploring Prediction Differences</a></li>
<li><a href='#asremlPlusTips'><p>The randomly-presented, startup tips.</p></a></li>
<li><a href='#asrtests.object'><p>Description of an asrtests object</p></a></li>
<li><a href='#bootREMLRT.asreml'><p>Uses the parametric bootstrap to calculate the p-value for a REML ratio test to compare two models.</p></a></li>
<li><a href='#changeModelOnIC.asrtests'><p>Uses information criteria to decide whether to change an already fitted model.</p></a></li>
<li><a href='#changeTerms.asrtests'><p>Adds and drops terms from one or both of the fixed or random model, replaces</p>
the residual (rcov) model with a new model and changes bounds or initial
values of terms.</a></li>
<li><a href='#ChickpeaEnd.dat'><p>A large data set comprising the end of imaging data from a chick pea experiment conducted in high-throughput greenhouses</p></a></li>
<li><a href='#chooseModel'><p>Determines the set of significant terms using p-values and records the tests performed in a</p>
<code>data.frame</code>, taking into account the
marginality relations of terms.</a></li>
<li><a href='#chooseModel.asrtests'><p>Determines and records the set of significant terms using an <code>asrtests.object</code>,</p>
taking into account the hierarchy or marginality relations of the terms.</a></li>
<li><a href='#chooseModel.data.frame'><p>Determines the set of significant terms from results stored in a <code>data.frame</code>,</p>
taking into account the marginality relations of terms and recording the tests used
in a <code>data.frame</code>.</a></li>
<li><a href='#chooseSpatialModelOnIC.asrtests'><p>Uses information criteria to choose the best fitting spatial model for accounting for local spatial variation.</p></a></li>
<li><a href='#convAsremlobj.asreml'><p>Recreates an <code>asreml</code> object so that it is compatible with the currently loaded <code>asreml</code> version.</p></a></li>
<li><a href='#convEffectNames2DataFrame.asreml'><p>Converts the effects names for a term stored in the component of an <code>asreml</code> object into a <code>data.frame</code>.</p></a></li>
<li><a href='#estimateV.asreml'><p>Forms the estimated variance, random or residual matrix for the observations</p>
from the variance parameter estimates.</a></li>
<li><a href='#exploreLSDs.alldiffs'><p>Explores the computed LSD values for pairwise differences between predictions.</p></a></li>
<li><a href='#facCombine.alldiffs'><p>Combines several factors into one in the components of an <code>alldiffs.object</code></p></a></li>
<li><a href='#facRecast.alldiffs'><p>Reorders and/or revises the factor levels using the order of old levels in <code>levels.order</code> and the new labels for the levels given in <code>newlabels</code>. The values in <code>levels.order</code> must be unique.</p></a></li>
<li><a href='#facRename.alldiffs'><p>Renames <code>factor</code>s in the <code>prediction</code> component of an</p>
<code>alldiffs.object</code>.</a></li>
<li><a href='#getASRemlVersionLoaded'><p>Finds the version of asreml that is loaded and returns the initial characters in version.</p></a></li>
<li><a href='#getFormulae.asreml'><p>Gets the formulae from an asreml object.</p></a></li>
<li><a href='#getTestEntry.asrtests'><p>Gets the entry for a test recorded in the test.summary data.frame of an <code>asrtests.object</code></p></a></li>
<li><a href='#getTestPvalue.asrtests'><p>Gets the p-value for a test recorded in the test.summary data.frame of an <code>asrtests.object</code></p></a></li>
<li><a href='#infoCriteria'><p>Computes AIC and BIC for models.</p></a></li>
<li><a href='#is.alldiffs'><p>Tests whether an object is of class alldiffs</p></a></li>
<li><a href='#is.asrtests'><p>Tests whether an object is of class asrtests</p></a></li>
<li><a href='#is.predictions.frame'><p>Tests whether an object is of class predictions.frame</p></a></li>
<li><a href='#iterate.asrtests'><p>Subject the fitted <code>asreml.obj</code> stored in an <code>asrtests.object</code></p>
to further iterations of the fitting process.</a></li>
<li><a href='#Ladybird.dat'><p>Data for an experiment to investigate whether ladybirds transfer aphids</p></a></li>
<li><a href='#linTransform.alldiffs'><p>Calculates a linear transformation of the predictions stored in an</p>
<code>alldiffs.object</code>.</a></li>
<li><a href='#loadASRemlVersion'><p>Ensures that a specific version of <code>asreml</code> is loaded.</p></a></li>
<li><a href='#LSD.frame'><p>Description of an LSD frame</p></a></li>
<li><a href='#makeTPPSplineMats.data.frame'><p>Make the spline basis matrices and data needed to fit Tensor Product P-splines.</p></a></li>
<li><a href='#newfit.asreml'><p>Refits an <code>asreml</code> model with changed arguments by extracting, modifying</p>
and evaluating its <code>call</code> - an alternate to update.asreml.</a></li>
<li><a href='#num.recode'><p>Recodes the unique values of a vector using the values in a new vector.</p></a></li>
<li><a href='#Oats.dat'><p>Data for an experiment to investigate nitrogen response of 3 oats varieties</p></a></li>
<li><a href='#pairdiffsTransform.alldiffs'><p>Calculates the differences between nominated pairs of predictions stored in</p>
an <code>alldiffs.object</code>.</a></li>
<li><a href='#permute.square'><p>Permutes the rows and columns of a square matrix.</p></a></li>
<li><a href='#permute.to.zero.lowertri'><p>Permutes a square matrix until all the lower triangular elements are zero.</p></a></li>
<li><a href='#pickLSDstatistics.alldiffs'><p>Pick LSDstatistics whose values minimize the number of errors in pairwise comparisons of predictions.</p></a></li>
<li><a href='#plotLSDerrors.alldiffs'><p>Plots a map of the errors that occur in using the computed LSD values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotLSDerrors.data.frame'><p>Plots a map of the supplied errors that occur in using the computed LSD values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotLSDs.alldiffs'><p>Plots a heat map of computed LSD values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotLSDs.data.frame'><p>Plots a heat map of computed LSD-values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotPredictions.data.frame'><p>Plots the predictions for a term, possibly with error bars.</p></a></li>
<li><a href='#plotPvalues.alldiffs'><p>Plots a heat map of p-values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotPvalues.data.frame'><p>Plots a heat map of p-values for pairwise differences between predictions.</p></a></li>
<li><a href='#plotVariofaces.data.frame'><p>Plots empirical variogram faces, including envelopes, from supplied residuals as</p>
described by Stefanova, Smith &amp; Cullis (2009).</a></li>
<li><a href='#powerTransform'><p>Performs a combination of a linear and a power transformation on a variable. The</p>
transformed variable is stored in the <code>data.frame data</code>.</a></li>
<li><a href='#predictions.frame'><p>Description of a predictions object</p></a></li>
<li><a href='#predictPlus.asreml'><p>Forms the predictions for a term, their pairwise differences and</p>
associated statistics. A factor having parallel values may occur in
the model and a linear transformation of the predictions can be specified.
It results in an object of class alldifffs.</a></li>
<li><a href='#predictPresent.asreml'><p>Forms the predictions for each of one or more terms and presents</p>
them in tables and/or graphs.</a></li>
<li><a href='#print.alldiffs'><p>Prints the values in an <code>alldiffs.object</code> in a nice format.</p></a></li>
<li><a href='#print.asrtests'><p>Prints the values in an <code>asrtests.object</code></p></a></li>
<li><a href='#print.LSDdata'><p>Prints the components of a list containing data on the LSDs for all pairwise differences of predictions.</p></a></li>
<li><a href='#print.predictions.frame'><p>Prints the values in a <code>predictions.frame</code>, with or without title and heading.</p></a></li>
<li><a href='#print.test.summary'><p>Prints a data.frame containing a test.summary.</p></a></li>
<li><a href='#print.wald.tab'><p>Prints a data.frame containing a Wald or pseudoanova table.</p></a></li>
<li><a href='#printFormulae.asreml'><p>Prints the formulae from an asreml object.</p></a></li>
<li><a href='#R2adj.asreml'><p>Calculates the adjusted coefficient of determination for a specified combination of fixed and random terms.</p></a></li>
<li><a href='#ratioTransform.alldiffs'><p>Calculates the ratios of nominated pairs of predictions stored in an <code>alldiffs.object</code>.</p></a></li>
<li><a href='#recalcLSD.alldiffs'><p>Adds or recalculates the <code>LSD.frame</code> that is a component of an</p>
<code>alldiffs.object</code>.</a></li>
<li><a href='#recalcWaldTab.asrtests'><p>Recalculates the denDF, F.inc and P values for a table of Wald test statistics obtained</p>
using <code>wald.asreml</code></a></li>
<li><a href='#redoErrorIntervals.alldiffs'><p>Adds or replaces the error intervals stored in a prediction component</p>
of an <code>alldiffs.object</code>.</a></li>
<li><a href='#REMLRT.asreml'><p>Performs a REML ratio test to compare two models.</p></a></li>
<li><a href='#renewClassify.alldiffs'><p>Renews the components in an <code>alldiffs.object</code> according to a new classify.</p></a></li>
<li><a href='#reparamSigDevn.asrtests'><p>Reparamterizes each random (deviations) term involving</p>
<code>devn.fac</code> to a fixed term and ensures that the same term, with
<code>trend.num</code> replacing <code>devn.fac</code>, is included if any
other term with <code>trend.num</code> is included in <code>terms</code>.</a></li>
<li><a href='#rmboundary.asrtests'><p>Removes any boundary or singular variance components from the fit stored in</p>
<code>asrtests.obj</code> and records their removal in an <code>asrtests.object</code>.</a></li>
<li><a href='#setvarianceterms.call'><p>allows the setting of bounds and initial values for terms in the</p>
<code>random</code> and <code>residual</code> arguments of an <code>asreml</code> call, with
the resulting call being evaluated.</a></li>
<li><a href='#simulate.asreml'><p>Produce sets of simulated data from a multivariate normal distribution and save</p>
quantities related to the simulated data</a></li>
<li><a href='#sort.alldiffs'><p>Sorts the components in an <code>alldiffs.object</code> according to the predicted values</p>
associated with a factor.</a></li>
<li><a href='#sort.predictions.frame'><p>Sorts a <code>predictions.frame</code> according to the predicted values</p>
associated with a factor.</a></li>
<li><a href='#subset.alldiffs'><p>Subsets the components in an <code>alldiffs.object</code> according to the supplied condition.</p></a></li>
<li><a href='#subset.list'><p>Forms a <code>list</code> that contains a subset of the components of the supplied</p>
<code>list</code>.</a></li>
<li><a href='#testranfix.asrtests'><p>Tests for a single fixed or random term in model fitted using <code>asreml</code></p>
and records the result in an <code>asrtests.object</code>.</a></li>
<li><a href='#testresidual.asrtests'><p>Fits a new residual formula, tests whether the change</p>
is significant and records the result in an <code>asrtests.object</code>.</a></li>
<li><a href='#testswapran.asrtests'><p>Tests, using a REMLRT, the significance of the difference between the current</p>
random model and one in which oldterms are dropped and newterms are added.
The result is recorded in an <code>asrtests.object</code>.</a></li>
<li><a href='#validAlldiffs'><p>Checks that an object is a valid alldiffs object.</p></a></li>
<li><a href='#validAsrtests'><p>Checks that an object is a valid asrtests object.</p></a></li>
<li><a href='#validPredictionsFrame'><p>Checks that an object is a valid predictions.frame.</p></a></li>
<li><a href='#variofaces.asreml'><p>Plots empirical variogram faces, including envelopes, as described by</p>
Stefanova, Smith &amp; Cullis (2009).</a></li>
<li><a href='#WaterRunoff.dat'><p>Data for an experiment to investigate the quality of water runoff over time</p></a></li>
<li><a href='#Wheat.dat'><p>Data for a 1976 experiment to investigate 25 varieties of wheat</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.4.27</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Augments 'ASReml-R' in Fitting Mixed Models and Packages
Generally in Exploring Prediction Differences</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dae, devtools, doParallel, dplyr, foreach, ggplot2, graphics,
grDevices, methods, nloptr, parallel, qqplotr, RColorBrewer,
reshape2, rlang, stats, sticky, stringr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emmeans (&ge; 1.8.8), lattice, lmerTest, pbkrtest, R.rsp,
testthat, tictoc</td>
</tr>
<tr>
<td>Enhances:</td>
<td>asreml</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>asreml</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Description:</td>
<td>Assists in automating the selection of terms to include in mixed models when  
  'asreml' is used to fit the models. Procedures are available for choosing models that 
  conform to the hierarchy or marginality principle, for fitting and choosing between 
  two-dimensional spatial models using correlation, natural cubic smoothing spline and 
  P-spline models. A history of the fitting of a sequence of models is kept in a data frame. 
  Also used to compute functions and contrasts of, to investigate differences between and 
  to plot predictions obtained using any model fitting function. The content  falls into 
  the following natural groupings: (i) Data, (ii) Model modification functions, (iii) Model 
  selection and description functions, (iv) Model diagnostics and simulation functions, 
  (v) Prediction production and presentation functions, (vi) Response transformation 
  functions, (vii) Object manipulation functions, and (viii) Miscellaneous functions 
  (for further details see 'asremlPlus-package' in help). The 'asreml' package provides a 
  computationally efficient algorithm for fitting a wide range of linear mixed models using 
  Residual Maximum Likelihood. It is a commercial package and a license for it can be 
  purchased from 'VSNi' <a href="https://vsni.co.uk/">https://vsni.co.uk/</a> as 'asreml-R', who will supply a zip file 
  for local installation/updating (see <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>). It is not needed 
  for functions that are methods for 'alldiffs'  and 'data.frame' objects. The package 
  'asremPlus' can also be installed from <a href="http://chris.brien.name/rpackages/">http://chris.brien.name/rpackages/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://chris.brien.name">http://chris.brien.name</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/briencj/asremlPlus/issues">https://github.com/briencj/asremlPlus/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 12:33:44 UTC; briencj</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Brien <a href="https://orcid.org/0000-0003-0581-1817"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Brien &lt;chris.brien@adelaide.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addBacktransforms.alldiffs'>Adds or recalculates the backtransforms component of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+addBacktransforms.alldiffs'></span><span id='topic+addBacktransforms'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, adds or recalculate its <code>backtransforms</code> component. 
The values of <code>transform.power</code>, <code>offset</code>, <code>scale</code> and <code>transform.function</code> 
from the <code>backtransforms</code> component will be used, unless this component is <code>NULL</code> 
when the values supplied in the call will be used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
addBacktransforms(alldiffs.obj, 
                  transform.power = 1, offset = 0, scale = 1, 
                  transform.function =  "identity", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBacktransforms.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="addBacktransforms.alldiffs_+3A_transform.power">transform.power</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the power of a transformation, if 
one has been applied to the response variable. Unless it is equal 
to 1, the default, back-transforms of the predictions will be 
obtained and presented in tables or graphs as appropriate. 
The back-transformation raises the predictions to the power equal 
to the reciprocal of <code>transform.power</code>, unless it equals 0 in 
which case the exponential of the predictions is taken.</p>
</td></tr> 
<tr><td><code id="addBacktransforms.alldiffs_+3A_offset">offset</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that has been added to each value of the 
response after any scaling and before applying any power transformation.</p>
</td></tr>
<tr><td><code id="addBacktransforms.alldiffs_+3A_scale">scale</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> by which each value of the response has been multiplied 
before adding any offset and applying any power transformation.</p>
</td></tr>
<tr><td><code id="addBacktransforms.alldiffs_+3A_transform.function">transform.function</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a function that 
specifies the scale on which the predicted values are defined. This may be the 
result of a transformation of the data using the function or the use of the 
function as a link function in the fitting of a generalized linear (mixed) 
model (GL(M)M). The possible <code>transform.function</code>s are 
<code>identity</code>, <code>log</code>, <code>inverse</code>, <code>sqrt</code>, <code>logit</code>, 
<code>probit</code>, and <code>cloglog</code>.  The <code>predicted.values</code> and 
<code>error.intervals</code>, if not <code>StandardError</code> intervals, will be 
back-transformed using the inverse function of the <code>transform.function</code>. 
The <code>standard.error</code> column will be set to <code>NA</code>, unless (i) 
<code>asreml</code> returns columns named <code>transformed.value</code> and 
<code>approx.se</code>, as well as those called <code>predicted.values</code> and 
<code>standard.error</code> (such as when a GLM is fitted) and 
(ii) the values in <code>transformed.value</code> are equal to those obtained by 
backtransforming the <code>predicted.value</code>s using the inverse function 
of the <code>transform.function</code>. Then, the <code>approx.se</code> values will be 
saved in the <code>standard.error</code> column of the <code>backtransforms</code> 
component of the returned <code>alldiffs.obj</code>. Also, the 
<code>transformed.value</code> and <code>approx.se</code> columns are removed from both 
the <code>predictions</code> and <code>backtransforms</code> components of the 
<code>alldiffs.obj</code>. Note that the values that end up in the <code>standard errors</code> 
column are approximate for the backtransformed values and are not used in 
calculating <code>error.intervals</code>.</p>
</td></tr>
<tr><td><code id="addBacktransforms.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with components 
<code>predictions</code>, <code>vcov</code>, <code>differences</code>, <code>p.differences</code>, 
<code>sed</code>, <code>LSD</code> and <code>backtransforms</code>.
</p>
<p>The <code>backtransforms</code> component will have the attributes (i) <code>LSDtype</code>, 
<code>LSDby</code> and <code>LSDstatistic</code> added from the <code>predictions</code> component and 
(ii) <code>transform.power</code>, <code>offset</code>, <code>scale</code>, and <code>link</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, 
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code><a href="#topic+print.alldiffs">print.alldiffs</a></code>,  <br /> 
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>, <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <br /> 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18" &amp; Benches != "3")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = log.Turbidity ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

##Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp;&amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(log.Turbidity ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=tmp)
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Species)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Species", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Recalculate the back-transforms of the predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  TS.diffs &lt;- addBacktransforms.alldiffs(TS.diffs, transform.power = 0)
}
</code></pre>

<hr>
<h2 id='addSpatialModel.asrtests'>Adds, to a supplied model, a spatial model that accounts for local spatial variation.</h2><span id='topic+addSpatialModel.asrtests'></span><span id='topic+addSpatialModel'></span>

<h3>Description</h3>

<p>Adds either a correlation, two-dimensional tensor-product natural cubic 
smoothing spline (TPNCSS), or a two-dimensional tensor-product penalized P-spline 
model (TPPS) to account for the local spatial variation exhibited by a response variable 
measured on a potentially irregular grid of rows and columns of the units. The data may 
be arranged in sections, for each of which there is a grid and for which the model is to 
be fitted separately. Also, the rows and columns of a grid are not necessarily one 
observational unit wide. For <code>TPPS</code> models for which the order of differencing the 
penalty matrix is two, the improvement in the fit from rotating the eigenvectors of the 
penalty matrix can be investigated.
</p>
<p>No hypothesis testing or comparison of information criteria is made. To only change 
the terms based on a comparison  of information criteria use 
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code>.
</p>
<p>The model fit supplied in the <code>asrtests.obj</code> should not include terms that will 
be included in the local spatial model. All spatial model terms are fitted as fixed or 
random. Consequently, the residual model does not have to be iid.
</p>
<p>One or more rows is added for each <code>section</code> to the <code>test.summary</code> 
<code>data.frame</code>. Convergence and the occurrence of fixed correlations in fitting the 
model is checked and a note included in the <code>action</code> if there was not. 
All components of the <code><a href="#topic+asrtests.object">asrtests.object</a></code> are updated for the new model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
addSpatialModel(asrtests.obj, spatial.model = "TPPS", 
                sections = NULL, 
                row.covar = "cRow", col.covar = "cCol", 
                row.factor = "Row", col.factor = "Col", 
                corr.funcs = c("ar1", "ar1"), corr.orders = c(0, 0), 
                row.corrFitfirst = TRUE, allow.corrsJointFit = TRUE, 
                dropFixed = NULL, dropRandom = NULL, 
                nsegs = NULL, nestorder = c(1,1), 
                degree = c(3,3), difforder = c(2,2), 
                usRandLinCoeffs = TRUE, 
                rotateX = FALSE, ngridangles = NULL, 
                which.rotacriterion = "AIC", nrotacores = 1, 
                asreml.option = "grp", tpps4mbf.obj = NULL, 
                allow.unconverged = FALSE, allow.fixedcorrelation = FALSE,
                checkboundaryonly = FALSE, update = FALSE, 
                maxit = 30, IClikelihood = "full", which.IC = "AIC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSpatialModel.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components 
(i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_spatial.model">spatial.model</code></td>
<td>
<p>A single <code>character</code> string nominating the type of spatial 
model to fit. Possible values are <code>corr</code>, <code>TPNCSS</code> and 
<code>TPPS</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_sections">sections</code></td>
<td>
<p>A single <code>character</code> string that specifies the name of the column 
in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the <code><a href="base.html#topic+factor">factor</a></code> 
that identifies different sections of the data to which separate spatial 
models are to be fitted. Note that, for other terms that involve 
<code>sections</code> in the random formula, there should be separate terms for 
each level of <code>sections</code>. For example, in a blocked experiment 
involving multiple sites, there should be the sum of separate terms for 
the Blocks at each Site i.e. a formula that contains terms like 
at(Site, i):Block for each site and these are separated by <code>'+'</code>. 
Otherwise, the combined term (e.g. Site:Block) will impact on the 
fitting of the local spatial models for the different Sites. Similarly, 
a separate residual variance for each of the <code>sections</code> should be 
fitted, unless there is a need to fit a different variance structure to 
the residual, e.g. heterogeneous residual variances depending on 
treatments. Separate residual variances for <code>sections</code> can be 
achieved using the <code>asreml</code> functions <code>dsum</code> or <code>idh</code>. 
Because, unlike random terms, terms for residual variances are not 
removed from the model, compound residual terms can be used to include 
them in the model, e.g. terms with <code>idh</code> or <code>dsum</code> with multiple
<code>levels</code> in the <code>list</code> or leaving <code>levels</code> out altogether. 
In addition to allowing the independent fitting of models to the 
<code>sections</code>, separate residual variance terms allows a nugget variance 
to be fitted in a correlation model for each of the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_row.covar">row.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the rows of a 
grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_col.covar">col.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the columns 
of a grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_row.factor">row.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the rows of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_col.factor">col.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the columns of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_corr.funcs">corr.funcs</code></td>
<td>
<p>A single <code>character</code> string of length two that specifies the 
<code>asreml</code> one-dimensional correlation or variance model function 
for the row and column dimensions of a two-dimensional separable spatial 
correlation model to be fitted when <code>spatial.model</code> is <code>corr</code>; 
the two-dimensional model is fitted as a random term. If a correlation 
or variance model is not to be investigated for one of the dimensions, 
specify <code>""</code> for that dimension. If the correlation model is  
<code>corb</code>, the values of <code>corr.orders</code> are used for its order 
argument (<code>b</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_corr.orders">corr.orders</code></td>
<td>
<p>A <code>numeric</code> of length two that specifies the order argument 
(<code>b</code>) values for the row and column dimensions of a two-dimensional 
separable spatial correlation model when <code>spatial.model</code> is 
<code>corr</code> and the <code>corr.funcs</code> for a dimension is <code>corb</code>, 
the <code>asreml</code> banded correlation model. If one of the dimensions 
does not involve an order argument, set the value of <code>corr.orders</code> 
for that dimension to zero. For a dimension for which the 
<code>corr.funcs</code> is <code>corb</code> and <code>corr.orders</code> is zero, a 
model with a single band, the correlation between immediate neighbours, 
will be fitted and then further bands, up to a maximum of 10 bands, will 
be added until the addition of an extra band does not reduce the 
information criterion nominated using <code>which.IC</code>. Note that the 
two-dimensional spatial model is fitted as a random term.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_row.corrfitfirst">row.corrFitfirst</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>. If <code>TRUE</code> then, in fitting the 
model for <code>spatial.model</code> set to <code>corr</code>, the row correlation  
or variance function is fitted first, followed by the addition of the 
column correlation or variance function. If <code>FALSE</code>, the order 
of fitting is reversed.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_allow.corrsjointfit">allow.corrsJointFit</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will allow 
the simultaneous fitting of correlation functions for the two dimensions 
of the grid when separate fits have failed to fit any correlation 
functions. This argument is available for when a joint fit 
hangs the system.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_dropfixed">dropFixed</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>". ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the fixed 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes these 
terms, will be compared with the fitted model that has had them removed and 
a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>wald.tab</code> component of the 
<code>asrtests.obj</code>. The fixed terms will be reordered so that 
single-variable terms come first, followed by two-variable terms and 
so on. Note also that multiple terms specified using a single 
<code>asreml::at</code> function can only be dropped as a whole. If the term 
was specified using an <code>asreml::at</code> function with a single level, 
then it can be removed and either the level itself or its 
<code><a href="base.html#topic+numeric">numeric</a></code> position in the levels returned by the 
<code><a href="base.html#topic+levels">levels</a></code> function can be specified.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_droprandom">dropRandom</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>" ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the random 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes 
these terms, will be compared with the fitted model that has had them removed 
and a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>. Note also that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_nsegs">nsegs</code></td>
<td>
<p>A pair of <code><a href="base.html#topic+numeric">numeric</a></code> values giving the number of segments into
which the column and row ranges are to be split, respectively, for fitting 
a P-spline model (<code>TPPS</code>) (each value specifies the number of internal 
knots + 1). If not specified, then (number of unique values - 1) is used 
in each dimension; for a grid layout with equal spacing, this gives a knot 
at each data value. If <code>sections</code> is not <code>NULL</code> and the grid 
differs between the <code>sections</code>, then <code>nsegs</code> will differ between 
the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_nestorder">nestorder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of nesting for column 
and row dimensions, respectively, in fitting a P-spline model (<code>TPPS</code>). 
A value of 1 specifies no nesting, a value of 2 generates a spline with 
half the number of segments in that 
dimension, etc. The number of segments in each direction must be a 
multiple of the order of nesting.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_degree">degree</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code>  of length 2. The degree of polynomial spline to 
be used for column and row dimensions respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_difforder">difforder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of differencing for 
column and row dimensions, respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_usrandlincoeffs">usRandLinCoeffs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will attempt to  
fit an unstructured variance model to the constant and linear terms in 
the interactions for constant and linear terms in one grid dimension 
interacting with smooth terms in the second grid dimension. The 
unstructured variance model can only be fitted if both the constant and 
linear interaction terms have been retained in the fitted model. 
This argument can be used to omit the attempt to fit an unstructured 
variance model when the attempt results in a system error.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_rotatex">rotateX</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to rotate the eigenvectors of the 
penalty matrix, as described by Piepho, Boer and Williams (2022), when 
fitting a P-spline (<code>TPPS</code>). Setting <code>rotateX</code> to <code>TRUE</code> 
results in a search for an optimized rotation under a model that omits 
the random spline interaction terms. If <code>ngridangles</code> is set to 
<code>NULL</code>, the optimal rotation us found using an optimizer 
(<code>nloptr::bobyqa</code>). Otherwise, the optimal rotation is found by 
exploring the fit over a  two-dimensional grid of rotation angle pairs. 
The optimization seeks to optimize the criterion nominated in 
<code>which.rotacriterion</code>. Rotation of the eigenvectors is only relevant 
for <code>difforder</code> values greater than 1 and has only been implemented 
for <code>difforder</code> equal to 2.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_ngridangles">ngridangles</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. If <code>NULL</code> (the default), 
the optimal pair of angles for rotating the eigenvectors of the penalty 
matrix of a P-spline (<code>TPPS</code>) will be determined using a nonlinear 
optimizer (<code>nloptr::bobyqa</code>). Otherwise, its two values specify the 
numbers of angles between 0 and 90 degrees for each of the row and column 
dimensions to be used in determining the optimal pair of angles. Specifying 
factors of 90 will result in integer-valued angles. The number of grid 
points, and hence re-analyses will be the product of the values of 
(<code>ngridangles</code> + 1).</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_which.rotacriterion">which.rotacriterion</code></td>
<td>
<p>A single <code>character</code> string nominating which of the 
criteria, out of the <code>deviance</code>, the <code>likelihood</code>, the 
<code>AIC</code> and the <code>BIC</code>, is to be used in determining the optimal 
rotation of the eigenvectors of the penalty matrix. The <code>deviance</code> 
uses the REML value computed by <code>asreml</code>; the other criteria use 
the full likelihood, evaluated using the REML estimates, that is computed 
by <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_nrotacores">nrotacores</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of cores to deploy for 
running the analyses required to search the two-dimensional grid of rotation 
angles when <code>rotateX</code> is <code>TRUE</code>. Parallel processing has been 
implemented for analyzing, for each column angle, the set of angles to be 
investigated for the row dimension.  The default value of one means that 
parallel processing will not be used. The value chosen for <code>nrotacores</code> 
needs to balanced against the other processes that are using parallel 
processing at the same time.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_asreml.option">asreml.option</code></td>
<td>
<p>A single <code>character</code> string specifying whether the <code>grp</code> or 
<code>mbf</code> methods are to be used to supply externally formed covariate 
matrices to <code>asreml</code> when fitting a P-spline (<code>TPPS</code>). Compared 
to the <code>mbf</code> method, the <code>grp</code> method is somewhat faster, but 
creates large <code><a href="#topic+asrtests.object">asrtests.object</a></code>s for which the time it takes 
to save them can exceed any gains in execution speed. The <code>grp</code> 
method adds columns to the <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the <code>data</code>. 
On the other hand, the <code>mbf</code> method adds only the fixed covariates 
to <code>data</code> and stores the random covariates in the environment of the 
internal function that calls the spline-fitting function; there are three smaller 
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> for each <code>section</code> that are not stored in the 
<code>asreml.object</code> resulting from the fitted model.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_tpps4mbf.obj">tpps4mbf.obj</code></td>
<td>
<p>An object made with <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> 
that contains the spline basis information for fitting P-splines. 
The argument <code>tpps4mbf.obj</code> only needs to be set when the <code>mbf</code> 
option of <code>asreml.option</code> is being used and it is desired to use 
<code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> that have been created and stored 
prior to calling <code>addSpatialModel.asrtests</code>. If <code>tpps4mbf.obj</code> 
is <code>NULL</code>, <br />
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> will be called 
internally to produce the required <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asrtests.obj</code> is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead. Note that, for 
correlation models, the fitting of each dimension and the test for a nugget 
term are performed with <code>checkboundaryonly</code>  set to <code>TRUE</code> and its 
supplied setting only honoured using a call to <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code> 
immediately prior to returning the final result of the fitting.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, then <code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the 
model to be tested, using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code>, then <code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored 
variance parameter values as starting values when fitting the new model, 
the only modifications being (i) to add the terms for the spatial models 
and (ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_maxit">maxit</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the maximum number of iterations that 
<code>asreml</code> should perform in fitting a model.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated 
using REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_which.ic">which.IC</code></td>
<td>
<p>A <code>character</code> specifying the information criterion to be used in 
selecting the best model. Possible values are <code>AIC</code> and <code>BIC</code>. 
The value of the criterion for supplied model must exceed that for changed 
model for the changed model to be returned. (For choosing the rotation angle 
of the eigenvectors of the penalty matrix, see <code>which.rotacriterion</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModel.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code>asreml</code> and 
<code>tpsmmb</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model to which the spatial models is to be added is supplied in the <code>asrtests.obj</code>. It should not include terms that will be included in the local spatial model. All spatial model terms are fitted as fixed or random. Consequently, the residual model does not have to be iid. The improvement in the fit resulting from the addition of a spatial model to the supplied model is evaluated. Note that the data must be in the order that corresponds to the <code>residual</code> argument with a variable to the right of another variable changes levels in the data frame faster than those of the other variable e.g. <code>Row:Column</code> implies that all levels for <code>Column</code> in consecutive rows of the <code>data.frame</code> with a single <code>Row</code> level. 
</p>
<p>For the <code>corr</code> spatial model, the default model is an autocorrelation model of order one (<code>ar1</code>) for each dimension. However, any of the single dimension correlation/variance models from <code>asreml</code> can be specified for each dimension, as can no correlation model for a dimension; the models for the two dimensions can differ. Using a forward selection procedure, a series of models are tried, without removing boundary or singular terms, beginning with the addition of row correlation and followed by the addition of column correlation or, if the <code>row.corrFitfirst</code> is set to <code>FALSE</code>, the reverse order. If the fitting of the first-fitted correlation did not result in a model change because the fitting did not converge or correlations were fixed, but the fit of the second correlation was successful, then adding the first correlation will be retried. If one of the metric correlation functions is specified (e.g. <code>exp</code>), then the <code>row.covar</code> or <code>col.covar</code> will be used in the spatial model. However, because the correlations are fitted separately for the two dimensions, the <code>row.factor</code> and <code>col.factor</code> are needed for all models and is used for a dimension that does not involve a correlation/variance function for the fit being performed. Also, the correlation models are fitted as <code>random</code> terms and so the correlation model will include a variance parameter for the grid even when <code>ar1</code> is used to specify the correlation model, i.e. the model fitted is a variance model and there is no difference between <code>ar1</code> and <code>ar1v</code> in fitting the model. The variance parameter for this term represents the spatial variance and the fit necessarily includes a nugget term, this being the residual variance. If any correlation is retained in the model, for a section if <code>sections</code> is not <code>NULL</code>, then the need for a nugget term is assessed by fixing the corresponding residual variance to one, unless there are multiple residual variances and these are not related to the <code>sections</code>. Once the fitting of the correlation model has been completed, the <code>rmboundary</code> function will be executed with the <code>checkboundaryonly</code> value supplied in the <code>addSpatialModel.asrtests</code> call. Finally, checking for bound and singular random terms associated with the correlation model and residual terms will be carried out when there are correlation terms in the model and <code>checkboundaryonly</code> has been set to <code>FALSE</code>; as many as possible will be removed from the fitted model, in some cases by fixing variance terms to one.
</p>
<p>The tensor-product natural-cubic-smoothing-spline (<code>TPNCSS</code>) spatial models are as described by Verbyla et al. (2018). The tensor-product penalized-spline (<code>TPPS</code>) models are as described by (Piepho, Boer and Williams, 2022). For the <code>TPPS</code> model, the degree of the polynomial and the order of differencing can be varied. The defaults of 3 and 2, respectively, fit a cubic spline with second order differencing, which is similar to those of Rodriguez-Alvarez et al. (2018). Setting both the degree and order of differencing to 1 will fit a type of linear variance model. The fixed terms for the spline models are <code>row.covar + col.covar + row.covar:col.covar</code> and the random terms are <code>spl(row.covar) + spl(col.covar) + dev(row.covar) + dev(col.covar) + spl(row.covar):col.covar +</code><br /> <code>row.covar:spl(col.covar) + spl(row.covar):spl(col.covar)</code>, except that <code>spl(row.covar) + spl(col.covar)</code> is not included in <code>TPPS</code> models. The supplied model should not include any of these terms. However, any fixed or random main-effect Row or Column term that has been included as an initial model for comparison with a spatial model can be removed prior to fitting the spatial model using <code>dropFixed</code> or <code>dropRandom</code>.  For <code>TPPS</code> with second-order differencing, the model matrices used to fit the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> are transformed using the spectral decomposition of their penalty matrices, and unstructured variance models across the columns of the linear component of each of them will be tried.  For <code>TPPS</code> with second-order differencing, it is also possible to investigate the rotation of the penalty matrix eigenvectors for the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> (for more information see Piepho, Boer and Williams, 2022). The investigation takes the form of a search over a grid of rotation angles for a reduced model; the fit of the full model with rotation will be returned.
</p>
<p>The <code>TPPCS</code> and <code>TPP1LS</code> models are fitted using functions from the <code>R</code> package <code>TPSbits</code> authored by Sue Welham (2022). There are two methods for supplying the spline basis information produced by <code>tpsmmb</code> to <code>asreml</code>. The <code>grp</code> method adds it to the <code>data.frame</code> supplied in the <code>data</code> argument of the <code>asreml</code> call. The <code>mbf</code> method creates smaller <code><a href="base.html#topic+data.frame">data.frame</a>s</code> with the spline basis information in the same environment as the internal function that calls the spline-fitting function. If it is desired to use in a later session, an <code>asreml</code> function, or <code>asrtests</code> function that calls <code>asreml</code>, (e.g. <code>predict.asreml</code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, or <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>) on an <code>asreml.object</code> created using <code>mbf</code> terms, then the <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> will need to be recreated using <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> in the new session, supplying, if there has been rotation of the penalty matrix eigenvectors, the <code>theta</code> values that are returned as the attribute <code>theta.opt</code> of the <code>asreml.obj</code>. 
</p>
<p>All models utlize the function <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code> to fit the spatial model. Arguments from <code>tpsmmb</code> and <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code> can be supplied in calls to <code>addSpatialModel.asrtests</code> and will be passed on to the relevant function through the ellipses argument (...).
</p>
<p>The data for experiment can be divided <code>sections</code> and the same spatial model fitted separately to each. The fit over all of the sections is assessed. For more detail see <code>sections</code> above.
</p>
<p>Each combination of a row.coords and a col.coords does not have to specify a single observation; 
for example, to fit a local spatial model to the main units of a split-unit design, 
each combination would correspond to a main unit and all subunits of the main unit would 
have the same combination.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
possibly with attribute <code>theta.opt</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code> for the model that includes the 
spatial model, unless the spatial model fails to be fitted when <code>allow.unconverged</code> 
and/or <code>allow.fixedcorrelation</code> is set to <code>FALSE</code>. If the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> is the result of fitting a <code>TPPCS</code> model with 
an exploration of the rotation of the eigenvectors of the penalty matrix for the linear 
components, then the <code>asreml.obj</code> will have an attribute <code>theta.opt</code> that contains 
the optimal rotation angles of the eigenvectors.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H.-P., Boer, M. P., &amp; Williams, E. R. (2022). Two-dimensional P-spline smoothing for spatial analysis of plant breeding trials. <em>Biometrical Journal</em>, <b>64</b>, 835-857.
</p>
<p>Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., &amp; Eilers, P. H. C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. <em>Spatial Statistics</em>, <b>23</b>, 52-71. 
</p>
<p>Verbyla, A. P., De Faveri, J., Wilkie, J. D., &amp; Lewis, T. (2018). Tensor Cubic Smoothing Splines in Designed Experiments Requiring Residual Modelling. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, <b>23(4)</b>, 478-508.
</p>
<p>Welham, S. J. (2022) <code>TPSbits</code>: <em>Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R.</em> Version 1.0.0 <a href="https://mmade.org/tpsbits/">https://mmade.org/tpsbits/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, 
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code>, 
<code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code>, <br />
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>,  <br />
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>,  
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
<code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <br />
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Wheat.dat)

#Add row and column covariates
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn  - mean(unique(cColumn))
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                    })

#Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column,
                      data=Wheat.dat)

#Create an asrtests object, removing boundary terms
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL, 
                            label = "Random Row and Column effects")
current.asrt &lt;- rmboundary(current.asrt)

#Create an asrtests object with a P-spline spatial variation model 
spatial.asrt &lt;- addSpatialModel(current.asrt, spatial.model = "TPPS", 
                                row.covar = "cRow", col.covar = "cColumn",
                                dropRowterm = "Row", dropColterm = "Column",
                                asreml.option = "grp")
infoCriteria(current.asrt$asreml.obj)

#Create an asrtests object with a P-spline spatial variation model 
#that includes rotation of the eigenvectors of the penalty matrix
spatial.asrt &lt;- addSpatialModel(current.asrt, spatial.model = "TPPS", 
                                row.covar = "cRow", col.covar = "cColumn",
                                dropRowterm = "Row", dropColterm = "Column",
                                rotateX = TRUE, 
                                which.rotacriterion = "dev", 
                                nrotacores = parallel::detectCores(), 
                                asreml.option = "mbf")
infoCriteria(current.asrt$asreml.obj)

## End(Not run)</code></pre>

<hr>
<h2 id='addSpatialModelOnIC.asrtests'>Uses information criteria to decide whether to add a spatial model to account for local spatial variation.</h2><span id='topic+addSpatialModelOnIC.asrtests'></span><span id='topic+addSpatialModelOnIC'></span>

<h3>Description</h3>

<p>Adds either a correlation, two-dimensional tensor-product natural cubic 
smoothing spline (TPNCSS), or a two-dimensional tensor-product penalized P-spline 
model (TPPS) to account for the local spatial variation exhibited by a response variable 
measured on a potentially irregular grid of rows and columns of the units. The data may 
be arranged in sections for each of which there is a grid and for which the model is to 
be fitted separately. Also, the rows and columns of a grid are not necessarily one 
observational unit wide. The spatial model is only added if the information criterion of 
the supplied model is decreased with the addition of the local spatial model.  For 
<code>TPPS</code> models for which the order of differencing the penalty matrix is two, the 
improvement in the fit from rotating the eigenvectors of the penalty matrix can be 
investigated; if there is no improvement, the unrotated fit will be returned.
</p>
<p>A row is added for each <code>section</code> to the <code>test.summary</code> <code>data.frame</code> 
of the <code><a href="#topic+asrtests.object">asrtests.object</a></code> stating whether or not the new model has been 
swapped for a model in which the spatial model has been add to the  supplied model. 
Convergence and the occurrence of fixed correlations in fitting the 
model is checked and a note included in the <code>action</code> if there was not. 
All components of the <code><a href="#topic+asrtests.object">asrtests.object</a></code> are updated to exhibit the 
differences between the supplied and the new model, if a spatial model is added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
addSpatialModelOnIC(asrtests.obj, spatial.model = "TPPS", 
                    sections = NULL, 
                    row.covar = "cRow", col.covar = "cCol", 
                    row.factor = "Row", col.factor = "Col", 
                    corr.funcs = c("ar1", "ar1"), corr.orders = c(0, 0), 
                    row.corrFitfirst = TRUE, allow.corrsJointFit = TRUE, 
                    dropFixed = NULL, dropRandom = NULL, 
                    nsegs = NULL, nestorder = c(1,1), 
                    degree = c(3,3), difforder = c(2,2), 
                    usRandLinCoeffs = TRUE, 
                    rotateX = FALSE, ngridangles = NULL, 
                    which.rotacriterion = "AIC", nrotacores = 1, 
                    asreml.option = "grp", tpps4mbf.obj = NULL, 
                    allow.unconverged = FALSE, allow.fixedcorrelation = FALSE,
                    checkboundaryonly = FALSE, update = FALSE, 
                    maxit = 30, IClikelihood = "full", which.IC = "AIC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components 
(i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_spatial.model">spatial.model</code></td>
<td>
<p>A single <code>character</code> string nominating the type of spatial 
model to fit. Possible values are <code>corr</code>, <code>TPNCSS</code> and 
<code>TPPS</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_sections">sections</code></td>
<td>
<p>A single <code>character</code> string that specifies the name of the column 
in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the <code><a href="base.html#topic+factor">factor</a></code> 
that identifies different sections of the data to which separate spatial 
models are to be fitted. Note that, for other terms that involve 
<code>sections</code> in the random formula, there should be separate terms for 
each level of <code>sections</code>. For example, in a blocked experiment 
involving multiple sites, there should be the sum of separate terms for 
the Blocks at each Site i.e. a formula that contains terms like 
at(Site, i):Block for each site and these are separated by <code>'+'</code>. 
Otherwise, the combined term (e.g. Site:Block) will impact on the 
fitting of the local spatial models for the different Sites. Similarly, 
a separate residual variance for each of the <code>sections</code> should be 
fitted, unless there is a need to fit a different variance structure to 
the residual, e.g. heterogeneous residual variances depending on 
treatments. Separate residual variances for <code>sections</code> can be 
achieved using the <code>asreml</code> functions <code>dsum</code> or <code>idh</code>. 
Because, unlike random terms, terms for residual variances are not 
removed from the model, compound residual terms can be used to include 
them in the model, e.g. terms with <code>idh</code> or <code>dsum</code> with multiple
<code>levels</code> in the <code>list</code> or leaving <code>levels</code> out altogether. 
In addition to allowing the independent fitting of models to the 
<code>sections</code>, separate residual variance terms allows a nugget variance 
to be fitted in a correlation model for each of the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_row.covar">row.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the rows of a 
grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_col.covar">col.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the columns 
of a grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_row.factor">row.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the rows of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_col.factor">col.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the columns of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_corr.funcs">corr.funcs</code></td>
<td>
<p>A single <code>character</code> string of length two that specifies the 
<code>asreml</code> one-dimensional correlation or variance model function 
for the row and column dimensions of a two-dimensional separable spatial 
correlation model to be fitted when <code>spatial.model</code> is <code>corr</code>; 
the two-dimensional model is fitted as a random term. If a correlation 
or variance model is not to be investigated for one of the dimensions, 
specify <code>""</code> for that dimension. If the correlation model is  
<code>corb</code>, the values of <code>corr.orders</code> are used for its order 
argument (<code>b</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_corr.orders">corr.orders</code></td>
<td>
<p>A <code>numeric</code> of length two that specifies the order argument 
(<code>b</code>) values for the row and column dimensions of a two-dimensional 
separable spatial correlation model when <code>spatial.model</code> is 
<code>corr</code> and the <code>corr.funcs</code> for a dimension is <code>corb</code>, 
the <code>asreml</code> banded correlation model. If one of the dimensions 
does not involve an order argument, set the value of <code>corr.orders</code> 
for that dimension to zero. For a dimension for which the 
<code>corr.funcs</code> is <code>corb</code> and <code>corr.orders</code> is zero, a 
model with a single band, the correlation between immediate neighbours, 
will be fitted and then further bands, up to a maximum of 10 bands, will 
be added until the addition of an extra band does not reduce the 
information criterion nominated using <code>which.IC</code>. Note that the 
two-dimensional spatial model is fitted as a random term.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_row.corrfitfirst">row.corrFitfirst</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>. If <code>TRUE</code> then, in fitting the 
model for <code>spatial.model</code> set to <code>corr</code>, the row correlation  
or variance function is fitted first, followed by the addition of the 
column correlation or variance function. If <code>FALSE</code>, the order 
of fitting is reversed.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_allow.corrsjointfit">allow.corrsJointFit</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will allow 
the simultaneous fitting of correlation functions for the two dimensions 
of the grid when separate fits have failed to fit any correlation 
functions. This argument is available for when a joint fit 
hangs the system.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_dropfixed">dropFixed</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>". ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the fixed 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes these 
terms, will be compared with the fitted model that has had them removed and 
a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>wald.tab</code> component of the 
<code>asrtests.obj</code>. The fixed terms will be reordered so that 
single-variable terms come first, followed by two-variable terms and 
so on. Note also that multiple terms specified using a single 
<code>asreml::at</code> function can only be dropped as a whole. If the term 
was specified using an <code>asreml::at</code> function with a single level, 
then it can be removed and either the level itself or its 
<code><a href="base.html#topic+numeric">numeric</a></code> position in the levels returned by the 
<code><a href="base.html#topic+levels">levels</a></code> function can be specified.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_droprandom">dropRandom</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>" ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the random 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes 
these terms, will be compared with the fitted model that has had them removed 
and a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>. Note also that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_nsegs">nsegs</code></td>
<td>
<p>A pair of <code><a href="base.html#topic+numeric">numeric</a></code> values giving the number of segments into
which the column and row ranges are to be split, respectively, for fitting 
a P-spline model (<code>TPPS</code>) (each value specifies the number of internal 
knots + 1). If not specified, then (number of unique values - 1) is used 
in each dimension; for a grid layout with equal spacing, this gives a knot 
at each data value. If <code>sections</code> is not <code>NULL</code> and the grid 
differs between the <code>sections</code>, then <code>nsegs</code> will differ between 
the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_nestorder">nestorder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of nesting for column 
and row dimensions, respectively, in fitting a P-spline model (<code>TPPS</code>). 
A value of 1 specifies no nesting, a value of 2 generates a spline with 
half the number of segments in that 
dimension, etc. The number of segments in each direction must be a 
multiple of the order of nesting.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_degree">degree</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code>  of length 2. The degree of polynomial spline to 
be used for column and row dimensions respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_difforder">difforder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of differencing for 
column and row dimensions, respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_usrandlincoeffs">usRandLinCoeffs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will attempt to  
fit an unstructured variance model to the constant and linear terms in 
the interactions for constant and linear terms in one grid dimension 
interacting with smooth terms in the second grid dimension. The 
unstructured variance model can only be fitted if both the constant and 
linear interaction terms have been retained in the fitted model. 
This argument can be used to omit the attempt to fit an unstructured 
variance model when the attempt results in a system error.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_rotatex">rotateX</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to rotate the eigenvectors of the 
penalty matrix, as described by Piepho, Boer and Williams (2022), when 
fitting a P-spline (<code>TPPS</code>). Setting <code>rotateX</code> to <code>TRUE</code> 
results in a search for an optimized rotation under a model that omits 
the random spline interaction terms. If <code>ngridangles</code> is set to 
<code>NULL</code>, the optimal rotation us found using an optimizer 
(<code>nloptr::bobyqa</code>). Otherwise, the optimal rotation is found by 
exploring the fit over a  two-dimensional grid of rotation angle pairs. 
The optimization seeks to optimize the criterion nominated in 
<code>which.rotacriterion</code>. Rotation of the eigenvectors is only relevant 
for <code>difforder</code> values greater than 1 and has only been implemented 
for <code>difforder</code> equal to 2.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_ngridangles">ngridangles</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. If <code>NULL</code> (the default), 
the optimal pair of angles for rotating the eigenvectors of the penalty 
matrix of a P-spline (<code>TPPS</code>) will be determined using a nonlinear 
optimizer (<code>nloptr::bobyqa</code>). Otherwise, its two values specify the 
numbers of angles between 0 and 90 degrees for each of the row and column 
dimensions to be used in determining the optimal pair of angles. Specifying 
factors of 90 will result in integer-valued angles. The number of grid 
points, and hence re-analyses will be the product of the values of 
(<code>ngridangles</code> + 1).</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_which.rotacriterion">which.rotacriterion</code></td>
<td>
<p>A single <code>character</code> string nominating which of the 
criteria out of the <code>deviance</code>, the <code>likelihood</code>, the 
<code>AIC</code> and the <code>BIC</code> in determining the optimal rotation of the 
eigenvectors of the penalty matrix. The <code>deviance</code> uses the 
REML value computed by <code>asreml</code>; the other criteria use the 
full likelihood, evaluated using the REML estimates, that is computed 
by <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_nrotacores">nrotacores</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of cores to deploy for 
running the analyses required to search the two-dimensional grid of rotation 
angles when <code>rotateX</code> is <code>TRUE</code>. Parallel processing has been 
implemented for analyzing, for each column angle, the set of angles to be 
investigated for the row dimension.  The default value of one means that 
parallel processing will not be used. The value chosen for <code>nrotacores</code> 
needs to balanced against the other processes that are using parallel 
processing at the same time.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_asreml.option">asreml.option</code></td>
<td>
<p>A single <code>character</code> string specifying whether the <code>grp</code> or 
<code>mbf</code> methods are to be used to supply externally formed covariate 
matrices to <code>asreml</code> when fitting a P-spline (<code>TPPS</code>). Compared 
to the <code>mbf</code> method, the <code>grp</code> method is somewhat faster, but 
creates large <code><a href="#topic+asrtests.object">asrtests.object</a></code>s for which the time it takes 
to save them can exceed any gains in execution speed. The <code>grp</code> 
method adds columns to the <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the <code>data</code>. 
On the other hand, the <code>mbf</code> method adds only the fixed covariates 
to <code>data</code> and stores the random covariates in the environment of the 
internal function that calls the spline-fitting function; there are three smaller 
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> for each <code>section</code> that are not stored in the 
<code>asreml.object</code> resulting from the fitted model.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_tpps4mbf.obj">tpps4mbf.obj</code></td>
<td>
<p>An object made with <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> 
that contains the spline basis information for fitting P-splines. 
The argument <code>tpps4mbf.obj</code> only needs to be set when the <code>mbf</code> 
option of <code>asreml.option</code> is being used and it is desired to use 
<code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> that have been created and stored 
prior to calling <br /> 
<code>addSpatialModelOnIC.asrtests</code>. If <code>tpps4mbf.obj</code> 
is <code>NULL</code>, <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> will be called 
internally to produce the required <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asrtests.obj</code> is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead. Note that, for 
correlation models, the fitting of each dimension and the test for a nugget 
term are performed with <code>checkboundaryonly</code>  set to <code>TRUE</code> and its 
supplied setting only honoured using a call to <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code> 
immediately prior to returning the final result of the fitting.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, then <code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the 
model to be tested, using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code>, then <code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored 
variance parameter values as starting values when fitting the new model, 
the only modifications being (i) to add the terms for the spatial models 
and (ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_which.ic">which.IC</code></td>
<td>
<p>A <code>character</code> specifying the information criterion to be used in 
selecting the best model. Possible values are <code>AIC</code> and <code>BIC</code>. 
The value of the criterion for supplied model must exceed that for changed 
model for the changed model to be returned. (For choosing the rotation angle 
of the eigenvectors of the penalty matrix, see <code>which.rotacriterion</code>.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_maxit">maxit</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the maximum number of iterations that 
<code>asreml</code> should perform in fitting a model.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> specifying whether Restricted Maximum Likelihood 
(<code>REML</code>) or the full likelihood, evaluated using REML estimates, 
(<code>full</code>) are to be used in calculating the information criteria 
to be included in the <code>test.summary</code> of an 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> or to be used in choosing the best model.</p>
</td></tr>
<tr><td><code id="addSpatialModelOnIC.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code>asreml</code> and 
<code>tpsmmb</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fitted spatial model is only returned if it improves the fit over and above that of achieved with the model fit supplied in the <code>asrtests.obj</code>. To fit the spatial model without any hypotheses testing or comparison of information criteria use <code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>. The model fit supplied in the <code>asrtests.obj</code> should not include terms that will be included in the local spatial model. All spatial model terms are fitted as fixed or random. Consequently, the residual model does not have to be iid. Note that the data must be in the order that corresponds to the <code>residual</code> argument with a variable to the right of another variable changes levels in the data frame faster than those of the other variable e.g. <code>Row:Column</code> implies that all levels for <code>Column</code> in consecutive rows of the <code>data.frame</code> with a single <code>Row</code> level.
</p>
<p>For the <code>corr</code> spatial model, the default model is an autocorrelation model of order one (<code>ar1</code>) for each dimension. However, any of the single dimension correlation/variance models from <code>asreml</code> can be specified for each dimension, as can no correlation model for a dimension; the models for the two dimensions can differ. Using a forward selection procedure, a series of models are tried, without removing boundary or singular terms, beginning with the addition of row correlation and followed by the addition of column correlation or, if the <code>row.corrFitfirst</code> is set to <code>FALSE</code>, the reverse order. If the fitting of the first-fitted correlation did not result in a model change because the fitting did not converge or correlations were fixed, but the fit of the second correlation was successful, then adding the first correlation will be retried. If one of the metric correlation functions is specified (e.g. <code>exp</code>), then the <code>row.covar</code> or <code>col.covar</code> will be used in the spatial model. However, because the correlations are fitted separately for the two dimensions, the <code>row.factor</code> and <code>col.factor</code> are needed for all models and is used for a dimension that does not involve a correlation/variance function for the fit being performed. Also, the correlation models are fitted as <code>random</code> terms and so the correlation model will include a variance parameter for the grid even when <code>ar1</code> is used to specify the correlation model, i.e. the model fitted is a variance model and there is no difference between <code>ar1</code> and <code>ar1v</code> in fitting the model. The variance parameter for this term represents the spatial variance and the fit necessarily includes a nugget term, this being the residual variance. If any correlation is retained in the model, for a section if <code>sections</code> is not <code>NULL</code>, then the need for a nuggest term is assessed by fixing the corresponding residual variance to one, unless there are multiple residual variances and these are not related to the <code>sections</code>. Once the fitting of the correlation model has been completed, the <code>rmboundary</code> function will be executed with the <code>checkboundaryonly</code> value supplied in the <code>addSpatialModelOnIC.asrtests</code> call. Finally, checking for bound and singular random terms associated with the correlation model and residual terms will be carried out when there are correlation terms in the model and <code>checkboundaryonly</code> has been set to <code>FALSE</code>; as many as possible will be removed from the fitted model, in some cases by fixing variance terms to one.
</p>
<p>The tensor-product natural-cubic-smoothing-spline (<code>TPNCSS</code>) spatial models are as described by Verbyla et al. (2018). The tensor-product penalized-spline (<code>TPPS</code>) models are as described by (Piepho, Boer and Williams, 2022). For the <code>TPPS</code> model, the degree of the polynomial and the order of differencing can be varied. The defaults of 3 and 2, respectively, fit a cubic spline with second order differencing, which is similar to those of Rodriguez-Alvarez et al. (2018). Setting both the degree and order of differencing to 1 will fit a type of linear variance model. The fixed terms for the spline models are <code>row.covar + col.covar + row.covar:col.covar</code> and the random terms are <code>spl(row.covar) + spl(col.covar) + dev(row.covar) + dev(col.covar) + spl(row.covar):col.covar +</code><br /> <code>row.covar:spl(col.covar) + spl(row.covar):spl(col.covar)</code>, except that <code>spl(row.covar) + spl(col.covar)</code> is not included in <code>TPPS</code> models. The supplied model should not include any of these terms. However, any fixed or random main-effect Row or Column term that has been included as an initial model for comparison with a spatial model can be removed prior to fitting the spatial model using <code>dropFixed</code> or <code>dropRandom</code>.  For <code>TPPS</code> with second-order differencing, the model matrices used to fit the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> are transformed using the spectral decomposition of their penalty matrices, and unstructured variance models across the columns of the linear component of each of them will be tried. For <code>TPPS</code> with second-order differencing, it is also possible to investigate the rotation of the penalty matrix eigenvectors for the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> (for more information see Piepho, Boer and Williams, 2022). The investigation takes the form of a search over a grid of rotation angles for a reduced model; the fit of the full model with rotation using the optimal rotation angles will only be returned if it improves on the fit of the full, unrotated model. 
</p>
<p>The <code>TPPCS</code> and <code>TPP1LS</code> models are fitted using functions from the <code>R</code> package <code>TPSbits</code> authored by Sue Welham (2022). There are two methods for supplying the spline basis information produced by <code>tpsmmb</code> to <code>asreml</code>. The <code>grp</code> method adds it to the <code>data.frame</code> supplied in the <code>data</code> argument of the <code>asreml</code> call. The <code>mbf</code> method creates smaller <code><a href="base.html#topic+data.frame">data.frame</a>s</code> with the spline basis information in the same environment as the internal function that calls the spline-fitting function. If it is desired to use in a later session, an <code>asreml</code> function, or <code>asrtests</code> function that calls <code>asreml</code>, (e.g. <code>predict.asreml</code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, or <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>) on an <code>asreml.object</code> created using <code>mbf</code> terms, then the <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> will need to be recreated using <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> in the new session, supplying, if there has been rotation of the penalty matrix eigenvectors, the <code>theta</code> values that are returned as the attribute <code>theta.opt</code> of the <code>asreml.obj</code>. 
</p>
<p>All models utlize the function <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code> to assess the model fit, the information criteria used in assessing the fit being calculated using <code><a href="#topic+infoCriteria">infoCriteria</a></code>. Any <code>bound</code> terms are removed from the model. Arguments from <code>tpsmmb</code> and <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code> can be supplied in calls to <code>addSpatialModelOnIC.asrtests</code> and will be passed on to the relevant function through the ellipses argument (...).
</p>
<p>The data for experiment can be divided <code>sections</code> and the same spatial model fitted separately to each. The fit over all of the sections is assessed. For more detail see <code>sections</code> above.
</p>
<p>Each combination of a row.coords and a col.coords does not have to specify a single observation; 
for example, to fit a local spatial model to the main units of a split-unit design, 
each combination would correspond to a main unit and all subunits of the main unit would 
have the same combination.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
possibly with attribute <code>theta.opt</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code> for the model whose fit has 
the smallest information criterion between the supplied and spatial model. The values 
of the degrees of freedom and the information criteria in the <code>test.summary</code> are 
differences between those of the changed model and those of the model supplied to 
<code>addSpatialModelOnIC</code>. If the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> is the result of fitting a <code>TPPCS</code> model with 
an exploration of the rotation of the eigenvectors of the penalty matrix for the linear 
components, then the <code>asreml.obj</code> will have an attribute <code>theta.opt</code> that contains 
the optimal rotation angles of the eigenvectors.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H.-P., Boer, M. P., &amp; Williams, E. R. (2022). Two-dimensional P-spline smoothing for spatial analysis of plant breeding trials. <em>Biometrical Journal</em>, <b>64</b>, 835-857.
</p>
<p>Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., &amp; Eilers, P. H. C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. <em>Spatial Statistics</em>, <b>23</b>, 52-71. 
</p>
<p>Verbyla, A. P., De Faveri, J., Wilkie, J. D., &amp; Lewis, T. (2018). Tensor Cubic Smoothing Splines in Designed Experiments Requiring Residual Modelling. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, <b>23(4)</b>, 478-508.
</p>
<p>Welham, S. J. (2022) <code>TPSbits</code>: <em>Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R.</em> Version 1.0.0 <a href="https://mmade.org/tpsbits/">https://mmade.org/tpsbits/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, 
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code>, 
<code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>, <br />
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>,  <br />
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>,  
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
<code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <br />
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Wheat.dat)

#Add row and column covariates
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn  - mean(unique(cColumn))
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                    })

#Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column,
                      data=Wheat.dat)

#Create an asrtests object, removing boundary terms
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL, 
                            label = "Random Row and Column effects")
current.asrt &lt;- rmboundary(current.asrt)

current.asrt &lt;- addSpatialModelOnIC(current.asrt, spatial.model = "TPPS", 
                                    row.covar = "cRow", col.covar = "cColumn",
                                    dropRowterm = "Row", dropColterm = "Column",
                                    asreml.option = "grp")
infoCriteria(current.asrt$asreml.obj)

## End(Not run)</code></pre>

<hr>
<h2 id='addto.test.summary'>Adds a row to a <code>test.summary</code> <code>data.frame</code>.</h2><span id='topic+addto.test.summary'></span>

<h3>Description</h3>

<p>A row that summarizes the result of a proposed change to a model is added to a 
<code>test.summary</code> <code>data.frame</code>. Only the values of those arguments for which there 
are columns in <code>test.summary</code> will be included in the row.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addto.test.summary(test.summary, terms, DF = 1, denDF = NA, 
                          p = NA, AIC = NA, BIC = NA,
                          action = "Boundary")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addto.test.summary_+3A_test.summary">test.summary</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns are a subset of <code>terms</code>, 
<code>DF</code>, <code>denDF</code>, <code>p</code>, <code>AIC</code>, <code>BIC</code> and <code>action</code>. 
Each row summarizes the results of proposed changes to the fitted model. 
See <code><a href="#topic+asrtests.object">asrtests.object</a></code> for more information.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_terms">terms</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a term that might be added to or removed 
from the model or a label indicating a change that might be made to the model.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_df">DF</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the numerator degrees of freedom for a Wald F-statistic 
or the number of variance parameters in the current model minus the number 
in the proposed model.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_dendf">denDF</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the denominator degrees of freedom for a 
Wald F-statistic.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_p">p</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the p-value for a Wald F-statistic or REML ratio test.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_aic">AIC</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving Akiake Information Criterion (AIC) for a model or the 
difference between the AIC values for the current and proposed models.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_bic">BIC</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving Bayesian (Schwarz) Information Criterion for a model or the 
difference between the AIC values for the current and proposed models.</p>
</td></tr>
<tr><td><code id="addto.test.summary_+3A_action">action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving what action was taken with respect to the 
proposed change. See <code><a href="#topic+asrtests.object">asrtests.object</a></code> for more 
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+asrtests.object">asrtests.object</a></code>,  <code><a href="#topic+print.test.summary">print.test.summary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
data(Wheat.dat)

## Fit an autocorrelation model
ar1.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                  random = ~ Row + Column + units,
                  residual = ~ ar1(Row):ar1(Column), 
                  data=Wheat.dat)
ar1.asrt &lt;- as.asrtests(ar1.asr, NULL, NULL, 
                        label = "Autocorrelation model")
ar1.asrt &lt;- rmboundary.asrtests(ar1.asrt)

## Fit a tensor spline
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn - mean(unique(cColumn))
                    })
ts.asr &lt;- asreml(yield ~ Rep + cRow + cColumn + WithinColPairs + 
                         Variety, 
                  random = ~ spl(cRow) + spl(cColumn) + 
                             dev(cRow) + dev(cColumn) + 
                             spl(cRow):cColumn + cRow:spl(cColumn) + 
                             spl(cRow):spl(cColumn),
                  residual = ~ Row:Column, 
                  data=Wheat.dat)
ts.asrt &lt;- as.asrtests(ts.asr, NULL, NULL, 
                       label = "Tensor spline model")
ts.asrt &lt;- rmboundary.asrtests(ts.asrt)
ar1.ic &lt;- infoCriteria(ar1.asrt$asreml.obj)
ts.ic &lt;- infoCriteria(ts.asrt$asreml.obj)
if (ar1.ic$AIC &lt; ts.ic$AIC)
{
  ic.diff &lt;- ar1.ic - ts.ic
  new.asrt &lt;- ar1.asrt 
  new.asrt$test.summary &lt;- addto.test.summary(ar1.asrt$test.summary, 
                                              terms = "Compare ar1 to ts", 
                                              DF = ic.diff$varDF, 
                                              AIC = ic.diff$AIC, BIC = ic.diff$BIC, 
                                              action = "Chose ar1")
} else
{
  ic.diff &lt;- ts.ic - ar1.ic
  new.asrt &lt;- ts.asrt
  new.asrt$test.summary &lt;- addto.test.summary(ts.asrt$test.summary, 
                                              terms = "Compare ar1 to ts", 
                                              DF = ic.diff$varDF, 
                                              AIC = ic.diff$AIC, BIC = ic.diff$BIC, 
                                              action = "Chose ts")
}

## End(Not run)</code></pre>

<hr>
<h2 id='allDifferences.data.frame'>Using supplied predictions and standard errors of pairwise differences or the 
variance matrix of predictions, forms all pairwise differences between the 
set of predictions, and p-values for the differences.</h2><span id='topic+allDifferences.data.frame'></span><span id='topic+allDifferences'></span>

<h3>Description</h3>

<p>Uses supplied predictions and standard errors of pairwise differences, 
or the variance matrix of predictions to form, in an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, for those components not already present, 
(i) a table of all pairwise differences of the predictions, 
(ii) the p-value of each pairwise difference, and 
(iii) the minimum, mean, maximum and accuracy of LSD values. 
Predictions that are aliased (or inestimable) are removed from the 
<code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> and 
standard errors of differences involving them are removed from the <code>sed</code> 
component. 
</p>
<p>If necessary, the order of the columns of the variables in the <code>predictions</code> 
component are changed to be the initial columns of the <code><a href="#topic+predictions.frame">predictions.frame</a></code> 
and to match their order in the <code>classify</code>.  Also, the rows of <code>predictions</code> 
component are ordered so that they are in standard order for the variables in the 
<code>classify</code>. That is, the values of the last variable change with every row, 
those of the second-last variable only change after all the values of the last 
variable have been traversed; in general, the values of a variable are the same for 
all the combinations of the values to the variables to its right in the 
<code>classify</code>. The <code>sortFactor</code> or <code>sortOrder</code> arguments can be used 
to order of the values for the <code>classify</code> variables, which is achieved using 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>. 
</p>
<p>Each p-value is computed as the probability of a t-statistic as large as or larger 
than the absolute value of the observed difference divided by its standard error. The 
p-values are stored in the <code>p.differences</code> component. The degrees of freedom of 
the t-distribution is the degrees of freedom stored in the <code>tdf</code> attribute of 
the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. This t-distribution is also used in calculating 
the LSD statistics stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
allDifferences(predictions, classify, vcov = NULL, 
               differences = NULL, p.differences = NULL, sed = NULL, 
               LSD = NULL, LSDtype = "overall", LSDsupplied = NULL, 
               LSDby = NULL, LSDstatistic = "mean", 
               LSDaccuracy = "maxAbsDeviation", 
               retain.zeroLSDs = FALSE, 
               zero.tolerance = .Machine$double.eps ^ 0.5, 
               backtransforms = NULL, 
               response = NULL, response.title = NULL, 
               term = NULL, tdf = NULL,  
               x.num = NULL, x.fac = NULL,  
               level.length = NA, 
               pairwise = TRUE, alpha = 0.05,
               transform.power = 1, offset = 0, scale = 1, 
               transform.function = "identity", 
               inestimable.rm = TRUE,
               sortFactor = NULL, sortParallelToCombo = NULL, 
               sortNestingFactor = NULL, sortOrder = NULL, 
               decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allDifferences.data.frame_+3A_predictions">predictions</code></td>
<td>
<p>A <code><a href="#topic+predictions.frame">predictions.frame</a></code>, or a <code>data.frame</code>, beginning 
with the variables classifying the predictions and also containing columns 
named <code>predicted.value</code>, <code>standard.error</code> and <code>est.status</code>; 
each row contains a single predicted value. It may also contain columns 
for the lower and upper limits of error intervals for the predictions.
Note that the names <code>standard.error</code> and 
<code>est.status</code> have been changed to <code>std.error</code> and <code>status</code> 
in the <code>pvals</code> component produced by <code>asreml-R4</code>; if the new names 
are in the <code>data.frame</code> supplied to <code>predictions</code>, they will be 
returned to the previous names. </p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_classify">classify</code></td>
<td>
<p>A <code>character</code> string giving the variables that define the margins 
of the multiway table that has been predicted. Multiway tables are 
specified by forming an interaction type term from the 
classifying variables, that is, separating the variable names 
with the <code>:</code> operator.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_vcov">vcov</code></td>
<td>
<p>A <code>matrix</code> containing the variance matrix of the predictions; it is used in 
computing the variance of linear transformations of the predictions.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_differences">differences</code></td>
<td>
<p>A <code>matrix</code> containing all pairwise differences between
the predictions; it should have the same number of rows and columns as there are
rows in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_p.differences">p.differences</code></td>
<td>
<p>A <code>matrix</code> containing p-values for all pairwise differences 
between the predictions; each p-value is computed as the probability of a t-statistic 
as large as or larger than the observed difference divided by its standard error. 
The degrees of freedom of the t distribution for computing it are computed as 
the denominator degrees of freedom of the F value for the fixed term, if available; 
otherwise, the degrees of freedom stored in the attribute <code>tdf</code> are used; 
the matrix should be of the same size as that for <code>differences</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_sed">sed</code></td>
<td>
<p>A <code>matrix</code> containing the standard errors of all pairwise differences 
between the predictions; they are used in computing the p-values.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsd">LSD</code></td>
<td>
<p>An <code><a href="#topic+LSD.frame">LSD.frame</a></code> containing the mean, minimum and maximum LSD for determining             
the significance of pairwise differences, as well as an assigned LSD and a measure 
of the accuracy of the LSD. If <code>LSD</code> is <code>NULL</code> then the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component will be calculated and 
the values of <code>LSDtype</code>, <code>LSDby</code> and <code>LSDstatistic</code> added as attributes 
of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The LSD for a single prediction 
assumes that any predictions to be compared are independent; this is not the case if 
residual errors are correlated.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_retain.zerolsds">retain.zeroLSDs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to retain or omit LSDs that are zero when 
calculating the summaries of LSDs.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_zero.tolerance">zero.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value such that if an LSD is less than it, the LSD will be 
considered to be zero.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_backtransforms">backtransforms</code></td>
<td>
<p>A <code>data.frame</code> containing the backtransformed values of the predicted 
values  that is consistent with the <code>predictions</code> component, except 
that the column named <code>predicted.value</code> is replaced by one called 
<code>backtransformed.predictions</code>. Any <code>error.interval</code> values will also 
be the backtransformed values. Each row contains a single predicted value.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable for the 
predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_response.title">response.title</code></td>
<td>
<p>A <code>character</code> specifying the title for the response variable 
for the predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_term">term</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that define the term 
that was fitted using <code>asreml</code> and that corresponds to <code>classify</code>. 
It only needs to be specified when it is different to <code>classify</code>; it 
is stored as an attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
It is likely to be needed when the fitted model includes terms that involve  
both a <code><a href="base.html#topic+numeric">numeric</a></code> covariate and a <code><a href="base.html#topic+factor">factor</a></code> that 
parallel each other; the <code>classify</code> would include the covariate and 
the <code>term</code> would include the <code>factor</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_tdf">tdf</code></td>
<td>
<p>an <code>integer</code> specifying the degrees of freedom of the standard error. It is used as 
the degrees of freedom for the t-distribution on which p-values and confidence 
intervals are based. 
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_x.num">x.num</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the numeric covariate that 
(i) is potentially included in terms in the fitted model and (ii) is the 
x-axis variable for plots. Its values will not be converted to a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_x.fac">x.fac</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor that 
(i) corresponds to <code>x.num</code> and (ii) is potentially included in 
terms in the fitted model. It should have the same number of levels as the 
number of unique values in <code>x.num</code>. The levels of 
<code>x.fac</code> must be in the order in which they are to be plotted 
- if they are dates, then they should be in the form 
yyyymmdd, which can be achieved using <code>as.Date</code>. However, the levels
can be non-numeric in nature, provided that <code>x.num</code> is also set.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_level.length">level.length</code></td>
<td>
<p>The maximum number of characters from the levels of 
factors to use in the row and column labels of the tables of 
pairwise differences and their p-values and standard errors.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_pairwise">pairwise</code></td>
<td>
<p>A logical indicating whether all pairwise differences of the
<code>predictions</code> and their standard errors and p-values are to be 
computed and stored. If <code>FALSE</code>, the components <code>differences</code> 
and <code>p.differences</code> will be <code>NULL</code> in the returned 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_transform.power">transform.power</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the power of a transformation, if 
one has been applied to the response variable. Unless it is equal 
to 1, the default, back-transforms of the predictions will be 
obtained and presented in tables or graphs as appropriate. 
The back-transformation raises the predictions to the power equal 
to the reciprocal of <code>transform.power</code>, unless it equals 0 in 
which case the exponential of the predictions is taken.</p>
</td></tr> 
<tr><td><code id="allDifferences.data.frame_+3A_offset">offset</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that has been added to each value of the 
response after any scaling and before applying any power transformation.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_scale">scale</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> by which each value of the response has been multiplied 
before adding any offset and applying any power transformation.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_transform.function">transform.function</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a function that 
specifies the scale on which the predicted values are defined. This may be the 
result of a transformation of the data using the function or the use of the 
function as a link function in the fitting of a generalized linear (mixed) 
model (GL(M)M). The possible <code>transform.function</code>s are 
<code>identity</code>, <code>log</code>, <code>inverse</code>, <code>sqrt</code>, <code>logit</code>, 
<code>probit</code>, and <code>cloglog</code>.  The <code>predicted.values</code> and 
<code>error.intervals</code>, if not <code>StandardError</code> intervals, will be 
back-transformed using the inverse function of the <code>transform.function</code>. 
The <code>standard.error</code> column will be set to <code>NA</code>, unless (i) 
<code>asreml</code> returns columns named <code>transformed.value</code> and 
<code>approx.se</code>, as well as those called <code>predicted.values</code> and 
<code>standard.error</code> (such as when a GLM is fitted) and 
(ii) the values in <code>transformed.value</code> are equal to those obtained by 
backtransforming the <code>predicted.value</code>s using the inverse function 
of the <code>transform.function</code>. Then, the <code>approx.se</code> values will be 
saved in the <code>standard.error</code> column of the <code>backtransforms</code> 
component of the returned <code>alldiffs.obj</code>. Also, the 
<code>transformed.value</code> and <code>approx.se</code> columns are removed from both 
the <code>predictions</code> and <code>backtransforms</code> components of the 
<code>alldiffs.obj</code>. Note that the values that end up in the <code>standard errors</code> 
column are approximate for the backtransformed values and are not used in 
calculating <code>error.intervals</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_inestimable.rm">inestimable.rm</code></td>
<td>
<p>A <code>logical</code> indicating whether rows for  predictions that 
are not estimable are to be removed from the components of the
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>:  <br />
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
is for increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="allDifferences.data.frame_+3A_...">...</code></td>
<td>
<p>provision for passsing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with components 
<code>predictions</code>, <code>vcov</code>, <code>differences</code>, <code>p.differences</code> 
<code>sed</code>, and <code>LSD</code>. 
</p>
<p>The name of the <code>response</code>, the <code>response.title</code>, 
the <code>term</code>, the <code>classify</code>, <code>tdf</code>, <code>alpha</code>, <code>sortFactor</code> 
and the <code>sortOrder</code> will be set as attributes to the object. 
Note that the <code>classify</code> in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is based on the 
variables indexing the predictions, which may differ from the 
<code>classify</code> used to obtain the original predictions (for example, 
when the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>s stores a linear transformation of predictions.
</p>
<p>Also, see <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code> for more information.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>,  <code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code>, 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>,  <br /> 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>,  <code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>,  
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <br />
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, 
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <br /> 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- Var.pred$pvals
  Var.sed &lt;- Var.pred$sed
  Var.vcov &lt;- NULL
  wald.tab &lt;-  current.asrt$wald.tab
  den.df &lt;- wald.tab[match("Variety", rownames(wald.tab)), "denDF"]
  
## End(Not run)

  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    den.df &lt;- min(Var.preds$df)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL
  }

  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("Var.preds"))
  {
    ## Order the Varieties in decreasing order for the predictions values in the 
    ## first N level 
    Var.diffs &lt;- allDifferences(predictions = Var.preds, 
                                classify = "Nitrogen:Variety", 
                                sed = Var.sed, vcov = Var.vcov, tdf = den.df,
                                sortFactor = "Variety", decreasing = TRUE)
    print.alldiffs(Var.diffs, which="differences")
  
    ## Change the order of the factors in the alldiffs object and reorder components
    Var.reord.diffs &lt;- allDifferences(predictions = Var.preds,
                                classify = "Variety:Nitrogen", 
                                sed = Var.sed, vcov = Var.vcov, tdf = den.df)
    print.alldiffs(Var.reord.diffs, which="predictions")
  }
</code></pre>

<hr>
<h2 id='alldiffs.object'>Description of an alldiffs object</h2><span id='topic+alldiffs.object'></span><span id='topic+alldiffs-class'></span>

<h3>Description</h3>

<p>An object of S3-class <code>alldiffs</code> that stores the predictions for a model, 
along with supplied statistics for all pairwise differences. While 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> can be constructed by defining a <code>list</code> with 
the appropriate components, it can be formed by passing the components to 
<code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, or from a <code>predictions</code> <code>data.frame</code> using 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>.
</p>
<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code> is function that assembles an object of this class from 
supplied components.
</p>
<p><code><a href="#topic+is.alldiffs">is.alldiffs</a></code> is the membership function for this class; it tests 
that an object is of class <code>alldiffs</code>.
</p>
<p><code><a href="#topic+validAlldiffs">validAlldiffs</a>(object)</code> can be used to test the validity of an object 
with this class. 
</p>
<p><code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code> is the function that constructs an 
object of this class by calculating components from statistics supplied via 
its arguments and then using <code><a href="#topic+as.alldiffs">as.alldiffs</a></code> to make the object.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>alldiffs</code> containing the following components: 
<code>predictions</code>, <code>vcov</code>, <code>differences</code>, 
<code>p.differences</code>, <code>sed</code>, <code>LSD</code> and <code>backtransforms</code>. 
Except for <code>predictions</code>, the components are optional and can be set 
to <code>NULL</code>. 
</p>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> also has attributes <code>response</code>, 
<code>response.title</code>, <code>term</code>, <code>classify</code>, <code>tdf</code>, <code>alpha</code>, 
<code>sortFactor</code> and <code>sortOrder</code>, which may be set to <code>NULL</code>.
</p>
<p>The details of the components are as follows:
</p>

<ol>
<li> <p><code>predictions</code>: A <code><a href="#topic+predictions.frame">predictions.frame</a></code>, being a <code>data.frame</code> 
beginning with the variables classifying the predictions, in the same order 
as in the <code>classify</code>, and also containing columns named 
<code>predicted.value</code>, <code>standard.error</code> and <code>est.status</code>; 
each row contains a single predicted value. The number of rows should equal the 
number of unique combinations of the <code>classify</code> variables and will be in 
standard order for the <code>classify</code> variables. That is, the values of the 
last variable change with every row, those of the second-last variable only 
change after all the values of the last variable have been traversed; 
in general, the values of a variable are the same for all the 
combinations of the values to the variables to its right in the <code>classify</code>.
</p>
<p>The <code>data.frame</code> may also include columns for the lower and upper 
values of error intervals, either standard error, confidence or half-LSD 
intervals.  The names of these columns will consist of three parts 
separated by full stops: 
1) the first part will be <code>lower</code> or <code>upper</code>; 
2) the second part will be one of <code>Confidence</code>, 
<code>StandardError</code> or <code>halfLeastSignificant</code>; 
3) the third component will be <code>limits</code>.
</p>
<p>Note that the names <code>standard.error</code> and 
<code>est.status</code> have been changed to <code>std.error</code> and <code>status</code> 
in the <code>pvals</code> component produced by <code>asreml-R4</code>; if the new names 
are in the <code>data.frame</code> supplied to <code>predictions</code>, they will be 
returned to the previous names. 
</p>
</li>
<li> <p><code>differences</code>: A <code>matrix</code> containing all pairwise differences between
the predictions; it should have the same number of rows and columns as there are
rows in <code>predictions</code>.
</p>
</li>
<li> <p><code>p.differences</code>: A <code>matrix</code> containing p-values for all pairwise differences 
between the predictions; each p-value is computed as the probability of a t-statistic 
as large as or larger than the observed difference divided by its standard error. 
The degrees of freedom of the t distribution for computing it are computed as 
the denominator degrees of freedom of the F value for the fixed term, if available; 
otherwise, the degrees of freedom stored in the attribute <code>tdf</code> are used; 
the matrix should be of the same size as that for <code>differences</code>.
</p>
</li>
<li> <p><code>sed</code>: A <code>matrix</code> containing the standard errors of all pairwise differences 
between the predictions; they are used in computing the p-values in <code>p.differences</code>.
</p>
</li>
<li> <p><code>vcov</code>: A <code>matrix</code> containing the variance matrix of the predictions; it is 
used in computing the variance of linear transformations of the predictions.
</p>
</li>
<li> <p><code>LSD</code>: An <code><a href="#topic+LSD.frame">LSD.frame</a></code> containing (i) <code>c</code>, the number of pairwise 
predictions comparisons for each LSD value and the mean, minimum, maximum and assigned LSD, 
(ii) the column <code>accuracyLSD</code> that gives a measure of the accuracy of the 
assigned LSD. given the variation in LSD values, and (iii) the columns <code>false.pos</code> and 
<code>false.neg</code> that contain the number of false positives and negatives if the 
<code>assignedLSD</code> value(s) is(are) used to determine the significance of the 
pairwise predictions differences. The LSD values in the <code>assignedLSD</code> 
column is used to determine the significance of pairwise differences that involve 
predictions for the combination of levels given by a row name. The value in the 
<code>assignedLSD</code> column is specified using the <code>LSDstatistic</code> argument. 
</p>
</li>
<li> <p><code>backtransforms</code>: When the response values have been transformed for analysis, 
a <code>data.frame</code> containing the backtransformed values of the 
predicted values is added to the <code>alldiffs.object</code>. This <code>data.frame</code> 
is consistent with the <code>predictions</code> component, except 
that the column named <code>predicted.value</code> is replaced by one called 
<code>backtransformed.predictions</code>. Any <code>error.interval</code> values will also 
be the backtransformed values. Each row contains a single predicted value.
</p>
</li></ol>

<p>The details of the <code>attributes</code> of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> are:
</p>

<ol>
<li> <p><code>response</code>: A <code>character</code> specifying the response variable for the 
predictions.
</p>
</li>
<li> <p><code>response.title</code>: A <code>character</code> specifying the title for the response variable 
for the predictions.
</p>
</li>
<li> <p><code>term</code>: A <code>character</code> giving the variables that define the term 
that was fitted using <code>asreml</code> and that corresponds 
to <code>classify</code>. It is often the same as <code>classify</code>.
</p>
</li>
<li> <p><code>classify</code>: A <code>character</code> giving the variables that define the margins
of the multiway table used in the prediction. Multiway tables are 
specified by forming an interaction type term from the 
classifying variables, that is, separating the variable names 
with the <code>:</code> operator.
</p>
</li>
<li> <p><code>tdf</code>: An <code>integer</code> specifying the degrees of freedom of the standard error. It is used as 
the degrees of freedom for the t-distribution on which p-values and confidence 
intervals are based.
</p>
</li>
<li> <p><code>alpha</code>: An <code>integer</code> specifying the significance level. It is used as 
the significance level calculating LSDs.
</p>
</li>
<li> <p><code>LSDtype</code>: If the <code>LSD</code> component is not <code>NULL</code> then <code>LSDtype</code> is 
added as an attribute. A <code>character</code> nominating the type of grouping of seds to be used 
in combining LSDs.
</p>
</li>
<li> <p><code>LSDby</code>: If the <code>LSD</code> component is not <code>NULL</code> then <code>LSDby</code> is added 
as an attribute. A <code>character</code> <code>vector</code> containing the names of the factors and numerics 
within whose combinations the LSDs are to be summarized.
</p>
</li>
<li> <p><code>LSDstatistic</code>: If the <code>LSD</code> component is not <code>NULL</code> then <code>LSDstatistic</code> is 
added as an attribute. A <code>character</code> nominating what statistic to use in summarizing a  
set of LSDs.
</p>
</li>
<li> <p><code>LSDaccuracy</code>: If the <code>LSD</code> component is not <code>NULL</code> then <code>LSDaccuracy</code> is 
added as an attribute. A <code>character</code> nominating the method of calculating a measure of 
the accuracy of the LSDs stored in the <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code>.
</p>
</li>
<li> <p><code>sortFactor</code>: <code>factor</code> that indexes the set of predicted values that 
determined the sorting of the components.
</p>
</li>
<li> <p><code>sortOrder</code>: A <code>character</code> vector that is the same length as the number of levels for 
<code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
</li></ol>

<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: <br />
<code>levs &lt;- levels(f)[order(x)]</code>.
</p>
<p>See <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code> for more information.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.alldiffs">is.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+validAlldiffs">validAlldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)

  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- Var.pred$pvals
  Var.sed &lt;- Var.pred$sed
  Var.vcov &lt;- NULL
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    den.df &lt;- min(Var.preds$df)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL
  }

  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("Var.preds"))
  {
    ## Form an all.diffs object
     Var.diffs &lt;- as.alldiffs(predictions = Var.preds, classify = "Nitrogen:Variety", 
                              sed = Var.sed, vcov = Var.vcov, tdf = den.df)

    ## Check the class and validity of the alldiffs object
    is.alldiffs(Var.diffs)
    validAlldiffs(Var.diffs)
  }
</code></pre>

<hr>
<h2 id='angular'>Applies the angular transformation to proportions.</h2><span id='topic+angular'></span>

<h3>Description</h3>

<p>Applies the angular transformation to numeric values.
It is given by <code class="reqn">\sin^{-1}(\sqrt{proportions})</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>angular(proportions, n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angular_+3A_proportions">proportions</code></td>
<td>
<p>The proportions.</p>
</td></tr>
<tr><td><code id="angular_+3A_n">n</code></td>
<td>
<p>The divisor(s) for each proportion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+angular.mod">angular.mod</a></code>, <code><a href="#topic+powerTransform">powerTransform</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;-25
y &lt;- rbinom(10, n, 0.5)
y &lt;- c(y,0,n)
p &lt;- y/n
p.ang &lt;- angular(p, n)
</code></pre>

<hr>
<h2 id='angular.mod'>Applies the modified angular transformation to a vector of counts.</h2><span id='topic+angular.mod'></span>

<h3>Description</h3>

<p>Applies the angular transformation to a vector of counts. A 
modified transformation is used that is appropriate when N &lt; 50 and the 
proportion is not between 0.3 and 0.7. The transformation is given by 
<code class="reqn">\sin^{-1}{\frac{count + 0.375}{n + 0.75}}</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular.mod(count, n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angular.mod_+3A_count">count</code></td>
<td>
<p>The numeric vector of counts.</p>
</td></tr>
<tr><td><code id="angular.mod_+3A_n">n</code></td>
<td>
<p>The number(s) of observations from which the count(s) were obtained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+angular">angular</a></code>, <code><a href="#topic+powerTransform">powerTransform</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;-25
y &lt;- rbinom(10, n, 0.5)
y &lt;- c(y,0,n)
p.ang.mod &lt;- angular.mod(y, n)
</code></pre>

<hr>
<h2 id='as.alldiffs'>Forms an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> from the supplied predictions, along with those statistics, 
associated with the predictions and their pairwise differences, that have been supplied.</h2><span id='topic+as.alldiffs'></span>

<h3>Description</h3>

<p>Creates an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> that consists of a <code>list</code> 
containing the following components: <code>predictions</code>, <code>vcov</code>, <code>differences</code>, 
<code>p.differences</code>, <code>sed</code>, <code>LSD</code> and <code>backtransforms</code>. 
Predictions must be supplied to the function while the others will be set 
only if they are supplied; those not supplied are set to <code>NULL</code>. 
It also has attributes <code>response</code>, <code>response.title</code>, <code>term</code>, 
<code>classify</code>, <code>tdf</code>, <code>tdf</code>, <code>alpha</code>, <code>sortFactor</code> and <code>sortOrder</code>.
which will be set to the values supplied or <code>NULL</code> if none are supplied.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.alldiffs(predictions, vcov = NULL, differences = NULL, 
            p.differences = NULL, sed = NULL, LSD = NULL, 
            backtransforms = NULL, 
            response = NULL, response.title = NULL, 
            term = NULL, classify = NULL, 
            tdf = NULL, alpha = 0.05, 
            sortFactor = NULL, sortOrder = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.alldiffs_+3A_predictions">predictions</code></td>
<td>
<p>A <code><a href="#topic+predictions.frame">predictions.frame</a></code>, being a <code>data.frame</code> beginning 
with the variables classifying the predictions and also containing columns 
named <code>predicted.value</code>, <code>standard.error</code> and <code>est.status</code>; 
each row contains a single predicted value. It may also contain columns 
for the lower and upper limits of error intervals for the predictions.
Note that the names <code>standard.error</code> and 
<code>est.status</code> have been changed to <code>std.error</code> and <code>status</code> 
in the <code>pvals</code> component produced by <code>asreml-R4</code>; if the new names 
are in the <code>data.frame</code> supplied to <code>predictions</code>, they will be 
returned to the previous names.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_differences">differences</code></td>
<td>
<p>A <code>matrix</code> containing all pairwise differences between
the predictions; it should have the same number of rows and columns as there are
rows in <code>predictions</code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_p.differences">p.differences</code></td>
<td>
<p>A <code>matrix</code> containing p-values for all pairwise differences 
between the predictions; each p-value is computed as the probability of a t-statistic 
as large as or larger than the observed difference divided by its standard error. 
The degrees of freedom of the t distribution for computing it are computed as 
the denominator degrees of freedom of the F value for the fixed term, if available; 
otherwise, the degrees of freedom stored in the attribute <code>tdf</code> are used; 
the matrix should be of the same size as that for <code>differences</code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_sed">sed</code></td>
<td>
<p>A <code>matrix</code> containing the standard errors of all pairwise differences 
between the predictions; they are used in computing the p-values.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_vcov">vcov</code></td>
<td>
<p>A <code>matrix</code> containing the variance matrix of the predictions; it is used in 
computing the variance of linear transformations of the predictions.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_lsd">LSD</code></td>
<td>
<p>An <code><a href="#topic+LSD.frame">LSD.frame</a></code> containing the mean, minimum and maximum LSD for determining             
the significance of pairwise differences, as well as an assigned LSD and a measure 
of the accuracy of the LSD. If <code>LSD</code> is <code>NULL</code> then the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component will be calculated and 
the values of <code>LSDtype</code>, <code>LSDby</code> and <code>LSDstatistic</code> added as attributes 
of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The LSD for a single prediction 
assumes that any predictions to be compared are independent; this is not the case if 
residual errors are correlated.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_backtransforms">backtransforms</code></td>
<td>
<p>A <code>data.frame</code> containing the backtransformed values of the predicted 
values  that is consistent with the <code>predictions</code> component, except 
that the column named <code>predicted.value</code> is replaced by one called 
<code>backtransformed.predictions</code>. Any <code>error.interval</code> values will also 
be the backtransformed values. Each row contains a single predicted value.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable for the 
predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_response.title">response.title</code></td>
<td>
<p>A <code>character</code> specifying the title for the response variable 
for the predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_term">term</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that define the term 
that was fitted using <code>asreml</code> and that corresponds to <code>classify</code>. 
It only needs to be specified when it is different to <code>classify</code>; it 
is stored as an attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
It is likely to be needed when the fitted model includes terms that involve  
both a <code><a href="base.html#topic+numeric">numeric</a></code> covariate and a <code><a href="base.html#topic+factor">factor</a></code> that 
parallel each other; the <code>classify</code> would include the covariate and 
the <code>term</code> would include the <code>factor</code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_classify">classify</code></td>
<td>
<p>A character string giving the variables that define the margins
of the multiway table used in the prediction. Multiway tables are 
specified by forming an interaction type term from the 
classifying variables, that is, separating the variable names 
with the <code>:</code> operator. It is stored as an attribute to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_tdf">tdf</code></td>
<td>
<p>an <code>integer</code> specifying the degrees of freedom of the standard error. It is used as 
the degrees of freedom for the t-distribution on which p-values and confidence 
intervals are based. 
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code>character</code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that 
determined the sorting of the components.</p>
</td></tr>
<tr><td><code id="as.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character</code> vector that is the same length as the number of levels for 
<code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3-class <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. Also, see <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code> for 
more information.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>,  <code><a href="#topic+is.alldiffs">is.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <br />
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <br />
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>, <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <br />
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>,  <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- Var.pred$pvals
  Var.sed &lt;- Var.pred$sed
  Var.vcov &lt;- NULL
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    den.df &lt;- min(Var.preds$df)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL
  }

  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("Var.preds"))
  {
    ## Form an all.diffs object
     Var.diffs &lt;- as.alldiffs(predictions = Var.preds, classify = "Nitrogen:Variety", 
                              sed = Var.sed, vcov = Var.vcov, tdf = den.df)

    ## Check the class and validity of the alldiffs object
    is.alldiffs(Var.diffs)
    validAlldiffs(Var.diffs)
  }
</code></pre>

<hr>
<h2 id='as.asrtests'>Forms an asrtests object that stores (i) a fitted asreml object, 
(ii) a pseudo-anova table for the fixed terms and (iii) a history of 
changes and hypothesis testing used in obtaining the model.</h2><span id='topic+as.asrtests'></span>

<h3>Description</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> that is a <code>list</code> consisting of 
the components <code>asreml.obj</code>, <code>wald.tab</code> and <code>test.summary</code>.
</p>
<p>A call to <code>as.asrtests</code> with <code>test.summary = NULL</code> re-initializes the 
<code>test.summary</code> <br /> <code>data.frame</code>.
</p>
<p>If there is no <code>wald.tab</code>, <code>wald.asreml</code> is called. In all cases, 
<code><a href="#topic+recalcWaldTab">recalcWaldTab</a></code> is called and any changes made as specified by the 
<code><a href="#topic+recalcWaldTab">recalcWaldTab</a></code> arguments supplied via <code>...</code>.
</p>
<p>The <code>label</code> argument can be used to include an entry in <code>test.summary</code> 
for the starting model. If a <code>label</code> is included, (i) the information criteria 
calculated using the <code>asreml.obj</code> will be added to the <code>test.summary</code>, if
<code>IClikelihood</code> is not set to <code>none</code> and (ii) the number of variance 
parameters is included in the denDF column, if <code>IClikelihood</code> is set to <code>none</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.asrtests(asreml.obj, wald.tab = NULL, test.summary = NULL, 
            denDF = "numeric", label = NULL, 
            IClikelihood = "none", bound.exclusions = c("F","B","S","C"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.asrtests_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>an <code>asreml</code> object for a fitted model.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_wald.tab">wald.tab</code></td>
<td>
<p>A <code>data.frame</code> containing a pseudo-anova table for 
the fixed terms produced by <code>wald.asreml</code>; it should have 4 or 6 columns.
Sometimes <code>wald.asreml</code> returns a <code>data.frame</code> and at other 
times a <code>list</code>. For example, it may return a <code>list</code> when 
<code>denDF</code> is used. In this case, the <code>Wald</code> component of the 
<code>list</code> is to be extracted and stored. It is noted that, 
as of asreml version 4, <code>wald.asreml</code> has a <code>kenadj</code> argument.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_test.summary">test.summary</code></td>
<td>
<p>A <code>data.frame</code> with columns <code>term</code>, 
<code>DF</code>, <code>denDF</code>, <code>p</code> and <code>action</code> containing the 
results of previous hypothesis tests.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_label">label</code></td>
<td>
<p>A <code>character</code> to use as an entry in the <code>terms</code> column in 
<code>test.summary</code> to indicate as far as is possible the nature of the 
model that has been fitted. The <code>action</code> column in <code>test.summary</code> 
will be <code>Starting model</code>.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated 
using REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying the bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in calculating information criteria. 
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="as.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>wald.asreml</code> and
<code><a href="#topic+recalcWaldTab">recalcWaldTab</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3-class <code>asrtests</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+is.alldiffs">is.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, 
<code><a href="#topic+recalcWaldTab">recalcWaldTab</a></code>, <br />
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>,  
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, <br />
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)

# Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)

# Load current fit into an asrtests object
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

# Check for and remove any boundary terms
current.asrt &lt;- rmboundary(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='as.predictions.frame'>Forms a <code><a href="#topic+predictions.frame">predictions.frame</a></code> from a <code>data.frame</code>, ensuring that the correct 
columns are present.</h2><span id='topic+as.predictions.frame'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+predictions.frame">predictions.frame</a></code> from a <code><a href="base.html#topic+data.frame">data.frame</a></code> by adding the 
<code>class</code> <code><a href="#topic+predictions.frame">predictions.frame</a></code> to it, and renaming the columns containing 
the  <code>predictions</code>, <code>se</code>, <code>est.status</code> and <code>error.intervals</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.predictions.frame(data, classify = NULL, 
                     predictions = NULL, se = NULL, est.status = NULL, 
                     interval.type = NULL, interval.names = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.predictions.frame_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing columns giving the variables that uniquely index 
the predicted values and columns with the predicted values, their standard errors 
and, optionally, their estimation status (<code>est.status</code>).</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_classify">classify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table that was predicted. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator. For predicting the overall 
mean, the <code>classify</code> is set to &quot;<code>(Intercept)</code>&quot;.</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_predictions">predictions</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>data</code> that 
contains the predicted values. This column will be renamed to 
<code>predicted.value</code>.</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_se">se</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>data</code> that 
contains the standard errors of the predicted values. This column will 
be renamed to <code>standard.error</code>.</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_est.status">est.status</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>data</code> that 
contains the estimation status of the predicted values. It will have a value 
<code>Estimable</code> for predicted values that have been estimated and a value 
<code>Aliased</code> for predicted values that are <code>NA</code>. If a column named 
<code>est.status</code> is not present in <code>data</code> and <code>est.status</code> is 
<code>NULL</code>, a column <code>est.status</code> will be generated.</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_interval.type">interval.type</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the type of <code>error.intervals</code> 
stored in <code>data</code> that require renaming. If <code>NULL</code>, <code>error.intervals</code> 
will not be renamed, even if they are present. Otherwise, <code>interval.type</code> 
should be set to one of &quot;CI&quot;, &quot;SE&quot; or &quot;halfLSD&quot;.</p>
</td></tr>
<tr><td><code id="as.predictions.frame_+3A_interval.names">interval.names</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the column names of the <code>lower</code> and 
<code>upper</code> limits stored in <code>data</code> that are to be renamed. The 
<code>character</code> must be of length two, with the first element being the name of 
the 'lower' limit and the second element being the name of the 'upper' limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3-class <code><a href="#topic+predictions.frame">predictions.frame</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+predictions.frame">predictions.frame</a></code>,  
<code><a href="#topic+is.predictions.frame">is.predictions.frame</a></code>, <code><a href="#topic+predictions.frame">predictions.frame</a></code>, <br /> 
<code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
 #Form predictions.frame changing asreml-R4 names to the standard names, if these are present
 Var.preds &lt;- as.predictions.frame(Var.pred$pvals, se = "std.error", 
                                    est.status = "status")
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
  }

  ## Check the class and validity of the alldiffs object
  if (exists("Var.preds"))
  {
    is.predictions.frame(Var.preds)
    validPredictionsFrame(Var.preds)
  }
</code></pre>

<hr>
<h2 id='asremlPlus-deprecated'>Deprecated Functions in the Package asremlPlus</h2><span id='topic+asremlPlus-deprecated'></span><span id='topic+addrm.terms.asreml'></span><span id='topic+addrm.terms.asrtests'></span><span id='topic+alldiffs'></span><span id='topic+asrtests'></span><span id='topic+choose.model.asreml'></span><span id='topic+choose.model.asrtests'></span><span id='topic+facRecode'></span><span id='topic+facRecode.alldiffs'></span><span id='topic+info.crit'></span><span id='topic+info.crit.asreml'></span><span id='topic+newrcov.asrtests'></span><span id='topic+plotvariofaces.asreml'></span><span id='topic+predictiondiffs.asreml'></span><span id='topic+predictionplot.asreml'></span><span id='topic+predictparallel.asreml'></span><span id='topic+pred.present.asreml'></span><span id='topic+power.transform'></span><span id='topic+recalc.wald.tab.asreml'></span><span id='topic+recalc.wald.tab.asrtests'></span><span id='topic+reorderClassify'></span><span id='topic+reorderClassify.alldiffs'></span><span id='topic+reml.lrt'></span><span id='topic+reml.lrt.asreml'></span><span id='topic+rmboundary.asreml'></span><span id='topic+setvarianceterms.asreml'></span><span id='topic+sig.devn.reparam.asreml'></span><span id='topic+sig.devn.reparam.asrtests'></span><span id='topic+testranfix.asreml'></span><span id='topic+testrcov.asreml'></span><span id='topic+testrcov.asrtests'></span><span id='topic+testswapran.asreml'></span>

<h3>Description</h3>

<p>These functions have been renamed and deprecated in <code>asremlPlus</code>: 
</p>

<ol>
<li><p> addrm.terms.asreml and addrm.terms.asrtests -&gt; <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
</p>
</li>
<li><p> alldiffs -&gt; <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, 
</p>
</li>
<li><p> asrtests-&gt; <code><a href="#topic+as.asrtests">as.asrtests</a></code>, 
</p>
</li>
<li><p> choose.model.asreml and choose.model.asrtests -&gt; <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, 
</p>
</li>
<li><p> facRecode and facRecode.alldiffs -&gt; <code><a href="#topic+facRecast.alldiffs">facRecast.alldiffs</a></code>,
</p>
</li>
<li><p> info.crit and info.crit.asreml -&gt; <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>, 
</p>
</li>
<li><p> newrcov.asrtests -&gt; <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
</p>
</li>
<li><p> plotvariofaces.asreml -&gt; <code><a href="#topic+plotVariofaces.data.frame">plotVariofaces.data.frame</a></code>, 
</p>
</li>
<li><p> power.transform -&gt; <code><a href="#topic+powerTransform">powerTransform</a></code>, 
</p>
</li>
<li><p> predictiondiffs.asreml -&gt; <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
</p>
</li>
<li><p> predictionplot.asreml -&gt; <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, 
</p>
</li>
<li><p> predictparallel.asreml -&gt; <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, 
</p>
</li>
<li><p> pred.present.asreml -&gt; <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, 
</p>
</li>
<li><p> recalc.wald.tab.asreml and recalc.wald.tab.asrtests -&gt; <code><a href="#topic+recalcWaldTab.asrtests">recalcWaldTab.asrtests</a></code>, 
</p>
</li>
<li><p> reorderClassify and reorderClassify.alldiffs -&gt; <code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>, 
</p>
</li>
<li><p> reml.lrt and reml.lrt.asreml -&gt; <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>,
</p>
</li>
<li><p> rmboundary.asreml -&gt; <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, 
</p>
</li>
<li><p> setvarianceterms.asreml  -&gt; <code><a href="#topic+setvarianceterms.call">setvarianceterms.call</a></code>, 
</p>
</li>
<li><p> sig.devn.reparam.asreml and sig.devn.reparam.asrtests -&gt; <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
</p>
</li>
<li><p> testranfix.asreml -&gt; <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
</p>
</li>
<li><p> testrcov.asreml and testrcov.asrtests -&gt; <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, 
</p>
</li>
<li><p> testswapran.asreml -&gt; <code><a href="#topic+testswapran.asrtests">testswapran.asrtests</a></code></p>
</li></ol>


<h3>Usage</h3>

<pre><code class='language-R'>addrm.terms.asreml(...)
addrm.terms.asrtests(...)
alldiffs(...)
asrtests(...)
choose.model.asreml(...)
choose.model.asrtests(...)
facRecode(...)
facRecode.alldiffs(...)
info.crit(...)
info.crit.asreml(...)
newrcov.asrtests(...)
plotvariofaces.asreml(...)
power.transform(...)
predictiondiffs.asreml(...)
predictionplot.asreml(...)
predictparallel.asreml(...)
pred.present.asreml(...)
recalc.wald.tab.asreml(...)
recalc.wald.tab.asrtests(...)
reml.lrt(...)
reml.lrt.asreml(...)
## S3 method for class 'alldiffs'
reorderClassify(...)
## S3 method for class 'asreml'
rmboundary(...)
setvarianceterms.asreml(...)
sig.devn.reparam.asreml(...)
sig.devn.reparam.asrtests(...)
testranfix.asreml(...)
testrcov.asreml(...)
testrcov.asrtests(...)
## S3 method for class 'asreml'
testswapran(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asremlPlus-deprecated_+3A_...">...</code></td>
<td>
<p>absorbs arguments passed from the old functions of the style foo.bar().</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Brien</p>

<hr>
<h2 id='asremlPlus-package'>
Augments 'ASReml-R' in Fitting Mixed Models and Packages
Generally in Exploring Prediction Differences
</h2><span id='topic+asremlPlus-package'></span><span id='topic+asremlPlus'></span>

<h3>Description</h3>

<p>Assists in automating the selection of terms to include in mixed models when  
  'asreml' is used to fit the models. Procedures are available for choosing models that 
  conform to the hierarchy or marginality principle, for fitting and choosing between 
  two-dimensional spatial models using correlation, natural cubic smoothing spline and 
  P-spline models. A history of the fitting of a sequence of models is kept in a data frame. 
  Also used to compute functions and contrasts of, to investigate differences between and 
  to plot predictions obtained using any model fitting function. The content  falls into 
  the following natural groupings: (i) Data, (ii) Model modification functions, (iii) Model 
  selection and description functions, (iv) Model diagnostics and simulation functions, 
  (v) Prediction production and presentation functions, (vi) Response transformation 
  functions, (vii) Object manipulation functions, and (viii) Miscellaneous functions 
  (for further details see 'asremlPlus-package' in help). The 'asreml' package provides a 
  computationally efficient algorithm for fitting a wide range of linear mixed models using 
  Residual Maximum Likelihood. It is a commercial package and a license for it can be 
  purchased from 'VSNi' &lt;https://vsni.co.uk/&gt; as 'asreml-R', who will supply a zip file 
  for local installation/updating (see &lt;https://asreml.kb.vsni.co.uk/&gt;). It is not needed 
  for functions that are methods for 'alldiffs'  and 'data.frame' objects. The package 
  'asremPlus' can also be installed from &lt;http://chris.brien.name/rpackages/&gt;.
</p>
<p><b>Version:</b> 4.4.27
</p>
<p><b>Date:</b> 2024-02-05
</p>


<h3>Index</h3>

<p>Note that many of the function below are S3 methods so that the suffix can be omitted. Of course, whether or not the suffix is omitted, the object supplied to the first argument must be of the class specified by the suffix.  For example <code><a href="#topic+getFormulae.asreml">getFormulae.asreml</a></code> is a <code><a href="#topic+getFormulae">getFormulae</a></code> method for an <code>asreml.object</code> and so  <code>.asreml</code> can be omitted and the object supplied to the first argument must be of class <code>asreml</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
(i) Data </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+Oats.dat">Oats.dat</a></code> 
      </td><td style="text-align: left;">  Data for an experiment to investigate nitrogen response of </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> 3 oats varieties. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Wheat.dat">Wheat.dat</a></code> 
      </td><td style="text-align: left;">  Data for an experiment to investigate 25 varieties of </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;">  wheat. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+WaterRunoff.dat">WaterRunoff.dat</a></code>
      </td><td style="text-align: left;"> Data for an experiment to investigate the quality of </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> water runoff over time</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(ii) Model modification </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>
      </td><td style="text-align: left;"> Adds, to a supplied model, a spatial model that accounts for </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> local spatial variation.      </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code>
      </td><td style="text-align: left;"> Uses information criteria to decide whether to add a spatial </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> model to account for local spatial variation. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>
      </td><td style="text-align: left;"> Adds and drops terms from one or both of the fixed or random </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> model, replaces the residual (rcov) model with a new model </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> and changes bounds or initial values of terms.  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+iterate.asrtests">iterate.asrtests</a></code> 
      </td><td style="text-align: left;"> Subject the fitted asreml.obj stored in an asrtests.object </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;">  to further iterations of the fitting process. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> 
      </td><td style="text-align: left;"> Refits an <code>asreml</code> model with changed arguments by extracting, </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> modifying and evaluating its <code>call</code>  - an alternate to </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> update.asreml. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>
       </td><td style="text-align: left;"> Reparamterizes each random (deviations) term </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> involving 'devn.fac' to a fixed term and ensures </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> that the same term, with 'trend.num' replacing </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> 'devn.fac', is included if any other term with </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> 'trend.num' is included in 'terms'. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code> 
       </td><td style="text-align: left;"> Removes any boundary or singular variance components </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> from the fit stored in 'asreml.obj' and records their </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> removal in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+setvarianceterms.call">setvarianceterms.call</a></code> 
       </td><td style="text-align: left;"> Allows the setting of bounds and initial values </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> for terms in the 'random' and 'residual' arguments of an </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> 'asreml' call. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iii) Model selection and description </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+addto.test.summary">addto.test.summary</a></code>
       </td><td style="text-align: left;"> Adds a row to a <code>test.summary</code> <code>data.frame</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>
       </td><td style="text-align: left;"> Uses information criteria to decide whether to change an </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> already fitted model. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>
       </td><td style="text-align: left;"> Determines and records the set of significant terms using an </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> <code><a href="#topic+asrtests.object">asrtests.object</a></code>, taking into account the hierarchy </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> or marginality relations of the terms..</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+chooseModel.data.frame">chooseModel.data.frame</a></code>
       </td><td style="text-align: left;"> Determines the set of significant terms from results stored </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> in a <code>data.frame</code>, taking into account the marginality  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> relations of terms and recording the tests used in a </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> <code>data.frame</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code>
       </td><td style="text-align: left;"> Uses information criteria to choose the best fitting </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> spatial model for accounting for local spatial variation. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getTestPvalue.asrtests">getTestPvalue.asrtests</a></code>
       </td><td style="text-align: left;"> Gets the p-value for a test recorded in the test.summary </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> data.frame of an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>
       </td><td style="text-align: left;"> Computes AIC and BIC for models. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+infoCriteria.list">infoCriteria.list</a></code>
       </td><td style="text-align: left;"> Computes AIC and BIC for models. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+R2adj.asreml">R2adj.asreml</a></code>
       </td><td style="text-align: left;"> Calculates the adjusted coefficient of determination for a </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> specified combination of fixed and random terms.     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+recalcWaldTab.asrtests">recalcWaldTab.asrtests</a></code>
       </td><td style="text-align: left;"> Recalculates the denDF, F.inc and P values for a table </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> of Wald test statistics obtained using 'wald.asreml'. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code> 
       </td><td style="text-align: left;"> Performs a REML ratio test. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bootREMLRT.asreml">bootREMLRT.asreml</a></code> 
       </td><td style="text-align: left;"> Performs a REML ratio test using the parametric </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> bootstrap. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>
       </td><td style="text-align: left;"> Tests for a single fixed or random term in model </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> fitted using 'asreml' and records the result in an </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;">  <code><a href="#topic+asrtests.object">asrtests.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>
       </td><td style="text-align: left;"> Fits a new residual formula using 'asreml', tests </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> whether the change is significant and records the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> result in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+testswapran.asrtests">testswapran.asrtests</a></code>
       </td><td style="text-align: left;"> Tests, using a REMLRT, the significance of the difference </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> between the current random model and one in which oldterms </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> are dropped and newterms are added. The result is recorded </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iv) Model diagnostics and simulation</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+plotVariofaces">plotVariofaces</a></code>
       </td><td style="text-align: left;"> Plots empirical variogram faces, including envelopes, </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> from supplied residuals as described by Stefanova, Smith </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> &amp; Cullis (2009). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>
       </td><td style="text-align: left;"> Calculates and plots empirical variogram faces, including </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> envelopes, as described by Stefanova, Smith &amp; Cullis (2009). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+estimateV.asreml">estimateV.asreml</a></code>
       </td><td style="text-align: left;"> Forms the estimated variance, random or residual matrix for </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> the observations from the variance parameter estimates. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+simulate.asreml">simulate.asreml</a></code>
       </td><td style="text-align: left;"> Produce sets of simulated data from a multivariate normal </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> distribution and save quantities related to the simulated data. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(v) Prediction production and presentation </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+addBacktransforms.alldiffs">addBacktransforms.alldiffs</a></code>
       </td><td style="text-align: left;"> Adds or recalculates the backtransforms component of an </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>
       </td><td style="text-align: left;"> Using supplied predictions and standard errors of pairwise </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> differences or the variance matrix of predictions, forms </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> all pairwise differences between the set of predictions, and </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> p-values for the differences. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+exploreLSDs">exploreLSDs</a></code>
       </td><td style="text-align: left;"> Explores the computed LSD values for pairwise differences </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> between predictions.    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code> 
       </td><td style="text-align: left;"> Calculates a linear transformation of the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> predictions stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+pairdiffsTransform.alldiffs">pairdiffsTransform.alldiffs</a></code> 
       </td><td style="text-align: left;"> Calculates the differences between nominated pairs of </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> predictions stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+pickLSDstatistics">pickLSDstatistics</a></code>
       </td><td style="text-align: left;"> Pick LSDstatistics whose values minimize the number of </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> errors in pairwise comparisons of predictions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>
       </td><td style="text-align: left;"> Plots a map of the supplied errors that occur in using the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> computed LSD values for pairwise differences between </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> predictions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code>
       </td><td style="text-align: left;"> Plots a map of the errors that occur in using the computed </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> LSD values for pairwise differences between predictions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>
       </td><td style="text-align: left;"> Plots a heat map of computed LSD values for pairwise </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> differences between predictions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotLSDs.alldiffs">plotLSDs.alldiffs</a></code>
       </td><td style="text-align: left;"> Plots a heat map of computed LSD values for pairwise </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> differences between predictions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>
       </td><td style="text-align: left;"> Plots the predictions for a term, possibly with </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> error bars. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotPvalues.alldiffs">plotPvalues.alldiffs</a></code>
       </td><td style="text-align: left;"> Plots the p-values in the p.differences components </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as a heat map. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotPvalues.data.frame">plotPvalues.data.frame</a></code>
       </td><td style="text-align: left;"> Plots the p-values in data.frame as a heat map.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>
       </td><td style="text-align: left;"> Forms the predictions and associated statistics for </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> a term, using an asreml object and a wald.tab and </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> taking into account that a numeric vector </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> and a factor having parallel values may occur in the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> model. It stores the results in an object of class </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> 'alldifffs' and may print the results. It can be </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> when there are not parallel values.  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>
       </td><td style="text-align: left;"> Forms the predictions for each of one or more terms </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> and presents them in tables and/or graphs. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ratioTransform.alldiffs">ratioTransform.alldiffs</a></code> 
       </td><td style="text-align: left;"> Calculates the ratios of nominated pairs of predictions </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code> 
       </td><td style="text-align: left;"> Adds or recalculates the <code><a href="#topic+LSD.frame">LSD.frame</a></code> that is a </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> component of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.           </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code> 
       </td><td style="text-align: left;"> Adds or replaces the error intervals stored in the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> prediction component of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>
       </td><td style="text-align: left;"> Renews the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> according to a new classify. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>
       </td><td style="text-align: left;"> Sorts the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> according to the predicted values associated with a factor. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>
       </td><td style="text-align: left;"> Subsets the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> to the supplied condition. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sort.predictions.frame">sort.predictions.frame</a></code>
       </td><td style="text-align: left;"> Sorts a <code><a href="#topic+predictions.frame">predictions.frame</a></code> according to the </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> predicted values. associated with a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">

(vi) Response transformation </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+angular">angular</a></code>
       </td><td style="text-align: left;"> Applies the angular transformation to proportions. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+angular.mod">angular.mod</a></code>
       </td><td style="text-align: left;"> Applies the modified angular transformation to a </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> vector of counts. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+powerTransform">powerTransform</a></code>
       </td><td style="text-align: left;"> Performs a combination of a linear and a power </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> transformation on a variable. The transformed </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> variable is stored in the 'data.frame data'. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(vii) Object manipulation </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+as.alldiffs">as.alldiffs</a></code>
      </td><td style="text-align: left;"> Forms an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> from the supplied </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> predictions, along with those statistics, associated with </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> the predictions and their pairwise differences, that have </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> been supplied. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+asrtests">asrtests</a></code>
      </td><td style="text-align: left;"> Pseudonym for <code><a href="#topic+as.asrtests">as.asrtests</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+as.asrtests">as.asrtests</a></code>
      </td><td style="text-align: left;"> Forms an <code><a href="#topic+asrtests.object">asrtests.object</a></code> that stores </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> (i) a fitted asreml object, </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> (ii) a pseudo-anova table for the fixed terms and </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> (iii) a history of changes and hypothesis testing </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> used in obtaining the model. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code>
      </td><td style="text-align: left;"> Forms a <code><a href="#topic+predictions.frame">predictions.frame</a></code> from a data.frame, ensuring </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> that the correct columns are present. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+convAsremlobj.asreml">convAsremlobj.asreml</a></code>
      </td><td style="text-align: left;"> Recreates an <code>asreml</code> object so that it is compatible with the </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> currently loaded <code>asreml</code> version. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+convEffectNames2DataFrame.asreml">convEffectNames2DataFrame.asreml</a></code>
      </td><td style="text-align: left;"> Converts the effects names for a term stored in the component of an </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> <code>asreml</code> object into a <code><a href="base.html#topic+data.frame">data.frame</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+facCombine.alldiffs">facCombine.alldiffs</a></code>
      </td><td style="text-align: left;"> Combines several factors into one in the components of </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+facRecast.alldiffs">facRecast.alldiffs</a></code>
      </td><td style="text-align: left;"> Reorders and/or revises the factor levels using the order of </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> old levels in <code>levels.order</code> and the new labels for the </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> levels given in <code>newlabels</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+facRename.alldiffs">facRename.alldiffs</a></code>
      </td><td style="text-align: left;"> Renames <code><a href="base.html#topic+factor">factor</a></code>s in the <code>prediction</code> component </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getFormulae.asreml">getFormulae.asreml</a></code>
      </td><td style="text-align: left;"> Gets the formulae from an asreml object. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+is.alldiffs">is.alldiffs</a></code>
      </td><td style="text-align: left;"> A single-line function that tests whether an object is </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> of class alldiffs.   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+is.asrtests">is.asrtests</a></code>
      </td><td style="text-align: left;"> A single-line function that tests whether an object is </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> of class asrtests.   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+is.predictions.frame">is.predictions.frame</a></code>
      </td><td style="text-align: left;"> A single-line function that tests whether an object is </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> of classes <code><a href="#topic+predictions.frame">predictions.frame</a></code> and <code><a href="base.html#topic+data.frame">data.frame</a></code>.   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code>
      </td><td style="text-align: left;"> Make the spline basis matrices and data needed to fit </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> Tensor Product P-Splines. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>
      </td><td style="text-align: left;"> Prints the values in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> in a nice format. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.asrtests">print.asrtests</a></code>
      </td><td style="text-align: left;"> Prints the values in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.LSDdata">print.LSDdata</a></code>
      </td><td style="text-align: left;"> Prints the components of a list containing data on the </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> LSDs for all pairwise differences of predictions.      </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.predictions.frame">print.predictions.frame</a></code>
      </td><td style="text-align: left;"> Prints the values in a <code><a href="#topic+predictions.frame">predictions.frame</a></code>, with or without </td>
</tr>
<tr>
 <td style="text-align: left;"> 
      </td><td style="text-align: left;"> title and heading. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.test.summary">print.test.summary</a></code>
      </td><td style="text-align: left;"> Prints a data.frame containing a test.summary. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.wald.tab">print.wald.tab</a></code>
      </td><td style="text-align: left;"> Prints a data.frame containing a Wald or pseudoanova table. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+printFormulae.asreml">printFormulae.asreml</a></code>
      </td><td style="text-align: left;"> Prints the formulae from an asreml object. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>
      </td><td style="text-align: left;"> Sorts the components of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according to </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> the predicted values associated with a factor. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>
       </td><td style="text-align: left;"> Subsets the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according </td>
</tr>
<tr>
 <td style="text-align: left;"> 
       </td><td style="text-align: left;"> to the supplied condition. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+subset.list">subset.list</a></code>
       </td><td style="text-align: left;"> Forms a <code>list</code> that contains a subset of the components of </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> the supplied <code><a href="base.html#topic+list">list</a></code>.     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+validAlldiffs">validAlldiffs</a></code>
       </td><td style="text-align: left;"> Checks that an object is a valid <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+validAsrtests">validAsrtests</a></code>
       </td><td style="text-align: left;"> Checks that an object is a valid <code><a href="#topic+asrtests.object">asrtests.object</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code>
       </td><td style="text-align: left;"> Checks that an object is a valid <code><a href="#topic+predictions.frame">predictions.frame</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(viii) Miscellaneous </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+getASRemlVersionLoaded">getASRemlVersionLoaded</a></code>
       </td><td style="text-align: left;"> Finds the version of asreml that is loaded and </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> returns the initial characters in version. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+loadASRemlVersion">loadASRemlVersion</a></code>
       </td><td style="text-align: left;"> Ensures that a specific version of asreml is loaded.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+num.recode">num.recode</a></code>
       </td><td style="text-align: left;"> Recodes the unique values of a vector using the values  </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> in a new vector. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+permute.square">permute.square</a></code>  
       </td><td style="text-align: left;">          Permutes the rows and columns of a square matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+permute.to.zero.lowertri">permute.to.zero.lowertri</a></code>
       </td><td style="text-align: left;"> Permutes a square matrix until all the lower </td>
</tr>
<tr>
 <td style="text-align: left;">
       </td><td style="text-align: left;"> triangular elements are zero. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The functions whose names end in 'alldiffs&quot; utilize an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> that stores:
(i) a <code><a href="#topic+predictions.frame">predictions.frame</a></code>, being a data frame containing predicted values, variables indexing them and their standard errors and estimability status; 
the lower and upper limits of error intervals will be included when these are requested,
(ii) optionally, square matrices containing all pairwise differences, the standard errors and p-values of the differences, 
and a <code>data.frame</code> containing LSD values and their summary statistics, 
(iii) optionally, the variance matrix of the predictions, and 
(iv) if the response was transformed for analysis, a data frame with backtransforms of the predicted values.
</p>
<p>The functions whose names end in 'asrtests', which are most of the model functions, utilize an <code><a href="#topic+asrtests.object">asrtests.object</a></code> that stores:  
(i) the currently fitted model in <code>asreml.obj</code>, 
(ii) the table of test statistics for the fixed effects in <code>wald.tab</code>, and 
(iii) a data frame that contains a history of the changes made to the model in <code>test.summary</code>. 
</p>


<h3>Author(s)</h3>

<p>Chris Brien [aut, cre] (&lt;https://orcid.org/0000-0003-0581-1817&gt;)
</p>
<p>Maintainer: Chris Brien &lt;chris.brien@adelaide.edu.au&gt;
</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a></p>


<h3>See Also</h3>

<p><code>asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Analyse wheat dat using asreml and asremlPlus (see the WheatSpatial Vignette for details)
## Set up for analysis
library(dae)
library(asreml)
library(asremlPlus)
## use ?Wheat.dat for data set details
data(Wheat.dat)

# Add row and column covariates for the spatial modelling
tmp.dat &lt;- within(Wheat.dat, 
                  {
                    cColumn &lt;- dae::as.numfac(Column)
                    cColumn &lt;- cColumn  - mean(unique(cColumn))
                    cRow &lt;- dae::as.numfac(Row)
                    cRow &lt;- cRow - mean(unique(cRow))
                  })

# Fit an initial model - Row and column random
current.asr &lt;- do.call(asreml, 
                       list(yield ~ Rep + WithinColPairs + Variety, 
                            random = ~ Row + Column,
                            residual = ~ Row:Column,
                            data = tmp.dat))

# Intialize a model sequence by loading the current fit into an asrtests object
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL, IClikelihood = "full", 
                            label = "Initial model")

# Check for and remove any boundary terms and print a summary of the fit in the asrtests object 
current.asrt &lt;- rmboundary(current.asrt)
print(current.asrt)


## Compare a series of information criteria to select a linear mixed model for the data

# Check the need for the term for within Column pairs (a post hoc factor)
current.asrt &lt;- changeModelOnIC(current.asrt, dropFixed = "WithinColPairs", 
                                label = "Try dropping withinColPairs", IClikelihood = "full")
print(current.asrt)

# Fit an ar1 model for local spatial variation
spatial.ar1.asrt &lt;- addSpatialModelOnIC(current.asrt, spatial.model = "corr", 
                                        row.covar = "cRow", col.covar = "cColumn", 
                                        row.factor = "Row", col.factor = "Column", 
                                        IClikelihood = "full")
spatial.ar1.asrt &lt;- rmboundary(spatial.ar1.asrt)
infoCriteria(list(nonspatial = current.asrt$asreml.obj, 
                  ar1 = spatial.ar1.asrt$asreml.obj))
print(spatial.ar1.asrt)

# Choose a model for local spatial variation from several potential models
suppressWarnings(
  spatial.asrts &lt;- chooseSpatialModelOnIC(current.asrt, 
                                          row.covar = "cRow", col.covar = "cColumn",
                                          row.factor = "Row", col.factor = "Column",
                                          dropRandom = "Row + Column",
                                          rotateX = TRUE, ngridangles = NULL, 
                                          asreml.option = "grp", return.asrts = "all"))
# Output the results
print(spatial.asrts$spatial.IC)
print(R2adj(spatial.asrts$asrts$TPNCSS$asreml.obj, include.which.random = ~ .))
print(spatial.asrts$best.spatial.mod)
print(spatial.asrts$asrts$TPNCSS)
printFormulae(spatial.asrts$asrts$TPNCSS$asreml.obj)

## Diagnosting checking using residual plots and variofaces

# Get current fitted asreml object and update to include standardized residuals
current.asr &lt;- spatial.asrts$asrts$TPNCSS$asreml.obj
current.asr &lt;- update(current.asr, aom=TRUE)
Wheat.dat$res &lt;- residuals(current.asr, type = "stdCond")
Wheat.dat$fit &lt;- fitted(current.asr)

# Do residuals-versus-fitted values plot
with(Wheat.dat, plot(fit, res))

# Plot variofaces
variofaces(current.asr, V=NULL, units="addtores", 
           maxiter=50, update = FALSE, 
           ncores = parallel::detectCores())

# Plot normal quantile plot
ggplot(data = Wheat.dat, mapping = aes(sample = res)) +
  stat_qq_band(bandType = "ts") + stat_qq_line() + stat_qq_point() +
  labs(x = "Theoretical Quantiles", y = "Sample Quantiles",
       title = "Normal probability plot") +
  theme(plot.title = element_text(size = 12, face = "bold")) + theme_bw()

## Prediction production and presentation

# Get Variety predictions and all pairwise prediction differences and p-values
Var.diffs &lt;- predictPlus(classify = "Variety", 
                         asreml.obj=current.asr, 
                         error.intervals="halfLeast",
                         wald.tab=current.asrt$wald.tab, 
                         sortFactor = "Variety",
                         tables = "predictions")

# Plot the Variety predictions, with halfLSD intervals, and the p-values
plotPredictions(Var.diffs$predictions, 
                classify = "Variety", y = "predicted.value", 
                error.intervals = "half")
plotPvalues(Var.diffs)

## End(Not run)</code></pre>

<hr>
<h2 id='asremlPlusTips'>The randomly-presented, startup tips.</h2><span id='topic+asremlPlusTips'></span>

<h3>Description</h3>

<p>The intermittent, randomly-presented, startup tips.</p>


<h3>Startup tips</h3>

<p>Need help? The manual is a vignette and is in the vignettes subdirectory  of the package's install directory.
</p>
<p>Find out what has changed in asremlPlus: enter news(package = 'asremlPlus').
</p>
<p>Need help getting started? Enter vignette(package = 'asremlPlus').
</p>
<p>To avoid start-up message that ASReml-R is needed, load asreml before asremlPlus.
</p>
<p>The methods for alldiffs and data.frame do not require asreml
</p>
<p>Use suppressPackageStartupMessages() to eliminate all package startup messages.
</p>
<p>To see all the intermittent, randomly-presented, startup tips enter ?asremlPlusTips.
</p>
<p>To install the latest version: go to <a href="http://chris.brien.name/rpackages">http://chris.brien.name/rpackages</a>.
</p>
<p>For versions between CRAN releases (and more) go to <a href="http://chris.brien.name/rpackages">http://chris.brien.name/rpackages</a>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>

<hr>
<h2 id='asrtests.object'>Description of an asrtests object</h2><span id='topic+asrtests.object'></span><span id='topic+asrtests-class'></span>

<h3>Description</h3>

<p>An object of S3-class <code>asrtests</code> that contains information derived from the fits of 
a mixed model using <code>asreml</code>.
</p>
<p><code><a href="#topic+as.asrtests">as.asrtests</a></code> is function that makes an object of this class.
</p>
<p><code><a href="base.html#topic+is.list">is.list</a></code> is the membership function for this class; it tests 
that an object is of class <code>list</code>.
</p>
<p><code><a href="#topic+validAsrtests">validAsrtests</a></code> can be used to test the validity of an 
<code>asrtests.object</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> that contains three components: 
</p>

<ol>
<li> <p><code>asreml.obj</code>: an object of class <code>asreml</code> that contains 
the fit of a model;
</p>
</li>
<li> <p><code>wald.tab</code>: A <code>data.frame</code> containing a pseudo-anova 
table for the fixed terms produced by <code>wald.asreml</code>. It has 
<code>rownames</code> that correspond to the fixed terms that were 
fitted and four columns. If denominator degrees of freedom were 
calculated then the columns are <code>DF</code>, <code>denDF</code>, 
<code>F.inc</code>, <code>Pr</code>; otherwise the columns are <code>Df</code>, 
<code>Sum of Sq</code>, <code>Wald statistic</code>, and <code>Pr(Chisq)</code>.
</p>
</li>
<li> <p><code>test.summary</code>: A <code>data.frame</code> with columns <code>terms</code>, 
<code>DF</code>, <code>denDF</code>, <code>p</code>, <code>AIC</code>, <code>BIC</code> and 
<code>action</code>, each row of which summarizes the results of  
proposed changes to the fitted model. 
</p>
<p>Possible codes for <code>action</code> are: 
<code>Dropped</code>, <code>Retained</code>, <code>Swapped</code>, <code>Unswapped</code>, 
<code>Unchanged</code>, <code>Significant</code>, <code>Nonsignificant</code>, 
<code>Absent</code>, <code>Added</code>, <code>Removed</code> and <code>Boundary</code>. 
If the either of the models did not converge, <code>unconverged</code> 
will be added to the code. <code>Unchanged</code> is used when 
<code>allow.unconverged</code> is <code>FALSE</code>.
Note that the logical <code>asreml.obj$converge</code> also
reflects whether there is convergence.
</p>
<p>A row is added to the <code>test.summary</code> for each term that is 
dropped, added or tested or a note that several terms have been
added or removed. When values for the AIC and BIC are included 
in the row, then the DF are the number of fixed parameters in the 
model and denDF are the numbers of variance parameters. 
When <code><a href="#topic+changeModelOnIC">changeModelOnIC</a></code> adds a row then the values of the 
degrees of freedom and information criteria are differences 
between those for the model that is supplied and the model 
changed by <code><a href="#topic+changeModelOnIC">changeModelOnIC</a></code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+validAsrtests">validAsrtests</a></code></p>

<hr>
<h2 id='bootREMLRT.asreml'>Uses the parametric bootstrap to calculate the p-value for a REML ratio test to compare two models.</h2><span id='topic+bootREMLRT.asreml'></span><span id='topic+bootREMLRT'></span>

<h3>Description</h3>

<p>Extracts the REML log likelihood for two <code>asreml</code> objects 
and forms the observed REML ratio statistic. It assumes that the second 
<code>asreml</code> object is the result of fitting a model that is a reduced 
version of the model for the first object and is considered to the null model. 
Using the <code>mean</code> and <code>V</code>, <code>nboot</code> bootstrap samples of simulated 
response values are generated in parallel; that is, <code>ncores</code> cores are used 
and each is used to generate and analyse a sample.  The full and reduced models 
are fitted to the data and if either analysis fails to converge another sample 
is generated and analysed using the current core, with a maximum of 
<code>max.retries</code> attempts to obtain a sample that converges for both analysis. 
Thus the maximum number of data sets that will be generated is 
<code>nboot</code> * <code>max.retries</code>. If a bootstrap sample converges for both analyses, 
the REML ratio test statistic is formed for it. The p-value is then calculated 
as <code class="reqn">(k + 1) / (b + 1)</code> where <code class="reqn">k</code> is the number 
of simulated ratio test statistics greater than the observed test statistic and 
<code class="reqn">s</code> is the number of bootstrap samples that were returned.
</p>
<p>The function checks that the models do not differ in either their fixed 
or sparse models. It also check the difference in the number of variance 
parameters between the two fits to the models, taking into account the 
<code>bound.exclusions</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
bootREMLRT(h0.asreml.obj, h1.asreml.obj, 
           nboot = 100, max.retries = 5, seed = NULL, 
           means=NULL, V = NULL, extra.matrix = NULL, ignore.terms = NULL, 
           fixed.spline.terms = NULL, 
           bound.exclusions = c("F","B","S","C"), 
           tolerance = 1E-10, update = TRUE, trace = FALSE, 
           ncores = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootREMLRT.asreml_+3A_h0.asreml.obj">h0.asreml.obj</code></td>
<td>
<p><code>asreml</code> object containing the fit under the model for the 
null hypothesis.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_h1.asreml.obj">h1.asreml.obj</code></td>
<td>
<p><code>asreml</code> object containing the fit under the model for the 
alternative hypothesis.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples to be generated.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_max.retries">max.retries</code></td>
<td>
<p>The maximum number of attempts to generate a sample whose analyses 
converge for both models.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer, that specifies the 
starting value of the random number generator. The &quot;L'Ecuyer-CMRG&quot; random 
generator is used and <code>nextRNGStream</code> is used to seed each core from the
original <code>seed</code>.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_means">means</code></td>
<td>
<p>The <code>vector</code> of means to be used in generating simulated bootstrap 
samples. If it is <code>NULL</code>, the fitted values based on <code>object</code> 
are used. It must be the same length as the response variable for 
<code>object</code>.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_v">V</code></td>
<td>
<p>The fitted variance <code>matrix</code>, i.e. having the pattern and values that 
conform to the model fit stored in the supplied <code>object</code>. If it is 
<code>NULL</code>, <code><a href="#topic+estimateV.asreml">estimateV.asreml</a></code> is used to estimate the 
variance matrix for the observations from the variance parameter estimates 
from the <code>reduced.asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_extra.matrix">extra.matrix</code></td>
<td>
<p>A <code>matrix</code> of order equal to the number of observations that is to 
be added to the variance <code>matrix</code>, the latter based 
on the information in <code>asreml.obj</code>. It is assumed that the sigma-parameterized 
values of the variance parameter estimates, such as is given in the <code>varcomp</code> 
component of <code>summary.asreml</code>, have been used in calculating 
<code>extra.matrix</code>; the values in the <code>vparameters</code> component of 
<code>G.param</code> and <code>R.param</code> may be either gamma- or sigma-parameterized. 
The argument <code>extra.matrix</code> can be used in conjunction with 
<code>ignore.terms</code> as a workaround to include components of the variance matrix 
for variance functions that have not been implemented in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_ignore.terms">ignore.terms</code></td>
<td>
<p>A <code>character</code> giving terms from either the <code>random</code> or 
<code>residual</code> models that are to be ignored in that their contributions to 
the variance is not to be included in the estimated matrix. The term names are those 
given in the <code>vparameters</code> component of the <code>asreml</code> object or the 
<code>varcomp</code> component produced by <code>summary.asreml</code>, but only up to the 
first exclamation mark (<code>!</code>). This can be used 
in conjunction with <code>estimateV.asreml</code> as a workaround to include components 
of the variance matrix for variance functions that have not been implemented                
in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_fixed.spline.terms">fixed.spline.terms</code></td>
<td>
<p>A <code>character</code> vector giving one or more spline terms in the 
<code>random</code> model that are regarded as fixed  and so are to be ignored 
because they are not regarded as contributing to the variance. The term 
names are those given in the <code>vparameters</code> component of the 
<code>asreml</code> object or the <code>varcomp</code> component produced by 
<code>summary.asreml</code>, but only up to the first exclamation mark 
(<code>!</code>).</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound codes that 
will result in a variance parameter in the <code>random</code> model being 
excluded from contributing to the variance. If set to <code>NULL</code> 
then none will be excluded.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_tolerance">tolerance</code></td>
<td>
<p>The value such that eigenvalues less than it are considered to be zero.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_update">update</code></td>
<td>
<p>If <code>TRUE </code>then the arguments <code>R.param</code> 
and <code>G.param</code> are set to those in the <code>asreml</code> object supplied 
in <code>object</code> so that the values from the original model are used as 
starting values. If <code>FALSE</code> then <code>asreml</code> <code>calls</code> are 
evaluated, the only changes from the previous call being that 
(i) the model is fitted to simulated data and (ii) modifications 
specified via <code>...</code> are mode, except that changes cannot be made to 
any of the models.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code> then partial iteration details are displayed when ASReml-R 
functions are invoked; if <code>FALSE</code> then no output is displayed.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_ncores">ncores</code></td>
<td>
<p>A <code>numeric</code> specifying the number of cores to use in doing the 
simulations. In choosing a value for <code>ncores</code>, it is necessary to 
take into account other processes that are using parallel processing at 
the same time.</p>
</td></tr>
<tr><td><code id="bootREMLRT.asreml_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the function asreml. Changes to the 
models are not allowed. Other changes are dangerous and generally should be 
avoided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following components:
</p>

<ol>
<li><p><b>REMLRT:</b> the observed REML ratio statistic. 
</p>
</li>
<li><p><b>p:</b> the bootstrap p-value for the observed test statistic.
</p>
</li>
<li><p><b>DF:</b> the calculated difference in DF for the variance parameters in the two models.
</p>
</li>
<li><p><b>totalunconverged:</b> the total number of unconverged analyses over the simulations.
</p>
</li>
<li><p><b>REMLRT.sim:</b> a <code>numeric</code> containing the values of the ratio statistics 
for the simulated data. It has an attribute called <code>na.action</code> that 
can be retrieved using <code>attr(REMLRT.sim, which = "na.action")</code>; it 
contains a list of the simulation numbers that were abandoned because 
<code>max.retries</code> failed to converge for both models.
</p>
</li>
<li><p><b>nunconverged:</b> the number of unconverged analyses for each bootstrap sample, the 
maximum being <code>max.retries</code>.</p>
</li></ol>



<h3>Note</h3>

<p>A bootstrap sample is generated using a multivariate normal distribution with expected value as 
specified by <code>means</code> and variance matrix given by <code>V</code>. Each simulated sample 
is analysed according to the reduced model and, provided this analysis converges, 
according to the full.model. If one of these analyses fails to converge, it is 
abandoned and another sample is generated for this simulation. As many as 
<code>max.retries</code> attempts are made to generate a data set for which both analyses 
converge. If data set that converges for both analyses is not generated for a 
simulation, <code>NA</code> is returned for that bootstrap sample. Hence, the maximum number 
of data sets that will be generated is <code>nboot</code> * <code>max.retries</code> and less than 
<code>nboot</code> samples will be generated if a data set that converges for both analyses 
is not obtained within <code>max.retries</code> attempts. 
</p>
<p>If a bootstrap sample converges for both analyses, the REML ratio test statistic is calculated 
as <code class="reqn">2(log(REML)_F - log(REML)_R)</code>.
</p>
<p>The <code>DF</code> is calculated from the information in <code>full.asreml.obj</code> and 
<code>reduced.asreml.obj</code>. The degrees of freedom are computed as the difference 
between the two models in the number of variance parameters whose estimates do 
not have a code for <code>bound</code> specified in <code>bound.exclusions</code>.
</p>
<p>If ASReml-R version 4 is being used then the codes specified in 
<code>bound.exclusions</code> are not restricted to a subset of the default codes, but 
a warning is issued if a code other than these is specified. 
For ASReml-R version 3, only a subset of the default codes are allowed: 
<code>F</code> (<code>Fixed</code>), <code>B</code> (<code>Boundary</code>), <code>C</code> (<code>Constrained</code>) 
and <code>S</code> (<code>Singular</code>). 
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    bootREMLRT(ICV.max, ICV.red, ncores = parallel::detectCores())

## End(Not run)</code></pre>

<hr>
<h2 id='changeModelOnIC.asrtests'>Uses information criteria to decide whether to change an already fitted model.</h2><span id='topic+changeModelOnIC.asrtests'></span><span id='topic+changeModelOnIC'></span>

<h3>Description</h3>

<p>Uses information criteria to decide whether to change the fitted model 
stored in the supplied <code><a href="#topic+asrtests.object">asrtests.object</a></code> according to the specified 
modifications. The function <code><a href="#topic+changeTerms">changeTerms</a></code> is 
used to change the model. Thus, the model can be modified using a 
combination of adding and removing sets of terms from one or both of the fixed 
or random models, replacing the residual model and changing the bounds and/or initial 
values of some terms. The model will be unchanged 
if terms specified in <code>dropFixed</code> or <code>dropRandom</code> are not in the fitted 
model.
</p>
<p>A row is added to the <code>test.summary</code> <code>data.frame</code> of the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> using the supplied <code>label</code> and stating 
whether or not the new model has been swapped for the supplied model. 
Convergence in fitting the model is checked and a note included in the 
<code>action</code> if there was not. All components of the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> are updated to exhibit the differences 
between the supplied and new models.
</p>
<p>To obtain a list of the information criteria for a set of models use 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code> with <code>IClikelihood</code> set to 
<code>REML</code> or <code>full</code>, or use <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
changeModelOnIC(asrtests.obj, 
                dropFixed = NULL, addFixed = NULL, 
                dropRandom = NULL,  addRandom = NULL, 
                newResidual = NULL, label = "Changed terms", 
                allow.unconverged = TRUE, allow.fixedcorrelation = TRUE,
                checkboundaryonly = FALSE, 
                trace = FALSE, update = TRUE, denDF = "numeric", 
                set.terms = NULL, ignore.suffices = TRUE, 
                bounds = "P", initial.values = NA, 
                which.IC = "AIC", IClikelihood = "REML", 
                fixedDF = NULL, varDF = NULL, 
                bound.exclusions = c("F","B","S","C"), 
          ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changeModelOnIC.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components 
(i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_dropfixed">dropFixed</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>". ~ . -"</code> and after expansion, specifies the sum 
of a set of terms to be dropped from the fixed formula. 
The names must match those in the <code>wald.tab</code> component of the 
<code>asrtests.obj</code>.  
The fixed terms will be reordered so that single-variable terms come 
first, followed by two-variable terms and so on. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_addfixed">addFixed</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>". ~ . +"</code> and expansion, specifies the sum 
of a set of terms to be added to the fixed formula. 
The fixed terms will be reordered so that single-variable terms come 
first, followed by two-variable terms and so on.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_droprandom">dropRandom</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ . -"</code> and expansion, specifies the sum 
of a set of terms to be dropped from the random formula. 
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_addrandom">addRandom</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ . +"</code>and expansion, specifies the sum 
of a set of terms to be added to the random formula.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_newresidual">newResidual</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ "</code>, specifies the <code>residual</code> 
(or <code>rcov</code>) model. To remove the model, enter <code>"-(.)"</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_label">label</code></td>
<td>
<p>A <code>character</code> to use as an entry in the <code>terms</code> column in 
<code>test.summary</code> to indicate as far as is possible the terms that are 
being manipulated.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asrtests.obj</code> is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) those specified by this function's arguments and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A <code>character</code> vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting the new model.
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. 
The terms in the model do not need to change from those in the 
model in the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_which.ic">which.IC</code></td>
<td>
<p>A <code>character</code> specifying the information criterion to be used in 
selecting the best model. Possible values are <code>AIC</code> and 
<code>BIC</code>. The value of the criterion for supplied model must 
exceed that for changed model for the changed model to be returned.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> specifying whether Restricted Maximum Likelihood 
(<code>REML</code>) or the full likelihood, evaluated using REML estimates, 
(<code>full</code>) are to be used in calculating the information criteria 
for choosing between models when <code>family</code> is set to 
<code>asr_gaussian</code>. For <code>family</code> set to <code>asr_binomial</code> or 
<code>asr_poisson</code> and with <code>dispersion</code> set to 1, the 
<code>deviance</code> is extracted from <code>object</code> and used to calculate 
the AIC and BIC (as suggested by Damian Collins); the setting of 
<code>IClikelihood</code> is ignored and the log-likelihood set to <code>NA</code>. 
The information criteria are not valid for other settings of 
<code>family</code> and <code>dispersion</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_fixeddf">fixedDF</code></td>
<td>
<p>A <code>numeric</code> giving the number of estimated fixed parameters. If
<code>NULL</code> then this is determined from the information in 
<code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_vardf">varDF</code></td>
<td>
<p>A <code>numeric</code> giving the number of estimated variance parameters. If
<code>NULL</code> then this is determined from the information in 
<code>asreml.obj</code>. It replaces the <code>varDF</code> argument.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying the bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in calculating the information criteria. 
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="changeModelOnIC.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>. The values of the degrees of 
freedom and the information criteria are differences between those of the changed 
model and those of the model supplied to <code>changeModelOnIC</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL, 
                            label = "Maximal model")
current.asrt &lt;- rmboundary(current.asrt)

# Drop both Row and Column terms
current.asrt &lt;- changeModelOnIC(current.asrt, 
                                dropRandom = "Row + Column", 
                                checkboundaryonly = TRUE,
                                which.IC = "AIC", IClikelihood = "full")
current.asrt &lt;- iterate(current.asrt)
                          
# Add and drop both fixed and random terms
current.asrt &lt;- changeModelOnIC(current.asrt, 
                                addFixed = "vRow", dropFixed = "WithinColPairs", 
                                addRandom = "spl(vRow)", dropRandom = "units", 
                                checkboundaryonly = TRUE,
                                which.IC = "AIC", IClikelihood = "full")
                          
# Replace residual with model without Row autocorrelation
current.asrt &lt;- changeModelOnIC(current.asrt, 
                                newResidual = "Row:ar1(Column)", 
                                label="Row autocorrelation",
                                IClikelihood = "full")


## End(Not run)</code></pre>

<hr>
<h2 id='changeTerms.asrtests'>Adds and drops terms from one or both of the fixed or random model, replaces 
the residual (rcov) model with a new model and changes bounds or initial 
values of terms.</h2><span id='topic+changeTerms.asrtests'></span><span id='topic+changeTerms'></span>

<h3>Description</h3>

<p>The specified terms are simply added or dropped, without testing, from 
either the fixed or random model and/or the residual (rcov) model replaced. 
Also, the bounds and/or initial values of some terms can be changed.
No hypothesis testing is performed, but a check is made for boundary or 
singular terms. 
</p>
<p>A row is added to the <code>test.summary</code> <code>data.frame</code> of the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> using the supplied <code>label</code> and stating 
which models have been changed. Information criteria can be included in the 
row of the <code>test.summary</code>. Convergence in fitting the model is checked 
and a note included in the action if there was not. All components of 
the <code><a href="#topic+asrtests.object">asrtests.object</a></code> are updated.
</p>
<p>To only change the terms based on a comparison  of information 
criteria use <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
changeTerms(asrtests.obj, 
            dropFixed = NULL, addFixed = NULL, 
            dropRandom = NULL,  addRandom = NULL, 
            newResidual = NULL, label = "Changed terms", 
            allow.unconverged = TRUE, allow.fixedcorrelation = TRUE, 
            checkboundaryonly = FALSE, 
            trace = FALSE, update = TRUE, denDF = "numeric", 
            set.terms = NULL, ignore.suffices = TRUE, 
            bounds = "P", initial.values = NA, 
            IClikelihood = "none", bound.exclusions = c("F","B","S","C"), 
            ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changeTerms.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_dropfixed">dropFixed</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>". ~ . -"</code> and after expansion, specifies the sum 
of a set of terms to be dropped from the fixed formula. 
The names must match those in the <code>wald.tab</code> component of the 
<code>asrtests.obj</code>. The fixed terms will be reordered so that 
single-variable terms come first, followed by two-variable terms and 
so on. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_addfixed">addFixed</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>". ~ . +"</code> and expansion, specifies the sum 
of a set of terms to be added to the fixed formula. 
The fixed terms will be reordered so that single-variable terms come 
first, followed by two-variable terms and so on.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_droprandom">dropRandom</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ . -"</code> and expansion, specifies the sum 
of a set of terms to be dropped from the random formula. 
The terms must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_addrandom">addRandom</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ . +"</code>and expansion, specifies the sum 
of a set of terms to be added to the random formula.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_newresidual">newResidual</code></td>
<td>
<p>A single <code>character</code> string in the form of a formula which, 
after addition of <code>" ~ "</code>, specifies the <code>residual</code> 
(or <code>rcov</code>) model. To remove the model, enter <code>"-(.)"</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_label">label</code></td>
<td>
<p>A <code>character</code> to use as an entry in the <code>terms</code> column in 
<code>test.summary</code> to indicate as far as is possible the terms that are 
being manipulated.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit does not 
converge, the supplied <code>asrtests.obj</code> is returned.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) those specified by this function's arguments and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A <code>character</code> vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting the new model.
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. 
The terms in the model do not need to change from those in the 
model in the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code> and <code>family</code> is set to 
<code>asr_guassian</code> (the default), then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code> 
and <code>family</code> is set to <code>asr_guassian</code>, 
then the AIC and BIC based on the full likelihood, evaluated using 
REML estimates, are included. 
if <code>family</code> is <code>asr_binomial</code> or <code>asr_poisson</code>, 
with <code>dispersion</code> set to 1, the <code>deviance</code> is extracted 
from <code>object</code> and used to calculate the AIC and BIC.
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying the bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in calculating the information criteria. 
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="changeTerms.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, <br /> 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
terms &lt;- "(Date/(Sources * (Type + Species)))"
current.asrt &lt;- changeTerms(current.asrt, addFixed = terms)

current.asrt &lt;- changeTerms(current.asrt, dropFixed = "A + B", denDF = "algebraic")

data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary(current.asrt)
# Add and drop both fixed and random terms
current.asrt &lt;- changeTerms(current.asrt, 
                            addFixed = "vRow", dropFixed = "WithinColPairs", 
                            addRandom = "spl(vRow)", dropRandom = "units", 
                            checkboundaryonly = TRUE)
# Replace residual with model without Row autocorrelation
current.asrt &lt;- changeTerms(current.asrt, 
                            newResidual = "Row:ar1(Column)", 
                            label="Row autocorrelation")


## End(Not run)</code></pre>

<hr>
<h2 id='ChickpeaEnd.dat'>A large data set comprising the end of imaging data from a chick pea experiment conducted in high-throughput greenhouses</h2><span id='topic+ChickpeaEnd.dat'></span>

<h3>Description</h3>

<p>The data collected after imaging  had been completed on the 1056 plants in the experiment reported by Atieno et al. (2017). The design employed for the experiment was a split-plot design in which two consecutive carts formed a main plot. The split-plot design assigned 245 genotypes to main plots, the genotypes being unequally replicated 2 or 3 times. Treatments (non-saline, saline) were randomized to the two subplots (carts) within each main plot. 
</p>
<p>The columns in the <code>data.frame</code> are: Smarthouse, Lane, Position, Zone, Mainplot, Subplot, Replicate, xLane, xPosition, Genotypes, Treatments, Biomass, PlantHeight, SenescenceRank, TotalPods, FilledPods, EmptyPods, SeedNo, TotalSeedWt, SeedWt100.   
</p>
<p>The columns Smarthouse, Lane and Position uniquely identify the rows of observations. Zones are groups of 4 Lanes, Mainplots are the 44 pairs of consecutive Subplots within each Zone, and a Subplot is a cart containing a single plant. The columns xLane and xPosition are numeric covariates for location within a Smarthouse. Genotypes and Treatments indicate the genotype and treatment that each plant was allocated.  The response variables are Biomass, PlantHeight, SenescenceRank, TotalPods, FilledPods, EmptyPods, SeedNo, TotalSeedWt and SeedWt100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ChickpeaEnd.dat)</code></pre>


<h3>Format</h3>

<p>A <code>data.frames</code> with 1056 rows by 20 columns.</p>


<h3>References</h3>

<p>Atieno, J., Li, Y., Langridge, P., Dowling, K., Brien, C., Berger, B., Varshney, R. K., and Sutton, T. (2017). Exploring genetic variation for salinity tolerance in chickpea using image-based phenotyping. <em>Scientific Reports</em>, <b>7</b>, 1300. <a href="https://doi.org/10.1038/s41598-017-01211-7">doi:10.1038/s41598-017-01211-7</a>
</p>

<hr>
<h2 id='chooseModel'>Determines the set of significant terms using p-values and records the tests performed in a 
<code><a href="base.html#topic+data.frame">data.frame</a></code>, taking into account the 
marginality relations of terms.</h2><span id='topic+chooseModel'></span>

<h3>Description</h3>

<p>Using p-values from hypothesis tests, determines the set of significant 
terms, taking into account the hierarchy or marginality of terms. 
In particular, a term will not be tested if it is marginal to (or nested in) one 
that is significant. 
For example, if A:B is significant, then neither A nor B will be tested. 
The tests conducted in choosing selected model are listed in 
a summary <code><a href="base.html#topic+data.frame">data.frame</a></code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseModel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseModel_+3A_object">object</code></td>
<td>
<p>an object using which p-values can be obtained for use in model selection.</p>
</td></tr>
<tr><td><code id="chooseModel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chooseModel</code> is the generic function for the <code>chooseModel</code> method. 
Use methods(&quot;chooseModel&quot;) to get all the methods for the chooseModel generic.
</p>
<p><code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code> is a method for an <code><a href="#topic+asrtests.object">asrtests.object</a></code>. It uses 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code> to conduct tests to determine the p-values used 
in the model selection.
</p>
<p><code><a href="#topic+chooseModel.data.frame">chooseModel.data.frame</a></code> is a method for a <code><a href="base.html#topic+data.frame">data.frame</a></code>. It uses 
the p-values stored in the <code>data.frame</code> in the model selection.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code></p>

<hr>
<h2 id='chooseModel.asrtests'>Determines and records the set of significant terms using an <code><a href="#topic+asrtests.object">asrtests.object</a></code>, 
taking into account the hierarchy or marginality relations of the terms.</h2><span id='topic+chooseModel.asrtests'></span>

<h3>Description</h3>

<p>Performs a series of hypothesis tests on a set of fixed and/or random terms taking 
into account the marginality of terms. In particular, a term will not be tested if it is 
marginal to (or nested in) one that is significant. For example, if A:B is significant, then 
neither A nor B will be tested. For a random term, the term is removed from 
the model fit, any boundary terms are removed using <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code> 
and a REML likelihood ratio test is performed using <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>.  
If it is not significant and <code>drop.ran.ns</code> is TRUE, the term is permanently removed 
from the model. Note that if boundary terms are removed, the reduced model may not 
be nested in the full model in which case the test is not valid. For fixed terms, 
the Wald tests are performed and the p-value for the term obtained. If it is not 
significant and <code>drop.fix.ns</code> is TRUE, the term is permanently removed 
from the model. A row that records the outcome of a test is added to 
<code>test.summary</code> for each term that is tested. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
chooseModel(object, terms.marginality=NULL, 
            alpha = 0.05, allow.unconverged = TRUE, 
            allow.fixedcorrelation = TRUE,  
            checkboundaryonly = FALSE, drop.ran.ns=TRUE, 
            positive.zero = FALSE, bound.test.parameters = "none", 
            drop.fix.ns=FALSE, denDF = "numeric",  dDF.na = "none", 
            dDF.values = NULL, trace = FALSE, update = TRUE, 
            set.terms = NULL, ignore.suffices = TRUE, 
            bounds = "P", initial.values = NA, 
            IClikelihood = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseModel.asrtests_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_terms.marginality">terms.marginality</code></td>
<td>
<p>A square matrix of ones and zeros with row and column names 
being the names of the terms to be tested. 
The names of fixed terms must match those in the <code>wald.tab</code> component of the 
<code>object</code>, while the names of random terms must match those 
in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>object</code>.
The diagonal elements of the matrix should be one, indicating 
that a term is marginal to itself. Elements should be one if the row 
term is marginal to the column term. All other elements should be zero.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the test.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and a fit when 
a term is removed does not converge, the term will not be removed.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_drop.ran.ns">drop.ran.ns</code></td>
<td>
<p>A logical indicating whether to drop nonsignificant random 
terms from the model.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_positive.zero">positive.zero</code></td>
<td>
<p>Indicates whether the hypothesized values for the 
variance components being tested are on the boundary 
of the parameter space. For example, this is true 
for positively-constrained variance components that, 
under the reduced model, are zero. This argument does 
not need to be set if <code>bound.test.parameters</code> is set.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_bound.test.parameters">bound.test.parameters</code></td>
<td>
<p>Indicates whether for the variance components 
being tested, at least some of the hypothesized values
are on the boundary of the parameter space. 
The possibilities are <code>"none"</code>, <code>"onlybound"</code> 
and <code>"one-and-one"</code>. The default is <code>"none"</code>, 
although if it is set to <code>"none"</code> and 
<code>positive.zero</code> is <code>TRUE</code> then 
<code>bound.test.parameters</code> is taken to be <code>"onlybound"</code>. 
When <code>bound.test.parameters</code> is set to 
<code>"one-and-one"</code>, it signifies that there are two 
parameters being tested, one of which is bound and the 
other is not. For example, the latter is true for testing 
a covariance and a positively-constrained variance component 
that, under the reduced model, are zero.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_drop.fix.ns">drop.fix.ns</code></td>
<td>
<p>A logical indicating whether to drop a fixed  
term from the model when it is nonsignificant </p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_ddf.na">dDF.na</code></td>
<td>
<p>The method to use to obtain substitute denominator degrees of freedom. 
when the numeric or algebraic methods produce an <code>NA</code>. If 
<code>dDF.na = "none"</code>, no substitute denominator degrees of freedom 
are employed; if <code>dDF.na = "residual"</code>, 
the residual degrees of freedom from <code>asreml.obj$nedf</code> are used; 
if <code>dDF.na = "maximum"</code>, the maximum of those denDF that are available, 
excluding that for the Intercept, is used; if all denDF are <code>NA</code>, 
<code>asreml.obj$nedf</code> is used. If <code>dDF.na = "supplied"</code>, 
a <code>vector</code> of values for the denominator degrees of freedom is to 
be supplied in <code>dDF.values</code>. Any other setting is ignored and 
a warning message produced. Generally, substituting these degrees of freedom is 
anticonservative in that it is likely that the degrees of freedom used will be
too large.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_ddf.values">dDF.values</code></td>
<td>
<p>A <code>vector</code> of values to be used when <code>dDF.na = "supplied"</code>. 
Its values will be used when <code>denDF</code> in a test for a fixed effect
is <code>NA</code>. This vector must be the same length as the number of 
fixed terms, including (Intercept) whose value could be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) to the terms in the fixed and random models 
corresponding to terms in <code>terms.marginality</code> and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting. 
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated using
REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="chooseModel.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and
<code><a href="#topic+as.asrtests">as.asrtests</a></code> via <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ol>
<li> <p><code>asrtests.obj</code>: an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the 
components (i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and 
(iii) <code>test.summary</code>.;
</p>
</li>
<li> <p><code>sig.tests</code>: a <code>character vector</code> whose elements are the 
significant terms amongst those tested.</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseModel">chooseModel</a></code>, <code><a href="#topic+chooseModel.data.frame">chooseModel.data.frame</a></code>, 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <br />
<code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <br />
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(WaterRunoff.dat)
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(log.Turbidity ~ Benches + (Sources * (Type + Species)) * Date, 
                      random = ~Benches:MainPlots:SubPlots:spl(xDay), 
                      data = WaterRunoff.dat, keep.order = TRUE)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
terms.treat &lt;- c("Sources", "Type", "Species", 
                 "Sources:Type", "Sources:Species")
terms &lt;- sapply(terms.treat, 
                FUN=function(term){paste("Date:",term,sep="")}, 
                simplify=TRUE)
terms &lt;- c("Date", terms)
terms &lt;- unname(terms)
marginality &lt;-  matrix(c(1,0,0,0,0,0, 1,1,0,0,0,0,  1,0,1,0,0,0, 
                         1,0,1,1,0,0, 1,1,1,0,1,0, 1,1,1,1,1,1), nrow=6)
rownames(marginality) &lt;- terms
colnames(marginality) &lt;- terms
choose &lt;- chooseModel(current.asrt, marginality) 
current.asrt &lt;- choose$asrtests.obj
sig.terms &lt;- choose$sig.terms

## End(Not run)</code></pre>

<hr>
<h2 id='chooseModel.data.frame'>Determines the set of significant terms from results stored in a <code>data.frame</code>, 
taking into account the marginality relations of terms and recording the tests used 
in a <code><a href="base.html#topic+data.frame">data.frame</a></code>.</h2><span id='topic+chooseModel.data.frame'></span>

<h3>Description</h3>

<p>Uses the <code>p.values</code> from a set of hypothesis tests that are stored in 
the supplied <code><a href="base.html#topic+data.frame">data.frame</a></code> to choose a model to describe the effects of the 
terms corresponding to the p-values, taking into account the hierarchy or marginality 
of terms. In particular, a term will not be tested if it is marginal to (or nested in) 
one that is significant. For example, if A:B is significant, then neither A nor B will 
be tested. The tests used in choosing the selected model are listed in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> <code>choose.summary</code>. 
</p>
<p>No change is made to the <code>p.values</code>, the <code>DF</code> and <code>denDF</code> being for 
information only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
chooseModel(object, terms=NULL, p.values = "Pr", 
            DF = "Df", denDF = "denDF", omit.DF = FALSE, 
            terms.marginality=NULL, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseModel.data.frame_+3A_object">object</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> object containing the results of hypothesis tests for a 
set of terms. It components should include <code>terms</code>, <code>p.values</code>, 
and, if not set to <code>NA</code>, <code>DF</code> and <code>denDF</code>.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_terms">terms</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> containing the 
terms corresponding to the <code>p.values</code>. If <code>NULL</code>, it is assumed that 
the row names of <code>object</code> give the terms.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_p.values">p.values</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> containing 
the p-values to use in deciding whether or not terms are significant.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_df">DF</code></td>
<td>
<p>Can be a <code>character</code> or a <code>numeric</code> that specifies the numerator 
degrees of freedom for the tests. 
If it is a <code>character</code>, it must be the name of a column in <code>object</code> 
containing the numerator degrees of freedom that are to be included in the 
<code>choose.summary</code> <code>data.frame</code>. if it is a <code>numeric</code>, its length 
must equal 1 or the number of rows in <code>object</code>. In either case, a column labelled 
<code>DF</code> will be included in the <code>choose.summary</code> <code>data.frame</code>. It will 
contain either the replicated single value (which can be <code>NA</code>) or the values supplied.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_dendf">denDF</code></td>
<td>
<p>Can be a <code>character</code> or a <code>numeric</code> that specifies the denominator 
degrees of freedom for the tests. 
If it is a <code>character</code>, it must be the name of a column in <code>object</code> 
containing the denominator degrees of freedom that are to be included in the 
<code>choose.summary</code> <code>data.frame</code>. if it is a <code>numeric</code>, its length 
must equal 1 or the number of rows in <code>object</code>. In either case, a column labelled 
<code>denDF</code> will be included in the <code>choose.summary</code> <code>data.frame</code>. It will 
contain either the replicated single value (which can be <code>NA</code>) or the values supplied.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_omit.df">omit.DF</code></td>
<td>
<p>A <code>logical</code> indicating whether or not both the numerator and denominator 
degrees of freedom are to be omitted from <code>choose.summary</code>. Doing so will 
mean that the <code>choose.summary</code> no longer has the same columns as a 
<code>test.summary</code> from an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_terms.marginality">terms.marginality</code></td>
<td>
<p>A square matrix of ones and zeros with row and column names 
being the names of the those terms in the <code>terms</code> column of <code>object</code> 
that are to be tested. The diagonal elements should be one, indicating 
that a term is marginal to itself. Elements should be one if the row 
term is marginal to the column term. All other elements should be zero. 
The names of the rows and columns should match the those elements of 
<code>terms</code> that are to be tested.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the hypothesis testing.</p>
</td></tr>
<tr><td><code id="chooseModel.data.frame_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ol>
<li> <p><code>choose.summary</code>: a <code><a href="base.html#topic+data.frame">data.frame</a></code> summarizing 
the tests carried out in choosing the significant terms; 
provided <code>omit.DF =</code> <code>FALSE</code>, it has the same columns as a 
<code>test.summary</code> from an <code><a href="#topic+asrtests.object">asrtests.object</a></code>
</p>
</li>
<li> <p><code>sig.tests</code>: a <code>character vector</code> whose elements are the 
significant terms amongst those tested.</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseModel">chooseModel</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  data("Ladybird.dat")
  
  ## Use asreml to get the table of p-values

  ## Not run: 
  m1.asr &lt;- asreml(logitP ~ Host*Cadavers*Ladybird, 
                   random = ~ Run,
                   data = Ladybird.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  fixed.tab &lt;-  current.asrt$wald.tab
  col.p &lt;- "Pr"
  df = "Df"
  den.df = "denDF"
  
## End(Not run)
  
  ## Use lmeTest to get the table of p-values
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(logitP ~ Host*Cadavers*Ladybird + (1|Run),
                              data=Ladybird.dat)
    fixed.tab &lt;- anova(m1.lmer, type = "II")
    col.p &lt;- "Pr(&gt;F)"
    df = "NumDF"
    den.df = "DenDF"
  }
  
  ## Select a model using the table of p-values obtained with either asreml or lmerTest
  if (exists("fixed.tab"))
  {
    term.marg &lt;- dae::marginality(dae::pstructure(~ Host*Cadavers*Ladybird, 
                                                  data = Ladybird.dat))
    chosen &lt;- chooseModel(fixed.tab, p.values = col.p, DF = df, denDF = den.df, 
                          terms.marginality = term.marg)
  }
</code></pre>

<hr>
<h2 id='chooseSpatialModelOnIC.asrtests'>Uses information criteria to choose the best fitting spatial model for accounting for local spatial variation.</h2><span id='topic+chooseSpatialModelOnIC.asrtests'></span><span id='topic+chooseSpatialModelOnIC'></span>

<h3>Description</h3>

<p>For a response variable measured on a potentially irregular grid of rows and 
columns of the units, uses information criteria (IC) to decide whether the fit and 
parsimony of the model fitted to a set of data can be improved by adding, to the fitted 
model stored in the supplied <code><a href="#topic+asrtests.object">asrtests.object</a></code>, one of the following spatial 
models to account for the local spatial variation: 
(i) a two-dimensional first-order autocorrelation model, (ii) a two-dimensional 
tensor-product natural cubic smoothing spline model (TPNCSS), (iii) a two-dimensional 
tensor-product penalized P-spline model (TPPCS) model, or (iv) a two-dimensional 
tensor-product penalized linear spline model with first-difference penalties (TPP1LS). 
The models from which to select can be reduced to a subset of these four models. 
For each model, a term from the spatial model is only added to the supplied model if 
the IC of the supplied model is decreased with the addition of that term. If no term 
improves the IC when a local spatial variation model is added, then the supplied, 
nonspatial model will be returned. The data can be arranged in sections, for each of 
which there is a grid and for which the model is to be fitted separately. Also, the 
rows and columns of a grid are not necessarily one observational unit wide. For 
<code>TPPCS</code> models, the improvement in the fit from rotating the eigenvectors of 
the penalty matrix can be investigated; if there is no improvement, the unrotated 
fit will be returned.
</p>
<p>One or more rows is added to the <code>test.summary</code> <code>data.frame</code> of the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code>, for each <code>section</code> and each spatial model, 
stating whether or not the new model has been swapped for a model in which the 
spatial model has been added to the  supplied model. Convergence in fitting the 
model is checked and a note included in the <code>action</code> if there was not. 
All components of the <code><a href="#topic+asrtests.object">asrtests.object</a></code> are updated to exhibit the 
differences between the supplied and any new model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
chooseSpatialModelOnIC(asrtests.obj, trySpatial = "all", 
                       sections = NULL, 
                       row.covar = "cRow", col.covar = "cCol", 
                       row.factor = "Row", col.factor = "Col", 
                       corr.funcs = c("ar1", "ar1"), corr.orders = c(0, 0), 
                       row.corrFitfirst = TRUE, allow.corrsJointFit = TRUE, 
                       dropFixed = NULL, dropRandom = NULL, 
                       nsegs = NULL, nestorder = c(1,1), 
                       usRandLinCoeffs = TRUE, 
                       rotateX = FALSE, ngridangles = NULL, 
                       which.rotacriterion = "AIC", nrotacores = 1, 
                       asreml.option = "grp", tpps4mbf.obj = NULL, 
                       allow.unconverged = FALSE, 
                       allow.fixedcorrelation = FALSE,
                       checkboundaryonly = FALSE, update = FALSE, 
                       maxit = 30, IClikelihood = "full", which.IC = "AIC", 
                       return.asrts = "best", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components 
(i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_tryspatial">trySpatial</code></td>
<td>
<p>A <code>character</code> string nominating the types of spatial 
model whose fits are to be assessed. Possible values are <code>none</code>, 
<code>corr</code>, <code>TPNCSS</code>, <code>TPPCS</code>, and <code>TPP1LS</code>. 
If set to <code>none</code>, then just the supplied nonspatial model and 
the information about its information criteria will be returned.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_sections">sections</code></td>
<td>
<p>A single <code>character</code> string that specifies the name of the column 
in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the <code><a href="base.html#topic+factor">factor</a></code> 
that identifies different sections of the data to which separate spatial 
models are to be fitted. Note that, for other terms that involve 
<code>sections</code> in the random formula, there should be separate terms for 
each level of <code>sections</code>. For example, in a blocked experiment 
involving multiple sites, there should be the sum of separate terms for 
the Blocks at each Site i.e. a formula that contains terms like 
at(Site, i):Block for each site and these are separated by <code>'+'</code>. 
Otherwise, the combined term (e.g. Site:Block) will impact on the 
fitting of the local spatial models for the different Sites. Similarly, 
a separate residual variance for each of the <code>sections</code> should be 
fitted, unless there is a need to fit a different variance structure to 
the residual, e.g. heterogeneous residual variances depending on 
treatments. Separate residual variances for <code>sections</code> can be 
achieved using the <code>asreml</code> functions <code>dsum</code> or <code>idh</code>. 
Because, unlike random terms, terms for residual variances are not 
removed from the model, compound residual terms can be used to include 
them in the model, e.g. terms with <code>idh</code> or <code>dsum</code> with multiple
<code>levels</code> in the <code>list</code> or leaving <code>levels</code> out altogether. 
In addition to allowing the independent fitting of models to the 
<code>sections</code>, separate residual variance terms allows a nugget variance 
to be fitted in a correlation model for each of the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_row.covar">row.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the rows of a 
grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_col.covar">col.covar</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
that contains the values of a centred covariate indexing the columns 
of a grid. The <code><a href="base.html#topic+numeric">numeric</a></code> must be a column in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is a 
component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_row.factor">row.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the rows of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_col.factor">col.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the columns of a grid that are to be one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code> that is 
a component of the supplied <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_corr.funcs">corr.funcs</code></td>
<td>
<p>A single <code>character</code> string of length two that specifies the 
<code>asreml</code> one-dimensional correlation or variance model function 
for the row and column dimensions of a two-dimensional separable spatial 
correlation model to be fitted when <code>spatial.model</code> is <code>corr</code>; 
the two-dimensional model is fitted as a random term. If a correlation 
or variance model is not to be investigated for one of the dimensions, 
specify <code>""</code> for that dimension. If the correlation model is  
<code>corb</code>, the values of <code>corr.orders</code> are used for its order 
argument (<code>b</code>).</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_corr.orders">corr.orders</code></td>
<td>
<p>A <code>numeric</code> of length two that specifies the order argument 
(<code>b</code>) values for the row and column dimensions of a two-dimensional 
separable spatial correlation model when <code>spatial.model</code> is 
<code>corr</code> and the <code>corr.funcs</code> for a dimension is <code>corb</code>, 
the <code>asreml</code> banded correlation model. If one of the dimensions 
does not involve an order argument, set the value of <code>corr.orders</code> 
for that dimension to zero. For a dimension for which the 
<code>corr.funcs</code> is <code>corb</code> and <code>corr.orders</code> is zero, a 
model with a single band, the correlation between immediate neighbours, 
will be fitted and then further bands, up to a maximum of 10 bands, will 
be added until the addition of an extra band does not reduce the 
information criterion nominated using <code>which.IC</code>. Note that the 
two-dimensional spatial model is fitted as a random term.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_row.corrfitfirst">row.corrFitfirst</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>. If <code>TRUE</code> then, in fitting the 
model for <code>spatial.model</code> set to <code>corr</code>, the row correlation  
or variance function is fitted first, followed by the addition of the 
column correlation or variance function. If <code>FALSE</code>, the order 
of fitting is reversed.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_allow.corrsjointfit">allow.corrsJointFit</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will allow 
the simultaneous fitting of correlation functions for the two dimensions 
of the grid when separate fits have failed to fit any correlation 
functions. This argument is available for when a joint fit 
hangs the system.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_dropfixed">dropFixed</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>". ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the fixed 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes these 
terms, will be compared with the fitted model that has had them removed and 
a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>wald.tab</code> component of the 
<code>asrtests.obj</code>. The fixed terms will be reordered so that 
single-variable terms come first, followed by two-variable terms and 
so on. Note also that multiple terms specified using a single 
<code>asreml::at</code> function can only be dropped as a whole. If the term 
was specified using an <code>asreml::at</code> function with a single level, 
then it can be removed and either the level itself or its 
<code><a href="base.html#topic+numeric">numeric</a></code> position in the levels returned by the 
<code><a href="base.html#topic+levels">levels</a></code> function can be specified.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_droprandom">dropRandom</code></td>
<td>
<p>A single <code>character</code> string or a <code>character</code> vector of strings 
with an element for each level of <code>sections</code> in the same order as the 
<code>sections</code> levels. Each string, which if it is not <code>NA</code> and after 
the addition of <code>" ~ . -"</code> and conversion to a formula that is then 
expanded, specifies the  sum of a set of terms to be dropped from the random 
formula in fitting splines (<code>TPPS</code> and <code>TPNCSS</code>). The result is 
that the fitted model supplied in the <code>asrtests.obj</code>, that includes 
these terms, will be compared with the fitted model that has had them removed 
and a spatial model added.
</p>
<p>An element that is <code>NA</code> indicates that no term pertaining to the 
corresponding <code>sections</code> level is to be removed. If <code>sections</code> 
is not <code>NULL</code> and a single <code>character</code> string has been supplied, 
the terms specified by the string are taken to be terms that are 
independent of the <code>sections</code> and will be removed when adding the 
spatial model for the first <code>sections</code>. 
</p>
<p>The terms must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>. Note also that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_nsegs">nsegs</code></td>
<td>
<p>A pair of <code><a href="base.html#topic+numeric">numeric</a></code> values giving the number of segments into
which the column and row ranges are to be split, respectively, for fitting 
a P-spline model (<code>TPPS</code>) (each value specifies the number of internal 
knots + 1). If not specified, then (number of unique values - 1) is used 
in each dimension; for a grid layout with equal spacing, this gives a knot 
at each data value. If <code>sections</code> is not <code>NULL</code> and the grid 
differs between the <code>sections</code>, then <code>nsegs</code> will differ between 
the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_nestorder">nestorder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of nesting for column 
and row dimensions, respectively, in fitting a P-spline model (<code>TPPS</code>). 
A value of 1 specifies no nesting, a value of 2 generates a spline with 
half the number of segments in that 
dimension, etc. The number of segments in each direction must be a 
multiple of the order of nesting.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_usrandlincoeffs">usRandLinCoeffs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, will attempt to  
fit an unstructured variance model to the constant and linear terms in 
the interactions for constant and linear terms in one grid dimension 
interacting with smoooth terms in the second grid dimension. The 
unstructured variance model can only be fitted if both the constant and 
linear interaction terms have been retained in the fitted model. 
This argument can be used to omit the attempt to fit an unstructured 
variance model when the attempt results in a stystem error.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_rotatex">rotateX</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to rotate the eigenvectors of the 
penalty matrix, as described by Piepho, Boer and Williams (2022), when 
fitting a P-spline (<code>TPPS</code>). Setting <code>rotateX</code> to <code>TRUE</code> 
results in a a search for an optimized rotation under a model that omits 
the random spline interaction terms. If <code>ngridangles</code> is set to 
<code>NULL</code>, the optimal rotation us found using an optimizer 
(<code>nloptr::bobyqa</code>). Otherwise, the optimal rotation is found by 
exploring the fit over a  two-dimensional grid of rotation angle pairs. 
The optimization seeks to optimize the criterion nominated in 
<code>which.rotacriterion</code>. Rotation of the eigenvectors is only relevant 
for <code>difforder</code> values greater than 1 and has only been implemented 
for <code>difforder</code> equal to 2.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_ngridangles">ngridangles</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. If <code>NULL</code> (the default), 
the optimal pair of angles for rotating the eignevectors of the penalty 
matrix of a P-spline (<code>TPPS</code>) will be determined using a nonlinear 
optimizer (<code>nloptr::bobyqa</code>). Otherwise, its two values specify the 
numbers of angles between 0 and 90 degrees for each of the row and column 
dimensions to be used in determining the optimal pair of angles. Specifying 
factors of 90 will result in integer-valued angles. The number of grid 
points, and hence re-analyses will be the product of the values of 
(<code>ngridangles</code> + 1).</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_which.rotacriterion">which.rotacriterion</code></td>
<td>
<p>A single <code>character</code> string nominating which of the 
criteria, out of the <code>deviance</code>, the <code>likelihood</code>, the 
<code>AIC</code> and the <code>BIC</code>, is to be used in determining the optimal 
rotation of the eigenvectors of the penalty matrix. The <code>deviance</code> 
uses the REML value computed by <code>asreml</code>; the other criteria use 
the full likelihood, evaluated using the REML estimates, that is computed 
by <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_nrotacores">nrotacores</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of cores to deploy for 
running the analyses required to search the two-diemsional grid of rotation 
angles when <code>rotateX</code> is <code>TRUE</code>. Parallel processing has been 
implemented for analyzing, for each column angle, the set of angles to be 
investigated for the row dimension.  The default value of one means that 
parallel processing will not be used. The value chosen for <code>nrotacores</code> 
needs to balanced against the other processes that are using parallel 
processing at the same time.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_asreml.option">asreml.option</code></td>
<td>
<p>A single <code>character</code> string specifying whether the <code>grp</code> or 
<code>mbf</code> methods are to be used to supply externally formed covariate 
matrices to <code>asreml</code> when fitting a P-spline (<code>TPPS</code>). Compared 
to the <code>mbf</code> method, the <code>grp</code> method is somewhat faster, but 
creates large <code><a href="#topic+asrtests.object">asrtests.object</a></code>s for which the time it takes 
to save them can exceed any gains in execution speed. The <code>grp</code> 
method adds columns to the <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the <code>data</code>. 
On the other hand, the <code>mbf</code> method adds only the fixed covariates 
to <code>data</code> and stores the random covariates in the environment of the 
internal function that calls the spline-fitting function; there are three smaller 
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> for each <code>section</code> that are not stored in the 
<code>asreml.object</code> resulting from the fitted model.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_tpps4mbf.obj">tpps4mbf.obj</code></td>
<td>
<p>An object made with <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> 
that contains the spline basis information for fitting P-splines. 
The argument <code>tpps4mbf.obj</code> only needs to be set when the <code>mbf</code> 
option of <code>asreml.option</code> is being used and it is desired to use 
<code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> that have been created and stored 
prior to calling <code>chooseSpatialModelOnIC.asrtests</code>. If <code>tpps4mbf.obj</code> 
is <code>NULL</code>, <br /> 
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> will be called 
internally to produce the required <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asrtests.obj</code> is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead. Note that, for 
correlation models, the fitting of each dimension and the test for a nugget 
term are performed with <code>checkboundaryonly</code>  set to <code>TRUE</code> and its 
supplied setting only honoured using a call to <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code> 
immediately prior to returning the final result of the fitting.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) to fit aptial terms and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_which.ic">which.IC</code></td>
<td>
<p>A <code>character</code> specifying the information criterion to be used in 
selecting the best model. Possible values are <code>AIC</code> and 
<code>BIC</code>. The value of the criterion for supplied model must 
exceed that for changed model for the changed model to be returned. 
(For choosing the rotation angle of the eigenvectors of the penalty 
matrix, see <code>which.rotacriterion</code>.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_maxit">maxit</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the maximum number of iterations that 
<code>asreml</code> should perform in fitting a model.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> specifying whether Restricted Maximum Likelihood 
(<code>REML</code>) or the full likelihood, evaluated using REML estimates, 
(<code>full</code>) are to be used in calculating the information criteria 
to be included in the <code>test.summary</code> of an 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> or to be used in choosing the best model.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_return.asrts">return.asrts</code></td>
<td>
<p>A <code>character</code> string specifying whether the <code><a href="#topic+asrtests.object">asrtests.object</a></code> 
for the <code>best</code> fitting model (smallest AIC or BIC) is returned or the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code>s resulting from the attempted fits of <code>all</code> of 
the models specified using <code>trySpatial</code> are returned.</p>
</td></tr>
<tr><td><code id="chooseSpatialModelOnIC.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code>asreml</code> and 
<code>tpsmmb</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each spatial model that is to be fitted, a fitted spatial model is only returned if it improves the fit over an above that achieved with the model fit supplied in the <code>asrtests.obj</code>, because terms in the spatial model are not added unless model fit is improved by their addition as measured by an IC. If <code>return.asrts</code> is <code>all</code>, then this applies to each spatial model specified by <code>trySpatial</code>. To force a spatial model to be fitted use <code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>. The model fit supplied in the <code>asrtests.obj</code> should not include terms that will be included in any local spatial model. All spatial model terms are fitted as fixed or random. Consequently, the residual model does not have to be iid. The improvement in the fit resulting from the addition of a spatial model to the supplied model is evaluated. Note that the data must be in the order that corresponds to the <code>residual</code> argument with a variable to the right of another variable changes levels in the data frame faster than those of the preceding variables e.g. <code>Row:Column</code> implies that all levels for <code>Column</code> in consecutive rows of the <code>data.frame</code> with a single <code>Row</code> level.
</p>
<p>For the <code>corr</code> spatial model, the default model is an autocorrelation model of order one (<code>ar1</code>) for each dimension. However, any of the single dimension correlation/variance models from <code>asreml</code> can be specified for each dimension, as can no correlation model for a dimension; the models for the two dimensions can differ. Using a forward selection procedure, a series of models are tried, without removing boundary or singular terms, beginning with the addition of row correlation and followed by the addition of column correlation or, if the <code>row.corrFitfirst</code> is set to <code>FALSE</code>, the reverse order. If the fitting of the first-fitted correlation did not result in a model change because the fitting did not converge or correlations were fixed, but the fit of the second correlation was successful, then adding the first correlation will be retried. If one of the metric correlation functions is specified (e.g. <code>exp</code>), then the <code>row.covar</code> or <code>col.covar</code> will be used in the spatial model. However, because the correlations are fitted separately for the two dimensions, the <code>row.factor</code> and <code>col.factor</code> are needed for all models and is used for a dimension that does not involve a correlation/variance function for the fit being performed. Also, the correlation models are fitted as <code>random</code> terms and so the correlation model will include a variance parameter for the grid even when <code>ar1</code> is used to specify the correlation model, i.e. the model fitted is a variance model and there is no difference between <code>ar1</code> and <code>ar1v</code> in fitting the model. The variance parameter for this term represents the spatial variance and the fit necessarily includes a nugget term, this being the residual variance. If any correlation is retained in the model, for a section if <code>sections</code> is not <code>NULL</code>, then the need for a nuggest term is assessed by fixing the corresponding residual variance to one, unless there are multiple residual variances and these are not related to the <code>sections</code>. Once the fitting of the correlation model has been completed, the <code>rmboundary</code> function will be executed with the <code>checkboundaryonly</code> value supplied in the <code>chooseSpatialModelOnIC.asrtests</code> call. Finally, checking for bound and singular random terms associated with the correlation model and residual terms will be carried out when there are correlation terms in the model and <code>checkboundaryonly</code> has been set to <code>FALSE</code>; as many as possible will be removed from the fitted model, in some cases by fixing variance terms to one.
</p>
<p>The tensor-product natural-cubic-smoothing-spline (<code>TPNCSS</code>) spatial model is as described by Verbyla et al. (2018), the tensor-product penalized-cubic-spline (<code>TPPCS</code>) model is similar to that described by Rodriguez-Alvarez et al. (2018), and the tensor-product, first-difference-penalty, linear spline (<code>TPP1LS</code>) model is amongst those described by Piepho, Boer and Williams (2022).  The fixed terms for the spline models are <code>row.covar + col.covar + row.covar:col.covar</code> and the random terms are <code>spl(row.covar) + spl(col.covar) + dev(row.covar) + dev(col.covar) + spl(row.covar):col.covar + row.covar:spl(col.covar) + spl(row.covar):spl(col.covar)</code>, except that <code>spl(row.covar) + spl(col.covar)</code> is not included in <code>TPPCS</code> and <code>TPP1LS</code> models. The supplied model should not include any of these terms. However, any fixed or random main-effect Row or Column term that has been included as an initial model for comparison with a spatial model can be removed prior to fitting the spatial model using <code>dropFixed</code> or <code>dropRandom</code>.  For the penalized P-spline models with second-order differencing, the model matrices used to fit the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> are transformed using the spectral decomposition of their penalty matrices, and unstructured variance models across the columns of each of them will be tried.  For <code>TPPCS</code>, it is also possible to investigate the rotation of the penalty matrix eigenvectors for the random terms <code>spl(row.covar):col.covar</code> and <code>row.covar:spl(col.covar)</code> (for more information see Piepho, Boer and Williams, 2022). The investigation takes the form of a search over a grid of rotation angles for a reduced model; the fit of the full model with rotation using the optimal rotation angles will only be returned if it improves on the fit of the full, unrotated model.
</p>
<p>The <code>TPPCS</code> and <code>TPP1LS</code> models are fitted using functions from the <code>R</code> package <code>TPSbits</code> authored by Sue Welham (2022). There are two methods for supplying the spline basis information produced by <code>tpsmmb</code> to <code>asreml</code>. The <code>grp</code> method adds it to the <code>data.frame</code> supplied in the <code>data</code> argument of the <code>asreml</code> call. The <code>mbf</code> method creates smaller <code><a href="base.html#topic+data.frame">data.frame</a>s</code> with the spline basis information in the same environment as the internal function that calls the spline-fitting function. If it is desired to use in a later session, an <code>asreml</code> function, or <code>asrtests</code> function that calls <code>asreml</code>, (e.g. <code>predict.asreml</code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, or <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>) on an <code>asreml.object</code> created using <code>mbf</code> terms, then the <code>mbf</code> <code><a href="base.html#topic+data.frame">data.frame</a>s</code> will need to be recreated using <code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code> in the new session, supplying, if there has been rotation of the penalty matrix eigenvectors, the <code>theta</code> values that are returned as the attribute <code>theta.opt</code> of the <code>asreml.obj</code>. 
</p>
<p>All models utlize the function <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code> to assess the model fit, the information criteria used in assessing the fit being calculated using <code><a href="#topic+infoCriteria">infoCriteria</a></code>. Arguments from <code>tpsmmb</code> and <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code> can be supplied in calls to <code>chooseSpatialModelOnIC.asrtests</code> and will be passed on to the relevant function though the ellipses argument (...).
</p>
<p>The data for experiment can be divided into <code>sections</code> and an attempt to fit the same spatial model to each is made. The fit may differ for each of the <code>sections</code>, but the fit over all of the <code>sections</code> is assessed. For more detail see <code>sections</code> above.
</p>
<p>Each combination of a row.coords and a col.coords does not have to specify a single observation; 
for example, to fit a local spatial model to the main units of a split-unit design, 
each combination would correspond to a main unit and all subunits of the main unit would 
have the same combination.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> containing four components: (i) <code>asrts</code>, (ii) <code>spatial.IC</code>, 
(iii) <code>best.spatial.mod</code>, and (iv) <code>best.spatial.IC</code>. 
</p>
<p>The component <code>asrts</code> itself holds a  <code><a href="base.html#topic+list">list</a></code> of one or more 
<code><a href="#topic+asrtests.object">asrtests.object</a></code>s, either the best overall out of the supplied model and 
the spatial models, or, for each spatial model, the best out of the supplied model 
and that spatial model. Each <code><a href="#topic+asrtests.object">asrtests.object</a></code> contains the components:  
(i) <code>asreml.obj</code>, (ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>. If the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code> is the result of fitting a <code>TPPCS</code> model with 
an exploration of the rotation of the eigenvectors of the penalty matrix for the linear 
components, then the <code>asreml.obj</code> will have an attribute <code>theta.opt</code> that contains 
the optimal rotation angles of the eigenvectors.
</p>
<p>The <code>spatial.IC</code> component holds a <code><a href="base.html#topic+data.frame">data.frame</a></code> with summary of the 
values of the information criteria for the supplied model and those resulting from  
adding the spatial model to the supplied model. In the se of a spatial correlation model, 
the information criteria for the selected spatial correlation model is returned. 
If a spatial model could not be fitted, then all returned values will be <code>NA</code>). 
</p>
<p>The <code>best.spatial</code> component is a character giving the name of the best spatial 
model, and <code>best.spatial.AIC</code> gives the value of its <code>AIC</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H.-P., Boer, M. P., &amp; Williams, E. R. (2022). Two-dimensional P-spline smoothing for spatial analysis of plant breeding trials. <em>Biometrical Journal</em>, <b>64</b>, 835-857.
</p>
<p>Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., &amp; Eilers, P. H. C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. <em>Spatial Statistics</em>, <b>23</b>, 52-71. 
</p>
<p>Verbyla, A. P., De Faveri, J., Wilkie, J. D., &amp; Lewis, T. (2018). Tensor Cubic Smoothing Splines in Designed Experiments Requiring Residual Modelling. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, <b>23(4)</b>, 478-508.
</p>
<p>Welham, S. J. (2022) <code>TPSbits</code>: <em>Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R.</em> Version 1.0.0 <a href="https://mmade.org/tpsbits/">https://mmade.org/tpsbits/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, 
<code><a href="#topic+makeTPPSplineMats.data.frame">makeTPPSplineMats.data.frame</a></code>, 
<code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code>, <br />
<code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>,  <br />
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>,  
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
<code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <br />
<code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Wheat.dat)

#Add row and column covariates
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn  - mean(unique(cColumn))
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                    })

#Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column,
                      data=Wheat.dat)

#Create an asrtests object, removing boundary terms
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL, 
                            label = "Random Row and Column effects")
current.asrt &lt;- rmboundary(current.asrt)

# Choose the best of four models for the local spatial variation
current.asrt &lt;- chooseSpatialModelOnIC(current.asrt, 
                                       row.covar = "cRow", col.covar = "cColumn",
                                       dropRowterm = "Row", dropColterm = "Column",
                                       asreml.option = "grp")

## End(Not run)</code></pre>

<hr>
<h2 id='convAsremlobj.asreml'>Recreates an <code>asreml</code> object so that it is compatible with the currently loaded <code>asreml</code> version.</h2><span id='topic+convAsremlobj.asreml'></span><span id='topic+convAsremlobj'></span>

<h3>Description</h3>

<p>Recreate an existing <code>asreml</code> object so that it is compatible with the currently loaded <code>asreml</code> version. It involves refitting the model stored in the <code>asreml</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
convAsremlobj(asreml.obj, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convAsremlobj.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An <code>asreml</code> object with  
a component named <code>call</code> (from a previous 
call to either <code>asreml</code> or <code>update.asreml</code>).</p>
</td></tr>
<tr><td><code id="convAsremlobj.asreml_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>asreml</code> object.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code>update.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    m1.asr &lt;- convAsremlobj(m1.asr)

## End(Not run)</code></pre>

<hr>
<h2 id='convEffectNames2DataFrame.asreml'>Converts the effects names for a term stored in the component of an <code>asreml</code> object into a <code><a href="base.html#topic+data.frame">data.frame</a></code>.</h2><span id='topic+convEffectNames2DataFrame.asreml'></span><span id='topic+convEffectNames2DataFrame'></span>

<h3>Description</h3>

<p>Converts the effects names for a term stored in the component of an <code>asreml</code> object into 
a <code><a href="base.html#topic+data.frame">data.frame</a></code> that has a column for each factor and variable in the term. 
It facilitates adding the effects to the <code><a href="base.html#topic+data.frame">data.frame</a></code> supplied to <code>asreml</code> 
for an analysis. This function can only be used with <code>asreml</code> v4.2 or later.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
convEffectNames2DataFrame(asreml.obj, term, use = "design.matrix", sep = ":", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convEffectNames2DataFrame.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An object resulting from the fitting of 
a model using <code>asreml</code> v4.2.</p>
</td></tr>
<tr><td><code id="convEffectNames2DataFrame.asreml_+3A_term">term</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating a single model term. It should be the 
name of the <code>term</code> in the component, of  the <code>asreml.obj</code>, nominated 
in the <code>use</code> argument. The variables/factors in <code>term</code> must match those 
in this component. Thus, it will not include <code>asreml</code> variance or 
correlation functions, but may include functions such at <code>at</code>. Generally, 
each element of the <code>term</code>, separated from other elements by colons, should 
involve  a single factor or variable.</p>
</td></tr>
<tr><td><code id="convEffectNames2DataFrame.asreml_+3A_use">use</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying a component in the <code>asreml.obj</code>. 
The default is the <code>design.matrix</code>. Other possibilities are the 
<code>random.coeffs</code>  or <code>G.aom</code>. For the option <code>design.matrix</code>, 
the <code>design</code> argument of <code>asreml.options</code> must be set to <code>TRUE</code>, 
before executing either the <code>asreml</code> or <code>update.asreml</code> call 
produces the <code>asreml.obj</code>. The option <code>G.aom</code> specifies the <code>G</code> 
component of the <code>aom</code> component that is included in the <code>asreml.obj</code> 
if the <code>aom</code> argument is set to <code>TRUE</code>  in either <code>asreml.options</code> 
before calling <code>asreml</code> or <code>update.asreml</code>, or in a call to 
<code>asreml</code> or <code>update.asreml</code> that is involved in producing the 
<code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="convEffectNames2DataFrame.asreml_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the separator of factors/variables 
in the <code>term</code>.</p>
</td></tr>
<tr><td><code id="convEffectNames2DataFrame.asreml_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns for the factors and variables in <code>term</code>. 
It includes the attribute <code>effect.names</code> that contains the extracted effects names
for the <code>term</code></p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    G.dat &lt;- convEffectNames2DataFrame(m1.asr, term = "Row:Column", use = "G.aom")
    
    G.dat &lt;- lapply(c("at(Smarthouse, 'SW'):Lane:Position", 
                      "at(Smarthouse, 'SE'):Lane:Position"), 
                   function(term, asreml.obj)
                     tmp &lt;- convEffectNames2DataFrame.asreml(asreml.obj, term = term),
                   asreml.obj = m1.asr)
    G.dat &lt;- do.call(rbind, G.dat)

## End(Not run)</code></pre>

<hr>
<h2 id='estimateV.asreml'>Forms the estimated variance, random or residual matrix for the observations 
from the variance parameter estimates.</h2><span id='topic+estimateV.asreml'></span><span id='topic+estimateV'></span>

<h3>Description</h3>

<p>Forms the estimated variance (<b>V</b>), random (<b>G</b>) or (<b>R</b>) matrix 
for the observations, a square symmetric matrix of order equal to the number of 
observations. The estimates of the variance parameters and the information about 
the <code>random</code> and <code>residual</code> models for which they were estimated are 
obtained from the <code>asreml</code> object. 
This function is not available in ASReml-R version 3.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
estimateV(asreml.obj, which.matrix = "V", 
          extra.matrix = NULL, ignore.terms = NULL, fixed.spline.terms = NULL, 
          bound.exclusions = c("F","B","S","C"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateV.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An <code>asreml</code> object from a call to <code>asreml</code> in which the 
<code>data</code> argument has been set.</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_which.matrix">which.matrix</code></td>
<td>
<p>A <code>character</code> giving the matrix that is to be formed. It must be 
one of <code>"V"</code>, to produce the variance matrix <b>V</b> = <b>G</b> + <b>R</b>, 
<code>"G"</code> to produce the matrix <b>G</b>, corresponding to the <code>random</code> 
formula, or <code>"R"</code> to produce the matrix <b>R</b>, corresponding to the 
<code>residual</code> formula.</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_extra.matrix">extra.matrix</code></td>
<td>
<p>A <code>matrix</code> of order equal to the number of observations that is to 
be added to the <code>matrix</code> specified by <code>which.matrix</code>, the latter based 
on the information in <code>asreml.obj</code>. It is assumed that the sigma-parameterized 
values of the variance parameter estimates, such as is given in the <code>varcomp</code> 
component of <code>summary.asreml</code>, have been used in calculating 
<code>extra.matrix</code>; the values in the <code>vparameters</code> component of 
<code>G.param</code> and <code>R.param</code> may be either gamma- or sigma-parameterized. 
The argument <code>extra.matrix</code> can be used in conjunction with 
<code>ignore.terms</code> as a workaround to include components of the variance matrix 
for variance functions that have not been implemented in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_ignore.terms">ignore.terms</code></td>
<td>
<p>A <code>character</code> giving terms from either the <code>random</code> or 
<code>residual</code> models that are to be ignored in that their contributions to 
the variance is not to be included in the estimated matrix. The term names are those 
given in the <code>vparameters</code> component of the <code>asreml</code> object or the 
<code>varcomp</code> component produced by <code>summary.asreml</code>, but only up to the 
first exclamation mark (<code>!</code>). This can be used 
in conjunction with <code>estimateV.asreml</code> as a workaround to include components 
of the variance matrix for variance functions that have not been implemented                
in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_fixed.spline.terms">fixed.spline.terms</code></td>
<td>
<p>A <code>character</code> vector giving one or more spline terms in the 
<code>random</code> model that are regarded as fixed  and so are to be ignored because 
they are not regarded as contributing to the variance. The term names are those
given in the <code>vparameters</code> component of the <code>asreml</code> object or the 
<code>varcomp</code> component produced by <code>summary.asreml</code>, but only up to the
first exclamation mark (<code>!</code>).</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound codes that 
will result in a variance parameter in the <code>random</code> model being excluded 
from contributing to the variance. If set to <code>NULL</code> then none will
be excluded.</p>
</td></tr>
<tr><td><code id="estimateV.asreml_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information about the variance parameters in the fitted mixed model are obtained 
from the <code>G.param</code> and <code>R.param</code> components of the <code>asreml</code> object. The 
function can deal with the following variance functions in either the <code>random</code> or 
<code>residual</code> models: <code>id</code>, <code>diag</code>, <code>us</code>, <code>ar1</code>, <code>ar2</code>, 
<code>ar3</code>, <code>sar</code>,<code>sar2</code>, <code>ma1</code>, <code>ma2</code>, <code>arma</code>, <code>exp</code>, 
<code>gau</code>, <code>cor</code>, <code>corb</code> and <code>corg</code>. All of these functions, 
except <code>us</code>, can be combined with either <code>v</code> or <code>h</code>. It will also cope 
with the following functions in the <code>random</code> model: <code>at</code>, <code>str</code>, 
<code>spl</code>, <code>dev</code>, <code>grp</code>, <code>fa</code> and <code>rr</code>. Additionally, it can deal 
with the function <code>dsum</code> in the <code>residual</code> model. For further information see 
the ASReml-R User Guide Version 4 (Butler et al., 2023).
</p>


<h3>Value</h3>

<p>A <code>matrix</code> containing the estimated variance matrix.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.</p>


<h3>See Also</h3>

<p><code>asreml</code>, <code><a href="#topic+simulate.asreml">simulate.asreml</a></code>, <code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
# Form variance matrix based on estimated variance parameters
V &lt;- estimateV(current.asr)


## End(Not run)</code></pre>

<hr>
<h2 id='exploreLSDs.alldiffs'>Explores the computed LSD values for pairwise differences between predictions.</h2><span id='topic+exploreLSDs.alldiffs'></span><span id='topic+exploreLSDs'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with an <code>sed</code> component, the LSDs are 
calculated for all pairwise comparisons of predictions. It then calculates 
(i) a table of frequencies of the LSD values, (ii) the distinct values of the LSDs 
after rounding, (iii) various statistics from the LSD values, (iv) a measure of 
the accuracy of each of the LSD statistics, (v) the numbers of false positives and 
false negatives for each of the LSD statistics if pairwise comparisons are based 
on the LSD statistic, (vi) the accuracy of each statistic in 
representing the LSD values for each prediction and (vii) a matrix containing 
the LSD values for comparing each pair of predictions. Histograms of the 
frequencies can also be produced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
exploreLSDs(alldiffs.obj, LSDtype = "overall", LSDby = NULL, 
            LSDaccuracy = "maxAbsDeviation", alpha = 0.05, digits = 3, 
            retain.zeroLSDs = FALSE, 
            zero.tolerance = .Machine$double.eps ^ 0.5, 
            plotHistogram = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exploreLSDs.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code> or <code>factor.combinations</code>. 
It determines whether the LSD values that are investigated and stored are  
(i) the <code>overall</code> minimum, quantile10, quantile25, mean, median, quantile75, quantile90, 
and maximum of all pairwise LSDs, or 
(ii) the minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum 
for the pairwise LSDs for each <code>factor.combination</code>, unless there is only one prediction 
for a <code>factor.combination</code>, when notional LSDs are calculated. The <code>LSDtype</code> 
specified here does not have to match that used in the creating the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on how the LSD statistics are calculated.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of the values the of the <code><a href="base.html#topic+factor">factor</a>s</code> and <code><a href="base.html#topic+numeric">numeric</a>s</code>, the LSD 
statistics and accuracy are computed, as well histograms plotted, when <code>LSDtype</code> is 
<code>factor.combinatons</code>. The <code>LSDby</code> specified here does not have to match that used in 
the creating the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of an LSD statistic when its values are used as an approximate LSD. The option 
<code>q90Deviation</code> produces the sample quantile corresponding to a probability of 0.90. 
The deviations are the differences between a set of LSDs and an LSD statistic calculated from 
those LSDs; the accuracy is expressed as a proportion of the value of the LSD statistic.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the significance level for an LSD to compare a pair of 
predictions.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_digits">digits</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of significant digits to retain in rounding 
the LSDs before determining the distinct rounded LSDs.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_retain.zerolsds">retain.zeroLSDs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to retain or omit LSDs that are zero when 
calculating the summaries of LSDs.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_zero.tolerance">zero.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value such that if an LSD is less than it, the LSD will be 
considered to be zero.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_plothistogram">plotHistogram</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not histograms of the LSD values are to 
be plotted. The <code>LSDtype</code> argument controls whether one histogram of all LSD values is 
plotted or histograms are plotted for each combination of the levels of the factors specified 
by the <code>LSDby</code> argument.</p>
</td></tr>
<tr><td><code id="exploreLSDs.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The false positives and negatives are computed by comparing, for each pair of predictions 
within each levels-combination of the <code>LSDby</code> variables, the 
significance of the pair difference determined using (i) the true LSD that is computed from the 
standard error of differences for the pair and (ii) the approximate LSD that is a statistic 
computed  from the true LSDs for all pairwise difference within each levels-combination of the 
<code>LSDby</code> variables. The number of false positives is the number of pairwise differences for 
which a difference is declared significant using the approximate LSD, but not using the true LSD. 
The number of false negatives is the number of pairwise differences for which a difference is 
declared nonsignificant using the approximate LSD, but significant using the true LSD.
</p>
<p>The LSD accuracy for a set of LSDs is a function of the deviations of those LSDs and an LSD 
statistic calculated from them; the accuracy is expressed as a proportion of the value of 
the LSD statistic.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components 
<code>frequencies</code>, <code>distinct.vals</code>, <code>statistics</code>, <code>accuracy</code>, <code>per.pred.accuracy</code> 
and <code>LSD</code>: 
</p>

<ol>
<li><p><code>frequencies</code> is a <code>data.frame</code> with the frequency distribution of the LSD 
values; 
</p>
</li>
<li><p><code>distinct.vals</code> is a <code>list</code>, each component of which contains the distinct values 
of the LSDs after rounding; 
</p>
</li>
<li><p><code>statistics</code> is a <code>data.frame</code> with the minimum, quantile10, 
quantile25, mean, median, quantile75, quantile90, and maximum of the LSD values; 
</p>
</li>
<li><p><code>accuracy</code> is a <code>data.frame</code> with the accuracies of the minimum, quantile10, 
quantile25, mean, median, quantile75, quantile90, and maximum of the LSD values with respect 
to the values from which these statistics are calculated;  
</p>
</li>
<li><p><code>false.pos</code> is a <code>data.frame</code> with the numbers of false positives for the 
pairwise comparisons within each levels-combination of the <code>LSDby</code> variables when each of 
the minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum of 
the LSD values is used as an approximate LSD in determining the significance of the pairwise 
differences; 
</p>
</li>
<li><p><code>false.neg</code> is a <code>data.frame</code> with the numbers of false negatives for the 
pairwise comparisons within each levels-combination of the <code>LSDby</code> variables when each of 
the minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum of 
the LSD values is used as an approximate LSD in determining the significance of the pairwise 
differences; 
</p>
</li>
<li><p><code>per.pred.accuracy</code> is a <code>data.frame</code> with the accuracies of the 
minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum of the LSD 
values for a set of predictions when these statistics are used to represent the LSDs for the 
comparisons amongst the set of predictions; 
</p>
</li>
<li><p><code>LSD</code> is a square <code>matrix</code> containing the LSD values for 
all pairwise comparisons of the predictions contained in the supplied <code>alldiffs.obj</code>.
</p>
</li></ol>

<p>In the <code>statistics</code>, <code>accuracy</code>, <code>false.pos</code> and <code>false.neg</code> <code>data.frame</code>s, 
<code>c</code> is the number of pairwise comparisons on which the values in the same row are based.  
The accuracy measure is specified by the <code>LSDaccuracy</code> argument.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>, <code><a href="#topic+plotLSDs.alldiffs">plotLSDs.alldiffs</a></code>, <br /> 
<code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code>, <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>, <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <br /> 
<code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Explore the LSD values for predictions obtained using asreml or lmerTest  
  LSDstat &lt;- exploreLSDs(TS.diffs, LSDtype = "factor.combinations", 
                         LSDby = "Sources")
}
</code></pre>

<hr>
<h2 id='facCombine.alldiffs'>Combines several factors into one in the components of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code></h2><span id='topic+facCombine.alldiffs'></span><span id='topic+facCombine'></span>

<h3>Description</h3>

<p>Combines several <code><a href="base.html#topic+factor">factor</a>s</code>, in the <code>prediction</code> component 
of <code>object</code>, into one whose <code>levels</code> are the combinations of the 
used <code>levels</code> of the individual <code><a href="base.html#topic+factor">factor</a>s</code>. The matching 
changes are made to the other components and the attributes of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. If any of the factors to be combined are in 
<code>LSDby</code>, they are removed from the <code>LSDby</code>, unless the factors to 
be combined are exactly those in the <code>LSDby</code>. 
The levels of the <code>factors</code> are combined using <code>fac.combine</code> 
from the <code>dae</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
facCombine(object, factors, order="standard", 
           combine.levels=TRUE, sep="_", level.length = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facCombine.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_factors">factors</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the names of <code><a href="base.html#topic+factor">factor</a>s</code> 
in the <code>prediction</code> component of <code>object</code> whose levels are to be combined.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_order">order</code></td>
<td>
<p>Either <code>standard</code> or <code>yates</code>. The order in which the 
<code>levels</code> combinations of the <code><a href="base.html#topic+factor">factor</a>s</code> are to be considered as 
numbered when forming the <code>levels</code> of the combined <code><a href="base.html#topic+factor">factor</a></code>; 
<code>standard</code> numbers them as if they are arranged in 
standard order, that is with the levels of the first factor moving slowest and 
those of the last factor moving fastest; <code>yates</code> numbers them as if they 
are arranged in Yates order, that is with the levels of the first factor moving 
fastest and those of the last factor moving slowest.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_combine.levels">combine.levels</code></td>
<td>
<p>A <code>logical</code> specifying whether the <code>levels</code> 
labels of the new <code><a href="base.html#topic+factor">factor</a></code> are to be combined from those of the 
<code><a href="base.html#topic+factor">factor</a>s</code> being combined. The default is to 
use the integers from 1 to the product of the numbers of combinations 
of used <code>levels</code> of the individual <code><a href="base.html#topic+factor">factor</a>s</code>, numbering the levels 
according to <code>order</code>.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> string to separate the levels when 
<code>combine.levels = TRUE</code>.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_level.length">level.length</code></td>
<td>
<p>The maximum number of characters from the levels of 
factors to use in the row and column labels of the tables of 
pairwise differences and their p-values and standard errors.</p>
</td></tr>
<tr><td><code id="facCombine.alldiffs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br />
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>; <code>fac.combine</code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("Ladybird.dat")
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(logitP ~ Host*Cadavers*Ladybird, 
                   random = ~ Run,
                   data = Ladybird.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  HCL.pred &lt;- asreml::predict.asreml(m1.asr, classify="Host:Cadavers:Ladybird", 
                                     sed=TRUE)
  HCL.preds &lt;- HCL.pred$pvals
  HCL.sed &lt;- HCL.pred$sed
  HCL.vcov &lt;- NULL
  wald.tab &lt;-  current.asrt$wald.tab
  den.df &lt;- wald.tab[match("Host:Cadavers:Ladybird", rownames(wald.tab)), "denDF"]
  
## End(Not run)
  
  ## Use lmeTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(logitP ~ Host*Cadavers*Ladybird + (1|Run),
                              data=Ladybird.dat)
    HCL.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Host:Cadavers:Ladybird)
    HCL.preds &lt;- summary(HCL.emm)
    den.df &lt;- min(HCL.preds$df)
    ## Modify HCL.preds to be compatible with a predictions.frame
    HCL.preds &lt;- as.predictions.frame(HCL.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    HCL.vcov &lt;- vcov(HCL.emm)
    HCL.sed &lt;- NULL
  }
  
  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("HCL.preds"))
  {
    ## Form an all.diffs object
    HCL.diffs &lt;- as.alldiffs(predictions = HCL.preds, classify = "Host:Cadavers:Ladybird", 
                             sed = HCL.sed, vcov = HCL.vcov, tdf = den.df)
    
    ## Check the class and validity of the alldiffs object
    is.alldiffs(HCL.diffs)
    validAlldiffs(HCL.diffs)

    ## Combine Cadavers and Ladybird
    HCL.diffs &lt;- facCombine(HCL.diffs, factors = c("Cadavers","Ladybird"))
    
    ## Check the validity of HCL.diffs
    validAlldiffs(HCL.diffs)
  }
</code></pre>

<hr>
<h2 id='facRecast.alldiffs'>Reorders and/or revises the factor levels using the order of old levels in <code>levels.order</code> and the new labels for the levels given in <code>newlabels</code>. The values in <code>levels.order</code> must be unique.</h2><span id='topic+facRecast.alldiffs'></span><span id='topic+facRecast'></span>

<h3>Description</h3>

<p>Reorders and revises the levels and labels of a <code><a href="base.html#topic+factor">factor</a></code>, in the <code>prediction</code> 
component of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The values in the 
<code>levels.order</code> vector should be the same as the levels in the existing <code><a href="base.html#topic+factor">factor</a></code>, 
but the order can be changed. To revise the levels, specify the new levels in the 
<code>newlabels</code> vector and these will replace the corresponding value in the 
<code>levels.order</code> vector. The matching 
changes are made to the other components and attributes of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
facRecast(object, factor, levels.order = NULL, newlabels = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facRecast.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="facRecast.alldiffs_+3A_factor">factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of a <code><a href="base.html#topic+factor">factor</a></code> 
in the <code>prediction</code> component of <code>object</code> whose levels and labels are to be recast.</p>
</td></tr>
<tr><td><code id="facRecast.alldiffs_+3A_levels.order">levels.order</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> of length <code>levels(factor)</code> containing 
the old levels in the new order for the factor being created. 
If <code>levels.order</code> is <code>NULL</code>, then the current levels of <code>levels(factor)</code> 
are used.</p>
</td></tr>
<tr><td><code id="facRecast.alldiffs_+3A_newlabels">newlabels</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> of length <code>levels(factor)</code> containing 
values to use in the revision.</p>
</td></tr>
<tr><td><code id="facRecast.alldiffs_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating the new 
<code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br />
<code><a href="#topic+facCombine.alldiffs">facCombine.alldiffs</a></code>, <code><a href="#topic+facRename.alldiffs">facRename.alldiffs</a></code>, 
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>; 
<code>fac.recast</code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("Ladybird.dat")
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(logitP ~ Host*Cadavers*Ladybird, 
                   random = ~ Run,
                   data = Ladybird.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  HCL.pred &lt;- asreml::predict.asreml(m1.asr, classify="Host:Cadavers:Ladybird", 
                                     sed=TRUE)
  HCL.preds &lt;- HCL.pred$pvals
  HCL.sed &lt;- HCL.pred$sed
  HCL.vcov &lt;- NULL
  wald.tab &lt;-  current.asrt$wald.tab
  den.df &lt;- wald.tab[match("Host:Cadavers:Ladybird", rownames(wald.tab)), "denDF"]
  
## End(Not run)
  
  ## Use lmeTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(logitP ~ Host*Cadavers*Ladybird + (1|Run),
                              data=Ladybird.dat)
    HCL.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Host:Cadavers:Ladybird)
    HCL.preds &lt;- summary(HCL.emm)
    den.df &lt;- min(HCL.preds$df)
    ## Modify HCL.preds to be compatible with a predictions.frame
    HCL.preds &lt;- as.predictions.frame(HCL.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    HCL.vcov &lt;- vcov(HCL.emm)
    HCL.sed &lt;- NULL
  }
  
  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("HCL.preds"))
  {
    ## Form an all.diffs object
    HCL.diffs &lt;- allDifferences(predictions = HCL.preds, classify = "Host:Cadavers:Ladybird", 
                                sed = HCL.sed, vcov = HCL.vcov, tdf = den.df)
    
    ## Check the class and validity of the alldiffs object
    is.alldiffs(HCL.diffs)
    validAlldiffs(HCL.diffs)

    ## Recast the Ladybird and Host factors
    HCL.diffs &lt;- facRecast(HCL.diffs, factor = "Ladybird", 
                           newlabels = c("none", "present"))
    HCL.diffs &lt;- facRecast(HCL.diffs, factor = "Ladybird", 
                           levels.order = c("present", "none"), 
                           newlabels = c("yes","no"))
    HCL.diffs &lt;- facRecast.alldiffs(HCL.diffs, factor = "Host", 
                                    levels.order = c("trefoil", "bean"))

    ## Check the validity of HCL.diffs
    validAlldiffs(HCL.diffs)
  }
</code></pre>

<hr>
<h2 id='facRename.alldiffs'>Renames <code><a href="base.html#topic+factor">factor</a></code>s in the <code>prediction</code> component of an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+facRename.alldiffs'></span><span id='topic+facRename'></span>

<h3>Description</h3>

<p>Renames <code><a href="base.html#topic+factor">factor</a></code>s in the <code>prediction</code> component of an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. These changes are propagated to the other 
components and attributes of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
facRename(object, factor.names, newnames,  ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facRename.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="facRename.alldiffs_+3A_factor.names">factor.names</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the names of the 
<code><a href="base.html#topic+factor">factor</a></code>s in the <code>prediction</code> component 
of <code>object</code> that are to be renamed.</p>
</td></tr>
<tr><td><code id="facRename.alldiffs_+3A_newnames">newnames</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the new names of the 
<code><a href="base.html#topic+factor">factor</a></code>s in the <code>prediction</code> component 
of <code>object</code>.</p>
</td></tr>
<tr><td><code id="facRename.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br />
<code><a href="#topic+facCombine.alldiffs">facCombine.alldiffs</a></code>, <code><a href="#topic+facRecast.alldiffs">facRecast.alldiffs</a></code>, 
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>; 
<code>fac.recast</code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("Ladybird.dat")
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(logitP ~ Host*Cadavers*Ladybird, 
                   random = ~ Run,
                   data = Ladybird.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  HCL.pred &lt;- asreml::predict.asreml(m1.asr, classify="Host:Cadavers:Ladybird", 
                                     sed=TRUE)
  HCL.preds &lt;- HCL.pred$pvals
  HCL.sed &lt;- HCL.pred$sed
  HCL.vcov &lt;- NULL
  wald.tab &lt;-  current.asrt$wald.tab
  den.df &lt;- wald.tab[match("Host:Cadavers:Ladybird", rownames(wald.tab)), "denDF"]
  
## End(Not run)
  
  ## Use lmeTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(logitP ~ Host*Cadavers*Ladybird + (1|Run),
                              data=Ladybird.dat)
    HCL.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Host:Cadavers:Ladybird)
    HCL.preds &lt;- summary(HCL.emm)
    den.df &lt;- min(HCL.preds$df)
    ## Modify HCL.preds to be compatible with a predictions.frame
    HCL.preds &lt;- as.predictions.frame(HCL.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    HCL.vcov &lt;- vcov(HCL.emm)
    HCL.sed &lt;- NULL
  }
  
  ## Use the predictions obtained with either asreml or lmerTest
  if (exists("HCL.preds"))
  {
    ## Form an all.diffs object
    HCL.diffs &lt;- allDifferences(predictions = HCL.preds, 
                                classify = "Host:Cadavers:Ladybird", 
                                sed = HCL.sed, vcov = HCL.vcov, tdf = den.df)
    
    ## Check the class and validity of the alldiffs object
    is.alldiffs(HCL.diffs)
    validAlldiffs(HCL.diffs)

    ## Rename Cadavers 
    HCL.diffs &lt;- facRename(HCL.diffs, factor.names = "Cadavers", newnames = "Cadaver.nos")
    
    ## Check the validity of HCL.diffs
    validAlldiffs(HCL.diffs)
  }
</code></pre>

<hr>
<h2 id='getASRemlVersionLoaded'>Finds the version of asreml that is loaded and returns the initial characters in version.</h2><span id='topic+getASRemlVersionLoaded'></span>

<h3>Description</h3>

<p>Checks that <code>asreml</code> is loaded and, if it is, returns the first <code>nchar</code> characters of the version that is loaded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getASRemlVersionLoaded(nchar = NULL, notloaded.fault = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getASRemlVersionLoaded_+3A_nchar">nchar</code></td>
<td>
<p>The number of characters in the asreml version to get.</p>
</td></tr>
<tr><td><code id="getASRemlVersionLoaded_+3A_notloaded.fault">notloaded.fault</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether a fault is to occur 
if <code>asreml</code> is not loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character, being the first <code>nchar</code> characters of the version of <code>asreml</code> 
that is loaded.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadASRemlVersion">loadASRemlVersion</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getASRemlVersionLoaded()
## End(Not run)</code></pre>

<hr>
<h2 id='getFormulae.asreml'>Gets the formulae from an asreml object.</h2><span id='topic+getFormulae.asreml'></span><span id='topic+getFormulae'></span>

<h3>Description</h3>

<p>Gets the <code><a href="stats.html#topic+formula">formula</a></code>e nominated in the <code>which</code> argument from the <code>call</code> stored in an <code>asreml</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
getFormulae(asreml.obj, which = c("fixed", "random", "residual"), 
            expanded = FALSE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFormulae.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An object resulting from the fitting of 
a model using <code>asreml</code>.</p>
</td></tr>
<tr><td><code id="getFormulae.asreml_+3A_which">which</code></td>
<td>
<p>A <code>character</code> listing the <code><a href="stats.html#topic+formula">formula</a></code>(e) to be extracted from the 
<code>call</code> stored in <code>asreml.obj</code>. it should be some combination 
of <code>fixed</code>, <code>random</code>, <code>residual</code>, <code>sparse</code> and 
<code>all</code>. If <code>all</code> is included then all <code><a href="stats.html#topic+formula">formula</a></code>(e) 
will be returned, those not having been specified in the <code>call</code> being 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getFormulae.asreml_+3A_expanded">expanded</code></td>
<td>
<p>A <code>logical</code> indicating whether terms are to be expanded to the 
sum of a set of individual terms.</p>
</td></tr>
<tr><td><code id="getFormulae.asreml_+3A_envir">envir</code></td>
<td>
<p>The environment in which the <code><a href="stats.html#topic+formula">formula</a></code>(e) are to be evaluated. 
May also be <code>NULL</code>, a <code>list</code>, a <code>data.frame</code>, a <code>pairlist</code> 
or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
<tr><td><code id="getFormulae.asreml_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>update.formula</code> and ultimately to 
<code>terms.formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing a component with each of the extracted 
<code><a href="stats.html#topic+formula">formula</a></code>(e), the name of a component being the <code><a href="stats.html#topic+formula">formula</a></code> 
that it contains.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+printFormulae.asreml">printFormulae.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   data(Wheat.dat)
   current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                         random = ~ Row + Column + units,
                         residual = ~ ar1(Row):ar1(Column), 
                         data=Wheat.dat)
    getFormulae(current.asr)

## End(Not run)</code></pre>

<hr>
<h2 id='getTestEntry.asrtests'>Gets the entry for a test recorded in the test.summary data.frame of an <code><a href="#topic+asrtests.object">asrtests.object</a></code></h2><span id='topic+getTestEntry.asrtests'></span><span id='topic+getTestEntry'></span>

<h3>Description</h3>

<p>Matches the <code>label</code> in the <code>term</code> column of the <code>test.summary</code> <code>data.frame</code> 
in the supplied <code><a href="#topic+asrtests.object">asrtests.object</a></code> and extracts the line for it. It only matches 
the last occurrence of <code>label</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
getTestEntry(asrtests.obj, label, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTestEntry.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="getTestEntry.asrtests_+3A_label">label</code></td>
<td>
<p>A <code>character</code> specifying the <code>label</code> of the test for which  
the entry is required. If <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code> was used 
for the test of interest, then the <code>label</code> will be the value of 
the <code>term</code> argument supplied to <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>. 
For <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, the <code>label</code> will be the value of 
the <code>label</code> argument. Other arguments will be relevant for other 
test and change functions.</p>
</td></tr>
<tr><td><code id="getTestEntry.asrtests_+3A_...">...</code></td>
<td>
<p>provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-line <code>data.frame</code> containing the entry.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTestPvalue.asrtests">getTestPvalue.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <br />
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
<code><a href="#topic+testswapran.asrtests">testswapran.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, <br />    
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary(current.asrt)
# Test nugget term
current.asrt &lt;- testranfix(current.asrt, "units", positive=TRUE)
getTestEntry(current.asrt, label = "units")

## End(Not run)</code></pre>

<hr>
<h2 id='getTestPvalue.asrtests'>Gets the p-value for a test recorded in the test.summary data.frame of an <code><a href="#topic+asrtests.object">asrtests.object</a></code></h2><span id='topic+getTestPvalue.asrtests'></span><span id='topic+getTestPvalue'></span>

<h3>Description</h3>

<p>Matches the <code>label</code> in the <code>term</code> column of the <code>test.summary</code> <code>data.frame</code> 
in the supplied <code><a href="#topic+asrtests.object">asrtests.object</a></code> and extracts its p-value. It only matches 
the last occurrence of <code>label</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
getTestPvalue(asrtests.obj, label, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTestPvalue.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="getTestPvalue.asrtests_+3A_label">label</code></td>
<td>
<p>A <code>character</code> specifying the <code>label</code> of the test for which  
the p-value is required. If <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code> was used 
for the test of interest, then the <code>label</code> will be the value of 
the <code>term</code> argument supplied to <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a>. 
               Other arguments will be relevant for other 
              test functions.</code></p>
</td></tr>
<tr><td><code id="getTestPvalue.asrtests_+3A_...">...</code></td>
<td>
<p>provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>numeric</code> containing the p-value. It can be <code>NA</code>, for example when a p-value could not be calculated.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+getTestEntry.asrtests">getTestEntry.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <br /> 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, 
<code><a href="#topic+testswapran.asrtests">testswapran.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, <br />    
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary(current.asrt)
# Test nugget term
current.asrt &lt;- testranfix(current.asrt, "units", positive=TRUE)
getTestPvalue(current.asrt, label = "units")

## End(Not run)</code></pre>

<hr>
<h2 id='infoCriteria'>Computes AIC and BIC for models.</h2><span id='topic+infoCriteria'></span><span id='topic+infoCriteria.asreml'></span><span id='topic+infoCriteria.list'></span>

<h3>Description</h3>

<p>Computes Akiake and Bayesian (Schwarz) Information Criteria for models. 
Either the Restricted Maximum likelihood (<code>REML</code>) or the full likelihood 
(<code>full</code>) can be used. The full likelihood, evaluated using REML estimates 
is used when it is desired to compare models that differ in their fixed models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
infoCriteria(object, DF = NULL, 
            bound.exclusions = c("F","B","S","C"), 
            IClikelihood = "REML", fixedDF = NULL, varDF = NULL, ...)
## S3 method for class 'list'
infoCriteria(object, bound.exclusions = c("F","B","S","C"), 
            IClikelihood = "REML", fixedDF = NULL, varDF = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoCriteria_+3A_object">object</code></td>
<td>
<p>An <code>asreml</code> object resulting from the fitting of a model using REML 
or a <code>list</code> of <code>asreml</code> objects. If the components of the 
<code>list</code> are named, then those names will be used as the 
<code>rownames</code> for the returned <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_df">DF</code></td>
<td>
<p>A <code>numeric</code> giving the number of estimated variance parameters. If
<code>NULL</code> then this is determined from the information in 
<code>object</code>. This argument has been replaced by <code>varDF</code>, 
but is retained for compatibility with legacy code. It is not 
available with the <code>list</code> method.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying the bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters. If set to <code>NULL</code> then none will 
be excluded.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> specifying whether Restricted Maximum Likelihood 
(<code>REML</code>) or the full likelihood, evaluated using REML estimates, 
(<code>full</code>) are to be used in calculating the information criteria 
for <code>family</code> set to <code>asr_gaussian</code>. 
For <code>family</code> set to <code>asr_binomial</code> 
or <code>asr_poisson</code> and with <code>dispersion</code> set to 1, the 
<code>deviance</code> is extracted from <code>object</code> and used to calculate 
the AIC and BIC (as suggested by Damian Collins); the setting of 
<code>IClikelihood</code> is ignored and the log-likelihood set to <code>NA</code>. 
The information criteria are not valid for other settings of 
<code>family</code> and <code>dispersion</code>.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_fixeddf">fixedDF</code></td>
<td>
<p>A <code>numeric</code> giving the number of estimated fixed parameters. If
<code>NULL</code> then this is determined from the information in 
<code>object</code>. For <code>object</code> a <code>list</code> only a single value 
that is used for all components of the <code>list</code> has been 
implemented.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_vardf">varDF</code></td>
<td>
<p>A <code>numeric</code> giving the number of estimated variance parameters. If
<code>NULL</code> then this is determined from the information in 
<code>object</code>. It replaces the <code>DF</code> argument. 
For <code>object</code> a <code>list</code> only a single value 
that is used for all components of the <code>list</code> has been 
implemented.</p>
</td></tr>
<tr><td><code id="infoCriteria_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance degrees of freedom (varDF) are the number of number of variance parameters that 
have been estimated, excluding those whose estimates have a code for <code>bound</code> 
specified in <code>bound.exclusions</code>. If <code>varDF</code> is not <code>NULL</code>, the supplied value 
is used. Otherwise <code>varDF</code> is determined from the information in <code>object</code>, 
i.e. if <code>object</code> is an <code>asreml</code> object then from it, or if <code>object</code> is a 
<code>list</code> then from each <code>asreml</code> object in the <code>list</code>. 
Similarly, the fixed degrees of freedom (fixedDF) are the number of number of fixed parameters 
that have been estimated, any coefficients that have the value <code>NA</code> being excluded. 
If <code>fixedDF</code> is not <code>NULL</code>, the supplied value is used. Otherwise <code>fixedDF</code> 
is determined from the information in <code>object</code>.
</p>
<p>If ASReml-R version 4 is being used then the codes specified in <code>bound.exclusions</code> are 
not restricted to a subset of the default codes, but a warning is issued if a code other 
than these is specified. 
For ASReml-R version 3, only a subset of the default codes are allowed:
<code>F</code> (<code>Fixed</code>), <code>B</code> (<code>Boundary</code>), <code>C</code> (<code>Constrained</code>) and 
<code>S</code> (<code>Singular</code>).  
</p>
<p>The calculation of the information criteria is an adaptation of the code supplied in File S1 
of Verbyla (2019). The log-likelihood is calculated as 
<code>loglik = log(REML) - log(|C|)/2</code>, 
where C is the inverse coefficient matrix; the term involving <b>C</b> is omitted for <code>REML</code>. 
The AIC is calculated as <code>- 2 * loglik + 2 * (varDF + fixedDF)</code> 
and the BIC as <code>- 2 * loglik + (fixedDF + varDF) * log(n - r + fixedDF)</code>, 
where <code>n</code> is the number of observations and <code>r</code> is the rank of the fixed effects 
design matrix. For <code>REML</code>, <code>fixedDF = 0</code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the numbers of estimated fixed (fixedDF) and variance (varDF) 
parameters, the number of bound parameters (NBound), AIC, BIC and the value of the 
log-likelihood (loglik). All elements of the <code><a href="base.html#topic+data.frame">data.frame</a></code> will be set to <code>NA</code> 
for the invalid combinations of family and dispersion as noted in the <code>IClikelihood</code> argument. 
If <code>object</code> is a <code>list</code> and its components are named, then those names will be used to 
set the <code>rownames</code> of the <code>data.frame</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Verbyla, A. P. (2019). A note on model selection using information criteria for general 
linear models estimated using REML. <em>Australian &amp; New Zealand Journal of Statistics</em>, 
<b>61</b>, 39&ndash;50. <a href="https://doi.org/10.1111/anzs.12254">doi:10.1111/anzs.12254</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   data(Wheat.dat)
   ## Fit several models to the wheat data and calculate their ICs
   # Fit initial model
   m.max &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                   random = ~ Row + Column + units,
                   residual = ~ ar1(Row):ar1(Column), 
                   data=Wheat.dat)
   infoCriteria(m.max.asr, IClikelihood = "full")

   #Drop term for within Column pairs
   m1 &lt;- asreml(yield ~ Rep + Variety, 
                random = ~ Row + Column + units,
                residual = ~ ar1(Row):ar1(Column), 
                data=Wheat.dat)
  
   #Drop nugget term
   m2 &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                random = ~ Row + Column,
                residual = ~ ar1(Row):ar1(Column), 
                data=Wheat.dat)

   #Drop Row autocorrelation
   m3 &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                   random = ~ Row + Column + units,
                   residual = ~ Row:ar1(Column), 
                   data=Wheat.dat)

   #Drop Col autocorrelation
   m4 &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                random = ~ Row + Column + units,
                residual = ~ ar1(Row):Column, 
                data=Wheat.dat)

   mods.asr &lt;- list(m.max, m1, m2, m3, m4)
   infoCriteria(mods.asr, IClikelihood = "full")


## End(Not run)</code></pre>

<hr>
<h2 id='is.alldiffs'>Tests whether an object is of class alldiffs</h2><span id='topic+is.alldiffs'></span>

<h3>Description</h3>

<p>A single-line <code>function</code> that tests whether an object is of <code>class</code> <code>alldiffs</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.alldiffs(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code>object</code> to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>,  <code><a href="#topic+is.alldiffs">is.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    den.df &lt;- min(Var.preds$df)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL

  ## Form an all.diffs object
   Var.diffs &lt;- as.alldiffs(predictions = Var.preds, classify = "Nitrogen:Variety", 
                            sed = Var.sed, vcov = Var.vcov, tdf = den.df)

  ## check the class of Var.diffs
  is.alldiffs(Var.diffs)
  }
</code></pre>

<hr>
<h2 id='is.asrtests'>Tests whether an object is of class asrtests</h2><span id='topic+is.asrtests'></span>

<h3>Description</h3>

<p>A single-line <code>function</code> that tests whether an object is of <code>class</code> <code>asrtests</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.asrtests(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.asrtests_+3A_object">object</code></td>
<td>
<p>An <code>object</code> to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+asrtests.object">asrtests.object</a></code>,  <code><a href="#topic+is.asrtests">is.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dae)
library(asreml)
library(asremlPlus)
## use ?Wheat.dat for data set details
data(Wheat.dat)

# Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)

# Load current fit into an asrtests object
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

# check the class of current.asrt
is.asrtests(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='is.predictions.frame'>Tests whether an object is of class predictions.frame</h2><span id='topic+is.predictions.frame'></span>

<h3>Description</h3>

<p>A single-line <code>function</code> that tests whether an object is of <code>class</code> <code>predictions.frame</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.predictions.frame(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.predictions.frame_+3A_object">object</code></td>
<td>
<p>An <code>object</code> to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+predictions.frame">predictions.frame</a></code>,  <code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code>, <code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- as.predictions.frame(Var.pred$pvals, se = "std.error", 
                                    est.status = "status")
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
  }

  if (exists("Var.preds"))
  {
    ## Check the class and validity of the alldiffs object
    is.predictions.frame(Var.preds)
  }
</code></pre>

<hr>
<h2 id='iterate.asrtests'>Subject the fitted <code>asreml.obj</code> stored in an <code>asrtests.object</code> 
to further iterations of the fitting process.</h2><span id='topic+iterate.asrtests'></span><span id='topic+iterate'></span>

<h3>Description</h3>

<p>In an effort to improve convergence, subject the fitted <code>asreml.obj</code> stored 
in an <code><a href="#topic+asrtests.object">asrtests.object</a></code> to further iterations of the fitting process; 
the model specification is not changed. While no change is made to the 
<code>test.summary</code>, the <code>wald.tab</code> is updated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
iterate(asrtests.obj, denDF="numeric", trace = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="iterate.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="iterate.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="iterate.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>update.asreml</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3-class <code>asrtests</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+asrtests.object">asrtests.object</a></code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  current.asrt &lt;- iterate(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='Ladybird.dat'>Data for an experiment to investigate whether ladybirds transfer aphids</h2><span id='topic+Ladybird.dat'></span>

<h3>Description</h3>

<p>Welham et al. (2015, Example 8.2) describe a three-factor factorial experiment to investigate whether ladybirds transfer fungus to live aphids on plants. The three factors are Host plant (beans, trefoil), infected Cadavers (5, 10, 20), and Ladybird (-, +). A generalized randomized complete-block design is used to assign the three factors  to 2 Runs, each of which involves 36 containers with a plant and live aphids. The response to be analyzed is the logit of the proportion of live aphids that were infected.
</p>
<p>The columns in the data frame are: ID, Run, Plant, Host, Ladybird, Cadavers, Live, Infected, logitP, Prop. The column ID numbers the observations. 
Live, Infected, logitP, Prop are response variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ladybird.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 72 observations of 10 variables.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Welham, S. J., Gezan, S. A., Clark, S. J., &amp; Mead, A. (2015). <em>Statistical Methods in Biology: Design and Analysis of Experiments and Regression</em>. Boca Raton: Chapman and Hall/CRC.. 
</p>

<hr>
<h2 id='linTransform.alldiffs'>Calculates a linear transformation of the predictions stored in an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+linTransform.alldiffs'></span><span id='topic+linTransform'></span>

<h3>Description</h3>

<p>Effects the linear transformation of the predictions in the 
supplied <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, the transformation being specified 
by a <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="stats.html#topic+formula">formula</a></code>. The values of 
the transformed values are stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
A <code><a href="base.html#topic+matrix">matrix</a></code> might be a contrast <code><a href="base.html#topic+matrix">matrix</a></code> or 
a <code><a href="base.html#topic+matrix">matrix</a></code> of weights for the levels of a 
<code><a href="base.html#topic+factor">factor</a></code> used to obtain the weighted average over  
the levels of that <code><a href="base.html#topic+factor">factor</a></code>. A <code><a href="stats.html#topic+formula">formula</a></code> gives 
rise to a projection <code><a href="base.html#topic+matrix">matrix</a></code> that linearly transforms 
the predictions so that they conform to the model specified by the 
<code><a href="stats.html#topic+formula">formula</a></code>, this model being a submodel of that inherent 
in the <code>classify</code>. 
</p>
<p>If <code>pairwise = TRUE</code>, all pairwise differences between the 
linear transforms of the <code>predictions</code>, their standard errors, 
p-values and LSD statistics are computed as using 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>. 
This adds them to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as additional 
<code>list</code> components named <code>differences</code>, <code>sed</code>, 
<code>p.differences</code> and <code>LSD</code>.
</p>
<p>If a transformation has been applied (any one of 
<code>transform.power</code> is not one, <code>scale</code> is  not one and 
<code>offset</code> is nonzero), the backtransforms of the transformed 
values and of the lower and upper limits of their <code>error.intervals</code> 
are added to a <code>data.frame</code> that is consistent with a 
<code><a href="#topic+predictions.frame">predictions.frame</a></code>.  If <code>transform.power</code> is other than 
one, the <code>standard.error</code> column of the <code>data.frame</code> 
is set to <code>NA</code>. This <code>data.frame</code> is added to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as a <code>list</code> component called 
<code>backtransforms</code>.
</p>
<p>The printing of the components produced is controlled by the 
<code>tables</code> argument. The order of plotting the levels of 
one of the factors indexing the predictions can be modified 
and is achieved using <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
linTransform(alldiffs.obj, classify = NULL, term = NULL, 
             linear.transformation = NULL, Vmatrix = FALSE, 
             error.intervals = "Confidence", 
             avsed.tolerance = 0.25, accuracy.threshold = NA, 
             LSDtype = "overall", LSDsupplied = NULL, 
             LSDby = NULL, LSDstatistic = "mean", 
             LSDaccuracy = "maxAbsDeviation", 
             zero.tolerance = .Machine$double.eps ^ 0.5, 
             response = NULL, response.title = NULL, 
             x.num = NULL, x.fac = NULL, 
             tables = "all", level.length = NA, 
             pairwise = TRUE, alpha = 0.05,
             inestimable.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linTransform.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_classify">classify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table corresponding to the 
<code>predictions</code> in <code>alldiffs.obj</code>. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_term">term</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that define the term 
that was fitted using <code>asreml</code> and that corresponds to <code>classify</code>. 
It only needs to be specified when it is different to <code>classify</code>; it 
is stored as an attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
It is likely to be needed when the fitted model includes terms that involve  
both a <code><a href="base.html#topic+numeric">numeric</a></code> covariate and a <code><a href="base.html#topic+factor">factor</a></code> that 
parallel each other; the <code>classify</code> would include the covariate and 
the <code>term</code> would include the <code>factor</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_linear.transformation">linear.transformation</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>. 
If a <code><a href="stats.html#topic+formula">formula</a></code> is given then it is taken to be a submodel of 
a model term corresponding to the <code>classify</code>. The projection matrix 
that transforms the <code>predictions</code> so that they conform to the submodel 
is obtained; the submodel does not have to involve variables in the 
<code>classify</code>, but the variables must be columns in the <code>predictions</code> 
component of <code>alldiffs.obj</code> and the space for the submodel must be a 
subspace of the space for the term specified by the <code>classify</code>. 
For example, for <code>classify</code> set to <code>"A:B"</code>, the submodel 
<code>~ A + B</code> will result in the <code>predictions</code> for the combinations of 
<code>A</code> and <code>B</code> being made additive for the <code><a href="base.html#topic+factor">factor</a>s</code> 
<code>A</code> and <code>B</code>. The submodel space corresponding to <code>A + B</code> is 
a subspace of the space <code>A:B</code>. In this case both the submodel and the 
classify involve only the factors A and B. To fit an intercept-only 
submodel, specify <code>linear.transformation</code> to be the formula <code>~1</code>.
</p>
<p>If a <code><a href="base.html#topic+matrix">matrix</a></code> is provided then it will be 
used to apply the linear transformation to the <code>predictions</code>. 
The number of rows in the <code><a href="base.html#topic+matrix">matrix</a></code> should equal the 
number of linear combinations of the <code>predictions</code> desired and 
the number of columns should equal the number of <code>predictions</code>.
</p>
<p>In either case, as well as the values of the linear combinations, 
their standard errors, pairwise differences and associated statistics 
are returned.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_vmatrix">Vmatrix</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the variance matrix of the 
<code>predictions</code> will be stored as a component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
that is returned. If <code>linear.transformation</code> is set, it will 
be stored irrespective of the value of <code>Vmatrix</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string indicating the type of error interval, if any, 
to calculate in order to indicate uncertainty in the results. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. The default is for confidence limits to 
be used. The <code>"halfLeastSignificant"</code> option results in half the 
Least Significant Difference (LSD) being added and subtracted to the 
predictions, the LSD being calculated using the square root of the mean of the 
variances of all or a subset of pairwise differences between the predictions. 
If the LSD is zero, as can happen when predictions are constrained to be equal,
then the limits of the error intervals are set to <code>NA</code>. 
If <code>LSDtype</code> is set to <code>overall</code>, the <code>avsed.tolerance</code> is not 
<code>NA</code> and the range of the SEDs divided by the average of the SEDs exceeds 
<code>avsed.tolerance</code> then the <code>error.intervals</code> calculations and the plotting 
will revert to confidence intervals.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_avsed.tolerance">avsed.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the SED range, the range of the SEDs 
divided by the square root of the mean of the variances of all or a subset of the 
pairwise differences, that is considered reasonable in calculating 
<code>error.intervals</code>. To have it ignored, set it to <code>NA</code>. It should be a 
value between 0 and 1. The following rules apply:
</p>

<ol>
<li><p> If <code>avsed.tolerance</code> is <code>NA</code> then mean LSDs of the type specified by 
<code>LSDtype</code> are calculated and used in <code>error.intervals</code> and plots.
</p>
</li>
<li><p> Irrespective of the setting of <code>LSDtype</code>, if <code>avsed.tolerance</code> is not 
exceeded then the mean LSDs are used in <code>error.intervals</code> and plots. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>overall</code>, <code>avsed.tolerance</code> is not 
<code>NA</code>, and <code>avsed.tolerance</code> is exceeded then  <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>factor.combinations</code> and <code>avsed.tolerance</code> 
is not exceeded for any factor combination then the half LSDs are 
used in <code>error.intervals</code> and plots; otherwise, <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>per.prediction</code> and <code>avsed.tolerance</code> 
is not exceeded for any prediction then the half LSDs are used in <code>error.intervals</code> 
and plots; otherwise, <code>error.intervals</code> and plotting revert to confidence intervals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_accuracy.threshold">accuracy.threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value of the LSD accuracy measure,  
which measure is specified by <code>LSDaccuracy</code>, as a threshold value in determining whether the 
<code>hallfLeastSignificant</code> <code>error.interval</code> for a predicted value is a reasonable  
approximation; this will be the case if the LSDs across all pairwise comparisons for which 
the interval's LSD was computed, as specified by <code>LSDtype</code> and <code>LSDby</code>, 
are similar enough to the interval's LSD, as measured by <code>LSDaccuracy</code>.  
If it is <code>NA</code>, it will be ignored. If it is 
not <code>NA</code>, a column of <code><a href="base.html#topic+logical">logical</a>s</code> named <code>LSDwarning</code>  will be added 
to the <code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The value of 
<code>LSDwarning</code> for a <code>predicted.value</code> will be <code>TRUE</code> if the value of the 
<code>LSDaccuracy</code> measure computed from the LSDs for differences between this 
<code>predicted.value</code> and the other <code>predicted.values</code> as compared to its 
<code>assignedLSD</code> exceeds the value of <code>accuracy.threshold</code>. Otherwise, the 
value of <code>LSDwarning</code> for a <code>predicted.value</code> will be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_zero.tolerance">zero.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value such that if a <code>predicted.value</code>, 
its variance-covariance, or an <code>LSD</code> is less than it, the LSD will be 
considered to be zero.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable for the 
predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> .</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_response.title">response.title</code></td>
<td>
<p>A <code>character</code> specifying the title for the response variable 
for the predictions. It is stored as an attribute to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_x.num">x.num</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the numeric covariate that 
(i) is potentially included in terms in the fitted model and (ii) is the 
x-axis variable for plots. Its values will not be converted to a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_x.fac">x.fac</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor that 
(i) corresponds to <code>x.num</code> and (ii) is potentially included in 
terms in the fitted model. It should have the same number of levels as the 
number of unique values in <code>x.num</code>. The levels of 
<code>x.fac</code> must be in the order in which they are to be plotted 
- if they are dates, then they should be in the form 
yyyymmdd, which can be achieved using <code>as.Date</code>. However, the levels
can be non-numeric in nature, provided that <code>x.num</code> is also set.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_tables">tables</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector containing a combination of 
<code>none</code>, 
<code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code>, <code>sed</code>, <code>LSD</code> and <code>all</code>.
These nominate which components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> to print.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_level.length">level.length</code></td>
<td>
<p>The maximum number of characters from the levels of 
factors to use in the row and column labels of the tables of 
pairwise differences and their p-values and standard errors.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_pairwise">pairwise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether all pairwise differences of the
<code>predictions</code> and their standard errors and p-values are to be 
computed and stored. If <code>tables</code> is equal to 
<code>"differences"</code> or <code>"all"</code> or <code>error.intervals</code> is 
equal to <code>"halfLeastSignificant"</code>, they will be stored 
irrespective of the value of <code>pairwise</code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_inestimable.rm">inestimable.rm</code></td>
<td>
<p>A <code>logical</code> indicating whether rows for  predictions 
that are not estimable are to be removed from the components of 
the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="linTransform.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a matrix <code class="reqn">\mathbf{L}</code>, vector of 
predictions <code class="reqn">\mathbf{p}</code> and variance matrix of the predictions 
<code class="reqn">\mathbf{V}_p</code>, the linear transformed predictions are given 
by <code class="reqn">\mathbf{Lp}</code> with variance matrix <code class="reqn">\mathbf{LV}_p\mathbf{L}^\mathrm{T}</code>. 
The last matrix is used to compute the variance of pairwise 
differences between the transformed values. 
</p>
<p>The <code><a href="base.html#topic+matrix">matrix</a></code> <code class="reqn">\mathbf{L}</code> is directly specified by setting 
<code>linear.transformation</code> to it. If <code>linear.transformation</code> is a 
<code><a href="stats.html#topic+formula">formula</a></code> then <code class="reqn">\mathbf{L}</code> is formed as the sum of the 
orthogonal projection matrices obtained using <code>pstructure.formula</code> 
from the package <code>dae</code>; <code>grandMean</code> is set to <code>TRUE</code> and 
<code>orthogonalize</code> to <code>"eigenmethods"</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with the linear transformation of the predictions 
and their standard errors and all pairwise differences between the linear 
transforms of their predictions, their standard errors and p-values 
and LSD statistics.
</p>
<p>If the supplied <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> contained a <code>backtransforms</code> 
component, then the returned <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> will contain 
a <code>backtransforms</code> component with the backtransformed linear transformation 
of the predictions. The backtransformation will, after backtransforming for any 
power transformation, subtract the <code>offset</code> and then divide by the <code>scale</code>.
</p>
<p>If <code>error.intervals</code> is not <code>"none"</code>, then the 
<code>predictions</code> component and, if present, the 
<code>backtransforms</code> component will contain columns for the lower 
and upper values of the limits for the interval. The names of these 
columns will consist of three parts separated by full stops: 
1) the first part will be <code>lower</code> or <code>upper</code>; 
2) the second part will be one of <code>Confidence</code>, 
<code>StandardError</code> or <code>halfLeastSignificant</code>; 
3) the third component will be <code>limits</code>.
</p>
<p>The name of the <code>response</code>, the <code>response.title</code>, 
the <code>term</code>, the <code>classify</code>, <code>tdf</code>, <code>alpha</code>, <code>sortFactor</code> 
and the <code>sortOrder</code> will be set as attributes to the object.
Also, if <code>error.intervals</code> is <code>"halfLeastSignificant"</code>, then those of 
<code>LSDtype</code>, <code>LSDby</code> and <code>LSDstatistic</code> that are not <code>NULL</code> 
will be added as attributes of the object and of the <code>predictions frame</code>; 
additionally, <code>LSDvalues</code> will be added as attribute of the 
<code>predictions frame</code>, <code>LSDvalues</code> being the LSD values used in 
calculating the <code>error.intervals</code>. 
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+linTransform">linTransform</a></code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>,  <br />
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <br /> 
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>,  
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, <br />
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>,  
<code>as.Date</code>, <code>predict.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
#Get additive predictions directly using predictPlus
diffs.sub &lt;- predictPlus.asreml(classify = "Sources:Species", Vmatrix = TRUE, 
                                linear.transformation = ~ Sources + Species,
                                asreml.obj = current.asr, tables = "none", 
                                wald.tab = current.asrt$wald.tab, 
                                present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * Species) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  SS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Species)
  SS.preds &lt;- summary(SS.emm)
  den.df &lt;- min(SS.preds$df, na.rm = TRUE)
  ## Modify SS.preds to be compatible with a predictions.frame
  SS.preds &lt;- as.predictions.frame(SS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  SS.vcov &lt;- vcov(SS.emm)
  SS.diffs &lt;- allDifferences(predictions = SS.preds, classify = "Sources:Species", 
                             vcov = SS.vcov, tdf = den.df)
  validAlldiffs(SS.diffs)

  #Get additive predictions
  diffs.sub &lt;- linTransform(SS.diffs, classify = "Sources:Species", 
                            linear.transformation = ~ Sources + Species,
                            Vmatrix = TRUE, tables = "none")
}  
 
##Calculate contrasts from prediction obtained using asreml or lmerTest 
if (exists("diffs.sub"))
{ 
  #Contrast matrix for differences between each species and non-planted for the last source
  L &lt;- cbind(matrix(rep(0,7*32), nrow = 7, ncol = 32),
             diag(1, nrow = 7), 
             matrix(rep(-1, 7), ncol = 1))
  rownames(L) &lt;- as.character(diffs.sub$predictions$Species[33:39])
  diffs.L &lt;- linTransform(diffs.sub, 
                          classify = "Sources:Species",
                          linear.transformation = L,
                          tables = "predictions")
}
</code></pre>

<hr>
<h2 id='loadASRemlVersion'>Ensures that a specific version of <code>asreml</code> is loaded.</h2><span id='topic+loadASRemlVersion'></span>

<h3>Description</h3>

<p>Loads the specified version of <code>asreml</code>, provided that it is not already loaded. If the version of <code>asreml</code> is not the required version, then the loaded version is unloaded first.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadASRemlVersion(version = 4, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadASRemlVersion_+3A_version">version</code></td>
<td>
<p>The <code>version</code> that is to be loaded, the version consisting of just the initial 
characters that are significant in the version that should be loaded. 
For example, the default value of 4 implies that any version that 
begins with <code>"4"</code> is acceptable. It is used to check that the 
required version is loaded.</p>
</td></tr>
<tr><td><code id="loadASRemlVersion_+3A_...">...</code></td>
<td>
<p>Other library/require arguments that are needed to load the specified <code>version</code> of <code>asreml</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character, being all characters in the version of asreml that is loaded on exit from the function.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+getASRemlVersionLoaded">getASRemlVersionLoaded</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loadASRemlVersion(3, lib.loc = "D:\Analyses\R asreml3")
## End(Not run)</code></pre>

<hr>
<h2 id='LSD.frame'>Description of an LSD frame</h2><span id='topic+LSD.frame'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> that stores  
Least Significant differences (LSDs) for <code>predictions</code> for a fitted model.</p>


<h3>Value</h3>

<p>A <code>data.frame</code> that can be a component of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> and that 
contains LSD values and statistics to be used in determining the significance of the 
pairwise differences. In particular, they are used in calculating 
<code>halfLeastSignificant</code> limits to be included in a <code>predictions.frame</code>.
</p>
<p>Exactly what an <code>LSD.frame</code> contains is 
determined by the following arguments to functions that return an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>: <code>LSDtype</code>, <code>LSDby</code>, <code>LSDstatistic</code>, 
<code>LSDaccuracy</code> and <code>LSDsupplied</code>. The <code>rownames</code> of the <code>LSD.frame</code> 
indicate, for each of its rows, for what group of predictions the entries in the row were calculated, 
this being controlled by the <code>LSDtype</code> and <code>LSDby</code> arguments. The values for 
all of the LSD arguments are stored as attributes to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> and the 
<code>predictions</code> and, if present <code>backtransforms</code>, components of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
<p>An <code>LSD.frame</code> always has the eight columns <code>c</code>, <code>minimumLSD</code>, <code>meanLSD</code>, 
<code>maximumLSD</code>, <code>assignedLSD</code>, <code>accuracyLSD</code>, <code>falsePos</code> and 
<code>falseNeg</code>.
</p>

<ol>
<li> <p><code>c</code>: This gives the number of pairwise comparison of predictions for the combinations of 
the factor levels given by the row name. If the row name is <code>overall</code> then it is for 
all predictions.
</p>
</li>
<li> <p><code>minimumLSD, meanLSD, maximumLSD</code>: These are computed for either <code>overall</code>, 
<code>factor.combinations</code>, <code>per.prediction</code> or <code>supplied</code> LSD values, as specified by the 
<code>LSDtype</code> argument.  The <code>meanLSD</code> is calculated using the square root of the mean of 
the variances of set of pairwise differences appropriate to the specific <code>LSDtype</code> argument.
</p>
<p>For <code>overall</code>, the mean, minimum and maximum of the LSDs for all pairwise 
comparisons are computed.  
</p>
<p>If <code>factor.combinations</code> was specified for 
<code>LSDtype</code> when the LSDs were being calculated, then the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
contains a row for each combination of the values of the <code><a href="base.html#topic+factor">factor</a>s</code> and 
<code><a href="base.html#topic+numeric">numeric</a>s</code> specified by <code>LSDby</code>. The values in a row  are calculated 
from the LSD values for the pairwise differences for each combination of the 
<code><a href="base.html#topic+factor">factor</a>s</code> and <code><a href="base.html#topic+numeric">numeric</a>s</code> values, unless there is only one 
prediction for a combination, when notional LSDs are calculated that are based on the 
standard error of the prediction multiplied by the square root of two. 
</p>
<p>For <code>per.prediction</code>, the minimum, mean and maximum LSD, based, for each prediction, 
on the LSD values for all pairwise differences involving that prediction are computed.
</p>
<p>For <code>supplied</code>, the <code>LSD.frame</code> is set up based on the setting of <code>LSDby</code>: 
a single row with name <code>overall</code> if <code>LSDby</code> is <code>NULL</code> or, if <code>LSDby</code> 
is a vector of <code><a href="base.html#topic+factor">factor</a></code> and <code><a href="base.html#topic+numeric">numeric</a></code> names, rows for each observed 
combinations of the values of the named <code><a href="base.html#topic+factor">factor</a>s</code> and <code><a href="base.html#topic+numeric">numeric</a>s</code>. 
The <code>LSDsupplied</code> argument is used to provide the values to be stored in the column 
<code>assignedLSD</code>.
</p>
</li>
<li> <p><code>assignedLSD</code>: The <code>assignedLSD</code> column contains the values that are assigned for 
use in calculating <code>halfLeastSignificant</code> <code>error.intervals</code>. Its contents are 
determined by <code>LSDstatistic</code> and <code>LSDsupplied</code> arguments. The 
<code>LSDsupplied</code> argument allows the direct specification of values to be placed 
in the <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code>. The default is to use the 
values in the <code>meanLSD</code> column.
</p>
</li>
<li> <p><code>LSDaccuracy</code>: The <code>LSDaccuracy</code> gives an indication of the proportion that the 
correct LSD for a single <code>predicted.value</code> might deviate from its <code>assignedLSD</code> value. 
The contents of the <code>accuracyLSD</code> column is controlled by the <code>LSDaccuracy</code> 
argument.
</p>
</li>
<li> <p><code>falsePos</code> and <code>falseNeg</code>: These columns contain the number of false positives 
and negatives if the <code>assignedLSD</code> value(s) is(are) used to determine the significance 
of the pairwise predictions differences. Each LSD value in the <code>assignedLSD</code> 
column is used to determine the significance of pairwise differences that involve 
predictions for the combination of values given by the row name for the LSD value.
</p>
</li></ol>

<p>See <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code> for more information.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>, 
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, <br /> 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.diffs &lt;- predictPlus(m1.asr, classify="Nitrogen:Variety", 
                          wald.tab = current.asrt$wald.tab, 
                          tables = "none")
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
   if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    #Get predictions
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL

    #Set up an alldiffs object, which includes overall LSDs
    Var.diffs &lt;- allDifferences(predictions = Var.preds, classify = "Variety:Nitrogen", 
                                     sed = Var.sed, vcov = Var.vcov, tdf = 45)
  }

  if (exists("Var.diffs"))
  {
    ## Use recalcLSD to get LSDs for within Variety differences
    Var.LSD.diffs &lt;- recalcLSD(Var.diffs, 
                               LSDtype = "factor.combinations", LSDby = "Variety")
    print(Var.LSD.diffs$LSD)
  }
</code></pre>

<hr>
<h2 id='makeTPPSplineMats.data.frame'>Make the spline basis matrices and data needed to fit Tensor Product P-splines.</h2><span id='topic+makeTPPSplineMats.data.frame'></span><span id='topic+makeTPPSplineMats'></span>

<h3>Description</h3>

<p>Prepares the fixed and random P-spline basis matrices, and associated 
information, that are needed for fitting of Tensor Product P-splines (TPPS) 
as described by Rodriguez-Alvarez et al. (2018). This function is called 
internally by <code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code>, 
<code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code> and 
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code> when fitting <code>TPPS</code> models 
for local spatial variation. There are two methods available, controlled by 
<code>asreml.option</code> for creating and storing the basis functions. 
This function is most likely to be called directly when <code>mbf</code> has been used 
in creating an <code>asreml.object</code> and it is desired to use the object in a 
session subsequent to the session in which the object was created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
makeTPPSplineMats(data, sections = NULL, 
                  row.covar, col.covar, 
                  nsegs = NULL, nestorder = c(1,1), 
                  degree = c(3,3), difforder = c(2,2),
                  rotateX = FALSE, theta = c(0,0), 
                  asreml.option = "grp", mbf.env = sys.frame(), 
                  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_data">data</code></td>
<td>
<p>An <code><a href="base.html#topic+data.frame">data.frame</a></code> that holds the spline bases for a section. 
It is indexed by columns named <code>col</code> and <code>row</code>.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_sections">sections</code></td>
<td>
<p>A single <code>character</code> string that species the name of the column 
in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the <code><a href="base.html#topic+factor">factor</a></code> 
that identifies different sections of the data 
to which separate spatial models are to be fitted.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_row.covar">row.covar</code></td>
<td>
<p>A single <code><a href="base.html#topic+character">character</a></code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
column in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the values of a 
covariate indexing the rows of the grid.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_col.covar">col.covar</code></td>
<td>
<p>A single <code><a href="base.html#topic+character">character</a></code> string nominating a <code><a href="base.html#topic+numeric">numeric</a></code> 
column in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the values of a 
covariate indexing the columns of the grid.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_nsegs">nsegs</code></td>
<td>
<p>A pair of <code><a href="base.html#topic+numeric">numeric</a></code> values giving the number of segments into
which the column and row ranges are to be split, respectively, for fitting 
a P-spline model (<code>TPPS</code>) (each value specifies the number of internal 
knots + 1). If not specified, then (number of unique values - 1) is used 
in each dimension; for a grid layout with equal spacing, this gives a knot 
at each data value. If <code>sections</code> is not <code>NULL</code> and the grid 
differs between the <code>sections</code>, then <code>nsegs</code> will differ between 
the <code>sections</code>.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_nestorder">nestorder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of nesting for column 
and row dimensions, respectively, in fitting a P-spline model (<code>TPPS</code>). 
A value of 1 specifies no nesting, a value of 2 generates a spline with 
half the number of segments in that 
dimension, etc. The number of segments in each direction must be a 
multiple of the order of nesting.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_degree">degree</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code>  of length 2. The degree of polynomial spline to 
be used for column and row dimensions respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_difforder">difforder</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The order of differencing for 
column and row dimensions, respectively, in fitting a P-spline 
(<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_rotatex">rotateX</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to rotate the eigenvectors of the 
penalty matrix, as described by Piepho, Boer and Williams (2022), when 
fitting a P-spline (<code>TPPS</code>). Setting <code>rotateX</code> to <code>TRUE</code> 
results in a search for an optimized rotation under a model that omits 
the random spline interaction terms. If <code>ngridangles</code> is set to 
<code>NULL</code>, the optimal rotation us found using an optimizer 
(<code>nloptr::bobyqa</code>). Otherwise, the optimal rotation is found by 
exploring the fit over a  two-dimensional grid of rotation angle pairs. 
The optimization seeks to optimize the criterion nominated in 
<code>which.rotacriterion</code>. Rotation of the eigenvectors is only relevant 
for <code>difforder</code> values greater than 1 and has only been implemented 
for <code>difforder</code> equal to 2.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_theta">theta</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> of length 2. The angle (in degrees) to be used in 
rotating the eignevectors of the penalty matrix of a P-spline (<code>TPPS</code>).</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_asreml.option">asreml.option</code></td>
<td>
<p>A single <code>character</code> string specifying whether the <code>grp</code> or 
<code>mbf</code> methods are to be used to supply externally formed covariate 
matrices to <code>asreml</code> when fitting a P-spline (<code>TPPS</code>). Compared 
to the <code>mbf</code> method, the <code>grp</code> method is somewhat faster, but 
creates large <code><a href="#topic+asrtests.object">asrtests.object</a></code>s for which the time it takes 
to save them can exceed any gains in execution speed. The <code>grp</code> 
method adds columns to the <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the <code>data</code>. 
On the other hand, the <code>mbf</code> method adds only the fixed covariates 
to <code>data</code> and stores the random covariates in the environment of the 
internal function that calls the spline-fitting function; there are three smaller 
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> for each <code>section</code> that are not stored in the 
<code>asreml.object</code> resulting from the fitted model.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_mbf.env">mbf.env</code></td>
<td>
<p>A <code><a href="base.html#topic+environment">environment</a></code> specifying the environment to which the 
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> containing the spline bases are to be assigned. 
If <code>mbf.env</code> is <code>NULL</code>, the data.frames will not be assigned.</p>
</td></tr>
<tr><td><code id="makeTPPSplineMats.data.frame_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>tpsmmb</code> from package <code>TPSbits</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objects are formed using the function <code>tpsmmb</code> from the <code>R</code> package <code>TPSbits</code> 
authored by Sue Welham (2022). This function has been extended to allow for <code>sections</code> (see below) 
and to allow rotation of the penalty matrix for the linear component of the interaction terms in 
<code>TPPCS</code> models (for more information about rotation see Piepho, Boer and Williams, 2022).
</p>
<p>Each combination of a <code>row.covar</code> and a <code>col.covar</code> does not have to specify a 
single observation; for example, to fit a local spatial variation model to the main units 
of a split-unit design, each combination would correspond to a main unit and all subunits 
of the main unit would have the same combination.
</p>
<p>The data for experiment can be divided <code>sections</code> and the spline bases and associated 
data will be produced for each section. If there is more than one <code>sections</code>, then a 
<code><a href="base.html#topic+list">list</a></code> is returned that has a component for each section. The component for 
a section contains:
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of length equal to the number of sections is produced. Each of 
these components is a <code><a href="base.html#topic+list">list</a></code> with 8 or 9 components. The component 
named <code>data.plus</code>, being the input <code><a href="base.html#topic+data.frame">data.frame</a></code> to which has been added 
the columns required to fit the <code>TPPS</code> model (the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored 
in the <code>data</code> component holds only the covariates from <code>data</code>).
</p>
<p>List of length 8 or 9 (according to the <code>asreml.option</code>).
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required 
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:diff.c = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:diff.r = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:(diff.c*diff.r) = interaction between the
two X parts for use in fixed model. The first variate is 
a constant term which should be omitted from the model when the constant 
(1) is present. If all elements are included in the model then the 
constant term should be omitted,eg. 
<code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis 
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>mbflist</code> = list that can be used in call to asreml (so long as Z 
matrix data frames extracted with right names, eg BcZ&lt;stub&gt;.df)
</p>
</li>
<li> <p><code>BcZ.df</code> = mbf data frame mapping onto smooth part of column
spline, last column (labelled <code>TP.col</code>) gives column index
</p>
</li>
<li> <p><code>BrZ.df</code> = mbf data frame mapping onto smooth part of row spline,
last column (labelled <code>TP.row</code>) gives row index
</p>
</li>
<li> <p><code>BcrZ.df</code> = mbf data frame mapping onto smooth x smooth term, last
column (labelled <code>TP.CxR</code>) maps onto col x row combined index
</p>
</li>
<li> <p><code>dim</code> = list structure, holding dimension values relating to the
model:
</p>

<ol>
<li> <p><code>"diff.c"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbc"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbcn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
<li> <p><code>"diff.r"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbr"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbrn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li></ol>

</li>
<li> <p><code>trace</code> = list of trace values for ZGZ' for the random TPspline
terms, where Z is the design matrix and G is the known diagonal variance
matrix derived from eigenvalues. This can  be used to rescale the spline 
design matrix (or equivalently variance components).
</p>
</li>
<li> <p><code>grp</code> = list structure, only added for setting <code>asreml="grp"</code>. 
For <code>asreml="grp"</code>, provides column indexes for each of the 5 
random components of the 2D splines in <code>data.plus</code>. Dimensions of 
the components can be derived from the values in the <code>dim</code> item.  
</p>
</li>
<li> <p><code>data.plus</code> = the input <code><a href="base.html#topic+data.frame">data.frame</a></code> to which has been  
added the columns required to fit tensor product splines in <code>asreml-R</code>. 
This <code><a href="base.html#topic+data.frame">data.frame</a></code> can be used to fit the TPS model.  
FOr multiple <code>sections</code>, this <code><a href="base.html#topic+data.frame">data.frame</a></code> will occur 
in the component for each section. If <code>asreml.option</code> is set to 
<code>mbf</code>, then this component will have the <code>attribute</code> <code>mbf.env</code> 
that specifies the environment to which the <code><a href="base.html#topic+data.frame">data.frame</a>s</code> 
containing the spline bases have been assigned. 
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H-P, Boer, M. P. &amp; Williams, E. R. (2022) Two-dimensional P-spline smoothing for spatial analysis of plant breeding trials. <em>Biometrical Journal</em>, <b>64</b>, 835-857.)
</p>
<p>Rodriguez-Alvarez, M. X., Boer, M. P., van Eeuwijk, F. A., &amp; Eilers, P. H. C. (2018). Correcting for spatial heterogeneity in plant breeding experiments with P-splines. <em>Spatial Statistics</em>, <b>23</b>, 52-71. 
</p>
<p>Welham, S. J. (2022) <code>TPSbits</code>: <em>Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R.</em> Version 1.0.0 <a href="https://mmade.org/tpsbits/">https://mmade.org/tpsbits/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+addSpatialModel.asrtests">addSpatialModel.asrtests</a></code>, <code><a href="#topic+addSpatialModelOnIC.asrtests">addSpatialModelOnIC.asrtests</a></code>, <br /> 
<code><a href="#topic+chooseSpatialModelOnIC.asrtests">chooseSpatialModelOnIC.asrtests</a></code>, <code>tpsmmb</code> from <code>TPSbits</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(Wheat.dat)

#Add row and column covariates
Wheat.dat &lt;- within(Wheat.dat, 
                    {
                      cColumn &lt;- dae::as.numfac(Column)
                      cColumn &lt;- cColumn  - mean(unique(cColumn))
                      cRow &lt;- dae::as.numfac(Row)
                      cRow &lt;- cRow - mean(unique(cRow))
                    })

#Set up the matrices
tps.XZmat &lt;- makeTPPSplineMats(wheat.dat, 
                                row.covar = "cRow", col.covar = "cColumn")

## End(Not run)</code></pre>

<hr>
<h2 id='newfit.asreml'>Refits an <code>asreml</code> model with changed arguments by extracting, modifying 
and evaluating its <code>call</code> - an alternate to update.asreml.</h2><span id='topic+newfit.asreml'></span><span id='topic+newfit'></span>

<h3>Description</h3>

<p>Extracts the call from the <code>asreml.obj</code> and evaluates that call, 
replacing supplied <code>asreml</code> arguments with changed values. 
If <code>update</code> is <code>TRUE</code> and <code>set.terms</code> is <code>NULL</code>, 
the call is evaluated using the variance parameter estimates 
from the <code>call</code> stored in <code>asreml.obj</code>; if some 
variance terms in the newly fitted model are singular (S) or 
bound (B), a refit of the model will be tried in which the 
variance parameter estimates in <code>asreml.obj</code> are not used 
and will become the fitted model if its boundary terms are a 
subset of those in the fitted model stored in <code>asreml.obj</code>. 
If <code>update</code> is <code>FALSE</code> or <code>set.terms</code> is not 
<code>NULL</code>, the previous values of the variance parameters 
are not used as initial values for fitting the new model; 
<code>G.param</code> and <code>R.param</code> are set to <code>NULL</code> or 
to values as specified for <code>set.terms</code>. The <code>...</code> 
argument can be used to pass <code>G.param</code> and/or 
<code>R.param</code>, provided <code>update</code> is <code>FALSE</code> and 
<code>set.terms</code> is <code>NULL</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
newfit(asreml.obj, fixed., random., sparse., 
       residual., rcov., update = TRUE, trace = FALSE, 
       allow.unconverged = TRUE, allow.fixedcorrelation = TRUE,
       keep.order = TRUE, 
       set.terms = NULL, ignore.suffices = TRUE, 
       bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newfit.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>A valid <code>asreml</code> object with 
a component named <code>call</code> (from a previous 
call to either <code>asreml</code> or <code>update.asreml</code>).</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_fixed.">fixed.</code></td>
<td>
<p>A character or formula specifying changes to the fixed 
formula. This is a two-sided formula 
where &quot;.&quot; is substituted for existing components in the 
fixed component of <code>asreml.obj$call</code>. If changes are 
specified, the fixed terms will be reordered so that 
single-variable terms come first, followed by two-variable 
terms and so on.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_random.">random.</code></td>
<td>
<p>A character or formula specifying changes to the random 
formula. This is a one-sided formula 
where &quot;.&quot; is substituted for existing components in the 
random component of <code>asreml.obj$call</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_sparse.">sparse.</code></td>
<td>
<p>A character or formula specifying changes to the sparse 
formula. This is a one-sided formula 
where &quot;.&quot; is substituted for existing components in the 
sparse component of <code>asreml.obj$call</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_residual.">residual.</code></td>
<td>
<p>A character or formula specifying changes to the error 
formula, used when version 4 or later of ASReml-R is loaded.
This is a one-sided formula 
where &quot;.&quot; is substituted for existing components in the 
residual component of <code>asreml.obj$call</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_rcov.">rcov.</code></td>
<td>
<p>A character or formula specifying changes to the error 
formula, used when version 3 of ASReml-R is loaded. 
This is a one-sided formula 
where &quot;.&quot; is substituted for existing components in the 
residual component of <code>asreml.obj$call</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_update">update</code></td>
<td>
<p>A logical indicating whether to use the variance parameter 
estimates in fitting a new model using <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>. 
If <code>update</code> is <code>TRUE</code> and <code>set.terms</code> is <code>NULL</code>, 
the call stored in the <code>asreml.obj</code> is evaluated using the 
variance parameter estimates stored in <code>R.param</code> and 
<code>G.param</code>, as well as the changes specified in the 
arguments to <code>newfit.asreml</code>. If <code>FALSE</code> or   
<code>set.terms</code> is not <code>NULL</code>, then the use of previous 
values of the variance parameters as initial values is not 
enforced; <code>G.param</code> and <code>R.param</code> are set to 
<code>NULL</code> or to values as specified for <code>set.terms</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_trace">trace</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that control output from ASReml-R. 
If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit does not 
converge, the supplied <code>asreml.obj</code> is returned.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asreml.obj</code> is returned. The fit in the supplied 
the <code>asreml.obj</code> will also be tested and a warning issued if 
both fixed correlations are found in it and 
<code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_keep.order">keep.order</code></td>
<td>
<p>A logical value indicating whether the terms should keep 
their positions. If <code>FALSE</code> the terms are reordered so 
that main effects come first, followed by the interactions, 
all second-order, all third-order and so on. Effects of a 
given order are kept in the order specified.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting.
The names must match those in the <code>vparameters</code> component of the 
new <code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="newfit.asreml_+3A_...">...</code></td>
<td>
<p>additional arguments to the call, or arguments with changed 
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>asreml</code> object.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+convAsremlobj.asreml">convAsremlobj.asreml</a></code>, <code>update.asreml</code>, <code><a href="#topic+setvarianceterms.call">setvarianceterms.call</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    m2.asreml &lt;- newfit(m1.asreml, random. = "~ . - Blocks:Plots", maxiter=75)

## End(Not run)</code></pre>

<hr>
<h2 id='num.recode'>Recodes the unique values of a vector using the values in a new vector.</h2><span id='topic+num.recode'></span>

<h3>Description</h3>

<p>Recodes the unique values of a variate using the value in position
i of the <code>new.values</code> vector to replace the ith 
sorted <code>unique</code> values of x. The new levels do
not have to be unique.</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.recode(x, new.values)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.recode_+3A_x">x</code></td>
<td>
<p>The <code>vector</code> to be recoded.</p>
</td></tr>
<tr><td><code id="num.recode_+3A_new.values">new.values</code></td>
<td>
<p>A <code>vector</code> of length <code>unique(x)</code> containing values to use in 
the recoding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>dae::fac.recast</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor with labels
x &lt;- rep(c(-42, -14, 14, 42), 4)
 
## recode x
b &lt;- num.recode(x, c(0, 28, 56, 84))
</code></pre>

<hr>
<h2 id='Oats.dat'>Data for an experiment to investigate nitrogen response of 3 oats varieties</h2><span id='topic+Oats.dat'></span>

<h3>Description</h3>

<p>Yates (1937) describes a split-plot experiment that investigates the effects of three varieties of oats and four levels of Nitrogen fertilizer. The varieties are assigned to the main plots using a randomized complete block design with 6 blocks and the nitrogen levels are randomly assigned  to the subplots in each main plot.
</p>
<p>The columns in the data frame are: Blocks, Wplots, Subplots, Variety, Nitrogen, xNitrogen, Yield. The column xNitrogen is a numeric version of the factor Nitrogen.
The response variable is Yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oats.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 72 observations of 7 variables.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Yates, F. (1937). The Design and Analysis of Factorial Experiments. <em>Imperial Bureau of Soil Science, Technical Communication</em>, <b>35</b>, 1-95. 
</p>

<hr>
<h2 id='pairdiffsTransform.alldiffs'>Calculates the differences between nominated pairs of predictions stored in 
an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+pairdiffsTransform.alldiffs'></span><span id='topic+pairdiffsTransform'></span>

<h3>Description</h3>

<p>Predictions of differences and their error intervals are formed for two levels of 
a factor, the <code>pairs.factor</code>. For each pair of a level of the 
<code>pairs.factor</code> in <code>numerator.levels</code> with a level in 
<code>denominator.levels</code>, an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is formed that 
contains the differences between predictions with this pair of levels for all of 
the combinations of the levels of the other factors in the <code>classify</code> of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. These prediction differences are obtained using 
<code><a href="#topic+linTransform">linTransform</a></code> by forming a suitable contrast matrix to specify 
the <code>linear.transformation</code>. This function has the advantage that the 
factors indexing the differences are included in the components of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>s.
</p>
<p>If <code>pairwise = TRUE</code>, all pairwise differences between the 
linear transforms of the <code>predictions</code>, their standard errors, 
p-values and LSD statistics are computed as using 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>. 
This adds them to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as additional 
<code>list</code> components named <code>differences</code>, <code>sed</code>, 
<code>p.differences</code> and <code>LSD</code>.
</p>
<p>The printing of the components produced is controlled by the 
<code>tables</code> argument. The order of plotting the levels of 
one of the factors indexing the predictions can be modified 
and is achieved using <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
pairdiffsTransform(alldiffs.obj, pairs.factor, first.levels, second.levels, 
                   Vmatrix = FALSE, error.intervals = "Confidence", 
                   avsed.tolerance = 0.25, accuracy.threshold = NA, 
                   LSDtype = "overall", LSDsupplied = NULL, LSDby = NULL, 
                   LSDstatistic = "mean", LSDaccuracy = "maxAbsDeviation", 
                   response = NULL, response.title = NULL, tables = "all", 
                   pairwise = TRUE, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_pairs.factor">pairs.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor 
for whose levels the differences are to be calculated.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_first.levels">first.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string containing the levels of the <code>pairs.factor</code>
whose predictions are those subtracted from.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_second.levels">second.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string containing the levels of the <code>pairs.factor</code>
whose predictions are those that are subtracted.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_vmatrix">Vmatrix</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the variance matrix of the 
<code>predictions</code> will be stored as a component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
that is returned.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string indicating the type of error interval, if any, 
to calculate in order to indicate uncertainty in the results. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. The default is for confidence limits to 
be used. The <code>"halfLeastSignificant"</code> option results in half the 
Least Significant Difference (LSD) being added and subtracted to the 
predictions, the LSD being calculated using the square root of the mean of the 
variances of all or a subset of pairwise differences between the predictions. 
If the LSD is zero, as can happen when predictions are constrained to be equal,
then the limits of the error intervals are set to <code>NA</code>. 
If <code>LSDtype</code> is set to <code>overall</code>, the <code>avsed.tolerance</code> is not 
<code>NA</code> and the range of the SEDs divided by the average of the SEDs exceeds 
<code>avsed.tolerance</code> then the <code>error.intervals</code> calculations and the plotting 
will revert to confidence intervals.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_avsed.tolerance">avsed.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the SED range, the range of the SEDs 
divided by the square root of the mean of the variances of all or a subset of the 
pairwise differences, that is considered reasonable in calculating 
<code>error.intervals</code>. To have it ignored, set it to <code>NA</code>. It should be a 
value between 0 and 1. The following rules apply:
</p>

<ol>
<li><p> If <code>avsed.tolerance</code> is <code>NA</code> then mean LSDs of the type specified by 
<code>LSDtype</code> are calculated and used in <code>error.intervals</code> and plots.
</p>
</li>
<li><p> Irrespective of the setting of <code>LSDtype</code>, if <code>avsed.tolerance</code> is not 
exceeded then the mean LSDs are used in <code>error.intervals</code> and plots. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>overall</code>, <code>avsed.tolerance</code> is not 
<code>NA</code>, and <code>avsed.tolerance</code> is exceeded then  <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>factor.combinations</code> and <code>avsed.tolerance</code> 
is not exceeded for any factor combination then the half LSDs are 
used in <code>error.intervals</code> and plots; otherwise, <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>per.prediction</code> and <code>avsed.tolerance</code> 
is not exceeded for any prediction then the half LSDs are used in <code>error.intervals</code> 
and plots; otherwise, <code>error.intervals</code> and plotting revert to confidence intervals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_accuracy.threshold">accuracy.threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value of the LSD accuracy measure,  
which measure is specified by <code>LSDaccuracy</code>, as a threshold value in determining whether the 
<code>hallfLeastSignificant</code> <code>error.interval</code> for a predicted value is a reasonable  
approximation; this will be the case if the LSDs across all pairwise comparisons for which 
the interval's LSD was computed, as specified by <code>LSDtype</code> and <code>LSDby</code>, 
are similar enough to the interval's LSD, as measured by <code>LSDaccuracy</code>.  
If it is <code>NA</code>, it will be ignored. If it is 
not <code>NA</code>, a column of <code><a href="base.html#topic+logical">logical</a>s</code> named <code>LSDwarning</code>  will be added 
to the <code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The value of 
<code>LSDwarning</code> for a <code>predicted.value</code> will be <code>TRUE</code> if the value of the 
<code>LSDaccuracy</code> measure computed from the LSDs for differences between this 
<code>predicted.value</code> and the other <code>predicted.values</code> as compared to its 
<code>assignedLSD</code> exceeds the value of <code>accuracy.threshold</code>. Otherwise, the 
value of <code>LSDwarning</code> for a <code>predicted.value</code> will be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable for the 
predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> .</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_response.title">response.title</code></td>
<td>
<p>A <code>character</code> specifying the title for the response variable 
for the predictions. It is stored as an attribute to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_tables">tables</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector containing a combination of 
<code>none</code>, <code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code>, <code>sed</code>, <code>LSD</code> and <code>all</code>.  
These nominate which components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> to print.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_pairwise">pairwise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether all pairwise differences of the
<code>predictions</code> and their standard errors and p-values are to be 
computed and stored. If <code>tables</code> is equal to 
<code>"differences"</code> or <code>"all"</code> or <code>error.intervals</code> is 
equal to <code>"halfLeastSignificant"</code>, they will be stored 
irrespective of the value of <code>pairwise</code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals. 
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pairdiffsTransform.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>s with a component for each combination 
of a <code>first.levels</code> with a <code>second.levels</code>. The name of a component will be 
a level from <code>first.levels</code> combined with a level from <code>second.levels</code>, 
separated by a comma. If the <code>predictions</code> in the supplied <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
are based on a <code>response</code> that was transformed, each <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
in the <code>list</code> will include a <code>backtransforms</code> component that contains   
a column labelled <code>backtransformed.predictions</code>, along with the backtransforms of 
the nominated <code>error.intervals</code>. The <code>predictions</code> and <code>backtransforms</code> 
components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> will be indexed by the variables in the 
<code>classify</code> of <code>alldiffs.obj</code>, except that the <code>pairs.factor</code> is omitted.  
If the transformation was the logarithmic transformation, these 
<code>backtransformed.predictions</code> are predicted ratios of the untransformed <code>response</code>. 
</p>
<p>If <code>sortFactor</code> attribute is set and is not the 
<code>ratio.factor</code>, the predictions and, if present, their backtransforms will be sorted using 
the <code>sortOrder</code> attribute of the  <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>,
and both <code>sortFactor</code> and <code>sortOrder</code> will be set as attributes to the object.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+linTransform">linTransform</a></code>, <code><a href="#topic+ratioTransform">ratioTransform</a></code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, 
<code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <br /> 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>,  <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <br />
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, <br />
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, 
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <br />
<code>as.Date</code>, <code>predict.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Form the differences for log(RGR) for Salinity
load(system.file("extdata", "testDiffs.rda", package = "asremlPlus", mustWork = TRUE))
#### For the ratios for Cl per WU Temperature - use backtransforms of log-predictions
Preds.ratio.ClUp &lt;- pairdiffsTransform(diffs.ClUp, 
                                       pairs.factor = "Temperature", 
                                       first.levels = "Hot",
                                       second.levels = "Cool",
                                       error.intervals = "halfLeast",
                                       tables = "backtransforms") #Backtransforms are ratios

#### Form the differences for Nitrogen compared to no Nitrogen                                  
data("Oats.dat")
## Not run: 
m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                 random=~Blocks/Wplots,
                 data=Oats.dat)
current.asrt &lt;- as.asrtests(m1.asr)
wald.tab &lt;-  current.asrt$wald.tab
Var.diffs &lt;- predictPlus(m1.asr, classify="Nitrogen:Variety", pairwise = TRUE,
                         Vmatrix = TRUE, error.intervals = "halfLeast",
                         LSDtype = "factor", LSDby = "Variety",
                         wald.tab = wald.tab)

## End(Not run)

 ## Use lme4 and emmmeans to get predictions and associated statistics
if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
  ## Set up a wald.tab
  int &lt;- as.data.frame(rbind(rep(NA,4)))
  rownames(int) &lt;- "(Intercept)"
  wald.tab &lt;- anova(m1.lmer, ddf = "Kenward", type = 1)[,3:6]
  names(wald.tab) &lt;- names(int) &lt;- c("Df", "denDF", "F.inc", "Pr")
  wald.tab &lt;- rbind(int, wald.tab)
  #Get predictions
  Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
  Var.preds &lt;- summary(Var.emm)
  ## Modify Var.preds to be compatible with a predictions.frame
  Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                    se = "SE", interval.type = "CI", 
                                    interval.names = c("lower.CL", "upper.CL"))
  Var.vcov &lt;- vcov(Var.emm)
  Var.sed &lt;- NULL
  den.df &lt;- wald.tab[match("Variety", rownames(wald.tab)), "denDF"]
  
  #Create alldiffs object
  Var.diffs &lt;- as.alldiffs(predictions = Var.preds, 
                           sed = Var.sed, vcov = Var.vcov, 
                           classify = "Nitrogen:Variety", response = "Yield", tdf = den.df)
} 

if (exists("Var.diffs"))
  Preds.diffs.OatsN &lt;- pairdiffsTransform(alldiffs.obj = Var.diffs,
                                          pairs.factor = "Nitrogen", 
                                          first.levels = c("0.2","0.4","0.6"),
                                          second.levels = "0", error.intervals = "halfLeast",
                                          tables = "none")
</code></pre>

<hr>
<h2 id='permute.square'>Permutes the rows and columns of a square matrix.</h2><span id='topic+permute.square'></span>

<h3>Description</h3>

<p>Permutes the rows and columns of a square matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.square(x, permutation)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute.square_+3A_x">x</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
<tr><td><code id="permute.square_+3A_permutation">permutation</code></td>
<td>
<p>A vector specifying the new order of rows and columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square <code>matrix</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+permute.to.zero.lowertri">permute.to.zero.lowertri</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  terms.marginality &lt;-  matrix(c(1,0,0,0,0,  0,1,0,0,0, 0,1,1,0,0, 
                                 1,1,1,1,0, 1,1,1,1,1), nrow=5)
  permtn &lt;- c(1,3,2,4,5)
  terms.marginality &lt;- permute.square(terms.marginality, permtn)
</code></pre>

<hr>
<h2 id='permute.to.zero.lowertri'>Permutes a square matrix until all the lower triangular elements are zero.</h2><span id='topic+permute.to.zero.lowertri'></span>

<h3>Description</h3>

<p>Permutes a square matrix until all the lower triangular elements are zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.to.zero.lowertri(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute.to.zero.lowertri_+3A_x">x</code></td>
<td>
<p>A square matrix of order n with at least n*(n-1)/2 zero elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square <code>matrix</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+permute.square">permute.square</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  terms.marginality &lt;-  matrix(c(1,0,0,0,0,  0,1,0,0,0, 0,1,1,0,0, 
                                 1,1,1,1,0, 1,1,1,1,1), nrow=5)
  terms.marginality &lt;- permute.to.zero.lowertri(terms.marginality)
</code></pre>

<hr>
<h2 id='pickLSDstatistics.alldiffs'>Pick LSDstatistics whose values minimize the number of errors in pairwise comparisons of predictions.</h2><span id='topic+pickLSDstatistics.alldiffs'></span><span id='topic+pickLSDstatistics'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with an <code>sed</code> component, 
<code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code> is used to calculate the LSD values for each set of 
prediction comparisons specified by <code>LSDtype</code> and <code>LSDby</code> using each of the 
statistics <code>minimum</code>, <code>q10</code>, <code>q25</code>,  <code>mean</code>, <code>median</code>, <code>q75</code>, 
<code>q90</code>  and <code>maximum</code>. Then the numbers of false positives and 
false negatives resulting from employing each of the calculated LSDs is obtained. For 
each set of comparisons, the LSD value(s) with the lowest number of false positives are 
identified and, from these, the smallest value with the lowest number of false negatives. 
That is, a conservative approach is taken to picking LSD values by putting the priority on 
avoiding false positives. Before using the LSDstatistics that this function suggests, the number 
of false positives and negatives generated by them should be checked. For example, it may be 
that there are too many false negatives and a better balance between the numbers of false 
positives and negatives can be identified using <code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code>,</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
pickLSDstatistics(alldiffs.obj, 
                  LSDtype = "overall", LSDby = NULL, 
                  alpha = 0.05, digits = 3, 
                  false.pos.wt = NULL, retain.zeroLSDs = FALSE, 
                  zero.tolerance = .Machine$double.eps ^ 0.5, 
                  ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code> or <code>factor.combinations</code>. 
It determines whether the LSD values that are investigated and stored are  
(i) the <code>overall</code> minimum, quantile10, quantile25, mean, median, quantile75, quantile90, 
and maximum of all pairwise LSDs, or 
(ii) the minimum, quantile10, quantile25, mean, median, quantile75, quantile90, and maximum 
for the pairwise LSDs for each combination of the values of the <code><a href="base.html#topic+factor">factor</a>s</code> and 
<code><a href="base.html#topic+numeric">numeric</a>s</code> named in <code>LSDby</code>, unless there is only one prediction for a 
combination, when notional LSDs are calculated. The <code>LSDtype</code> specified here does not 
have to match that used in the creating the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on how the LSD statistics are calculated.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of the values the of the <code><a href="base.html#topic+factor">factor</a>s</code> and <code><a href="base.html#topic+numeric">numeric</a>s</code>, the 
LSD errors are to be computed when <code>LSDtype</code> is <code>factor.combinatons</code>. The <code>LSDby</code> 
specified here does not have to match that used in the creating the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the significance level for an LSD to compare a pair of 
predictions.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_digits">digits</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of significant digits to retain in rounding 
the LSDs before determining the distinct rounded LSDs.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_false.pos.wt">false.pos.wt</code></td>
<td>
<p>When it is not <code>NULL</code>, it should be a <code><a href="base.html#topic+numeric">numeric</a></code> that specifies the 
weight (e.g. 3) to apply to the number of false positives in calculating the weighted sums of  
the numbers of false positives and negatives in using different LSD statistics to compare 
pairs of predictions. The <code>LSDstatistic</code> that is chosen for making comparisons will be 
the one that minimizes the weighted sum. If it is <code>NULL</code>, the <code>LSDstatistic</code> 
will chosen as the one that minimizes the number of false negatives from amongst those that 
minimize the number of false positives.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_retain.zerolsds">retain.zeroLSDs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to retain or omit LSDs that are zero when 
calculating the summaries of LSDs.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_zero.tolerance">zero.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value such that if an LSD is less than it, the LSD will be 
considered to be zero.</p>
</td></tr>
<tr><td><code id="pickLSDstatistics.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+character">character</a></code> of length one for <code>LSDby</code> set to <code>overall</code> or of length equal to the 
number of observed combinations of the values of the <code><a href="base.html#topic+factor">factor</a>s</code> and <code><a href="base.html#topic+numeric">numeric</a>s</code> 
in <code>LSDby</code>. Each element of the returned <code><a href="base.html#topic+character">character</a></code> is one of <code>minimum</code>, 
<code>q10</code>, <code>q25</code>,  <code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code>, 
reflecting the value(s) of the LSD from amongst those calculated that minimizes the number of false 
positives; if there is more than one such value, then the element will be correspond to the value 
of the LSD from amongst those with the minimum number of false positives that minimizes 
the number of false negatives.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code> <code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>, 
<code><a href="#topic+plotLSDs.alldiffs">plotLSDs.alldiffs</a></code>, <br /> 
<code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code>, <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>, <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <br /> 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Pick the LSD values for predictions obtained using asreml or lmerTest  
  LSDstat &lt;- pickLSDstatistics(TS.diffs)
  TS.diffs &lt;- redoErrorIntervals(TS.diffs, LSDstatistic = LSDstat)
  TS.diffs$LSD
  LSDstat &lt;- pickLSDstatistics(TS.diffs, LSDtype = "factor.combinations", 
                         LSDby = "Sources")
  TS.diffs &lt;- redoErrorIntervals(TS.diffs, LSDtype = "factor.combinations", 
                                 LSDby = "Sources", LSDstatistic = LSDstat)
  TS.diffs$LSD
}
</code></pre>

<hr>
<h2 id='plotLSDerrors.alldiffs'>Plots a map of the errors that occur in using the computed LSD values for pairwise differences between predictions.</h2><span id='topic+plotLSDerrors.alldiffs'></span><span id='topic+plotLSDerrors'></span>

<h3>Description</h3>

<p>Produces a plot of the errors that occur in using the computed  LSD values for 
pairwise differences predictions by comparing the result obtained from using the 
LSDs stored in the <code>assignedLSD</code> column of the <code>LSD</code> component of 
the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with those computed from the <code>sed</code> 
component using the <code>t</code>-value for the <code>df</code> stored in the  <code>tdf</code> 
attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The <code>sed</code> component is generally a matrix whose rows and columns 
are labelled by the levels of one or more factors, the set of labels being 
the same for rows and columns. The <code>sections</code> argument allows multiple 
plots to be produced, one for each combination of the levels of the factors 
listed in <code>sections</code>. Otherwise, a single plot is produced for all 
observed combinations of the levels of the factors in the <code>classify</code> 
attribute for the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The plots are produced using 
<code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>. The order of plotting the levels of 
one of the factors indexing the predictions can be modified using 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLSDerrors(object, ...)
## S3 method for class 'alldiffs'
plotLSDerrors(object, alpha = 0.05, useIntervals = FALSE, 
              sections = NULL, gridspacing = 0, factors.per.grid = 0, 
              triangles = "both", title = NULL, 
              axis.labels = TRUE, axis.text.size = 12, 
              sep=",", colours = c("white","blue","red","grey"), 
              ggplotFuncs = NULL, printPlot = TRUE, 
              sortFactor = NULL, sortParallelToCombo = NULL, 
              sortNestingFactor = NULL, sortOrder = NULL, 
              decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with both <code>LSD</code> and  
<code>sed</code> components that are not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for the LSD.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_useintervals">useIntervals</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to use the interval limits 
stored in the <code>predictions</code> component of <code>object</code>, instead of
the LSDs stored in the <code>LSD</code> component, for determining whether 
pairs of predictions are significantly different. It allows a check of how 
the <code>error.intervals</code> in the <code>predictions</code> component will perform 
if they are used for all pairwise predictions comparisons, whereas the 
comparisons to which the LSDs apply 
may be restricted by the setting of the <code>LSDby</code> attribute of 
<code>object</code>. There is no restriction on the <code>error.intervals</code> that 
can be used. However, the limits for them must be in columns 
in the <code>predictions</code> component of <code>object</code> and their names 
must end with <code>.limits</code> and begin with <code>lower.</code> and <code>upper.</code></p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sections">sections</code></td>
<td>
<p>A <code>character</code> listing the names of the factors that are to be used 
to break the plot into sections. A separate plot will be produced for 
each observed combination of the levels of these factors.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. An alternative is to specify 
the <code>factors.per.grid</code> argument to have the grid spacings automatically 
calculated. Grids are most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_factors.per.grid">factors.per.grid</code></td>
<td>
<p>A <code>numeric</code> specifying the number of factors to include 
within each grid of differences. The <code>gridspacing</code> will then be 
computed based on the numbers of combinations observed within the 
levels of the remaining factors in a single plot. The <code>gridspacing</code> 
argument to this function will be ignored if <code>factors.per.grid</code> is 
greater than zero. Grids are most useful when two or more factors index the 
rows and columns of each plot.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_triangles">triangles</code></td>
<td>
<p>A <code>character</code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> triangle(s).</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_title">title</code></td>
<td>
<p>A <code>character</code> string giving the main title for the plot and to which 
is appended the levels combination of the sectioning factors, if any, for each plot.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code>logical</code> indicating whether a label is to be added to the x- and y-axes. 
If TRUE, the label is the comma-separated list of factors whose levels 
combinations are involved in the prediction differences for which the LSD values 
are calculated.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> giving the characters separating the levels of different 
factors in the row and column names of the <code>sed</code> component. </p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_colours">colours</code></td>
<td>
<p>A vector of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
It is passed to <code>ggplot</code> via <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code> 
to be applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>data.frame</code> is required.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> components is for 
increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passsing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components named <code>LSDresults</code> and <code>plots</code>. 
The <code>LSDresults</code> component contains the <code>data.frame</code> with the columns <code>Rows</code>, 
<code>Columns</code>, <code>LSDresults</code>, <code>sections1</code> and <code>sections2</code>. This <code>data.frame</code> 
is formed using the <code>LSD</code> and <code>sed</code> components of <code>object</code> and is used 
by <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code> in producng the plots. The <code>plots</code> 
component contains a list of <code>ggplot</code> objects, one for each plot produced. 
Multiple plots are stored in the <code>plots</code> component if the <code>sections</code> argument 
is set and the plots are are named for the levels combinations of the sections.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code>, <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>, 
<code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>,  <br />
<code><a href="#topic+exploreLSDs">exploreLSDs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, 
<code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18" &amp; Benches != "3")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot LSD values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  plotLSDerrors(TS.diffs, gridspacing = rep(c(3,4), c(4,2)))

  plotLSDerrors(TS.diffs, sections = "Sources", axis.labels = TRUE)
  
}
</code></pre>

<hr>
<h2 id='plotLSDerrors.data.frame'>Plots a map of the supplied errors that occur in using the computed LSD values for pairwise differences between predictions.</h2><span id='topic+plotLSDerrors.data.frame'></span>

<h3>Description</h3>

<p>Produces a plot of the errors that have been supplied in a <code>data.frame</code>. 
The <code>data.frame</code> includes two factors whose levels specify, 
for each LSD result, which combinations of factor levels are being compared. The function
<code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code> produces such <code>data.frame</code>s.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotLSDerrors(object, LSDresults = "LSDresults", x, y, 
              alpha = 0.05, triangles = "both", 
              gridspacing = 0, title = NULL, 
              axis.labels = NULL, axis.text.size = 12, 
              colours = c("white","blue","red","grey"), 
              ggplotFuncs = NULL, printPlot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLSDerrors.data.frame_+3A_object">object</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the three columns specified by 
<code>LSDresults</code>, <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_lsdresults">LSDresults</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>object</code> 
that contains the LSDresults values to be plotted. The column should be a 
<code><a href="base.html#topic+character">character</a></code> or <code><a href="base.html#topic+factor">factor</a></code> with values or levels that are a 
subset of <code>Ok</code>,<code>FN</code>, <code>FP</code> and <code>na</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>object</code> that contains 
the factor whose levels index the LSD values that are to be plotted in the same column.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_y">y</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains 
the labels of the LSD values that are to be plotted as the rows.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for the LSD.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_triangles">triangles</code></td>
<td>
<p>A <code>character</code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> triangle(s). Here it is only used 
to adjust gridlines for the omission of the diagonal.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. This is most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_title">title</code></td>
<td>
<p>A <code>character</code> string giving the main title for the plot.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code>character</code> string giving the label to use for both the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_colours">colours</code></td>
<td>
<p>A vector of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>ggplot</code> object is required.</p>
</td></tr>
<tr><td><code id="plotLSDerrors.data.frame_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<a href="ggplot2.html#topic+ggplot">ggplot</a>&quot;, which can be plotted using <code>print</code> or otherwise manipulated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>, <code><a href="#topic+plotLSDs.alldiffs">plotLSDs.alldiffs</a></code>, 
<code><a href="#topic+exploreLSDs">exploreLSDs</a></code>, <code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp))
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot LSD values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  LSDresults &lt;- within(reshape2::melt(TS.diffs$p.differences), 
                      { 
                        Var1 &lt;- factor(Var1, levels=dimnames(TS.diffs$p.differences)[[1]])
                        Var2 &lt;- factor(Var2, levels=levels(Var1))
                      })
  names(LSDresults) &lt;- c("Rows","Columns","LSDresults")
  plotLSDerrors(LSDresults, x = "Rows", y = "Columns", gridspacing = rep(c(3,4), c(4,2)))
}
</code></pre>

<hr>
<h2 id='plotLSDs.alldiffs'>Plots a heat map of computed LSD values for pairwise differences between predictions.</h2><span id='topic+plotLSDs.alldiffs'></span><span id='topic+plotLSDs'></span>

<h3>Description</h3>

<p>Produces a heat-map plot of the computed  LSD values for pairwise differences between 
predictions by multiplying the values stored in the <code>sed</code> component of an 
<code>alldiffs</code> object by the <code>t</code>-value for the <code>df</code> stored in the  
<code>tdf</code> attribute of the object. 
This component is generally a matrix whose rows and columns 
are labelled by the levels of one or more factors, the set of labels being 
the same for rows and columns. The <code>sections</code> argument allows multiple 
plots to be produced, one for each combination of the levels of the factors 
listed in <code>sections</code>. Otherwise, a single plot is produced for all 
observed combinations of the levels of the factors in the <code>classify</code> 
attribute for the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The plots are produced using 
<code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>. The order of plotting the levels of 
one of the factors indexing the predictions can be modified using 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLSDs(object, ...)
## S3 method for class 'alldiffs'
plotLSDs(object, alpha = 0.05, 
         sections = NULL, gridspacing = 0, factors.per.grid = 0, 
         triangles = "both", 
         title = NULL, axis.labels = TRUE, axis.text.size = 12, 
         sep=",", colours = RColorBrewer::brewer.pal(3, "Set2"), 
         ggplotFuncs = NULL, printPlot = TRUE, 
         sortFactor = NULL, sortParallelToCombo = NULL, 
         sortNestingFactor = NULL, sortOrder = NULL, 
         decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLSDs.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with an <code>sed</code> component that is not 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for the LSD.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sections">sections</code></td>
<td>
<p>A <code>character</code> listing the names of the factors that are to be used 
to break the plot into sections. A separate plot will be produced for 
each observed combination of the levels of these factors.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. An alternative is to specify 
the <code>factors.per.grid</code> argument to have the grid spacings automatically 
calculated. Grids are most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_factors.per.grid">factors.per.grid</code></td>
<td>
<p>A <code>numeric</code> specifying the number of factors to include 
within each grid of differences. The <code>gridspacing</code> will then be 
computed based on the numbers of combinations observed within the 
levels of the remaining factors in a single plot. The <code>gridspacing</code> 
argument to this function will be ignored if <code>factors.per.grid</code> is 
greater than zero. Grids are most useful when two or more factors index the 
rows and columns of each plot.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_triangles">triangles</code></td>
<td>
<p>A <code>character</code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> triangle(s).</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_title">title</code></td>
<td>
<p>A <code>character</code> string giving the main title for the plot and to which 
is appended the levels combination of the sectioning factors, if any, for each plot.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code>logical</code> indicating whether a label is to be added to the x- and y-axes. 
If TRUE, the label is the comma-separated list of factors whose levels 
combinations are involved in the prediction differences for which the LSD values 
are calculated.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> giving the characters separating the levels of different 
factors in the row and column names of the <code>sed</code> component. </p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_colours">colours</code></td>
<td>
<p>A vector of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
It is passed to <code>ggplot</code> via <code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code> 
to be applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>data.frame</code> is required.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> components is for 
increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="plotLSDs.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passsing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components named <code>LSDs</code> and <code>plots</code>. 
The <code>LSDs</code> component contains the <code>data.frame</code> with the columns <code>Rows</code>, 
<code>Columns</code>, <code>LSDs</code>, <code>sections1</code> and <code>sections2</code>. This <code>data.frame</code> is 
formed using the <code>sed</code> component of <code>object</code> and is used by 
<code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code> in producng the plot. The <code>plots</code> 
component contains a list of <code>ggplot</code> objects, one for each plot produced. 
Multiple plots are stored in the <code>plots</code> component if the <code>sections</code> argument 
is set and the plots are are named for the levels combinations of the sections.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLSDs.data.frame">plotLSDs.data.frame</a></code>, <code><a href="#topic+exploreLSDs">exploreLSDs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, 
<code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18" &amp; Benches != "3")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot LSD values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  plotLSDs(TS.diffs, gridspacing = rep(c(3,4), c(4,2)))

  plotLSDs(TS.diffs, sections = "Sources", axis.labels = TRUE)
  
}
</code></pre>

<hr>
<h2 id='plotLSDs.data.frame'>Plots a heat map of computed LSD-values for pairwise differences between predictions.</h2><span id='topic+plotLSDs.data.frame'></span>

<h3>Description</h3>

<p>Produces a heat-map plot of the computed  LSD values for pairwise differences between 
predictions that are stored in a <code>data.frame</code>. The <code>data.frame</code> includes 
two factors whose levels specify, for each LSD value, which combinations of factor 
levels are being compared.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotLSDs(object, LSD = "LSDs", x, y, alpha = 0.05, 
         triangles = "both", gridspacing = 0, 
         title = NULL, axis.labels = NULL, axis.text.size = 12, 
         colours = RColorBrewer::brewer.pal(3, "Set2"), 
         ggplotFuncs = NULL, printPlot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLSDs.data.frame_+3A_object">object</code></td>
<td>
<p>A <code>data.frame</code> containing the three columns specified by <code>LSD</code>, <code>x</code> 
and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_lsd">LSD</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains
the LSD values to be plotted.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_x">x</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains 
the factor whose levels index the LSD values that are to be plotted in the same column.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_y">y</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains 
the labels of the LSD values that are to be plotted as the rows.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for the LSD.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_triangles">triangles</code></td>
<td>
<p>A <code>character</code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> triangle(s). Here it is only used 
to adjust gridlines for the omission of the diagonal.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. This is most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_title">title</code></td>
<td>
<p>A <code>character</code> string giving the main title for the plot.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code>character</code> string giving the label to use for both the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_colours">colours</code></td>
<td>
<p>A vector of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>ggplot</code> object is required.</p>
</td></tr>
<tr><td><code id="plotLSDs.data.frame_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<a href="ggplot2.html#topic+ggplot">ggplot</a>&quot;, which can be plotted using <code>print</code> or otherwise manipulated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLSDs.alldiffs">plotLSDs.alldiffs</a></code>, <code><a href="#topic+plotLSDerrors.alldiffs">plotLSDerrors.alldiffs</a></code>, <code><a href="#topic+plotLSDerrors.data.frame">plotLSDerrors.data.frame</a></code>, <br />
<code><a href="#topic+exploreLSDs">exploreLSDs</a></code>, <code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp))
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot LSD values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  LSD &lt;- within(reshape2::melt(TS.diffs$p.differences), 
              { 
                Var1 &lt;- factor(Var1, levels=dimnames(TS.diffs$p.differences)[[1]])
                Var2 &lt;- factor(Var2, levels=levels(Var1))
              })
  names(LSD) &lt;- c("Rows","Columns","LSDs")
  plotLSDs(LSD, x = "Rows", y = "Columns", gridspacing = rep(c(3,4), c(4,2)))
}
</code></pre>

<hr>
<h2 id='plotPredictions.data.frame'>Plots the predictions for a term, possibly with error bars.</h2><span id='topic+plotPredictions.data.frame'></span><span id='topic+plotPredictions'></span>

<h3>Description</h3>

<p>This function plots the predictions <code>y</code> that are based on 
<code>classify</code> and stored in the <code>data.frame</code> <code>data</code>. The package 
<code>ggplot2</code> is used to produce the plots. Line plots are 
produced when variables involving <code>x.num</code> or <code>x.fac</code> are 
involved in <code>classify</code> for the predictions; otherwise, bar 
charts are produced. Further, for line charts, the argument <code>panels</code> 
determines whether a single plot or multiple plots in a single window 
are produced; for bar charts, the argument <code>panels</code> is 
ignored.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotPredictions(data, classify, y, 
                x.num = NULL, x.fac = NULL, nonx.fac.order = NULL,  
                colour.scheme = "colour", panels = "multiple", 
                graphics.device = NULL,
                error.intervals = "Confidence", interval.annotate = TRUE,
                titles = NULL, y.title = NULL, 
                filestem = NULL, printPlot = TRUE, ggplotFuncs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPredictions.data.frame_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+predictions.frame">predictions.frame</a></code>, or <code>data.frame</code>, containing the 
values of the variables to be plotted. 
Generally, it should contain the variables classifying the predictions 
and include a column with the name specified in the <code>y</code> argument, 
usually <code>predicted.value</code> or <code>backtransformed.predictions</code>; 
each row contains a single predicted value.  It should also include 
columns for the <code>standard.error</code> and <code>est.status</code>. 
The number of rows should equal the number of unique combinations of 
the classifying variables. While such a <code>data.frame</code> 
can be constructed from the beginning, the <code>pvals</code> component 
of the value produced by <code>predict.asreml</code> is a suitable value to 
supply for this argument. Note that the names <code>standard.error</code> and 
<code>est.status</code> have been changed to <code>std.error</code> and <code>status</code> 
in the <code>pvals</code> component produced by <code>asreml-R4</code>; if the new names 
are in the <code>data.frame</code> supplied to <code>predictions</code>, they will be 
returned to the previous names. 
</p>
<p>If <code>error.intervals</code> 
is not <code>"none"</code>, then the <code>predictions</code> component and, 
if present, the <code>backtransforms</code> component should contain 
columns for the lower and upper values of the limits for the interval 
with names that begin with <code>lower</code> and <code>upper</code>, 
respectively. The second part of the name must be one of 
<code>Confidence</code>, <code>StandardError</code> or 
<code>halfLeastSignificant</code>. The last part needs to be consistent 
between the lower and upper limits.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_classify">classify</code></td>
<td>
<p>A character string giving the combinations of the independent 
variables on which the predictions are based. It is 
an interaction type term formed from the independent variables, 
that is, separating the variable names with the <code>:</code> operator. 
To predict the overall mean, set the <code>classify</code> to 
&quot;<code>(Intercept)</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_y">y</code></td>
<td>
<p>A character string giving the name of the variable that is to be plotted 
on the Y axis.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_x.num">x.num</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the numeric covariate that 
(i) is potentially included in terms in the fitted model and (ii) is the 
x-axis variable for plots. Its values will not be converted to a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_x.fac">x.fac</code></td>
<td>
<p>A character string giving the name of the factor that corresponds to 
<code>x.num</code>, is potentially included in terms in the fitted model and 
which corresponds to the x-axis variable. It should have the same 
number of levels as the number of unique values in <code>x.num</code>. 
The levels of <code>x.fac</code> must be in the order in which they are to 
be plotted - if they are dates, then they should be in the form 
yyyymmdd, which can be achieved using <code>as.Date</code>. However, the levels
can be non-numeric in nature, provided that <code>x.num</code> is also set.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_nonx.fac.order">nonx.fac.order</code></td>
<td>
<p>A character vector giving the order in which factors other 
than <code>x.fac</code> are to be plotted in faceted plots (i.e. where the 
number of non x factors is greater than 1). The first factor in the vector 
will be plotted on the X axis (if there is no <code>x.num</code> or 
<code>x.fac</code>. Otherwise, the order of plotting the factors is in 
columns (X facets) and then rows (Y facets). By default the order is 
in decreasing order for the numbers of levels of the non x factors.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_colour.scheme">colour.scheme</code></td>
<td>
<p>A character string specifying the colour scheme for the plots. 
The default is <code>"colour"</code> which produces coloured lines and bars, 
a grey background and white gridlines. A value of <code>"black"</code> 
results in black lines, grey bars and gridlines and a white background.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_panels">panels</code></td>
<td>
<p>Possible values are <code>"single"</code> and <code>"multiple"</code>. 
When line plots are to be produced, because variables involving 
<code>x.num</code> or <code>x.fac</code> are involved in <code>classify</code> for 
the predictions, <code>panels</code> determines whether or not a single 
panel or multiple panels in a single window are produced. The 
<code>panels</code> argument is ignored for bar charts.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_graphics.device">graphics.device</code></td>
<td>
<p>A <code>character</code> specifying a graphics device for plotting. 
The default is <br /><code>graphics.device = NULL</code>, which will result 
in plots being produced on the current graphics device. Setting it to 
<code>"windows"</code>, for example,  will result in a windows graphics 
device being  opened.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A character string indicating the type of error interval, if any, 
to plot in order to indicate uncertainty in the results. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. Here, any option other than <code>"none"</code> 
will result in the interval limits contained in <code>data</code> being plotted. </p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_interval.annotate">interval.annotate</code></td>
<td>
<p>A <code>logical</code> indicating whether the plot annotation indicating the 
type of <code>error.interval</code> is to be included in the plot.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_titles">titles</code></td>
<td>
<p>A <code>list</code>, each component of which is named for a column in 
the <code>data.frame</code> for the <code>asreml.obj</code> used in making the predictions 
and contains a <code>character string</code> giving a title to use 
in output (e.g. tables and graphs). Here they will be used for 
axis labels for nonresponse variables. For response variable labels 
see <code>y.title</code>.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_y.title">y.title</code></td>
<td>
<p>The title to be displayed on the y axis of any plot.</p>
</td></tr> 
<tr><td><code id="plotPredictions.data.frame_+3A_filestem">filestem</code></td>
<td>
<p>A character sting giving the beginning of the name of the file in which to 
save the plot. If <code>filestem = NULL</code>, the plot is not saved. The remainder 
of the file name will be generated automatically and consists of the 
following elements separated by full stops: the classify term, 
<code>Bar</code> or <code>Line</code> and, if <code>error.intervals</code> 
is not <code>"none"</code>, one of <code>SE</code>, <code>CI</code> or <code>LSI</code>. The
file will be saved as a &lsquo;png&rsquo; file in the current work directory.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>ggplot</code> object is required.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.
These functions are applied in creating the <code>ggplot</code> object for plotting.</p>
</td></tr>
<tr><td><code id="plotPredictions.data.frame_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<a href="ggplot2.html#topic+ggplot">ggplot</a>&quot;, which can be plotted using <code>print</code> or otherwise manipulated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <br /> 
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <code>ggplot</code>, <code>Devices</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(WaterRunoff.dat)
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = log.Turbidity ~ Benches + Sources + Type + Species +
                                Sources:Type + Sources:Species + 
                                Sources:xDay + Species:xDay + Species:Date,
                      data = WaterRunoff.dat, keep.order = TRUE)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

#### Get the observed combinations of the factors and variables in classify
class.facs &lt;- c("Species","Date","xDay")
levs &lt;- as.data.frame(table(WaterRunoff.dat[class.facs]))
levs &lt;- as.list(levs[levs$Freq != 0, class.facs])
levs$xDay &lt;- as.numfac(levs$xDay)

predictions &lt;- predict(current.asr, classify="Species:Date:xDay", 
                       parallel = TRUE, levels = levs, 
                       present = c("Type","Species","Sources"))
#### for asreml-R3
predictions &lt;- predictions$predictions$pvals
predictions &lt;- predictions[predictions$est.status == "Estimable",]
#### for asreml-R4
predictions &lt;- predictions$pvals
predictions &lt;- predictions[predictions$status == "Estimable",]
#### end
plotPredictions(classify="Species:Date:xDay", y = "predicted.value", 
                data = predictions, 
                x.num = "xDay", x.fac = "Date", 
                x.title = "Days since first observation",
                y.title = "Predicted log(Turbidity)",
                present = c("Type","Species","Sources"),
                error.intervals = "none",
                ggplotFuncs = list(ggtitle("Transformed turbidity over time")))
  
diffs &lt;- predictPlus(classify="Species:Date:xDay", 
                     present=c("Type","Species","Sources"), 
                     asreml.obj = current.asr, tables = "none", 
                     x.num = "xDay", x.fac = "Date", 
                     parallel = TRUE, levels = levs, 
                     x.plot.values=c(0,28,56,84),
                     wald.tab = current.asrt$wald.tab)
x.title &lt;- "Days since first observation"
names(x.title) &lt;- "xDay"
plotPredictions(classify="Species:Date:xDay", y = "predicted.value", 
               data = diffs$predictions, 
               x.num = "xDay", x.fac = "Date", 
               titles = x.title,
               y.title = "Predicted log(Turbidity)")

## End(Not run)

## Use lmerTest and emmmeans to get predictions and associated statistics
if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  data(Ladybird.dat)
  m1.lmer &lt;- lmerTest::lmer(logitP ~ Host*Cadavers*Ladybird + (1|Run),
                            data=Ladybird.dat)
  HCL.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Host:Cadavers:Ladybird)
  HCL.preds &lt;- summary(HCL.emm)
  den.df &lt;- min(HCL.preds$df)
  ## Modify HCL.preds to be compatible with a predictions.frame
  HCL.preds &lt;- as.predictions.frame(HCL.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  ## Plot the predictions
  plotPredictions(HCL.preds, y = "predicted.value", "Host:Cadavers:Ladybird")
}
</code></pre>

<hr>
<h2 id='plotPvalues.alldiffs'>Plots a heat map of p-values for pairwise differences between predictions.</h2><span id='topic+plotPvalues.alldiffs'></span><span id='topic+plotPvalues'></span>

<h3>Description</h3>

<p>Produces a heat-map plot of the p-values for pairwise differences between 
predictions that is stored in the <code>p.differences</code> component of an 
<code>all.diffs</code> object. This is generally a matrix whose rows and columns 
are labelled by the levels of one or more factors, the set of labels being 
the same for rows and columns. The <code>sections</code> argument allows multiple 
plots to be produced, one for each combination of the levels of the factors 
listed in <code>sections</code>. Otherwise, a single plot is produced for all 
observed combinations of the levels of the factors in the <code>classify</code> 
for the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The plots are produced using 
<code><a href="#topic+plotPvalues.data.frame">plotPvalues.data.frame</a></code>. The order of plotting the levels of 
one of the factors indexing the predictions can be modified using 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPvalues(object, ...)
## S3 method for class 'alldiffs'
plotPvalues(object, sections = NULL, 
            gridspacing = 0, factors.per.grid = 0, 
            show.sig = FALSE, alpha = 0.10, 
            sig.size = 3, sig.colour = "black", 
            sig.face = "plain", sig.family = "",  
            triangles = "both", 
            title = NULL, axis.labels = TRUE, axis.text.size = 12, 
            sep=",", colours = RColorBrewer::brewer.pal(3, "Set2"), 
            ggplotFuncs = NULL, printPlot = TRUE, 
            sortFactor = NULL, sortParallelToCombo = NULL, 
            sortNestingFactor = NULL, sortOrder = NULL, 
            decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPvalues.alldiffs_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with a <code>p.differences</code> component that is not 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sections">sections</code></td>
<td>
<p>A <code>character</code> listing the names of the factors that are to be used 
to break the plot into sections. A separate plot will be produced for 
each observed combination of the levels of these factors.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. An alternative is to specify 
the <code>factors.per.grid</code> argument to have the grid spacings automatically 
calculated. Grids are most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_factors.per.grid">factors.per.grid</code></td>
<td>
<p>A <code>numeric</code> specifying the number of factors to include 
within each grid of differences. The <code>gridspacing</code> will then be 
computed based on the numbers of combinations observed within the 
levels of the remaining factors in a single plot. The <code>gridspacing</code> 
argument to this function will be ignored if <code>factors.per.grid</code> is 
greater than zero. Grids are most useful when two or more factors index the 
rows and columns of each plot.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_show.sig">show.sig</code></td>
<td>
<p>A <code>logical</code> that specifies whether asterisks indicating the level 
of significance are to be added to the plot. If they are then 
&lsquo;***&rsquo; indicates that <code class="reqn">p \leq 0.001</code>, 
&lsquo;**&rsquo; that <code class="reqn"> 0.001 &lt; p \leq 0.01</code>, 
&lsquo;*&rsquo; that <code class="reqn"> 0.01 &lt; p \leq 0.05</code>
&lsquo;.&rsquo; that <code class="reqn"> 0.05 &lt; p \leq 0.10</code>. The last is only 
included for <code>alpha</code> = 0.10.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for testing 
pairwise differences; must be 0.05 or 0.10.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sig.size">sig.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the size, in pts, of the 
significance asterisks.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sig.colour">sig.colour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the colour to use for the 
significance asterisks.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sig.face">sig.face</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the font face for the significance 
asterisks (<code>"plain"</code>, <code>"italic"</code>, <code>"bold"</code>, <code>"bold.italic"</code>).</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sig.family">sig.family</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the font family for the significance 
asterisks. The font families that are available depends on the system. For font 
families other than the basic Postscript fonts, see the <code>extrafont</code> package.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_triangles">triangles</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> traingle(s).</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_title">title</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code>  string giving the main title for the plot and to which 
is appended the levels combination of the sectioning factors, if any, for each plot.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether a label is to be added to the x- and y-axes. 
If TRUE, the label is the comma-separated list of factors whose levels 
combinations are involved in the prediction differences for which the p-values 
are calculated.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters separating the levels of different 
factors in the row and column names of the <code>p.differences</code> component. </p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_colours">colours</code></td>
<td>
<p>A vector of of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
It is passed to <code>ggplot</code> via <code><a href="#topic+plotPvalues.data.frame">plotPvalues.data.frame</a></code> 
to be applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_printplot">printPlot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>data.frame</code> is required.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> components is for 
increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="plotPvalues.alldiffs_+3A_...">...</code></td>
<td>
<p>Provision for passsing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components named <code>pvalues</code> and <code>plots</code>. 
The <code>pvalues</code> component contains the <code>data.frame</code> with the columns <code>Rows</code>, 
<code>Columns</code>, <code>p</code>, <code>sections1</code> and <code>sections2</code>. This <code>data.frame</code> is 
formed using the <code>sed</code> component of <code>object</code> and is used by 
<code><a href="#topic+plotPvalues.data.frame">plotPvalues.data.frame</a></code> in producng the plot. The <code>plots</code> 
component contains a list of <code>ggplot</code> objects, one for each plot produced. 
Multiple plots are stored in the <code>plots</code> component if the <code>sections</code> argument 
is set and the plots are are named for the levels combinations of the sections.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPvalues.data.frame">plotPvalues.data.frame</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18" &amp; Benches != "3")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  plotPvalues(TS.diffs, gridspacing = rep(c(3,4), c(4,2)), show.sig = TRUE)

  plotPvalues(TS.diffs, sections = "Sources", show.sig = TRUE, axis.labels = TRUE)
  
}
</code></pre>

<hr>
<h2 id='plotPvalues.data.frame'>Plots a heat map of p-values for pairwise differences between predictions.</h2><span id='topic+plotPvalues.data.frame'></span>

<h3>Description</h3>

<p>Produces a heat-map plot of the p-values for pairwise differences between 
predictions that is in a <code>data.frame</code>. The <code>data.frame</code> includes 
two factors whose levels specify, for each p-value, which factor levels are 
being compared.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotPvalues(object, p = "p", x, y, 
            gridspacing = 0, show.sig = FALSE, alpha = 0.10, 
            sig.size = 3, sig.colour = "black", 
            sig.face = "plain", sig.family = "",  
            triangles = "both", 
            title = NULL, axis.labels = NULL, axis.text.size = 12, 
            colours = RColorBrewer::brewer.pal(3, "Set2"), 
            ggplotFuncs = NULL, printPlot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPvalues.data.frame_+3A_object">object</code></td>
<td>
<p>A <code>data.frame</code> containing the three columns specified by <code>p</code>, <code>x</code> 
and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_p">p</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains
the p-values to be plotted.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_x">x</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains 
the factor whose levels index the p-values that are to be plotted in the same column.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_y">y</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>object</code> that contains 
the labels of the p-values that are to be plotted as the rows.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_gridspacing">gridspacing</code></td>
<td>
<p>A <code>numeric</code> specifying the number(s) of rows and columns 
that form groups in the grid of differences. This is most useful when  
two or more factors index the rows and columns. If a single, nonzero 
number, <em>k</em> say, is given then a grid line is placed after every 
<em>k</em>th  row and column. If a vector of values is given then the 
number of grid lines is the length of the vector and the spacing between 
each is specified by the elements of the vector.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_show.sig">show.sig</code></td>
<td>
<p>A <code>logical</code> that specifies whether asterisks indicating the level 
of significance are to be added to the plot. If they are then 
&lsquo;***&rsquo; indicates that <code class="reqn">p \leq 0.001</code>, 
&lsquo;**&rsquo; that <code class="reqn"> 0.001 &lt; p \leq 0.01</code>, 
&lsquo;*&rsquo; that <code class="reqn"> 0.01 &lt; p \leq 0.05</code>
&lsquo;.&rsquo; that <code class="reqn"> 0.05 &lt; p \leq 0.10</code>. The last is only 
included for <code>alpha</code> = 0.10.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for testing 
pairwise differences; must be 0.05 or 0.10.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_sig.size">sig.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the size, in pts, of the 
significance asterisks.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_sig.colour">sig.colour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the colour to use for the 
significance asterisks.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_sig.face">sig.face</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the font face for the significance 
asterisks (<code>"plain"</code>, <code>"italic"</code>, <code>"bold"</code>, <code>"bold.italic"</code>).</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_sig.family">sig.family</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the font family for the significance 
asterisks. The font families that are available depends on the system. For font 
families other than the basic Postscript fonts, see the <code>extrafont</code> package.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_triangles">triangles</code></td>
<td>
<p>A <code>character</code> indicating whether the plot should include the 
<code>lower</code>, <code>upper</code> or <code>both</code> traingle(s). Here it is only used 
to adjust gridlines for the omission of the diagonal.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_title">title</code></td>
<td>
<p>A <code>character</code> string giving the main title for the plot.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_axis.labels">axis.labels</code></td>
<td>
<p>A <code>character</code> string giving the label to use for both the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> on the axes   
of the <code>heatmap</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_colours">colours</code></td>
<td>
<p>A vector of of colours to be passed to the <code>ggplot</code> function 
<code>scale\_colour\_gradientn</code>.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_printplot">printPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether or not the a plot is to be printed. This would 
be used when just the returned <code>ggplot</code> object is required.</p>
</td></tr>
<tr><td><code id="plotPvalues.data.frame_+3A_...">...</code></td>
<td>
<p>Provision for passsing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<a href="ggplot2.html#topic+ggplot">ggplot</a>&quot;, which can be plotted using <code>print</code> or otherwise manipulated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPvalues.alldiffs">plotPvalues.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <code>ggplot</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Subset WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= tmp))
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
SS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = current.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  p &lt;- within(reshape2::melt(TS.diffs$p.differences), 
              { 
                Var1 &lt;- factor(Var1, levels=dimnames(TS.diffs$p.differences)[[1]])
                Var2 &lt;- factor(Var2, levels=levels(Var1))
              })
  names(p) &lt;- c("Rows","Columns","p")
  plotPvalues(p, x = "Rows", y = "Columns", 
              gridspacing = rep(c(3,4), c(4,2)), show.sig = TRUE)
}
</code></pre>

<hr>
<h2 id='plotVariofaces.data.frame'>Plots empirical variogram faces, including envelopes, from supplied residuals as 
described by Stefanova, Smith &amp; Cullis (2009).</h2><span id='topic+plotVariofaces.data.frame'></span><span id='topic+plotVariofaces'></span>

<h3>Description</h3>

<p>Produces a plot for each face of an empirical 2D 
<code>variogram</code> based on supplied residuals from both an observed data set 
and simulated data sets. Those from simulated data sets are used to
produce confidence envelopes If the data consists of sections, such as separate
experiments, the two variogram faces are produced for each section. This 
function is less efficient in storage terms than <code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>,
because here the residuals from all simulated data sets must be saved, in 
addition to the values for the variogram faces; in 
<code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>, the residuals for each simulated data set are 
discarded after the variogram has been calculated. On the other hand, the 
present function is more flexible, because there is no restriction on how the 
residuals are obtained.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
plotVariofaces(data, residuals, restype="Residuals", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVariofaces.data.frame_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with either 3 or 4 columns. Only if there are 4 columns, the
first should be a factor indexing sections for which separate variogram plots are 
to be produced. In either case, the other 3 columns should be, in order, 
(i) a factor indexing the x-direction, (ii) a factor indexing the y-direction, 
and (iii) the residuals for the observed response.</p>
</td></tr>
<tr><td><code id="plotVariofaces.data.frame_+3A_residuals">residuals</code></td>
<td>
<p>A <code>data.frame</code>, with either 2 or 3 initial columns followed by 
columns, each of which are the residuals from a simulated 
data set.</p>
</td></tr>
<tr><td><code id="plotVariofaces.data.frame_+3A_restype">restype</code></td>
<td>
<p>A <code>character</code> describing the type of residuals that have been supplied. 
It will be used in the plot titles.</p>
</td></tr>
<tr><td><code id="plotVariofaces.data.frame_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the function <code>asreml.variogram</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each set of residuals, <code>asreml.variogram</code> is used to obtain the empirical 
variogram, from which the values for its faces are obtained.  Plots are produced for
each face and include the observed residuals and the 2.5%, 50% &amp; 97.5% quantiles.</p>


<h3>Value</h3>

<p>A <code>list</code> with the following components:
</p>

<ol>
<li><p><b>face1:</b> a <code>data.frame</code> containing the variogram values on 
which the plot for the first dimension is based. 
</p>
</li>
<li><p><b>face2:</b> a <code>data.frame</code> containing the variogram values on 
which the plot for the second dimension is based.</p>
</li></ol>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Stefanova, K. T., Smith, A. B. &amp; Cullis, B. R. (2009) Enhanced diagnostics for the 
spatial analysis of field trials. <em>Journal of Agricultural, Biological, 
and Environmental Statistics</em>, <b>14</b>, 392&ndash;410.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code>asreml</code>, <code>asreml.variogram</code>,
<code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>, <code><a href="#topic+simulate.asreml">simulate.asreml</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Form variance matrix based on estimated variance parameters
s2 &lt;- current.asr$sigma2
gamma.Row &lt;- current.asr$gammas[1]
gamma.unit &lt;- current.asr$gammas[2]
rho.r &lt;- current.asr$gammas[4]
rho.c &lt;- current.asr$gammas[5]
row.ar1 &lt;- mat.ar1(order=10, rho=rho.r)
col.ar1 &lt;- mat.ar1(order=15, rho=rho.c)
V &lt;- gamma.Row * fac.sumop(Wheat.dat$Row) + 
  gamma.unit * diag(1, nrow=150, ncol=150) + 
  mat.dirprod(col.ar1, row.ar1)
V &lt;- s2*V

#Produce variogram faces plot (Stefanaova et al, 2009)
resid &lt;- simulate(current.asr, V=V, which="residuals")
resid$residuals &lt;- cbind(resid$observed[c("Row","Column")],
                         resid$residuals)
plotVariofaces(data=resid$observed[c("Row","Column","residuals")],
               residuals=resid$residuals, 
               restype="Standardized conditional residuals")

## End(Not run)</code></pre>

<hr>
<h2 id='powerTransform'>Performs a combination of a linear and a power transformation on a variable. The 
transformed variable is stored in the <code>data.frame data</code>.</h2><span id='topic+powerTransform'></span>

<h3>Description</h3>

<p>Perform a combination of a linear and a power transformation on a variable 
whose name is given as a character string in <code>var.name</code>. The transformed 
variable is stored in the <code>data.frame data</code>. The name of the transformed 
variable is made by prepending to the original <code>var.name</code> a combination of 
(i) <code>.offset</code>, if <code>offset</code> is nonzero, 
(ii) <code>neg.</code>, if <code>scale</code> is -1, or <code>scaled.</code>, if <code>abs(scale)</code> 
is other than one, and (iii) either <code>log.</code>, <code>sqrt.</code>, <code>recip.</code> or 
<code>power.</code>, if <code>power</code> is other than one. 
No action is taken if there is no transformation (i.e. <code>offset = 0</code>, 
<code>scale = 1</code> and <code>power = 1</code>). Also, the <code>titles</code> list is 
extended to include a component with a generated title for the 
transformed variable with text indicating the transformation prepended 
to the <code>title</code> for the <code>var.name</code> obtained from the 
<code>titles list</code>.  For nonzero <code>offset</code>, &lsquo;Offset &rsquo; is prepended, 
For <code>scaled</code> not equal to one, the possible prepends are &lsquo;Negative of &rsquo;  
and &lsquo;Scaled &rsquo;. The possible prepended texts for <code>power</code> not equal to one 
are &lsquo;Logarithm of&rsquo;, &lsquo;Square root of &rsquo;, &lsquo;Reciprocal of &rsquo; and &lsquo;Power nnnn of &rsquo;, 
where <code>nnn</code> is the power used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerTransform(var.name, power = 1, offset = 0, scale = 1, titles = NULL, data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerTransform_+3A_var.name">var.name</code></td>
<td>
<p>A <code>character string</code> specifying the name of the variable 
in the <code>data.frame data</code> that is to be transformed.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_power">power</code></td>
<td>
<p>A number specifying the power to be used in the transformation. 
If equal to 1, the default, no power transformation is applied. 
Otherwise, the variable is raised to the specified <code>power</code>, 
after scaling and applying any nonzero <code>offset</code>.
If <code>power = 0</code>, the natural logarithm is used to transform 
the response; however, if the smallest value to be log-transformed 
is less than 1e-04, an error is generated. A log-transformation in 
this situation may be possible if a nonzero <code>offset</code> and/or a 
<code>scale</code> not equal to one is used.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_offset">offset</code></td>
<td>
<p>A number to be added to each value of the variable, after any scaling 
and before applying any power transformation.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_scale">scale</code></td>
<td>
<p>A number to multiply each value of the variable, before adding 
any offset and applying any power transformation.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_titles">titles</code></td>
<td>
<p>A <code>character vector</code>, each element of which is named for a 
variable in <code>data</code> and is a <code>character string</code> giving a title 
to use in output (e.g. tables and graphs) involving the variable. If
titles are not supplied, the column name of the variable in <code>data</code> 
is used.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the variable to be transformed and 
to which the transformed variable is to be appended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with a component named <code>data</code> that is the <code>data.frame</code> containing the 
transformed variable, a component named <code>tvar.name</code> that is a <code>character string</code> 
that is the name of the transformed variable in <code>data</code>, and a component named 
<code>titles</code> that extends the <code>list</code> supplied in the <code>titles</code> argument to 
include a generated title for the transformed title, the name of the new component being 
<code>tvar.name</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+angular">angular</a></code>, <code><a href="#topic+angular.mod">angular.mod</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor with labels
x.dat &lt;- data.frame(y = c(14, 42, 120, 150))
 
## transform y to logarithms
trans &lt;- powerTransform("y", power = 0, titles=list(y = "Length (cm)"), data = x.dat)
x.dat &lt;- trans$data
tvar.name &lt;- trans$tvar.name

## transform y to logarithms after multiplying by -1 and adding 1.
z.dat &lt;- data.frame( y = c(-5.25, -4.29, -1.22, 0.05))
trans &lt;- powerTransform("y", power = 0, scale = -1, offset = 1 ,
                        titles=list(y = "Potential"), data = z.dat)
z.dat &lt;- trans$data
tvar.name &lt;- trans$tvar.name
</code></pre>

<hr>
<h2 id='predictions.frame'>Description of a predictions object</h2><span id='topic+predictions.frame'></span><span id='topic+predictions.frame-class'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of S3-class <code>predictions.frame</code> that stores the 
predictions for a fitted model.
</p>
<p><code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code> is function that converts a 
<code><a href="base.html#topic+data.frame">data.frame</a></code> to an object of this class.
</p>
<p><code><a href="#topic+is.predictions.frame">is.predictions.frame</a></code> is the membership function for this class; it tests 
that an object has class <code>predictions.frame</code>.
</p>
<p><code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code> can be used to test the validity of a 
<code>predictions.frame</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> that begins with the variables classifying the predictions, 
in the same order as in the <code>classify</code>, followed by a column of 
predictions that is named either <code>predicted.value</code> or
<code>backtransformed.predictions</code>; it also contains columns named  
<code>standard.error</code> and <code>est.status</code>. 
The number of rows should equal the number of unique combinations 
of the classifying variables. While such a <code>data.frame</code> 
can be constructed from the beginning, the <code>pvals</code> component 
of the value produced by <code>predict.asreml</code> is a suitable value to 
supply for this argument. Note that the names <code>standard.error</code> and 
<code>est.status</code> have been changed to <code>std.error</code> and <code>status</code> 
in the <code>pvals</code> component produced by <code>asreml-R4</code>; if the new names 
are in the <code>data.frame</code> supplied to <code>predictions</code>, they will be 
returned to the previous names. 
</p>
<p>The <code>data.frame</code> may also include columns for the lower and upper 
values of error intervals, either standard error, confidence or half-LSD 
intervals.  The names of these columns will consist of three parts 
separated by full stops: 
1) the first part will be <code>lower</code> or <code>upper</code>; 
2) the second part will be one of <code>Confidence</code>, 
<code>StandardError</code> or <code>halfLeastSignificant</code>; 
3) the third component will be <code>limits</code>.
</p>
<p>IF <code>accuracy.threshold</code> is set to a numeric value at the time the 
<code>prediction.frame</code> is formed, it will also include a column <code>logical</code> values 
named <code>LSDwarning</code>.
</p>
<p>When <code>halfLeastSignificant</code> limits have been included in a <code>predictions.frame</code>, 
its attributes will include those that are not <code>NULL</code> of <code>LSDtype</code>, 
<code>LSDby</code>, <code>LSDstatistic</code>, <code>LSDaccuracy</code> and <code>LSDvalues</code>. <code>LSDvalues</code> are 
the LSD values used to calculate the <code>halfLeastSignificant</code> <code>error.intervals</code> 
and are an expanded version of the values stored in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code>.
</p>
<p>See <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code> for more information.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+is.predictions.frame">is.predictions.frame</a></code>, 
<code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code>, <code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- as.predictions.frame(Var.pred$pvals, se = "std.error", 
                                    est.status = "status")
  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
  }

  if (exists("Var.preds"))
  {
    ## Check the class and validity of the alldiffs object
    is.predictions.frame(Var.preds)
    validPredictionsFrame(Var.preds)
  }
</code></pre>

<hr>
<h2 id='predictPlus.asreml'>Forms the predictions for a term, their pairwise differences and 
associated statistics. A factor having parallel values may occur in 
the model and a linear transformation of the predictions can be specified.
It results in an object of class alldifffs. </h2><span id='topic+predictPlus.asreml'></span><span id='topic+predictPlus'></span>

<h3>Description</h3>

<p>This function forms the predictions for <code>term</code> using 
<code>classify</code> and the supplied <code>asreml</code> object and stores 
them in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. If <code>x.num</code> is 
supplied, the predictions will be obtained for the values supplied 
in <code>x.pred.values</code> and, if supplied, <code>x.plot.values</code> will 
replace them in the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> that is returned. 
If <code>x.fac</code>, but not <code>x.num</code>, is specified, predictions 
will involve it and, if supplied, <code>x.plot.values</code> will replace 
the levels of <code>x.fac</code> in the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
that is returned. In order to get the correct predictions you may 
need to supply additional arguments to <code>predict.asreml</code> 
through <code>...</code> e.g. <code>present</code>, <code>parallel</code>, <code>levels</code>. 
Any aliased predictions will be removed, as 
will any standard error of pairwise differences involving them.
</p>
<p>Also calculated are the approximate degrees of freedom of the 
standard errors of the predictions. If the denominator degrees of 
freedom for <code>term</code> are available in <code>wald.tab</code>, they are 
used. Otherwise the residual degrees of freedom or the maximum of 
the denominator degrees in <code>wald.tab</code>, excluding the  
Intercept, are used. Which is used depends on the setting of 
<code>dDF.na</code>. These degrees of freedom are used for the 
t-distribution on which p-values and confidence intervals are 
based. It is stored as an  attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The degrees of freedom are also used in calculating the minimum, 
mean and maximum LSD for comparing pairs of predictions, which are 
also stored in the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>
<p>If <code>pairwise = TRUE</code>, all pairwise differences between the 
<code>predictions</code>, their standard errors, p-values and LSD 
statistics are computed using <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>. 
This adds them to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as additional 
<code>list</code> components named <code>differences</code>, <code>sed</code>, 
<code>p.differences</code> and <code>LSD</code>.
</p>
<p>If a linear transformation of the predictions is specified then the 
values of this linear transformation are returned, 
instead of the original predictions, along with their standard errors 
and the pairwise differences and associated statistics. 
</p>
<p>If a transformation has been applied in the analysis (any one of 
<code>transform.power</code> is not one, <code>scale</code> is  not one and 
<code>offset</code> is nonzero), the backtransforms of the transformed 
values and their lower and upper error intervals are added 
to a <code>data.frame</code> that is consistent with the <code>predictions</code> 
<code>data.frame</code>. 
If <code>transform.power</code> is other than 
one, the <code>standard.error</code> column of the <code>data.frame</code> 
is set to <code>NA</code>. This <code>data.frame</code> is added to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> as a <code>list</code> component called 
<code>backtransforms</code>.
</p>
<p>The printing of the components produced is controlled by the 
<code>tables</code> argument. The order of plotting the levels of 
one of the factors indexing the predictions can be modified 
and is achieved using <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
predictPlus(asreml.obj, classify, term = NULL, 
            inestimable.rm = TRUE, linear.transformation = NULL, 
            error.intervals = "Confidence", alpha = 0.05, 
            wald.tab = NULL, dDF.na = "residual",  dDF.values = NULL, 
            pairwise = TRUE, Vmatrix = FALSE, 
            avsed.tolerance = 0.25, accuracy.threshold = NA, 
            LSDtype = "overall", LSDsupplied = NULL, LSDby = NULL, 
            LSDstatistic = "mean", LSDaccuracy = "maxAbsDeviation", 
            x.num = NULL, x.fac = NULL,  
            x.pred.values = NULL, x.plot.values = NULL, 
            titles = NULL,  tables = "all" , level.length = NA, 
            transform.power = 1, offset = 0, scale = 1, 
            transform.function = "identity", 
            sortFactor = NULL, sortParallelToCombo = NULL, 
            sortNestingFactor = NULL, sortOrder = NULL, 
            decreasing = FALSE, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictPlus.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p><code>asreml</code> object for a fitted model.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_classify">classify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table to be predicted. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator. To predict the overall 
mean, set the <code>classify</code> to &quot;<code>(Intercept)</code>&quot;.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_term">term</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that define the term 
that was fitted using <code>asreml</code> and that corresponds to <code>classify</code>. 
It only needs to be specified when it is different to <code>classify</code>; it 
is stored as an attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
It is likely to be needed when the fitted model includes terms that involve  
both a <code><a href="base.html#topic+numeric">numeric</a></code> covariate and a <code><a href="base.html#topic+factor">factor</a></code> that 
parallel each other; the <code>classify</code> would include the covariate and 
the <code>term</code> would include the <code>factor</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_inestimable.rm">inestimable.rm</code></td>
<td>
<p>A <code>logical</code> indicating whether rows for  predictions 
that are not estimable are to be removed from the components of 
the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_linear.transformation">linear.transformation</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>. 
If a <code><a href="stats.html#topic+formula">formula</a></code> is given then it is taken to be a submodel of 
a model term corresponding to the <code>classify</code>. The projection matrix 
that transforms the <code>predictions</code> so that they conform to the submodel 
is obtained; the submodel does not have to involve variables in the 
<code>classify</code>, but the variables must be columns in the <code>predictions</code> 
component of <code>alldiffs.obj</code> and the space for the submodel must be a 
subspace of the space for the term specified by the <code>classify</code>. 
For example, for <code>classify</code> set to <code>"A:B"</code>, the submodel 
<code>~ A + B</code> will result in the <code>predictions</code> for the combinations of 
<code>A</code> and <code>B</code> being made additive for the <code><a href="base.html#topic+factor">factor</a>s</code> 
<code>A</code> and <code>B</code>. The submodel space corresponding to <code>A + B</code> is 
a subspace of the space <code>A:B</code>. In this case both the submodel and the 
classify involve only the factors A and B. To fit an intercept-only 
submodel, specify <code>linear.transformation</code> to be the formula <code>~1</code>.
</p>
<p>If a <code><a href="base.html#topic+matrix">matrix</a></code> is provided then it will be 
used to apply the linear transformation to the <code>predictions</code>. 
It might be a contrast <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code> of 
weights for a factor used to obtain the weighted average over that factor. 
The number of rows in the <code><a href="base.html#topic+matrix">matrix</a></code> should equal the 
number of linear combinations of the <code>predictions</code> desired and 
the number of columns should equal the number of <code>predictions</code>.
</p>
<p>In either case, as well as the values of the linear combinations, 
their standard errors, pairwise differences and associated statistics 
are returned.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string indicating the type of error interval, if any, 
to calculate in order to indicate uncertainty in the results. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. The default is for confidence limits to 
be used. The <code>"halfLeastSignificant"</code> option results in half the 
Least Significant Difference (LSD) being added and subtracted to the 
predictions, the LSD being calculated using the square root of the mean of the 
variances of all or a subset of pairwise differences between the predictions. 
If the LSD is zero, as can happen when predictions are constrained to be equal,
then the limits of the error intervals are set to <code>NA</code>. 
If <code>LSDtype</code> is set to <code>overall</code>, the <code>avsed.tolerance</code> is not 
<code>NA</code> and the range of the SEDs divided by the average of the SEDs exceeds 
<code>avsed.tolerance</code> then the <code>error.intervals</code> calculations and the plotting 
will revert to confidence intervals.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_wald.tab">wald.tab</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the pseudo-anova table for the 
fixed terms produced by a call to <code>wald.asreml</code>. The main 
use of it here is in determining the degrees of freedom for 
calculating confidence or half-LSD <code>error.intervals</code> and p-values, 
the latter to be stored in the <code>p.differences</code> component of the 
<code>alldiffs.object</code> that is created.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_ddf.na">dDF.na</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the method to use to 
obtain approximate denominator degrees of 
freedom. when the numeric or algebraic methods produce an 
<code>NA</code>. Consistent with when no denDF are available, the 
default is <code>"residual"</code> and so the residual degrees of 
freedom from <code>asreml.obj$nedf</code> are used. 
If <code>dDF.na = "none"</code>, no substitute denominator degrees of 
freedom are employed; if <code>dDF.na = "maximum"</code>, the maximum 
of those denDF that are available, excluding that for the 
Intercept, is used; if all denDF are <code>NA</code>, <code>asreml.obj$nedf</code> is used. If 
<code>dDF.na = "supplied"</code>, a <code>vector</code> of values for the 
denominator degrees of freedom is to be supplied in <code>dDF.values</code>. 
Any other setting is ignored and a warning message produced. 
Generally, substituting these degrees of freedom is 
anticonservative in that it is likely that the degrees of freedom 
used will be too large.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_ddf.values">dDF.values</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> of values to be used when 
<code>dDF.na = "supplied"</code>. Its values will be used when 
<code>denDF</code> in a test for a fixed effect is <code>NA</code>. 
This vector must be the same length as the number of 
fixed terms, including (Intercept) whose value could be 
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_pairwise">pairwise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether all pairwise differences of the
<code>predictions</code> and their standard errors and p-values are to be 
computed and stored. If <code>tables</code> is equal to 
<code>"differences"</code> or <code>"all"</code> or <code>error.intervals</code> is 
equal to <code>"halfLeastSignificant"</code>, they will be stored 
irrespective of the value of <code>pairwise</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_vmatrix">Vmatrix</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the variance matrix of the 
<code>predictions</code> will be stored as a component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> that is returned. 
If <code>linear.transformation</code> is set, it will 
be stored irrespective of the value of <code>Vmatrix</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_avsed.tolerance">avsed.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the SED range, the range of the SEDs 
divided by the square root of the mean of the variances of all or a subset of the 
pairwise differences, that is considered reasonable in calculating 
<code>error.intervals</code>. To have it ignored, set it to <code>NA</code>. It should be a 
value between 0 and 1. The following rules apply:
</p>

<ol>
<li><p> If <code>avsed.tolerance</code> is <code>NA</code> then mean LSDs of the type specified by 
<code>LSDtype</code> are calculated and used in <code>error.intervals</code> and plots.
</p>
</li>
<li><p> Irrespective of the setting of <code>LSDtype</code>, if <code>avsed.tolerance</code> is not 
exceeded then the mean LSDs are used in <code>error.intervals</code> and plots. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>overall</code>, <code>avsed.tolerance</code> is not 
<code>NA</code>, and <code>avsed.tolerance</code> is exceeded then  <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>factor.combinations</code> and <code>avsed.tolerance</code> 
is not exceeded for any factor combination then the half LSDs are 
used in <code>error.intervals</code> and plots; otherwise, <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>per.prediction</code> and <code>avsed.tolerance</code> 
is not exceeded for any prediction then the half LSDs are used in <code>error.intervals</code> 
and plots; otherwise, <code>error.intervals</code> and plotting revert to confidence intervals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_accuracy.threshold">accuracy.threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value of the LSD accuracy measure,  
which measure is specified by <code>LSDaccuracy</code>, as a threshold value in determining whether the 
<code>hallfLeastSignificant</code> <code>error.interval</code> for a predicted value is a reasonable  
approximation; this will be the case if the LSDs across all pairwise comparisons for which 
the interval's LSD was computed, as specified by <code>LSDtype</code> and <code>LSDby</code>, 
are similar enough to the interval's LSD, as measured by <code>LSDaccuracy</code>.  
If it is <code>NA</code>, it will be ignored. If it is 
not <code>NA</code>, a column of <code><a href="base.html#topic+logical">logical</a>s</code> named <code>LSDwarning</code>  will be added 
to the <code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The value of 
<code>LSDwarning</code> for a <code>predicted.value</code> will be <code>TRUE</code> if the value of the 
<code>LSDaccuracy</code> measure computed from the LSDs for differences between this 
<code>predicted.value</code> and the other <code>predicted.values</code> as compared to its 
<code>assignedLSD</code> exceeds the value of <code>accuracy.threshold</code>. Otherwise, the 
value of <code>LSDwarning</code> for a <code>predicted.value</code> will be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_titles">titles</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each component of which is named for a column in 
the <code>data.frame</code> for <code>asreml.obj</code> and contains a 
<code>character string</code> giving a title to use 
in output (e.g. tables and graphs). Here they will 
be used for table headings.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_tables">tables</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector containing a combination of 
<code>none</code>, 
<code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code>, <code>sed</code>, <code>LSD</code> and <code>all</code>.
These nominate which components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> to print.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_x.num">x.num</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the numeric covariate that 
(i) is potentially included in terms in the fitted model and (ii) is the 
x-axis variable for plots. Its values will not be converted to a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_x.fac">x.fac</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor that 
(i) corresponds to <code>x.num</code> and (ii) is potentially included in 
terms in the fitted model. It should have the same number of levels as the 
number of unique values in <code>x.num</code>. The levels of 
<code>x.fac</code> must be in the order in which they are to be plotted 
- if they are dates, then they should be in the form 
yyyymmdd, which can be achieved using <code>as.Date</code>. However, the levels
can be non-numeric in nature, provided that <code>x.num</code> is also set.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_x.pred.values">x.pred.values</code></td>
<td>
<p>The values of <code>x.num</code> for which predicted values are 
required. If <code>levels</code> is set for passing to <code>predict.asreml</code>, 
<code>x.pred.values</code> is ignored. Note that while <code>levels</code> is an
alternative to <code>x.pred.values</code>, <code>x.pred.values</code> allows more 
general setting of the levels to be predicted.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_x.plot.values">x.plot.values</code></td>
<td>
<p>The actual values to be plotted on the x axis. They are 
needed when values different to those in <code>x.num</code> are to be 
plotted or <code>x.fac</code> is to be plotted because there is no 
<code>x.num</code> term corresponding to the same term with <code>x.fac</code>.</p>
</td></tr> 
<tr><td><code id="predictPlus.asreml_+3A_level.length">level.length</code></td>
<td>
<p>The maximum number of characters from the levels of 
factors to use in the row and column labels of the tables of 
pairwise differences and their p-values and standard errors.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_transform.power">transform.power</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the power of a transformation, if 
one has been applied to the response variable. Unless it is equal 
to 1, the default, back-transforms of the predictions will be 
obtained and stored in the <code>backtransforms</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The back-transformation raises the predictions to the power equal 
to the reciprocal of <code>transform.power</code>, unless it equals 0 in 
which case the exponential of the predictions is taken.</p>
</td></tr> 
<tr><td><code id="predictPlus.asreml_+3A_offset">offset</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that has been added to each value of the 
response after any scaling and before applying any power transformation.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_scale">scale</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> by which each value of the response has been multiplied 
before adding any offset and applying any power transformation.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_transform.function">transform.function</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a function that 
specifies the scale on which the predicted values are defined. This may be the 
result of a transformation of the data using the function or the use of the 
function as a link function in the fitting of a generalized linear (mixed) 
model (GL(M)M). The possible <code>transform.function</code>s are 
<code>identity</code>, <code>log</code>, <code>inverse</code>, <code>sqrt</code>, <code>logit</code>, 
<code>probit</code>, and <code>cloglog</code>.  The <code>predicted.values</code> and 
<code>error.intervals</code>, if not <code>StandardError</code> intervals, will be 
back-transformed using the inverse function of the <code>transform.function</code>. 
The <code>standard.error</code> column will be set to <code>NA</code>, unless (i) 
<code>asreml</code> returns columns named <code>transformed.value</code> and 
<code>approx.se</code>, as well as those called <code>predicted.values</code> and 
<code>standard.error</code> (such as when a GLM is fitted) and 
(ii) the values in <code>transformed.value</code> are equal to those obtained by 
backtransforming the <code>predicted.value</code>s using the inverse function 
of the <code>transform.function</code>. Then, the <code>approx.se</code> values will be 
saved in the <code>standard.error</code> column of the <code>backtransforms</code> 
component of the returned <code>alldiffs.obj</code>. Also, the 
<code>transformed.value</code> and <code>approx.se</code> columns are removed from both 
the <code>predictions</code> and <code>backtransforms</code> components of the 
<code>alldiffs.obj</code>. Note that the values that end up in the <code>standard errors</code> 
column are approximate for the backtransformed values and are not used in 
calculating <code>error.intervals</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is for 
increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_trace">trace</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that control output from ASReml-R. 
If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="predictPlus.asreml_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>predict.asreml</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>linear.transformations</code> set to <code>NULL</code>, an S3-class 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with predictions and their standard 
errors and, depending on the settings of the arguments, all pairwise 
differences between predictions, their standard errors and p-values 
and LSD statistics.  Also, unless the <code>sortFactor</code> or <code>sortOrder</code> 
arguments are invoked, the rows of <code>predictions</code> component are ordered 
so that they are in standard order for the variables in the <code>classify</code>. 
That is, the values of the last variable change with every row, those of the 
second-last variable only change after all the values of the last variable have 
been traversed; in general, the values of a variable are the same for all the 
combinations of the values to the variables to its right in the <code>classify</code>. 
In addition, if necessary, the order of the columns of the variables in the 
<code>predictions</code> component are changed to match their order in the <code>classify</code>.
</p>
<p>If <code>transform.power</code> or <code>scale</code> is not one or <code>offset</code> 
is not zero, it will contain a <code>data.frame</code> with the backtransformed 
linear transformation of the predictions. The backtransformation will, after 
backtransforming for any power transformation, subtract the <code>offset</code> 
and then divide by the <code>scale</code>.
</p>
<p>If <code>error.intervals</code> is not <code>"none"</code>, then the 
<code>predictions</code> component and, if present, the 
<code>backtransforms</code> component will contain columns for the lower 
and upper values of the limits for the interval.
</p>
<p>The name of the <code>response</code>, the <code>response.title</code>, 
the <code>term</code>, the <code>classify</code>, <code>tdf</code>, <code>sortFactor</code> 
and the <code>sortOrder</code> will be set as attributes to the object. 
Also, if <code>error.intervals</code> is <code>"halfLeastSignificant"</code>, then those of 
<code>LSDtype</code>, <code>LSDby</code> and <code>LSDstatistic</code> that are not <code>NULL</code> 
will be added as attributes of the object and of the <code>predictions frame</code>; 
additionally, <code>LSDvalues</code> will be added as attribute of the 
<code>predictions frame</code>, <code>LSDvalues</code> being the LSD values used in 
calculating the <code>error.intervals</code>. 
Note that the <code>classify</code> in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is based on the 
variables indexing the predictions, which may differ from the 
<code>classify</code> used to obtain the original predictions (for example, 
when the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>s stores a linear transformation of predictions.
</p>
<p>For <code>linear.transformations</code> set to other than <code>NULL</code>, 
an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with the <code>linear.transformation</code> 
applied to the <code>predictions</code> and their standard errors and, 
depending on the settings of the arguments, all pairwise 
differences between the linearly transformed predictions, their 
standard errors and p-values and LSD statistics. 
(See also <code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code>.)</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, 
<code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>,  <br /> 
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <br /> 
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code>, 
<code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, <br />
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, 
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <code>as.Date</code>, <code>predict.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(WaterRunoff.dat)
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
diffs &lt;- predictPlus(classify = "Sources:Type", 
                     asreml.obj = current.asr, 
                     wald.tab = current.asrt$wald.tab, 
                     present = c("Sources", "Type", "Species"))

## End(Not run)</code></pre>

<hr>
<h2 id='predictPresent.asreml'>Forms the predictions for each of one or more terms and presents 
them in tables and/or graphs.</h2><span id='topic+predictPresent.asreml'></span><span id='topic+predictPresent'></span>

<h3>Description</h3>

<p>This function forms the predictions for each term in <code>terms</code> 
using a supplied <code>asreml</code> object and 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>. 
Tables are produced using <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, 
in conjunction with <br /> 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
with the argument <code>tables</code> specifying which tables are printed. 
The argument <code>plots</code>, along with <code>transform.power</code>, 
controls which plots are produced. The plots are 
produced using <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, with 
line plots produced when variables involving <code>x.num</code> or <code>x.fac</code> 
are involved in <code>classify</code> for the predictions and bar charts 
otherwise.  
In order to get the correct predictions you may 
need to supply additional arguments to <code>predict.asreml</code> 
through <code>...</code> e.g. <code>present</code>, <code>parallel</code>, <code>levels</code>.
</p>
<p>The order of plotting the levels of 
one of the factors indexing the predictions can be modified and is achieved 
using <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
predictPresent(asreml.obj, terms, inestimable.rm = TRUE, 
               linear.transformation = NULL, 
               error.intervals = "Confidence", alpha = 0.05, 
               wald.tab = NULL, dDF.na = "residual", dDF.values = NULL, 
               pairwise = TRUE, Vmatrix = FALSE, 
               avsed.tolerance = 0.25, accuracy.threshold = NA, 
               LSDtype = "overall", LSDsupplied = NULL, LSDby = NULL, 
               LSDstatistic = "mean", LSDaccuracy = "maxAbsDeviation", 
               x.num = NULL, x.fac = NULL, nonx.fac.order = NULL,  
               x.pred.values = NULL, x.plot.values = NULL, 
               plots = "predictions", panels = "multiple", 
               graphics.device = NULL, interval.annotate = TRUE,
               titles = NULL, colour.scheme = "colour", save.plots = FALSE, 
               transform.power = 1, offset = 0, scale = 1, 
               transform.function = "identity", 
               tables = "all", level.length = NA, 
               sortFactor = NULL, sortParallelToCombo = NULL, 
               sortNestingFactor = NULL, sortOrder = NULL, 
               decreasing = FALSE, 
               trace = FALSE, ggplotFuncs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictPresent.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p><code>asreml</code> object for a fitted model.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_terms">terms</code></td>
<td>
<p>A <code>character vector</code> giving the terms for which predictions 
are required.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_inestimable.rm">inestimable.rm</code></td>
<td>
<p>A <code>logical</code> indicating whether rows for  predictions that 
are not estimable are to be removed from the components of the
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_linear.transformation">linear.transformation</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>. 
If a <code><a href="stats.html#topic+formula">formula</a></code> is given then it is taken to be a submodel of 
a model term corresponding to the <code>classify</code>. The projection matrix 
that transforms the <code>predictions</code> so that they conform to the submodel 
is obtained; the submodel does not have to involve variables in the 
<code>classify</code>, but the variables must be columns in the <code>predictions</code> 
component of <code>alldiffs.obj</code> and the space for the submodel must be a 
subspace of the space for the term specified by the <code>classify</code>. 
For example, for <code>classify</code> set to <code>"A:B"</code>, the submodel 
<code>~ A + B</code> will result in the <code>predictions</code> for the combinations of 
<code>A</code> and <code>B</code> being made additive for the <code><a href="base.html#topic+factor">factor</a>s</code> 
<code>A</code> and <code>B</code>. The submodel space corresponding to <code>A + B</code> is 
a subspace of the space <code>A:B</code>. In this case both the submodel and the 
classify involve only the factors A and B. To fit an intercept-only 
submodel, specify <code>linear.transformation</code> to be the formula <code>~1</code>.
</p>
<p>If a <code><a href="base.html#topic+matrix">matrix</a></code> is provided then it will be 
used to apply the linear transformation to the <code>predictions</code>. 
It might be a contrast <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code> of 
weights for a factor used to obtain the weighted average over that factor. 
The number of rows in the <code><a href="base.html#topic+matrix">matrix</a></code> should equal the 
number of linear combinations of the <code>predictions</code> desired and 
the number of columns should equal the number of <code>predictions</code>.
</p>
<p>In either case, as well as the values of the linear combinations, 
their standard errors, pairwise differences and associated statistics 
are returned in the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A <code>character</code> string indicating the type of error interval, if any, 
to calculate in order to indicate uncertainty in the results. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. The default is for confidence limits to 
be used. The <code>"halfLeastSignificant"</code> option results in half the 
Least Significant Difference (LSD) being added and subtracted to the 
predictions, the LSD being calculated using the square root of the mean of the 
variances of all or a subset of pairwise differences between the predictions. 
If the LSD is zero, as can happen when predictions are constrained to be equal,
then the limits of the error intervals are set to <code>NA</code>. 
If <code>LSDtype</code> is set to <code>overall</code>, the <code>avsed.tolerance</code> is not 
<code>NA</code> and the range of the SEDs divided by the average of the SEDs exceeds 
<code>avsed.tolerance</code> then the <code>error.intervals</code> calculations and the plotting 
will revert to confidence intervals.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_wald.tab">wald.tab</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the pseudo-anova table for the 
fixed terms produced by a call to <code>wald.asreml</code>. The main 
use of it here is in determining the degrees of freedom for 
calculating confidence or half-LSD <code>error.intervals</code> and p-values, 
the latter to be stored in the <code>p.differences</code> component of the 
<code>alldiffs.object</code> that is created.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_ddf.na">dDF.na</code></td>
<td>
<p>The method to use to obtain approximate denominator degrees of freedom. 
when the numeric or algebraic methods produce an <code>NA</code>. Consistent with 
when no denDF are available, the default is <code>"residual"</code> and so the residual 
degrees of freedom from <code>asreml.obj$nedf</code> are used. If 
<code>dDF.na = "none"</code>, no substitute denominator degrees of freedom 
are employed; if <code>dDF.na = "maximum"</code>, the maximum of those denDF 
that are available, excluding that for the Intercept, is used; if all 
denDF are <code>NA</code>, <code>asreml.obj$nedf</code> is used. If 
<code>dDF.na = "supplied"</code>, a <code>vector</code> of values for the 
denominator degrees of freedom is to be supplied in <code>dDF.values</code>. 
Any other setting is ignored and a warning message produced. Generally, 
substituting these degrees of freedom is anticonservative in that it 
is likely that the degrees of freedom used will be too large.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_ddf.values">dDF.values</code></td>
<td>
<p>A <code>vector</code> of values to be used when <code>dDF.na = "supplied"</code>. 
Its values will be used when <code>denDF</code> in a test for a fixed effect
is <code>NA</code>. This vector must be the same length as the number of 
fixed terms, including (Intercept) whose value could be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_pairwise">pairwise</code></td>
<td>
<p>A logical indicating whether all pairwise differences of the
<code>predictions</code> and their standard errors and p-values are to be 
computed and stored. If <code>tables</code> is equal to <code>"differences"</code> 
or <code>"all"</code> or <code>error.intervals</code> is equal to 
<code>"halfLeastSignificant"</code>, they will be stored irrespective of the 
value of <code>pairwise</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_vmatrix">Vmatrix</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the variance matrix of the 
<code>predictions</code> will be stored as a component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
that is returned. If <code>linear.transformation</code> is set, it will 
be stored irrespective of the value of <code>Vmatrix</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_avsed.tolerance">avsed.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the SED range, the range of the SEDs 
divided by the square root of the mean of the variances of all or a subset of the 
pairwise differences, that is considered reasonable in calculating 
<code>error.intervals</code>. It should be a value between 0 and 1. The following rules apply:
</p>

<ol>
<li><p> If <code>avsed.tolerance</code> is <code>NA</code> then mean LSDs of the type specified by 
<code>LSDtype</code> are calculated and used in <code>error.intervals</code> and plots.
</p>
</li>
<li><p> Irrespective of the setting of <code>LSDtype</code>, if <code>avsed.tolerance</code> is not 
exceeded then the mean LSDs are used in <code>error.intervals</code> and plots. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>overall</code>, <code>avsed.tolerance</code> is not 
<code>NA</code>, and <code>avsed.tolerance</code> is exceeded then  <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>factor.combinations</code> and <code>avsed.tolerance</code> 
is not exceeded for any factor combination then the half LSDs are 
used in <code>error.intervals</code> and plots; otherwise, <code>error.intervals</code> and 
plotting revert to confidence intervals.
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>per.prediction</code> and <code>avsed.tolerance</code> 
is not exceeded for any prediction then the half LSDs are used in <code>error.intervals</code> 
and plots; otherwise, <code>error.intervals</code> and plotting revert to confidence intervals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_accuracy.threshold">accuracy.threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value of the LSD accuracy measure,  
which measure is specified by <code>LSDaccuracy</code>, as a threshold value in determining whether the 
<code>hallfLeastSignificant</code> <code>error.interval</code> for a predicted value is a reasonable  
approximation; this will be the case if the LSDs across all pairwise comparisons for which 
the interval's LSD was computed, as specified by <code>LSDtype</code> and <code>LSDby</code>, 
are similar enough to the interval's LSD, as measured by <code>LSDaccuracy</code>.  
If it is <code>NA</code>, it will be ignored. If it is 
not <code>NA</code>, a column of <code><a href="base.html#topic+logical">logical</a>s</code> named <code>LSDwarning</code>  will be added 
to the <code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The value of 
<code>LSDwarning</code> for a <code>predicted.value</code> will be <code>TRUE</code> if the value of the 
<code>LSDaccuracy</code> measure computed from the LSDs for differences between this 
<code>predicted.value</code> and the other <code>predicted.values</code> as compared to its 
<code>assignedLSD</code> exceeds the value of <code>accuracy.threshold</code>. Otherwise, the 
value of <code>LSDwarning</code> for a <code>predicted.value</code> will be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_x.num">x.num</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the numeric covariate that 
(i) is potentially included in terms in the fitted model and (ii) is the 
x-axis variable for plots. Its values will not be converted to a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_x.fac">x.fac</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor that 
(i) corresponds to <code>x.num</code> and (ii) is potentially included in 
terms in the fitted model. It should have the same number of levels as the 
number of unique values in <code>x.num</code>. The levels of 
<code>x.fac</code> must be in the order in which they are to be plotted 
- if they are dates, then they should be in the form 
yyyymmdd, which can be achieved using <code>as.Date</code>. However, the levels
can be non-numeric in nature, provided that <code>x.num</code> is also set.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_nonx.fac.order">nonx.fac.order</code></td>
<td>
<p>A <code>character vector</code> giving the order in which factors other 
than <code>x.fac</code> are to be plotted in plots with multiple panels 
(i.e. where the number of non-x factors is greater than 1). 
The first factor in the vector 
will be plotted on the X axis (if there is no <code>x.num</code> or 
<code>x.fac</code>. Otherwise, the order of plotting the factors is in 
columns (X facets) and then rows (Y facets). By default the order is 
in decreasing order for the numbers of levels of the non x factors.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_x.pred.values">x.pred.values</code></td>
<td>
<p>The values of <code>x.num</code> for which predicted values are required.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_x.plot.values">x.plot.values</code></td>
<td>
<p>The actual values to be plotted on the x axis or in the labels of 
tables. They are 
needed when values different to those in <code>x.num</code> are to be 
plotted or <code>x.fac</code> is to be plotted because there is no 
<code>x.num</code> term corresponding to the same term with <code>x.fac</code>.</p>
</td></tr> 
<tr><td><code id="predictPresent.asreml_+3A_plots">plots</code></td>
<td>
<p>Possible values are <code>"none"</code>, <code>"predictions"</code>, 
<code>"backtransforms"</code> and <code>"both"</code>. Plots are not produced 
if the value is <code>"none"</code>. If data are not transformed for 
analysis (<code>transform.power</code> = 1), a plot of the predictions 
is produced provided <code>plots</code> is not <code>"none"</code>. If the 
data are transformed, the value of <code>plots</code> determines what 
is produced.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_panels">panels</code></td>
<td>
<p>Possible values are <code>"single"</code> and <code>"multiple"</code>. 
When line plots are to be produced, because variables involving 
<code>x.num</code> or <code>x.fac</code> are involved in <code>classify</code> for 
the predictions, <code>panels</code> determines whether or not a single 
panel or multiple panels in a single window are produced. The 
<code>panels</code> argument is ignored for bar charts.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_graphics.device">graphics.device</code></td>
<td>
<p>A <code>character</code> specifying a graphics device for plotting. 
The default is <br /><code>graphics.device = NULL</code>, which will result 
in plots being produced on the current graphics device. Setting it to 
<code>"windows"</code>, for example,  will result in a windows graphics 
device being opened.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_interval.annotate">interval.annotate</code></td>
<td>
<p>A <code>logical</code> indicating whether the plot annotation indicating the 
type of <code>error.interval</code> is to be included in the plot.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_titles">titles</code></td>
<td>
<p>A <code>list</code>, each component of which is named for a column in 
the <code>data.frame</code> for <code>asreml.obj</code> and contains a 
<code>character string</code> giving a title to use in output (e.g. tables and 
graphs). Here they will be used for axis labels.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_colour.scheme">colour.scheme</code></td>
<td>
<p>A character string specifying the colour scheme for the plots. 
The default is <code>"colour"</code> which produces coloured lines and bars, 
a grey background and white gridlines. A value of <code>"black"</code> 
results in black lines, grey bars and gridlines and a white background.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_save.plots">save.plots</code></td>
<td>
<p>A <code>logical</code> that determines whether any plots will be saved. 
If they are to be saved, a file name will be generated that consists of the 
following elements separated by full stops: the response variable name with 
<code>.back</code> if backtransformed values are being plotted, 
the classify term, <code>Bar</code> or <code>Line</code> and, if <code>error.intervals</code> 
is not <code>"none"</code>, one of <code>SE</code>, <code>CI</code> or <code>LSI</code>. The 
file will be saved as a &lsquo;png&rsquo; file in the current work directory.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_transform.power">transform.power</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the power of a transformation, if 
one has been applied to the response variable. Unless it is equal 
to 1, the default, back-transforms of the predictions will be 
obtained and stored in the <code>backtransforms</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The <code>plots</code> and <code>tables</code> arguments 
control the plotting and output of the <code>predictions</code> and 
<code>backtransforms</code>. 
The back-transformation raises the predictions to the power equal 
to the reciprocal of <code>transform.power</code>, unless it equals 0 in 
which case the exponential of the predictions is taken.</p>
</td></tr> 
<tr><td><code id="predictPresent.asreml_+3A_offset">offset</code></td>
<td>
<p>A number that has been added to each value of the response after any scaling 
and before applying any power transformation. Unless it is equal to 0, the 
default, back-transforms of the predictions will be obtained and stored in 
the <code>backtransforms</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The <code>plots</code> and <code>tables</code> arguments 
control the plotting and output of the <code>predictions</code> and 
<code>backtransforms</code>. The backtransformation will, after 
backtransforming for any power transformation, subtract the <code>offset</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_scale">scale</code></td>
<td>
<p>A number by which each value of the response has been multiply before adding 
any offset and applying any power transformation. Unless it is equal to 1, the
default, back-transforms of the predictions will be obtained and stored in 
the <code>backtransforms</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The <code>plots</code> and <code>tables</code> arguments 
control the plotting and output of the <code>predictions</code> and 
<code>backtransforms</code>. The backtransformation will, after backtransforming 
for any power transformation and then subtracting the offset, divide by the <code>scale</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_transform.function">transform.function</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a function that 
specifies the scale on which the predicted values are defined. This may be the 
result of a transformation of the data using the function or the use of the 
function as a link function in the fitting of a generalized linear (mixed) 
model (GL(M)M). The possible <code>transform.function</code>s are 
<code>identity</code>, <code>log</code>, <code>inverse</code>, <code>sqrt</code>, <code>logit</code>, 
<code>probit</code>, and <code>cloglog</code>.  The <code>predicted.values</code> and 
<code>error.intervals</code>, if not <code>StandardError</code> intervals, will be 
back-transformed using the inverse function of the <code>transform.function</code>. 
The <code>standard.error</code> column will be set to <code>NA</code>, unless (i) 
<code>asreml</code> returns columns named <code>transformed.value</code> and 
<code>approx.se</code>, as well as those called <code>predicted.values</code> and 
<code>standard.error</code> (such as when a GLM is fitted) and 
(ii) the values in <code>transformed.value</code> are equal to those obtained by 
backtransforming the <code>predicted.value</code>s using the inverse function 
of the <code>transform.function</code>. Then, the <code>approx.se</code> values will be 
saved in the <code>standard.error</code> column of the <code>backtransforms</code> 
component of the returned <code>alldiffs.obj</code>. Also, the 
<code>transformed.value</code> and <code>approx.se</code> columns are removed from both 
the <code>predictions</code> and <code>backtransforms</code> components of the 
<code>alldiffs.obj</code>. Note that the values that end up in the <code>standard errors</code> 
column are approximate for the backtransformed values and are not used in 
calculating <code>error.intervals</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_tables">tables</code></td>
<td>
<p>A <code>character vector</code> containing a combination of 
<code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, 
<code>differences</code>, <code>p.differences</code>, <code>sed</code>, 
<code>LSD</code> and <code>all</code>.
These nominate which components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
to print.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_level.length">level.length</code></td>
<td>
<p>The maximum number of characters from the levels of 
factors to use in the row and column labels of the tables produced by 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code>character vector</code> whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code>logical</code> passed to <code>order</code> that detemines whether 
the order for sorting the components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is for 
increasing or decreasing magnitude of the predicted values.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. 
It is passed to <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="predictPresent.asreml_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>predict.asreml</code> via 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code> and to <code>ggplot</code> 
via <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> containing an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> for each <code>term</code> for 
which tables are produced. The names of the components of this list are 
the <code>terms</code> with full-stops (<code>.</code>) replacing colons (<code>:</code>). 
Plots are also preduced depending on the setting of the <code>plot</code> 
argument.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <br /> 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  
<code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, <br /> 
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code>as.Date</code>, <code>Devices</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(WaterRunoff.dat)
titles &lt;- list("Days since first observation", "Days since first observation", 
               "pH", "Turbidity (NTU)")
names(titles) &lt;- names(WaterRunoff.dat)[c(5,7,11:12)]
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = log.Turbidity ~ Benches + Sources + Type + Species + 
                                 Sources:Type + Sources:Species + Sources:Species:xDay + 
                                 Sources:Species:Date, 
                      data = WaterRunoff.dat, keep.order = TRUE)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

#### Get the observed combinations of the factors and variables in classify
class.facs &lt;- c("Sources","Species","Date","xDay")
levs &lt;- as.data.frame(table(WaterRunoff.dat[class.facs]))
levs &lt;- levs[do.call(order, levs), ]
levs &lt;- as.list(levs[levs$Freq != 0, class.facs])
levs$xDay &lt;- as.numfac(levs$xDay)
  
#### parallel and levels are arguments from predict.asreml
diff.list &lt;- predictPresent.asreml(asreml.obj = current.asrt$asreml.obj, 
                                   terms = "Date:Sources:Species:xDay",
                                   x.num = "xDay", x.fac = "Date", 
                                   parallel = TRUE, levels = levs, 
                                   wald.tab = current.asrt$wald.tab, 
                                   plots = "predictions", 
                                   error.intervals = "StandardError", 
                                   titles = titles, 
                                   transform.power = 0, 
                                   present = c("Type","Species","Sources"), 
                                   tables = "none", 
                                   level.length = 6)

## End(Not run)</code></pre>

<hr>
<h2 id='print.alldiffs'>Prints the values in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> in a nice format.</h2><span id='topic+print.alldiffs'></span>

<h3>Description</h3>

<p>Prints the predictions and standard errors from a fitted model, 
including the attributes of the <code><a href="#topic+predictions.frame">predictions.frame</a></code>. Also prints out all 
pairwise differences between the predictions to 2 significant figures,  
along with their p-values and standard errors to 4 decimal places. If LSDs are 
requested the mean, minimum and maximum LSDs will be printed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
print(x, which = "all", colourise = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.alldiffs_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="print.alldiffs_+3A_which">which</code></td>
<td>
<p>A <code>character vector</code> containing a combination of 
<code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, 
<code>differences</code>, <code>p.differences</code>, <code>sed</code>, 
<code>LSD</code> and <code>all</code>.
These nominate which components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
to print.</p>
</td></tr>
<tr><td><code id="print.alldiffs_+3A_colourise">colourise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, results in the header 
text produced by <code>predict.asreml</code> being displayed in a different colour, if 
supported by the output terminal device. It overrides the <code>TRUE</code> 
setting of the <code>colourise</code> argument of <code>asreml::asreml.options</code>.</p>
</td></tr>
<tr><td><code id="print.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print.predictions.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but the components of <code>x</code> are printed.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.predictions.frame">print.predictions.frame</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
print.alldiffs(diffs, which = "predictions")

## End(Not run)</code></pre>

<hr>
<h2 id='print.asrtests'>Prints the values in an <code><a href="#topic+asrtests.object">asrtests.object</a></code></h2><span id='topic+print.asrtests'></span>

<h3>Description</h3>

<p>Prints a <code>summary</code> of the asreml object, the <code>pseudoanova</code> and 
the test.summary <code>data.frame</code> that are stored in the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
print(x, which = "key", colourise = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.asrtests_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="print.asrtests_+3A_which">which</code></td>
<td>
<p>Which elements of the <code><a href="#topic+asrtests.object">asrtests.object</a></code> to print. Possible
values are some combination of <code>asremlsummary</code>, <code>vparametersummary</code>,
<code>pseudoanova</code>, <code>wald.tab</code>, <code>testsummary</code> and <code>key</code> or 
<code>all</code>. The option <code>wald.tab</code> is a synonym for <code>pseudoanova</code>. 
The options <code>key</code> and <code>all</code> are mutually exclusive; <code>key</code> 
includes <code>vparametersummary</code>, but not the rest of <code>asremlsummary</code>, while 
<code>all</code> includes the full <code>asremlsummary</code> that includes the 
<code>vparametersummary</code>.</p>
</td></tr>
<tr><td><code id="print.asrtests_+3A_colourise">colourise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, results in the header 
text produced by <code>wald.asreml</code> being displayed in a different colour, if 
supported by the output terminal device. It overrides the <code>TRUE</code> 
setting of the <code>colourise</code> argument of <code>asreml::asreml.options</code>.</p>
</td></tr>
<tr><td><code id="print.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code> and <code>print.wald.tab</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but the elements of the list in <code>x</code> are 
printed.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.wald.tab">print.wald.tab</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Test Row autocorrelation
current.asrt &lt;- testresidual(current.asrt, , "~ Row:ar1(Column)", 
                             label="Row autocorrelation", simpler=TRUE)
print(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='print.LSDdata'>Prints the components of a list containing data on the LSDs for all pairwise differences of predictions.</h2><span id='topic+print.LSDdata'></span>

<h3>Description</h3>

<p>Prints the components of an <code>LSDdata</code> <code><a href="base.html#topic+list">list</a></code> created by <code><a href="#topic+exploreLSDs">exploreLSDs</a></code>, 
that contains data on the LSDs for all pairwise differences of predictions stored in an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LSDdata'
print(x, which.print = c("statistics", "false.pos", "false.neg"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.LSDdata_+3A_x">x</code></td>
<td>
<p>An object that, ideally, is of class <code>LSDdata</code>.</p>
</td></tr>
<tr><td><code id="print.LSDdata_+3A_which.print">which.print</code></td>
<td>
<p>Which components of the <code>LSDdata</code> <code><a href="base.html#topic+list">list</a></code> to print. 
Possible values are any combination of <code>frequencies</code>, 
<code>distinct.vals</code>, <code>statistics</code>,   <code>accuracy</code>, 
<code>false.pos</code>, <code>false.neg</code>, 
<code>per.pred.accuracy</code>, <code>LSD</code>, <code>summary</code> and <code>all</code>, 
except that <code>summary</code> and <code>all</code> cannot occur together. 
For a description of the components, see <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
The default is to print <code>statistics</code>, <code>false.pos</code>, 
<code>false.neg</code>. The option <code>summary</code> results in the printing of 
<code>distinct.vals</code>, <code>statistics</code>, <code>false.pos</code>, <code>false.neg</code>.</p>
</td></tr>
<tr><td><code id="print.LSDdata_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but components of <code>x</code> are printed as specified in <code>which.print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code>, <code><a href="#topic+alldiffs.object">alldiffs.object</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(WaterRunoff.dat)
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
diffs &lt;- predictPlus(classify = "Sources:Type", 
                     asreml.obj = current.asr, 
                     wald.tab = current.asrt$wald.tab, 
                     present = c("Sources", "Type", "Species"))
LSDdata &lt;- exploreLSDs(diffs, LSDtype = "factor.combinations", LSDby = "Sources")
print(LSDdata)

## End(Not run)</code></pre>

<hr>
<h2 id='print.predictions.frame'>Prints the values in a <code><a href="#topic+predictions.frame">predictions.frame</a></code>, with or without title and heading.</h2><span id='topic+print.predictions.frame'></span>

<h3>Description</h3>

<p>Prints the predictions from a fitted model, along with their standard errors and, if present, their error intervals, with or without title and headings.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictions.frame'
print(x, title = NULL,  
      which.predictions = c("title", "heading", "table"), 
      colourise = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.predictions.frame_+3A_x">x</code></td>
<td>
<p>An object that, ideally, is of class <code><a href="#topic+predictions.frame">predictions.frame</a></code>.</p>
</td></tr>
<tr><td><code id="print.predictions.frame_+3A_title">title</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving a title to be printed out before the 
<code>heading</code> and <code>table</code> for the <code><a href="#topic+predictions.frame">predictions.frame</a></code>,</p>
</td></tr>
<tr><td><code id="print.predictions.frame_+3A_which.predictions">which.predictions</code></td>
<td>
<p>what Which elements of the <code><a href="#topic+predictions.frame">predictions.frame</a></code> 
to print. Possible values are some combination of <code>title</code>, 
<code>heading</code>, <code>table</code> and <code>all</code>. The <code>heading</code> is an 
attribute of <code>x</code>.</p>
</td></tr>
<tr><td><code id="print.predictions.frame_+3A_colourise">colourise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, results in the header 
text produced by <code>predict.asreml</code> being displayed in a different colour, if 
supported by the output terminal device. It overrides the <code>TRUE</code> 
setting of the <code>colourise</code> argument of <code>asreml::asreml.options</code>, 
but is only operational when the <code>table</code> is also printed.</p>
</td></tr>
<tr><td><code id="print.predictions.frame_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print.predictions.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but the components of <code>x</code> are printed.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
print.predictions.frame(diffs$predictions, which = "all")

## End(Not run)</code></pre>

<hr>
<h2 id='print.test.summary'>Prints a data.frame containing a test.summary.</h2><span id='topic+print.test.summary'></span>

<h3>Description</h3>

<p>Prints a <code>test.summary</code> (also a <code>choose.summary</code>) with or without a title and with p-values limited to 4-digits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'test.summary'
print(x,  which.print = c("title", "table"), omit.columns = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.test.summary_+3A_x">x</code></td>
<td>
<p>A object that, ideally, is of class <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="print.test.summary_+3A_which.print">which.print</code></td>
<td>
<p>A <code>character</code> specifying the aspects of the <code>test.summary</code> to print. 
Possible values are some combination of <code>title</code>, 
<code>table</code> and <code>all</code>.</p>
</td></tr>
<tr><td><code id="print.test.summary_+3A_omit.columns">omit.columns</code></td>
<td>
<p>A <code>character</code> specifying the columns of the <code>test.summary</code> table 
to be omitted from the print. If <code>NULL</code>, none are omitted.</p>
</td></tr>
<tr><td><code id="print.test.summary_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code>, 
but is only operational when the <code>table</code> is also printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but <code>x</code> is printed, possibly with a title.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.wald.tab">print.wald.tab</a></code>, <code><a href="#topic+print.asrtests">print.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Test Row autocorrelation
current.asrt &lt;- testresidual(current.asrt, "~ Row:ar1(Column)", 
                             label="Row autocorrelation", simpler=TRUE)
print(current.asrt$test.summary)

## End(Not run)</code></pre>

<hr>
<h2 id='print.wald.tab'>Prints a data.frame containing a Wald or pseudoanova table.</h2><span id='topic+print.wald.tab'></span>

<h3>Description</h3>

<p>Prints a <code>wald.tab</code> with or without title and/or heading. 
The printing of the p-values is limited to 4 digits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wald.tab'
print(x, which.wald = c("title", "heading", "table"), 
      colourise = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wald.tab_+3A_x">x</code></td>
<td>
<p>An object that, ideally, is of class <code>wald.tab</code>.</p>
</td></tr>
<tr><td><code id="print.wald.tab_+3A_which.wald">which.wald</code></td>
<td>
<p>Which elements of the <code>wald.tab</code> to print. Possible
values are some combination of <code>title</code>, <code>heading</code>, 
<code>table</code> and <code>all</code>. The <code>heading</code> is an 
attribute of <code>x</code>.</p>
</td></tr>
<tr><td><code id="print.wald.tab_+3A_colourise">colourise</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, results in the header 
text produced by <code>wald.asreml</code> being displayed in a different colour, if 
supported by the output terminal device. It overrides the <code>TRUE</code> 
setting of the <code>colourise</code> argument of <code>asreml::asreml.options</code>.</p>
</td></tr>
<tr><td><code id="print.wald.tab_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code> and <code>print.wald.tab</code>, 
but is only operational when the <code>table</code> is also printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, but <code>x</code> is printed as specified in <code>which.wald</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.test.summary">print.test.summary</a></code>, <code><a href="#topic+print.asrtests">print.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Test Row autocorrelation
current.asrt &lt;- testresidual(current.asrt, "~ Row:ar1(Column)", 
                             label="Row autocorrelation", simpler=TRUE)
print(current.asrt$wald.tab)

## End(Not run)</code></pre>

<hr>
<h2 id='printFormulae.asreml'>Prints the formulae from an asreml object.</h2><span id='topic+printFormulae.asreml'></span><span id='topic+printFormulae'></span>

<h3>Description</h3>

<p>Prints the <code><a href="stats.html#topic+formula">formula</a></code>e nominated in the <code>which</code> argument from the <code>call</code> stored in an <code>asreml</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
printFormulae(asreml.obj, which = c("fixed", "random", "residual"), 
              expanded = FALSE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printFormulae.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An <code>asreml</code> object resulting from the fitting of 
a model using REML.</p>
</td></tr>
<tr><td><code id="printFormulae.asreml_+3A_which">which</code></td>
<td>
<p>A <code>character</code> listing the <code><a href="stats.html#topic+formula">formula</a></code>(e) to be printed from the 
<code>call</code> stored in <code>asreml.obj</code>. It should be some combination 
of <code>fixed</code>, <code>random</code>, <code>residual</code>, <code>sparse</code> and 
<code>all</code>. If <code>all</code> is included then all <code><a href="stats.html#topic+formula">formula</a></code>(e) 
will be printed.</p>
</td></tr>
<tr><td><code id="printFormulae.asreml_+3A_expanded">expanded</code></td>
<td>
<p>A <code>logical</code> indicating whether terms are to be expanded to the 
sum of a set of individual terms.</p>
</td></tr>
<tr><td><code id="printFormulae.asreml_+3A_envir">envir</code></td>
<td>
<p>The environment in which the <code><a href="stats.html#topic+formula">formula</a></code>(e) are to be evaluated. 
May also be <code>NULL</code>, a <code>list</code>, a <code>data.frame</code>, a <code>pairlist</code> 
or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
<tr><td><code id="printFormulae.asreml_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>getFormulae.asreml</code> and ultimately to 
<code>update.formula</code> and <code>terms.formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>character</code>, each element of which contains one of the extracted 
<code><a href="stats.html#topic+formula">formula</a></code>e.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+printFormulae.asreml">printFormulae.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   data(Wheat.dat)
   current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                         random = ~ Row + Column + units,
                         residual = ~ ar1(Row):ar1(Column), 
                         data=Wheat.dat)
    printFormulae(current.asr)

## End(Not run)</code></pre>

<hr>
<h2 id='R2adj.asreml'>Calculates the adjusted coefficient of determination for a specified combination of fixed and random terms.</h2><span id='topic+R2adj.asreml'></span><span id='topic+R2adj'></span>

<h3>Description</h3>

<p>Calculates the adjusted coefficient of determination (R2) that measures the contributions to the total 
variance exhibited by the observations of a specified combination of fixed and random terms in a 
fitted linear mixed model. This function is not available in ASReml-R version 3.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
R2adj(asreml.obj, 
      include.which.fixed = ~ ., orthogonalize = "hybrid", 
      include.which.random = NULL, 
      bound.exclusions = c("F","B","S","C"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2adj.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An <code>asreml</code> object returned from a call to <code>asreml</code>.</p>
</td></tr>
<tr><td><code id="R2adj.asreml_+3A_include.which.fixed">include.which.fixed</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> specifying the fixed terms whose joint contribution to 
the total variance is to be measured.  If it is <code>NULL</code>, no fixed term 
is to be included in the terms whose contributions is to be assessed. 
The formula <code>~ .</code> indicates that the joint contribution of all fixed terms are to 
be measured. Otherwise, the joint contribution of the set of terms in the formula will 
be assessed. The names of the terms in the <code><a href="stats.html#topic+formula">formula</a></code> must be the same as 
those in either the Wald table produced by <code>wald.asreml</code> or the <code>terms</code> attribute 
of the <code>fixed</code> component of the <code>coefficient</code> component of the supplied 
<code>asreml.obj</code>. 
</p>
<p>Note that the contribution of a subset of the fixed terms is only unique if the effects 
for the fixed terms are orthogonal; if the effects are not orthogonal then the 
contributions will depend on the order of the terms in the formula. Also, determining 
the joint contribution of a subset of the fixed terms in the model may be 
computationally demanding because the projection matrices have to be formed for all 
fixed terms and these projections matrices have to be orthogonalized. A heavy 
computational burden is most likely when the effects for the fixed terms are not 
orthogonal, for example, when numeric covariates are included amongst the terms.</p>
</td></tr>
<tr><td><code id="R2adj.asreml_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the method for orthogonalizing a 
projector to those for terms that occurred previously in the 
<code><a href="stats.html#topic+formula">formula</a></code> for <code>include.which.fixed</code>. Orthogonalizing the 
projectors of fixed terms is not performed for the default setting of 
<code>. ~</code>.  WHen required, two options are available for orthogonalizing: 
<code>hybrid</code> and <code>eigenmethods</code>. The <code>hybrid</code> option is the most 
general and uses the relationships between the projection operators for the 
terms in the <code>formula</code> to decide which <code><a href="dae.html#topic+projector">projector</a></code>s to 
subtract and which to orthogonalize using eigenmethods. The <code>eigenmethods</code> 
option recursively orthogonalizes the <code><a href="dae.html#topic+projector">projector</a></code>s 
using an eigenanalysis of each <code><a href="dae.html#topic+projector">projector</a></code> 
with previously orthogonalized <code><a href="dae.html#topic+projector">projector</a></code>s. 
See the documentation for <code>porthogonalize.list</code> from the R package 
<code>dae</code> for more information.</p>
</td></tr>
<tr><td><code id="R2adj.asreml_+3A_include.which.random">include.which.random</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> specifying the random terms whose joint 
contribution  to the total variance is to be measured.  If it is <code>NULL</code>, no 
random term is to be included in the terms whose joint contribution is to be assessed. 
The formula <code>~ .</code> indicates that the joint contribution of all random terms is 
to be measured. Otherwise, the joint contribution of the set of terms in the formula 
will be assessed. The terms in the <code><a href="stats.html#topic+formula">formula</a></code> must be on of those occurring 
in the <code>vparameters</code> component of the supplied <code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="R2adj.asreml_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound codes that 
will result in a variance parameter in the <code>random</code> model being excluded 
from contributing to the variance. If set to <code>NULL</code> then none will
be excluded.</p>
</td></tr>
<tr><td><code id="R2adj.asreml_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method used to compute the adjusted R2 under a linear mixes model (LMM) is that 
described by Piepho (2023). Here, the method has been extended to allow computation  
of the adjusted R2 for a subset of the fixed terms. A set of orthogonalized 
projectors for all of the fixed terms in the model (a set of 
<code class="reqn">\mathbf{Q}_i\mathrm{s}</code>) is obtained and the combined contribution of the 
fixed terms nominated in <code>include.which.fixed</code> is obtained by computing the 
average semisquared bias, ASSB, for the nominated fixed terms as:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_i \{(\mathbf{Q}_i \mathbf{X}\boldsymbol{\beta})^\mathrm{T}\mathbf{Q}_i \mathbf{X}\boldsymbol{\beta} + \textnormal{trace}(\mathbf{X}^\mathrm{T} \mathbf{Q}_i \mathbf{X} \mathrm{var}(\boldsymbol{\beta})) \} / (n - 1)</code>
</p>

<p>Of the two methods, <code>eigenmethods</code> is least likely to fail, but it does 
not establish the marginality between the terms. It is often needed when 
there is nonorthogonality between terms, such as when there are several linear 
covariates. It can also be more efficient in these circumstances.
</p>
<p>The process can be computationally expensive, particularly for a large data set 
(500 or more observations) and/or when many terms are to be orthogonalized, 
particularly if they are not orthogonal. 
</p>
<p>If the error <code>Matrix is not idempotent</code> should occur then, especially if 
there are  many terms, one might try using <code>set.daeTolerance</code> from the 
<code>dae</code> package to reduce the tolerance used in determining if values are 
either the same or are zero; it may be necessary to lower the tolerance to as 
low as 0.001. Also, setting <code>orthogonalize</code> to <code>eigenmethods</code> is 
worth a try.
</p>
<p>Note that the adjusted R2 can be negative, which indicates that the contribution 
of the terms to the total variance is very small relative to the sum of the 
degrees of freedom of the terms.
</p>
<p>The function <code>estimateV.asreml</code> is used to calculate the variance matrices 
required in calculating the adjusted R2.
</p>
<p>Piepho's (2023) method for GLMMs has not been implemented. 
</p>


<h3>Value</h3>

<p>A <code>numeric</code> that is the adjusted R2, expressed as a percentage.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Piepho, H.-P. (2023). An adjusted coefficient of determination (R2) for generalized 
linear mixed models in one go. <em>Biometrical Journal</em>, <b>65(7)</b>, 2200290. 
<a href="https://doi.org/10.1002/bimj.202200290">doi:10.1002/bimj.202200290</a>.</p>


<h3>See Also</h3>

<p><code>asreml</code>, <code><a href="#topic+estimateV.asreml">estimateV.asreml</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(Oats.dat)
  
  current.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                        random=~Blocks/Wplots,
                        data=Oats.dat)
  R2.adj.fix &lt;- R2adj.asreml(current.asr)
  R2.adj.ran &lt;- R2adj.asreml(current.asr, 
                             include.which.fixed = NULL, include.which.random = ~ .)
  R2.adj.tot &lt;- R2adj.asreml(current.asr, include.which.random = ~ .)
  R2.adj.add &lt;- R2adj.asreml(current.asr, include.which.fixed = ~ Nitrogen + Variety)

## End(Not run)</code></pre>

<hr>
<h2 id='ratioTransform.alldiffs'>Calculates the ratios of nominated pairs of predictions stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+ratioTransform.alldiffs'></span><span id='topic+ratioTransform'></span>

<h3>Description</h3>

<p>Ratio predictions and error intervals are formed for two levels of a factor, 
the <code>ratio.factor</code>. For each pair of a level of the <code>ratio.factor</code> 
in <code>numerator.levels</code> with a level in <code>denominator.levels</code>, 
the ratio predictions are formed from all combinations of the other factors 
as the ratio of the two predictions for each combination, along with confidence 
intervals for the ratio predictions computed using the Fieller (1954) method.
</p>
<p>The printing of the components produced is controlled by the 
<code>tables</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
ratioTransform(alldiffs.obj, ratio.factor, 
               numerator.levels, denominator.levels, 
               method = "Fieller", alpha = 0.05,  
               response = NULL, response.title = NULL, 
               tables = "predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioTransform.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_ratio.factor">ratio.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the name of the factor 
for whose levels the ratios are to be calculated.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_numerator.levels">numerator.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string containing the levels 
of <code>ratio.factor</code> to be used as numerators of the ratio.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_denominator.levels">denominator.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string containing the levels 
of <code>ratio.factor</code> to be used as denominators of the ratio.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_method">method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the method to use in calculating 
the ratios and their <code>error.intervals</code>. At present only <code>Fieller</code> 
is available. For the <code>Fieller</code> <code>method</code>, ratios of predictions 
are formed and confidence intervals formed for them using Fieller's (1954) theorem.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable for the 
predictions. It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> .</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_response.title">response.title</code></td>
<td>
<p>A <code>character</code> specifying the title for the response variable 
for the predictions. It is stored as an attribute to the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_tables">tables</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector containing either <code>none</code> or <code>predictions</code></p>
</td></tr>
<tr><td><code id="ratioTransform.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code><a href="#topic+predictions.frame">predictions.frame</a></code>s, each containing the ratio predictions 
and their confidence limits for a combination of the <code>numerator.levels</code> with the 
<code>denominator.levels</code>. It will also contain the values of the variables in the 
<code>classify</code> of <code>alldiffs.obj</code> that index the ratio predictions, except that 
the <code>ratio.factor</code> is omitted. 
</p>
<p>If <code>sortFactor</code> attribute of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is set and is not the 
<code>ratio.factor</code>, the predictions and their backtransforms will be sorted using 
the <code>sortOrder</code> attribute of the  <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Fieller, E. C. (1954). Some Problems in Interval Estimation. <em>Journal of the 
Royal Statistical Society.Series B (Methodological)</em>, <b>16</b>, 175-185.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairdiffsTransform">pairdiffsTransform</a></code>, <code><a href="#topic+linTransform">linTransform</a></code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, 
<code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <br /> 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>,  <code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <br /> 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,  
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>, <br />
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <br />
<code>as.Date</code>, <code>predict.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Form the ratios and Fieller CIs for RGR Salinity
load(system.file("extdata", "testDiffs.rda", package = "asremlPlus", mustWork = TRUE))
Preds.ratio.RGR &lt;- ratioTransform(diffs.RGR,
                                  ratio.factor = "Salinity", 
                                  numerator.levels = "Salt",
                                  denominator.levels = "Control")

#### Form the ratios and Fieller CIs for Nitrogen compared to no Nitrogen                                  
data("Oats.dat")
## Not run: 
m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                 random=~Blocks/Wplots,
                 data=Oats.dat)
current.asrt &lt;- as.asrtests(m1.asr)
wald.tab &lt;-  current.asrt$wald.tab
Var.diffs &lt;- predictPlus(m1.asr, classify="Nitrogen:Variety", pairwise = TRUE,
                         Vmatrix = TRUE, error.intervals = "halfLeast",
                         LSDtype = "factor", LSDby = "Variety",
                         wald.tab = wald.tab)

## End(Not run)

 ## Use lme4 and emmmeans to get predictions and associated statistics
if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
  ## Set up a wald.tab
  int &lt;- as.data.frame(rbind(rep(NA,4)))
  rownames(int) &lt;- "(Intercept)"
  wald.tab &lt;- anova(m1.lmer, ddf = "Kenward", type = 1)[,3:6]
  names(wald.tab) &lt;- names(int) &lt;- c("Df", "denDF", "F.inc", "Pr")
  wald.tab &lt;- rbind(int, wald.tab)
  #Get predictions
  Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
  Var.preds &lt;- summary(Var.emm)
  ## Modify Var.preds to be compatible with a predictions.frame
  Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                    se = "SE", interval.type = "CI", 
                                    interval.names = c("lower.CL", "upper.CL"))
  Var.vcov &lt;- vcov(Var.emm)
  Var.sed &lt;- NULL
  den.df &lt;- wald.tab[match("Variety", rownames(wald.tab)), "denDF"]
  
  #Create alldiffs object
  Var.diffs &lt;- as.alldiffs(predictions = Var.preds, 
                           sed = Var.sed, vcov = Var.vcov, 
                           classify = "Nitrogen:Variety", response = "Yield", tdf = den.df)
} 

if (exists("Var.diffs"))
  Preds.ratio.OatsN &lt;- ratioTransform(alldiffs.obj = Var.diffs,
                                      ratio.factor = "Nitrogen", 
                                      numerator.levels = c("0.2","0.4","0.6"),
                                      denominator.levels = "0.2")
</code></pre>

<hr>
<h2 id='recalcLSD.alldiffs'>Adds or recalculates the <code><a href="#topic+LSD.frame">LSD.frame</a></code> that is a component of an 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+recalcLSD.alldiffs'></span><span id='topic+recalcLSD'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, adds or recalculate its <code><a href="#topic+LSD.frame">LSD.frame</a></code>. 
<b>N.B. No changes are made to the error.intervals &mdash; use <code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>
to modify both the error.intervals and the <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</b>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
recalcLSD(alldiffs.obj, LSDtype = "overall", LSDsupplied = NULL, 
          LSDby = NULL, LSDstatistic = "mean", LSDaccuracy = "maxAbsDeviation", 
          alpha = 0.05, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalcLSD.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for an LSD to compare a pair of predictions.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="recalcLSD.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>; 
attributes <code>transform.power</code>, <code>offset</code> and <code>scale</code> cannot be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with components 
<code>predictions</code>, <code>vcov</code>, <code>differences</code>, <code>p.differences</code> 
<code>sed</code>, <code>LSD</code> and, if present in <code>alldiffs.obj</code>, <code>backtransforms</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, 
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <code><a href="#topic+print.alldiffs">print.alldiffs</a></code>,  <br /> 
<code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>, <code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code>, 
<code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>, <br />
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>,   
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <br />
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Species)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Species", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Recalculate the LSD values for predictions obtained using asreml or lmerTest  
  TS.diffs &lt;- recalcLSD.alldiffs(TS.diffs, LSDtype = "factor.combinations", 
                                 LSDby = "Sources")
}
</code></pre>

<hr>
<h2 id='recalcWaldTab.asrtests'>Recalculates the denDF, F.inc and P values for a table of Wald test statistics obtained 
using <code>wald.asreml</code></h2><span id='topic+recalcWaldTab.asrtests'></span><span id='topic+recalcWaldTab'></span>

<h3>Description</h3>

<p>If some or all denDF are not available, either because they are NA or because 
F.inc values were not calculated, this function allows the user to specify how 
approximate denDF values are to be obtained. This is done through the <code>dDF.na</code> and 
<code>dDF.values</code> arguments. Note that if denDF values are available in the Wald table then 
only those that are <code>NA</code> will be replaced. The P values are recalculated using F.con, 
if present in the <code>wald.tab</code>, otherwise F.inc is used. It is noted that, as of asreml version 4, 
<code>wald.asreml</code> has a <code>kenadj</code> argument.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
recalcWaldTab(asrtests.obj, recalc.wald = FALSE,
              denDF="numeric", dDF.na = "none", 
              dDF.values = NULL, trace = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalcWaldTab.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_recalc.wald">recalc.wald</code></td>
<td>
<p>A <code>logical</code> indicating whether to call <code>wald.asreml</code> to recalculate 
the pseudoanova table for the model fit stored in the <code>asreml</code> object 
contained in <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_ddf.na">dDF.na</code></td>
<td>
<p>The method to use to obtain substitute denominator degrees of freedom. 
when the numeric or algebraic methods produce an <code>NA</code>. If 
<code>dDF.na = "none"</code>, no substitute denominator degrees of freedom 
are employed; if <code>dDF.na = "residual"</code>, 
the residual degrees of freedom from <code>asreml.obj$nedf</code> are used; 
if <code>dDF.na = "maximum"</code>, the maximum of those denDF that are available, 
excluding that for the Intercept, is used; if all denDF are <code>NA</code>, 
<code>asreml.obj$nedf</code> is used. If <code>dDF.na = "supplied"</code>, 
a <code>vector</code> of values for the denominator degrees of freedom is to 
be supplied in <code>dDF.values</code>. Any other setting is ignored and 
a warning message produced. Generally, substituting these degrees of freedom is 
anticonservative in that it is likely that the degrees of freedom used will be
too large.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_ddf.values">dDF.values</code></td>
<td>
<p>A <code>vector</code> of values to be used when <code>dDF.na = "supplied"</code>. 
Its values will be used when <code>denDF</code> in a test for a fixed effect
is <code>NA</code>. This vector must be the same length as the number of 
fixed terms, including (Intercept) whose value could be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="recalcWaldTab.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>asreml</code> and to <code>wald.asreml</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>wald.tab</code>: a 4- or 6-column <code>data.frame</code> containing a 
pseudo-anova table for the fixed terms produced by <code>wald.asreml</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  wald.tab &lt;- recalcWaldTab(current.asrt, 
                            dDF.na = "supplied", 
                            dDF.values = c(NA,rep(c(330,346), c(4,3))))

## End(Not run)</code></pre>

<hr>
<h2 id='redoErrorIntervals.alldiffs'>Adds or replaces the error intervals stored in a prediction component 
of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</h2><span id='topic+redoErrorIntervals.alldiffs'></span><span id='topic+redoErrorIntervals'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, adds or replaces <code>error.intervals</code> 
for its <code>prediction</code> component. If the <code>backtransforms</code> component is 
present, the <code>transform.power</code>, <code>offset</code> and <code>scale</code> will be 
retrieved from the <code>backtransforms</code> attributes, ignoring the values for the 
function's arguments, and the backtransformed 
<code>error.intervals</code> will also be calculated. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
redoErrorIntervals(alldiffs.obj, error.intervals = "Confidence", 
                   alpha = 0.05, 
                   avsed.tolerance = 0.25, accuracy.threshold = NA,
                   LSDtype = NULL, LSDsupplied = NULL, 
                   LSDby = NULL, LSDstatistic = "mean", 
                   LSDaccuracy = "maxAbsDeviation", 
                   retain.zeroLSDs = FALSE, 
                   zero.tolerance = .Machine$double.eps ^ 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_error.intervals">error.intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string indicating the type of error interval, if any, 
to calculate in order to indicate uncertainty in the predicted values. 
Possible values are <code>"none"</code>, <code>"StandardError"</code>, <code>"Confidence"</code> 
and <code>"halfLeastSignificant"</code>. The default is for confidence limits to 
be used. The <code>"halfLeastSignificant"</code> option results in half the 
Least Significant Difference (LSD) being added and subtracted to the 
predictions, the LSD being calculated using the square root of the mean of the 
variances of all or a subset of pairwise differences between the predictions. 
If the LSD is zero, as can happen when predictions are constrained to be equal,
then the limits of the error intervals are set to <code>NA</code>. 
If <code>LSDtype</code> is set to <code>overall</code>, the <code>avsed.tolerance</code> is not 
<code>NA</code> and the range of the SEDs divided by the average of the SEDs exceeds 
<code>avsed.tolerance</code> then the <code>error.intervals</code> calculations and the plotting 
will revert to confidence intervals.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the significance level for LSDs or one minus 
the confidence level for confidence intervals.
It is stored as an attribute to the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_avsed.tolerance">avsed.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the SED range, the range of the SEDs 
divided by the square root of the mean of the variances of all or a subset of the 
pairwise differences, that is considered reasonable in calculating 
<code>error.intervals</code>. To have it ignored, set it to <code>NA</code>. It should be a 
value between 0 and 1. The following rules apply:
</p>

<ol>
<li><p> If <code>avsed.tolerance</code> is <code>NA</code> then mean LSDs of the type specified by 
<code>LSDtype</code> are calculated and used in <code>error.intervals</code> and plots.
</p>
</li>
<li><p> Irrespective of the setting of <code>LSDtype</code>, if <code>avsed.tolerance</code> is not 
exceeded then the mean LSDs are used in <code>error.intervals</code> and plots. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>overall</code>, <code>avsed.tolerance</code> is not 
<code>NA</code>, and <code>avsed.tolerance</code> is exceeded then  <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>factor.combinations</code> and <code>avsed.tolerance</code> 
is not exceeded for any factor combination then the half LSDs are 
used in <code>error.intervals</code> and plots; otherwise, <code>error.intervals</code> and 
plotting revert to confidence intervals. 
</p>
</li>
<li><p> If <code>LSDtype</code> is set to <code>per.prediction</code> and <code>avsed.tolerance</code> 
is not exceeded for any prediction then the half LSDs are used in <code>error.intervals</code> 
and plots; otherwise, <code>error.intervals</code> and plotting revert to confidence intervals.
</p>
</li></ol>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_accuracy.threshold">accuracy.threshold</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value of the LSD accuracy measure,  
which measure is specified by <code>LSDaccuracy</code>, as a threshold value in determining whether the 
<code>hallfLeastSignificant</code> <code>error.interval</code> for a predicted value is a reasonable  
approximation; this will be the case if the LSDs across all pairwise comparisons for which 
the interval's LSD was computed, as specified by <code>LSDtype</code> and <code>LSDby</code>, 
are similar enough to the interval's LSD, as measured by <code>LSDaccuracy</code>.  
If it is <code>NA</code>, it will be ignored. If it is 
not <code>NA</code>, a column of <code><a href="base.html#topic+logical">logical</a>s</code> named <code>LSDwarning</code>  will be added 
to the <code>predictions</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The value of 
<code>LSDwarning</code> for a <code>predicted.value</code> will be <code>TRUE</code> if the value of the 
<code>LSDaccuracy</code> measure computed from the LSDs for differences between this 
<code>predicted.value</code> and the other <code>predicted.values</code> as compared to its 
<code>assignedLSD</code> exceeds the value of <code>accuracy.threshold</code>. Otherwise, the 
value of <code>LSDwarning</code> for a <code>predicted.value</code> will be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_lsdtype">LSDtype</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that can be <code>overall</code>, <code>factor.combinations</code>, 
<code>per.prediction</code> or <code>supplied</code>. It determines whether the values stored in a row  
of a <code><a href="#topic+LSD.frame">LSD.frame</a></code> are the values calculated 
(i) <code>overall</code> from the LSD values for all pairwise comparison2, 
(ii) the values calculated from the pairwise LSDs for the levels of each 
<code>factor.combination</code>, unless there is only one prediction for a level  of the 
<code>factor.combination</code>, when a notional LSD is calculated,  
(iii) <code>per.prediction</code>, being based, for each prediction, on all pairwise differences 
involving that prediction, or 
(iv) as <code>supplied</code> values of the LSD, specified with the <code>LSDsupplied</code> argument; 
these supplied values are to be placed in the <code>assignedLSD</code> column of the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> so that they can be used 
in LSD calculations.
</p>
<p>If <code>LSDtype</code> is <code>NULL</code> (the default), the <code>LSDtype</code> attribute of the 
<code>alldiffs.obj</code> will be used; it is also <code>NULL</code>, then the <code>LSDtype</code> will 
be set to <code>overall</code>.
</p>
<p>See <code><a href="#topic+LSD.frame">LSD.frame</a></code> for further information on the values in a row of this 
<code>data.frame</code> and how they are calculated.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_lsdsupplied">LSDsupplied</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a named <code><a href="base.html#topic+numeric">numeric</a></code> containing a set of <code>LSD</code> 
values that correspond to the observed combinations of the values of the <code>LSDby</code> variables 
in the <code><a href="#topic+predictions.frame">predictions.frame</a></code> or a single LSD value that is an overall LSD. 
If a <code><a href="base.html#topic+data.frame">data.frame</a></code>, it may have (i) a column for the <code>LSDby</code> variable and a column 
of <code>LSD</code> values or (ii) a single column of <code>LSD</code> values with rownames being the 
combinations of the observed values of the <code>LSDby</code> variables. Any name can be used 
for the column of <code>LSD</code> values; <code>assignedLSD</code> is sensible, but not obligatory. Otherwise, 
a <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>LSD</code> values, each of which is named for the observed 
combination of the values of the <code>LSDby</code> variables to which it corresponds. (Applying the 
<code>function</code> <code>dae::fac.combine</code> to the <code>predictions</code> component is one way of 
forming the required combinations for the (row) names.)  The values supplied 
will be incorporated into <code>assignedLSD</code> column of the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored as the 
<code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_lsdby">LSDby</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> (vector) of variables names, being the names of the 
<code><a href="base.html#topic+factor">factor</a>s</code> or <code><a href="base.html#topic+numeric">numeric</a>s</code> in the <code>classify</code>; for each 
combination of their levels and values, there will be or is a row in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> 
stored in the <code>LSD</code> component of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> when <code>LSDtype</code> is 
<code>factor.combinatons</code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_lsdstatistic">LSDstatistic</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one or more of <code>minimum</code>, <code>q10</code>, <code>q25</code>,  
<code>mean</code>, <code>median</code>, <code>q75</code>, <code>q90</code> or <code>maximum</code> as the value(s) to be 
stored in the <code>assignedLSD</code> column in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>; the values in the 
<code>assignedLSD</code> column are used in computing <code>halfLeastSignificant</code> <code>error.intervals</code>. 
Here <code>q10</code>,  <code>q25</code>, <code>q75</code> and <code>q90</code> indicate the sample quantiles corresponding 
to probabilities of 0.1, 0.25, 0.75 and 0.9 for the group of LSDs from which a single LSD value 
is calculated. The function <code><a href="stats.html#topic+quantile">quantile</a></code> is used to obtain them. The <code>mean</code> LSD is 
calculated as the square root of the mean of the squares of the LSDs for the group. The 
<code>median</code> is calculated using the <code><a href="stats.html#topic+median">median</a></code> function. Multiple values are only 
produced for <code>LSDtype</code> set to <code>factor.combination</code>, in which case <code>LSDby</code> must 
not be <code>NULL</code> and the number of values must equal the number of observed combinations of 
the values of the variables specified by <code>LSDby</code>.  If <code>LSDstatistic</code> is <code>NULL</code>, 
it is reset to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_lsdaccuracy">LSDaccuracy</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating one of <code>maxAbsDeviation</code>, <code>maxDeviation</code>, 
<code>q90Deviation</code> or <code>RootMeanSqDeviation</code> as the statistic to be calculated as a measure 
of the accuracy of <code>assignedLSD</code>. The option <code>q90Deviation</code> produces the sample quantile 
corresponding to a probability of 0.90. The deviations are the differences between the LSDs used in 
calculating the LSD statistics and each assigned LSD and the accuracy is expressed as a 
proportion of the assigned LSD value. The calculated values are stored in the column named 
<code>accuracyLSD</code> in an <code><a href="#topic+LSD.frame">LSD.frame</a></code>.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_retain.zerolsds">retain.zeroLSDs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to retain or omit LSDs that are zero when 
calculating the summaries of LSDs.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_zero.tolerance">zero.tolerance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the value such that if an LSD is less than it, the LSD will be 
considered to be zero.</p>
</td></tr>
<tr><td><code id="redoErrorIntervals.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with components 
<code>predictions</code>, <code>vcov</code>, <code>differences</code>, <code>p.differences</code> 
<code>sed</code>, <code>LSD</code> and, if present in <code>alldiffs.obj</code>, <code>backtransforms</code>. 
</p>
<p>If <code>error.intervals</code> is not <code>"none"</code>, then the 
<code>predictions</code> component and, if present, the 
<code>backtransforms</code> component will contain columns for the lower 
and upper values of the limits for the interval. The names of these 
columns will consist of three parts separated by full stops: 
1) the first part will be <code>lower</code> or <code>upper</code>; 
2) the second part will be one of <code>Confidence</code>, 
<code>StandardError</code> or <code>halfLeastSignificant</code>; 
3) the third component will be <code>limits</code>.
</p>
<p>The name of the <code>response</code>, the <code>term</code>, the <code>classify</code> and 
<code>tdf</code>, as well as the degrees of freedom of the standard error, will be set 
as attributes to the object.
Also, if <code>error.intervals</code> is <code>"halfLeastSignificant"</code>, then those of 
<code>LSDtype</code>, <code>LSDby</code> and <code>LSDstatistic</code> that are not <code>NULL</code> 
will be added as attributes of the object and of the <code>predictions frame</code>; 
additionally, <code>LSDvalues</code> will be added as attribute of the 
<code>predictions frame</code>, <code>LSDvalues</code> being the LSD values used in 
calculating the <code>error.intervals</code>. 
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <code><a href="#topic+exploreLSDs.alldiffs">exploreLSDs.alldiffs</a></code>,  
<code><a href="#topic+pickLSDstatistics.alldiffs">pickLSDstatistics.alldiffs</a></code>,  <br />
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code>,  <code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, 
<code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, <br />
<code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>,  
<code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code>, <br />
<code>as.Date</code>, <code>predict.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus(classify = "Sources:Type", 
                        asreml.obj = current.asr, 
                        wald.tab = current.asrt$wald.tab, 
                        present = c("Sources", "Type", "Species"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Species)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, 
                             classify = "Sources:Species", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Recalculate the LSD values for predictions obtained using asreml or lmerTest  
  TS.diffs &lt;- redoErrorIntervals.alldiffs(TS.diffs, 
                                          error.intervals = "halfLeastSignificant")

}
</code></pre>

<hr>
<h2 id='REMLRT.asreml'>Performs a REML ratio test to compare two models.</h2><span id='topic+REMLRT.asreml'></span><span id='topic+REMLRT'></span>

<h3>Description</h3>

<p>Extracts the REML log likelihood and the number of variance 
parameters from two <code>asreml</code> objects. It assumes that the 
first <code>asreml</code> object corresponds to the null hypothesis and 
the second <code>asreml</code> object to the alternative hypothesis for the 
test being conducted. That is, the second 
<code>asreml</code> object is the result of fitting a model that is a 
reduced version of the model for the first object. In the case 
where the reduced model is obtained by setting positively-constrained 
variance parameters in the full model to zero, the <code>positive.zero</code> 
argument should be set to <code>TRUE</code> so that 
the p-value is computed using a mixture of chi-square distributions as 
described in Self and Liang (1987).
</p>
<p>The function checks that the models do not differ in either their fixed 
or sparse models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
REMLRT(h0.asreml.obj, h1.asreml.obj, 
       positive.zero = FALSE, bound.test.parameters = "none", 
       DF = NULL, bound.exclusions = c("F","B","S","C"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REMLRT.asreml_+3A_h0.asreml.obj">h0.asreml.obj</code></td>
<td>
<p><code>asreml</code> object containing the fit under the model for the 
null hypothesis.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_h1.asreml.obj">h1.asreml.obj</code></td>
<td>
<p><code>asreml</code> object containing the fit under the model for the 
alternative hypothesis.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_positive.zero">positive.zero</code></td>
<td>
<p>Indicates whether the hypothesized values for the 
variance components being tested are on the boundary 
of the parameter space. For example, this is true 
for positively-constrained variance components that, 
under the reduced model, are zero. This argument does 
not need to be set if <code>bound.test.parameters</code> is set.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_bound.test.parameters">bound.test.parameters</code></td>
<td>
<p>Indicates whether for the variance components 
being tested, at least some of the hypothesized values
are on the boundary of the parameter space. 
The possibilities are <code>"none"</code>, <code>"onlybound"</code> 
and <code>"one-and-one"</code>. The default is <code>"none"</code>, 
although if it is set to <code>"none"</code> and 
<code>positive.zero</code> is <code>TRUE</code> then 
<code>bound.test.parameters</code> is taken to be <code>"onlybound"</code>. 
When <code>bound.test.parameters</code> is set to 
<code>"one-and-one"</code>, it signifies that there are two 
parameters being tested, one of which is bound and the 
other is not. For example, the latter is true for testing 
a covariance and a positively-constrained variance component 
that, under the reduced model, are zero.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_df">DF</code></td>
<td>
<p>A <code>numeric</code> giving the difference between the two models in the 
number of variance parameters whose estimates are not of the type 
specified in <code>bound.exclusions</code>. If 
<code>NULL</code> then this is determined from the information in 
<code>full.asreml.obj</code> and <code>reduced.asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters. If set to <code>NULL</code> then none will
be excluded.</p>
</td></tr>
<tr><td><code id="REMLRT.asreml_+3A_...">...</code></td>
<td>
<p>Provision for passing arguments to functions called internally - 
not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the log of the likelihood ratio, its degrees of 
freedom, its p-value and the number of bound parameters in each of the two models 
being compared.</p>


<h3>Note</h3>

<p>If <code>DF</code> is not <code>NULL</code>, the supplied value is used. Otherwise <code>DF</code> 
is determined from the information in <code>h1.asreml.obj</code> and 
<code>h0.asreml.obj</code>. In this case, the degrees of freedom for the test 
are computed as the difference between the two models in the number of variance 
parameters whose estimates do not have a code for <code>bound</code> specified in 
<code>bound.exclusions</code>.
</p>
<p>If ASReml-R version 4 is being used then the codes specified in <code>bound.exclusions</code> are
not restricted to a subset of the default codes, but a warning is issued if a code other 
than these is specified. 
For ASReml-R version 3, only a subset of the default codes are allowed: 
<code>F</code> (<code>Fixed</code>), <code>B</code> (<code>Boundary</code>), <code>C</code> (<code>Constrained</code>) and 
<code>S</code> (<code>Singular</code>). 
</p>
<p>The test statistic is calculated as <code class="reqn">2(log(REML)_1 - log(REML)_0)</code>.
</p>
<p>This procedure is only appropriate when the null hypothesis is that 
(i) all parameters are on the boundary of the parameter space (ii) all 
parameters are in the interior of the parameter space, or (iii) there 
are two parameters, one of which is on the boundary and the other is not. 
Other cases have been discussed by Self and Liang (1987), but are not 
implemented here.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Self, S.G., and Liang, K-Y. (1987) Asymptotic Properties of 
Maximum Likelihood Estimators and Likelihood Ratio Tests Under 
Nonstandard Conditions. <em>Journal of the American 
Statistical Association</em>, <b>82</b>, 605-10.</p>


<h3>See Also</h3>

<p><code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>, <code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    REMLRT(ICV.max, ICV.red, bound.test.parameters = "onlybound")

## End(Not run)</code></pre>

<hr>
<h2 id='renewClassify.alldiffs'>Renews the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according to a new classify.</h2><span id='topic+renewClassify.alldiffs'></span><span id='topic+renewClassify'></span>

<h3>Description</h3>

<p>The <code>classify</code> is an attribute of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> and determines 
the order within the components of an unsorted <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
This function resets the <code>classify</code> attribute and re-orders the components of 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> to be in standard order for the variables in a 
<code>newclassify</code>, using <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>. The <code>newclassify</code> 
may be just a re-ordering of the variable names in the previous <code>classify</code>, or be 
based on a new set of variable names. The latter is particularly useful when 
<code><a href="#topic+linTransform.alldiffs">linTransform.alldiffs</a></code> has been used with a <code><a href="base.html#topic+matrix">matrix</a></code> and it 
is desired to replace the resulting <code>Combination</code> <code>classify</code> with a 
<code>newclassify</code> comprised of a more meaningful set of variables; first replace 
<code>Combination</code> in the <code>predictions</code> component with the new set of variables 
and then call <code>renewClassify</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
renewClassify(alldiffs.obj, newclassify, 
              sortFactor = NULL, sortParallelToCombo = NULL, 
              sortNestingFactor = NULL, sortOrder = NULL, decreasing = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewClassify.alldiffs_+3A_alldiffs.obj">alldiffs.obj</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_newclassify">newclassify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table that was predicted, 
but ordered so that the predictions are in the desired order when they are 
arranged in standard order for the <code>newclassify</code>. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator. The number of combined values of the 
set of variable name(s) must equal the number of rows in the <code>predictions</code> 
component.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> passed to <code>order</code> that detemines whether 
the order is for increasing or decreasing magnitude of the predicted 
values.</p>
</td></tr>
<tr><td><code id="renewClassify.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>; 
attributes <code>tranform.power</code>, <code>offset</code> and <code>scale</code> cannot be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> is arranged in standard order for
the <code>newclassify</code>. Then predictions are reordered according to the settings of 
<code>sortFactor</code>, <code>sortParallelToCombo</code>, <code>sortOrder</code> and <code>decreasing</code> (see 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code> for details).</p>


<h3>Value</h3>

<p>The <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> supplied with the following components, 
if present, sorted: <code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code> and <code>sed</code>. Also, the <code>sortFactor</code> and <code>sortOrder</code> 
attributes are set.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br /> 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>, <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  <br />
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
#Analyse pH  
m1.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(m1.asr, NULL, NULL)
current.asrt &lt;- as.asrtests(m1.asr)
current.asrt &lt;- rmboundary(current.asrt)
m1.asr &lt;- current.asrt$asreml.obj

#Get predictions and associated statistics  
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = m1.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  #Analyse pH
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
   
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, 
                               classify = "Sources:Type", 
                               vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

#Re-order predictions from asreml or lmerTest so all Sources for the same Type are together 
#for each combination of A and B
if (exists("TS.diffs"))
{
  TS.diffs.reord &lt;- renewClassify(TS.diffs, newclassify = "Type:Sources")
  validAlldiffs(TS.diffs.reord)
}
</code></pre>

<hr>
<h2 id='reparamSigDevn.asrtests'>Reparamterizes each random (deviations) term involving 
<code>devn.fac</code> to a fixed term and ensures that the same term, with 
<code>trend.num</code> replacing <code>devn.fac</code>, is included if any 
other term with <code>trend.num</code> is included in <code>terms</code>.</h2><span id='topic+reparamSigDevn.asrtests'></span><span id='topic+reparamSigDevn'></span>

<h3>Description</h3>

<p>This function reparamterizes each random (deviations) term involving
<code>devn.fac</code> to a fixed term and ensures that the same term with 
<code>trend.num</code> replacing <code>devn.fac</code> is included if any 
other term with <code>trend.num</code> is included in <code>terms</code>. It also 
ansures that any term with <code>spl{trend.num}</code> replacing 
<code>devn.fac</code> in a term being reparameterized is removed from the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
reparamSigDevn(asrtests.obj,terms = NULL, 
               trend.num = NULL, devn.fac = NULL, 
               allow.unconverged = TRUE, allow.fixedcorrelation = TRUE, 
               checkboundaryonly = FALSE, 
               denDF = "numeric", IClikelihood = "none", 
               trace = FALSE, update = TRUE, 
               set.terms = NULL, ignore.suffices = TRUE,
               bounds = "P", initial.values = NA,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reparamSigDevn.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_terms">terms</code></td>
<td>
<p>A character string vector giving the random terms that are to be reparameterized.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_trend.num">trend.num</code></td>
<td>
<p>A character string giving the name of the numeric covariate that 
corresponds to <code>devn.fac</code> and is potentially included in terms 
in the fitted model.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_devn.fac">devn.fac</code></td>
<td>
<p>A character string giving the name of the factor that corresponds to 
<code>trend.num</code> and is included in terms in the fitted model.
The name must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. Initially all changes are made with 
<code>allow.unconverged</code> set to <code>TRUE</code>. If 
<code>allow.unconverged</code> has been set to <code>FALSE</code> in the call and 
the final fit does not converge, an attempt is made to achieve 
convergence by removing any boundary terms. If this is unsuccessful, 
the supplied <code>asrtests.obj</code> is returned.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to autommatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated using
REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) the models are updated and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="reparamSigDevn.asrtests_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>asreml</code> via 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code> and <code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>,  <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(WaterRunoff.dat)
  asreml.options(keep.order = TRUE) #required for asreml-R4 only
  current.asr &lt;- asreml(fixed = log.Turbidity ~ Benches + Sources + Type + Species + 
                            Sources:Type + Sources:Species + Sources:Species:xDay + 
                            Sources:Species:Date, 
                        data = WaterRunoff.dat, keep.order = TRUE)
  current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

  #Examine terms that describe just the interactions of Date and the treatment factors
  terms.treat &lt;- c("Sources", "Type", "Species", "Sources:Type", "Sources:Species")
  date.terms &lt;- sapply(terms.treat, 
                       FUN=function(term){paste("Date:",term,sep="")}, 
                       simplify=TRUE)
  date.terms &lt;- c("Date", date.terms)
  date.terms &lt;- unname(date.terms)
  treat.marginality &lt;-  matrix(c(1,0,0,0,0,0, 1,1,0,0,0,0,  1,0,1,0,0,0, 
                                 1,0,1,1,0,0, 1,1,1,0,1,0, 1,1,1,1,1,1), nrow=6)
  rownames(treat.marginality) &lt;- date.terms
  colnames(treat.marginality) &lt;- date.terms
  choose &lt;- chooseModel(current.asrt, treat.marginality, denDF="algebraic")
  current.asrt &lt;- choose$asrtests.obj
  current.asr &lt;- current.asrt$asreml.obj
  sig.date.terms &lt;- choose$sig.terms

  #Remove all Date terms left in the fixed model
  terms &lt;- "(Date/(Sources * (Type + Species)))"
  current.asrt &lt;- changeTerms(current.asrt, dropFixed = terms)
  #if there are significant date terms, reparameterize to xDays + spl(xDays) + Date
  if (length(sig.date.terms) != 0)
  { #add lin + spl + devn for each to fixed and random models
    trend.date.terms &lt;- sapply(sig.date.terms, 
                               FUN=function(term){sub("Date","xDay",term)}, 
                               simplify=TRUE)
    trend.date.terms &lt;- paste(trend.date.terms,  collapse=" + ")
    current.asrt &lt;- changeTerms(current.asrt, addFixed=trend.date.terms)
    trend.date.terms &lt;- sapply(sig.date.terms, 
                               FUN=function(term){sub("Date","spl(xDay)",term)}, 
                               simplify=TRUE)
    trend.date.terms &lt;- c(trend.date.terms, sig.date.terms)
    trend.date.terms &lt;- paste(trend.date.terms,  collapse=" + ")
    current.asrt &lt;- changeTerms(current.asrt, addRandom = trend.date.terms)
    current.asrt &lt;- rmboundary(current.asrt)
  }
  
  #Now test terms for sig date terms
  spl.terms &lt;- sapply(terms.treat, 
                      FUN=function(term){paste("spl(xDay):",term,sep="")}, 
                      simplify=TRUE)
  spl.terms &lt;- c("spl(xDay)",spl.terms)
  lin.terms &lt;- sapply(terms.treat, 
                      FUN=function(term){paste(term,":xDay",sep="")}, 
                      simplify=TRUE)
  lin.terms &lt;- c("xDay",lin.terms)
  systematic.terms &lt;- c(terms.treat, lin.terms, spl.terms, date.terms)
  systematic.terms &lt;- unname(systematic.terms)
  treat.marginality &lt;-  matrix(c(1,0,0,0,0,0, 1,1,0,0,0,0,  1,0,1,0,0,0, 
                                 1,0,1,1,0,0, 1,1,1,1,1,0, 1,1,1,1,1,1), nrow=6)
  systematic.marginality &lt;- kronecker(matrix(c(1,0,0,0, 1,1,0,0, 
                                               1,1,1,0, 1,1,1,1), nrow=4), 
                                      treat.marginality)
  systematic.marginality &lt;- systematic.marginality[-1, -1]
  rownames(systematic.marginality) &lt;- systematic.terms
  colnames(systematic.marginality) &lt;- systematic.terms
  choose &lt;- chooseModel(current.asrt, systematic.marginality, 
                         denDF="algebraic", pos=TRUE)
  current.asrt &lt;- choose$asrtests.obj

  #Check if any deviations are significant and, for those that are, go back to 
  #fixed dates
  current.asrt &lt;- reparamSigDevn(current.asrt, choose$sig.terms, 
                                 trend.num = "xDay", devn.fac = "Date", 
                                 denDF = "algebraic")

## End(Not run)</code></pre>

<hr>
<h2 id='rmboundary.asrtests'>Removes any boundary or singular variance components from the fit stored in 
<code>asrtests.obj</code> and records their removal in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</h2><span id='topic+rmboundary.asrtests'></span><span id='topic+rmboundary'></span>

<h3>Description</h3>

<p>Any terms specified in the random model that are 
estimated on the boundary or are singular and can be removed are removed from the fit 
stored in the <code>asreml</code> object stored in the <code><a href="#topic+asrtests.object">asrtests.object</a></code>. 
Terms that specify multiple parameters in the random model cannot be removed 
(e.g. terms specified using the <code>at</code> function with more than one level of the 
factor) and terms in <code>residual</code> model are not removed. Terms that can be removed 
are selected for removal in the following order based on whether they involve:  
(i) a <code>dev</code> function, (ii) only factors, (iii) an <code>spl</code> function, 
(iv) a <code>pol</code> function and (v) a <code>lin</code> function or a variable that
is an <code>integer</code> or a <code>numeric</code>. It should be noted that this order of removal 
presumes that random deviation terms are specified via the <code>dev</code> function 
rather than via a random factor. Once the earliest of the above classes 
with a boundary term is identified, a term within this class is selected for 
removal. For all classes, except for factor-only terms, the smallest term 
with the largest number of  variables/factors is removed. 
Amongst factor-only terms, the smallest term with the smallest number of 
variables/factors is removed. After each 
variance component is removed, a row for it is added to the 
<code>test.summary</code> <code>data.frame</code> and the model refitted. If there are further 
boundary or singular terms, one is removed using the above strategy. 
This process continues until there are no further boundary or singular 
variance components that are removable. Other types of boundary or singular terms, 
which cannot be removed, are reported in warning messages.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
rmboundary(asrtests.obj, checkboundaryonly = FALSE, 
           IClikelihood = "none", trace = FALSE, update = TRUE,
           set.terms = NULL, ignore.suffices = TRUE, 
           bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmboundary.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated using
REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code> then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model with any boundary 
terms removed and using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the model without the boundary 
terms.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting.
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="rmboundary.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments, including <code>asreml</code> arguments, passed to <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, 
<code><a href="#topic+testranfix.asrtests">testranfix.asrtests</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>,  <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, 
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
current.asrt &lt;- rmboundary(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='setvarianceterms.call'>allows the setting of bounds and initial values for terms in the 
<code>random</code> and <code>residual</code> arguments of an <code>asreml</code> call, with 
the resulting call being evaluated. </h2><span id='topic+setvarianceterms.call'></span><span id='topic+setvarianceterms'></span>

<h3>Description</h3>

<p>Takes an unevaluated <code>call</code> and evaluates the <code>call</code> 
after setting the bounds and initial values for the terms 
specified in <code>terms</code>. The elements of <code>terms</code> are matched 
with those generated by asreml and used, for example, in the 
<code>varcomp</code> component of a <code>summary.asreml</code> object. 
These names generally include descriptive suffices. To match an 
element of <code>terms</code> that includes such a suffix, set 
<code>ignore.suffices</code> to <code>FALSE</code> so that a literal match 
between the element and the assigned names is sought.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'call'
setvarianceterms(call, terms, ignore.suffices = TRUE, 
                 bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setvarianceterms.call_+3A_call">call</code></td>
<td>
<p>an unevaluated <code>call</code> to <code>asreml</code>. One way to create 
such a <code>call</code> is to use the <code>call</code> function with 
its <code>name</code> argument set to <code>"asreml"</code>. Another is to 
obtain it from the <code>call</code> component of an <code>asreml</code> 
object  (e.g. <code>call &lt;- asreml.obj$call</code>).</p>
</td></tr>
<tr><td><code id="setvarianceterms.call_+3A_terms">terms</code></td>
<td>
<p>A character vector specifying the terms 
that are to have bounds and/or initial values specified.
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="setvarianceterms.call_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to be ignored in 
matching elements of <code>terms</code>. If <code>TRUE</code> for 
an element of <code>terms</code>, the suffices are stripped 
from the <code>asreml</code>-assigned names. If <code>FALSE</code> for 
an element of <code>terms</code>, the element must exactly match 
an <code>asreml</code>-assigned name for a variance term. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same action is 
applied to the <code>asreml</code>-assigned suffices for all the terms 
in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="setvarianceterms.call_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.
</p>
<p>The codes used by ASReml are: 
</p>

<ul>
<li><p> B - fixed at a boundary;
</p>
</li>
<li><p> F - fixed by the user;
</p>
</li>
<li><p> P - positive definite;
</p>
</li>
<li><p> C - Constrained by user; 
</p>
</li>
<li><p> U - unbounded.
</p>
</li></ul>
</td></tr>
<tr><td><code id="setvarianceterms.call_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="setvarianceterms.call_+3A_...">...</code></td>
<td>
<p>additional arguments to be added to the call, or arguments in 
the call with changed values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>asreml</code> object.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code>update.asreml</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   m1.call &lt;- call("asreml", 
                   fixed = Height ~ (Block + Irrig)*csDay.num,
                   random= ~ spl(csDay.num)/(Irrig+Block)
                             + dev(csDay.num)
                             + str(~Block:Plot/csDay.num, ~us(2):id(20)) 
                             + Block:Plot:spl(csDay.num),
                   data=quote(dat)) ##use quote to stop evaluation of dat here 
   terms &lt;- c("Block:Plot+Block:Plot:csDay.num!us(2).2:1", "R!variance")
   m1.asreml &lt;- setvarianceterms(m1.call, terms, bounds=c("U","P"), 
                                 initial=c(NA,3), ignore.suffices=c(FALSE,TRUE))
   summary(m1.asreml)

## End(Not run)</code></pre>

<hr>
<h2 id='simulate.asreml'>Produce sets of simulated data from a multivariate normal distribution and save 
quantities related to the simulated data</h2><span id='topic+simulate.asreml'></span>

<h3>Description</h3>

<p>Produce in parallel sets of simulated data corresponding to an <code>asreml</code> model,
along with its fitted values and residuals. A variance matrix <code>V</code>,
corresponding to the <code>random</code> and <code>residual</code> models must be 
supplied. What to save is specified by the <code>which</code> argument.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
simulate(object, nsim=100, seed = NULL, means=NULL, V, tolerance = 1E-10, 
         update = TRUE, trace = FALSE, which="data", units = "ignore", 
         ncores = 2, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.asreml_+3A_object">object</code></td>
<td>
<p>An <code>asreml</code> object from a call to <code>asreml</code> in which the 
<code>data</code> argument has been set.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_means">means</code></td>
<td>
<p>The <code>vector</code> of means to be used in generating simulated data sets. If
it is <code>NULL</code>, the fitted values based on <code>object</code> are used. 
It must be the same length as the response variable for <code>object</code>.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_v">V</code></td>
<td>
<p>The fitted variance <code>matrix</code>, i.e. having the pattern and values that 
conform to the model fit stored in the supplied <code>object</code>.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_nsim">nsim</code></td>
<td>
<p>The number of data sets to be simulated.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer, that specifies the 
starting value of the random number generator. The &quot;L'Ecuyer-CMRG&quot; random 
generator is used and <code>nextRNGStream</code> is used to seed each core from the
original <code>seed</code>.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_tolerance">tolerance</code></td>
<td>
<p>The value such that eigenvalues less than it are considered to be zero.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_update">update</code></td>
<td>
<p>If <code>TRUE </code>then the arguments <code>R.param</code> 
and <code>G.param</code> are set to those in the <code>asreml</code> object supplied 
in <code>object</code> so that the values from the original model are used as 
starting values. If <code>FALSE</code> then <code>asreml</code> <code>calls</code> are 
evaluated, the only changes from the previous call being that 
(i) the model is fitted to simulated data and (ii) modifications 
specified via <code>...</code> are mode, except that changes cannot be made to 
any of the models.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code> then partial iteration details are displayed when ASReml-R 
functions are invoked; if <code>FALSE</code> then no output is displayed.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_which">which</code></td>
<td>
<p>The quantities from the simulated data set to be stored. Any combination of
<code>"response"</code>, <code>"residuals"</code> and <code>"fitted"</code>, or <code>"all"</code>. 
If <code>residuals</code> and/or <code>fitted</code> is specified, those for the 
analysis stored in <code>object</code> will be added to the <code>data.frame</code> 
nominated in the <code>data</code> argument of <code>object</code> and the modified 
<code>data.frame</code> added as a component named <code>data</code> in the <code>list</code> 
that is the <code>value</code> returned by the <code>function</code>.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_units">units</code></td>
<td>
<p>A <code>character</code> indicating whether the BLUPs for <code>units</code> are 
added to the residuals when this reserved factor is included in the 
<code>random</code> model. Possible values are <code>addtoresiduals</code> and 
<code>ignore</code>.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_ncores">ncores</code></td>
<td>
<p>A <code>numeric</code> specifying the number of cores to use in doing the 
simulations. In choosing a value for <code>ncores</code>, it is necessary to 
take into account other processes that are using parallel processing at 
the same time.</p>
</td></tr>
<tr><td><code id="simulate.asreml_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the function asreml. Changes to the 
models are not allowed. Other changes are dangerous and generally should be 
avoided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate <code>nsim</code> sets of data and analyse them using <code>asreml</code> 
using the model in <code>object</code>, performing the generation and analysis of several 
sets in parallel. Note, if the analysis for a data set does 
not converge in <code>maxiter</code> iterations, it is discarded and 
a replacement data set generated. The value of <code>maxiter</code> can be specified 
in the call to <code>simulate.asreml</code>. The fitted values and residuals are extracted 
as required. If <code>aom = TRUE</code> when the simulated data are analysed, standardised 
conditional residuals are stored. If <code>which</code> includes <code>residuals</code> or
<code>fitted</code>, the specified quantities for the observed data are added to the
<code>data.frame</code> on which the fit in <code>object</code> is based.</p>


<h3>Value</h3>

<p>A <code>list</code> with the following components whose presence depends on the setting of 
<code>which</code>:
</p>

<ol>
<li><p><b>observed:</b> present if <code>which</code> includes <code>residuals</code> or <code>fitted</code>, 
in which case it will be the <code>data.frame</code> on which the fit in 
<code>object</code> is based, with <code>residuals</code> and/or <code>fitted</code>. 
</p>
</li>
<li><p><b>data:</b> present if <code>which</code> includes <code>data</code>, a <code>data.frame</code> 
containing the simulated data sets.
</p>
</li>
<li><p><b>fitted:</b> present if <code>which</code> includes <code>fitted</code>, a <code>data.frame</code> 
containing the fitted values from the analyses of the simulated data sets.
</p>
</li>
<li><p><b>residuals:</b> present if <code>which</code> includes <code>residuals</code>, a <code>data.frame</code> 
containing the residuals from the analyses of the simulated data sets.</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>asreml</code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+variofaces.asreml">variofaces.asreml</a></code>, <code><a href="#topic+plotVariofaces.data.frame">plotVariofaces.data.frame</a></code>, 
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Form variance matrix based on estimated variance parameters
s2 &lt;- current.asr$sigma2
gamma.Row &lt;- current.asr$gammas[1]
gamma.unit &lt;- current.asr$gammas[2]
rho.r &lt;- current.asr$gammas[4]
rho.c &lt;- current.asr$gammas[5]
row.ar1 &lt;- mat.ar1(order=10, rho=rho.r)
col.ar1 &lt;- mat.ar1(order=15, rho=rho.c)
V &lt;- gamma.Row * fac.sumop(Wheat.dat$Row) + 
     gamma.unit * diag(1, nrow=150, ncol=150) + 
     mat.dirprod(col.ar1, row.ar1)
V &lt;- s2*V

#Produce residuals from 100 simulated data sets
resid &lt;- simulate(current.asr, V=V, which="residuals", ncores = parallel::detectCores())

## End(Not run)</code></pre>

<hr>
<h2 id='sort.alldiffs'>Sorts the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according to the predicted values 
associated with a factor.</h2><span id='topic+sort.alldiffs'></span>

<h3>Description</h3>

<p>Sorts the rows of the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> 
(see <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>) that are <code>data.frames</code> and the rows and columns 
of those that are <code>matrices</code> according to the predicted values in the 
<code>predictions</code> component. These predicted values are generally obtained using 
<code>predict.asreml</code> by specifying a <code>classify</code> term comprised of one or 
more variables. Generally, the values associated with one variable are sorted in 
parallel within each combination of values of the other variables. When there is more 
than one variable in the <code>classify</code> term, the sorting is controlled using 
one or more of <code>sortFactor</code>, <code>sortParallelToCombo</code> and <code>sortOrder</code>. 
If there is only one variable in the <code>classify</code> then all components are sorted 
according to the order of the complete set of predictions.
</p>
<p>Note that <code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code> is called after sorting to ensure that 
the order of the rows and columns of the components is in standard order for the new 
variable order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
sort(x, decreasing = FALSE, classify = NULL, sortFactor = NULL, 
     sortParallelToCombo = NULL, sortNestingFactor = NULL, 
     sortOrder = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.alldiffs_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> passed to <code>order</code> that detemines whether 
the order is for increasing or decreasing magnitude of the predicted 
values.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_classify">classify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table that was predicted. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator. If <code>NULL</code>, 
it will be obtained from the <code>classify</code> attribute of the 
<code><a href="#topic+as.alldiffs">as.alldiffs</a></code> object supplied through <code>x</code>.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions</code> component of the 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. It specifies the desired order of the 
levels in the reordered components of the <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="sort.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic technique is to change the order of the levels of the <code>sortFactor</code> 
within the <code>predictions</code> and, if present, <code>backtransforms</code> components so 
that they are ordered for a subset of predicted values, one for each levels of the 
<code>sortFactor</code>. When the <code>classify</code> term consists of more than one 
variable then a subset of one combination of the values of variables other than
the <code>sortFactor</code>, the <code>sortParallelToCombo</code> combination, must be chosen for determining the 
order of the <code>sortFactor</code> levels. Then the sorting of the rows (and columns) 
will be in parallel within each combination of the values of <code>sortParallelToCombo</code> variables: 
the <code>classify</code> term, excluding the <code>sortFactor</code>.</p>


<h3>Value</h3>

<p>The <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> supplied with the following components, 
if present, sorted: <code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code> and <code>sed</code>. Also, the <code>sortFactor</code> and <code>sortOrder</code> 
attributes are set.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <br /> 
<code><a href="#topic+sort.predictions.frame">sort.predictions.frame</a></code>, <code><a href="#topic+renewClassify.alldiffs">renewClassify.alldiffs</a></code>, 
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>, <br />
<code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>,  
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Halve WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
#Analyse pH  
m1.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m1.asr, NULL, NULL)
current.asrt &lt;- as.asrtests(m1.asr)
current.asrt &lt;- rmboundary(current.asrt)
m1.asr &lt;- current.asrt$asreml.obj

#Get predictions and associated statistics  
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = m1.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))
  
#Use sort.alldiffs and save order for use with other response variables
TS.diffs.sort &lt;- sort(TS.diffs, sortFactor = "Sources", 
                      sortParallelToCombo = list(Type = "Control"))
sort.order &lt;- attr(TS.diffs.sort, which = "sortOrder")
  
#Analyse Turbidity
m2.asr &lt;- asreml(fixed = Turbidity ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m2.asr)
#Use pH sort.order to sort Turbidity alldiffs object
diffs2.sort &lt;- predictPlus(m2.asr, classify = "Sources:Type", 
                           pairwise = FALSE, error.intervals = "Stand", 
                           tables = "none", present = c("Type","Species","Sources"),
                           sortFactor = "Sources", 
                           sortOrder = sort.order)

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  #Analyse pH
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, 
                             classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
    
  #Use sort.alldiffs and save order for use with other response variables
  TS.diffs.sort &lt;- sort(TS.diffs, sortFactor = "Sources", 
                        sortParallelToCombo = list(Type = "Control"))
  sort.order &lt;- attr(TS.diffs.sort, which = "sortOrder")
  
  #Analyse Turbidity
  m2.lmer &lt;- lmerTest::lmer(Turbidity ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m2.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
    
  ## Form an all.diffs object, sorting it using the pH sort.order and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs2.sort &lt;- allDifferences(predictions = TS.preds, 
                                   classify = "Sources:Type", 
                                   vcov = TS.vcov, tdf = den.df,
                                   sortFactor = "Sources", 
                                   sortOrder = sort.order)
  validAlldiffs(TS.diffs2.sort)
}  
</code></pre>

<hr>
<h2 id='sort.predictions.frame'>Sorts a <code><a href="#topic+predictions.frame">predictions.frame</a></code> according to the predicted values 
associated with a factor.</h2><span id='topic+sort.predictions.frame'></span>

<h3>Description</h3>

<p>Sorts the rows of a <code><a href="#topic+predictions.frame">predictions.frame</a></code> according to the predicted values 
in the <code>predictions.frame</code>. These predicted values are generally obtained using 
<code>predict.asreml</code> by specifying a <code>classify</code> term comprised of one or 
more variables. Generally, the values associated with one variable are sorted in 
parallel within each combination of values of the other variables. When there is more 
than one variable in the <code>classify</code> term, the sorting is controlled using 
one or more of <code>sortFactor</code>, <code>sortParallelToCombo</code> and <code>sortOrder</code>. 
If there is only one variable in the <code>classify</code> then the <code><a href="#topic+predictions.frame">predictions.frame</a></code> 
is sorted according to the order of the complete set of predictions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictions.frame'
sort(x, decreasing = FALSE, classify, sortFactor = NULL, 
     sortParallelToCombo = NULL, sortNestingFactor = NULL, 
     sortOrder = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.predictions.frame_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+predictions.frame">predictions.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_decreasing">decreasing</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> passed to <code>order</code> that detemines whether 
the order is for increasing or decreasing magnitude of the predicted 
values.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_classify">classify</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string giving the variables that 
define the margins of the multiway table that was predicted. 
Multiway tables are specified by forming an interaction type 
term from the classifying variables, that is, separating the 
variable names with the <code>:</code> operator.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_sortfactor">sortFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that indexes the set of predicted values that determines 
the sorting of the components. If there is only one variable in the 
<code>classify</code> term then <code>sortFactor</code> can be <code>NULL</code> and 
the order is defined by the complete set of predicted values. 
If there is more than one variable in the <code>classify</code> term 
then <code>sortFactor</code> must be set. In this case the <code>sortFactor</code> 
is sorted in the same order within each combination of the values of 
the <code>sortParallelToCombo</code> variables: the <code>classify</code> variables, excluding the 
<code>sortFactor</code>. There should be only one predicted value for 
each unique value of <code>sortFactor</code> within each set defined by a 
combination of the values of the <code>classify</code> variables, excluding the 
<code>sortFactor</code> <code>factor</code>. 
The order to use is determined by either <code>sortParallelToCombo</code> or 
<code>sortOrder</code>.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_sortparalleltocombo">sortParallelToCombo</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that specifies a combination of the values 
of the <code>factor</code>s and <code>numeric</code>s, excluding <code>sortFactor</code>, that 
are in <code>classify</code>. Each of the components of the supplied <code><a href="base.html#topic+list">list</a></code> 
is named for a <code>classify</code> variable and specifies a single value for it. The 
combination of this set of values will be used to define a subset of the predicted 
values whose order will define the order of <code>sortFactor</code>. Each of the other 
combinations of the values of the <code>factor</code>s and <code>numeric</code>s will be sorted 
in parallel. If <code>sortParallelToCombo</code> is <code>NULL</code> then the first value of               
each <code>classify</code> variable, except for the <code>sortFactor</code> <code>factor</code>,  
in the <code>predictions</code> component is used to define <code>sortParallelToCombo</code>. 
If there is only one variable in the <code>classify</code> then 
<code>sortParallelToCombo</code> is ignored.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_sortnestingfactor">sortNestingFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> containing the name of the 
<code>factor</code> that defines groups of the <code>sortFactor</code> within which the predicted 
values are to be ordered. 
If there is only one variable in the <code>classify</code> then 
<code>sortNestingFactor</code> is ignored.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_sortorder">sortOrder</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector whose length is the same as the number 
of levels for <code>sortFactor</code> in the <code>predictions.frame</code>. 
It specifies the desired order of the levels in the reordered 
the <code><a href="#topic+predictions.frame">predictions.frame</a></code>. 
The argument <code>sortParallelToCombo</code> is ignored.
</p>
<p>The following creates a <code>sortOrder</code> vector <code>levs</code> for factor 
<code>f</code> based on the values in <code>x</code>: 
<code>levs &lt;- levels(f)[order(x)]</code>.</p>
</td></tr>
<tr><td><code id="sort.predictions.frame_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic technique is to change the order of the levels of the <code>sortFactor</code> 
within the <code>predictions.frame</code> so 
that they are ordered for a subset of predicted values, one for each levels of the 
<code>sortFactor</code>. When the <code>classify</code> term consists of more than one 
variable then a subset of one combination of the values of variables other than
the <code>sortFactor</code>, the <code>sortParallelToCombo</code> combination, must be chosen for determining the 
order of the <code>sortFactor</code> levels. Then the sorting of the rows (and columns) 
will be in parallel within each combination of the values of <code>sortParallelToCombo</code> variables: 
the <code>classify</code> term, excluding the <code>sortFactor</code>.</p>


<h3>Value</h3>

<p>The sorted <code><a href="#topic+predictions.frame">predictions.frame</a></code>. Also, the <code>sortFactor</code> and 
<code>sortOrder</code> attributes are set.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code>, <code><a href="#topic+print.predictions.frame">print.predictions.frame</a></code>, 
<code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br /> 
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Halve WaterRunoff data to reduce time to execute
data(WaterRunoff.dat)
tmp &lt;- subset(WaterRunoff.dat, Date == "05-18")

##Use asreml to get predictions and associated statistics

## Not run: 
#Analyse pH  
m1.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m1.asr, NULL, NULL)
current.asrt &lt;- as.asrtests(m1.asr)
current.asrt &lt;- rmboundary(current.asrt)
m1.asr &lt;- current.asrt$asreml.obj

#Get predictions and associated statistics  
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                               asreml.obj = m1.asr, tables = "none", 
                               wald.tab = current.asrt$wald.tab, 
                               present = c("Type","Species","Sources"))
  
#Use sort.predictions.frame and save order for use with other response variables
TS.preds &lt;- TS.diffs$predictions
TS.preds.sort &lt;- sort(TS.preds, sortFactor = "Sources", 
                      sortParallelToCombo = list(Type = "Control"))
sort.order &lt;- attr(TS.preds.sort, which = "sortOrder")
  
#Analyse Turbidity
m2.asr &lt;- asreml(fixed = Turbidity ~ Benches + (Sources * (Type + Species)), 
                 random = ~ Benches:MainPlots,
                 keep.order=TRUE, data= tmp)
current.asrt &lt;- as.asrtests(m2.asr)
#Use pH sort.order to sort Turbidity alldiffs object
TS.diffs2 &lt;- predictPlus(m2.asr, classify = "Sources:Type", 
                         pairwise = FALSE, error.intervals = "Stand", 
                         tables = "none", present = c("Type","Species","Sources"))
TS.preds2 &lt;- TS.diffs2$predictions
TS.preds2.sort &lt;- sort(TS.preds, sortFactor = "Sources", sortOder = sort.order)

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  #Analyse pH
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  #Use sort.predictions.frame and save order for use with other response variables
  TS.preds.sort &lt;- sort(TS.preds, classify = "Sources:Type", sortFactor = "Sources", 
                        sortParallelToCombo = list(Type = "Control"))
  sort.order &lt;- attr(TS.preds.sort, which = "sortOrder")
  
  #Analyse Turbidity
  m2.lmer &lt;- lmerTest::lmer(Turbidity ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(tmp))
  TS.emm &lt;- emmeans::emmeans(m2.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
}  
</code></pre>

<hr>
<h2 id='subset.alldiffs'>Subsets the components in an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> according to the supplied condition.</h2><span id='topic+subset.alldiffs'></span>

<h3>Description</h3>

<p>Subsets each of the components of an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>. The subset is 
determined by applying the condition to the <code>prediction</code> component to 
determine which of its rows are to be included in the subset. Then, if present, 
this subset is applied to the rows of <code>backtransforms</code> and to the rows 
and columns of <code>differences</code>, <code>p.differences</code> and <code>sed</code> 
components. In addition, if <code>sed</code> is present, <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code> 
is called to recalculate the values in the <code><a href="#topic+LSD.frame">LSD.frame</a></code> stored in the 
<code>LSD</code> component, with any arguments supplied via the <code>...</code> 
argument passed ot it.
</p>
<p>The <code>select</code> argument of <code>subset</code> is not implemented, but can be 
achieved for variables in the <code>classify</code> using the <code>rmClassifyVars</code> 
argument.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'alldiffs'
subset(x, subset = rep(TRUE, nrow(x$predictions)), 
       rmClassifyVars = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.alldiffs_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
<tr><td><code id="subset.alldiffs_+3A_subset">subset</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that detemines rows of the <code>predictions</code>  
component of <code>x</code> to be included in the subset. By default allws are 
included.</p>
</td></tr>
<tr><td><code id="subset.alldiffs_+3A_rmclassifyvars">rmClassifyVars</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> that contains the names of the 
variables in the <code>classify</code> attribute of <code>x</code> that are to be 
removed from the predictions <code>data.frame</code> and the names of the 
dimensions of the other components of <code>x</code>. In doing this, 
the combinations of the remaining <code>classify</code> variables must 
uniquely index the predictions.</p>
</td></tr>
<tr><td><code id="subset.alldiffs_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> with the following components of the supplied 
<code><a href="#topic+alldiffs.object">alldiffs.object</a></code> subsetted, if present in the original object: 
<code>predictions</code>, <code>vcov</code>, <code>backtransforms</code>, <code>differences</code>, 
<code>p.differences</code> and <code>sed</code>. In addition, if <code>sed</code> is present, the 
<code><a href="#topic+LSD.frame">LSD.frame</a></code> in the <code>LSD</code> component will be recalculated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <code><a href="#topic+allDifferences.data.frame">allDifferences.data.frame</a></code>, 
<code><a href="#topic+print.alldiffs">print.alldiffs</a></code>, <code><a href="#topic+sort.alldiffs">sort.alldiffs</a></code>, <br />
<code><a href="#topic+redoErrorIntervals.alldiffs">redoErrorIntervals.alldiffs</a></code>, <code><a href="#topic+recalcLSD.alldiffs">recalcLSD.alldiffs</a></code>, <br />
<code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, <code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)

##Use asreml to get predictions and associated statistics

## Not run: 
asreml.options(keep.order = TRUE) #required for asreml-R4 only
current.asr &lt;- asreml(fixed = pH ~ Benches + (Sources * (Type + Species)), 
                      random = ~ Benches:MainPlots,
                      keep.order=TRUE, data= WaterRunoff.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
TS.diffs &lt;- predictPlus.asreml(classify = "Sources:Type", 
                              asreml.obj = current.asr, tables = "none", 
                              wald.tab = current.asrt$wald.tab, 
                              present = c("Type","Species","Sources"))

## End(Not run)

## Use lmeTest and emmmeans to get predictions and associated statistics

if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
    requireNamespace("emmeans", quietly = TRUE))
{
  m1.lmer &lt;- lmerTest::lmer(pH ~ Benches + (Sources * (Type + Species)) + 
                              (1|Benches:MainPlots),
                            data=na.omit(WaterRunoff.dat))
  TS.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Sources:Type)
  TS.preds &lt;- summary(TS.emm)
  den.df &lt;- min(TS.preds$df, na.rm = TRUE)
  ## Modify TS.preds to be compatible with a predictions.frame
  TS.preds &lt;- as.predictions.frame(TS.preds, predictions = "emmean", 
                                   se = "SE", interval.type = "CI", 
                                   interval.names = c("lower.CL", "upper.CL"))
  
  ## Form an all.diffs object and check its validity
  TS.vcov &lt;- vcov(TS.emm)
  TS.diffs &lt;- allDifferences(predictions = TS.preds, classify = "Sources:Type", 
                             vcov = TS.vcov, tdf = den.df)
  validAlldiffs(TS.diffs)
}  

## Plot p-values for predictions obtained using asreml or lmerTest
if (exists("TS.diffs"))
{
  ##Use subset.alldiffs to select a subset of the alldiffs object
  TS.diffs.subs &lt;- subset(TS.diffs, 
                          subset = grepl("R", Sources, fixed = TRUE) &amp; 
                                   Type %in% c("Control","Medicinal"))
}
</code></pre>

<hr>
<h2 id='subset.list'>Forms a <code><a href="base.html#topic+list">list</a></code> that contains a subset of the components of the supplied 
<code><a href="base.html#topic+list">list</a></code>.</h2><span id='topic+subset.list'></span>

<h3>Description</h3>

<p>Select components of a <code><a href="base.html#topic+list">list</a></code> specified by a list of numbers or names,
or by a logical indicating for each component of the list whether or not it is to 
be retained.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
subset(x, select = 1:length(x), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.list_+3A_x">x</code></td>
<td>
<p>An <code><a href="base.html#topic+list">list</a></code> object.</p>
</td></tr>
<tr><td><code id="subset.list_+3A_select">select</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code> that lists or names the 
components of the <code><a href="base.html#topic+list">list</a></code> <code>x</code> that are to be retained in the 
subset. It can also be a <code><a href="base.html#topic+logical">logical</a></code> that is the same length as 
<code>x</code> and indicates whether or not a component is to be retained.</p>
</td></tr>
<tr><td><code id="subset.list_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with just the subset of the components from <code>x</code>. If the 
components of <code>x</code> are named, then these names are retained in the subset 
<code><a href="base.html#topic+list">list</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.alldiffs">subset.alldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1:3,letters[1:3],LETTERS[1:3])
y &lt;- subset.list(x, select = c(1,3))
y &lt;- subset.list(x, select = c(TRUE,FALSE,TRUE))

names(x) &lt;- LETTERS[1:3]
y &lt;- subset.list(x, select = c(1,3))
z &lt;- subset.list(x, select = LETTERS[c(1,3)])
x &lt;- list(1:3,letters[1:3],LETTERS[1:3])
names(x)[c(1,3)] &lt;- LETTERS[c(1,3)]
z &lt;- subset.list(x, select = c(1,2))
v &lt;- subset.list(x)
</code></pre>

<hr>
<h2 id='testranfix.asrtests'>Tests for a single fixed or random term in model fitted using <code>asreml</code>
and records the result in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</h2><span id='topic+testranfix.asrtests'></span><span id='topic+testranfix'></span>

<h3>Description</h3>

<p>Tests for a single term, using a REML ratio test (REMLRT) for a random term or based 
on Wald statistics for a fixed term. The term must be in the fitted model. 
A random term is removed from the model fit and a REMLRT is 
performed using <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>. It compares the fit of the model in 
<code>asreml.obj</code> and the newly fitted model without the <code>term</code>. 
If the newly fitted model is retained, any boundary terms are then removed
using <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>. 
For a fixed term, the probability of the Wald 
statistics is extracted from the pseudo-anova table produced by 
<code>wald.asreml</code>. If this is available in the <code><a href="#topic+asrtests.object">asrtests.object</a></code>, it is 
used; otherwise <code>wald.asreml</code> is called to add it to the 
<code><a href="#topic+asrtests.object">asrtests.object</a></code>. Whether nonsignificant terms are dropped is controlled 
by <code>drop.ran.ns</code> for random terms and <code>drop.fix.ns</code> for fixed terms. A row is 
added to the <code>test.summary</code> <code>data.frame</code> for the term that is tested.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
testranfix(asrtests.obj, term=NULL, alpha = 0.05, 
           allow.unconverged = TRUE, allow.fixedcorrelation = TRUE, 
           checkboundaryonly = FALSE, 
           drop.ran.ns = TRUE, positive.zero = FALSE, 
           bound.test.parameters = "none", 
           bound.exclusions = c("F","B","S","C"), REMLDF = NULL, 
           drop.fix.ns = FALSE, denDF="numeric", dDF.na = "none", 
           dDF.values = NULL, IClikelihood = "none", 
           trace = FALSE, update = TRUE,
           set.terms = NULL, ignore.suffices = TRUE, 
           bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testranfix.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>, 
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_term">term</code></td>
<td>
<p>A single model term that is valid in <code>asreml</code>, stored 
as a <code>character</code>. The names of fixed terms must match those in the <code>wald.tab</code> 
component of the <code>asrtests.obj</code>, while the names of random terms must 
match those in the <code>vparameters</code> component of the <code>asreml.obj</code> component 
in the <code>asrtests.obj</code>. </p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the test.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code>, it will be 
checked whether convergence can be achieved with the removal of 
any boundary random terms; random terms will be retested if terms 
are removed. Also, if <code>FALSE</code> and the fit of the new model has 
converged, but that of the old model has not, the new model will be 
accepted.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_drop.ran.ns">drop.ran.ns</code></td>
<td>
<p>A <code>logical</code> indicating whether to drop a random 
term from the model when it is nonsignificant. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
will only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified in <code>term</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_positive.zero">positive.zero</code></td>
<td>
<p>Indicates whether the hypothesized values for the 
variance components being tested are on the boundary 
of the parameter space. For example, this is true 
for positively-constrained variance components that, 
under the reduced model, are zero. This argument does 
not need to be set if <code>bound.test.parameters</code> is set.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_bound.test.parameters">bound.test.parameters</code></td>
<td>
<p>Indicates whether for the variance components 
being tested, at least some of the hypothesized values
are on the boundary of the parameter space. 
The possibilities are <code>"none"</code>, <code>"onlybound"</code> 
and <code>"one-and-one"</code>. The default is <code>"none"</code>, 
although if it is set to <code>"none"</code> and 
<code>positive.zero</code> is <code>TRUE</code> then 
<code>bound.test.parameters</code> is taken to be <code>"onlybound"</code>. 
When <code>bound.test.parameters</code> is set to 
<code>"one-and-one"</code>, it signifies that there are two 
parameters being tested, one of which is bound and the 
other is not. For example, the latter is true for testing 
a covariance and a positively-constrained variance component 
that, under the reduced model, are zero.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in using <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>. 
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_remldf">REMLDF</code></td>
<td>
<p>A <code>numeric</code> giving the difference in the number of variance parameters 
whose estimates are not of the type specified in <code>bound.exclusions</code> 
for two models being compared in a REML ratio test using 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>. If <code>NULL</code> then this is determined from 
the information in the <code>asreml</code> object for the two models.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_drop.fix.ns">drop.fix.ns</code></td>
<td>
<p>A <code>logical</code> indicating whether to drop a fixed  
term from the model when it is nonsignificant. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to autommatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_ddf.na">dDF.na</code></td>
<td>
<p>The method to use to obtain substitute denominator degrees of freedom. 
when the numeric or algebraic methods produce an <code>NA</code>. If 
<code>dDF.na = "none"</code>, no subtitute denominator degrees of freedom 
are employed; if <code>dDF.na = "residual"</code>, 
the residual degrees of freedom from <code>asreml.obj$nedf</code> are used; 
if <code>dDF.na = "maximum"</code>, the maximum of those denDF that are available, 
excluding that for the Intercept, is used; if all denDF are <code>NA</code>, 
<code>asreml.obj$nedf</code> is used. If <code>dDF.na = "supplied"</code>, 
a <code>vector</code> of values for the denominator degrees of freedom is to 
be supplied in <code>dDF.values</code>. Any other setting is ignored and 
a warning message produced. Generally, substituting these degrees of freedom is 
anticonservative in that it is likely that the degrees of freedom used will be
too large.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_ddf.values">dDF.values</code></td>
<td>
<p>A <code>vector</code> of values to be used when <code>dDF.na = "supplied"</code>. 
Its values will be used when <code>denDF</code> in a test for a fixed effect
is <code>NA</code>. This vector must be the same length as the number of 
fixed terms, including (Intercept) whose value could be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code> and <code>family</code> is set to 
<code>asr_guassian</code> (the default), then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code> 
and <code>family</code> is set to <code>asr_guassian</code>, 
then the AIC and BIC based on the full likelihood, evaluated using 
REML estimates, are included. If <code>family</code> is <code>asr_binomial</code> 
or <code>asr_poisson</code>, with <code>dispersion</code> set to 1, the 
<code>deviance</code> is extracted from <code>object</code> and used to 
calculate the AIC and BIC.
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) those for the supplied <code>terms</code> and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting. 
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testranfix.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.
If the <code>term</code> is not in the model, then the supplied <code>asreml</code> 
object will be returned. Also, <code>reml.test</code> will have the likelihood 
ratio and the p-value set to <code>NA</code> and the degrees of freedom to zero.
Similarly, the row of <code>test.summary</code> for the <code>term</code> will have 
its name, DF set to NA, p-value set to <code>NA</code>, and action set to Absent.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, 
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <br />
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <br />
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary(current.asrt)
# Test nugget term
current.asrt &lt;- testranfix(current.asrt, "units", positive=TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='testresidual.asrtests'>Fits a new residual formula, tests whether the change 
is significant and records the result in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</h2><span id='topic+testresidual.asrtests'></span><span id='topic+testresidual'></span>

<h3>Description</h3>

<p>Fits a new <code>residual formula</code> using <code>asreml-R4</code> 
(replaces the <code>rcov</code> <code>formula</code> of asreml-R3) and tests 
whether the change is significant. If <code>simpler = FALSE</code> the model 
to be fitted must be more complex than the one whose fit has been stored in 
<code>asrtests.obj</code>. That is, the new model must have more parameters. 
However, if <code>simpler = TRUE</code> the model to be fitted must be simpler 
than the one whose fit has been stored in <code>asrtests.obj</code> in that it 
must have fewer parameters. Any boundary terms are removed using 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, which may mean that the models are not 
nested. The test is a REML likelihood ratio test that is performed using 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, which is only valid if the models are nested. 
It compares the newly fitted model with the fit of the model in 
<code>asrtest.obj</code>. If the two models have the same number of variance 
parameters, then no change is made to the residual. A row is added to the 
<code>test.summary</code> <code>data.frame</code> using the supplied <code>label</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
testresidual(asrtests.obj, terms=NULL, label = "R model", 
             simpler = FALSE, alpha = 0.05, 
             allow.unconverged = TRUE, allow.fixedcorrelation = TRUE, 
             checkboundaryonly = FALSE, positive.zero = FALSE, 
             bound.test.parameters = "none", 
             bound.exclusions = c("F","B","S","C"), REMLDF = NULL, 
             denDF="numeric", IClikelihood = "none", 
             update = TRUE, trace = FALSE,
             set.terms = NULL, ignore.suffices = TRUE, 
             bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testresidual.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> for a fitted model that is a list 
containing the componets (i) <code>asreml.obj</code>, (ii) <code>wald.tab</code> 
(iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_terms">terms</code></td>
<td>
<p>A model for the <code>residual</code> argument in <code>asreml-R4</code> 
(the <code>rcov</code> formula in older versions of <code>asreml</code>), stored 
as a <code>character</code>. To remove the model, enter <code>"-(.)"</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_label">label</code></td>
<td>
<p>A character string to use as the label in <code>test.summary</code> and 
which indicates what is being tested.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_simpler">simpler</code></td>
<td>
<p>A logical indicating whether the new model to be fitted is 
simpler than the already fitted model whose fit is stored in 
<code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the test.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asreml</code> object is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_positive.zero">positive.zero</code></td>
<td>
<p>Indicates whether the hypothesized values for the 
variance components being tested are on the boundary 
of the parameter space. For example, this is true 
for positively-constrained variance components that, 
under the reduced model, are zero. This argument does 
not need to be set if <code>bound.test.parameters</code> is set.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_bound.test.parameters">bound.test.parameters</code></td>
<td>
<p>Indicates whether for the variance components 
being tested, at least some of the hypothesized values
are on the boundary of the parameter space. 
The possibilities are <code>"none"</code>, <code>"onlybound"</code> 
and <code>"one-and-one"</code>. The default is <code>"none"</code>, 
although if it is set to <code>"none"</code> and 
<code>positive.zero</code> is <code>TRUE</code> then 
<code>bound.test.parameters</code> is taken to be <code>"onlybound"</code>. 
When <code>bound.test.parameters</code> is set to 
<code>"one-and-one"</code>, it signifies that there are two 
parameters being tested, one of which is bound and the 
other is not. For example, the latter is true for testing 
a covariance and a positively-constrained variance component 
that, under the reduced model, are zero.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying one or more bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in using <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>.
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_remldf">REMLDF</code></td>
<td>
<p>A <code>numeric</code> giving the difference in the number of variance parameters 
whose estimates are not of the type specified in <code>bound.exclusions</code> 
for two models being compared in a REML ratio test using 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>. If <code>NULL</code> then this is determined from 
the information in the <code>asreml</code> object for the two models.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to autommatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated 
using REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) the <code>residual</code> (<code>rcov</code>)  model is 
that specified in <code>terms</code> (ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE </code> then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting. 
The names must match those in the <code>vparameters</code> component of the 
<code>asreml.obj</code> component in the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testresidual.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> containing the components (i) <code>asreml.obj</code>,
(ii) <code>wald.tab</code>, and (iii) <code>test.summary</code>.
If the <code>term</code> is not in the model, then the supplied <code>asreml.obj</code> 
will be returned. Also, <code>reml.test</code> will have the likelihood 
ratio and the p-value set to <code>NA</code> and the degrees of freedom to zero.
Similarly, the row of <code>test.summary</code> for the <code>term</code> will have 
its name, a p-value set to <code>NA</code>, and action set to Absent.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <br />
<code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+testswapran.asrtests">testswapran.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <br />
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary(current.asrt)
# Test Row autocorrelation
current.asrt &lt;- testresidual(current.asrt, "~ Row:ar1(Column)", 
                             label="Row autocorrelation", simpler=TRUE)
print(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='testswapran.asrtests'>Tests, using a REMLRT, the significance of the difference between the current 
random model and one in which oldterms are dropped and newterms are added.
The result is recorded in an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</h2><span id='topic+testswapran.asrtests'></span><span id='topic+testswapran'></span>

<h3>Description</h3>

<p>Fits a new random model using <code>asreml</code> by removing <code>oldterms</code> 
and adding <code>newterms</code>. If <code>simpler = FALSE</code> the model to be fitted 
must be more complex than the one whose fit has been stored in 
<code>asrtests.obj</code>. That is, the new model must have more parameters. 
However, if <code>simpler = TRUE</code> the model to be fitted must be simpler 
than the one whose fit has been stored in <code>asrtests.obj</code> in that it 
must have fewer parameters. The test is a REML ratio test that is performed using 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <b>which is only valid if the models are nested</b>. 
It compares the newly fitted model with the fit of the model in 
<code>asrtests.obj</code>. A row is added to the <code>test.summary</code> 
<code>data.frame</code> using the supplied <code>label</code>. If the newly fitted model 
is retained, any boundary terms are then removed using 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>. If the models are not nested, then using 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code> may be the more appropriate approach 
for comparing models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asrtests'
testswapran(asrtests.obj, oldterms = NULL, newterms = NULL, 
            label = "Swap in random model", simpler = FALSE, alpha = 0.05, 
            allow.unconverged = TRUE, allow.fixedcorrelation = TRUE, 
            checkboundaryonly = FALSE, 
            positive.zero = FALSE, bound.test.parameters = "none", 
            bound.exclusions = c("F","B","S","C"), REMLDF = NULL, 
            denDF="numeric", IClikelihood = "none", 
            trace = FALSE, update = TRUE, 
            set.terms = NULL, ignore.suffices = TRUE, 
            bounds = "P", initial.values = NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testswapran.asrtests_+3A_asrtests.obj">asrtests.obj</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code> for a fitted model that is a list 
containing the components (i) <code>asreml.obj</code>, (ii) <code>wald.tab</code> 
(iii) <code>test.summary</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_oldterms">oldterms</code></td>
<td>
<p>Terms, stored as a <code>character</code>, that are to be removed from the 
random model using <code>asreml</code>. The names of the terms must 
match those in the <code>vparameters</code> component of the <code>asreml.obj</code> 
component in <code>asrtests.obj</code>. Note that 
multiple terms specified using a single <code>asreml::at</code> function 
can only be dropped as a whole. If the term was specified using 
an <code>asreml::at</code> function with a single level, then it can be 
removed and either the level itself or its <code><a href="base.html#topic+numeric">numeric</a></code> 
position in the levels returned by the <code><a href="base.html#topic+levels">levels</a></code> function 
can be specified.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_newterms">newterms</code></td>
<td>
<p>Terms, stored as a <code>character</code>, that are to be added to the 
random model using <code>asreml</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_simpler">simpler</code></td>
<td>
<p>A logical indicating whether the new model to be fitted. after the
changes made as a result of swapping <code>oldterms</code> for 
<code>newterms</code>, is simpler than the already fitted model whose 
fit is stored in <code>asrtests.obj</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the test.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_allow.unconverged">allow.unconverged</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it does not converge. If <code>FALSE</code> and the fit of the new 
model does not converge, the supplied <code>asrtests.obj</code> is returned.  
Also, if <code>FALSE</code> and the fit of the new model has converged, but that 
of the old model has not, the new model will be accepted.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_allow.fixedcorrelation">allow.fixedcorrelation</code></td>
<td>
<p>A <code>logical</code> indicating whether to accept a new model 
even when it contains correlations in the model whose values have been 
designated as fixed, bound or singular. If <code>FALSE</code> and the new model 
contains correlations whose values have not been able to be estimated, 
the supplied <code>asrtests.obj</code> is returned. The fit in the 
<code>asreml.obj</code> component of the supplied <code>asrtests.obj</code> will 
also be tested and a warning issued if both fixed correlations are found 
in it and <code>allow.fixedcorrelation</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_checkboundaryonly">checkboundaryonly</code></td>
<td>
<p>If <code>TRUE</code> then boundary and singular terms are not removed by 
<code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>; a warning is issued instead.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_label">label</code></td>
<td>
<p>A character string to use as the label in <code>test.summary</code> and 
which indicates what is being tested.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_positive.zero">positive.zero</code></td>
<td>
<p>Indicates whether the hypothesized values for the 
variance components being tested are on the boundary 
of the parameter space. For example, this is true 
for positively-constrained variance components that, 
under the reduced model, are zero. This argument does 
not need to be set if <code>bound.test.parameters</code> is set.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_bound.test.parameters">bound.test.parameters</code></td>
<td>
<p>Indicates whether for the variance components 
being tested, at least some of the hypothesized values
are on the boundary of the parameter space. 
The possibilities are <code>"none"</code>, <code>"onlybound"</code> 
and <code>"one-and-one"</code>. The default is <code>"none"</code>, 
although if it is set to <code>"none"</code> and 
<code>positive.zero</code> is <code>TRUE</code> then 
<code>bound.test.parameters</code> is taken to be <code>"onlybound"</code>. 
When <code>bound.test.parameters</code> is set to 
<code>"one-and-one"</code>, it signifies that there are two 
parameters being tested, one of which is bound and the 
other is not. For example, the latter is true for testing 
a covariance and a positively-constrained variance component 
that, under the reduced model, are zero.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound (constraint) codes that 
will result in a variance parameter being excluded from the count of 
estimated variance parameters in using <code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>.
If set to <code>NULL</code> then none will be excluded.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_remldf">REMLDF</code></td>
<td>
<p>A <code>numeric</code> giving the difference in the number of variance parameters 
whose estimates are not of the type specified in <code>bound.exclusions</code> 
for two models being compared in a REML ratio test using 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>. If <code>NULL</code> then this is determined from 
the information in the <code>asreml</code> object for the two models.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_dendf">denDF</code></td>
<td>
<p>Specifies the method to use in computing approximate denominator 
degrees of freedom when <code>wald.asreml</code> is called. Can be <code>none</code> 
to suppress the computations, <code>numeric</code> for numerical methods,
<code>algebraic</code> for algebraic methods or <code>default</code>, the default, 
to automatically choose numeric or algebraic computations depending 
on problem size. The denominator degrees of freedom are calculated 
according to Kenward and Roger (1997) for fixed terms in the dense 
part of the model.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_iclikelihood">IClikelihood</code></td>
<td>
<p>A <code>character</code> that controls both the occurrence and the type 
of likelihood for information criterion in the <code>test.summary</code> 
of the new <code><a href="#topic+asrtests.object">asrtests.object</a></code>. If <code>none</code>, none are 
included. Otherwise, if <code>REML</code>, then the AIC and BIC based 
on the Restricted Maximum Likelihood are included; if <code>full</code>, 
then the AIC and BIC based on the full likelihood, evaluated 
using REML estimates, are included. 
(See also <code><a href="#topic+infoCriteria.asreml">infoCriteria.asreml</a></code>.)</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being (i) for the supplied <code>oldterms</code> and 
(ii) those specified via <code>...</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_set.terms">set.terms</code></td>
<td>
<p>A character vector specifying the terms that are to have 
bounds and/or initial values set prior to fitting. 
The names must match those in the <code>vparameters</code> component 
of the <code>asreml.obj</code> component in the <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_ignore.suffices">ignore.suffices</code></td>
<td>
<p>A logical vector specifying whether the suffices of the 
<code>asreml</code>-assigned names of the variance terms (i.e. the 
information to the right of an &quot;!&quot;, other than &quot;R!&quot;) is to 
be ignored in matching elements of <code>terms</code>. 
If <code>TRUE</code> for an element of <code>terms</code>, the suffices 
are stripped from the <code>asreml</code>-assigned names. 
If <code>FALSE</code> for an element of <code>terms</code>, the element 
must exactly match an <code>asreml</code>-assigned name for a 
variance term. This vector must be of length one or the 
same length as <code>terms</code>. If it is of length one then 
the same action is applied to the <code>asreml</code>-assigned 
suffices for all the terms in <code>terms</code>.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_bounds">bounds</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the bounds to be applied 
to the terms specified in <code>set.terms</code>. This vector 
must be of length one or the same length as <code>set.terms</code>. 
If it is of length one then the same constraint is 
applied to all the terms in <code>set.terms</code>. 
If any of the bounds are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_initial.values">initial.values</code></td>
<td>
<p>A character vector specifying the initial values for  
the terms specified in <code>terms</code>. This vector 
must be of length one or the same length as <code>terms</code>. 
If it is of length one then the same initial value is 
applied to all the terms in <code>terms</code>. 
If any of the initial.values are equal to NA then they are 
left unchanged for those terms.</p>
</td></tr>
<tr><td><code id="testswapran.asrtests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>asreml</code>, <code>wald.asreml</code> and 
<code><a href="#topic+as.asrtests">as.asrtests</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+asrtests.object">asrtests.object</a></code> for a fitted model that is a list 
containing the components (i) <code>asreml.obj</code>, (ii) <code>wald.tab</code> 
(iii) <code>test.summary</code>.
If the <code>term</code> is not in the model, then the supplied <code>asreml</code> 
object will be returned. Also, <code>reml.test</code> will have the likelihood 
ratio and the p-value set to <code>NA</code> and the degrees of freedom to zero.
Similarly, the row of <code>test.summary</code> for the <code>term</code> will have 
its name, a p-value set to <code>NA</code>, and action set to Absent.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Kenward, M. G., &amp; Roger, J. H. (1997). Small sample inference for fixed effects from restricted maximum likelihood. 
<em>Biometrics</em>, <b>53</b>, 983-997.</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.asrtests">as.asrtests</a></code>, <code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, 
<code><a href="#topic+REMLRT.asreml">REMLRT.asreml</a></code>, <code><a href="#topic+rmboundary.asrtests">rmboundary.asrtests</a></code>, <br />
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, <code><a href="#topic+testresidual.asrtests">testresidual.asrtests</a></code>, 
<code><a href="#topic+changeModelOnIC.asrtests">changeModelOnIC.asrtests</a></code>, <br /> 
<code><a href="#topic+changeTerms.asrtests">changeTerms.asrtests</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
current.asrt &lt;- testswapran(current.asrt, oldterms = "str(~ Cart/xDays, ~us(2):id(184))",
                            newterms = "Cart/xDays", pos = FALSE, 
                            label = "Intercept/Slope correlation", 
                            simpler = TRUE)
  print(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='validAlldiffs'>Checks that an object is a valid alldiffs object.</h2><span id='topic+validAlldiffs'></span>

<h3>Description</h3>

<p>Checks that an <code>object</code> is an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code> of S3-class 
<code>alldiffs</code> containing the components <code>asreml.obj</code>, 
<code>wald.tab</code> and <code>test.summary</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validAlldiffs(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validAlldiffs_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> describing why the <code>object</code> 
is not a valid <code><a href="#topic+alldiffs.object">alldiffs.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldiffs.object">alldiffs.object</a></code>, <code><a href="#topic+is.alldiffs">is.alldiffs</a></code>, <code><a href="#topic+as.alldiffs">as.alldiffs</a></code>, <br /> 
<code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code>, <code><a href="#topic+validAsrtests">validAsrtests</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    den.df &lt;- min(Var.preds$df)
    ## Modify Var.preds to be compatible with a predictions.frame
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
    Var.vcov &lt;- vcov(Var.emm)
    Var.sed &lt;- NULL

    ## Form an all.diffs object
     Var.diffs &lt;- as.alldiffs(predictions = Var.preds, classify = "Nitrogen:Variety", 
                              sed = Var.sed, vcov = Var.vcov, tdf = den.df)

    ## check the validity of Var.diffs
    validAlldiffs(Var.diffs)
  }
</code></pre>

<hr>
<h2 id='validAsrtests'>Checks that an object is a valid asrtests object.</h2><span id='topic+validAsrtests'></span>

<h3>Description</h3>

<p>Checks that an <code>object</code> is an <code><a href="#topic+asrtests.object">asrtests.object</a></code> of S3-class 
<code>asrtests</code> containing the components <code>asreml.obj</code>, 
<code>wald.tab</code> and <code>test.summary</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validAsrtests(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validAsrtests_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> describing why the <code>object</code> 
is not a valid <code><a href="#topic+asrtests.object">asrtests.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+asrtests.object">asrtests.object</a></code>, <code><a href="#topic+is.asrtests">is.asrtests</a></code>, <code><a href="#topic+as.asrtests">as.asrtests</a></code>, <br /> 
<code><a href="#topic+validPredictionsFrame">validPredictionsFrame</a></code>, <code><a href="#topic+validAlldiffs">validAlldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dae)
library(asreml)
library(asremlPlus)
## use ?Wheat.dat for data set details
data(Wheat.dat)

# Fit initial model
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)

# Load current fit into an asrtests object
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)

# check validity of current.asrt
validAsrtests(current.asrt)

## End(Not run)</code></pre>

<hr>
<h2 id='validPredictionsFrame'>Checks that an object is a valid predictions.frame.</h2><span id='topic+validPredictionsFrame'></span>

<h3>Description</h3>

<p>Checks that an <code>object</code> is a <code><a href="#topic+predictions.frame">predictions.frame</a></code> 
of S3-class <code>data.frame</code> that contains the columns 
predicted.value, standard.error and est.status.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validPredictionsFrame(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validPredictionsFrame_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+predictions.frame">predictions.frame</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or a <code>character</code> describing why the <code>object</code> 
is not a valid <code><a href="#topic+predictions.frame">predictions.frame</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictions.frame">predictions.frame</a></code>, <code><a href="#topic+is.predictions.frame">is.predictions.frame</a></code>, 
<code><a href="#topic+as.predictions.frame">as.predictions.frame</a></code>, <br /> 
<code><a href="#topic+validAsrtests">validAsrtests</a></code>, <code><a href="#topic+validAlldiffs">validAlldiffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Oats.dat)
  
  ## Use asreml to get predictions and associated statistics

  ## Not run: 
  m1.asr &lt;- asreml(Yield ~ Nitrogen*Variety, 
                   random=~Blocks/Wplots,
                   data=Oats.dat)
  current.asrt &lt;- as.asrtests(m1.asr)
  Var.pred &lt;- asreml::predict.asreml(m1.asr, classify="Nitrogen:Variety", 
                                      sed=TRUE)
  if (getASRemlVersionLoaded(nchar = 1) == "3")
    Var.pred &lt;- Var.pred$predictions
  Var.preds &lt;- as.predictions.frame(Var.pred$pvals, se = "std.error", 
                                    est.status = "status")

  
## End(Not run)
  
  ## Use lmerTest and emmmeans to get predictions and associated statistics
  if (requireNamespace("lmerTest", quietly = TRUE) &amp; 
      requireNamespace("emmeans", quietly = TRUE))
  {
    m1.lmer &lt;- lmerTest::lmer(Yield ~ Nitrogen*Variety + (1|Blocks/Wplots),
                              data=Oats.dat)
    Var.emm &lt;- emmeans::emmeans(m1.lmer, specs = ~ Nitrogen:Variety)
    Var.preds &lt;- summary(Var.emm)
    Var.preds &lt;- as.predictions.frame(Var.preds, predictions = "emmean", 
                                      se = "SE", interval.type = "CI", 
                                      interval.names = c("lower.CL", "upper.CL"))
  }

  if (exists("Var.preds"))
  {
    ## Check the class and validity of the predictions.frame
    is.predictions.frame(Var.preds)
    validPredictionsFrame(Var.preds)
  }
</code></pre>

<hr>
<h2 id='variofaces.asreml'>Plots empirical variogram faces, including envelopes, as described by 
Stefanova, Smith &amp; Cullis (2009).</h2><span id='topic+variofaces.asreml'></span><span id='topic+variofaces'></span>

<h3>Description</h3>

<p>A function that produces a plot for each face of an empirical 2D 
<code>variogram</code> based on residuals produced after the fitting of a model 
using the function <code>asreml</code>. 
It also adds envelopes to the plot by simulating data sets in parallel 
from a multivariate normal distribution with expectation equal to the 
fitted values obtained from the fixed and spline terms and variance 
matrix equal to the fitted variance matrix 
(Stefanova, Smith &amp; Cullis, 2009). The plot is controlled by the 
<code>residual</code> model, which must consist of two factors corresponding to 
the two physical dimensions underlying the data. It can also have a third 
term involving the <code>at</code> or <code>dsum</code> function that defines sections 
of the data, such as experiments in different environments. 
In this case, the two variogram faces are produced for each section.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asreml'
variofaces(asreml.obj, means=NULL, V=NULL, 
           sections = NULL, row.factor = NULL, col.factor = NULL,
           nsim=100, seed = NULL, 
           extra.matrix = NULL, ignore.terms = NULL, fixed.spline.terms = NULL, 
           bound.exclusions = c("F","B","S","C"), tolerance=1E-10, 
           units = "ignore", update = TRUE, trace = FALSE, 
           graphics.device=NULL, ncores = 2, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variofaces.asreml_+3A_asreml.obj">asreml.obj</code></td>
<td>
<p>An <code>asreml</code> object from a call to <code>asreml</code> in which the 
<code>data</code> argument has been set.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_means">means</code></td>
<td>
<p>The <code>vector</code> of means to be used in generating simulated data sets. If
it is <code>NULL</code>, the fitted values based on <code>object</code> are used. 
It must be the same length as the response variable for <code>object</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_v">V</code></td>
<td>
<p>The fitted variance <code>matrix</code>, i.e. having the appropriate pattern and values 
given the model fitted to the observed data and the estimates of the 
parameters obtained. If <code>V</code> is <code>NULL</code> then <code><a href="#topic+estimateV.asreml">estimateV.asreml</a></code> 
is called to obtain it from <code>asreml.obj</code></p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_sections">sections</code></td>
<td>
<p>A single <code>character</code> string that specifies the name of the column 
in the <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the <code><a href="base.html#topic+factor">factor</a></code> 
that identifies different sections of the data to which separate spatial 
models have been fitted.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_row.factor">row.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the rows of a grid that are one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_col.factor">col.factor</code></td>
<td>
<p>A single <code>character</code> string nominating a <code><a href="base.html#topic+factor">factor</a></code> 
that indexes the columns of a grid that are one dimension of a 
spatial correlation model. The <code><a href="base.html#topic+factor">factor</a></code> must a column in 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> stored in the <code>asreml.obj</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_nsim">nsim</code></td>
<td>
<p>The number of data sets to be simulated in obtaining the envelopes.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_seed">seed</code></td>
<td>
<p>A single value, interpreted as an integer, that specifies the 
starting value of the random number generator. The &quot;L'Ecuyer-CMRG&quot; random 
generator is used and <code>nextRNGStream</code> is used to seed each core from the
original <code>seed</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_extra.matrix">extra.matrix</code></td>
<td>
<p>A <code>matrix</code> of order equal to the number of observations that is to 
be added to the variance <code>matrix</code>, the latter based 
on the information in <code>asreml.obj</code>. It is assumed that the sigma-parameterized 
values of the variance parameter estimates, such as is given in the <code>varcomp</code> 
component of <code>summary.asreml</code>, have been used in calculating 
<code>extra.matrix</code>; the values in the <code>vparameters</code> component of 
<code>G.param</code> and <code>R.param</code> may be either gamma- or sigma-parameterized. 
The argument <code>extra.matrix</code> can be used in conjunction with 
<code>ignore.terms</code> as a workaround to include components of the variance matrix 
for variance functions that have not been implemented in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_ignore.terms">ignore.terms</code></td>
<td>
<p>A <code>character</code> giving terms from either the <code>random</code> or 
<code>residual</code> models that are to be ignored in that their contributions to 
the variance is not to be included in the estimated matrix. The term names are those 
given in the <code>vparameters</code> component of the <code>asreml</code> object or the 
<code>varcomp</code> component produced by <code>summary.asreml</code>, but only up to the 
first exclamation mark (<code>!</code>). This can be used 
in conjunction with <code>estimateV.asreml</code> as a workaround to include components 
of the variance matrix for variance functions that have not been implemented                
in <code>estimateV</code>.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_fixed.spline.terms">fixed.spline.terms</code></td>
<td>
<p>A <code>character</code> vector giving one or more spline terms in the 
<code>random</code> model that are regarded as fixed  and so are to be ignored because 
they are not regarded as contributing to the variance. The term names are those
given in the <code>vparameters</code> component of the <code>asreml</code> object or the 
<code>varcomp</code> component produced by <code>summary.asreml</code>, but only up to the
first exclamation mark (<code>!</code>).</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_bound.exclusions">bound.exclusions</code></td>
<td>
<p>A <code>character</code> specifying one or more bound codes that 
will result in a variance parameter in the <code>random</code> model being excluded 
from contributing to the variance. If set to <code>NULL</code> then none will
be excluded.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_tolerance">tolerance</code></td>
<td>
<p>The value such that eigenvalues less than it are considered to be zero.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_units">units</code></td>
<td>
<p>A <code>character</code> indicating whether the BLUPs for <code>units</code> are 
added to the residuals when this reserved factor is included in the 
<code>random</code> model. Possible values are <code>addtoresiduals</code> and 
<code>ignore</code>. If standardized conditional residuals are plotted and 
the BLUPs for <code>units</code> are to be added then it is the standardized 
BLUPs that are added.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_update">update</code></td>
<td>
<p>If <code>TRUE</code>, and <code>set.terms</code> is <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> is called to fit the model to be tested, 
using the values of the variance parameters stored in 
the <code>asreml.object</code>, that is stored in <code>asrtests.obj</code>, as starting values. 
If <code>FALSE</code> or <code>set.terms</code> is not <code>NULL</code>, then 
<code><a href="#topic+newfit.asreml">newfit.asreml</a></code> will not use the stored variance parameter 
values as starting values when fitting the new model, the only 
modifications being ((i) the model is fitted to simulated data and 
(ii) those specified via <code>...</code>, except that changes 
cannot be made to any of the models.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_trace">trace</code></td>
<td>
<p>If TRUE then partial iteration details are displayed when ASReml-R 
functions are invoked; if FALSE then no output is displayed.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_graphics.device">graphics.device</code></td>
<td>
<p>A <code>character</code> specifying a graphics device for plotting. 
The default is <br /><code>graphics.device = NULL</code>, which will result 
in plots being produced on the current graphics device. Setting it to 
<code>"windows"</code>, for example,  will result in a windows graphics 
device being  opened.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_ncores">ncores</code></td>
<td>
<p>A <code>numeric</code> specifying the number of cores to use in doing the 
simulations. In choosing a value for <code>ncores</code>, it is necessary to 
take into account other processes that are using parallel processing at 
the same time.</p>
</td></tr>
<tr><td><code id="variofaces.asreml_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the function <code>asreml</code>. Changes 
to the models are not allowed. Other changes are dangerous and generally 
should be avoided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>residual</code> model is scanned to ensure that it involves only two factors 
not included in the <code>at</code> function, and to see if it has a third factor in
an <code>at</code> function. If so, the faces of the 2D variogram, each based on one 
of the two non-<code>at</code> factors, are derived from the residuals in the 
supplied <code>asreml</code> object using <code>asreml.variogram</code>, this yielding the observed 
<code>variogram</code> faces. If <code>aom</code> was set to <code>TRUE</code> for the <code>asreml</code> 
object, the standardized conditional residuals are used. 
Then <code>nsim</code> data sets are generated by 
adding the <code>fitted.values</code>, extracted from the <code>asreml</code> object,
to a vector of values randomly generated from a normal distribution with 
expectation zero and variance matrix <code>V</code>. Each data set is analyzed 
using the model in <code>object</code> and several sets are generated and analyzed 
in parallel. The variogram values for the faces are 
obtained using <code>asreml.variogram</code> stored. Note, if the analysis for a 
data set does not converge in <code>maxiter</code> iterations, it is discarded and 
a replacement data set generated. The value of <code>maxiter</code> can be specified 
in the call to <code>variofaces.asreml</code>. Plots are produced for each face and 
include the observed values and the 2.5%, 50% &amp; 97.5% quantiles.</p>


<h3>Value</h3>

<p>A <code>list</code> with the following components:
</p>

<ol>
<li><p><b>face1:</b> a <code>data.frame</code> containing the variogram values on 
which the plot for the first dimension is based. 
</p>
</li>
<li><p><b>face2:</b> a <code>data.frame</code> containing the variogram values on 
which the plot for the second dimension is based.</p>
</li></ol>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Stefanova, K. T., Smith, A. B. &amp; Cullis, B. R. (2009) Enhanced diagnostics for the 
spatial analysis of field trials. <em>Journal of Agricultural, Biological, 
and Environmental Statistics</em>, <b>14</b>, 392&ndash;410.</p>


<h3>See Also</h3>

<p><code><a href="#topic+asremlPlus-package">asremlPlus-package</a></code>, <code>asreml</code>, <code><a href="#topic+newfit.asreml">newfit.asreml</a></code>, 
<code><a href="#topic+plotVariofaces.data.frame">plotVariofaces.data.frame</a></code>, <code><a href="#topic+simulate.asreml">simulate.asreml</a></code>, <code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Wheat.dat)
current.asr &lt;- asreml(yield ~ Rep + WithinColPairs + Variety, 
                      random = ~ Row + Column + units,
                      residual = ~ ar1(Row):ar1(Column), 
                      data=Wheat.dat)
current.asrt &lt;- as.asrtests(current.asr, NULL, NULL)
current.asrt &lt;- rmboundary.asrtests(current.asrt)
# Form variance matrix based on estimated variance parameters
s2 &lt;- current.asr$sigma2
gamma.Row &lt;- current.asr$gammas[1]
gamma.unit &lt;- current.asr$gammas[2]
rho.r &lt;- current.asr$gammas[4]
rho.c &lt;- current.asr$gammas[5]
row.ar1 &lt;- mat.ar1(order=10, rho=rho.r)
col.ar1 &lt;- mat.ar1(order=15, rho=rho.c)
V &lt;- gamma.Row * fac.sumop(Wheat.dat$Row) + 
     gamma.unit * diag(1, nrow=150, ncol=150) + 
     mat.dirprod(col.ar1, row.ar1)
V &lt;- s2*V

#Produce variogram faces plot (Stefanaova et al, 2009)
variofaces(current.asr, V=V, ncores = parallel::detectCores())

## End(Not run)</code></pre>

<hr>
<h2 id='WaterRunoff.dat'>Data for an experiment to investigate the quality of water runoff over time</h2><span id='topic+WaterRunoff.dat'></span>

<h3>Description</h3>

<p>This data is from an experiment to investigate the quality of water runoff. However, it has been modified to hide the true identity of the Species and Sources. It is used to provide executable examples of the functions listed under <b>Examples</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WaterRunoff.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 440 observations of 13 variables.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Kazemi, F. (pers. comm.)</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseModel.asrtests">chooseModel.asrtests</a></code>, <code><a href="#topic+reparamSigDevn.asrtests">reparamSigDevn.asrtests</a></code>, <br />
<code><a href="#topic+plotPredictions.data.frame">plotPredictions.data.frame</a></code>, <code><a href="#topic+predictPlus.asreml">predictPlus.asreml</a></code>, 
<code><a href="#topic+predictPresent.asreml">predictPresent.asreml</a></code></p>

<hr>
<h2 id='Wheat.dat'>Data for a 1976 experiment to investigate 25 varieties of wheat</h2><span id='topic+Wheat.dat'></span>

<h3>Description</h3>

<p>The data appears in Gilmour et al. (1995) and is from a field experiment designed to compare the
performance of 25 varieties of spring wheat. An analysis of it using asreml is presented by 
Butler et al. (2023, Section 7.6), although they suggest that it is a barley experiment. 
It is used in the Wheat vignettes  [Enter <code>vignette(package = "asremlPlus")</code>] as an 
executable example of the use of the <code>asremlPlus</code> to analyse a data set.
</p>
<p>The experiment was conducted at Slate Hall Farm, UK, in 1976 and was designed as 
a balanced lattice square with 6 replicates laid out in a 10 <code class="reqn">\times</code> 15 rectangular
grid. The columns in the data frame are: Rep, Row, Column, WithinColPairs, Variety, yield.
The response variable is the grain yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Wheat.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 150 observations of 6 variables.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Butler, D. G., Cullis, B. R., Gilmour, A. R., Gogel, B. J. and 
Thompson, R. (2023). <em>ASReml-R Reference Manual Version 4.2.</em>  
VSN International Ltd, <a href="https://asreml.kb.vsni.co.uk/">https://asreml.kb.vsni.co.uk/</a>.
</p>
<p>Gilmour, A. R., et al. (1995) Average Information REML: An efficient algorithm for 
variance parameter estimation in linear mixed models. <em>Biometrics</em>, 
<b>51</b>, 1440-1450.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
