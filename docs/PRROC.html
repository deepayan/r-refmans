<!DOCTYPE html><html><head><title>Help for package PRROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PRROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PRROC-package'><p>Compute and plot PR and ROC curves and the areas under the curves for weighted and unweighted data</p></a></li>
<li><a href='#plot.PRROC'>
<p>Plotting PRROC objects</p></a></li>
<li><a href='#pr.curve'>
<p>PR curve</p></a></li>
<li><a href='#print.PRROC'>
<p>printing PRROC objects</p></a></li>
<li><a href='#roc.curve'>
<p>ROC curve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Precision-Recall and ROC Curves for Weighted and Unweighted Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-06-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Grau and Jens Keilwagen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Grau &lt;grau@informatik.uni-halle.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the areas under the precision-recall (PR) and ROC curve for weighted (e.g., soft-labeled) and unweighted data. In contrast to other implementations, the interpolation between points of the PR curve is done by a non-linear piecewise function. In addition to the areas under the curves, the curves themselves can also be computed and plotted by a specific S3-method. References: Davis and Goadrich (2006) &lt;<a href="https://doi.org/10.1145%2F1143844.1143874">doi:10.1145/1143844.1143874</a>&gt;; Keilwagen et al. (2014) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0092209">doi:10.1371/journal.pone.0092209</a>&gt;; Grau et al. (2015) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtv153">doi:10.1093/bioinformatics/btv153</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-19 10:20:18 UTC; dev</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggplot2, ROCR</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-19 10:42:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='PRROC-package'>Compute and plot PR and ROC curves and the areas under the curves for weighted and unweighted data</h2><span id='topic+PRROC-package'></span><span id='topic+PRROC'></span>

<h3>Description</h3>

<p>This package computes the areas under the precision-recall (PR) and receiver operating characteristics (ROC) curve for weighted (e.g., soft-labeled) and unweighted data. In contrast to other implementations, the interpolation between points of the PR curve is done by a non-linear piecewise function. In addition to the areas under the curves, the curves themselves can also be computed and plotted by a specific S3-method.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> PRROC</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-04-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jan Grau and Jens Keilwagen
</p>
<p>Maintainer: Jan Grau &lt;grau@informatik.uni-halle.de&gt;
</p>


<h3>References</h3>

<p>J. Davis and M. Goadrich. The relationship between precision-recall and ROC curves.
In <em>Proceedings of the 23rd International Conference on Machine Learning</em>, pages 233&ndash;240, New York, NY, USA, 2006. ACM.
</p>
<p>T. Fawcett, An introduction to ROC analysis, Pattern Recognition Letters (27) 8, 861-874, 2006.
</p>
<p>J. Keilwagen, I. Grosse, and J. Grau. Area under precision-recall curves for weighted and unweighted data, PLOS ONE (9) 3, 2014.
</p>
<p>J. Grau, I. Grosse, and J. Keilwagen. PRROC: computing and visualizing precision-recall and receiver operating characteristic curves in R. Bioinformatics, 31(15):2595-2597, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pr.curve">pr.curve</a></code>
</p>
<p><code><a href="#topic+roc.curve">roc.curve</a></code>
</p>
<p><code><a href="#topic+plot.PRROC">plot.PRROC</a></code>
</p>
<p><code><a href="#topic+print.PRROC">print.PRROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create artificial scores as random numbers
x &lt;- rnorm( 1000 );
y &lt;- rnorm( 1000, -1 );

# compute area under PR curve
pr &lt;- pr.curve( x, y );
print( pr );

# compute area under ROC curve
roc &lt;- roc.curve( x, y );
print( roc );

# compute PR curve and area under curve
pr &lt;- pr.curve( x, y, curve = TRUE );
# plot curve
plot(pr);

# compute ROC curve and area under curve
roc &lt;- roc.curve( x, y, curve = TRUE );
# plot curve
plot(roc);

# create artificial weights
x.weights &lt;- runif( 1000 );
y.weights &lt;- runif( 1000 );

# compute PR curve and area under curve
pr &lt;- pr.curve( x, y, x.weights, y.weights, curve = TRUE );
# plot curve
plot(pr);

# compute ROC curve and area under curve
roc &lt;- roc.curve( x, y, x.weights, y.weights, curve = TRUE );
# plot curve
plot(roc);
</code></pre>

<hr>
<h2 id='plot.PRROC'>
Plotting PRROC objects
</h2><span id='topic+plot.PRROC'></span>

<h3>Description</h3>

<p>Plots the PR or ROC curves of a PRROC object. To obtain such curves, <code>pr.curve</code> or <code>roc.curve</code> must be called with
argument <code>curve=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PRROC'
plot(x, xlim=c(0,1), ylim=c(0,1), auc.main=TRUE, 
    auc.type=c("integral","davis.goadrich"), 
    legend=ifelse(is.logical(color) &amp; color==TRUE,4,NA), xlab=NULL, ylab=NULL, 
    main=NULL, color=TRUE, lwd=3, add=FALSE, 
    scale.color=hsv(h=seq(0,1,length=100)*0.8, s=1, v=1), 
    max.plot = FALSE, min.plot = FALSE, rand.plot = FALSE, 
    fill.area = (max.plot &amp; min.plot), maxminrand.col = grey(0.5), 
    fill.color = grey(0.95), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PRROC_+3A_x">x</code></td>
<td>
<p>a PRROC object obtained from <code><a href="#topic+pr.curve">pr.curve</a></code> or <code><a href="#topic+roc.curve">roc.curve</a></code></p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_xlim">xlim</code></td>
<td>
<p>as in <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_ylim">ylim</code></td>
<td>
<p>as in <code>plot</code></p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_auc.main">auc.main</code></td>
<td>
<p><code>TRUE</code> to show the area under curve in the title</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_auc.type">auc.type</code></td>
<td>
<p>the area under the curve shown in the title (see also <code>pr.curve</code>). Ignored if <code>auc.main=FALSE</code> or <code>x$type=="ROC"</code>.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_legend">legend</code></td>
<td>
<p>if <code>TRUE</code> (and <code>color==TRUE</code>), a legend for the color scheme for the scores is shown on the right side of the main plot. 
If <code>legend</code> is a number between 1 and 4, the legend is drawn on the correspond side of the main plot (see <code><a href="graphics.html#topic+axis">axis</a></code>). If <code>legend</code>
is <code>FALSE</code> or <code>NA</code>, no legend is drawn.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_xlab">xlab</code></td>
<td>
<p>the label of the x-axis. If <code>NULL</code>, label is chosen according the kind of the curve.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_ylab">ylab</code></td>
<td>
<p>the label of the y-axis. If <code>NULL</code>, label is chosen according the kind of the curve.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_main">main</code></td>
<td>
<p>the title of the plot. If <code>NULL</code>, title is chosen according the kind of the curve.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_color">color</code></td>
<td>
<p>if <code>TRUE</code>, curve is plotted in colors reflecting score thresholds, 
if <code>FALSE</code>, the curve is plotted in black, 
if a color value (e.g., <code>2</code> or <code>"red"</code> for red) the curve is plotted in that color. 
For everything different from <code>TRUE</code>, the legend is omitted irrespective of the value of argument <code>legend</code></p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_lwd">lwd</code></td>
<td>
<p>the line width of the curve</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, the curve is added to an existing plot. Only works correctly, if in the previous call (with <code>add==FALSE</code>), no legend has been added to the plot.</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_scale.color">scale.color</code></td>
<td>
<p>vector of colors that are used to reflect score thresholds, compare <code>color</code></p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_max.plot">max.plot</code></td>
<td>
<p>if <code>TRUE</code> and <code>x</code> has been computed including the maximum curve, plot this maximum curve (ignored if <code>add=TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_min.plot">min.plot</code></td>
<td>
<p>if <code>TRUE</code> and <code>x</code> has been computed including the minimum curve, plot this maximum curve (ignored if <code>add=TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_rand.plot">rand.plot</code></td>
<td>
<p>if <code>TRUE</code> and <code>x</code> has been computed including the curve of a random classifier, plot this curve (ignored if <code>add=TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_fill.area">fill.area</code></td>
<td>
<p>fill the area between maximum and minimum curve (given both have been computed for <code>x</code>) (ignored if <code>add=TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_maxminrand.col">maxminrand.col</code></td>
<td>
<p>the plot color for the maximum, minimum, and random curves</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_fill.color">fill.color</code></td>
<td>
<p>the fill color for the area between minimum and maximum curve</p>
</td></tr>
<tr><td><code id="plot.PRROC_+3A_...">...</code></td>
<td>
<p>see <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for PRROC objects can be used in different ways. 
</p>
<p>The first is to plot a visualization of a single ROC or PR curve
that also represents the classification thresholds of individual points on the curve by a color scale. 
In this case, a <code>PRROC</code> object must be provided as <code>x</code>, <code>add</code> must be <code>FALSE</code>, and <code>color</code> must be <code>TRUE</code>. 
If, in addition, <code>legend</code> is set to <code>TRUE</code>, a legend translating colors to numerical threshold values is included to the right of the curve plot
itself. The layout of curve plot and legend is accomplished using <code>layout()</code>, which means that this type of ROC/PR plot cannot be combined
with other/complex layouts.
</p>
<p>The second application of the <code>plot</code> method is to compare the performance of different classifiers (typically on the same data set). To do so,
<code>plot</code> must be called with <code>add=FALSE</code> and <code>color</code> set to one specific color (e.g., 2, &quot;red&quot;,...) for the first <code>PRROC</code> object
provided as <code>x</code>. Subsequent calls of <code>plot</code> with <code>add=TRUE</code> can be used to add further curves to the first plot, where different colors
may be specified by the <code>color</code> parameter.
</p>
<p>In both cases, the first (or only) call to <code>plot</code> also allows for including plots of the maximum and minimum curve, 
highlighting the area between minimum and maximum, and the curve of a random classifier. 
For this purpose, the <code>PRROC</code> object needs to be created (using <code><a href="#topic+pr.curve">pr.curve</a></code> or <code><a href="#topic+roc.curve">roc.curve</a></code>) with the corresponding
parameters (e.g., <code>max.compute</code>) set to <code>TRUE</code>.
</p>
<p>Additional examples for the different use cases and corresponding plot commands are given in the documentations of <code><a href="#topic+pr.curve">pr.curve</a></code> and <code><a href="#topic+roc.curve">roc.curve</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jan Grau and Jens Keilwagen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pr.curve">pr.curve</a></code>
</p>
<p><code><a href="#topic+roc.curve">roc.curve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create artificial scores as random numbers
x &lt;- rnorm( 1000 );
y &lt;- rnorm( 1000, -1 );

# compute PR curve
pr &lt;- pr.curve( x, y, curve = TRUE );

# standard plot of PR curve
plot( pr );

# compute ROC curve
roc &lt;- roc.curve( x, y, curve = TRUE );

# standard plot of ROC curve
plot( roc );

# create another set of scores
x.2 &lt;- rnorm( 1000 );
y.2 &lt;- rnorm( 1000, -2 );

# compute PR curve
pr.2 &lt;- pr.curve( x.2, y.2, curve=TRUE );
# and ROC curve
roc.2 &lt;- roc.curve( x.2, y.2, curve=TRUE );

# plot PR curve in red, without legend
plot( pr, color = "red", auc.main=FALSE );
# add second PR curve in green
plot( pr.2, color = 3, add = TRUE );


# plot ROC curve in red, without legend
plot( roc, color = "red", auc.main=FALSE);
# add second ROC curve in green
plot( roc.2, color = 3, add = TRUE );

# plot PR curve with legend below the main plot
plot( pr, legend=1 );

# compute PR curve with minimum and maximum curve, and random classifier
pr &lt;- pr.curve( x, y, curve = TRUE, max.compute = TRUE, 
  min.compute = TRUE, rand.compute = TRUE);

# plot PR curve with area between minimum and 
# maximum curve in green and random classifier in blue
plot(pr, rand.plot = TRUE, fill.area = TRUE, fill.color = rgb(0.8,1,0.8), 
  maxminrand.col = "blue" );


</code></pre>

<hr>
<h2 id='pr.curve'>
PR curve
</h2><span id='topic+pr.curve'></span>

<h3>Description</h3>

<p>Computes the area under the precision-recall (PR) curve for weighted and unweighted data. 
In contrast to other implementations, the interpolation between points of the PR curve is done by a non-linear piecewise function. 
In addition to the area under the curve, the curve itself can be obtained by setting argument <code>curve</code> to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr.curve( scores.class0, scores.class1=scores.class0, weights.class0=NULL, 
    weights.class1 = {if(is.null(weights.class0)){NULL}else{1-weights.class0}}, 
    sorted = FALSE, curve = FALSE, 
    minStepSize=min(1,ifelse(is.null(weights.class0),1,sum(weights.class0)/100)),
    max.compute=F, min.compute=F, rand.compute=F,dg.compute=T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr.curve_+3A_scores.class0">scores.class0</code></td>
<td>
<p>the classification scores of i) all data points or ii) only the data points belonging to the positive class.
</p>
<p>In the first case, scores.class1 should not be assigned an explicit value, but left at the default (scores.class1=scores.class0). 
In addition, weights.class0 needs to contain the class labels of the data points (1 for positive class, 0 for negative class) or 
the soft-labels for the positive class, i.e., the probability for each data point to belong to the positive class. 
Accordingly, weights.class1 should be left at the default value (1-weights.class0).
</p>
<p>In the second case, the scores for the negative data points need to be provided in scores.class1. In this case, weights.class0 and weights.class1
need to be provided only for soft-labelling and should be of the same length as scores.class0 and scores.class1, respectively.</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_scores.class1">scores.class1</code></td>
<td>
<p>the scores of the negative class if provided separately (see scores.class0)</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_weights.class0">weights.class0</code></td>
<td>
<p>the weights for the data points of the positive class in same ordering as <code>scores.class0</code> (optional)</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_weights.class1">weights.class1</code></td>
<td>
<p>the weights for the data points of the negative class in same ordering as <code>scores.class1</code> (optional)</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_sorted">sorted</code></td>
<td>
<p><code>TRUE</code> if the scores are already sorted</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_curve">curve</code></td>
<td>
<p><code>TRUE</code> if the curve should also be returned, <code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_minstepsize">minStepSize</code></td>
<td>
<p>the minimum step size between intermediate points of the curve, does not affect the computation of AUC-PR</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_max.compute">max.compute</code></td>
<td>
<p><code>TRUE</code> if the maximum PR curve given the supplied weights should be computed</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_min.compute">min.compute</code></td>
<td>
<p><code>TRUE</code> if the minimum PR curve given the supplied weights should be computed</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_rand.compute">rand.compute</code></td>
<td>
<p><code>TRUE</code> if the PR curve of a random classifier given the supplied weights should be computed</p>
</td></tr>
<tr><td><code id="pr.curve_+3A_dg.compute">dg.compute</code></td>
<td>
<p><code>TRUE</code> if the area under the curve according to the interpolation of Davis and Goadrich should be computed. Reduces runtime if switched off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the area under a precision-recall curve and, optionally, the curve itself and returns it as a <code>PRROC</code> object (see below).
It can be used under different scenarios:
</p>
<p>1. Standard, hard-labeled classification problems:
</p>
<p>Each data point is uniquely assigned to one out of two possible classes. In this case, the classification scores may be either provided separately
for the data points of each of the classes, i.e., as <code>scores.class0</code> for the data points from the positive/foreground class and as <code>scores.class1</code>
for the data points of the negative/background class; or the classification scores for all data points are provided as <code>scores.class0</code> and the labels
are provided as numerical values (<code>1</code> for the positive class, <code>0</code> for the negative class)  as <code>weights.class0</code>.
</p>
<p>2. Weighted, hard-labeled classification problems:
</p>
<p>Each data point is uniquely assigned to one out of two possible classes, where each data points additionally has a weight assigned, for instance
multiplicities in the original data set. In this case, the classification scores need to be provided separately
for the data points of each of the classes, i.e., as <code>scores.class0</code> for the data points from the positive/foreground class and as <code>scores.class1</code>
for the data points of the negative/background class. In addition, the weights for the data points must be provided as <code>weights.class0</code> and <code>weights.class1</code>, respectively.
</p>
<p>3. Soft-labeled classification problems:
</p>
<p>Each data point belongs to both of the two classes with a certain probability, where for each data point, these two probabilities add up to 1.
In this case, the classification scores for all data points need to be provided only once as <code>scores.class0</code> and only the positive/foreground weights for each data point need to be provided in <code>weights.class0</code>, while the converse probability for the negative class is automatically set to
<code>weights.class1=1.0-weights.class0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>type</code></td>
<td>
<p>always <code>"PR"</code></p>
</td></tr>
<tr><td><code>auc.integral</code></td>
<td>
<p>area under the curve computed by integration of the piecewise function</p>
</td></tr>
<tr><td><code>auc.davis.goadrich</code></td>
<td>
<p>area under the curve computed using the interpolation of Davis &amp; Goadrich (2006). Is <code>NA</code> if weights are provided and different from <code>1</code>.</p>
</td></tr>
<tr><td><code>curve</code></td>
<td>
<p>the PR curve as a matrix, where the first column contains recall, the second contains precision, and the third contains the corresponding threshold on the scores.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum PR curve (if <code>max.compute=TRUE</code>)</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum PR curve (if <code>min.compute=TRUE</code>)</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>the PR curve of a random classifier (if <code>rand.compute=TRUE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Grau and Jens Keilwagen
</p>


<h3>References</h3>

<p>J. Davis and M. Goadrich. The relationship between precision-recall and ROC curves.
In <em>Proceedings of the 23rd International Conference on Machine Learning</em>, pages 233&ndash;240, New York, NY, USA, 2006. ACM.
</p>
<p>J. Keilwagen, I. Grosse, and J. Grau. Area under precision-recall curves for weighted and unweighted data, PLOS ONE (9) 3, 2014.
</p>
<p>J. Grau, I. Grosse, and J. Keilwagen. PRROC: computing and visualizing precision-recall and receiver operating characteristic curves in R. Bioinformatics, 31(15):2595-2597, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roc.curve">roc.curve</a></code>
</p>
<p><code><a href="#topic+plot.PRROC">plot.PRROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create artificial scores as random numbers
x &lt;- rnorm( 1000 );
y &lt;- rnorm( 1000, -1 );
# compute area under PR curve for the hard-labeled case
pr &lt;- pr.curve( x, y );
print( pr );

# compute PR curve and area under curve
pr &lt;- pr.curve( x, y, curve = TRUE );
# plot curve
plot(pr);

# create artificial weights
x.weights &lt;- runif( 1000 );
y.weights &lt;- runif( 1000 );

# compute PR curve and area under curve for weighted, hard-labeled data
pr &lt;- pr.curve( x, y, x.weights, y.weights, curve = TRUE );
# and plot the curve
plot(pr);


# compute PR curve and area under curve,
# and maximum, minimum, and random PR curve for weighted, hard-labeled data
pr &lt;- pr.curve(x, y, x.weights, y.weights, curve = TRUE, max.compute = TRUE, 
  min.compute = TRUE, rand.compute = TRUE);
# plot all three curves
plot(pr, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE)


# concatenate the drawn scores
scores&lt;-c(x,y);
# and create artificial soft-labels
weights&lt;-c(runif(1000, min = 0.5, max = 1), runif(1000, min = 0, max = 0.5))

# compute PR curve and area under curve,
# and maximum, minimum, and random PR curve for soft-labeled data
pr&lt;-pr.curve(scores.class0 = scores, weights.class0 = weights, curve = TRUE, 
  max.compute = TRUE, min.compute = TRUE, rand.compute = TRUE);
# plot all three curves
plot(pr, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE)

# print the areas under the curves
print(pr);


# generate classification scores of a second classifier
scores.2&lt;-c(rnorm( 1000 ),rnorm( 1000, -2 ));
# and compute the PR curve
pr.2&lt;-pr.curve(scores.class0 = scores.2, weights.class0 = weights, curve = TRUE)
# plot all three curves for the first classifier in red
plot(pr, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE, 
  color="red", auc.main=FALSE)
# and add the curve for the second classifier
plot(pr.2, add=TRUE, color="green")
</code></pre>

<hr>
<h2 id='print.PRROC'>
printing PRROC objects
</h2><span id='topic+print.PRROC'></span>

<h3>Description</h3>

<p>Prints a PRROC object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PRROC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PRROC_+3A_x">x</code></td>
<td>
<p>a PRROC object obtained from <code><a href="#topic+pr.curve">pr.curve</a></code> or <code><a href="#topic+roc.curve">roc.curve</a></code></p>
</td></tr>
<tr><td><code id="print.PRROC_+3A_...">...</code></td>
<td>
<p>see <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method for PRROC objects prints the area under the (PR or ROC) curve, and (if <code>curve=TRUE</code> in <code><a href="#topic+pr.curve">pr.curve</a></code> or <code><a href="#topic+roc.curve">roc.curve</a></code>) the range of classification scores. If also <code>max.compute=TRUE</code>, <code>min.compute=TRUE</code>, and/or <code>rand.compute=TRUE</code> when the PRROC object has been computes using <code><a href="#topic+pr.curve">pr.curve</a></code> or <code><a href="#topic+roc.curve">roc.curve</a></code>, a relative area under curve is reported, i.e., the minimal AUC subtracted from the original AUC and the result divided by the difference of maximum and minimum AUC.
</p>


<h3>Author(s)</h3>

<p>Jan Grau and Jens Keilwagen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pr.curve">pr.curve</a></code>
</p>
<p><code><a href="#topic+roc.curve">roc.curve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create artificial scores as random numbers
x &lt;- rnorm( 1000 );
y &lt;- rnorm( 1000, -1 );
# compute area under PR curve
pr &lt;- pr.curve( x, y );
print( pr );

# compute area under ROC curve
roc &lt;- roc.curve( x, y );
print( roc );
</code></pre>

<hr>
<h2 id='roc.curve'>
ROC curve
</h2><span id='topic+roc.curve'></span>

<h3>Description</h3>

<p>Computes the area under the receiver operating characteristics (ROC) curve for weighted and unweighted data.
In addition to the area under the curve, the curve can be obtained by setting argument <code>curve</code> to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc.curve( scores.class0, scores.class1=scores.class0, weights.class0=NULL, 
    weights.class1 = {if(is.null(weights.class0)){NULL}else{1-weights.class0}}, 
    sorted = FALSE, curve = FALSE, 
    max.compute=F, min.compute=F, rand.compute=F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.curve_+3A_scores.class0">scores.class0</code></td>
<td>
<p>the classification scores of i) all data points or ii) only the data points belonging to the positive class.
</p>
<p>In the first case, scores.class1 should not be assigned an explicit value, but left at the default (scores.class1=scores.class0). 
In addition, weights.class0 needs to contain the class labels of the data points (1 for positive class, 0 for negative class) or 
the soft-labels for the positive class, i.e., the probability for each data point to belong to the positive class. 
Accordingly, weights.class1 should be left at the default value (1-weights.class0).
</p>
<p>In the second case, the scores for the negative data points need to be provided in scores.class1. In this case, weights.class0 and weights.class1
need to be provided only for soft-labelling and should be of the same length as scores.class0 and scores.class1, respectively.</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_scores.class1">scores.class1</code></td>
<td>
<p>the scores of the negative class if provided separately (see scores.class0)</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_weights.class0">weights.class0</code></td>
<td>
<p>the weights for the data points of the positive class in same ordering as <code>scores.class0</code> (optional)</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_weights.class1">weights.class1</code></td>
<td>
<p>the weights for the data points of the negative class in same ordering as <code>scores.class1</code> (optional)</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_sorted">sorted</code></td>
<td>
<p><code>TRUE</code> if the scores are already sorted</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_curve">curve</code></td>
<td>
<p><code>TRUE</code> if the curve should also be returned, <code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_max.compute">max.compute</code></td>
<td>
<p><code>TRUE</code> if the maximum ROC curve given the supplied weights should be computed</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_min.compute">min.compute</code></td>
<td>
<p><code>TRUE</code> if the minimum ROC curve given the supplied weights should be computed</p>
</td></tr>
<tr><td><code id="roc.curve_+3A_rand.compute">rand.compute</code></td>
<td>
<p><code>TRUE</code> if the ROC curve of a random classifier given the supplied weights should be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the area under a receiver-operating characteristic (ROC) curve and, optionally, the curve itself and returns it as a <code>PRROC</code> object (see below).
It can be used under different scenarios:
</p>
<p>1. Standard, hard-labeled classification problems:
</p>
<p>Each data point is uniquely assigned to one out of two possible classes. In this case, the classification scores may be either provided separately
for the data points of each of the classes, i.e., as <code>scores.class0</code> for the data points from the positive/foreground class and as <code>scores.class1</code>
for the data points of the negative/background class; or the classification scores for all data points are provided as <code>scores.class0</code> and the labels
are provided as numerical values (<code>1</code> for the positive class, <code>0</code> for the negative class)  as <code>weights.class0</code>.
</p>
<p>2. Weighted, hard-labeled classification problems:
</p>
<p>Each data point is uniquely assigned to one out of two possible classes, where each data points additionally has a weight assigned, for instance
multiplicities in the original data set. In this case, the classification scores need to be provided separately
for the data points of each of the classes, i.e., as <code>scores.class0</code> for the data points from the positive/foreground class and as <code>scores.class1</code>
for the data points of the negative/background class. In addition, the weights for the data points must be provided as <code>weights.class0</code> and <code>weights.class1</code>, respectively.
</p>
<p>3. Soft-labeled classification problems:
</p>
<p>Each data point belongs to both of the two classes with a certain probability, where for each data point, these two probabilities add up to 1.
In this case, the classification scores for all data points need to be provided only once as <code>scores.class0</code> and only the positive/foreground weights for each data point need to be provided in <code>weights.class0</code>, while the converse probability for the negative class is automatically set to
<code>weights.class1=1.0-weights.class0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>type</code></td>
<td>
<p>always <code>"ROC"</code></p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>area under the curve</p>
</td></tr>
<tr><td><code>curve</code></td>
<td>
<p>the ROC curve as a matrix, where the first column contains the false-positive rate, the second contains recall (sensitivity), and the third contains the corresponding threshold on the scores.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum ROC curve (if <code>max.compute=TRUE</code>)</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum ROC curve (if <code>min.compute=TRUE</code>)</p>
</td></tr>
<tr><td><code>rand</code></td>
<td>
<p>the ROC curve of a random classifier (if <code>rand.compute=TRUE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Grau and Jens Keilwagen
</p>


<h3>References</h3>

<p>J. Keilwagen, I. Grosse, and J. Grau. Area under precision-recall curves for weighted and unweighted data, PLOS ONE (9) 3, 2014.
</p>
<p>J. Grau, I. Grosse, and J. Keilwagen. PRROC: computing and visualizing precision-recall and receiver operating characteristic curves in R. Bioinformatics, 31(15):2595-2597, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pr.curve">pr.curve</a></code>
</p>
<p><code><a href="#topic+plot.PRROC">plot.PRROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create artificial scores as random numbers
x &lt;- rnorm( 1000 );
y &lt;- rnorm( 1000, -1 );
# compute area under ROC curve for the hard-labeled case
roc &lt;- roc.curve( x, y );
print( roc );

# compute ROC curve and area under curve
roc &lt;- roc.curve( x, y, curve = TRUE );
# plot curve
plot(roc);


# create artificial weights
x.weights &lt;- runif( 1000 );
y.weights &lt;- runif( 1000 );

# compute ROC curve and area under curve for weighted, hard-labeled data
roc &lt;- roc.curve( x, y, x.weights, y.weights, curve = TRUE );
# and plot the curve
plot(roc);


# compute ROC curve and area under curve,
# and maximum, minimum, and random ROC curve for weighted, hard-labeled data
roc &lt;- roc.curve(x, y, x.weights, y.weights, curve = TRUE, max.compute = TRUE, 
  min.compute = TRUE, rand.compute = TRUE);
# plot all three curves
plot(roc, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE)


# concatenate the drawn scores
scores&lt;-c(x,y);
# and create artificial soft-labels
weights&lt;-c(runif(1000, min = 0.5, max = 1), runif(1000, min = 0, max = 0.5))

# compute ROC curve and area under curve,
# and maximum, minimum, and random ROC curve  for soft-labeled data
roc&lt;-roc.curve(scores.class0 = scores, weights.class0 = weights, curve = TRUE, 
  max.compute = TRUE, min.compute = TRUE, rand.compute = TRUE);
# plot all three curves
plot(roc, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE)

# print the areas under the curves
print(roc);

# generate classification scores of a second classifier
scores.2&lt;-c(rnorm( 1000 ),rnorm( 1000, -2 ));
# and compute the ROC curve
roc.2&lt;-roc.curve(scores.class0 = scores.2, weights.class0 = weights, curve = TRUE)
# plot all three curves for the first classifier in red
plot(roc, max.plot = TRUE, min.plot = TRUE, rand.plot = TRUE, fill.area = TRUE, 
  color="red", auc.main=FALSE)
# and add the curve for the second classifier
plot(roc.2, add=TRUE, color="green")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
