<!DOCTYPE html><html lang="en-US"><head><title>Help for package treePlotArea</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treePlotArea}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#treePlotArea-package'><p>Correction Factors for Tree Plot Areas Intersected by Stand</p>
Boundaries</a></li>
<li><a href='#boundaries'><p>Boundaries of the German National Inventory 2022</p></a></li>
<li><a href='#bw2bwi2022de'><p>Convert Preprocessed Data Back to Original Units</p></a></li>
<li><a href='#bwi2cartesian'><p>Convert Coordinates of the German National Forest Inventory to Cartesian</p>
Coordinates</a></li>
<li><a href='#check_boundaries'><p>Check Validity of Boundaries</p></a></li>
<li><a href='#get_boundary_polygons'><p>Convert Boundaries to Polygons</p></a></li>
<li><a href='#get_boundary_radius'><p>Get the Boundary Radius for a Given Diameter at Breast Height</p></a></li>
<li><a href='#get_correction_factors'><p>Correction Factors for Tree Plot Areas Intersected by Stand Boundaries</p></a></li>
<li><a href='#get_defaults'><p>Get Default Options for <span class="pkg">treePlotArea</span></p></a></li>
<li><a href='#get_intersection'><p>Get Intersection Point of Two Lines</p></a></li>
<li><a href='#get_r_max'><p>Get a Theoretical Maximum Distance for a Tree</p></a></li>
<li><a href='#orthogonal'><p>Get the Slope–intercept Form of an Orthogonal</p></a></li>
<li><a href='#plot_tree_plot_area'><p>Plot Tree Plot Area</p></a></li>
<li><a href='#points2equation'><p>Get a Slope–intercept Form from a Two-point Form of an Equation</p></a></li>
<li><a href='#secant_intersections'><p>Calculate Intersections of Circle by a Straight Line</p></a></li>
<li><a href='#select_valid_angle_count_trees'><p>Select Valid Angle Counts Only</p></a></li>
<li><a href='#set_options'><p>Set Default Options for <span class="pkg">treePlotArea</span></p></a></li>
<li><a href='#throw'><p>Throw a Condition</p></a></li>
<li><a href='#trees'><p>Angle Count Sampling of the German National Inventory 2022</p></a></li>
<li><a href='#validate_data'><p>Validate Data and Optionally Delete Missing Data</p></a></li>
<li><a href='#vector_length'><p>Give the Length of a Vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Correction Factors for Tree Plot Areas Intersected by Stand
Boundaries</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The German national forest inventory uses angle count sampling, 
    a sampling method first published as 'Bitterlich, W.: Die Winkelzählmessung.
    Allgemeine Forst- und Holzwirtschaftliche Zeitung, 58. Jahrg., Folge 11/12 
    vom Juni 1947' and extended by Grosenbaugh
    (<a href="https://academic.oup.com/jof/article-abstract/50/1/32/4684174">https://academic.oup.com/jof/article-abstract/50/1/32/4684174</a>)
    as probability proportional to size sampling.
    When plots are located near stand boundaries, their sizes and hence
    their probabilities need to be corrected.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/fvafrcu/treeplotarea.git">https://gitlab.com/fvafrcu/treeplotarea.git</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fritools, graphics, sf, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>checkmate, pkgload, plotrix, rmarkdown, rprojroot, RUnit,
testthat, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 09:20:38 UTC; qwer</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Dominik Cullmann [aut, cre],
  Bernhard Bösch [ctb],
  Christoph Fischer [ctb],
  Gerald Kändler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Dominik Cullmann &lt;fvafrcu@mailbox.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='treePlotArea-package'>Correction Factors for Tree Plot Areas Intersected by Stand
Boundaries</h2><span id='topic+treePlotArea'></span><span id='topic+treePlotArea-package'></span>

<h3>Description</h3>

<p>The German national forest inventory uses angle count sampling, a
sampling method first published by Bitterlich (1947) and extended by
Grosenbaugh (1952) as probability proportional to size sampling. When plots
are located near stand boundaries, their sizes and hence their
probabilities need to be corrected.
</p>


<h3>Details</h3>

<p>You will find the details in<br />
<code>vignette("An_Introduction_to_treePlotArea", package =
"treePlotArea")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andreas Dominik Cullmann <a href="mailto:fvafrcu@mailbox.org">fvafrcu@mailbox.org</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bernhard Bösch [contributor]
</p>
</li>
<li><p> Christoph Fischer [contributor]
</p>
</li>
<li><p> Gerald Kändler [contributor]
</p>
</li></ul>



<h3>References</h3>

<p><cite>
Bitterlich, W. (1947): Die Winkelzählmessung.
Allgemeine Forst- und Holzwirtschaftliche Zeitung, 58.
</cite>
</p>
<p><cite>
Grosenbaugh, L. R. (1952): Plotless Timber Estimates &ndash; New, Fast, Easy.
Journal of Forestry.
https://academic.oup.com/jof/article-abstract/50/1/32/4684174.
</cite>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/fvafrcu/treeplotarea.git">https://gitlab.com/fvafrcu/treeplotarea.git</a>
</p>
</li></ul>


<hr>
<h2 id='boundaries'>Boundaries of the German National Inventory 2022</h2><span id='topic+boundaries'></span>

<h3>Description</h3>

<p>An extract from the the federal database. Refer to <em>Aufnahmeanweisung
für die vierte Bundeswaldinventur (2021 - 2022)</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("boundaries", package = "treePlotArea")
</code></pre>


<h3>Format</h3>

<p>A data frame with 148 observations on the following 13 variables.
Variables not needed with the package are marked with an asterisk.
</p>

<dl>
<dt><code>tnr</code></dt><dd><p>The tract id.</p>
</dd>
<dt><code>enr</code></dt><dd><p>The corner id. A tract may have up to 4 corners on
wooden floor.</p>
</dd>
<dt><code>vbl</code></dt><dd><p>* An indicator giving the country. 804 denotes
Baden-Wuerttemberg.</p>
</dd>
<dt><code>rnr</code></dt><dd><p>* The boundary id.</p>
</dd>
<dt><code>rk</code></dt><dd><p>An indicator giving the validity of the boundary. Values
of 9 or higher indicate that this boundary is not valid (any more).</p>
</dd>
<dt><code>rart</code></dt><dd><p>An indicator giving the type of the boundary (stand or
forest boundary, for example).</p>
</dd>
<dt><code>rterrain</code></dt><dd><p>* An Indicator giving the type of terrain behind
the border.</p>
</dd>
<dt><code>spa_gon</code></dt><dd><p>The azimuth in gon of the starting point of the
boundary.</p>
</dd>
<dt><code>spa_m</code></dt><dd><p>The distance to the starting point of the boundary in
centimeter</p>
</dd>
<dt><code>spk_gon</code></dt><dd><p>As above, for the boundary's flexing point.</p>
</dd>
<dt><code>spk_m</code></dt><dd><p>As above, for the boundary's flexing point.</p>
</dd>
<dt><code>spe_gon</code></dt><dd><p>As above, for the boundary's stopping point.</p>
</dd>
<dt><code>spe_m</code></dt><dd><p>As above, for the boundary's stopping point.</p>
</dd>
</dl>



<h3>References</h3>

<p><cite>
Aufnahmeanweisung für die vierte Bundeswaldinventur (2021 - 2022)
Johann Heinrich von Thünen-Institut. Bundesforschungseinheit für
Ländliche Räume, Wald und Fischerei, Thünen-Institut für
Waldökologie.
</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundaries &lt;- get(data("boundaries", package = "treePlotArea"))
</code></pre>

<hr>
<h2 id='bw2bwi2022de'>Convert Preprocessed Data Back to Original Units</h2><span id='topic+bw2bwi2022de'></span>

<h3>Description</h3>

<p>The data tree coming with this package was processed by Gerald Kaendler for
the
country of  Baden-Wuerttemberg, and is the reference for testing as he
adjusted diameter measurements to breast height where they had been measured
in diverging heights (due to deformations of trees at breast height).
<em>Which we really need to do.</em>
But he did some other things we need to revert if we want to follow the
standards
from the federal database. He
</p>

<ol>
<li><p> converted the diameter at breast height from millimeter to
centimeter and renamed it,
</p>
</li>
<li><p> converted horizontal distance from centimeter to meter and renamed
it.
</p>
</li></ol>

<p>So we add two variables holding the diameter in millimeter and the horizontal
distance in centimeter, named by the output of <br />
<code>getOption("treePlotArea")[["angle_counts"]][["dbh"]]</code><br />
and<br />
<code>getOption("treePlotArea")[["angle_counts"]][["distance"]]</code><br />
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw2bwi2022de(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw2bwi2022de_+3A_x">x</code></td>
<td>
<p>A tree data set, typically
<code>get(data("trees", package = "treePlotArea"))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree data set prepared to work with the package.
</p>


<h3>See Also</h3>

<p>Other data functions: 
<code><a href="#topic+select_valid_angle_count_trees">select_valid_angle_count_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- get(data("trees", package = "treePlotArea"))
summary(trees)
angle_counts &lt;- bw2bwi2022de(trees)
summary(angle_counts)
</code></pre>

<hr>
<h2 id='bwi2cartesian'>Convert Coordinates of the German National Forest Inventory to Cartesian
Coordinates</h2><span id='topic+bwi2cartesian'></span>

<h3>Description</h3>

<p>Coordinates of the German national forest inventory are measured in gon
eastward from north at distance in centimeter.
We need cartesian coordinates for relational computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwi2cartesian(azimuth, distance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bwi2cartesian_+3A_azimuth">azimuth</code></td>
<td>
<p>The azimuths, from north, eastern side, in gon.</p>
</td></tr>
<tr><td><code id="bwi2cartesian_+3A_distance">distance</code></td>
<td>
<p>The distances from the origin, typically measured in
centimeter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of cartesian coordinates in the unit of <code>distance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- c(0, 100)
d1 &lt;- c(100, 200)
print(coords &lt;- bwi2cartesian(a1, d1))
all.equal(coords, matrix(c(0, 100, 200, 0), nrow = 2, byrow = TRUE),
          check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='check_boundaries'>Check Validity of Boundaries</h2><span id='topic+check_boundaries'></span>

<h3>Description</h3>

<p>There is a boundary (tract 6878, corner 1, boundary 1) in the federal
database
for the 2012 survey that runs exactly through the plot. If that boundary
would be valid, at that corner the term &quot;stand&quot; is not defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_boundaries(x, stop_on_error = TRUE, clean_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_boundaries_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing boundaries.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["boundaries"]]</code> or <br />
<code>getOption("treePlotArea")[["boundaries"]]</code>.
<br />
Could be
<code>get(data("boundaries", package = "treePlotArea"))</code>.</p>
</td></tr>
<tr><td><code id="check_boundaries_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>Throw an error if invalid boundaries are found?</p>
</td></tr>
<tr><td><code id="check_boundaries_+3A_clean_data">clean_data</code></td>
<td>
<p>Get rid of invalid boundaries?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>So we check for such boundaries. These are straight boundaries with identical
azimuth values for start and end, and flexed boundaries where azimuth values
for either start or end and the azimuth value for the nook are identical and
the nook is farther away form the plot than the corresponding start or end.
</p>


<h3>Value</h3>

<p>A (possibly cleansed) <code><a href="base.html#topic+data.frame">data.frame</a></code> containing boundaries.
</p>


<h3>See Also</h3>

<p>Other boundary functions: 
<code><a href="#topic+get_boundary_polygons">get_boundary_polygons</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("boundaries", package = "treePlotArea")
validate_data(x = boundaries)
check_boundaries(boundaries)
</code></pre>

<hr>
<h2 id='get_boundary_polygons'>Convert Boundaries to Polygons</h2><span id='topic+get_boundary_polygons'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+get_correction_factors">get_correction_factors</a></code> to convert a boundary table
to polygons. You may want to see the polygons, that is why we exported this
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boundary_polygons(boundaries, stop_on_error = TRUE, clean_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_boundary_polygons_+3A_boundaries">boundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing boundaries.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["boundaries"]]</code> or <br />
<code>getOption("treePlotArea")[["boundaries"]]</code>.<br />
Could be
<code>get(data("boundaries", package = "treePlotArea"))</code> or the
output of
<code><a href="#topic+get_boundary_polygons">get_boundary_polygons</a></code>.</p>
</td></tr>
<tr><td><code id="get_boundary_polygons_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>Throw an error if invalid boundaries are encountered?
(There was tract 6878, corner 1, boundary 1 in the federal
database for the 2012 survey, runs through the plot.
There is no stand defined that way!).</p>
</td></tr>
<tr><td><code id="get_boundary_polygons_+3A_clean_data">clean_data</code></td>
<td>
<p>Omit invalid boundaries in any further calculations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with all boundary polygons for each corner for each tract.
</p>


<h3>See Also</h3>

<p>Other boundary functions: 
<code><a href="#topic+check_boundaries">check_boundaries</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundaries &lt;- get(data("boundaries", package = "treePlotArea"))
boundary_polygons &lt;- get_boundary_polygons(boundaries)
</code></pre>

<hr>
<h2 id='get_boundary_radius'>Get the Boundary Radius for a Given Diameter at Breast Height</h2><span id='topic+get_boundary_radius'></span>

<h3>Description</h3>

<p>The boundary radius is the maximum distance a tree with a given diameter at
breast height may be
away from the center of the plot to still be part of the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boundary_radius(
  dbh,
  unit = c("mm", "cm", "dm", "m"),
  counting_factor = 4,
  area = 10000,
  is_ti_round = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_boundary_radius_+3A_dbh">dbh</code></td>
<td>
<p>Diameter at breast height in millimeter.</p>
</td></tr>
<tr><td><code id="get_boundary_radius_+3A_unit">unit</code></td>
<td>
<p>The unit for the return value.</p>
</td></tr>
<tr><td><code id="get_boundary_radius_+3A_counting_factor">counting_factor</code></td>
<td>
<p>The basal area factor used in counting the trees. For
tally trees in the German national forest inventory its value is 4 [m^2].</p>
</td></tr>
<tr><td><code id="get_boundary_radius_+3A_area">area</code></td>
<td>
<p>The reference surface in [m^2].</p>
</td></tr>
<tr><td><code id="get_boundary_radius_+3A_is_ti_round">is_ti_round</code></td>
<td>
<p>When checking for the boundary circle of a tree to include
the center of the plot: round that circle's radius to the unit (i.e. [cm])
as done by Thuenen Institute?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>counting_factor</code> and <code>area</code> really don't have to be
square meters as long as they are in the same unit.
</p>


<h3>Value</h3>

<p>Minimum diameter at breast height in <code>units</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A diameter at breast height of 50.5 cm
get_boundary_radius(505, unit  = "m")
get_boundary_radius(505, unit  = "m", is_ti_round = FALSE)
get_boundary_radius(1000, unit  = "cm")
get_boundary_radius(973, unit  = "cm")
get_boundary_radius(973, unit  = "cm", is_ti_round = FALSE)
</code></pre>

<hr>
<h2 id='get_correction_factors'>Correction Factors for Tree Plot Areas Intersected by Stand Boundaries</h2><span id='topic+get_correction_factors'></span>

<h3>Description</h3>

<p>Get correction factors for an angle count table (i.e. a
<code><a href="base.html#topic+data.frame">data.frame</a></code>) and a corresponding boundary
table (i.e. a <code><a href="base.html#topic+data.frame">data.frame</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_correction_factors(
  angle_counts,
  boundaries,
  verbose = TRUE,
  stop_on_error = FALSE,
  skip_check = FALSE,
  counting_factor = 4,
  is_ti_round = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_correction_factors_+3A_angle_counts">angle_counts</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing angle counts.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["angle_counts"]]</code> or <br />
<code>getOption("treePlotArea")[["angle_counts"]]</code>.<br />
Could be
<code>bw2bwi2022de(get(data("trees", package = "treePlotArea")))</code>).</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_boundaries">boundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing boundaries.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["boundaries"]]</code> or <br />
<code>getOption("treePlotArea")[["boundaries"]]</code>.<br />
Could be
<code>get(data("boundaries", package = "treePlotArea"))</code> or the
output of
<code><a href="#topic+get_boundary_polygons">get_boundary_polygons</a></code>.</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose?</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>Passed to <code><a href="#topic+get_boundary_polygons">get_boundary_polygons</a></code>.</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_skip_check">skip_check</code></td>
<td>
<p>We usually check if the angle counts are
suitable
(for example whether a diameter at breast height, a horizontal distance and
an azimuth
measurement are given). Skip this check? This might be of interest if you
want to check whether another plot with no dbh recorded (for example a
corner) is intersected by a boundary.</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_counting_factor">counting_factor</code></td>
<td>
<p>The basal area factor used in counting the trees. For
tally trees in the German national forest inventory its value is 4 [m^2].</p>
</td></tr>
<tr><td><code id="get_correction_factors_+3A_is_ti_round">is_ti_round</code></td>
<td>
<p>When checking for the boundary circle of a tree to include
the center of the plot: round that circle's radius to the unit (i.e. [cm])
as done by Thuenen Institute?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns in the names have to be named according to the values of
<code>getOption("treePlotArea")</code>.
If they do not: you can either rename the columns
or set the option accordingly, probably using <code><a href="#topic+set_options">set_options</a></code>.
</p>


<h3>Value</h3>

<p>A  <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the correction factors and a
status giving information on possibly errors.
</p>


<h3>See Also</h3>

<p>set_options
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("trees", "boundaries", package = "treePlotArea")

# For CRAN's sake: draw a subset
tracts &lt;- c(sample(boundaries[["tnr"]], 20), 10056)

# Calculate correction factors
trees &lt;- subset(trees, tnr %in% tracts)
boundaries &lt;- subset(boundaries, tnr %in% tracts)
angle_counts &lt;- bw2bwi2022de(trees)
validate_data(x = boundaries)
validate_data(x = angle_counts)
boundary_polygons &lt;- get_boundary_polygons(boundaries)
correction_factors &lt;- get_correction_factors(angle_counts, boundary_polygons)
summary(correction_factors$status)

#  Select valid angle count trees only
valid_angle_counts &lt;- select_valid_angle_count_trees(angle_counts)
correction_factors &lt;- get_correction_factors(valid_angle_counts,
                                             boundary_polygons)
summary(correction_factors$status)

# Select a single tree
tnr &lt;- 10056
enr &lt;- 4
bnr &lt;- 3
tree &lt;- valid_angle_counts[valid_angle_counts[["tnr"]] == tnr &amp;
                     valid_angle_counts[["enr"]] == enr &amp;
                     valid_angle_counts[["bnr"]] == bnr, TRUE]
bounds &lt;- boundaries[boundaries[["tnr"]] == tnr &amp; boundaries[["enr"]] == enr,
                     TRUE]
get_correction_factors(tree, bounds)

# Deadwood plots:
dead_wood_plots &lt;- unique(trees[TRUE, c("tnr", "enr")])
dead_wood_plots[["bnr"]] &lt;- 0
dead_wood_plots[["hori"]] &lt;- 0
dead_wood_plots[["azi"]] &lt;- 0
dead_wood_plots[["bhd"]] &lt;- 200
get_correction_factors(dead_wood_plots, boundary_polygons,
                       skip_check = TRUE)
# Set the deadwood plot's radius to 500 mm
dead_wood_plots[["bhd"]] &lt;- 5000
# The counting factor has unit square meters per area.
# Area is hardcoded to 10000 [square meters], so to get a plot radius that's
# equal to the dbh, we need 2 * sqrt(counting_factor) / sqrt(10000) to be
# equal to 1.
get_correction_factors(dead_wood_plots, boundary_polygons,
                       skip_check = TRUE,
                       counting_factor = 2500)
</code></pre>

<hr>
<h2 id='get_defaults'>Get Default Options for <span class="pkg">treePlotArea</span></h2><span id='topic+get_defaults'></span>

<h3>Description</h3>

<p>Used to see (not <em>set</em>) the default options set by <span class="pkg">treePlotArea</span>.
Use <code><a href="#topic+set_options">set_options</a></code> to change these default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_defaults()
</code></pre>


<h3>Value</h3>

<p>A named list.
It has the following entries giving the column names of the
angle count or boundary data that hold information on:
</p>

<dl>
<dt>angle_counts</dt><dd> 
<dl>
<dt>tract_id</dt><dd><p>The tract id.</p>
</dd>
<dt>corner_id</dt><dd><p>The corner id.</p>
</dd>
<dt>tree_id</dt><dd><p>The tree id.</p>
</dd>
<dt>distance</dt><dd><p>The distance from the center of the tract's corner.</p>
</dd>
<dt>azimuth</dt><dd><p>The azimuth from North.</p>
</dd>
<dt>dbh</dt><dd><p>The diameter at breast height.</p>
</dd>
</dl>
</dd>
<dt>boundaries</dt><dd> 
<dl>
<dt>tract_id</dt><dd><p>The tract id.</p>
</dd>
<dt>corner_id</dt><dd><p>The corner id.</p>
</dd>
<dt>boundary_type</dt><dd><p>Type of boundary.</p>
</dd>
<dt>boundary_status</dt><dd><p>Validity of the boundary.</p>
</dd>
<dt>distance_start</dt><dd><p>The starting point's distance.</p>
</dd>
<dt>distance_flexing</dt><dd><p>The flexing point's distance.</p>
</dd>
<dt>distance_end</dt><dd><p>The ending point's distance.</p>
</dd>
<dt>azimuth_start</dt><dd><p>The starting point's azimuth.</p>
</dd>
<dt>azimuth_flexing</dt><dd><p>The flexing point's azimuth.</p>
</dd>
<dt>azimuth_end</dt><dd><p>The ending point's azimuth.</p>
</dd>
</dl>
</dd>
</dl>



<h3>See Also</h3>

<p>Other option functions: 
<code><a href="#topic+set_options">set_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_defaults()
</code></pre>

<hr>
<h2 id='get_intersection'>Get Intersection Point of Two Lines</h2><span id='topic+get_intersection'></span>

<h3>Description</h3>

<p>Get the intersection point of two straight lines given in slope–intercept
form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intersection(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_intersection_+3A_x">x</code></td>
<td>
<p>A named vector with intercept [&quot;a&quot;] and slope [&quot;b&quot;].</p>
</td></tr>
<tr><td><code id="get_intersection_+3A_y">y</code></td>
<td>
<p>A named vector with intercept [&quot;a&quot;] and slope [&quot;b&quot;].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector giving the intersection, <code><a href="base.html#topic+NULL">NULL</a></code> if the
lines do not intersect,  <code><a href="base.html#topic+NaN">NaN</a></code> if they are identical.
</p>


<h3>See Also</h3>

<p>Other geometry functions: 
<code><a href="#topic+points2equation">points2equation</a>()</code>,
<code><a href="#topic+vector_length">vector_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_intersection(x = c(a = 0, b = 1), y = c(a = 2, b = -1))
get_intersection(x = c(a = 0, b = 1), y = c(a = 2, b = 1))
x &lt;- c(a = 0, b = 1)
get_intersection(x = x, y = x)
</code></pre>

<hr>
<h2 id='get_r_max'>Get a Theoretical Maximum Distance for a Tree</h2><span id='topic+get_r_max'></span>

<h3>Description</h3>

<p>Maximum distance is of interest as boundaries that are more than double that
distance away are of no interest.
This only a convenience wrapper to <code><a href="#topic+get_boundary_radius">get_boundary_radius</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_r_max(counting_factor = 4, area = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_r_max_+3A_counting_factor">counting_factor</code></td>
<td>
<p>The basal area factor used in counting the trees. For
tally trees in the German national forest inventory its value is 4 [m^2].</p>
</td></tr>
<tr><td><code id="get_r_max_+3A_area">area</code></td>
<td>
<p>The reference surface in [m^2].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A theoretical maximum distance in centimeter. Based on the assumption
that trees have a maximum diameter at breast height of 200 cm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_r_max()
</code></pre>

<hr>
<h2 id='orthogonal'>Get the Slope–intercept Form of an Orthogonal</h2><span id='topic+orthogonal'></span>

<h3>Description</h3>

<p>If slope-point form of an equation is given, we might be interested in the
slope-intercept form of the orthogonal to the equation running through the
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthogonal(b, xy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthogonal_+3A_b">b</code></td>
<td>
<p>The slope.</p>
</td></tr>
<tr><td><code id="orthogonal_+3A_xy">xy</code></td>
<td>
<p>The point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with intercept [&quot;a&quot;] and slope [&quot;b&quot;], as in
<code><a href="graphics.html#topic+abline">graphics::abline</a></code>.
If the slope was 0, there is no slope-intercept form as this is a vertical
line. Then the intercept is <code><a href="base.html#topic+NA">NA</a></code> and the slope gives the value of
x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orthogonal(1, c(x = 0, y = 0))
orthogonal(0, c(x = 4, y = 0))
orthogonal(-1, c(x = -2, y = -2))
orthogonal(Inf, c(x = 0, y = 4))
</code></pre>

<hr>
<h2 id='plot_tree_plot_area'>Plot Tree Plot Area</h2><span id='topic+plot_tree_plot_area'></span>

<h3>Description</h3>

<p>Visualize a corner, its boundaries and tree plot areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_plot_area(
  angle_counts,
  boundaries,
  tnr,
  enr,
  bnr = NULL,
  frame_factor = 1,
  use_sub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_tree_plot_area_+3A_angle_counts">angle_counts</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing angle counts.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["angle_counts"]]</code> or <br />
<code>getOption("treePlotArea")[["angle_counts"]]</code>.<br />
Could be
<code>bw2bwi2022de(get(data("trees", package = "treePlotArea")))</code>).</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_boundaries">boundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing boundaries.
It has to have columns named by the contents of
either<br />
<code><a href="#topic+get_defaults">get_defaults</a>()[["boundaries"]]</code> or <br />
<code>getOption("treePlotArea")[["boundaries"]]</code>.<br />
Could be
<code>get(data("boundaries", package = "treePlotArea"))</code> or the
output of
<code><a href="#topic+get_boundary_polygons">get_boundary_polygons</a></code>.</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_tnr">tnr</code></td>
<td>
<p>Number of the tract.</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_enr">enr</code></td>
<td>
<p>Number of the tract's corner.</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_bnr">bnr</code></td>
<td>
<p>If given, the number of a corner's tree.</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_frame_factor">frame_factor</code></td>
<td>
<p>Plotting from as a factor of the tree plot area. Stick
with the default.</p>
</td></tr>
<tr><td><code id="plot_tree_plot_area_+3A_use_sub">use_sub</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corrections factors for the trees' plot areas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnr &lt;- 166
enr &lt;- 2
bnr &lt;- 7
angle_counts &lt;- bw2bwi2022de(get(data("trees", package = "treePlotArea")))
plot_tree_plot_area(angle_counts = angle_counts,
                    boundaries = get(data("boundaries",
                                          package = "treePlotArea")),
                    tnr =  tnr, enr = enr, bnr = bnr, frame_factor = 4)
plot_tree_plot_area(angle_counts = angle_counts,
                    boundaries = get(data("boundaries",
                                          package = "treePlotArea")),
                    tnr =  tnr, enr = enr, frame_factor = 1)
</code></pre>

<hr>
<h2 id='points2equation'>Get a Slope–intercept Form from a Two-point Form of an Equation</h2><span id='topic+points2equation'></span>

<h3>Description</h3>

<p>Two-point from is often seen in German national forest inventory data,
we want to get an equation of form
<em>y = a + bx</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2equation(p1, p2 = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2equation_+3A_p1">p1</code></td>
<td>
<p>The first point (x, y).</p>
</td></tr>
<tr><td><code id="points2equation_+3A_p2">p2</code></td>
<td>
<p>The second point (x, y).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with intercept [&quot;a&quot;] and slope [&quot;b&quot;].
If both points have the same value for x, no function exists. Then
the intercept is <code><a href="base.html#topic+NA">NA</a></code> and the slope gives the value of x.
</p>


<h3>See Also</h3>

<p>Other geometry functions: 
<code><a href="#topic+get_intersection">get_intersection</a>()</code>,
<code><a href="#topic+vector_length">vector_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points2equation(c(0, 4), c(1, 5))
</code></pre>

<hr>
<h2 id='secant_intersections'>Calculate Intersections of Circle by a Straight Line</h2><span id='topic+secant_intersections'></span>

<h3>Description</h3>

<p>The circle is centered a (0, 0) and has radius r, the line is given in
slope-intercept from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secant_intersections(a, b, r, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secant_intersections_+3A_a">a</code></td>
<td>
<p>The secant's intercept.</p>
</td></tr>
<tr><td><code id="secant_intersections_+3A_b">b</code></td>
<td>
<p>The secant's slope.</p>
</td></tr>
<tr><td><code id="secant_intersections_+3A_r">r</code></td>
<td>
<p>The circle's radius</p>
</td></tr>
<tr><td><code id="secant_intersections_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of x und y values. For a tangent, both rows are identical,
for a straight line missing the circle, a matrix of <code><a href="base.html#topic+NA">NA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>secant_intersections(a = 0, b = 1, r = 2)
# A tangent
secant_intersections(a = 2, b = 0, r = 2, verbose = TRUE)
# Missing the circle
secant_intersections(a = 3, b = 0, r = 2)
# Creating a circle boundary approximation
plot(0, 0, col = "red", pch = "+",
     xlim = c(-2, 2),
     ylim = c(-2, 2))
for (i in seq(-1, 1, by = 0.01)) {
         points(secant_intersections(Inf, i, 1), pch = "+")
}
</code></pre>

<hr>
<h2 id='select_valid_angle_count_trees'>Select Valid Angle Counts Only</h2><span id='topic+select_valid_angle_count_trees'></span>

<h3>Description</h3>

<p>The tree data coming with this package was processed by Gerald Kaendler for
the
country of  Baden-Wuerttemberg, and is the reference for testing as he
adjusted diameter measurements to breast height where they had been measured
in diverging heights (due to deformations of trees at breast height).
Which we really need to do.
But he also
added trees that are not part of the angle count sampling, which this
function removes. We need that mainly to run tests against the reference
values computed by <code>grenzkreis</code> because we would not be able to
easily find the keys to merge the data. <em>So this function is probably of
no use to you.</em>
And we remove trees with a diameter at breast height greater than zero and a
distance of 0, for these tree should not be there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_valid_angle_count_trees(x, sample_type = "stp", tree_status = "pk")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_valid_angle_count_trees_+3A_x">x</code></td>
<td>
<p>A tree data set, typically
<code>get(data(trees, package = "treePlotArea"))</code>.</p>
</td></tr>
<tr><td><code id="select_valid_angle_count_trees_+3A_sample_type">sample_type</code></td>
<td>
<p>An indicator giving the type of sample the tree was
in. 0 marks the angle count sample with counting factor 4.</p>
</td></tr>
<tr><td><code id="select_valid_angle_count_trees_+3A_tree_status">tree_status</code></td>
<td>
<p>An indicator giving the status of a tree in the German
national forest inventory. 0 marks ingrowth, 1 marks ongrowth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree data containing valid angle count trees only.
</p>


<h3>See Also</h3>

<p>Other data functions: 
<code><a href="#topic+bw2bwi2022de">bw2bwi2022de</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- get(data("trees", package = "treePlotArea"))
subset(trees, entf == 0 &amp; bhd2 &gt; 0 &amp; stp == 0)
angle_counts &lt;- select_valid_angle_count_trees(trees)
subset(angle_counts, entf == 0 &amp; bhd2 &gt; 0 &amp; stp == 0)
</code></pre>

<hr>
<h2 id='set_options'>Set Default Options for <span class="pkg">treePlotArea</span></h2><span id='topic+set_options'></span>

<h3>Description</h3>

<p>Just convenience function for <code><a href="base.html#topic+options">options</a></code>.
<span class="pkg">treePlotArea</span> has a set of default options to define the columns of the
<code><a href="base.html#topic+data.frame">data.frame</a>s</code> that are passed to
<code><a href="#topic+get_correction_factors">get_correction_factors</a></code>.
See <code><a href="#topic+get_defaults">get_defaults</a></code> for a description of these options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_options(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_options_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+options">options</a></code>.
Leave empty to initialize the defaults if need be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">Invisibly</a></code>
<code><a href="base.html#topic+TRUE">TRUE</a></code>.
</p>


<h3>See Also</h3>

<p>Other option functions: 
<code><a href="#topic+get_defaults">get_defaults</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the default
set_options()
getOption("treePlotArea")
# Overwrite some
option_list &lt;- list(angle_counts = list(dbh = "diameter"),
                    boundaries = list(boundary_status = "boundart_stat"))
set_options(angle_counts = option_list[["angle_counts"]],
            boundaries = option_list[["boundaries"]])
getOption("treePlotArea")$angle_counts$dbh
# restore default
option_list &lt;- get_defaults()
set_options(angle_counts = option_list[["angle_counts"]],
            boundaries = option_list[["boundaries"]])
getOption("treePlotArea")$angle_counts$dbh
</code></pre>

<hr>
<h2 id='throw'>Throw a Condition</h2><span id='topic+throw'></span>

<h3>Description</h3>

<p>Throws a condition of class c(&quot;error&quot;, &quot;treePlotArea&quot;, &quot;condition&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>throw(message_string, system_call = sys.call(-1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="throw_+3A_message_string">message_string</code></td>
<td>
<p>The message to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_system_call">system_call</code></td>
<td>
<p>The call to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="base.html#topic+structure">base::structure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use this condition as an error dedicated to <span class="pkg">treePlotArea</span>.
</p>


<h3>Value</h3>

<p>The function does never return anything, it stops with a
condition of class c(&quot;error&quot;, &quot;treePlotArea&quot;, &quot;condition&quot;).
</p>

<hr>
<h2 id='trees'>Angle Count Sampling of the German National Inventory 2022</h2><span id='topic+trees'></span>

<h3>Description</h3>

<p>This is an extract form a data set prepared by Gerald Kaendler.
He
</p>

<ol>
<li><p> added trees that are not part of the angle count sampling,
</p>
</li>
<li><p> converted the diameter at breast height from millimeter to
centimeter and renamed it,
</p>
</li>
<li><p> converted horizontal distance from centimeter to meter and renamed
it,
</p>
</li>
<li><p> computed correction factors using <code>grenzkreis</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>data("trees", package = "treePlotArea")
</code></pre>


<h3>Format</h3>

<p>A data frame with 1121 observations on the following 9 variables.
Variables not needed with the package are marked with an asterisk.
</p>

<dl>
<dt><code>tnr</code></dt><dd><p>The tract id.</p>
</dd>
<dt><code>enr</code></dt><dd><p>The corner id. A tract may have up to 4 corners on
wooden floor.</p>
</dd>
<dt><code>bnr</code></dt><dd><p>The tree id.</p>
</dd>
<dt><code>bhd2</code></dt><dd><p>The diameter at breast height, given in centimeter</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>kf2</code></dt><dd><p>* The correction factor given by <code>grenzkreis</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>entf</code></dt><dd><p>The trees' distance from the center of the tract's
corner, given in meter.</p>
</dd>
<dt><code>azi</code></dt><dd><p>The azimuth from North, measured in gon (or gradian).</p>
</dd>
<dt><code>pk</code></dt><dd><p>* An indicator giving the type of a tree in the German
national forest inventory. 0 marks ingrowth, 1 marks ongrowth.</p>
</dd>
<dt><code>stp</code></dt><dd><p>* An indicator giving the type of sample the tree was
in. 0 marks the angle count sample with counting factor 4.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>trees &lt;- get(data("trees", package = "treePlotArea"))
summary(trees)
angle_counts &lt;- bw2bwi2022de(trees)
summary(angle_counts)
</code></pre>

<hr>
<h2 id='validate_data'>Validate Data and Optionally Delete Missing Data</h2><span id='topic+validate_data'></span>

<h3>Description</h3>

<p>The 2012 data of the federal database contains tract 18063, corner 2.
There are boundaries recorded for that corner, nevertheless tree 14 has no
azimuth measurement. This function therefore checks for the data sets not
having missing
data in the columns needed by <code><a href="#topic+get_correction_factors">get_correction_factors</a></code> and
optionally removes affected observations.
It does not cross check whether missing data is really needed (azimuth is
not when there is no boundary recorded for that tracts corner).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data(x, type = c(NA, "angle_counts", "boundaries"), clean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_data_+3A_x">x</code></td>
<td>
<p>A tree or angle count data set.</p>
</td></tr>
<tr><td><code id="validate_data_+3A_type">type</code></td>
<td>
<p>The type of data, stick with the default to let us guess.</p>
</td></tr>
<tr><td><code id="validate_data_+3A_clean">clean</code></td>
<td>
<p>Omit missing data? If the input contains missing data in the
columns needed by <code><a href="#topic+get_correction_factors">get_correction_factors</a></code>, the affected
observations
may be deleted. Otherwise an error is thrown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree data set. The input, if that was valid data, the cleaned
input otherwise. Throws an error if columns are missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boundaries &lt;- get(data("boundaries", package = "treePlotArea"))
nrow(boundaries)
nrow(validate_data(x = boundaries))
boundaries[1, "enr"] &lt;- NA
try(validate_data(boundaries))
nrow(validate_data(boundaries, clean = TRUE))
</code></pre>

<hr>
<h2 id='vector_length'>Give the Length of a Vector</h2><span id='topic+vector_length'></span>

<h3>Description</h3>

<p>A vector given by two points in a plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_length(p1, p2 = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_length_+3A_p1">p1</code></td>
<td>
<p>The first point (x, y).</p>
</td></tr>
<tr><td><code id="vector_length_+3A_p2">p2</code></td>
<td>
<p>The second point (x, y).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the vector.
</p>


<h3>See Also</h3>

<p>Other geometry functions: 
<code><a href="#topic+get_intersection">get_intersection</a>()</code>,
<code><a href="#topic+points2equation">points2equation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- c(0, 4)
vector_length(p1)
p2 &lt;- c(3, 4)
vector_length(p1, p2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
