<!DOCTYPE html><html><head><title>Help for package SpatialGEV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialGEV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatialGEV-package'><p>SpatialGEV: Fit Spatial Generalized Extreme Value Models</p></a></li>
<li><a href='#grid_location'><p>Grid the locations with fixed cell size</p></a></li>
<li><a href='#kernel_exp'><p>Exponential covariance function</p></a></li>
<li><a href='#kernel_matern'><p>Matern covariance function</p></a></li>
<li><a href='#matern_pc_prior'><p>Helper funcion to specify a Penalized Complexity (PC) prior on the Matern hyperparameters</p></a></li>
<li><a href='#ONsnow'><p>Monthly total snowfall in Ontario, Canada from 1987 to 2021.</p></a></li>
<li><a href='#print.spatialGEVfit'><p>Print method for spatialGEVfit</p></a></li>
<li><a href='#print.spatialGEVpred'><p>Print method for spatialGEVpred</p></a></li>
<li><a href='#print.spatialGEVsam'><p>Print method for spatialGEVsam</p></a></li>
<li><a href='#r_nll'><p>Calculate the negative marginal loglikelihood of the GEV-GP  model.</p></a></li>
<li><a href='#sim_cond_normal'><p>Create a helper function to simulate from the conditional normal distribution of new data given old data</p></a></li>
<li><a href='#simulatedData'><p>Simulated dataset 1</p></a></li>
<li><a href='#simulatedData2'><p>Simulated dataset 2</p></a></li>
<li><a href='#spatialGEV_fit'><p>Fit a GEV-GP model.</p></a></li>
<li><a href='#spatialGEV_predict'><p>Draw from the posterior predictive distributions at new locations based on a fitted GEV-GP model</p></a></li>
<li><a href='#spatialGEV_sample'><p>Get posterior parameter draws from a fitted GEV-GP model.</p></a></li>
<li><a href='#summary.spatialGEVpred'><p>Summary method for spatialGEVpred</p></a></li>
<li><a href='#summary.spatialGEVsam'><p>Summary method for spatialGEVsam</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fit Spatial Generalized Extreme Value Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Meixi Chen &lt;meixi.chen@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit latent variable models with the GEV distribution as the data likelihood and the GEV parameters following latent Gaussian processes. The models in this package are built using the template model builder 'TMB' in R, which has the fast ability to integrate out the latent variables using Laplace approximation. This package allows the users to choose in the fit function which GEV parameter(s) is considered as a spatially varying random effect following a Gaussian process, so the users can fit spatial GEV models with different complexities to their dataset without having to write the models in 'TMB' by themselves. This package also offers methods to sample from both fixed and random effects posteriors as well as the posterior predictive distributions at different spatial locations. Methods for fitting this class of models are described in Chen, Ramezan, and Lysy (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2110.07051">doi:10.48550/arXiv.2110.07051</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB (&ge; 1.7.16), mvtnorm, evd, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>INLA, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-31 22:46:27 UTC; meixichen</td>
</tr>
<tr>
<td>Author:</td>
<td>Meixi Chen [aut, cre],
  Martin Lysy [aut],
  Reza Ramezan [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-05 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatialGEV-package'>SpatialGEV: Fit Spatial Generalized Extreme Value Models</h2><span id='topic+SpatialGEV'></span><span id='topic+SpatialGEV-package'></span>

<h3>Description</h3>

<p>Fit latent variable models with the GEV distribution as the data likelihood and the GEV parameters following latent Gaussian processes. The models in this package are built using the template model builder 'TMB' in R, which has the fast ability to integrate out the latent variables using Laplace approximation. This package allows the users to choose in the fit function which GEV parameter(s) is considered as a spatially varying random effect following a Gaussian process, so the users can fit spatial GEV models with different complexities to their dataset without having to write the models in 'TMB' by themselves. This package also offers methods to sample from both fixed and random effects posteriors as well as the posterior predictive distributions at different spatial locations. Methods for fitting this class of models are described in Chen, Ramezan, and Lysy (2021) &lt;arXiv:https://arxiv.org/abs/2110.07051&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Meixi Chen <a href="mailto:meixi.chen@uwaterloo.ca">meixi.chen@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Martin Lysy <a href="mailto:mlysy@uwaterloo.ca">mlysy@uwaterloo.ca</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Reza Ramezan <a href="mailto:rramezan@uwaterloo.ca">rramezan@uwaterloo.ca</a> [contributor]
</p>
</li></ul>


<hr>
<h2 id='grid_location'>Grid the locations with fixed cell size</h2><span id='topic+grid_location'></span>

<h3>Description</h3>

<p>Grid the locations with fixed cell size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_location(
  lon,
  lat,
  sp.resolution = 2,
  lon.range = range(lon),
  lat.range = range(lat)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_location_+3A_lon">lon</code></td>
<td>
<p>Numeric, <code>n</code> longitude values</p>
</td></tr>
<tr><td><code id="grid_location_+3A_lat">lat</code></td>
<td>
<p>Numeric, <code>n</code> latitude values</p>
</td></tr>
<tr><td><code id="grid_location_+3A_sp.resolution">sp.resolution</code></td>
<td>
<p>Numeric, must be a single value that indicates the minimal unit length of
a grid cell.</p>
</td></tr>
<tr><td><code id="grid_location_+3A_lon.range">lon.range</code></td>
<td>
<p>Optional vector that indicates the range of <code>lon</code>. Default is <code>range(lon)</code>.</p>
</td></tr>
<tr><td><code id="grid_location_+3A_lat.range">lat.range</code></td>
<td>
<p>Optional vector that indicates the range of <code>lat</code>. Default is <code>range(lat)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The longitude and latitude of each grid cell are the coordinate of the cell center.
For example, if <code>sp.resolution=1</code>, then <code>cell_lon=55.5</code> and <code>cell_lat=22.5</code> correspond to the
square whose left boundary is 55, right boundary is 56, upper boundary is 23, and lower boundary
is 22.
</p>


<h3>Value</h3>

<p>An <code style="white-space: pre;">&#8288;n x 3&#8288;</code> data frame containing three variables: <code>cell_ind</code> corresponds to unique id
for each grid cell,
<code>cell_lon</code> is the longitude of the grid cell, <code>cell_lat</code> is the latitude of the grid cell.
Since the output data frame retains the order of the input coordinates, the original coordinate
dataset and the output have can be linked one-to-one by the row index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longitude &lt;- runif(20, -90, 80)
latitude &lt;- runif(20, 40, 60)
grid_locs &lt;- grid_location(longitude, latitude, sp.resolution=0.5)
cbind(longitude, latitude, grid_locs)
</code></pre>

<hr>
<h2 id='kernel_exp'>Exponential covariance function</h2><span id='topic+kernel_exp'></span>

<h3>Description</h3>

<p>Exponential covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_exp(x, sigma, ell, X1 = NULL, X2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_exp_+3A_x">x</code></td>
<td>
<p>Distance measure.</p>
</td></tr>
<tr><td><code id="kernel_exp_+3A_sigma">sigma</code></td>
<td>
<p>The amplitude parameter (scalar) with the constraint of <code>sigma &gt; 0</code></p>
</td></tr>
<tr><td><code id="kernel_exp_+3A_ell">ell</code></td>
<td>
<p>The smoothness parameter (scalar) with the constraint of <code>ell &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="kernel_exp_+3A_x1">X1</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n1 x 2&#8288;</code> matrix containing the coordinates of location set 1.
If <code>x</code> is not provided, <code>X1</code> and <code>X2</code> should be provided for calculating their distance.</p>
</td></tr>
<tr><td><code id="kernel_exp_+3A_x2">X2</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n2 x 2&#8288;</code> coordinate matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let x = dist(x_i, x_j).</p>
<pre>cov(i,j) = sigma*exp(-x/ell)
</pre>


<h3>Value</h3>

<p>A matrix or a scalar of exponential covariance depending on the type of <code>x</code> or
whether <code>X1</code> and <code>X2</code> are used instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- cbind(runif(10, 1, 10), runif(10, 10, 20))
X2 &lt;- cbind(runif(5, 1, 10), runif(5, 10, 20))

kernel_exp(sigma=2, ell=1, X1=X1, X2=X2)

kernel_exp(as.matrix(stats::dist(X1)), sigma=2, ell=1)
</code></pre>

<hr>
<h2 id='kernel_matern'>Matern covariance function</h2><span id='topic+kernel_matern'></span>

<h3>Description</h3>

<p>Matern covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_matern(x, sigma, kappa, nu = 1, X1 = NULL, X2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_matern_+3A_x">x</code></td>
<td>
<p>Distance measure.</p>
</td></tr>
<tr><td><code id="kernel_matern_+3A_sigma">sigma</code></td>
<td>
<p>Positive parameter. (This is in fact sigma^2)</p>
</td></tr>
<tr><td><code id="kernel_matern_+3A_kappa">kappa</code></td>
<td>
<p>Positive parameter.</p>
</td></tr>
<tr><td><code id="kernel_matern_+3A_nu">nu</code></td>
<td>
<p>Range parameter default to 1.</p>
</td></tr>
<tr><td><code id="kernel_matern_+3A_x1">X1</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n1 x 2&#8288;</code> matrix containing the coordinates of location set 1.
If <code>x</code> is not provided, <code>X1</code> and <code>X2</code> should be provided for calculating their distance.</p>
</td></tr>
<tr><td><code id="kernel_matern_+3A_x2">X2</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n2 x 2&#8288;</code> coordinate matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let x = dist(x_i, x_j).</p>
<pre>cov(i,j) = sigma * 2^(1-nu)/gamma(nu) * (kappa*x)^nu * K_v(kappa*x)
</pre>
<p>Note that when <code>nu=0.5</code>, the Matern kernel corresponds to the absolute exponential kernel.
</p>


<h3>Value</h3>

<p>A matrix or a scalar of Matern covariance depending on the type of <code>x</code> or
whether <code>X1</code> and <code>X2</code> are used instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- cbind(runif(10, 1, 10), runif(10, 10, 20))
X2 &lt;- cbind(runif(5, 1, 10), runif(5, 10, 20))

kernel_matern(sigma=2, kappa=1, X1=X1, X2=X2)

kernel_matern(as.matrix(stats::dist(X1)), sigma=2, kappa=1)
</code></pre>

<hr>
<h2 id='matern_pc_prior'>Helper funcion to specify a Penalized Complexity (PC) prior on the Matern hyperparameters</h2><span id='topic+matern_pc_prior'></span>

<h3>Description</h3>

<p>Helper funcion to specify a Penalized Complexity (PC) prior on the Matern hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_pc_prior(rho_0, p_rho, sig_0, p_sig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_pc_prior_+3A_rho_0">rho_0</code></td>
<td>
<p>Hyperparameter for PC prior on the range parameter. Must be positive.
See details.</p>
</td></tr>
<tr><td><code id="matern_pc_prior_+3A_p_rho">p_rho</code></td>
<td>
<p>Hyperparameter for PC prior on the range parameter. Must be between 0
and 1. See details.</p>
</td></tr>
<tr><td><code id="matern_pc_prior_+3A_sig_0">sig_0</code></td>
<td>
<p>Hyperparameter for PC prior on the range parameter. Must be positive.
See details.</p>
</td></tr>
<tr><td><code id="matern_pc_prior_+3A_p_sig">p_sig</code></td>
<td>
<p>Hyperparameter for PC prior on the range parameter. Must be between 0
and 1. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The joint prior on <code>rho</code> and <code>sig</code> achieves</p>
<pre>P(rho &lt; rho_0) = p_rho,
</pre>
<p>and</p>
<pre>P(sig &gt; sig_0) = p_sig,
</pre>
<p>where <code>rho = sqrt(8*nu)/kappa</code> and <code>sig = sqrt(sigma)</code>.
</p>


<h3>Value</h3>

<p>A list to provide to the <code>matern_pc_prior</code> argument of <code>spatialGEV_fit</code>.
</p>


<h3>References</h3>

<p>Simpson, D., Rue, H., Riebler, A., Martins, T. G., &amp; Sørbye, S. H. (2017).
Penalising model component complexity: A principled, practical approach to
construct priors. Statistical Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- simulatedData2$y
locs &lt;- simulatedData2$locs
n_loc &lt;- nrow(locs) 
fit &lt;- spatialGEV_fit(y = y, locs = locs, random = "abs",
                      init_param = list(a = rep(0, n_loc),
                                        log_b = rep(0, n_loc), 
                                        s = rep(-2, n_loc),
                                        beta_a = 0,
                                        beta_b = 0,
                                        beta_s = -2,
                                        log_sigma_a = 0, 
                                        log_kappa_a = 0,
                                        log_sigma_b = 0, 
                                        log_kappa_b = 0,
                                        log_sigma_s = 0, 
                                        log_kappa_s = 0
                                        ),
                       reparam_s = "positive",
                       kernel = "matern",
                       beta_prior = list(beta_a=c(0,100), beta_b=c(0,10),
                                         beta_s=c(0,10)),
                       matern_pc_prior = list(
                                              matern_a=matern_pc_prior(1e5,0.95,5,0.1),
                                              matern_b=matern_pc_prior(1e5,0.95,3,0.1),
                                              matern_s=matern_pc_prior(1e2,0.95,1,0.1)
                                              ))

</code></pre>

<hr>
<h2 id='ONsnow'>Monthly total snowfall in Ontario, Canada from 1987 to 2021.</h2><span id='topic+ONsnow'></span>

<h3>Description</h3>

<p>A dataset containing the monthly total snowfall (in cm) in Ontario, Canada from 1987 to 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ONsnow
</code></pre>


<h3>Format</h3>

<p>A data frame with 63945 rows and 7 variables with each row corresponding to a monthly
record at a weather location:
</p>

<dl>
<dt>LATITUDE</dt><dd><p>Numeric. Latitude of the weather station</p>
</dd>
<dt>LONGITUDE</dt><dd><p>Numeric. Longitude of the weather station</p>
</dd>
<dt>STATION_NAME</dt><dd><p>Character. Name of the weather station</p>
</dd>
<dt>CLIMATE_IDENTIFIER</dt><dd><p>Character. Unique id of each station</p>
</dd>
<dt>LOCAL_YEAR</dt><dd><p>Integer from 1987 to 2021. Year of the record</p>
</dd>
<dt>LOCAL_MONTH</dt><dd><p>Integer from 1 to 12. Month of the record</p>
</dd>
<dt>TOTAL_SNOWFALL</dt><dd><p>Positive number. Total monthly snowfall at a station in cm</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://climate-change.canada.ca/climate-data/#/monthly-climate-summaries">https://climate-change.canada.ca/climate-data/#/monthly-climate-summaries</a>
</p>

<hr>
<h2 id='print.spatialGEVfit'>Print method for spatialGEVfit</h2><span id='topic+print.spatialGEVfit'></span>

<h3>Description</h3>

<p>Print method for spatialGEVfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialGEVfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spatialGEVfit_+3A_x">x</code></td>
<td>
<p>Model object of class <code>spatialGEVfit</code> returned by <code>spatialGEV_fit</code>.</p>
</td></tr>
<tr><td><code id="print.spatialGEVfit_+3A_...">...</code></td>
<td>
<p>More arguments for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the fitted model containing number of fixed/random effects,
fitting time, convergence information, etc.
</p>

<hr>
<h2 id='print.spatialGEVpred'>Print method for spatialGEVpred</h2><span id='topic+print.spatialGEVpred'></span>

<h3>Description</h3>

<p>Print method for spatialGEVpred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialGEVpred'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spatialGEVpred_+3A_x">x</code></td>
<td>
<p>Object of class <code>spatialGEVpred</code> returned by <code>spatialGEV_predict</code>.</p>
</td></tr>
<tr><td><code id="print.spatialGEVpred_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the prediction.
</p>

<hr>
<h2 id='print.spatialGEVsam'>Print method for spatialGEVsam</h2><span id='topic+print.spatialGEVsam'></span>

<h3>Description</h3>

<p>Print method for spatialGEVsam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialGEVsam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spatialGEVsam_+3A_x">x</code></td>
<td>
<p>Object of class <code>spatialGEVsam</code> returned by <code>spatialGEV_sample</code>.</p>
</td></tr>
<tr><td><code id="print.spatialGEVsam_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the object including dimension and direction to use <code>summary</code> on the object.
</p>

<hr>
<h2 id='r_nll'>Calculate the negative marginal loglikelihood of the GEV-GP  model.</h2><span id='topic+r_nll'></span>

<h3>Description</h3>

<p>Calculate the negative marginal loglikelihood of the GEV-GP  model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_nll(
  y,
  dd,
  a,
  log_b,
  s,
  hyperparam_a,
  hyperparam_b,
  hyperparam_s,
  kernel = "exp",
  beta_a = NULL,
  beta_b = NULL,
  beta_s = NULL,
  X_a = NULL,
  X_b = NULL,
  X_s = NULL,
  f_s = function(x) {     x },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_nll_+3A_y">y</code></td>
<td>
<p>List of <code>n</code> locations each with <code>n_obs[i]</code> independent GEV realizations.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_dd">dd</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;n x n&#8288;</code> distance matrix.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_a">a</code></td>
<td>
<p>Vector of <code>n</code> location paramter</p>
</td></tr>
<tr><td><code id="r_nll_+3A_log_b">log_b</code></td>
<td>
<p>A numeric value or a vector of <code>n</code> log-transformed scale parameters if considered
as a random effect.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_s">s</code></td>
<td>
<p>A numeric value or a vector of <code>n</code> shape parameters</p>
</td></tr>
<tr><td><code id="r_nll_+3A_hyperparam_a">hyperparam_a</code></td>
<td>
<p>A vector of hyperparameters for a. See details.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_hyperparam_b">hyperparam_b</code></td>
<td>
<p>A vector of hyperparameters for b. Must be provided if <code>log_b</code> is a vector.
See details.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_hyperparam_s">hyperparam_s</code></td>
<td>
<p>A vector of hyperparameters for f(s), where f() is a transformation function
for s specifided using the <code>f_s</code> argument. Must be provided if <code>s</code> is a vector.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_kernel">kernel</code></td>
<td>
<p>&quot;exp&quot; or &quot;matern&quot;. Kernel function used to compute the covariance matrix for
spatial random effects. Default is &quot;exp&quot;.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_beta_a">beta_a</code></td>
<td>
<p>Numeric. Coefficients for mean of GP(a).</p>
</td></tr>
<tr><td><code id="r_nll_+3A_beta_b">beta_b</code></td>
<td>
<p>Numeric. Coefficients for mean of GP(log_b).</p>
</td></tr>
<tr><td><code id="r_nll_+3A_beta_s">beta_s</code></td>
<td>
<p>Numeric. Coefficients for mean of GP(s).</p>
</td></tr>
<tr><td><code id="r_nll_+3A_x_a">X_a</code></td>
<td>
<p>Design matrix for a. If not provided, this will a <code style="white-space: pre;">&#8288;n_loc x 1&#8288;</code> column matrix of 1s.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_x_b">X_b</code></td>
<td>
<p>Design matrix for log(b). If not provided and logb is a random effect,
this will a <code style="white-space: pre;">&#8288;n_loc x 1&#8288;</code> column matrix of 1s.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_x_s">X_s</code></td>
<td>
<p>Design matrix for s. If not provided, this will a <code style="white-space: pre;">&#8288;n_loc x 1&#8288;</code> column matrix of 1s.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_f_s">f_s</code></td>
<td>
<p>A function f() used to transform s such that
f(s) ~ GP(X_s*beta_s, Sigma(hyperparam_s)). Default is identitfy function: <code>function(x){x}</code>.</p>
</td></tr>
<tr><td><code id="r_nll_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the kernel function, e.g. <code>nu</code> for the matern.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to test if TMB and R output the same negative loglikelihood.
If <code style="white-space: pre;">&#8288;kernel="exp&#8288;</code>, <code>hyperparam_a/b/s</code> should be <code>c(sigma_a/b/s, ell_a/b/s)</code>, where <code>sigma</code> is the
amplitude hyperparameter and <code>ell</code> is the smoothness hyperparameter for the exponential kernel.
If <code style="white-space: pre;">&#8288;kernel="matern&#8288;</code>, <code>hyperparam_a/b/s</code> should be <code>c(sigma_a/b, kappa_a/b/s)</code>, where <code>sigma</code> and
<code>kappa</code> are hyperparameters for the Matern kernel.
If only <code>a</code> is a spatial random effect and <code>b</code> is fixed, only <code>hyperparam_a</code> needs to be
provided.
</p>
<p>This function is used as the ground truth for testing hpp model likelihood.
</p>


<h3>Value</h3>

<p>Scalar value of the negative marginal loglikelihood:</p>
<pre>-logL(Data; spatial_random_effects, fixed_hyperparameters)
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(SpatialGEV)
a &lt;- simulatedData$a
logb &lt;- simulatedData$logb
logs &lt;- simulatedData$logs
s &lt;- exp(logs)
y &lt;- simulatedData$y
locs &lt;- simulatedData$locs
dd &lt;- as.matrix(stats::dist(locs))
log_sigma_a &lt;- -1; log_ell_a &lt;- 5
log_sigma_b &lt;- -2; log_ell_b &lt;- 10
beta_a &lt;- mean(a); beta_b &lt;- mean(logb)
# Negative marginal log-likelihood produced in R using the exponential kernel
nll_r &lt;- r_nll(y, dd, a=a, log_b=logb, s=s,
               hyperparam_a=c(exp(log_sigma_a), exp(log_ell_a)),
               hyperparam_b=c(exp(log_sigma_b), exp(log_ell_b)),
               kernel="exp", beta_a=beta_a, beta_b=beta_b)
# Negative marg loglik produced by TMB template
init_param &lt;- list(beta_a=beta_a, beta_b=beta_b,
                   a=a, log_b=logb, s=log(s), 
                   log_sigma_a=log_sigma_a, 
                   log_ell_a=log_ell_a,
                   log_sigma_b=log_sigma_b, 
                   log_ell_b=log_ell_b)
adfun &lt;- spatialGEV_fit(y, locs, random="ab",
                        init_param=init_param,
                        reparam_s="positive",
                        kernel="exp",
                        adfun_only=TRUE,
                        ignore_random=TRUE,
                        silent=TRUE)
nll_tmb &lt;- adfun$fn(unlist(init_param))
nll_r - nll_tmb
</code></pre>

<hr>
<h2 id='sim_cond_normal'>Create a helper function to simulate from the conditional normal distribution of new data given old data</h2><span id='topic+sim_cond_normal'></span>

<h3>Description</h3>

<p>Create a helper function to simulate from the conditional normal distribution of new data given old data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_cond_normal(joint.mean, a, locs_new, locs_obs, kernel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_cond_normal_+3A_joint.mean">joint.mean</code></td>
<td>
<p>The length <code>n</code> mean vector of the MVN distribution. By default mu1 is the first <code>m</code> elements of <code>joint.mean</code></p>
</td></tr>
<tr><td><code id="sim_cond_normal_+3A_a">a</code></td>
<td>
<p>A vector of length <code>n-m</code>, the values of mu2 to condition on</p>
</td></tr>
<tr><td><code id="sim_cond_normal_+3A_locs_new">locs_new</code></td>
<td>
<p>A matrix containing the coordiantes of new locations</p>
</td></tr>
<tr><td><code id="sim_cond_normal_+3A_locs_obs">locs_obs</code></td>
<td>
<p>A matrix containing the coordinates of observed locations</p>
</td></tr>
<tr><td><code id="sim_cond_normal_+3A_kernel">kernel</code></td>
<td>
<p>A function (kernel function) that returns a matrix containing the similarity between the two arguments.</p>
</td></tr>
<tr><td><code id="sim_cond_normal_+3A_...">...</code></td>
<td>
<p>Hyperparameters to pass to the kernel function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This serves as a helper function for <code>spatialGEV_predict</code>. The notations are consistent to the notations on the MVN wikipedia page
</p>


<h3>Value</h3>

<p>A function that takes in one argument <code>n</code> as the number of samples to draw from the condition normal distribution
of <code>locs_new</code> given <code>locs_obs</code>: either from <code>rmvnorm</code> for MVN or <code>rnorm</code> for univariate normal. The old and new data are assumed to follow a joint multivariate normal distribution.
</p>

<hr>
<h2 id='simulatedData'>Simulated dataset 1</h2><span id='topic+simulatedData'></span>

<h3>Description</h3>

<p>A list of data used for package testing and demos. Both <code>a</code> and <code>logb</code> are simulated on smooth
deterministic surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatedData
</code></pre>


<h3>Format</h3>

<p>A list containing the simulation parameters and simulated data on a 20x20 grid:
</p>

<dl>
<dt>locs</dt><dd><p>A 400x2 matrix. First column contains longitudes and second contains latitudes</p>
</dd>
<dt>a</dt><dd><p>A length 400 vector. GEV location parameters</p>
</dd>
<dt>logb</dt><dd><p>A length 400 vector. Log-transformed GEV scale parameters</p>
</dd>
<dt>logs</dt><dd><p>A scalar. Log-transformed GEV shape parameter shared across space</p>
</dd>
<dt>y</dt><dd><p>A length 400 list of vectors which are observations simulated at each location</p>
</dd>
</dl>


<hr>
<h2 id='simulatedData2'>Simulated dataset 2</h2><span id='topic+simulatedData2'></span>

<h3>Description</h3>

<p>A list of data used for package testing and demos. <code>a</code>, <code>logb</code>, <code>logs</code> are simulated from
respective Gaussian random fields and thus are nonsmooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatedData2
</code></pre>


<h3>Format</h3>

<p>A list containing the simulation parameters and simulated data on a 20x20 grid:
</p>

<dl>
<dt>locs</dt><dd><p>A 400x2 matrix. First column contains longitudes and second contains latitudes</p>
</dd>
<dt>a</dt><dd><p>A length 400 vector. GEV location parameters</p>
</dd>
<dt>logb</dt><dd><p>A length 400 vector. Log-transformed GEV scale parameters</p>
</dd>
<dt>logs</dt><dd><p>A length 400 vector. Log-transformed GEV shape parameters</p>
</dd>
<dt>y</dt><dd><p>A length 400 list of vectors which are observations simulated at each location</p>
</dd>
</dl>


<hr>
<h2 id='spatialGEV_fit'>Fit a GEV-GP model.</h2><span id='topic+spatialGEV_fit'></span>

<h3>Description</h3>

<p>Fit a GEV-GP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGEV_fit(
  y,
  locs,
  random,
  init_param,
  reparam_s,
  kernel = "exp",
  X_a = NULL,
  X_b = NULL,
  X_s = NULL,
  nu = 1,
  s_prior = NULL,
  beta_prior = NULL,
  matern_pc_prior = NULL,
  sp_thres = -1,
  adfun_only = FALSE,
  ignore_random = FALSE,
  silent = FALSE,
  mesh_extra_init = list(a = 0, log_b = -1, s = 0.001),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialGEV_fit_+3A_y">y</code></td>
<td>
<p>List of <code>n</code> locations each with <code>n_obs[i]</code> independent GEV realizations.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_locs">locs</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x 2&#8288;</code> matrix of longitude and latitude of the corresponding response values.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_random">random</code></td>
<td>
<p>Either &quot;a&quot;, &quot;ab&quot;, or &quot;abs&quot;, where <code>a</code> indicates the location parameter,
<code>b</code> indicates the scale parameter, <code>s</code> indicates the shape parameter.  This tells the model
which GEV parameters are considered as random effects.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_init_param">init_param</code></td>
<td>
<p>A list of initial parameters. See details.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_reparam_s">reparam_s</code></td>
<td>
<p>A flag indicating whether the shape parameter is &quot;zero&quot;, &quot;unconstrained&quot;,
constrained to be &quot;negative&quot;, or constrained to be &quot;positive&quot;. If model &quot;abs&quot; is used,
<code>reparam_s</code> cannot be zero. See details.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function for spatial random effects covariance matrix. Can be &quot;exp&quot;
(exponential kernel), &quot;matern&quot; (Matern kernel), or &quot;spde&quot; (Matern kernel with SPDE
approximation described in Lindgren el al. 2011). To use the SPDE approximation,
the user must first install the INLA R package.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_x_a">X_a</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x r&#8288;</code> design matrix for a, where <code>r-1</code> is the number of covariates. If not
provided, a <code style="white-space: pre;">&#8288;n x 1&#8288;</code> column matrix of 1s is used.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_x_b">X_b</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x r&#8288;</code> design matrix for log(b). Does not need to be provided if b is fixed.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_x_s">X_s</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n x r&#8288;</code> design matrix for g(s), where g() is a transformation function of <code>s</code>.
Does not need to be provided if s is fixed.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_nu">nu</code></td>
<td>
<p>Hyperparameter of the Matern kernel. Default is 1.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_s_prior">s_prior</code></td>
<td>
<p>Optional. A length 2 vector where the first element is the mean of the normal
prior on s or log(s) and the second is the standard deviation. Default is NULL, meaning a
uniform prior is put on s if s is fixed, or a GP prior is applied if s is a random effect.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_beta_prior">beta_prior</code></td>
<td>
<p>Optional named list that specifies normal priors on the GP mean function
coefficients <code>beta</code>s. Each element of the list should be a named length 2 vector in which
the first element is mean and second element is sd.
E.g. <code>beta_prior=list(beta_a=c(0,100), beta_b=c(0,10), beta_s=c(-2,5))</code>.
Default is NULL, which means imposing a noninformative uniform flat prior.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_matern_pc_prior">matern_pc_prior</code></td>
<td>
<p>Optional named list that specifies Penalized complexity
priors on the GP Matern covariance hyperparameters <code>sig</code> and <code>rho</code>, where <code>sig = sqrt(sigma)</code> and <code>rho = sqrt(8*nu)/kappa</code>. Names must be <code>matern_a</code>, <code>matern_b</code>,
or <code>matern_s</code>.
E.g. <code>matern_pc_prior=list(matern_s=matern_pc_prior(100, 0.9, 2, 0.1))</code>.
Default is NULL, which means a flat prior. See <code>?matern_pc_prior</code> for more details.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_sp_thres">sp_thres</code></td>
<td>
<p>Optional. Thresholding value to create sparse covariance matrix. Any distance
value greater than or equal to <code>sp_thres</code> will be set to 0. Default is -1, which means not
using sparse matrix. Caution: hard thresholding the covariance matrix often results in bad
convergence.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_adfun_only">adfun_only</code></td>
<td>
<p>Only output the ADfun constructed using TMB? If TRUE, model fitting is not
performed and only a TMB tamplate <code>adfun</code> is returned (along with the created mesh if kernel is
&quot;spde&quot;).
This can be used when the user would like to use a different optimizer other than the default
<code>nlminb</code>. E.g., call <code>optim(adfun$par, adfun$fn, adfun$gr)</code> for optimization.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_ignore_random">ignore_random</code></td>
<td>
<p>Ignore random effect? If TRUE, spatial random effects are not integrated
out in the model. This can be helpful for checking the marginal likelihood.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_silent">silent</code></td>
<td>
<p>Do not show tracing information?</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_mesh_extra_init">mesh_extra_init</code></td>
<td>
<p>A named list of scalars. Used when the SPDE kernel is used. The list
provides the initial values for a, log(b), and s on the extra triangles created in the mesh.
The default is <code>list(a=1, log_b=0, s=0.001)</code>.</p>
</td></tr>
<tr><td><code id="spatialGEV_fit_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>INLA::inla.mesh.2d()</code>. See details <code>?inla.mesh.2d()</code> and
Section 2.1 of Lindgren &amp; Rue (2015) JSS paper.
This is used specifically for when <code>kernel="spde"</code>, in which case a mesh needs to be
constructed on the spatial domain. When no arguments are passed to <code>inla.mesh.2d()</code>, a
default argument is <code>max.edge=2</code>, which simply specifies the largest allowed triangle edge
length. It is strongly suggested that the user should specify these arguments if they would
like to use the SPDE kernel. Please make sure INLA package is installed before
using the SPDE approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adopts Laplace approximation using TMB model to integrate out the random effects.
</p>
<p>The random effects are assumed to follow Gaussian processes with mean 0 and covariance matrix
defined by the chosen kernel function. E.g., using the exponential kernel function:</p>
<pre>cov(i,j) = sigma*exp(-|x_i - x_j|/ell)
</pre>
<p>When specifying the initial parameters to be passed to <code>init_param</code>, care must be taken to
count the number of parameters. Described below is how to specify <code>init_param</code> under different
settings of <code>random</code> and <code>kernel</code>. Note that the order of the parameters must match the
descriptions below (initial values specified below such as 0 and 1 are only examples).
</p>

<ul>
<li><p> random = &quot;a&quot;, kernel = &quot;exp&quot;:
<code>a</code> should be a vector and the rest are scalars. <code>log_sigma_a</code> and <code>log_ell_a</code> are
hyperparameters in the exponential kernel for the Gaussian process describing the spatial
variation of <code>a</code>.
</p>
</li></ul>
<pre>init_param = list(a = rep(1,n_locations), log_b = 0, s = 1,
                  beta_a = rep(0, n_covariates), 
                  log_sigma_a = 0, log_ell_a = 0)
</pre>
<p>Note that even if <code>reparam_s=="zero"</code>, an initial value for <code>s</code> still must be provided, even
though in this case the value does not matter anymore.
</p>

<ul>
<li><p> random = &quot;ab&quot;, kernel = &quot;exp&quot;:
When <code>b</code> is considered a random effect, its corresponding GP hyperparameters <code>log_sigma_b</code>
and <code>log_ell_b</code> need to be specified.
</p>
</li></ul>
<pre>init_param = list(a = rep(1,n_locations),
                  log_b = rep(0,n_locations), s=1,
                  beta_a = rep(0, n_covariates), beta_b = rep(0, n_covariates),
                  log_sigma_a = 0,log_ell_a = 0, 
                  log_sigma_b = 0,log_ell_b = 0).
</pre>

<ul>
<li><p> random = &quot;abs&quot;, kernel = &quot;exp&quot;:
</p>
</li></ul>
<pre>init_param = list(a = rep(1,n_locations),
                  log_b = rep(0,n_locations), 
                  s = rep(0,n_locations),
                  beta_a = rep(0, n_covariates), 
                  beta_b = rep(0, n_covariates),
                  beta_s = rep(0, n_covariates),
                  log_sigma_a = 0,log_ell_a = 0, 
                  log_sigma_b = 0,log_ell_b = 0).
                  log_sigma_s = 0,log_ell_s = 0).
</pre>

<ul>
<li><p> random = &quot;abs&quot;, kernel = &quot;matern&quot; or &quot;spde&quot;:
When the Matern or SPDE kernel is used, hyperparameters for the GP kernel are <code>log_sigma_a/b/s</code>
and <code>log_kappa_a/b/s</code> for each spatial random effect.
</p>
</li></ul>
<pre>init_param = list(a = rep(1,n_locations),
                  log_b = rep(0,n_locations), 
                  s = rep(0,n_locations), 
                  beta_a = rep(0, n_covariates), 
                  beta_b = rep(0, n_covariates),
                  beta_s = rep(0, n_covariates),
                  log_sigma_a = 0,log_kappa_a = 0, 
                  log_sigma_b = 0,log_kappa_b = 0).
                  log_sigma_s = 0,log_kappa_s = 0).
</pre>
<p><code>raparam_s</code> allows the user to reparametrize the GEV shape parameter <code>s</code>. For example,
</p>

<ul>
<li><p> if the data is believed to be right-skewed and lower bounded, this means <code>s&gt;0</code> and one should
use <code>reparam_s = "positive"</code>;
</p>
</li>
<li><p> if the data is believed to be left-skewed and upper bounded, this means <code>s&lt;0</code> and one should
use <code>reparam_s="negative"</code>.
</p>
</li>
<li><p> When <code>reparam_s = "zero"</code>, the data likelihood is a Gumbel distribution. In this case the data
has no upper nor lower bound. Finally, specify <code>reparam_s = "unconstrained"</code> if no sign
constraint should be imposed on <code>s</code>.
</p>
</li></ul>

<p>Note that when reparam_s = &quot;negative&quot; or &quot;postive&quot;, the initial value of <code>s</code> in <code>init_param</code>
should be that of log(|s|).
</p>
<p>When the SPDE kernel is used, a mesh on the spatial domain is created using
<code>INLA::inla.mesh.2d()</code>, which extends the spatial domain by adding additional triangles in the
mesh to avoid boundary effects in estimation. As a result, the number of <code>a</code> and <code>b</code>  will be
greater than the number of locations due to these additional triangles: each of them also has
their own <code>a</code> and <code>b</code> values. Therefore, the fit function will return a vector <code>meshidxloc</code> to
indicate the positions of the observed coordinates in the random effects vector.
</p>


<h3>Value</h3>

<p>If <code>adfun_only=TRUE</code>, this function outputs a list returned by <code>TMB::MakeADFun()</code>.
This list contains components <code style="white-space: pre;">&#8288;par, fn, gr&#8288;</code> and can be passed to an R optimizer.
If <code>adfun_only=FALSE</code>, this function outputs an object of class <code>spatialGEVfit</code>, a list
</p>

<ul>
<li><p> An adfun object
</p>
</li>
<li><p> A fit object given by calling <code>nlminb()</code> on the adfun
</p>
</li>
<li><p> An object of class <code>sdreport</code> from TMB which contains the point estimates, standard error,
and precision matrix for the fixed and random effects
</p>
</li>
<li><p> Other helpful information about the model: kernel, data coordinates matrix, and optionally
the created mesh if 'kernel=&quot;spde&quot; (See details).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(SpatialGEV)
a &lt;- simulatedData$a
logb &lt;- simulatedData$logb
logs &lt;- simulatedData$logs
y &lt;- simulatedData$y
locs &lt;- simulatedData$locs
n_loc = nrow(locs)
# No covariates are included, only intercept is inlcuded.
fit &lt;- spatialGEV_fit(y = y, locs = locs, random = "ab",
                      init_param = list(a = rep(0, n_loc), 
                                        log_b = rep(0, n_loc), 
                                        s = 0,
                                        beta_a = 0,
                                        beta_b = 0,
                                        log_sigma_a = 0, 
                                        log_kappa_a = 0,
                                        log_sigma_b = 0, 
                                        log_kappa_b = 0),
                      reparam_s = "positive",
                      kernel = "matern",
                      X_a = matrix(1, nrow=n_loc, ncol=1),
                      X_b = matrix(1, nrow=n_loc, ncol=1),
                      silent = TRUE) 
print(fit)

# To use a different optimizer other than the default `nlminb()`, create 
# an object ready to be passed to optimizer functions using `adfun_only=TRUE`
obj &lt;- spatialGEV_fit(y = y, locs = locs, random = "ab",
                      init_param = list(a = rep(0, n_loc), 
                                        log_b = rep(0, n_loc), 
                                        s = 0,
                                        beta_a = 0,
                                        beta_b = 0,
                                        log_sigma_a = 0, 
                                        log_kappa_a = 0,
                                        log_sigma_b = 0, 
                                        log_kappa_b = 0),
                      reparam_s = "positive",
                      kernel = "matern",
                      X_a = matrix(1, nrow=n_loc, ncol=1),
                      X_b = matrix(1, nrow=n_loc, ncol=1),
                      adfun_only = TRUE) 
fit &lt;- optim(obj$par, obj$fn, obj$gr)


# Using the SPDE kernel (SPDE approximation to the Matern kernel)
# Make sure the INLA package is installed before using `kernel="spde"`
## Not run: 
library(INLA)
y &lt;- simulatedData2$y
locs &lt;- simulatedData2$locs
n_loc &lt;- nrow(locs) 
fit_spde &lt;- spatialGEV_fit(y = y, locs = locs, random = "abs",
                           init_param = list(a = rep(0, n_loc),
                                             log_b = rep(0, n_loc), 
                                             s = rep(-2, n_loc),
                                             beta_a = 0,
                                             beta_b = 0,
                                             beta_s = -2,
                                             log_sigma_a = 0, 
                                             log_kappa_a = 0,
                                             log_sigma_b = 0, 
                                             log_kappa_b = 0,
                                             log_sigma_s = 0, 
                                             log_kappa_s = 0
                                             ),
                           reparam_s = "positive",
                           kernel = "spde",
                           beta_prior = list(beta_a=c(0,100), beta_b=c(0,10),
                                             beta_s=c(0,10)),
                           matern_pc_prior = list(
                                                 matern_a=matern_pc_prior(1e5,0.95,5,0.1),
                                                 matern_b=matern_pc_prior(1e5,0.95,3,0.1),
                                                 matern_s=matern_pc_prior(1e2,0.95,1,0.1)
                                                 )) 
plot(fit_spde$mesh) # Plot the mesh
points(locs[,1], locs[,2], col="red", pch=16) # Plot the locations

## End(Not run)
</code></pre>

<hr>
<h2 id='spatialGEV_predict'>Draw from the posterior predictive distributions at new locations based on a fitted GEV-GP model</h2><span id='topic+spatialGEV_predict'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distributions at new locations based on a fitted GEV-GP model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGEV_predict(
  model,
  locs_new,
  n_draw,
  X_a_new = NULL,
  X_b_new = NULL,
  X_s_new = NULL,
  parameter_draws = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialGEV_predict_+3A_model">model</code></td>
<td>
<p>A fitted spatial GEV model object of class <code>spatialGEVfit</code></p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_locs_new">locs_new</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;n_test x 2&#8288;</code> matrix containing the coordinates of the new locations</p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_n_draw">n_draw</code></td>
<td>
<p>Number of draws from the posterior predictive distribution</p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_x_a_new">X_a_new</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n_test x r1&#8288;</code> design matrix for a at the new locations. If not provided, the
default is a column matrix of all 1s.</p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_x_b_new">X_b_new</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n_test x r2&#8288;</code> design matrix for log(b) at the new locations</p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_x_s_new">X_s_new</code></td>
<td>
<p><code style="white-space: pre;">&#8288;n_test x r2&#8288;</code> design matrix for (possibly transformed) s at the new locations</p>
</td></tr>
<tr><td><code id="spatialGEV_predict_+3A_parameter_draws">parameter_draws</code></td>
<td>
<p>Optional. A <code style="white-space: pre;">&#8288;n_draw x n_parameter&#8288;</code> matrix. If <code>spatialGEV_sample()</code> has
already been called, the output matrix of parameter draws can be supplied here to avoid doing
sampling of parameters again. Make sure the number of rows of <code>parameter_draws</code> is the same as
<code>n_draw</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spatialGEVpred</code>, which is a list of the following components:
</p>

<ul>
<li><p> An <code style="white-space: pre;">&#8288;n_draw x n_test&#8288;</code> matrix <code>pred_y_draws</code> containing the draws from the posterior predictive
distributions at <code>n_test</code> new locations
</p>
</li>
<li><p> An <code style="white-space: pre;">&#8288;n_test x 2&#8288;</code> matrix <code>locs_new</code> containing the coordinates of the test data
</p>
</li>
<li><p> An <code style="white-space: pre;">&#8288;n_train x 2&#8288;</code> matrix <code>locs_obs</code> containing the coordinates of the observed data
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
library(SpatialGEV)
a &lt;- simulatedData$a
logb &lt;- simulatedData$logb
logs &lt;- simulatedData$logs
y &lt;- simulatedData$y
locs &lt;- simulatedData$locs
n_loc &lt;- nrow(locs)
n_test &lt;- 20
test_ind &lt;- sample(1:n_loc, n_test)

# Obtain coordinate matrices and data lists
locs_test &lt;- locs[test_ind,]
y_test &lt;- y[test_ind]
locs_train &lt;- locs[-test_ind,]
y_train &lt;- y[-test_ind]

# Fit the GEV-GP model to the training set
train_fit &lt;- spatialGEV_fit(y = y_train, locs = locs_train, random = "ab",
                            init_param = list(beta_a = mean(a),
                                             beta_b = mean(logb),   
                                             a = rep(0, n_loc-n_test), 
              				log_b = rep(0, n_loc-n_test),
					s = 0,
					log_sigma_a = 1, 
                                             log_kappa_a = -2,
					log_sigma_b = 1, 
                                             log_kappa_b = -2),
	       	       reparam_s = "positive", 
		       kernel = "matern",
		       silent = TRUE)
pred &lt;- spatialGEV_predict(model = train_fit, locs_new = locs_test, n_draw = 100)
summary(pred)

</code></pre>

<hr>
<h2 id='spatialGEV_sample'>Get posterior parameter draws from a fitted GEV-GP model.</h2><span id='topic+spatialGEV_sample'></span>

<h3>Description</h3>

<p>Get posterior parameter draws from a fitted GEV-GP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGEV_sample(model, n_draw, observation = FALSE, loc_ind = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialGEV_sample_+3A_model">model</code></td>
<td>
<p>A fitted spatial GEV model object of class <code>spatialGEVfit</code></p>
</td></tr>
<tr><td><code id="spatialGEV_sample_+3A_n_draw">n_draw</code></td>
<td>
<p>Number of draws from the posterior distribution</p>
</td></tr>
<tr><td><code id="spatialGEV_sample_+3A_observation">observation</code></td>
<td>
<p>whether to draw from the posterior distribution of the GEV observation?</p>
</td></tr>
<tr><td><code id="spatialGEV_sample_+3A_loc_ind">loc_ind</code></td>
<td>
<p>A vector of location indices to sample from. Default is all locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>spatialGEVsam</code>, which is a list of matrices containing the
joint posterior draws of the parameters and optionally the GEV observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(SpatialGEV)
a &lt;- simulatedData$a
logb &lt;- simulatedData$logb
logs &lt;- simulatedData$logs
y &lt;- simulatedData$y
locs &lt;- simulatedData$locs
n_loc &lt;- nrow(locs)
beta_a &lt;- mean(a); beta_b &lt;- mean(logb)
fit &lt;- spatialGEV_fit(y = y, locs = locs, random = "ab",
                      init_param = list(beta_a = beta_a,
                                        beta_b = beta_b,
                                        a = rep(0, n_loc), 
                                        log_b = rep(0, n_loc), 
                                        s = 0,
                                        log_sigma_a = 0, 
                                        log_kappa_a = 0,
                                        log_sigma_b = 0, 
                                        log_kappa_b = 0),
                      reparam_s = "positive",
                      kernel = "matern",
                      silent = TRUE) 
sam &lt;- spatialGEV_sample(model = fit, n_draw = 100, 
                         observation = TRUE, loc_ind=1:10)
print(sam)
summary(sam)

</code></pre>

<hr>
<h2 id='summary.spatialGEVpred'>Summary method for spatialGEVpred</h2><span id='topic+summary.spatialGEVpred'></span>

<h3>Description</h3>

<p>Summary method for spatialGEVpred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialGEVpred'
summary(object, q = c(0.025, 0.25, 0.5, 0.75, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spatialGEVpred_+3A_object">object</code></td>
<td>
<p>Object of class <code>spatialGEVpred</code> returned by <code>spatialGEV_predict</code>.</p>
</td></tr>
<tr><td><code id="summary.spatialGEVpred_+3A_q">q</code></td>
<td>
<p>A vector of quantile values used to summarize the samples.
Default is <code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code>.</p>
</td></tr>
<tr><td><code id="summary.spatialGEVpred_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary statistics of the posterior predictive samples.
</p>

<hr>
<h2 id='summary.spatialGEVsam'>Summary method for spatialGEVsam</h2><span id='topic+summary.spatialGEVsam'></span>

<h3>Description</h3>

<p>Summary method for spatialGEVsam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialGEVsam'
summary(object, q = c(0.025, 0.25, 0.5, 0.75, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spatialGEVsam_+3A_object">object</code></td>
<td>
<p>Object of class <code>spatialGEVsam</code> returned by <code>spatialGEV_sample</code>.</p>
</td></tr>
<tr><td><code id="summary.spatialGEVsam_+3A_q">q</code></td>
<td>
<p>A vector of quantile values used to summarize the samples.
Default is <code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code>.</p>
</td></tr>
<tr><td><code id="summary.spatialGEVsam_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>summary</code>. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary statistics of the posterior samples.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
