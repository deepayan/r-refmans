<!DOCTYPE html><html lang="en"><head><title>Help for package StereoMorph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StereoMorph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#StereoMorph-package'><p>Stereo Camera Morphometrics</p></a></li>
<li><a href='#alignLandmarksToMidline'><p>Aligns bilateral landmarks to the midline plane</p></a></li>
<li><a href='#avectors'><p>Computes the angle between two vectors</p></a></li>
<li><a href='#calibrateCameras'><p>Finds the optimized DLT coefficients for a stereo camera setup</p></a></li>
<li><a href='#digitizeImage'><p>Opens the StereoMorph Digitizing App</p></a></li>
<li><a href='#digitizeImages'><p>Opens the StereoMorph Digitizing App</p></a></li>
<li><a href='#distanceGridUnits'><p>Returns the distances between pairs of points on a square grid</p></a></li>
<li><a href='#distancePointToLine'><p>Finds the minimum distance(s) between point(s) and a line</p></a></li>
<li><a href='#distancePointToPoint'><p>Finds the distance between two points or sets of points</p></a></li>
<li><a href='#dltCalibrateCameras'><p>Finds the optimized DLT coefficients for a stereo camera setup</p></a></li>
<li><a href='#dltCoefficientRMSError'><p>Returns the error during calibration coefficient optimization</p></a></li>
<li><a href='#dltCoefficients'><p>Computes DLT coefficients for a stereo camera setup</p></a></li>
<li><a href='#dltEpipolarDistance'><p>Finds the distance between a point and a self-epipolar line</p></a></li>
<li><a href='#dltEpipolarLine'><p>Finds a epipolar or self-epipolar line</p></a></li>
<li><a href='#dltInverse'><p>Returns ideal pixel coordinates of 3D point(s) in a stereo camera setup</p></a></li>
<li><a href='#dltMatchCurvePoints'><p>Matches curve points between two camera views</p></a></li>
<li><a href='#dltNearestPointOnEpipolar'><p>Returns the closest point on a epipolar line to a point or points</p></a></li>
<li><a href='#dltReconstruct'><p>Reconstructs the 3D position of points in two or more camera views</p></a></li>
<li><a href='#dltTestCalibration'><p>Tests the accuracy of a stereo camera calibration</p></a></li>
<li><a href='#dltTransformationParameterRMSError'><p>Returns the error during transformation parameter optimization</p></a></li>
<li><a href='#drawCheckerboard'><p>Creates a checkerboard image</p></a></li>
<li><a href='#extractFrames'><p>Extracts frames from video</p></a></li>
<li><a href='#findCheckerboardCorners'><p>Finds internal corners of a checkerboard pattern</p></a></li>
<li><a href='#findOptimalPointAlignment'><p>Optimally aligns one point set to another</p></a></li>
<li><a href='#gridPointsFit'><p>Fits regularly spaced points to a sample line or grid</p></a></li>
<li><a href='#imagePlaneGridTransform'><p>Performs image perspective transformations to a grid</p></a></li>
<li><a href='#imagePlaneGridTransformError'><p>Returns imagePlaneGridTransform error</p></a></li>
<li><a href='#landmarkListToMatrix'><p>Converts a landmark list to a landmark matrix</p></a></li>
<li><a href='#landmarkMatrixToList'><p>Converts a landmark matrix to a landmark list</p></a></li>
<li><a href='#measureCheckerboardSize'><p>Estimates checkerboard square size</p></a></li>
<li><a href='#orthogonalProjectionToLine'><p>Finds the orthogonal projection of a point onto a line</p></a></li>
<li><a href='#pointsAtEvenSpacing'><p>Generates evenly spaced points from point matrix</p></a></li>
<li><a href='#quadraticPointsOnInterval'><p>Generates points along an interval with quadratic parameterization</p></a></li>
<li><a href='#readBezierControlPoints'><p>Reads a file of Bezier control points</p></a></li>
<li><a href='#readCheckerboardsToArray'><p>Reads file(s) containing grid points into an array</p></a></li>
<li><a href='#readLandmarksToList'><p>Reads landmark file(s) into a list</p></a></li>
<li><a href='#readLandmarksToMatrix'><p>Reads a landmark file or files into a matrix</p></a></li>
<li><a href='#readShapes'><p>Reads a StereoMorph shape file</p></a></li>
<li><a href='#reconstructStereoSets'><p>3D reconstruction of landmark and curves from stereo coordinates</p></a></li>
<li><a href='#reflectMissingLandmarks'><p>Reflects missing landmarks across the plane of symmetry</p></a></li>
<li><a href='#resampleGridImagePoints'><p>Resamples imaged grid points</p></a></li>
<li><a href='#TPSToShapes'><p>Converts TPS file to shape file</p></a></li>
<li><a href='#transformPlanarCalibrationCoordinates'><p>Performs rotational and translational transformations to a planar grid</p></a></li>
<li><a href='#unifyLandmarks'><p>Optimally align a set of partial landmark sets</p></a></li>
<li><a href='#writeLMToTPS'><p>Writes landmarks as TPS file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Date:</td>
<td>2022-05-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Stereo Camera Calibration and Reconstruction</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the collection of 3D points and curves using a stereo camera setup.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.11.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils, bezier (&ge; 1.1), grid,
rjson, shiny (&ge; 0.13.0), Rcpp (&ge; 0.9.9), jpeg, tiff, png,
svgViewR (&ge; 1.0.1), MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Olsen, Annat Haber</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Olsen &lt;aarolsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://aaronolsen.github.io/software/stereomorph.html">https://aaronolsen.github.io/software/stereomorph.html</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-24 18:32:07 UTC; aaron</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-25 15:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='StereoMorph-package'>Stereo Camera Morphometrics</h2><span id='topic+StereoMorph-package'></span><span id='topic+StereoMorph'></span><span id='topic+alignShapesToMidline'></span><span id='topic+btShapes'></span><span id='topic+checkCornerOrder'></span><span id='topic+check_system_command_SM'></span><span id='topic+cprod_SM'></span><span id='topic+createErrorPlots'></span><span id='topic+dilateImage'></span><span id='topic+distancePointToPlane'></span><span id='topic+distortionError'></span><span id='topic+dltCCEstimateStartParams'></span><span id='topic+drawRectangle'></span><span id='topic+drawShapes'></span><span id='topic+epipolarBezier'></span><span id='topic+equalizeImageHist'></span><span id='topic+erodeImage'></span><span id='topic+estimateDistortion'></span><span id='topic+estimateUndistortion'></span><span id='topic+estimateDLTCoefficients'></span><span id='topic+findBoundaryPoints'></span><span id='topic+findCornerSubPix'></span><span id='topic+findEpipolarTangencyAngles'></span><span id='topic+findHomography'></span><span id='topic+findInterpointDistanceError'></span><span id='topic+generateQuads'></span><span id='topic+gridPointsFitError'></span><span id='topic+intCornersFromQuads'></span><span id='topic+inverseGridTransform'></span><span id='topic+list2XML4R'></span><span id='topic+listToJSONStr'></span><span id='topic+matchCurvePoints'></span><span id='topic+meanBlurImage'></span><span id='topic+orderCorners'></span><span id='topic+polyArea'></span><span id='topic+print_processing_times'></span><span id='topic+process_digitize_images_input'></span><span id='topic+readLandmarksToArray'></span><span id='topic+readTPS'></span><span id='topic+readXML4R'></span><span id='topic+readXMLLines'></span><span id='topic+read_video_info'></span><span id='topic+reflectMissingShapes'></span><span id='topic+removeOutlierCorners'></span><span id='topic+rgbToGray'></span><span id='topic+rotationMatrixZYX_SM'></span><span id='topic+StereoMorph_dilateImage'></span><span id='topic+StereoMorph_drawRectangle'></span><span id='topic+StereoMorph_equalizeImageHist'></span><span id='topic+StereoMorph_erodeImage'></span><span id='topic+StereoMorph_findBoundaryPoints'></span><span id='topic+StereoMorph_findCornerSubPix'></span><span id='topic+StereoMorph_generateQuads'></span><span id='topic+StereoMorph_intCornersFromQuads'></span><span id='topic+StereoMorph_meanBlurImage'></span><span id='topic+StereoMorph_orderCorners'></span><span id='topic+StereoMorph_rgbToGray'></span><span id='topic+StereoMorph_thresholdImageMatrix'></span><span id='topic+testCalibration'></span><span id='topic+thresholdImageMatrix'></span><span id='topic+tMatrixDC_SM'></span><span id='topic+undistort'></span><span id='topic+undistortionError'></span><span id='topic+undistortShapes'></span><span id='topic+uvector_SM'></span><span id='topic+XML4R2list'></span><span id='topic+XML4R2listLines'></span>

<h3>Description</h3>

<p><strong>StereoMorph</strong> provides functions for the collection of 3D points and curves using a stereo camera setup. <strong>StereoMorph</strong> can also be used for <a href="https://aaronolsen.github.io/software/digitizing.html">collecting 2D shape data from photographs</a>. Please see <a href="https://aaronolsen.github.io/software/stereomorph.html">StereoMorph tutorials</a> for step-by-step tutorials on how to use <strong>StereoMorph</strong> for 2D or 3D shape data collection.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> StereoMorph</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-05-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> CC BY-SA 4.0</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Aaron Olsen, Annat Haber
</p>
<p>Maintainer: Aaron Olsen <a href="mailto:aarolsen@gmail.com">aarolsen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=svgViewR">svgViewR</a>, 
<a href="https://cran.r-project.org/package=bezier">bezier</a>
</p>

<hr>
<h2 id='alignLandmarksToMidline'>Aligns bilateral landmarks to the midline plane</h2><span id='topic+alignLandmarksToMidline'></span><span id='topic+summary.alignLandmarksToMidline'></span><span id='topic+print.summary.alignLandmarksToMidline'></span>

<h3>Description</h3>

<p>This function aligns a set of bilateral landmarks to the midline plane. Midline landmarks and the mean position of bilateral landmarks are both used to define the midline plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
alignLandmarksToMidline(lm.matrix, left = '(_l[_]?|_left[_]?)([0-9]*$)', 
                        right = '(_r[_]?|_right[_]?)([0-9]*$)',
                        left.remove = '\\2', right.remove = '\\2', 
                        use = rep(TRUE, dim(lm.matrix)[1]), average = FALSE)

## S3 method for class 'alignLandmarksToMidline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alignLandmarksToMidline_+3A_lm.matrix">lm.matrix</code></td>
<td>
<p>a 2D or 3D matrix with landmark names as row names.</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_left">left</code></td>
<td>
<p>a regular expression to identify left landmarks in the row names of <code>lm.matrix</code>.</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_right">right</code></td>
<td>
<p>a regular expression to identify right landmarks in the row names of <code>lm.matrix</code>.</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_left.remove">left.remove</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating which element of <code>left</code> in parentheses should be removed to create a landmark name that is not side-specific (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_right.remove">right.remove</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating which element of <code>right</code> in parentheses should be removed to create a landmark name that is not side-specific (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_use">use</code></td>
<td>
<p>a vector of <code>TRUE</code> or <code>FALSE</code> values of the same length as the number of landmarks to specify which landmarks will be used in aligning to the midline. Default is that all landmarks are used.</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_average">average</code></td>
<td>
<p>Whether to average left and right landmarks after alignment. Can be left false if landmarks previously reflected with <code>average</code> equal to <code>TRUE</code> (see <code><a href="#topic+reflectMissingLandmarks">reflectMissingLandmarks</a></code>).</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_object">object</code></td>
<td>
<p>a list of class <code>"alignLandmarksToMidline"</code> (output of this function).</p>
</td></tr>
<tr><td><code id="alignLandmarksToMidline_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the function only accepts left/right designations by matching a regular expression to the landmark name. This is preferable in that it allows for easier match up between bilateral landmarks (based on their common name without a side annotation). The default regular expression identifies left landmarks by a name ending in &quot;_L&quot;, &quot;_l&quot;, &quot;_left&quot; or &quot;_LEFT&quot;, optionally followed by numbers. For example, &quot;hamulus_left&quot;, &quot;hamulus_L&quot; and &quot;zymgomatic_arch_l012&quot; would all be identified as landmarks on the left side. Similarly, &quot;hamulus_right&quot;, &quot;hamulus_R&quot; and &quot;zymgomatic_arch_r012&quot; would all be identified as landmarks on the right side. Landmarks not identified as left or right are assumed to fall on the midline.
</p>
<p>In order to find corresponding left and right landmarks, the function requires the <code>left.remove</code> and <code>right.remove</code> arguments. The <code>left.remove</code> and <code>right.remove</code> arguments are passed to the base function <code>gsub()</code> as the <code>replacement</code> argument. This is used to generate a landmark name that is not side-specific. For example, &quot;hamulus_left&quot; and &quot;zymgomatic_arch_l012&quot; would become &quot;hamulus&quot; and &quot;zymgomatic_arch012&quot;. These will be reverted to their original names at return.
</p>
<p>Once corresponding right and left landmarks have been identified, the function finds the mean positions of all bilateral landmarks and the positions of all midline landmarks. These points are used to define the midline. After alignment, the specimen will have the midline axis as the last column (z in 3D, y in 2D), the longest non-midline axis as the first column (x in 3D), and the second non-midline axis as y for 3D. No further rotation and reflection is done, therefore the specimen may be facing any direction along each of the axes.
</p>
<p>This function returns the aligned landmarks and an error vector, <code>midline.error</code>. This is a vector of the squared z-coordinate of the midline landmarks (the distance between each midline landmark and the midline plane). If <code><a href="#topic+reflectMissingLandmarks">reflectMissingLandmarks</a></code> was called on the landmarks prior to <code>alignLandmarksToMidline()</code> with <code>average</code> equal to <code>TRUE</code>, then all of the midline points will fall exactly along the midline. Thus, the error vector will consist entirely of zeros (or near-zero values).
</p>


<h3>Value</h3>

<p>a list of class <code>"alignLandmarksToMidline"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>lm.matrix</code></td>
<td>
<p>a 2D or 3D matrix of landmarks aligned to the midline.</p>
</td></tr>
<tr><td><code>midline.error</code></td>
<td>
<p>a vector of the errors (distances) between each midline landmark and the midline plane.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the R function <code>AMP()</code> written by A Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## GET LANDMARKS
file &lt;- paste0(fdir, "lm_3d_unify.txt")

## LOAD FILES INTO A MATRIX
lm.matrix &lt;- readLandmarksToMatrix(file=file, row.names=1)

## ALIGN TO MIDLINE
align_landmarks &lt;- alignLandmarksToMidline(lm.matrix=lm.matrix)

## PRINT SUMMARY OF ERRORS
print(summary(align_landmarks))
</code></pre>

<hr>
<h2 id='avectors'>Computes the angle between two vectors</h2><span id='topic+avectors'></span>

<h3>Description</h3>

<p>This function returns the angle (in radians) between two vectors. The vectors can be of any dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'>avectors(u, v)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avectors_+3A_u">u</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="avectors_+3A_v">v</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the angle (in radians) between the two input vectors.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>Examples</h3>

<pre><code class='language-R'>## THE ANGLE BETWEEN TWO 2D, ORTHOGONAL VECTORS
## VALUE IS EQUAL TO asin(1/sqrt(2))
u &lt;- c(0, 1)
v &lt;- c(1, 0)
avectors(u, v)

## THE ANGLE BETWEEN TWO 3D VECTORS
## VALUE IS EQUAL TO asin(sqrt(2)/sqrt(3))
u &lt;- c(1, 1, 1)
v &lt;- c(0, 1, 0)
avectors(u, v)
</code></pre>

<hr>
<h2 id='calibrateCameras'>Finds the optimized DLT coefficients for a stereo camera setup</h2><span id='topic+calibrateCameras'></span><span id='topic+print.calibrateCameras'></span>

<h3>Description</h3>

<p>This function uses a checkerboard at different positions and angles within a stereo camera setup to estimate DLT calibration coefficients for use in stereo reconstruction. This function is a wrapper for the function <code>dltCalibrateCameras</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateCameras(img.dir, sq.size, nx, ny, cal.file, corner.dir,
                 print.progress = TRUE, flip.view = FALSE, verify.dir = NULL,
                 error.dir = NULL, min.views = 'max', exec.dir = NULL, 
                 undistort = FALSE, num.aspects.read = 'auto', 
                 num.sample.est = 'auto', num.sample.sets = 'auto', 
                 num.aspects.sample = 'auto', max.sample.optim = 30, nlm.calls.max = 20, 
                 fit.min.break = 1, objective.min = 1, objective.min.break = 5, 
                 with.circles = FALSE, sample.est = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrateCameras_+3A_img.dir">img.dir</code></td>
<td>
<p>folder containing images of the checkerboard pattern, separated into separate folders by view.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_sq.size">sq.size</code></td>
<td>
<p>character string indicating size of checkerboard squares (length along one dimension) including the unit of measure (e.g. '6.35 mm').</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_nx">nx</code></td>
<td>
<p>integer indicating the number of internal corners along one dimension of the checkerboard.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_ny">ny</code></td>
<td>
<p>integer indicating the number of internal corners along the other dimension of the checkerboard.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_cal.file">cal.file</code></td>
<td>
<p>file path to the output calibration file (if it does not already exist one will be created).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_corner.dir">corner.dir</code></td>
<td>
<p>folder where the detected checkerboard corners will be saved (if it does not already exist one will be created).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_print.progress">print.progress</code></td>
<td>
<p>logical indicating whether function processes should be printed to the console.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_flip.view">flip.view</code></td>
<td>
<p>logical indicating whether one camera view is upside-down relative to the other.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_verify.dir">verify.dir</code></td>
<td>
<p>folder where the images of the checkerboards with detected corners overlaid will be written (if it does not already exist one will be created).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_error.dir">error.dir</code></td>
<td>
<p>folder where the error diagnostic plots will be saved (if it does not already exist one will be created).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_min.views">min.views</code></td>
<td>
<p>integer indicating the minimum views in which corners must be detected in order to use in coefficient estimation. If set to 'max' (default) this will be equal to the number of input views.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_exec.dir">exec.dir</code></td>
<td>
<p>file path to folder containing external executables for reading video files (still under development).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_undistort">undistort</code></td>
<td>
<p>logical indicating whether to estimate lens distortion correction coefficients (still under development).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_num.aspects.read">num.aspects.read</code></td>
<td>
<p>number (integer) of frames to be read from video input. Requires external executables (still under development).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_num.sample.est">num.sample.est</code></td>
<td>
<p>number (integer) of aspects from total that will be sampled calibration coefficient estimation.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_num.sample.sets">num.sample.sets</code></td>
<td>
<p>number (integer) of unique sets of aspects to try.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_num.aspects.sample">num.aspects.sample</code></td>
<td>
<p>number (integer) of aspects to sample for each set.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_max.sample.optim">max.sample.optim</code></td>
<td>
<p>maximum number (integer) of aspects to be used in identifying the best DLT coefficient set (once already estimated).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_nlm.calls.max">nlm.calls.max</code></td>
<td>
<p>maximum number (integer) of different sets of random starting parameters to use during coefficient optimization. This parameter cannot exceed 576.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_fit.min.break">fit.min.break</code></td>
<td>
<p>minimum error at which <code>resampleGridImagePoints()</code> will stop iterating to find a better fit.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_objective.min.break">objective.min.break</code></td>
<td>
<p>minimum error at which optimization will stop estimating the position of additional checkerboards.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_objective.min">objective.min</code></td>
<td>
<p>The expected mean reconstruction error when optimizing the calibration coefficients (the minimum, or <code>objective</code> value returned by <code>nlminb()</code>). A value between 0.2 and 1.2 should be reasonable.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_with.circles">with.circles</code></td>
<td>
<p>logical indicating whether the checkerboard pattern includes concentric circles for identifying the starting corner. Requires external executables (still under development).</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_sample.est">sample.est</code></td>
<td>
<p>vector of explicitly defined aspects to use in coefficient estimation.</p>
</td></tr>
<tr><td><code id="calibrateCameras_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see <a href="https://aaronolsen.github.io/software/stereomorph.html">StereoMorph tutorials</a> for step-by-step tutorials on how to use <strong>StereoMorph</strong> for 2D or 3D shape data collection.
</p>


<h3>Value</h3>

<p>a list of class <code>"calibrateCameras"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>cal.coeff</code></td>
<td>
<p>a matrix of 11 optimized DLT calibration coefficients per camera view.</p>
</td></tr>
<tr><td><code>mean.reconstruct.rmse</code></td>
<td>
<p>the RMS error when <code>coor.2d</code> and the optimized calibration coefficients <code>cal.coeff</code> are input to <code><a href="#topic+dltReconstruct">dltReconstruct</a></code>.</p>
</td></tr>
<tr><td><code>coefficient.rmse</code></td>
<td>
<p>the RMS error when <code>coor.2d</code> and the optimized 3D coordinates <code>coor.3d</code> are input to <code><a href="#topic+dltCoefficients">dltCoefficients</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+digitizeImages">digitizeImages</a></code>,
<code><a href="#topic+reconstructStereoSets">reconstructStereoSets</a></code>
</p>

<hr>
<h2 id='digitizeImage'>Opens the StereoMorph Digitizing App</h2><span id='topic+digitizeImage'></span>

<h3>Description</h3>

<p>This function has been replaced by <code><a href="#topic+digitizeImages">digitizeImages</a></code>.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+digitizeImages">digitizeImages</a></code>
</p>

<hr>
<h2 id='digitizeImages'>Opens the StereoMorph Digitizing App</h2><span id='topic+digitizeImages'></span>

<h3>Description</h3>

<p>This function opens an application in the user's default web browser for manually digitizing landmarks and Bezier curves from photographs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
digitizeImages(image.file, shapes.file=NULL, landmarks.file=NULL, 
     control.points.file=NULL, curve.points.file=NULL, 
     cal.file=NULL, landmarks.ref=NULL, curves.ref=NULL, image.id=NULL, 
     landmark.color.blur = 'blue', landmark.color.focus = 'green', 
     curve.color.blur = 'purple', control.point.color.blur = 'purple', 
     control.point.color.focus = 'red', landmark.radius = 4, 
     control.point.radius = 4, marker.stroke.width = 2, app.dir=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="digitizeImages_+3A_image.file">image.file</code></td>
<td>
<p>file path to the image or images to be digitized. This can be a folder containing one or more images or a vector of file paths of one or more images.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_shapes.file">shapes.file</code></td>
<td>
<p>file path or folder indicating where shape files should be saved. This is a new format that is currently only intended to be used when collecting 2D data. The other input types (<code>landmarks.file</code>, <code>control.points.file</code>, <code>curve.points.file</code>) will be phased out in future updates and replaced with this format.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_landmarks.file">landmarks.file</code></td>
<td>
<p>same input as <code>landmarks.file</code> in <code><a href="#topic+digitizeImage">digitizeImage</a></code>. Included for backward compatibility. This will eventually be phased out.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_control.points.file">control.points.file</code></td>
<td>
<p>same input as <code>control.points.file</code> in <code><a href="#topic+digitizeImage">digitizeImage</a></code>. Included for backward compatibility. This will eventually be phased out.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_curve.points.file">curve.points.file</code></td>
<td>
<p>same input as <code>curve.points.file</code> in <code><a href="#topic+digitizeImage">digitizeImage</a></code>. Included for backward compatibility. This will eventually be phased out.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_cal.file">cal.file</code></td>
<td>
<p>file path to calibration file created by <code><a href="#topic+calibrateCameras">calibrateCameras</a></code>.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_landmarks.ref">landmarks.ref</code></td>
<td>
<p>landmarks to be digitized. This can either be a file path to a .txt file containing the landmarks (listed in a single column, each on a separate line) or a vector of landmark names.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_curves.ref">curves.ref</code></td>
<td>
<p>curves to be digitized. For each curve, the name of the curve, the starting point and the ending point must be specified. <code>curves.ref</code> can either be a three-column matrix (with the curve name in the first column, the starting point in the second and the end point in the third) or a file path to a .txt file containing a three-column curve reference matrix. If a file path, the file should have no header and tab-separated row values.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_image.id">image.id</code></td>
<td>
<p>image IDs to be saved with each image. These will be used to reference shape data in the output of <code><a href="#topic+readShapes">readShapes</a></code>. If <code>NULL</code>, the filenames of the images will be used (without the file extension).</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_landmark.color.blur">landmark.color.blur</code></td>
<td>
<p>color of an unselected landmark. It might be necessary to change if the background color is close to the default. Colors must be valid SVG color names or codes (e.g. &quot;hotpink&quot;, &quot;#4B0082&quot;, etc.). A web-search for &quot;SVG color codes&quot; will indicate several possible options.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_landmark.color.focus">landmark.color.focus</code></td>
<td>
<p>color of a selected landmark. See <code>landmark.color.blur</code>.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_curve.color.blur">curve.color.blur</code></td>
<td>
<p>color of digitized curves. A different color for a selected curve is not yet supported. See <code>landmark.color.blur</code>.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_control.point.color.blur">control.point.color.blur</code></td>
<td>
<p>color of an unselected control point. See <code>landmark.color.blur</code>.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_control.point.color.focus">control.point.color.focus</code></td>
<td>
<p>color of a selected control point. See <code>landmark.color.blur</code>.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_landmark.radius">landmark.radius</code></td>
<td>
<p>radius of digitized landmarks.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_control.point.radius">control.point.radius</code></td>
<td>
<p>radius of the Bezier control points.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_marker.stroke.width">marker.stroke.width</code></td>
<td>
<p>thickness of the lines used to draw the landmarks and control points.</p>
</td></tr>
<tr><td><code id="digitizeImages_+3A_app.dir">app.dir</code></td>
<td>
<p>changes the shiny app directory for debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function opens a digitizing app in the user's default browswer and allows for the digitization of landmarks and Bezier curves from photographs. Although the app runs in a web browser, the user does not have to be connected to the internet as the app runs on a local server. The R package 'shiny' handles the communication between the browser and the R console. Safari, Chrome and Opera all provide full compatibility with the apps's features. Please see <a href="https://aaronolsen.github.io/software/stereomorph.html">StereoMorph tutorials</a> for step-by-step tutorials on how to use <strong>StereoMorph</strong> for 2D or 3D shape data collection.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readShapes">readShapes</a></code>
</p>

<hr>
<h2 id='distanceGridUnits'>Returns the distances between pairs of points on a square grid</h2><span id='topic+distanceGridUnits'></span>

<h3>Description</h3>

<p>This function returns the distances in grid units between pairs of points on a square grid. This function is used in testing the accuracy of a calibration by comparing theoretical distances among grid points to measured distances.</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceGridUnits(pairs, nx)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceGridUnits_+3A_pairs">pairs</code></td>
<td>
<p>a two-column matrix specifying the pairs of points between which the distance is to be found.</p>
</td></tr>
<tr><td><code id="distanceGridUnits_+3A_nx">nx</code></td>
<td>
<p>the number of points in the first dimension along which grid points are counted (see &quot;Details&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the distances in grid units between pairs of points on a square grid. Thus, adjoining points in the same row or column would be separated by a distance of one. The returned distances can then be multiplied by the grid square size to obtain the distances between pairs of points in real-world units (e.g. mm).
</p>
<p>The input <code>pairs</code> is a two-column matrix specifying the pairs of points, with the first column corresponding to one point and the second column to the other. The numbers in <code>pairs</code> are indices of grid points (not point coordinates themselves). The assumed numbering scheme for the grid points is as follows: the points are first numbered across the first dimension (of length <code>nx</code>) and then along a second dimension. For example, on a 5x4 grid points 1-5 would be across the first row, 6-10 across the second row, etc. For each row the point numbering starts in the same column. For <code>distanceGridUnits()</code> the number of columns does not need to be specified since this can be found from the point index in <code>pairs</code>. See &quot;Examples&quot; for an explanation of the numbering scheme.
</p>


<h3>Value</h3>

<p>a vector of the distances between the specified pairs of grid points.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltTestCalibration">dltTestCalibration</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## INDICES OF POINT PAIRS ON A GRID WITH 5 ROWS
pairs &lt;- matrix(c(1,1, 5,10, 6,16, 1,20), nrow=4, ncol=2, byrow=TRUE)

## FIND THE DISTANCE BETWEEN PAIRS OF POINTS IN GRID UNITS
## NOTE LAST DISTANCE IS 5 BECAUSE IT IS A 3,4,5-TRIANGLE
distanceGridUnits(pairs, nx=5)

## FOR ILLUSTRATION, HERE IS A GRID WITH 5 ROWS AND 4 COLUMNS
xy &lt;- cbind(rep(0:4, 4), c(rep(0, 5), rep(1, 5), rep(2, 5), rep(3, 5)))

## PLOT THESE POINTS
plot(xy)

## PLOT LINE SEGMENTS CONNECTING THE PAIRS ABOVE
segments(x0=xy[pairs[, 1], 1], y0=xy[pairs[, 1], 2],
  x1=xy[pairs[, 2], 1], y1=xy[pairs[, 2], 2],
  col=c('blue', 'red', 'purple', 'green'))
</code></pre>

<hr>
<h2 id='distancePointToLine'>Finds the minimum distance(s) between point(s) and a line</h2><span id='topic+distancePointToLine'></span>

<h3>Description</h3>

<p>Finds the minimum distance between a point and a line or multiple points and a line in two or three dimensions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePointToLine(p, l1, l2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePointToLine_+3A_p">p</code></td>
<td>
<p>a vector of a single point or a matrix of multiple points</p>
</td></tr>
<tr><td><code id="distancePointToLine_+3A_l1">l1</code></td>
<td>
<p>a vector describing a point on a line or a list with line constants</p>
</td></tr>
<tr><td><code id="distancePointToLine_+3A_l2">l2</code></td>
<td>
<p>if <code>l1</code> is a point, a second point on a line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>p</code> is a vector, the function returns the distance between a point and the line input. If <code>p</code> is a matrix, the function returns the distance between each point in the matrix (defined by each row) and the line input. If <code>p</code> is a vector, the length must be 2 or 3 (2D or 3D, respectively). If <code>p</code> is a matrix, the number of columns must be 2 or 3 (2D or 3D, respectively).
</p>
<p>The line input can be defined using one of three standard ways: two points on the line, 'm' and 'b' constants and direction numbers (a vector parallel to the line). If <code>l1</code> is a vector, this is taken as one point on the line and <code>l2</code> must be a second point on the line. If <code>l1</code> is a list, the named objects must correspond to one of these three line definitions. Two points on the line are defined as <code>l1$l1</code> and <code>l1$l2</code>. 'm' and 'b' are defined as <code>l1$m</code> and <code>l1$b</code>. And the direction numbers 'abc' are defined as <code>l1$a</code>, <code>l1$b</code> and <code>l1$c</code>.
</p>


<h3>Value</h3>

<p>a vector of distance(s)</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthogonalProjectionToLine">orthogonalProjectionToLine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE DISTANCE BETWEEN A 2D POINT AND A LINE DEFINED BY A SLOPE AND Y-INTERCEPT
distancePointToLine(p=c(0, 2), l1=list(m=0, b=1))

## FIND THE DISTANCE BETWEEN A 2D POINT AND A LINE DEFINED BY TWO POINTS ON THE LINE
distancePointToLine(p=c(0, 5), l1=list(l1=c(2, 4), l2=c(2, 1)))

## FIND THE DISTANCE BETWEEN MULTIPLE 2D POINTS AND A LINE DEFINED BY A SLOPE AND Y-INTERCEPT
p &lt;- matrix(c(0, 0, 1, 1, 2, 2), nrow=3, ncol=2, byrow=TRUE)
distancePointToLine(p=p, l1=list(m=0, b=1))

## FIND THE DISTANCE BETWEEN MULTIPLE 2D POINTS AND A LINE DEFINED BY DIRECTION NUMBERS
p &lt;- matrix(c(0, -1.5, 1, -2, 2, 2), nrow=3, ncol=2, byrow=TRUE)
distancePointToLine(p=p, l1=list(a=1, b=2, c=3))

## FIND THE DISTANCE BETWEEN A 3D POINT AND A LINE DEFINED BY TWO POINTS ON THE LINE
## HERE THE DISTANCE IS EQUAL TO sqrt(2)
distancePointToLine(p=c(1, 1, 1), l1=c(0, 0, 0), l2=c(1, 0, 0))

## FIND THE DISTANCE BETWEEN MULTIPLE 3D POINTS AND A LINE DEFINED BY TWO POINTS ON THE LINE
p &lt;- matrix(c(0, 0, 0, 1, 1, 1, 2, 2, 2), nrow=3, ncol=3, byrow=TRUE)
distancePointToLine(p=p, l1=list(l1=c(0, 0, 0), l2=c(1, 0, 0)))
</code></pre>

<hr>
<h2 id='distancePointToPoint'>Finds the distance between two points or sets of points</h2><span id='topic+distancePointToPoint'></span>

<h3>Description</h3>

<p>Finds the distance betweeen two single points, the distances between one point and a set of points, or the distances between two point sets. Points can be of any number of dimensions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePointToPoint(p1, p2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePointToPoint_+3A_p1">p1</code></td>
<td>
<p>a vector of a single point or a matrix of one or multiple points</p>
</td></tr>
<tr><td><code id="distancePointToPoint_+3A_p2">p2</code></td>
<td>
<p>a vector of a single point or a matrix of one or multiple points. If <code>NULL</code>, the function either returns the distance of <code>p1</code> from the origin or the distances between subsequent values of <code>p1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>p1</code> is a single point and <code>p2</code> is a single point then the function returns the distance between these two points. If either <code>p1</code> or <code>p2</code> is a single point and the other is a matrix of multiple points then the function returns a vector of the distances between the single point and each of the multiple points. If both <code>p1</code> and <code>p2</code> are matrices of multiple points, then the function returns a vector of the distances between the points in each corresponding row. If <code>p1</code> and <code>p2</code> are both matrices, the matrix dimensions must match.
</p>
<p>If <code>p2</code> is <code>NULL</code>, then <code>distancePointToPoint()</code> returns the distance between consecutive points in <code>p1</code>. If <code>p1</code> is a vector, the function returns the absolute difference between consecutive values of <code>p1</code> (interpoint distances along a single dimension). If <code>p1</code> is a matrix, then the function returns the distance between the point in each row of <code>p1</code> and its subsequent row. This can be used to return the interpoint distances along a curve defined as a matrix of points.
</p>


<h3>Value</h3>

<p>a vector of distance(s)</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+distancePointToLine">distancePointToLine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## FIND THE DISTANCE BETWEEN TWO, 2D POINTS
## VALUE IS sqrt(2)
distancePointToPoint(p1=c(0, 0), p2=c(1, 1))

## FIND THE DISTANCE BETWEEN A 2D POINT AND MULTIPLE 2D POINTS
p1 &lt;- c(0, 0)
p2 &lt;- matrix(c(1, 1, 2, 2, 3, 3), nrow=3, ncol=2, byrow=TRUE)
distancePointToPoint(p1=p1, p2=p2)

## FIND THE DISTANCE BETWEEN TWO SETS OF 2D POINTS
p1 &lt;- matrix(c(0, 0, 1, 1, 2, 2), nrow=3, ncol=2, byrow=TRUE)
p2 &lt;- matrix(c(1, 1, 2, 2, 3, 3), nrow=3, ncol=2, byrow=TRUE)
distancePointToPoint(p1=p1, p2=p2)

## FIND THE DISTANCE BETWEEN A 3D POINT AND MULTIPLE 3D POINTS
p1 &lt;- c(0, 0, 0)
p2 &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow=3, ncol=3, byrow=TRUE)
distancePointToPoint(p1=p1, p2=p2)

## FIND THE DISTANCE BETWEEN CONSECUTIVE VALUES IN A VECTOR
distancePointToPoint(p1=c(1, 2, 4, 7))

## FIND THE DISTANCE BETWEEN CONSECUTIVE 2D POINTS IN A MATRIX
## HERE, WE FIND THE DISTANCE BETWEEN THE POINT c(0, 0) AND c(1, 1), WHICH IS sqrt(2)
distancePointToPoint(p1=matrix(c(0, 0, 1, 1), nrow=2, ncol=2, byrow=TRUE))

## FIND THE DISTANCE BETWEEN CONSECUTIVE 2D POINTS IN A MATRIX, WITH MORE POINTS
## HERE, WE ADD TWO MORE POINTS TO THE PREVIOUS EXAMPLE: c(2, 2) AND c(3, 3)
## THE DISTANCE BETWEEN EACH CONSECUTIVE PAIR OF POINTS IS sqrt(2)
distancePointToPoint(p1=matrix(c(0, 0, 1, 1, 2, 2, 3, 3), nrow=4, ncol=2, byrow=TRUE))

## FIND THE DISTANCE BETWEEN CONSECUTIVE 3D POINTS IN A MATRIX
distancePointToPoint(p1=matrix(c(0, 0, 0, 1, 1, 1), nrow=2, ncol=3, byrow=TRUE))

## FIND THE DISTANCE BETWEEN CONSECUTIVE 4D POINTS IN A MATRIX
distancePointToPoint(p1=matrix(c(0, 0, 0, 0, 1, 1, 1, 1), nrow=2, ncol=4, byrow=TRUE))
</code></pre>

<hr>
<h2 id='dltCalibrateCameras'>Finds the optimized DLT coefficients for a stereo camera setup</h2><span id='topic+dltCalibrateCameras'></span><span id='topic+summary.dltCalibrateCameras'></span><span id='topic+print.summary.dltCalibrateCameras'></span>

<h3>Description</h3>

<p>This function uses the corners from a grid positioned in several different orientations within a stereo camera setup to estimate the DLT calibration coefficients that minimize reconstruction error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltCalibrateCameras(coor.2d, nx, grid.size, c.run = FALSE, reduce.grid.dim = 3,
                    fit.min.break = 1, nlm.iter.max.init = 100, objective.min.init = 10, 
                    nlm.eval.max = 350, nlm.iter.max = 250, nlm.calls.max = 100,
                    min.views = 'max', objective.min = 1, grid.incl.min=2, 
                    objective.min.break = NULL, start.param=NULL, 
                    sx = NULL, sy = NULL, print.progress = FALSE, print.tab = '')

## S3 method for class 'dltCalibrateCameras'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltCalibrateCameras_+3A_coor.2d">coor.2d</code></td>
<td>
<p>a four-dimensional array of grid points. The first two dimensions correspond to each matrix of grid points, the third corresponds to each grid position/orientation and the fourth corresponds to each camera view. Can be read from file by the function <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points in <code>coor.2d</code> are listed first by row). The number of points along the second dimension is calculated based on the total number of points per view and orientation.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_grid.size">grid.size</code></td>
<td>
<p>the size of the grid squares in real-world units (e.g. millimeters).</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_c.run">c.run</code></td>
<td>
<p>a logical indicating whether a second optimization should be performed on the calibration coefficients.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_reduce.grid.dim">reduce.grid.dim</code></td>
<td>
<p>a numeric indicating the number of grid points along each dimension for each grid after resampling. The total number of resampled points is <code>reduce.grid.dim^2</code>. Resampling can be turned off by setting this to <code>0</code> or <code>FALSE</code>. The default is recommended. <code>reduce.grid.dim</code> must be greater than two.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_fit.min.break">fit.min.break</code></td>
<td>
<p>passed to <code>resampleGridImagePoints()</code>. A minimum returned by <code>nlminb()</code> (indicating goodness of fit in pixel coordinates) at which <code>resampleGridImagePoints()</code> will stop iterating to find a better fit for each checkerboard grid. Ignored if <code>reduce.grid.dim</code> is <code>0</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_nlm.iter.max.init">nlm.iter.max.init</code></td>
<td>
<p>The maximum number of iterations to be performed by <code>nlminb()</code> during initial coefficient optimization, passed as a control parameter to <code>nlminb()</code>. These are the number of iterations for an initial determination of whether the function is likely to converge on the correct estimate.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_objective.min.init">objective.min.init</code></td>
<td>
<p>The objective used during the initial coefficient optimization, passed as a control parameter to <code>nlminb()</code>, to determine whether the function is close to convergence.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_nlm.eval.max">nlm.eval.max</code></td>
<td>
<p>The maximum number of evaluations to be performed by <code>nlminb()</code> during primary coefficient optimization, passed as a control parameter to <code>nlminb()</code>. Keeping this value as low as possible without excluding actual convergence speeds performance of the function by preventing the function from stalling far from the optimal values.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_nlm.iter.max">nlm.iter.max</code></td>
<td>
<p>The maximum number of iterations to be performed by <code>nlminb()</code> during primary coefficient optimization, passed as a control parameter to <code>nlminb()</code>. Keeping this value as low as possible without excluding actual convergence speeds performance of the function by preventing the function from stalling far from the optimal values.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_nlm.calls.max">nlm.calls.max</code></td>
<td>
<p>The maximum number of different sets of random starting parameters to use during coefficient optimization. This parameter cannot exceed 576.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_min.views">min.views</code></td>
<td>
<p>The minimum views in which corners must be detected in order to use in coefficient estimation. If set to 'max' (default) this will be equal to the number of input views.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_objective.min">objective.min</code></td>
<td>
<p>The expected mean reconstruction error when optimizing the calibration coefficients (the minimum, or <code>objective</code> value returned by <code>nlminb()</code>). A value between 0.7 and 3 should be reasonable.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_grid.incl.min">grid.incl.min</code></td>
<td>
<p>The minimum number of grids to include during coefficient optimization.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_objective.min.break">objective.min.break</code></td>
<td>
<p>During coefficient optimization if the error (in pixels) always exceeds this value the estimation will stop estimating the position of additional checkerboards.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_start.param">start.param</code></td>
<td>
<p>An set of fixed starting parameters to be used during coefficient optimization. This parameter is intended primarily for debugging.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_sx">sx</code></td>
<td>
<p>Used for de-bugging.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_sy">sy</code></td>
<td>
<p>Used for de-bugging.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_print.progress">print.progress</code></td>
<td>
<p>a logical indicating whether the progress of the function should be printed while running. This includes the error in grid re-sampling, an iteration count during optimization and other outputs relating to the optimization.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_print.tab">print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_object">object</code></td>
<td>
<p>a list of class <code>"dltCalibrateCameras"</code> (the output of <code>dltCalibrateCameras()</code>).</p>
</td></tr>
<tr><td><code id="dltCalibrateCameras_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calibration is the most challenging step in stereo camera data collection. Most fundamentally, DLT calibration requires a set of 3D coordinates and their corresponding 2D pixel coordinates in each camera view in order to derive calibration coefficients (see <code><a href="#topic+dltCoefficients">dltCoefficients</a></code>). These coefficients can then be used to reconstruct any point in 3D given its 2D pixel coordinates in two or more camera views. DLT calibration has traditionally been done using a &quot;calibration object&quot;, typically a 3D box-shaped structure filled with markers at known 3D positions. Such objects require the use of high precision machining in order to achieve an accurate calibration and the calibration points are usually digitized manually.
</p>
<p>The <code>dltCalibrateCameras()</code> function provides a camera calibration routine that is easier to implement and potentially more accurate. This function uses the corners from a grid positioned in several different orientations within the calibration space to estimate the DLT calibration coefficients that minimize reconstruction error. The easiest method for obtaining these corner points is to print a checkerboard pattern (using <code><a href="#topic+drawCheckerboard">drawCheckerboard</a></code>), attach the pattern to flat, hard surface and use <code><a href="#topic+findCheckerboardCorners">findCheckerboardCorners</a></code> to automatically extract the pixel coordinates of the internal corners.
</p>
<p>The grid pattern should be photographed in at least four different positions and orientations spanning the volume to be calibrated (the tutorial files loaded with StereoMorph include eight different positions). Using only a couple of positions will result in uneven sampling of the calibration volume causing larger errors in some regions relative to others. Additionally, using only a single orientation of the checkerboard will produce higher errors along a particular dimension relative to the others. Once the pixel coordinates of the grid points (e.g. the internal corners of the checkerboard pattern) have been extracted from all of the calibration images, they should be read into an array using <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>. This function allows for the point order to be reversed along rows, columns or both. If one of the cameras views the pattern upside down relative to another camera or if the pattern is in a different orientation, the grid points may be extracted in a different order.  This can be fixed using the <code>row.reverse</code> and <code>col.reverse</code> arguments in <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>. It is <strong>essential</strong> that the grid points extracted from each camera view correspond to each other row-by-row or else the calibration will not work.
</p>
<p><code>dltCalibrateCameras()</code> first calls <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code> to downsample the number of grid points. <code>reduce.grid.dim</code> is the downsample number (the default is 3, meaning 3x3 or nine points per grid). Downsampling can be turned off by setting <code>reduce.grid.dim</code> to <code>0</code>, although this is not recommended as it will increase run-time substantially without increasing accuracy. A camera perspective model is fit to the full point set such that the number of points input to the coefficient optimization can be reduced (thereby reducing run-time) without losing any relevant information (see <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>). If <code>print.progress</code> is set to <code>TRUE</code>, the mean and maximum fit error is printed for each input grid. As the fitting does not take into account lens distortion, high fit errors may indicate large distortional effects.
</p>
<p>Since each checkerboard grid has been photographed in an arbitrary position and orientation, the 3D coordinates of the grid points are unknown. However, if the first grid is fixed, each additional grid can be described by applying six transformation parameters relative to the first (three translational and three rotational). Using the reduced grid point set, <code>dltCalibrateCameras()</code> uses <code>nlminb()</code> to search for the six transformation parameters per grid that minimizes the RMS error when the 3D coordinates are input (with the corresponding 2D coordinates) to <code><a href="#topic+dltCoefficients">dltCoefficients</a></code>. In effect, <code>dltCalibrateCameras()</code> solves for the position of each grid in 3D space using the error from <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> as an optimality criterion. Since the first grid is fixed, the optimization will search for 6*(n-1) parameters, where n is the number of separate grid orientations. <code>nlminb()</code> calls the function <code><a href="#topic+dltTransformationParameterRMSError">dltTransformationParameterRMSError</a></code>.
</p>
<p>In order to fully explore the parameter space, <code>dltCalibrateCameras()</code> calls <code>nlminb()</code> several times with a different set of randomly generated starting parameters to estimate the transformation parameters for each additional grid. The number of different sets of starting parameters is determined by <code>nlm.calls.max</code>. An initial optimization run is intended to quickly determine whether a particular set of starting parameters is likely to lead to convergence. The number of iterations for this initial optimization is determined by <code>nlm.iter.max.init</code> and the objective used in determining likely convergence is <code>objective.min.init</code>. If it is determined that the starting parameters are likely to lead to convergence below <code>objective.min</code>, <code>nlminb()</code> is allowed to continue optimizing. For each grid, the solution yielding the lowest error, or the first solution below the <code>objective.min</code> threshold, is retained for the next grid optimization.
</p>
<p>These optimal transformation parameters are then used to obtain the 3D coordinates of the original grid points (not downsampled). Once these 3D coordinates are known, the 3D and 2D pixel coordinates are input to <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> to obtain the 11 calibration coefficients per camera. For this reason, the calibration coefficient RMS Error (<code>coefficient.rmse</code>) returned will differ slightly from the reported final <code>nlminb()</code> minimum (<code>t.min</code>).
</p>
<p>If <code>c.run</code> is set to <code>TRUE</code>, <code>dltCalibrateCameras()</code> performs a second optimization on the calibration coefficients themselves. <code>nlminb()</code> is used, this time calling <code><a href="#topic+dltCoefficientRMSError">dltCoefficientRMSError</a></code>, to find the 11 calibration coefficients per view that minimizes the reconstruction RMS error. Note that <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> cannot be used as with the previous optimization because the coefficients must be an input. Running this second optimization seems to have little effect in increasing the accuracy of the calibration but is included as this may be useful for some stereo setups.
</p>


<h3>Value</h3>

<p>a list of class <code>"dltCalibrateCameras"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>cal.coeff</code></td>
<td>
<p>a matrix of 11 optimized DLT calibration coefficients per camera view.</p>
</td></tr>
<tr><td><code>coor.3d</code></td>
<td>
<p>the optimized 3D coordinates of the input grid points in <code>coor.2d</code>.</p>
</td></tr>
<tr><td><code>mean.reconstruct.rmse</code></td>
<td>
<p>the RMS error when <code>coor.2d</code> and the optimized calibration coefficients <code>cal.coeff</code> are input to <code><a href="#topic+dltReconstruct">dltReconstruct</a></code>.</p>
</td></tr>
<tr><td><code>coefficient.rmse</code></td>
<td>
<p>the RMS error when <code>coor.2d</code> and the optimized 3D coordinates <code>coor.3d</code> are input to <code><a href="#topic+dltCoefficients">dltCoefficients</a></code>.</p>
</td></tr>
<tr><td><code>t.param.final</code></td>
<td>
<p>the final transformation parameters reported by <code>nlminb()</code> from the first optimization. <code>'t.'</code> refers to the transformation optimization.</p>
</td></tr>
<tr><td><code>t.min</code></td>
<td>
<p>the minimum reported by <code>nlminb()</code> from the first optimization. This is the mean RMS error across all camera views returned by <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> for the downsampled grid points.</p>
</td></tr>
<tr><td><code>t.runtime</code></td>
<td>
<p>the run-time (in seconds) for the first optimization.</p>
</td></tr>
</table>
<p>if <code>c.run</code> is <code>FALSE</code>, the following are <code>NA</code>. Otherwise,
</p>
<table role = "presentation">
<tr><td><code>c.param.init</code></td>
<td>
<p>the initial parameters for the second optimization. <code>'c.'</code> refers to the coefficient optimization.</p>
</td></tr>
<tr><td><code>c.param.final</code></td>
<td>
<p>the final parameters reported by <code>nlminb()</code> from the second optimization.</p>
</td></tr>
<tr><td><code>c.min</code></td>
<td>
<p>the minimum reported by <code>nlminb()</code> from the second optimization. This is the mean RMS error across all camera views returned by <code><a href="#topic+dltReconstruct">dltReconstruct</a></code>.</p>
</td></tr>
<tr><td><code>c.iter</code></td>
<td>
<p>the number of iterations reported by <code>nlminb()</code> from the second optimization.</p>
</td></tr>
<tr><td><code>c.runtime</code></td>
<td>
<p>the run-time (in seconds) for the second optimization.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltTestCalibration">dltTestCalibration</a></code>,
<code><a href="#topic+dltCoefficients">dltCoefficients</a></code>,
<code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>,
</p>
<p><code><a href="#topic+transformPlanarCalibrationCoordinates">transformPlanarCalibrationCoordinates</a></code>,
<code><a href="#topic+dltTransformationParameterRMSError">dltTransformationParameterRMSError</a></code>,
</p>
<p><code><a href="#topic+dltCoefficientRMSError">dltCoefficientRMSError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SET NUMBER OF INTERNAL CORNERS FOR CALIBRATION GRIDS
nx &lt;- 21
ny &lt;- 14

## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CHECKERBOARD CORNERS FROM CALIBRATION IMAGE SET
## THE TUTORIAL INCLUDES 8 CALIBRATION IMAGES FROM TWO CAMERA VIEWS
file &lt;- matrix(c(paste0(fdir, "cal_a", 1:8, "_v1.txt"), 
  paste0(fdir, "cal_a", 1:8, "_v2.txt")), ncol=2)

## READ IN CHECKERBOARD CORNERS
## NOTE THAT col.reverse IS USED TO MAKE POINTS CORRESPOND
coor.2d &lt;- readCheckerboardsToArray(file=file, nx=nx, ny=ny, col.reverse=TRUE)

## SET GRID SIZE (IN MM)
grid.size &lt;- 6.347889

## Not run: 
## CALIBRATE CAMERAS
## TO REDUCE RUN-TIME, WE JUST USE CORNERS FROM TWO IMAGES (1 AND 5)
dlt_calibrate_cameras &lt;- dltCalibrateCameras(coor.2d=coor.2d[, , c(1, 5), ], nx=nx, 
  grid.size=grid.size, c.run=FALSE, print.progress=TRUE)

## RUN CALIBRATION ON ALL IMAGES, ACCURACY IS GREATLY IMPROVED
dlt_calibrate_cameras &lt;- dltCalibrateCameras(coor.2d=coor.2d, nx=nx, 
  grid.size=grid.size, c.run=FALSE, print.progress=TRUE)

## PRINT SUMMARY
summary(dlt_calibrate_cameras)

## End(Not run)
</code></pre>

<hr>
<h2 id='dltCoefficientRMSError'>Returns the error during calibration coefficient optimization</h2><span id='topic+dltCoefficientRMSError'></span>

<h3>Description</h3>

<p>Returns the RMS error from <code><a href="#topic+dltReconstruct">dltReconstruct</a></code> when optimizing the calibration coefficients. This function is called internally by <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltCoefficientRMSError(p, coor.2d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltCoefficientRMSError_+3A_p">p</code></td>
<td>
<p>a vector of the current, 11-parameter calibration coefficients.</p>
</td></tr>
<tr><td><code id="dltCoefficientRMSError_+3A_coor.2d">coor.2d</code></td>
<td>
<p>a four-dimensional array of grid points passed from <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean RMS error from <code><a href="#topic+dltReconstruct">dltReconstruct</a></code> across all views.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+transformPlanarCalibrationCoordinates">transformPlanarCalibrationCoordinates</a></code>,
<code><a href="#topic+dltReconstruct">dltReconstruct</a></code>,
<code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>
</p>

<hr>
<h2 id='dltCoefficients'>Computes DLT coefficients for a stereo camera setup</h2><span id='topic+dltCoefficients'></span><span id='topic+summary.dltCoefficients'></span><span id='topic+print.summary.dltCoefficients'></span>

<h3>Description</h3>

<p>This function takes 3D coordinates and their corresponding 2D coordinates in one or more camera views and returns DLT calibration coefficients. The DLT coefficients can then be used in 3D reconstruction and calculation of epipolar lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltCoefficients(coor.3d, coor.2d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltCoefficients_+3A_coor.3d">coor.3d</code></td>
<td>
<p>a three-column matrix of 3D coordinates.</p>
</td></tr>
<tr><td><code id="dltCoefficients_+3A_coor.2d">coor.2d</code></td>
<td>
<p>an three-dimensional array of 2D pixel coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes 3D coordinates and their corresponding 2D coordinates in one or more camera views and returns DLT calibration coefficients. Note that to find the calibration coefficient for a particular camera view, only the pixel coordinates in that camera view and their corresponding 3D coordinates are used. Thus, it is possible to derive calibration coefficients for several cameras without any overlap among the views in the points used to derive the calibration coefficients. Any missing values (either in <code>coor.3d</code> or pixel coordinates missing in a particular view in <code>coor.2d</code>) can be input as <code>NA</code>; they will be ignored.
</p>
<p>The requirements for the structure of the <code>coor.2d</code> array are as follows. The first dimension of <code>coor.2d</code> is the number of points used in calculating the DLT coefficients. The number of elements in the first dimension of <code>coor.2d</code> must match the number of rows in <code>coor.3d</code> and these must be corresponding points (though some may be <code>NA</code>). The second dimension of <code>coor.2d</code> should be two as these are x,y-coordinates. The third dimension of <code>coor.2d</code> is the number of camera views. This will correspond to the number of columns in the returned calibration coefficient matrix.
</p>


<h3>Value</h3>

<p>a list of class <code>"dltCoefficients"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>cal.coeff</code></td>
<td>
<p>the calibration coefficient matrix.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>the root-mean-square error for each camera view.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the Matlab function <code>dlt_reconstruct()</code> written by T Hedrick.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Abdel-Aziz, Y.I., Karara, H.M. (1971) Direct linear transformation into object space coordinates in close-range photogrammetry. <em>Proc. Symp. on Close-Range Photogrammetry</em> (University of Illinois at Urbana-Champaign).
</p>
<p>Hedrick, T.L. (2008) Software techniques for two- and three-dimensional kinematic measurements of biological and biomimetic systems. <em>Bioinspiration &amp; Biomimetics</em>, <b>3</b> (034001).
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, <code><a href="#topic+findCheckerboardCorners">findCheckerboardCorners</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SET NUMBER OF INTERNAL CORNERS AND ROWS
nx &lt;- 21
ny &lt;- 14

## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## GET FILE PATHS FOR PIXEL COORDINATES FROM CALIBRATION IMAGES 1 AND 5
file2d &lt;- matrix(c(paste0(fdir, "cal_a", c(1, 5), "_v1.txt"), 
  paste0(fdir, "cal_a", c(1, 5), "_v2.txt")), ncol=2)

## READ INTO ARRAY
## THESE ARE THE 2D COORDINATES USED IN THE CALIBRATION
coor.2d &lt;- readCheckerboardsToArray(file=file2d, nx=nx, ny=ny, col.reverse=TRUE)

## REDUCE ARRAY DIMENSIONS TO THREE
## THIS STACKS MULTIPLE VIEWS ON TOP OF EACH OTHER INTO THE SAME MATRIX
coor.2d &lt;- apply(coor.2d, c(2, 4), matrix, byrow=FALSE)

## GET FILE PATH FOR CORRESPONDING 3D COORDINATES
file3d &lt;- paste0(fdir, "cal_3d_coor.txt")

## READ 3D POINTS INTO MATRIX
coor.3d &lt;- as.matrix(read.table(file=file3d))

## FIND THE DLT COEFFICIENTS
dlt_coeffcients &lt;- dltCoefficients(coor.3d=coor.3d, coor.2d=coor.2d)

## PRINT THE SUMMARY
summary(dlt_coeffcients)

## NOTE THAT EACH CAMERA VIEW IS CALIBRATED SEPARATELY
## GIVES THE EXACT SAME RESULT
dltCoefficients(coor.3d=coor.3d, coor.2d=coor.2d[, , 1])
</code></pre>

<hr>
<h2 id='dltEpipolarDistance'>Finds the distance between a point and a self-epipolar line</h2><span id='topic+dltEpipolarDistance'></span>

<h3>Description</h3>

<p>Given the same point in two camera views, this function finds the distance between the point in the second camera view and a epipolar line in the second view, as determined from the point in the first view. The option is also available to return the mean reciprocal epipolar distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltEpipolarDistance(p1, p2, cal.coeff, reciprocal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltEpipolarDistance_+3A_p1">p1</code></td>
<td>
<p>an x,y vector or two-column matrix of a point or points in the camera view corresponding to the first column of <code>cal.coeff</code>. This point will be used to generate an epipolar line in the second view.</p>
</td></tr>
<tr><td><code id="dltEpipolarDistance_+3A_p2">p2</code></td>
<td>
<p>an x,y vector or two-column matrix of a point or points in a second camera view, corresponding to the second column of <code>cal.coeff</code>. The distance will be measured from this point to the epipolar line of <code>p1</code>.</p>
</td></tr>
<tr><td><code id="dltEpipolarDistance_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a two-column matrix of DLT calibration coefficients, where each column corresponds to the views from which <code>p1</code> and <code>p2</code> were taken, respectively.</p>
</td></tr>
<tr><td><code id="dltEpipolarDistance_+3A_reciprocal">reciprocal</code></td>
<td>
<p>a logical indicating whether epipolar distance should be calculated reciprocally and then averaged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a stereo camera setup, a point in one camera view must fall somewhere along a line in a second camera view. This line is called its epipolar line. Due to error in manually selecting the same point in two camera views and error in the calibration, the epipolar line of the point in the first view will not intersect exactly with the same point in the second view. This distance between a point and the epipolar line of the same point in another view is the epipolar distance (or error).
</p>
<p>The epipolar distance can be calculated between the point in the second view and the epipolar line of the point in the first view or between the point in the first view and the epipolar line of the point in the second view; the choice is arbitrary. This function performs the former. If a user would like to perform the latter, simply switch <code>p1</code> with <code>p2</code> <em>and</em> reverse the column order of <code>cal.coeff</code> (see &quot;Examples&quot;). Another possibility is to perform both distance calculations and return an average (mean reciprocal epipolar distance). This can be done by setting <code>reciprocal</code> to <code>TRUE</code>.
</p>
<p>Although a stereo camera system may consist of more than two cameras, the coefficients of only two cameras should be input to <code>dltEpipolarDistance()</code>. Only the coefficients of the two camera views for which epipolar distances are being calculated are relevant. Currently, this function only works with the 11-parameter DLT model.
</p>
<p>A few options for input of <code>p1</code> and <code>p2</code> are available. If a single point is input for both, the epipolar distance is calculated for these two points. If a matrix of points is input for both (of the same dimensions), the epipolar distance is calculated pair-wise - points in the same row are treated as the same point. Lastly, if a single point is input as <code>p1</code> and a matrix is input as <code>p2</code>, the epipolar distance is calculated for <code>p1</code> relative to all points in <code>p2</code> (see &quot;Examples&quot;).
</p>


<h3>Value</h3>

<p>a vector of the epipolar distance(s).
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, <code><a href="#topic+dltEpipolarLine">dltEpipolarLine</a></code>, <code><a href="#topic+dltNearestPointOnEpipolar">dltNearestPointOnEpipolar</a></code>, 
</p>
<p><code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CALIBRATION COEFFICIENTS IN TWO CAMERA STEREO SETUP
cc_file &lt;- paste0(fdir, "cal_coeffs.txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=cc_file))

## GET LANDMARKS IN FIRST CAMERA VIEW
lm_files &lt;- paste0(fdir, c("lm_2d_a1_v1.txt", "lm_2d_a1_v2.txt"))

## READ LANDMARKS INTO MATRIX
lm.array &lt;- readLandmarksToArray(file=lm_files, row.names=1)

## FIND EPIPOLAR DISTANCE BETWEEN TWO SINGLE LANDMARKS
## EPIPOLAR DISTANCE (ERROR) IS AROUND 7 PIXELS
## IDENTIFYING THE EXACT SAME POINT IN TWO VIEWS MANUALLY IS CHALLENGING...
dltEpipolarDistance(p1=lm.array[1, , 1], p2=lm.array[1, , 2], cal.coeff=cal.coeff)

## FIND EPIPOLAR DISTANCE USING EPIPOLAR FROM SECOND VIEW INSTEAD
dltEpipolarDistance(p1=lm.array[1, , 2], p2=lm.array[1, , 1], cal.coeff=cal.coeff[, 2:1])

## FIND MEAN RECIPROCAL EPIPOLAR DISTANCE BETWEEN TWO SINGLE LANDMARKS
## THIS IS THE AVERAGE OF THE PREVIOUS TWO DISTANCES
dltEpipolarDistance(p1=lm.array[1, , 1], p2=lm.array[1, , 2], cal.coeff=cal.coeff, 
  reciprocal=TRUE)

## FIND EPIPOLAR DISTANCES BETWEEN ALL LANDMARKS
## PROCEEDS PAIRWISE BECAUSE p1 AND p2 HAVE THE SAME DIMENSIONS
dltEpipolarDistance(p1=lm.array[, , 1], p2=lm.array[, , 2], cal.coeff=cal.coeff)

## FIND EPIPOLAR DISTANCES BETWEEN FIRST LANDMARK AND ALL LANDMARKS
## HERE THE EPIPOLAR DISTANCES ARE HIGH BECAUSE ONLY THE FIRST LANDMARK
##  CORRESPONDS
## THE REMAINING POINTS ARE NOT THE SAME LANDMARK
dltEpipolarDistance(p1=lm.array[1, , 1], p2=lm.array[, , 2], cal.coeff=cal.coeff)

</code></pre>

<hr>
<h2 id='dltEpipolarLine'>Finds a epipolar or self-epipolar line</h2><span id='topic+dltEpipolarLine'></span>

<h3>Description</h3>

<p>This function takes a point in one camera view and returns either its epipolar line in another camera view or its epipolar line in that same camera view (self-epipolar line).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltEpipolarLine(p, cal.coeff1, cal.coeff2 = NULL, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltEpipolarLine_+3A_p">p</code></td>
<td>
<p>vector of x,y pixel coordinates for a point in an image.</p>
</td></tr>
<tr><td><code id="dltEpipolarLine_+3A_cal.coeff1">cal.coeff1</code></td>
<td>
<p>DLT calibration coefficients corresponding to the camera view from which <code>p</code> is taken or a two-column matrix of calibration coefficients in which the first column corresonds to the camera view from which <code>p</code> is taken and the second column corresponds to an additional camera view.</p>
</td></tr>
<tr><td><code id="dltEpipolarLine_+3A_cal.coeff2">cal.coeff2</code></td>
<td>
<p>in the case that <code>cal.coeff1</code> is a single column matrix, these are the DLT calibration coefficients corresponding to a camera view in a stereo camera setup other than that from which <code>p</code> is taken.</p>
</td></tr>
<tr><td><code id="dltEpipolarLine_+3A_self">self</code></td>
<td>
<p>a logical indicating whether the epipolar line returned should be a self-epipolar line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a stereo camera setup, a point in one camera view must fall somewhere along a line in a second camera view. This line is called its epipolar line. If a second point is taken anywhere along this epipolar line in the second camera and its epipolar line is found in the first camera, the original point must fall along this line. The epipolar line in the first camera view, along which the original point falls, is called its self-epipolar line (Yakutieli et al. 2007). <code>dltEpipolarLine()</code> uses DLT calibration coefficients (see <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>) to find the epipolar or self-epipolar line for a given point in a stereo camera setup.
</p>
<p>Although a stereo camera system may consist of more than two cameras, the coefficients of only two cameras should be input to <code>dltEpipolarLine()</code>. Only the coefficients of the two cameras between which epipolar lines are being calculated are relevant. These two columns of coefficients can be input as one matrix (to <code>cal.coeff1</code>) or as two separate, one-column matrices (to <code>cal.coeff1</code> and <code>cal.coeff2</code>).
</p>
<p>Currently, <code>dltEpipolarLine()</code> only works with the 11-parameter DLT model.
</p>


<h3>Value</h3>

<p><code>dltEpipolarLine()</code> outputs the resulting epipolar line in two forms: slope-intercept coefficients (<code>m</code> and <code>b</code>) and two points on the line (<code>l1</code> and <code>l2</code>). These are stored in a list as follows:
</p>
<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>the slope of the epipolar line.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the y-intercept of the epipolar line.</p>
</td></tr>
<tr><td><code>l1</code></td>
<td>
<p>one point on the epipolar line.</p>
</td></tr>
<tr><td><code>l2</code></td>
<td>
<p>a second point on the epipolar line.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the Matlab function <code>partialdlt()</code> written by T Hedrick. A Olsen added the self-epipolar functionality after Yekutieli et al. 2007.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Abdel-Aziz, Y.I., Karara, H.M. (1971) Direct linear transformation into object space coordinates in close-range photogrammetry. <em>Proc. Symp. on Close-Range Photogrammetry</em> (University of Illinois at Urbana-Champaign).
</p>
<p>Yekutieli, Y.,  Mitelman, R., Hochner, B. &amp; Flash, T. (2007). Analyzing Octopus Movements Using Three-Dimensional Reconstruction. <em>Journal of Neurophysiology</em>, <b>98</b>, 1775&ndash;1790.
</p>
<p>Hedrick, T.L. (2008) Software techniques for two- and three-dimensional kinematic measurements of biological and biomimetic systems. <em>Bioinspiration &amp; Biomimetics</em>, <b>3</b> (034001).
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, <code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>, <code><a href="#topic+dltNearestPointOnEpipolar">dltNearestPointOnEpipolar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CALIBRATION COEFFICIENTS IN TWO CAMERA STEREO SETUP
cc_file &lt;- paste0(fdir, "cal_coeffs.txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=cc_file))

## GET LANDMARKS IN FIRST CAMERA VIEW
lm_file &lt;- paste0(fdir, "lm_2d_a1_v1.txt")

## READ LANDMARKS INTO MATRIX
lm.matrix &lt;- readLandmarksToMatrix(file=lm_file, row.names=1)

## FIND EPIPOLAR LINE IN SECOND CAMERA VIEW
epipolar &lt;- dltEpipolarLine(p=lm.matrix['occipital_condyle', ], cal.coeff1=cal.coeff)

## FIND SELF-EPIPOLAR LINE (IN FIRST CAMERA VIEW)
self_epipolar &lt;- dltEpipolarLine(p=lm.matrix['occipital_condyle', ], cal.coeff1=cal.coeff, 
  self=TRUE)

## CONFIRM THAT DISTANCE FROM ORIGINAL POINT TO SELF-EPIPOLAR LINE IS ZERO
distancePointToLine(p=lm.matrix['occipital_condyle', ], l1=self_epipolar)
</code></pre>

<hr>
<h2 id='dltInverse'>Returns ideal pixel coordinates of 3D point(s) in a stereo camera setup</h2><span id='topic+dltInverse'></span>

<h3>Description</h3>

<p>This function takes 3D coordinates and the DLT calibration coefficients corresponding to one camera view and returns the ideal pixel coordinates of the 3D points in that camera view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltInverse(cal.coeff, coor.3d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltInverse_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a single column matrix of DLT calibration coefficients for one camera view.</p>
</td></tr>
<tr><td><code id="dltInverse_+3A_coor.3d">coor.3d</code></td>
<td>
<p>a three-column matrix of 3D coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code><a href="#topic+dltReconstruct">dltReconstruct</a></code> is used to reconstruct points in 3D based on pixel coordinates from two or more camera views, these 3D points can be projected back into any camera view at their &quot;ideal&quot; pixel coordinates (the &quot;inverse&quot; of reconstruction). The &quot;ideal&quot; pixel coordinates represent the pixel coordinates in each view if there were no error (i.e. all pixel coordinates in every view correspond to the exact same point in 3D). In any real-world system there is some error and these ideal pixel coordinates are compared to the original pixel coordinates used in the reconstruction to assess reconstruction error. <code>dltInverse()</code> is called by <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> and <code><a href="#topic+dltEpipolarLine">dltEpipolarLine</a></code>.
</p>
<p>Since <code>dltInverse()</code> only projects the 3D coordinates into a single camera view, only one column of the DLT coefficients should be input. Currently, <code>dltInverse()</code> only works with the 11-parameter DLT model.
</p>


<h3>Value</h3>

<p>a two-column matrix of pixel coordinates of all points in <code>coor.3d</code> in the camera view corresponding to <code>cal.coeff</code>.
</p>


<h3>Note</h3>

<p>This function was modified by A Olsen from the Matlab function <code>dlt_inverse()</code> written by T Hedrick.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Abdel-Aziz, Y.I., Karara, H.M. (1971) Direct linear transformation into object space coordinates in close-range photogrammetry. <em>Proc. Symp. on Close-Range Photogrammetry</em> (University of Illinois at Urbana-Champaign).
</p>
<p>Hedrick, T.L. (2008) Software techniques for two- and three-dimensional kinematic measurements of biological and biomimetic systems. <em>Bioinspiration &amp; Biomimetics</em>, <b>3</b> (034001).
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>,
<code><a href="#topic+dltReconstruct">dltReconstruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CALIBRATION COEFFICIENTS IN TWO CAMERA STEREO SETUP
cc_file &lt;- paste0(fdir, "cal_coeffs.txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=cc_file))

## READ LANDMARKS INTO MATRIX
lm.matrix &lt;- readLandmarksToMatrix(file=paste0(fdir, "lm_3d_a1.txt"), row.names=1)

## GET IDEAL 2D COORDINATES OF 3D POINTS IN FIRST CAMERA VIEW
dltInverse(cal.coeff[, 1], lm.matrix)

## GET IDEAL 2D COORDINATES OF 3D POINTS IN SECOND CAMERA VIEW
dltInverse(cal.coeff[, 2], lm.matrix)
</code></pre>

<hr>
<h2 id='dltMatchCurvePoints'>Matches curve points between two camera views</h2><span id='topic+dltMatchCurvePoints'></span><span id='topic+summary.dltMatchCurvePoints'></span><span id='topic+print.summary.dltMatchCurvePoints'></span>

<h3>Description</h3>

<p>This function uses DLT calibration coefficients to find corresponding points along a curve viewed from two different cameras in stereo camera setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltMatchCurvePoints(lm.list, cal.coeff, min.direct.tangency = 25, 
                    min.fill.tangency = 0, epi.err.weight = 1, 
                    rec.err.weight = 0)
	
## S3 method for class 'dltMatchCurvePoints'
summary(object, print.tab = '', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltMatchCurvePoints_+3A_lm.list">lm.list</code></td>
<td>
<p>a list of curve points from two camera views (see <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>). <code>lm.list</code> can include landmarks; these will be returned unchanged.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a two-column matrix of DLT calibration coefficients, where each column corresponds to the views from which points in <code>lm.list</code> were taken.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_min.direct.tangency">min.direct.tangency</code></td>
<td>
<p>Threshold (in degrees) to determine which points will be matched during initial (direct) matching. Regions of the curve that have a tangent less than this value relative to the epipolar line will be skipped.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_min.fill.tangency">min.fill.tangency</code></td>
<td>
<p>Threshold (in degrees) to determine which points will be matched during second step (fill) of matching. Regions of the curve that have a tangent less than this value relative to the epipolar line will be skipped.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_epi.err.weight">epi.err.weight</code></td>
<td>
<p>Weight of epipolar error in determining matching points during second step of matching. This weight is taken relative to <code>rec.err.weight</code>.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_rec.err.weight">rec.err.weight</code></td>
<td>
<p>Weight of reconstruction error in determining matching points during second step of matching. This weight is taken relative to <code>epi.err.weight</code>.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_object">object</code></td>
<td>
<p>a list of class <code>"dltMatchCurvePoints"</code> (the output of <code>dltMatchCurvePoints()</code>).</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_print.tab">print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td></tr>
<tr><td><code id="dltMatchCurvePoints_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point reconstruction with a stereo camera setup requires pixel coordinates of the same point in two or more camera views. Curves can also be reconstructed in a stereo camera setup if reconstructed as a series of single points. This, however, poses an additional challenge: that of identifying the same point on a curve viewed from two different perspectives. A point half-way along the curve in one view will not necessarily correspond to a point half-way along the same curve in another view. <code>dltMatchCurvePoints()</code> solves this challenge by using epipolar geometry informed by the DLT calibration coefficients (Yekutieli et al. 2007).
</p>
<p>In a stereo camera setup, a point in one camera view must fall somewhere along a line in a second camera view. This line is called its epipolar line. If the same curve has been digitized in two camera views, the epipolar line of a point on the first curve should intersect the curve in the second camera view. The point at which the epipolar line intersects the curve in the second view represents the corresponding point on the second curve. <code>dltMatchCurvePoints()</code> iterates through all the points on one curve and uses epipolar geometry to identify the corresponding point on a second curve. The corresponding point is identified as a point on the epipolar line that is closest to the curve in the second view (rather than finding the intersection, per se). For more details on the use of epipolar geometry to solve for corresponding points see Yekutieli et al. (2007).
</p>
<p>Two different types of curve point input to <code>dltMatchCurvePoints()</code> are possible. The first type is a list with two elements (<code>list[[1]]</code> and <code>list[[2]]</code>), containing the curve points of the first and second camera view, respectively. The second type is a list of the same form as the landmark list described in <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>. The main elements of the landmark list are the landmarks and curves (<code>list[['landmark1']]</code>, <code>list[['curve1']]</code>, etc.). Each main element then has two elements (e.g. <code>list[['curve1']][[1]]</code>, <code>list[['curve1']][[2]]</code>) corresponding to the first and second camera views, respectively. The curve points themselves should be densely sampled pixel coordinates (e.g. single pixel spacing) in order to improve matching accuracy.
</p>
<p><code>dltMatchCurvePoints()</code> returns the landmark list as the element <code>match.lm.list</code> in the same format as the input, except that all curve points will be corresponding points. Note that list input is used, rather than a matrix, because the number of curve points may differ between the two views. Once the corresponding curve points are identified, however, the number of curve points in each view will be equal. Landmarks and curves containing less than three points are ignored and returned just as input. In this way, all landmarks and curve points can be passed through <code>dltMatchCurvePoints()</code> without having to be processed separately.
</p>
<p>Although a stereo camera system may consist of more than two cameras, the coefficients of only two cameras should be input to <code>dltMatchCurvePoints()</code>. Only the coefficients of the two camera views for which corresponding curve points are being identified are relevant. Currently, this function can only match curve points between two camera views using the 11-parameter DLT model.
</p>
<p>The curve points chosen as the reference are used to generate epipolar lines in a second camera view. The results will differ slightly depending on which view is chosen as a reference. By default, <code>dltMatchCurvePoints()</code> uses the curve with the maximum number of points as a reference. Users can specify which view is to be used as reference through <code>ref.view</code>. Setting <code>ref.view</code> to &quot;min&quot; will use the curve with the minimum number of points as a reference. Setting <code>ref.view</code> to 1 or 2 will use the first view or second view as a reference, respectively.
</p>
<p>As <code>dltMatchCurvePoints()</code> steps through each point on the reference curve, it searches for the closest point on the epipolar line to the second curve. Rather than search for the closest point among all of the second curve points, <code>dltMatchCurvePoints()</code> only searches over a sliding window of points. <code>window.size</code> is the number of curve points considered at each iteration in identifying the corresponding point. A lower <code>window.size</code> will decrease the run-time but will potentially cause the function to miss corresponding points. If <code>curve.pt.dist</code> values are low, the current <code>window.size</code> is probably appropriate. <code>window.size</code> can be increased if <code>curve.pt.dist</code> values are high (over several pixels).
</p>
<p>When the epipolar line is nearly parallel to the curve in the non-reference view, several points are equally likely to be the corresponding point and determining the actual corresponding point is impossible without additional information. The angle between the epipolar line and the points on the non-reference curve is referred to here as the tangency angle. When the tangency angle for points on the non-reference curve is less than <code>min.tangency.angle</code>, the current reference point is skipped. Additionally, when the points near a point on the non-reference curve are also very close to the epipolar line, a wrong match is more likely. Within the window of candidate points, the distance from each point to the epipolar line is calculated. The slope of these distances away from the point closest to the epipolar line (the minimum distance) is referred to here as the adjacent point distance slope. When the adjacent point distance slope is lower, the confidence that the minimum distance point is the correct match decreases. When this adjacent point distance slope is less than <code>min.dist.adj.slope</code>, the current reference point is skipped. The <code>min.tangency.angle</code> and <code>min.dist.adj.slope</code> are similar criteria, however the <code>min.dist.adj.slope</code> might provide more robust results with more irregular curves. Users might need to increase one or both of these values to obtain satisfactory results.
</p>
<p>When reference points are skipped, these are filled in at the end with straight lines extending between defined points to either side of the skipped regions. Straight lines are used because these regions are likely to be nearly linear, owing to their minimal deviation from the epipolar line.
</p>
<p>In addition to returning <code>match.lm.list</code>, <code>dltMatchCurvePoints()</code> also returns two vectors (or lists of vectors, depending on the format of <code>lm.list</code>) that can be used to assess the accuracy of the curve point matching. <code>epipolar.dist</code> is the epipolar distance between the epipolar line of the reference point and the corresponding point in the non-reference view. The first and last point are assumed to correspond, so there will be some epipolar error for these points. The remaining points are chosen on the epipolar line of the reference point, so their epipolar error will be zero. Future implementations may allow users to specify that corresponding points be on the curve in the second view and not necessarily on the epipolar line, in which case <code>epipolar.dist</code> will become more relevant. <code>curve.pt.dist</code> is the distance between the epipolar line and the nearest point on the curve in the second view for each curve point. If the exact same curve has been digitized in the two views, <code>curve.pt.dist</code> should be low (within a pixel or less).
</p>


<h3>Value</h3>

<p>a list of class <code>"dltMatchCurvePoints"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>match.lm.list</code></td>
<td>
<p>a landmark list of matched curve points (and landmarks if also input).</p>
</td></tr>
<tr><td><code>epipolar.dist</code></td>
<td>
<p>a list or vector of the epipolar distance between the epipolar line of the reference points and the corresponding non-reference point. In current implementation, all values will be zero except the start and end points.</p>
</td></tr>
<tr><td><code>curve.pt.dist</code></td>
<td>
<p>a list or vector of the distances from the chosen corresponding points and the nearest point on the non-reference curve.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was written by A Olsen based on the methodology described in Yekutieli et al. 2007.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Yekutieli, Y.,  Mitelman, R., Hochner, B. and Flash, T. (2007). Analyzing Octopus Movements Using Three-Dimensional Reconstruction. <em>Journal of Neurophysiology</em>, <b>98</b>, 1775&ndash;1790.
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>,
<code><a href="#topic+dltEpipolarLine">dltEpipolarLine</a></code>, 
<code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>, 
<code><a href="#topic+dltNearestPointOnEpipolar">dltNearestPointOnEpipolar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO LANDMARK DATA
file &lt;- paste0(fdir, "lm_2d_a2_v", 1:2, ".txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=paste0(fdir, "cal_coeffs.txt")))

## READ LANDMARKS INTO LIST
lm.list &lt;- readLandmarksToList(file=file, row.names=1)

## MATCH CURVE POINTS FOR ONE CURVE
## FIRST TYPE OF LANDMARK INPUT
## RETURNS LIST OF MATCHING POINTS WITHOUT CURVE NAME
dlt_match &lt;- dltMatchCurvePoints(lm.list$pterygoid_crest_R, cal.coeff)

## PRINT SUMMARY
summary(dlt_match)

## SET A DIFFERENT REFERENCE VIEW
## SECOND VIEW HAS 80 FEWER POINTS
## dlt_match &lt;- dltMatchCurvePoints(lm.list$pterygoid_crest_R, cal.coeff, ref.view=2)

## MATCH CURVE POINTS FOR ALL CURVES IN LIST
## SECOND TYPE OF LANDMARK INPUT
## RETURNS LIST OF ALL LANDMARKS AND MATCHED CURVE POINTS WITH CURVE NAMES
## dlt_match &lt;- dltMatchCurvePoints(lm.list, cal.coeff)
</code></pre>

<hr>
<h2 id='dltNearestPointOnEpipolar'>Returns the closest point on a epipolar line to a point or points</h2><span id='topic+dltNearestPointOnEpipolar'></span>

<h3>Description</h3>

<p>Given the same point in two camera views, this function finds the nearest point on the epipolar line of the point in the first view to a point or points in the second view.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltNearestPointOnEpipolar(p1, p2, cal.coeff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltNearestPointOnEpipolar_+3A_p1">p1</code></td>
<td>
<p>vector of x,y pixel coordinates for a point in the camera view corresponding to the first column of <code>cal.coeff</code>. This point will be used to generate an epipolar line in the second view.</p>
</td></tr>
<tr><td><code id="dltNearestPointOnEpipolar_+3A_p2">p2</code></td>
<td>
<p>an x,y vector or two-column matrix of a point or points in a second camera view, corresponding to the second column of <code>cal.coeff</code>. The nearest point on the epipolar line will be an orthogonal projection from a point in <code>p2</code>.</p>
</td></tr>
<tr><td><code id="dltNearestPointOnEpipolar_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a two-column matrix of DLT calibration coefficients, where each column corresponds to the views from which <code>p1</code> and <code>p2</code> were taken, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a stereo camera setup, a point in one camera view must fall somewhere along a line in a second camera view. This line is called its epipolar line. Due to error in manually selecting the same point in two camera views and error in the calibration, the epipolar line of the point in the first view will not intersect exactly with the same point in the second view. The nearest point on the epipolar line is a point at a minimum distance from the point in the second view. This is equivalent to the orthogonal projection (<code><a href="#topic+orthogonalProjectionToLine">orthogonalProjectionToLine</a></code>) of the point in the second view onto the epipolar line of the point in the first view. The length of this line is the epipolar distance (<code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>).
</p>
<p><code>dltNearestPointOnEpipolar()</code> first finds the epipolar line of <code>p1</code>, a point in the first camera view, and then finds the point on this epipolar line nearest to point(s) <code>p2</code> in the second camera view. If <code>p2</code> is a single point, <code>dltNearestPointOnEpipolar()</code> finds the point on the epipolar line closest to <code>p2</code>. If <code>p2</code> is a matrix of points, the point in <code>p2</code> closest to the epipolar line is first identified and then the point on the epipolar line closest to this point is determined.
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>matching.pt</code></td>
<td>
<p>an x,y vector of the point on the epipolar line of <code>p1</code> closest to point(s) <code>p2</code>.</p>
</td></tr>
<tr><td><code>min.idx</code></td>
<td>
<p>the index in <code>p2</code> of the nearest point to the epipolar line of <code>p1</code>. If <code>p2</code> is a single point (vector), <code>min.idx</code> will be 1.</p>
</td></tr>
<tr><td><code>p2.dist</code></td>
<td>
<p>the epipolar distance between <code>matching.pt</code> and the point in <code>p2</code> at the <code>min.idx</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, <code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>, <code><a href="#topic+dltEpipolarLine">dltEpipolarLine</a></code>, <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CALIBRATION COEFFICIENTS IN TWO CAMERA STEREO SETUP
cc_file &lt;- paste0(fdir, "cal_coeffs.txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=cc_file))

## GET LANDMARKS IN FIRST CAMERA VIEW
lm_files &lt;- paste0(fdir, c("lm_2d_a1_v1.txt", "lm_2d_a1_v2.txt"))

## READ LANDMARKS INTO MATRIX
lm.array &lt;- readLandmarksToArray(file=lm_files, row.names=1)

## FIND THE NEAREST POINT ON THE EPIPOLAR LINE OF P1
dltNearestPointOnEpipolar(p1=lm.array[3, , 1], p2=lm.array[3, , 2], cal.coeff=cal.coeff)

## FIND THE NEAREST POINT ON THE EPIPOLAR LINE OF P1
## THIS TIME USING ALL LANDMARKS IN THAT VIEW
## FUNCTION IDENTIFIES THE CORRECT LANDMARK IN THE SECOND VIEW AS THE SAME LANDMARK
dltNearestPointOnEpipolar(p1=lm.array[3, , 1], p2=lm.array[, , 2], cal.coeff=cal.coeff)

</code></pre>

<hr>
<h2 id='dltReconstruct'>Reconstructs the 3D position of points in two or more camera views</h2><span id='topic+dltReconstruct'></span><span id='topic+summary.dltReconstruct'></span><span id='topic+print.summary.dltReconstruct'></span>

<h3>Description</h3>

<p>This function takes 2D pixel coordinates of a point or points from two more camera views and uses DLT coefficients to reconstruct their position in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltReconstruct(cal.coeff, coor.2d, min.views = 2)

## S3 method for class 'dltReconstruct'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltReconstruct_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a matrix of DLT calibration coefficients. The columns correspond to each camera view and the column order should match the camera view order of the landmarks in <code>coor.2d</code>.</p>
</td></tr>
<tr><td><code id="dltReconstruct_+3A_coor.2d">coor.2d</code></td>
<td>
<p>2D pixel coordinates from two or more camera views. Format can be either a landmark matrix, list or array.</p>
</td></tr>
<tr><td><code id="dltReconstruct_+3A_min.views">min.views</code></td>
<td>
<p>the minimum number of views required for a point to be reconstructed in 3D.</p>
</td></tr>
<tr><td><code id="dltReconstruct_+3A_object">object</code></td>
<td>
<p>a list of class <code>"dltReconstruct"</code> (the output of <code>dltReconstruct()</code>).</p>
</td></tr>
<tr><td><code id="dltReconstruct_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses DLT coefficients (calculated using <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, for example) to reconstruct the 3D position of points, based on their 2D position in two or more camera views. 2D pixel coordinates can be input as a landmark matrix (<code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>), as a list (<code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>) or as an array (<code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>).
</p>
<p>A minimum of two views is required for 3D reconstruction although additional camera views can be used, potentially improving reconstruction accuracy. Points that are present in fewer views than specified by <code>min.views</code> will be assigned NA values in the returned 3D matrix (<code>coor.3d</code>).
</p>
<p>After 3D reconstruction, <code>dltReconstruct()</code> performs the inverse operation, taking the reconstructed, 3D coordinates and solving for the 2D position of the points in each camera view. These inverse 2D coordinates are compared with the original coordinates and their difference is returned as the root-mean-square (RMS) reconstruction error (<code>list$rmse</code>). This error is similar to the epipolar distance (<code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>). The <code>summary()</code> function can be used to view the error by landmark.
</p>
<p>Currently, <code>dltReconstruct()</code> only works with the 11-parameter DLT model.
</p>


<h3>Value</h3>

<p>a list of class <code>"dltReconstruct"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>coor.3d</code></td>
<td>
<p>a 2D or 3D landmark matrix.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>the root-mean-square reconstruction error (in pixels).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the Matlab function <code>dlt_reconstruct()</code> written by T Hedrick.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Abdel-Aziz, Y.I., Karara, H.M. (1971) Direct linear transformation into object space coordinates in close-range photogrammetry. <em>Proc. Symp. on Close-Range Photogrammetry</em> (University of Illinois at Urbana-Champaign).
</p>
<p>Hedrick, T.L. (2008) Software techniques for two- and three-dimensional kinematic measurements of biological and biomimetic systems. <em>Bioinspiration &amp; Biomimetics</em>, <b>3</b> (034001).
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>,
<code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>,
<code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>,
</p>
<p><code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>,
<code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CALIBRATION COEFFICIENTS IN TWO CAMERA STEREO SETUP
cc_file &lt;- paste0(fdir, "cal_coeffs.txt")

## LOAD COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=cc_file))

## GET LANDMARKS IN FIRST CAMERA VIEW
lm_files &lt;- paste0(fdir, c("lm_2d_a1_v1.txt", "lm_2d_a1_v2.txt"))

## READ LANDMARKS INTO MATRIX
lm.matrix &lt;- readLandmarksToMatrix(file=lm_files, row.names=1)

## RECONSTRUCT LANDMARKS IN 3D (MATRIX INPUT)
dlt_recon &lt;- dltReconstruct(cal.coeff=cal.coeff, coor.2d=lm.matrix)


## OTHER POSSIBLE LANDMARK FORMAT INPUTS ##
## READ LANDMARKS INTO LIST
lm.list &lt;- readLandmarksToList(file=lm_files, row.names=1)

## RECONSTRUCT LANDMARKS IN 3D (LIST INPUT)
dlt_recon &lt;- dltReconstruct(cal.coeff=cal.coeff, coor.2d=lm.list)

## READ LANDMARKS INTO ARRAY
lm.array &lt;- readLandmarksToArray(file=lm_files, row.names=1)

## RECONSTRUCT LANDMARKS IN 3D (ARRAY INPUT)
dlt_recon &lt;- dltReconstruct(cal.coeff=cal.coeff, coor.2d=lm.array)
</code></pre>

<hr>
<h2 id='dltTestCalibration'>Tests the accuracy of a stereo camera calibration</h2><span id='topic+dltTestCalibration'></span><span id='topic+summary.dltTestCalibration'></span><span id='topic+print.summary.dltTestCalibration'></span>

<h3>Description</h3>

<p>This function uses a set of grid points, ideally other than those used in stereo camera calibration, to test calibration accuracy. Results of both distance-based and position-based accuracy tests are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltTestCalibration(cal.coeff, coor.2d, nx, sq.size, 
                   reciprocal = TRUE, align.princomp = FALSE)

## S3 method for class 'dltTestCalibration'
summary(object, print.tab = '', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltTestCalibration_+3A_cal.coeff">cal.coeff</code></td>
<td>
<p>a matrix of DLT calibration coefficients. The columns correspond to each camera view and the column order should match the camera view order in the fourth dimension of the <code>coor.2d</code> array.</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_coor.2d">coor.2d</code></td>
<td>
<p>a four-dimensional array of grid points. The first two dimensions correspond to each matrix of grid points, the third corresponds to each grid position/orientation and the fourth corresponds to each camera view. These can be read in from file by <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>.</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points in <code>coor.2d</code> are listed first by row). The number of points along the second dimension is calculated based on the total number of points per view and orientation.</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_sq.size">sq.size</code></td>
<td>
<p>the size of the grid squares in real-world units (e.g. millimeters).</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_reciprocal">reciprocal</code></td>
<td>
<p>a logical indicating whether epipolar distance should be calculated reciprocally and then averaged.</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_align.princomp">align.princomp</code></td>
<td>
<p>a logical indicating whether checkerboard corners should be aligned along principal coordinate axes prior to error testing (serves to describe error along axes that may be more physically meaningful than the initial, arbitrary coordinate system).</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_object">object</code></td>
<td>
<p>a list of class <code>"dltTestCalibration"</code> (the output of <code>dltTestCalibration()</code>).</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_print.tab">print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td></tr>
<tr><td><code id="dltTestCalibration_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the RMS errors reported by <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code> can be used to assess the accuracy of a stereo camera setup, these represent how well the DLT parameters fit the calibration point set and not the reconstruction accuracy per se. It has been argued that in order to obtain a true estimation of reconstruction accuracy, an independent assessment criterion is required (Challis &amp; Kerwin 1992). With the StereoMorph package, this is best accomplished by photographing a grid not used in the calibration and of a different square size (to test for proper scaling). These images are taken and the internal corners extracted just as in the calibration step (see <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>), again ensuring that the test images fully sample the calibration volume and that the extracted point orders correspond between the two views. The input format of <code>coor.2d</code> to <code>dltTestCalibration()</code> is the same format as the <code>coor.2d</code> input to <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.
</p>
<p><code>dltTestCalibration()</code> measures the calibration accuracy using two approaches: a distance-based approach and a position-based approach. For the distance-based approach (e.g. Tashman &amp; Anderst 2003; Brainerd et al. 2010), random pairs of grid points are chosen (without resampling), reconstructed and the distance between the reconstructed points is compared with the actual distance. The deviations from the true distance (interpoint distance error or IPD error) for each pair of points are returned in the <code>ipd.error</code> vector. <code>dltTestCalibration()</code> also measures IPD error of only adjacent points, returned in the vector <code>adj.pair.ipd.error</code>. With a sufficient number of grid points, adjacent points are close enough that one can test how IPD error varies as a function of the distance from the approximate center of the calibrated volume (<code>adj.pair.centroid.dist</code>) or along a particular dimension (<code>adj.pair.mean.pos</code>).
</p>
<p>One challenge in interpreting the IPD error, however, is that each deviation represents error in the x, y and z position of two points. This makes it difficult to assess the accuracy of a particular point or along a particular dimension. Since we do not know the 3D coordinates of a test grid placed at an arbitrary orientation in the calibration volume, we must find the best fit 3D position in order to assess positional accuracy. For the position-based approach, <code>dltTestCalibration()</code> takes an ideal grid of the same square size and dimensions and optimally aligns it with the reconstructed test points using <code><a href="#topic+findOptimalPointAlignment">findOptimalPointAlignment</a></code>. The reconstructed test points can then be compared with their corresponding reference points. These errors are returned in the matrix <code>aitr.error</code> (aligned ideal to reconstructed point position). This approach has the disadvantage that best fit alignment will tend to align the reference grid where the error is highest so as to minimize differences. This can decrease error where it is in actuality relatively high and vice versa.
</p>


<h3>Value</h3>

<p>a list of class <code>"dltTestCalibration"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>num.grids</code></td>
<td>
<p>the number of test calibration grids used in accuracy assessment.</p>
</td></tr>
<tr><td><code>epipolar.error</code></td>
<td>
<p>the epipolar error (distance) for every test calibration point. This is the reciprocal epipolar distance if <code>reciprocal</code> is <code>TRUE</code>. See <code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>.</p>
</td></tr>
<tr><td><code>epipolar.rmse</code></td>
<td>
<p>the root-mean-square error of <code>epipolar.error</code>.</p>
</td></tr>
<tr><td><code>ipd.error</code></td>
<td>
<p>a vector of the deviations from the true distance between random pairs of points (without resampling).</p>
</td></tr>
<tr><td><code>pair.dist</code></td>
<td>
<p>a vector of the true distances between the random pairs of points in <code>ipd.error</code>.</p>
</td></tr>
<tr><td><code>ipd.rmse</code></td>
<td>
<p>the root-mean-square error of <code>ipd.error</code>.</p>
</td></tr>
<tr><td><code>adj.pair.ipd.error</code></td>
<td>
<p>a vector of the deviations from the true distance between random pairs of adjacent points (without resampling).</p>
</td></tr>
<tr><td><code>adj.pair.mean.pos</code></td>
<td>
<p>a three-column matrix of the mean position (midpoint) of the adjacent pairs of points in <code>adj.pair.ipd.error</code>.</p>
</td></tr>
<tr><td><code>adj.pair.centroid.dist</code></td>
<td>
<p>a vector of the distances from each point in <code>adj.pair.mean.pos</code> to the centroid of all <code>adj.pair.mean.pos</code>.</p>
</td></tr>
<tr><td><code>aitr.error</code></td>
<td>
<p>a three-column matrix of the x, y and z position errors for the reconstructed test calibration points relative to optimally aligned ideal grid points.</p>
</td></tr>
<tr><td><code>aitr.dist.error</code></td>
<td>
<p>a vector of the distances between the reconstructed test calibration points and the optimally aligned ideal grid points. Note that ideally this distance should be zero so all values in this vector are positive.</p>
</td></tr>
<tr><td><code>aitr.dist.rmse</code></td>
<td>
<p>the RMS error (or deviation) of <code>aitr.dist.error</code>.</p>
</td></tr>
<tr><td><code>aitr.rmse</code></td>
<td>
<p>a vector of the RMS error (or deviation) of <code>aitr.error</code> along each dimension. This is very similar to the standard deviation of <code>aitr.error</code> along each dimension.</p>
</td></tr>
<tr><td><code>aitr.pos</code></td>
<td>
<p>a three-column matrix of the ideal grid points after best fit alignment to the reconstructed grid points.</p>
</td></tr>
<tr><td><code>aitr.centroid.dist</code></td>
<td>
<p>a vector of the distances between each AITR point and the centroid of all AITR points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>Challis, J.H. and Kerwin, D.G. (1992). Accuracy assessment and control point configuration when using the DLT for photogrammetry. <em>Journal of Biomechanics</em>, <b>25</b> (9), 1053&ndash;1058.
</p>
<p>Tashman, S. and Anderst, W. (2003). <em>In Vivo</em> Measurement of Dynamic Joint Motion Using High Speed Biplane Radiography and CT: Application to Canine ACL Deficiency. <em>Transactions of the ASME</em>, <b>125</b>, 238&ndash;245.
</p>
<p>Brainerd, E.L., Baier, D.B., Gatesy, S.M., Hedrick, T.L., Metzger, K.A., Gilbert, S.L and Crisco, J.J. (2010). X-ray reconstruction of moving morphology (XROMM): Precision, accuracy and applications in comparative biomechanics research. <em>Journal of Experimental Zoology</em>, <b>313A</b>, 262&ndash;279.
</p>
<p>For a general overview of DLT: <a href="http://kwon3d.com/theory/dlt/dlt.html">http://kwon3d.com/theory/dlt/dlt.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>,
<code><a href="#topic+dltCoefficients">dltCoefficients</a></code>,
<code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>,
<code><a href="#topic+dltEpipolarDistance">dltEpipolarDistance</a></code>,
<code><a href="#topic+findCheckerboardCorners">findCheckerboardCorners</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SET NUMBER OF INTERNAL ROWS AND COLUMNS
nx &lt;- 21
ny &lt;- 14

## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CHECKERBOARD CORNERS FROM TEST CALIBRATION IMAGE SET
file &lt;- matrix(c(paste0(fdir, "test_cal_a", 1:11, "_v1.txt"), 
  paste0(fdir, "test_cal_a", 1:11, "_v2.txt")), ncol=2)

## READ IN CHECKERBOARD CORNERS
coor.2d &lt;- readCheckerboardsToArray(file=file, nx=nx, ny=ny, col.reverse=FALSE)

## SET GRID SIZE OF TEST CHECKERBOARDS (IN MM)
sq.size &lt;- 4.2218

## LOAD CALIBRATION COEFFICIENTS
cal.coeff &lt;- as.matrix(read.table(file=paste0(fdir, "cal_coeffs.txt")))

## TEST CALIBRATION ACCURACY
## USE ONLY A SUBSET (FIVE) OF TEST CALIBRATION IMAGES
## IN THE TUTORIAL POINTS, UNITS NOT IN PIXELS ARE MILLIMETERS
dlt_test &lt;- dltTestCalibration(cal.coeff=cal.coeff, coor.2d=coor.2d[, , 1:5, ], nx=nx, 
  sq.size=sq.size)

## RUN TEST ON ALL TEST CALIBRATION IMAGES
## Not run: 
dlt_test &lt;- dltTestCalibration(cal.coeff=cal.coeff, coor.2d=coor.2d, nx=nx, 
  sq.size=sq.size)

## End(Not run)

## PRINT SUMMARY
summary(dlt_test)

## PLOT A HISTOGRAM OF THE INTERPOINT DISTANCE ERROR
hist(dlt_test$ipd.error)

## PLOT ADJACENT POINT DISTANCE ERROR AS A FUNCTION OF POSITION ALONG THE Y-AXIS
dev.new()
plot(dlt_test$adj.pair.ipd.error, abs(dlt_test$adj.pair.mean.pos[, 2, ]))

## PLOT POSITION-BASED ERROR AS A FUNCTION OF POSITION ALONG THE X-AXIS
dev.new()
plot(dlt_test$aitr.pos[, 1, ], abs(dlt_test$aitr.error[, 1, ]))
</code></pre>

<hr>
<h2 id='dltTransformationParameterRMSError'>Returns the error during transformation parameter optimization</h2><span id='topic+dltTransformationParameterRMSError'></span>

<h3>Description</h3>

<p>Returns the RMS error from <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> after applying a given set of transformation parameters to grid points in stereo camera calibration. This function is called internally by the function <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code> to estimate the position and orientation of a set of calibration grid points that minimizes calibration error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dltTransformationParameterRMSError(p, coor.2d, nx, ny, sx, sy = NULL, 
                                   p.fixed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dltTransformationParameterRMSError_+3A_p">p</code></td>
<td>
<p>a vector of six transformation parameters per grid. The first three being rotational parameters (rotation about the z, y and x axes, respectively) and the second three being translational parameters (translation along the x, y and z axes, respectively). For more than one grid, these six values are concatenated as a vector.</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_coor.2d">coor.2d</code></td>
<td>
<p>a four-dimensional array of grid points passed from <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points are listed first by row).</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_ny">ny</code></td>
<td>
<p>the number of points along the second dimension (e.g. this would be the number of points in each column if points are listed first by row).</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_sx">sx</code></td>
<td>
<p>a scaling factor along the first dimension.</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_sy">sy</code></td>
<td>
<p>a scaling factor along the second dimension. If the grid blocks are squares, this can be left as <code>NULL</code> and only <code>sx</code> will be used.</p>
</td></tr>
<tr><td><code id="dltTransformationParameterRMSError_+3A_p.fixed">p.fixed</code></td>
<td>
<p>a set of transformation parameters to be appended to the beginning of <code>p</code> that will are fixed (constant) during the optimization step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean RMS error from <code><a href="#topic+dltCoefficients">dltCoefficients</a></code> across all views.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+transformPlanarCalibrationCoordinates">transformPlanarCalibrationCoordinates</a></code>,
<code><a href="#topic+dltCoefficients">dltCoefficients</a></code>,
<code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>
</p>

<hr>
<h2 id='drawCheckerboard'>Creates a checkerboard image</h2><span id='topic+drawCheckerboard'></span>

<h3>Description</h3>

<p>Creates a checkerboard image of specified dimensions and saves to an input file path. The dimensions of the checkerboard are specified by the number of internal corners (the number of squares minus one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawCheckerboard(nx, ny, square.size, file = NULL, 
                 margin.x = c(round(square.size/2), round(square.size/2)),
                 margin.y = c(round(square.size/2), round(square.size/2)),
                 filename = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawCheckerboard_+3A_nx">nx</code></td>
<td>
<p>the number of internal corners in the horizontal direction (the number of squares in each row minus one).</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_ny">ny</code></td>
<td>
<p>the number of internal corners in the vertical direction (the number of squares in each column minus one).</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_square.size">square.size</code></td>
<td>
<p>the square size in pixels.</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_file">file</code></td>
<td>
<p>the file path and name to which the image should be saved. The filename must be a valid image filename. Acceptable extensions are: jpg, jpeg, bmp, png and tiff.</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_margin.x">margin.x</code></td>
<td>
<p>the margin in pixels on the left and right sides of the checkerboard pattern.</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_margin.y">margin.y</code></td>
<td>
<p>the margin in pixels on the top and bottom of the checkerboard pattern.</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_filename">filename</code></td>
<td>
<p>Duplicate with <code>file</code>. Included for backward compatibility with previous version.</p>
</td></tr>
<tr><td><code id="drawCheckerboard_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the image function corresponding to the extension in <code>filename</code> (e.g. <code>compression</code>, <code>quality</code>, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>grid</code> package. The image type is determined automatically from the filename and the corresponding image writing function is called.
</p>


<h3>Value</h3>

<p>returns null device</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NUMBER OF INTERNAL CORNERS IN THE HORIZONTAL DIMENSION
## NUMBER OF ROWS OF SQUARES MINUS ONE
nx &lt;- 21

## NUMBER OF INTERNAL CORNERS IN THE VERTICAL DIMENSION
## NUMBER OF COLUMNS OF SQUARES MINUS ONE
ny &lt;- 14

## SQUARE SIZE IN PIXELS
square.size &lt;- 200

## WHERE TO SAVE THE FILE
filename &lt;- paste0("checkerboard_", nx, "_", ny, "_", square.size, ".jpeg")

## Not run: 
## DRAW CHECKERBOARD
## FILE WILL BE CREATED IN CURRENT WORKING DIRECTORY
drawCheckerboard(nx=nx, ny=ny, square.size=square.size, filename=filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='extractFrames'>Extracts frames from video</h2><span id='topic+extractFrames'></span>

<h3>Description</h3>

<p>Extracts frames from a video saving them as a series of images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractFrames(file = NULL, save.to = NULL, frames = NULL, names = NULL, 
              ext = 'jpeg', qscale = 2, frame.start = 0, video.i = NULL, 
              warn.min = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractFrames_+3A_file">file</code></td>
<td>
<p>Video file from which frames are to be extracted.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_save.to">save.to</code></td>
<td>
<p>Where to save the extracted frames.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_frames">frames</code></td>
<td>
<p>The frames to be extracted, starting with 0.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_names">names</code></td>
<td>
<p>Names to be given to the extracted frames. If <code>NULL</code> the function will automatically name them with the corresponding frame number, preceded by enough zeros to maintain a constant filename width.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_ext">ext</code></td>
<td>
<p>The image type/extension to be added to each extract frame.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_qscale">qscale</code></td>
<td>
<p>Integer indicating the image quality of the extracted frames. This is an input parameter passed direclty to ffmpeg.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_frame.start">frame.start</code></td>
<td>
<p>The time (in msec) corresponding to the frame immediately before the first frame change.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_video.i">video.i</code></td>
<td>
<p>Video metadata passed to the function. This parameter is only intended for internal use.</p>
</td></tr>
<tr><td><code id="extractFrames_+3A_warn.min">warn.min</code></td>
<td>
<p>The minimum number of extracted frames for which the user is prompted and has to respond 'y' prior to frame extraction. This is intended to prevent the user from mistakenly extracting thousands of frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use this function you must separately install the ffmpeg video codec library. For instructions please refer to the 'Extracting video frames' section of the most <a href="https://aaronolsen.github.io/software/stereomorph.html">recent StereoMorph user guide here</a>. This function can be used interactively with prompts by calling <code>extractFrames()</code>. The user will then be prompted for all necessary input parameters. This is useful because the function will report the number of frames in the video before prompting which frames the user would like to extract.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use extractFrames() with interactive prompts
extractFrames()

# Extract the first 20 frames from a video
extractFrames(file='Example_video.mov', save.to='Frames', frames=0:20)

## End(Not run)
</code></pre>

<hr>
<h2 id='findCheckerboardCorners'>Finds internal corners of a checkerboard pattern</h2><span id='topic+findCheckerboardCorners'></span>

<h3>Description</h3>

<p>This function finds the internal corners of a checkerboard pattern in an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCheckerboardCorners(image.file, nx, ny, corner.file=NULL, verify.file=NULL, 
                        perim.min = 'auto', perim.max = 'auto', dilations.min = 0,
                        dilations.max = 7, sub.pix.win = NULL, sub.pix.win.min = NULL, 
                        quad.fit.max=4, poly.cont.min=-0.3, poly.cont.max=0.3, 
                        quad.approx.thresh = 'auto', flip = FALSE, 
                        print.progress=TRUE, verbose=FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findCheckerboardCorners_+3A_image.file">image.file</code></td>
<td>
<p>File path(s) to image(s) or to folder(s) containing image(s) (and only images). The image(s) should be a JPEG and include a checkerboard pattern. Can be a vector or matrix. Many different inputs accepted, see &quot;Examples&quot;.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_nx">nx</code></td>
<td>
<p>The number of internal corners in the checkerboard along one dimension. Note that this is not the number of squares (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_ny">ny</code></td>
<td>
<p>The number of internal corners in the checkerboard along a second dimension.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_corner.file">corner.file</code></td>
<td>
<p>File path(s) to text file(s) or to folder(s) where the corners should be saved. Can be a vector or matrix. If <code>NULL</code>, corners are not saved to a text file. Many different inputs accepted, see &quot;Examples&quot;.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_verify.file">verify.file</code></td>
<td>
<p>File path(s) to JPEG image(s) or to folder(s) where verification images should be saved. Can be a vector or matrix. If <code>NULL</code>, verification images are not created. Many different inputs accepted, see &quot;Examples&quot;.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_perim.min">perim.min</code></td>
<td>
<p>The minimum expected perimeter of a black square in the checkerboard pattern (in pixels).</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_perim.max">perim.max</code></td>
<td>
<p>The maximum expected perimeter of a black square in the checkerboard pattern (in pixels).</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_dilations.min">dilations.min</code></td>
<td>
<p>The initial number of dilations to perform on the image. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_dilations.max">dilations.max</code></td>
<td>
<p>The maximum number of dilations to perform on the image. If equal to <code>dilations.min</code>, the function will only perform one dilation. See &quot;details&quot;.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_sub.pix.win">sub.pix.win</code></td>
<td>
<p>The window size to use in determining the corner positions to subpixel resolution. If <code>NULL</code>, this is determined automatically based on the size of the found corners.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_sub.pix.win.min">sub.pix.win.min</code></td>
<td>
<p>Only relevant if sub.pix.win is <code>NULL</code>. This sets the minimum window size that can be set by default.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_quad.fit.max">quad.fit.max</code></td>
<td>
<p>Fit threshold used to identify quadrangles.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_poly.cont.min">poly.cont.min</code></td>
<td>
<p>The minimum allowed aspect ratio of the polygon contours, used as a threshold in identifying quadrangles.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_poly.cont.max">poly.cont.max</code></td>
<td>
<p>The maximum allowed aspect ratio of the polygon contours, used as a threshold in identifying quadrangles.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_quad.approx.thresh">quad.approx.thresh</code></td>
<td>
<p>A threshold for the perimeter of black squares in which method to use to approximate the shape as a quadrangle.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_flip">flip</code></td>
<td>
<p>Logical whether the order of the corners should be flipped.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_print.progress">print.progress</code></td>
<td>
<p>Logical indicating whether the function progress should be printed to the console. See <code>verbose</code>.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether more detailed progress reports to the console. If <code>verbose</code> is <code>FALSE</code>, only the image name and whether the corners were found successfully are printed. If <code>verbose</code> is <code>TRUE</code>, the outcome of the corner search at the conclusion of each dilation is also printed.</p>
</td></tr>
<tr><td><code id="findCheckerboardCorners_+3A_debug">debug</code></td>
<td>
<p>Logical indicating whether images should be created at each of several steps in the corner search. These will be written to the same location as the images written to <code>verify.file</code>. If <code>debug</code> is <code>TRUE</code>, <code>verify.file</code> must be defined. Additionally, <code>dilations.min</code> and <code>dilations.max</code> should be identical since debugging images are created at each dilation and will be overwritten if a range of dilations is input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically detects checkerboard corners in an image and returns the pixel coordinates of the internal corners (where the corners of the black squares contact other black squares) to subpixel resolution. The function uses several C++ functions for image processing written by the author and compiled with the StereoMorph package but hidden until documentation can be written for more general use. Currently the function only works with JPEG images (.jpg or .jpeg); this is the most common digital camera image format output. For large images (10-20 MB), the function can take from 5-15 seconds per image.
</p>
<p><code>image.file</code> input to the function can be of several different forms. First, it can be file paths to particular images or file paths to a folder or folders containing images. Secondly, it can be in a vector or matrix format. The format of <code>image.file</code> will dictate the structure of the value returned by the function. If a single image file is input, a two-colum matrix of corners (where the two columns correspond to the x, y pixel coordinates) is returned. If the input is a vector of file paths or folders containing images, a three-dimensional array is returned; the first two dimensions are the rows and columns of each corner matrix and the third dimension is the order of the corresponding image files in <code>image.file</code>. If the input is a matrix of file paths or folders containing images, a four-dimensional array is returned; the first two dimensions are the rows and columns of each corner matrix and the third and fourth dimensions are the positions of the corresponding image files in the <code>image.file</code> matrix. If <code>image.file</code> is a folder or folders containing images, the folders cannot contain any other files.
</p>
<p>The inputs <code>corner.file</code> and <code>verify.file</code> are optional but if they are non-<code>NULL</code>, they should be of the same format as <code>image.file</code>. If <code>image.file</code> is a folder or folders containing images, folders can also be input for <code>corner.file</code> and <code>verify.file</code>. In this case, the function will automatically name the corner files and verify image files with the same names as the images and as text files and JPEG files, respectively. The corners are saved to a text file as a two column matrix without a header or row names.
</p>
<p>For every input image, the function begins by reading in the image (using <code>readJPEG()</code> of the 'jpeg' package). For large images this is one of the most time-consuming steps. The image is converted to grayscale using the internal function <code>rgbToGray()</code>. The image is thresholded to create a binary image (black and white) based on an adaptive threshold. The threshold is created using the internal function <code>meanBlurImage()</code> and the image thresholded with the internal function <code>thresholdImageMatrix()</code>. Morphological closing is performed to reduce noise using the internal functions <code>dilateImage()</code> and <code>erodeImage()</code>.
</p>
<p>The function then proceeds to dilate the image (expand white areas and consolidate black areas) using a 3x3 square kernel for the range specified by <code>dilations.min</code> and <code>dilations.max</code>. This separates the black squares from each other so that their perimeters can be detected as separate contours. For each dilation, all edge points are identified (black pixels with a neighboring white pixel and vice versa) using the internal function <code>findBoundaryPoints()</code>. Contours (connected edge points) are identified by the internal function <code>generateQuads()</code>, retaining only contours that are quadrangles. The midpoints between adjoining corners of all the quads are found using the internal function <code>intCornersFromQuads()</code>; among these will be the full set of internal corners.
</p>
<p>If the initial set of internal corners exceeds the expectation, the internal corners are filtered, fitting a line to the internal corner set and removing the points at the furthest difference from the line of best fit until the number of corners matches the expectation. The filtered internal corner set is then ordered using the internal function <code>orderCorners()</code> so that first corner is the top left most corner in the pattern and the sequence of internal corners proceeds along <code>nx</code> first and <code>ny</code> second. Lastly, the function finds the internal corner positions to subpixel resolution (using the internal function <code>findCornerSubPix()</code>) by sampling a window around the approximate location of the internal corners (of dimensions determined by <code>sub.pix.win</code>) to find a point optimally positioned at the intersection of diagonally opposing white and black squares. If determined automatically, this sampling window will usually be 23x23 pixels. It is the sampling of this large image region that allows the function to return the corner position to subpixel resolution.
</p>
<p>If <code>verify.file</code> is non-<code>NULL</code>, the internal corners are overlayed on the input image to verify that the correct corners have been found and in the correct order. The first corner is circled in red, a green line interconnects all the intermediate corners in sequence and the last corner is circled in blue (the order of colors then being RGB).
</p>


<h3>Value</h3>

<p>An array of the pixel coordinates of internal corners to subpixel resolution in an array of two (one checkerboard input), three (if <code>image.file</code> is a vector) or four dimensions (if <code>image.file</code> is a matrix). For images in which the expected number of internal corners were not found, an <code>NA</code> matrix is returned for those particular images. The corners are returned along the <code>nx</code> dimension first and the <code>ny</code> dimension second.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p>This function was written based on the methodology described in 'Learning OpenCV' for the automated detection of internal checkerboard corners (Bradski and Kaehler 2008).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>, <code><a href="#topic+measureCheckerboardSize">measureCheckerboardSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## FIND 5 X 3 INTERNAL CORNERS IN A SINGLE IMAGE
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards/RUlna.JPG"), perim.min=180, nx=5, ny=3)

## FIND 5 X 3 INTERNAL CORNERS IN ALL IMAGES IN A FOLDER (HERE 3)
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards"), perim.min=180, nx=5, ny=3)

## WHICH DIMENSIONS ARE ASSIGNED TO NX AND NY IS ARBITRARY BUT REVERSING
## THESE WILL CHANGE THE SEQUENCE IN WHICH THE CORNERS ARE RETURNED
corners &lt;- findCheckerboardCorners(image.file=paste0(fdir, 
     "Checkerboards/RUlna.JPG"), perim.min=180, nx=3, ny=5)
</code></pre>

<hr>
<h2 id='findOptimalPointAlignment'>Optimally aligns one point set to another</h2><span id='topic+findOptimalPointAlignment'></span>

<h3>Description</h3>

<p>This function translates and rotates one point set, optimally aligning it with another point set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOptimalPointAlignment(m1, m2, sign = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findOptimalPointAlignment_+3A_m1">m1</code></td>
<td>
<p>a point set matrix</p>
</td></tr>
<tr><td><code id="findOptimalPointAlignment_+3A_m2">m2</code></td>
<td>
<p>a second point set matrix of the same dimensions as <code>m1</code></p>
</td></tr>
<tr><td><code id="findOptimalPointAlignment_+3A_sign">sign</code></td>
<td>
<p>Used for debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimally aligns point set <code>m2</code> with point set <code>m1</code>. <code>m1</code> and <code>m2</code> must contain the exact same landmarks or points in the same order. Points present in <code>m2</code> but not <code>m1</code> should be <code>NA</code> in <code>m1</code>. They do not need to be <code>NA</code> in <code>m2</code>; all translations and rotations will be applied to all points in <code>m2</code> even though only shared points will be used in the alignment.
</p>
<p>The function first centers the centroid <code>m2</code> about the centroid of <code>m1</code>. The function <code>svd()</code> is then used to find the 3D rotation matrix that optimally aligns <code>m2</code> to <code>m1</code> based on common points. The positions of points in <code>m2</code> relative to one another are unchanged. Thus, optimal rotation is constrained to already translated point sets. Depending on the point sets, a better alignment may be possible by allowing translation and rotation to be optimized simultaneously.
</p>
<p>This function is called by <code><a href="#topic+unifyLandmarks">unifyLandmarks</a></code> to align landmark sets and by <code><a href="#topic+dltTestCalibration">dltTestCalibration</a></code> to test accuracy in reconstructed calibration grids.
</p>


<h3>Value</h3>

<p><code>m2</code> after alignment.</p>


<h3>Note</h3>

<p>Modified from <code>unifyVD()</code> by Annat Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>References</h3>

<p>Rohlf, F.J. (1990) &quot;Chapter 10. Rotational fit (Procrustes) Methods.&quot; <em>Proceedings of the Michigan Morphometrics Workshop</em>. Ed. F. James Rohlf and Fred L. Bookstein. The University of Michigan Museum of Zoology, 1990. 227&ndash;236. <a href="http://deepblue.lib.umich.edu/handle/2027.42/49535">Info page at lib.umich.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unifyLandmarks">unifyLandmarks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## MAKE MATRIX OF 3D POINTS
m1 &lt;- matrix(c(0,0,0, 1,3,2, 4,2,1, 5,5,3, 1,4,2, 3,6,4), nrow=6, ncol=3)

## COPY TO M2
m2 &lt;- m1

## MAKE MISSING POINT IN M1
## ALTHOUGH NOT USED IN THE ALIGNMENT THE CORRESPONDING POINT
##  IN M2 IS STILL RETURNED AFTER ALIGNMENT
m1[3, ] &lt;- NA

## CENTER M2 ABOUT CE
m2 &lt;- m2 %*% rotationMatrixZYX_SM(pi/6, -pi/3, pi/8)

## TRANSLATE M2
m2 &lt;- m2 + matrix(c(2,3,4), nrow=6, ncol=3, byrow=TRUE)

## ALIGN M2 TO M1
m3 &lt;- findOptimalPointAlignment(m1, m2)

## NOTE THAT RETURNED MATRIX IS IDENTICAL TO M1
## OF COURSE REAL WORLD DATA WILL HAVE SOME ERROR
m1
m3
</code></pre>

<hr>
<h2 id='gridPointsFit'>Fits regularly spaced points to a sample line or grid</h2><span id='topic+gridPointsFit'></span>

<h3>Description</h3>

<p>This function is used to fit a model of points at a regular interval to a sample of points in one dimension. The function is used by <code><a href="#topic+measureCheckerboardSize">measureCheckerboardSize</a></code> to estimate the solution to the inter-point distance of points along a line or in a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
gridPointsFit(p, nx, ny=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridPointsFit_+3A_p">p</code></td>
<td>
<p>The parameters defining the regular point distribution. When <code>nx</code> is <code>NULL</code>, <code>p</code> is of length 2. When <code>nx</code> is non-<code>NULL</code>, <code>p</code> is of length 3.</p>
</td></tr>
<tr><td><code id="gridPointsFit_+3A_nx">nx</code></td>
<td>
<p>The number of points to be created at regular spacing along one dimension.</p>
</td></tr>
<tr><td><code id="gridPointsFit_+3A_ny">ny</code></td>
<td>
<p>The number of points to be created at regular spacing along a second dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to fit a model of points at a regular interval to a sample of points in one dimension. The function is used by <code><a href="#topic+measureCheckerboardSize">measureCheckerboardSize</a></code> to estimate the solution to the inter-point distance of points along a line or in a grid. To fit a model to points along lines and grids in two dimensions, each dimension is fit separately. A best fit estimate of the true interval between points can then be calculated from the optimized parameters. See the examples below for how to use <code>gridPointsFit()</code> to estimate the inter-point intervals of line and grid points.
</p>


<h3>Value</h3>

<p>a vector of length <code>nx*ny</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+measureCheckerboardSize">measureCheckerboardSize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ESTIMATE LINE INTER-POINT INTERVAL
# GENERATE POINTS AT A REGULAR INTERVAL WITH NORMAL, RANDOM VARIATION
pts &lt;- cbind((1:500) + rnorm(500, sd=1), (1:500) + rnorm(500, sd=1))

# FIND THE MEAN SUCCESSIVE POINT-TO-DISTANCE
# NOTE THAT THIS CONSISTENTLY OVERESTIMATES THE TRUE INTERVAL
mean(sqrt(rowSums((pts[2:nrow(pts), ] - pts[1:(nrow(pts)-1), ])^2)))

# FIT A REGULARLY SPACED POINTS MODEL TO EACH DIMENSION OF THE POINTS MATRIX
fit_x &lt;- nlminb(start=c(pts[1, 1], pts[2, 1]-pts[1, 1]), 
    objective=gridPointsFitError, nx=nrow(pts), points=pts[, 1])
fit_y &lt;- nlminb(start=c(pts[1, 2], pts[2, 2]-pts[1, 2]), 
    objective=gridPointsFitError, nx=nrow(pts), points=pts[, 2])

# FIND THE BEST FIT INTER-POINT DISTANCE
# MORE ACCURATELY RECOVERS TRUE INTERVAL
sqrt(fit_x$par[2]^2 + fit_y$par[2]^2)


## ESTIMATE REGULAR GRID SQUARE SIZE
# GENERATE A REGULAR GRID WITH NORMAL, RANDOM VARIATION
corners &lt;- cbind(
    rep(1:20, 20) + rnorm(20^2, sd=0.1), 
    c(t(matrix(1:20, nrow=20, ncol=20))) + rnorm(20^2, sd=0.1))

# FIT A REGULARLY SPACED POINTS MODEL TO EACH DIMENSION OF THE POINTS MATRIX
fit_x &lt;- nlminb(
    start=c(corners[1, 1], corners[2, 1]-corners[1, 1], 0),
    objective=gridPointsFitError, points=corners[, 1], nx=20, ny=20)
fit_y &lt;- nlminb(
    start=c(corners[1, 2], corners[2, 2]-corners[1, 2], 0),
    objective=gridPointsFitError, points=corners[, 2], nx=20, ny=20)

# FIND THE BEST FIT INTER-POINT DISTANCE (SQUARE SIZE)
sqrt(fit_x$par[2]^2 + fit_y$par[2]^2)
</code></pre>

<hr>
<h2 id='imagePlaneGridTransform'>Performs image perspective transformations to a grid</h2><span id='topic+imagePlaneGridTransform'></span>

<h3>Description</h3>

<p>This function takes parameters describing a 3D planar grid projected onto a 2D image plane and returns a grid of specified dimensions. Users will probably not call this function directly. Rather, it is used by <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code> to produce grid points with the same transformations as an imaged grid but with fewer points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagePlaneGridTransform(p, nx, ny)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imagePlaneGridTransform_+3A_p">p</code></td>
<td>
<p>a vector of 12 grid parameters. The first eight values are the x,y-coordinates of the four grid corners (<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, etc.) and the last four values are transformation parameters for slope and interpoint spacing.</p>
</td></tr>
<tr><td><code id="imagePlaneGridTransform_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension. Note that although the grid can have a different number of rows than columns, the grid units themselves should be square (of uniform size in both dimensions).</p>
</td></tr>
<tr><td><code id="imagePlaneGridTransform_+3A_ny">ny</code></td>
<td>
<p>the number of points along the second dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When taking a photo of planar grid points (such as the internal corners of a checkerboard pattern) arbitrarily oriented in 3D space, the distribution of grid points in a 2D photograph will reflect several transformations. The grid may be translated to any position within the image plane and rotated by any angle. Additionally, if the grid plane is not parallel to the image plane, perspective effects will cause points further away to appear closer together. When arbitrary 3D position and perspective effects are combined, the transformation of a planar grid can be quite extreme (see example).
</p>
<p><code>imagePlaneGridTransform()</code> takes 12 parameters describing these effects and applies them to a grid of the specified dimensions, returning the transformed grid points. The first eight parameters are the x,y-coordinates of the four grid corners (<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, etc.). The ninth and tenth parameters describe how interpoint spacing changes from row-to-row and column-to-column, respectively. This is the <code>a</code> parameter in the function <code><a href="#topic+quadraticPointsOnInterval">quadraticPointsOnInterval</a></code>. A value of zero indicates uniform spacing between consecutive points across all rows while values less or greater than zero indicates points that become closer together or further apart from one row or column to the next. The eleventh and twelfth parameters are analogous to the ninth and tenth parameters but describe how spacing changes between rows and columns instead of between points. These last two parameters are also the <code>a</code> parameter in the function <code><a href="#topic+quadraticPointsOnInterval">quadraticPointsOnInterval</a></code>.
</p>
<p>Currently, <code>imagePlaneGridTransform()</code> does not currently account for lens distortion (e.g. barrel, pincushion, etc.). If distortion is significant, users should undistort the photographs prior to using <code>imagePlaneGridTransform()</code>. It is hoped that future versions will include additional parameters to account for lens distortion.
</p>
<p>Users will probably not call <code>imagePlaneGridTransform()</code> directly. In this package, this function is used by <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code> to both fit transformation parameters to a matrix of imaged grid points and to produce a transformed grid consisting of fewer points. In this way, fewer points (but representing the same amount of information) can be used in more computationally intensive steps.
</p>


<h3>Value</h3>

<p>a matrix of transformed grid points.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>, <code><a href="#topic+quadraticPointsOnInterval">quadraticPointsOnInterval</a></code>, <code><a href="#topic+imagePlaneGridTransformError">imagePlaneGridTransformError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SET GRID PARAMETERS
## THE FIRST 8 NUMBERS ARE CORNERS
## THE LAST 4 NUMBERS ARE TRANSFORMATION PARAMETERS
p &lt;- c(3656, 379, 707, 264, 383, 1034, 3984, 1164, 63.772, -25.211, -0.818, -3.339)

## CREATE TRANSFORMED GRID
grid &lt;- imagePlaneGridTransform(p=p, nx=21, ny=14)

## PLOT GRID
plot(grid)

## MARK CORNERS OF GRID FROM p
points(matrix(p[1:8], nrow=4, ncol=2, byrow=TRUE), col='red', lwd=2, cex=1.5)
</code></pre>

<hr>
<h2 id='imagePlaneGridTransformError'>Returns imagePlaneGridTransform error</h2><span id='topic+imagePlaneGridTransformError'></span>

<h3>Description</h3>

<p>Returns the mean error between a matrix of grid points and a matrix of transformed grid points (produced by <code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>). This function is called internally by the function <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code> in evaluating the goodness of fit between imaged grid points and grid points produced by an image perspective model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagePlaneGridTransformError(p, nx, ny, grid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imagePlaneGridTransformError_+3A_p">p</code></td>
<td>
<p>a vector of 12 grid parameters (see <code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>).</p>
</td></tr>
<tr><td><code id="imagePlaneGridTransformError_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension.</p>
</td></tr>
<tr><td><code id="imagePlaneGridTransformError_+3A_ny">ny</code></td>
<td>
<p>the number of points along the second dimension.</p>
</td></tr>
<tr><td><code id="imagePlaneGridTransformError_+3A_grid">grid</code></td>
<td>
<p>a matrix of grid points to be compared against the model grid points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean error.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>, <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>
</p>

<hr>
<h2 id='landmarkListToMatrix'>Converts a landmark list to a landmark matrix</h2><span id='topic+landmarkListToMatrix'></span>

<h3>Description</h3>

<p>Converts a landmark list to a landmark matrix. The landmark matrix is identical to the matrix that would be returned if the landmark files were sent directly to <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarkListToMatrix(lm.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landmarkListToMatrix_+3A_lm.list">lm.list</code></td>
<td>
<p>a landmark list. See <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a landmark matrix.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>, <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILES TO LOAD - TWO DIFFERENT 3D POINT SETS
file &lt;- paste0(fdir, "lm_3d_even_a", 1:2, ".txt")

## READ LANDMARKS INTO A LIST
lm.list &lt;- readLandmarksToList(file=file, row.names=1)

## CONVERT LANDMARK LIST TO LANDMARK MATRIX
lm.matrix &lt;- landmarkListToMatrix(lm.list)

lm.matrix
</code></pre>

<hr>
<h2 id='landmarkMatrixToList'>Converts a landmark matrix to a landmark list</h2><span id='topic+landmarkMatrixToList'></span>

<h3>Description</h3>

<p>Converts a landmark matrix to a landmark list.</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarkMatrixToList(lm.matrix, semilandmark.pattern='[0-9]+$', k=ncol(lm.matrix))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landmarkMatrixToList_+3A_lm.matrix">lm.matrix</code></td>
<td>
<p>a landmark matrix. See <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="landmarkMatrixToList_+3A_semilandmark.pattern">semilandmark.pattern</code></td>
<td>
<p>a regular expression pattern passed to <code>sub()</code> for identifying and grouping curve points. The default is landmark names ending in one or more numbers. To disable grouping, set to code&rdquo;.</p>
</td></tr>
<tr><td><code id="landmarkMatrixToList_+3A_k">k</code></td>
<td>
<p>the number of dimensions of the landmark data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a landmark list.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+landmarkListToMatrix">landmarkListToMatrix</a></code>, <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>, <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILES TO LOAD - TWO DIFFERENT 3D POINT SETS
file &lt;- paste0(fdir, "lm_2d_a1_v", 1:2, ".txt")

## READ LANDMARKS INTO A LIST
lm.matrix &lt;- readLandmarksToMatrix(file=file, row.names=1)

## CONVERT LANDMARK LIST TO LANDMARK MATRIX
lm.list &lt;- landmarkMatrixToList(lm.matrix, k=2)

## CAN BE CONVERTED BACK INTO MATRIX
## RECOVERING THE SAME MATRIX AS THE ORIGINAL
lm.matrix &lt;- landmarkListToMatrix(lm.list)
</code></pre>

<hr>
<h2 id='measureCheckerboardSize'>Estimates checkerboard square size</h2><span id='topic+measureCheckerboardSize'></span><span id='topic+summary.measureCheckerboardSize'></span><span id='topic+print.summary.measureCheckerboardSize'></span>

<h3>Description</h3>

<p>This function estimates the square size of a checkerboard, optionally scaling this to real-world units (e.g. millimeters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureCheckerboardSize(corner.file, nx, ruler.file=NULL, ruler.pt.size=NULL)

## S3 method for class 'measureCheckerboardSize'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measureCheckerboardSize_+3A_corner.file">corner.file</code></td>
<td>
<p>a file path to text file containing a matrix of internal corners from a checkerboard pattern (a point grid) or the matrix itself. The text file must not have row names or a header.</p>
</td></tr>
<tr><td><code id="measureCheckerboardSize_+3A_nx">nx</code></td>
<td>
<p>the number of internal corners in the first dimension along which the checkerboard points are ordered.</p>
</td></tr>
<tr><td><code id="measureCheckerboardSize_+3A_ruler.file">ruler.file</code></td>
<td>
<p>a file path to a text file containing a matrix of evenly spaced points digitized along a ruler (or comparable standard) or the matrix itself. The text file must have row names but no header or column names.</p>
</td></tr>
<tr><td><code id="measureCheckerboardSize_+3A_ruler.pt.size">ruler.pt.size</code></td>
<td>
<p>the size of the spacing between points in the <code>ruler.file</code> matrix in real world units. This can be numeric or alphanumeric including the unit (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="measureCheckerboardSize_+3A_object">object</code></td>
<td>
<p>a list of class <code>"measureCheckerboardSize"</code>.</p>
</td></tr>
<tr><td><code id="measureCheckerboardSize_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>corner.file</code> can be a file path to a text file containing a matrix of internal corners from a checkerboard pattern (ie points in a regular grid pattern) or the matrix itself. These can be automatically detected from a JPEG image using the function <code><a href="#topic+findCheckerboardCorners">findCheckerboardCorners</a></code>. The function first fits a camera perspective model to the corner points to robustly compare the opposing side lengths of the grid (see <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>). These are returned as <code>side.lengths</code> and are displayed when calling the summary method. Opposing sides that differ greatly in length indicate that the grid was not completely flat relative to the image plane when it was photographed.
</p>
<p><code>measureCheckerboardSize()</code> then estimates the checkerboard or grid square size by fitting a simple grid model to the points (see <code><a href="#topic+gridPointsFit">gridPointsFit</a></code>). The best fitting parameters are used to estimate the square size. Model fitting is more robust to noise in the grid point coordinates than taking the mean inter-point distance, for instance. The model goodness of fit can be assessed by the returned elements <code>dist.corner.fit.mean</code> and <code>dist.corner.fit.sd</code>.
</p>
<p><code>ruler.file</code> can be a file path to a text file containing a matrix of points at equal intervals along a ruler or the matrix itself. These ruler points can be digitized from an image using the function <code><a href="#topic+digitizeImage">digitizeImage</a></code>. If <code>ruler.file</code> is <code>NULL</code>, then only the checkerboard square size (in the input units) is returned. All other return values are <code>NULL</code>. If <code>ruler.file</code> is non-<code>NULL</code>, the distance between consecutive ruler points (the ruler point interval) is estimated by fitting a model of points at a regular interval along a line (see <code><a href="#topic+gridPointsFit">gridPointsFit</a></code>). The goodness of fit for the ruler point model can be assessed by the returned elements <code>dist.ruler.fit.mean</code> and <code>dist.ruler.fit.sd</code>. The estimated ruler point interval is used to scale the checkerboard square size to the units of <code>ruler.pt.size</code>.
</p>
<p><code>ruler.pt.size</code> can be numeric or alphanumeric (including the units). For example, <code>'1'</code>, <code>'1 mm'</code> and <code>'1.0 mm'</code> are all possible inputs to <code>ruler.pt.size</code>. The units are automatically extracted and only used in the summary function to help interpret the function results. <code>measureCheckerboardSize()</code> also returns the estimated real-world size of a pixel. This represents the resolution of the camera at the surface of the checkerboard pattern.
</p>


<h3>Value</h3>

<p>a list of class <code>"measureCheckerboardSize"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>side.lengths</code></td>
<td>
<p>the lengths of the four sides of the grid estimated by camera perspective model fitting.</p>
</td></tr>
<tr><td><code>dist.corner.fit.mean</code></td>
<td>
<p>the mean difference between the corner points <code>corner.file</code> and those generated assuming the best-fit simple grid model.</p>
</td></tr>
<tr><td><code>dist.corner.fit.sd</code></td>
<td>
<p>the standard deviation in the difference between the corner points <code>corner.file</code> and those generated assuming the best-fit model.</p>
</td></tr>
<tr><td><code>square.size.px</code></td>
<td>
<p>the best-fit estimate of the checkerboard square size in pixels.</p>
</td></tr>
<tr><td><code>square.size.rwu</code></td>
<td>
<p>the best-fit estimate of the checkerboard square size in real-world units. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist.ruler.fit.mean</code></td>
<td>
<p>the mean difference between the <code>ruler.file</code> matrix and those generated assuming the best-fit model. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist.ruler.fit.sd</code></td>
<td>
<p>the standard deviation in the difference between the <code>ruler.file</code> matrix and those generated assuming the best-fit model. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>ruler.size.px</code></td>
<td>
<p>the best-fit estimate of the distance between consecutive points on the ruler (in pixels) in the plane of the imaged grid. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>rwu.per.px</code></td>
<td>
<p>the real-world size of a pixel in the image (the length of one side of the pixel) in the plane of the imaged grid. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>if <code>ruler.pt.size</code> includes a unit, the unit. <code>NULL</code> if <code>ruler.file</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawCheckerboard">drawCheckerboard</a></code>, <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>, <code><a href="#topic+gridPointsFit">gridPointsFit</a></code>, <code><a href="#topic+digitizeImage">digitizeImage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILE PATH TO CHECKERBOARD POINTS FILE
corner_file &lt;- paste0(fdir, "checker_21_14_200(9).txt")

## NUMBER OF INTERNAL CORNERS IN THE HORIZONTAL DIMENSION
nx &lt;- 21

## NUMBER OF INTERNAL CORNERS IN THE VERTICAL DIMENSION
ny &lt;- 14

## SET FILE PATH TO RULER POINTS FILE
ruler_file &lt;- paste0(fdir, "ruler_21_14_200(9).txt")

## ESTIMATE SQUARE SIZE
square_size &lt;- measureCheckerboardSize(corner.file=corner_file, nx=nx)

## PRINT SUMMARY
summary(square_size)



## ESTIMATE SQUARE SIZE AND SCALE WITH RULER POINTS
square_size_scale &lt;- measureCheckerboardSize(corner.file=corner_file, nx=nx,
    ruler.file=ruler_file, ruler.pt.size='1 mm')

## PRINT SUMMARY
summary(square_size_scale)


## Not run: 

## INPUT MATRICES DIRECTLY
## READ POINTS INTO MATRICES
corner_pts &lt;- as.matrix(read.table(corner_file))
ruler_pts &lt;- as.matrix(read.table(ruler_file, row.names=1))

## ESTIMATE SQUARE SIZE AND SCALE WITH RULER POINTS
square_size_scale &lt;- measureCheckerboardSize(corner.file=corner_pts, nx=nx,
    ruler.file=ruler_pts, ruler.pt.size='1 mm')

## End(Not run)
</code></pre>

<hr>
<h2 id='orthogonalProjectionToLine'>Finds the orthogonal projection of a point onto a line</h2><span id='topic+orthogonalProjectionToLine'></span>

<h3>Description</h3>

<p>Given a 2D or 3D input point <code>p</code> and a 2D or 3D line, this function finds a point on the line at a minimum distance from point <code>p</code>. This is equivalent to the orthogonal projection of point <code>p</code> onto the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthogonalProjectionToLine(p, l1 = NULL, l2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthogonalProjectionToLine_+3A_p">p</code></td>
<td>
<p>a vector of a single point or a matrix of multiple points</p>
</td></tr>
<tr><td><code id="orthogonalProjectionToLine_+3A_l1">l1</code></td>
<td>
<p>a vector describing a point on a line or a list with line constants</p>
</td></tr>
<tr><td><code id="orthogonalProjectionToLine_+3A_l2">l2</code></td>
<td>
<p>if <code>l1</code> is a point, a second point on a line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>p</code> is a vector, the function returns a point as a vector of the same dimension. If <code>p</code> is a matrix, each row is treated as a point and the orthogonal projection is returned for each. These points are returned as a matrix (of the same dimension), each row being the orthogonal projection of the corresponding row in <code>p</code>.
</p>
<p>The line input can be defined using one of three standard ways: two points on the line, 'm' and 'b' constants (slope and y-intercept) and direction numbers 'abc' (a vector parallel to a line through the origin). If <code>l1</code> is a vector, this is taken as one point on the line and <code>l2</code> must be a second point on the line. If <code>l1</code> is a list, the named objects must correspond to one of these three line definitions. Two points on the line are defined as <code>l1$l1</code> and <code>l1$l2</code>. 'm' and 'b' are defined as <code>l1$m</code> and <code>l1$b</code>. And the direction numbers 'abc' are defined as <code>l1$a</code>, <code>l1$b</code> and <code>l1$c</code>.
</p>


<h3>Value</h3>

<p>a vector if <code>p</code> is a vector and a matrix if <code>p</code> is a matrix. The returned vector or matrix will be of the same dimensions as <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>References</h3>

<p><a href="http://paulbourke.net/geometry/pointlineplane/">http://paulbourke.net/geometry/pointlineplane/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distancePointToLine">distancePointToLine</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## POINT INPUT: 2D VECTOR
## LINE INPUT: l1, l2
## LINE THROUGH THE ORIGIN WITH SLOPE OF ONE
orthogonalProjectionToLine(p=c(0, 5), l1=c(0, 0), l2=c(3, 3))

## POINT INPUT: 2D VECTOR
## LINE INPUT: LIST WITH l1, l2
orthogonalProjectionToLine(p=c(0, 5), l1=list(l1=c(0, 0), l2=c(3, 3)))

## POINT INPUT: 2D VECTOR
## LINE INPUT: LIST WITH m, b
## LINE WITH Y-INTERCEPT AT ONE AND SLOPE OF ONE
orthogonalProjectionToLine(p=c(0, 5), l1=list(m=1, b=0))

## POINT INPUT: 2D VECTOR
## LINE INPUT: LIST WITH VECTOR PARALLEL TO LINE THROUGH THE ORIGIN
## LINE THROUGH THE ORIGIN WITH SLOPE OF ONE
orthogonalProjectionToLine(p=c(0, 5), l1=list(a=1, b=-1, c=0))

## POINT INPUT: 2D VECTOR
## LINE INPUT: SAME AS PREVIOUS BUT WITH Z-AXIS COMPONENT
orthogonalProjectionToLine(p=c(0, 5), l1=list(a=1, b=-1, c=1))

## POINT INPUT: 3D VECTOR
## LINE INPUT: l1, l2
orthogonalProjectionToLine(p=c(0, 5, 0), l1=list(l1=c(0, 0, 0), l2=c(3, 3, 3)))

## POINT INPUT: 2D MATRIX
## LINE INPUT: l1, l2
p &lt;- matrix(c(0,5, 0,10), nrow=2, byrow=TRUE)
orthogonalProjectionToLine(p=p, l1=list(l1=c(0, 0), l2=c(3, 3)))

## POINT INPUT: 3D MATRIX
## LINE INPUT: l1, l2
p &lt;- matrix(c(0,5,0, 0,10,0), nrow=2, byrow=TRUE)
orthogonalProjectionToLine(p=p, l1=list(l1=c(0, 0, 0), l2=c(3, 3, 3)))
</code></pre>

<hr>
<h2 id='pointsAtEvenSpacing'>Generates evenly spaced points from point matrix</h2><span id='topic+pointsAtEvenSpacing'></span>

<h3>Description</h3>

<p>This function takes a matrix of points, calculates the cumulative distance from start to end and then uses the cumulative distance and intermediate points to generate evenly spaced points between the start and end points. Linear interpolation is used between neighboring points, so the returned points will either coincide with the input points or fall on straight lines between consecutive points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsAtEvenSpacing(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointsAtEvenSpacing_+3A_x">x</code></td>
<td>
<p>a matrix or landmark list of points of any number of dimensions. If input is a list, only the first element is used.</p>
</td></tr>
<tr><td><code id="pointsAtEvenSpacing_+3A_n">n</code></td>
<td>
<p>the number of points to generate, including the start and end points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first removes all <code>NA</code> values. Then, the cumulative distance is calculated from the first to last point. The last value is taken as the total length of the line or curve, defined by matrix <code>x</code>. This total length is divided by <code>n-1</code> to find a uniform segment length that will separate <code>n</code> evenly spaced points, including the first and last non-<code>NA</code> values in <code>x</code>.
</p>
<p>The function iterates through <code>x</code>, finding the point that is at a distance equal to or just less than the segment length from the previous point. If the selected point is at a distance less than the segment length from the previous point, a point is chosen on the line between this point and the next to complete the full segment length. In this way, returned points will either coincide with the input points or fall on straight lines between consecutive points.
</p>
<p>In the simplest implementation, <code>pointsAtEvenSpacing()</code> can be used for linear interpolation (see first example below). Define the start and end points in <code>x</code> as a two-row matrix and then select the number of points to include on the line.
</p>
<p>If <code>x</code> represents densely sampled points on a curve (see the second example below) and if the curve can be approximated by straight lines between consecutive points, then <code>pointsAtEvenSpacing()</code> will provide comparable results to other methods, such as function fitting. This is especially useful for curves not easily fit by a mathematical function.
</p>


<h3>Value</h3>

<p>a matrix of <code>n</code> points. The start and end points correspond to the first and last non-NA values in <code>x</code>.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>, <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>, <code><a href="#topic+imagePlaneGridTransformError">imagePlaneGridTransformError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## LINEAR INTERPOLATION ##
## CREATE A MATRIX OF TWO POINTS
two_points &lt;- matrix(c(0, 10, 0, 10), nrow=2, ncol=2)

## GENERATE 20 POINTS ALONG THE LINE
pts_aes &lt;- pointsAtEvenSpacing(x=two_points, n=20)

## PLOT THE LINE
plot(two_points, type='l')

## AND THE POINTS ALONG THE LINE
points(pts_aes, col='red')


## POINTS ALONG A CURVE ##
## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## GET 3D LANDMARK AND CURVE POINT FILE AND READ INTO A MATRIX
lm.matrix &lt;- readLandmarksToMatrix(paste0(fdir, "lm_3d_a2.txt"), row.names=1)

## PLOT THE LANDMARKS AND CURVE POINTS
pts &lt;- na.omit(lm.matrix)
r &lt;- abs(apply(pts, 2, 'max') - apply(pts, 2, 'min'))

## Not run: 
## PLOT USING THE RGL PACKAGE
plot3d(pts, aspect=c(r[1]/r[3], r[2]/r[3], 1), size=0.5)

## End(Not run)

## CONVERT LANDMARKS TO LIST FORMAT TO EASILY ACCESS CURVE POINTS
lm.list &lt;- landmarkMatrixToList(lm.matrix)

## CREATE 10 EVENLY SPACED POINTS ALONG ONE CURVE
lm.list$pterygoid_crest_R &lt;- pointsAtEvenSpacing(x=lm.list$pterygoid_crest_R, n=10)

## CREATE 15 ALONG ANOTHER
lm.list$tomium_R &lt;- pointsAtEvenSpacing(x=lm.list$tomium_R, n=15)

## CONVERT BACK TO MATRIX
lm.matrix &lt;- landmarkListToMatrix(lm.list)

## Not run: 
## PLOT NEW EVENLY SPACED POINTS WITH PREVIOUS POINTS
plot3d(lm.matrix, add=T, size=4, col='red')

## End(Not run)
</code></pre>

<hr>
<h2 id='quadraticPointsOnInterval'>Generates points along an interval with quadratic parameterization</h2><span id='topic+quadraticPointsOnInterval'></span>

<h3>Description</h3>

<p>Generates a specified number of points on an interval, applying a quadratic function to interpoint spacing. This function is called internally by <code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadraticPointsOnInterval(t1, t2, n, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadraticPointsOnInterval_+3A_t1">t1</code></td>
<td>
<p>the starting value of the returned points.</p>
</td></tr>
<tr><td><code id="quadraticPointsOnInterval_+3A_t2">t2</code></td>
<td>
<p>the final value of the returned points.</p>
</td></tr>
<tr><td><code id="quadraticPointsOnInterval_+3A_n">n</code></td>
<td>
<p>the number of points.</p>
</td></tr>
<tr><td><code id="quadraticPointsOnInterval_+3A_a">a</code></td>
<td>
<p>a quadratic parameter describing how interpoint spacing changes over the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>a</code> describes how strong of a skew to place on the interpoint distances over the interval specified by <code>t1</code> and <code>t2</code>. When <code>a=0</code>, the points are spaced uniformly across the interval. When <code>a&gt;0</code> or <code>a&lt;0</code>, points become further apart or closer together along the interval, respectively, at the rate of a quadratic function (see &quot;Examples&quot;).
</p>


<h3>Value</h3>

<p>a vector of points.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>, <code><a href="#topic+resampleGridImagePoints">resampleGridImagePoints</a></code>, <code><a href="#topic+imagePlaneGridTransformError">imagePlaneGridTransformError</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GENERATE EVENLY SPACED POINTS ON INTERVAL
q0 &lt;- quadraticPointsOnInterval(t1=0, t2=1, n=10, a=0)

## MAKE POINTS PROGRESSIVELY FURTHER APART ALONG INTERVAL
qgt0 &lt;- quadraticPointsOnInterval(t1=0, t2=1, n=10, a=1)

## MAKE POINTS PROGRESSIVELY CLOSER TOGETHER ALONG INTERVAL
qlt0 &lt;- quadraticPointsOnInterval(t1=0, t2=1, n=10, a=-1)

## PLOT POINTS ON THREE SEPARATE LINES
plot(q0, rep(0, 10))
points(qgt0, rep(0.5, 10), col='green')
points(qlt0, rep(-0.5, 10), col='blue')
</code></pre>

<hr>
<h2 id='readBezierControlPoints'>Reads a file of Bezier control points</h2><span id='topic+readBezierControlPoints'></span>

<h3>Description</h3>

<p>Reads Bezier control points from a file or files into a list grouped first by curve name and then by the index of the file from which they were read. A separate function from the standard read functions is necessary since the number of control points may differ for each Bezier curve or spline and, thus, the number of values may differ by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBezierControlPoints(file, ndim = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBezierControlPoints_+3A_file">file</code></td>
<td>
<p>file(s) to be read.</p>
</td></tr>
<tr><td><code id="readBezierControlPoints_+3A_ndim">ndim</code></td>
<td>
<p>the number of dimensions of the Bezier curve points</p>
</td></tr>
<tr><td><code id="readBezierControlPoints_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>readLines()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows of each file must start with the name of the curve or spline followed by the control points, all separated by tabs. The control points are listed first by dimension and then by point (<code>x1\ty1\tx2\ty2</code> etc.). For example, three Bezier points starting with [100, 200] would be on one line as follows, with <code>\t</code> replaced by tabs.
</p>
<p><code>tomium_R\t100\t200\t300\t100\t400\t300</code>
</p>
<p>Each Bezier curve or spline is first grouped into a list by curve name (e.g. <code>list$tomium_R</code>) and then by the index of the file from which it was read (e.g. <code>list$tomium_R[[1]]</code> from the first file). The control points are made into a matrix where the number of columns corresponds to <code>ndim</code>. The Bezier list structure is similar to the landmark list structure created by <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code> and can be used to generate points along a Bezier curve or spline. See the R package <a href="https://cran.r-project.org/package=bezier">bezier</a> for more details.
</p>


<h3>Value</h3>

<p>a list of Bezier control points grouped by name and file number.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>, <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>, <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>,
</p>
<p><code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## FILE TO READ
file &lt;- paste0(fdir, "bezier_control_points_a2_v", 1:2, ".txt")

## FILE TO READ
bcp &lt;- readBezierControlPoints(file=file)
</code></pre>

<hr>
<h2 id='readCheckerboardsToArray'>Reads file(s) containing grid points into an array</h2><span id='topic+readCheckerboardsToArray'></span>

<h3>Description</h3>

<p>This function reads grid point matrices into an array from a matrix files allowing for point order reversals along rows, columns, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCheckerboardsToArray(file, nx, ny, col.reverse = FALSE, row.reverse = FALSE, 
                         na.omit=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readCheckerboardsToArray_+3A_file">file</code></td>
<td>
<p>a matrix of file paths to be read into an array. Each file path should correspond to a file containing a single landmark matrix.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_nx">nx</code></td>
<td>
<p>the number of internal corners in the first dimension along which grid points are ordered.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_ny">ny</code></td>
<td>
<p>the number of internal corners in the second dimension along which grid points are ordered.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_col.reverse">col.reverse</code></td>
<td>
<p>a logical indicating whether the column order of grid points should be reversed. Can be either single value, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_row.reverse">row.reverse</code></td>
<td>
<p>a logical indicating whether the row order of grid points should be reversed. Can be either single value, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_na.omit">na.omit</code></td>
<td>
<p>whether landmarks with NA values in any file should be omitted.</p>
</td></tr>
<tr><td><code id="readCheckerboardsToArray_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>readLandmarksToArray()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using planar grid points to find an optimal stereo calibration, ensuring that the grid point coordinates are listed in the same order from different camera views is challenging. When cameras are viewing the same points from different orientations (e.g. one camera is upside-down relative to another) and when the checkerboard itself is in different orientations, columns and/or rows in one grid point matrix could be flipped relative to another camera view.
</p>
<p><code>readCheckerboardsToArray()</code> enables correction for this by allowing users to specify whether the rows, columns or both should be reversed after the points are read from a file. If the checkerboard changes orientation within a single camera view it could be necessary to specify row and/or column reversals individually for each file. <code>col.reverse</code> and <code>row.reverse</code> can both be either a single logical, a vector of logicals or a matrix of logicals. This allows <code>col.reverse</code> and <code>row.reverse</code> to be specified for all files in a vector or matrix or for each file separately. Vector inputs of <code>col.reverse</code> and <code>row.reverse</code> with a matrix input of <code>file</code> will be applied to each column of <code>file</code> (see last example below).
</p>
<p>Row reversal means that point order is reversed along the second dimension (the order along the first dimension is kept intact). Column reversal means that point order is reversed along the first dimension (the order along the second dimension is kept intact). Setting both <code>col.reverse</code> and <code>row.reverse</code> to <code>TRUE</code> is equivalent to reversing the order of points from start to end (row and column structures have no effect). These operations are perhaps best understood through the examples below. For an example of the grid point ordering scheme, also see <code><a href="#topic+distanceGridUnits">distanceGridUnits</a></code>.
</p>


<h3>Value</h3>

<p>an array of three or four dimensions.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>, <code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>, <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET NUMBER OF ROWS AND COLUMNS
## THESE ARE THE NUMBER OF INTERNAL CORNERS, NOT THE NUMBER OF SQUARES
nx &lt;- 4
ny &lt;- 3

## SET FILE PATHS
file &lt;- matrix(c(paste0(fdir, "rcta_a", 1:3, "_v1.txt"), 
                 paste0(fdir, "rcta_a", 1:3, "_v2.txt")), ncol=2)

## READ MATRIX OF FILES ##
## REVERSE COLUMNS IN FIRST COLUMN OF FILE MATRIX
## REVERSE ROWS IN ALL FILES
readCheckerboardsToArray(file, nx, ny, col.reverse=c(TRUE, FALSE), row.reverse=TRUE)
</code></pre>

<hr>
<h2 id='readLandmarksToList'>Reads landmark file(s) into a list</h2><span id='topic+readLandmarksToList'></span>

<h3>Description</h3>

<p>Reads landmarks from one or more files into a list. This function is useful when dealing with curves (semilandmarks) since curve points can be grouped by curve name for other operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLandmarksToList(file, semilandmark.pattern = "[0-9]+$", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLandmarksToList_+3A_file">file</code></td>
<td>
<p>a single landmark file or vector of landmark files to be read. Each file should contain a single landmark matrix with row names.</p>
</td></tr>
<tr><td><code id="readLandmarksToList_+3A_semilandmark.pattern">semilandmark.pattern</code></td>
<td>
<p>a regular expression pattern passed to <code>sub()</code> for identifying and grouping curve points. The default is landmark names ending in one or more numbers.</p>
</td></tr>
<tr><td><code id="readLandmarksToList_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>read.table()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will read a landmark matrix from one or more files and use the row names in each matrix to match corresponding landmarks into list elements, ordered first by the landmark name and then numbered by the index of the file (in <code>file</code>) from which the landmark was read. Landmark lists are the required input format for <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code>. Landmark lists are also one of three possible input formats for <code><a href="#topic+dltReconstruct">dltReconstruct</a></code> and allow for curve points to be easily pulled out of a landmark set for curve fitting.
</p>
<p><code>semilandmark.pattern</code> is a regular expression passed to <code>sub()</code> to identify semilandmarks (curve points). By default, the regular expression <code>"[0-9]+$"</code> identifies row names that end in more than one digit (e.g. 'tomium_R004') as curve points. <code>sub()</code> removes the part of the string identified by <code>semilandmark.pattern</code> in order to group all curve points under one curve name (e.g. 'tomium_R004' would be grouped under 'tomium_R'). Curve grouping can be turned off by setting <code>semilandmark.pattern</code> to <code>""</code>. Once grouped, curve points are sorted only by the numeric portion of their row name (identified by <code>semilandmark.pattern</code> using <code>regexpr</code>). Preceding zeros are not necessary. For example, after sorting, the order of the following curve points would be: tomium_R1, tomium_R02, tomium_R9, tomium_R10. Note that if these were sorted simply by row name, the order would be: tomium_R02, tomium_R1, tomium_R10, tomium_R9. Landmarks missing from one or more files are given the value <code>NULL</code>.
</p>
<p>The landmark files are read by <code>read.file()</code> and should thus conform to all requirements of <code>read.file()</code>. Arguments for <code>read.file()</code> can be passed through <code>readLandmarksToList()</code> (e.g. <code>header</code>, <code>row.names</code>, etc.).
</p>


<h3>Value</h3>

<p>a landmark list.</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>, <code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>, <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>, 
</p>
<p><code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILES TO LOAD - TWO DIFFERENT 3D POINT SETS
file &lt;- paste0(fdir, "lm_3d_even_a", 1:2, ".txt")

## READ LANDMARKS INTO A LIST
lm.list &lt;- readLandmarksToList(file=file, row.names=1)

## CURVE POINTS
## CURVE POINTS ARE ABSENT FROM FIRST POINT SET
lm.list[['tomium_R']]

## LANDMARKS PRESENT IN BOTH POINT SETS
lm.list[['quadrate_jugal_R']]

## LANDMARK MISSING FROM SECOND POINT SET
lm.list[['foramen_magnum_inf']]
</code></pre>

<hr>
<h2 id='readLandmarksToMatrix'>Reads a landmark file or files into a matrix</h2><span id='topic+readLandmarksToMatrix'></span>

<h3>Description</h3>

<p>Reads landmarks from one or more files into a matrix. A single file or vector of files can be input. If more than one file is input, each matrix will be appended to the previous one with matching landmarks in the same row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLandmarksToMatrix(file, na.omit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLandmarksToMatrix_+3A_file">file</code></td>
<td>
<p>a single landmark file or vector of landmark files to be read. Each file should contain a single landmark matrix.</p>
</td></tr>
<tr><td><code id="readLandmarksToMatrix_+3A_na.omit">na.omit</code></td>
<td>
<p>whether landmarks with NA values in any file should be omitted.</p>
</td></tr>
<tr><td><code id="readLandmarksToMatrix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>read.table()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will read a landmark matrix from one or more files and use the row names in each matrix to match corresponding landmarks into a single matrix, filling in missing landmarks with <code>NA</code>. The rows correspond to landmarks and the columns correspond to the number of landmark dimensions (2 for 2D landmarks, 3 for 3D landmarks, etc.). Each landmark matrix is appended as new columns onto the existing matrix. So, if three, 2D landmark files are input the resulting matrix would have six columns.
</p>
<p>The landmark files are read by <code>read.file()</code> and should thus conform to all requirements of <code>read.file()</code>. Arguments for <code>read.file()</code> can be passed through <code>readLandmarksToList()</code> (e.g. <code>header</code>, <code>row.names</code>, etc.). All landmark matrices must have row names.
</p>


<h3>Value</h3>

<p>a landmark matrix</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToList">readLandmarksToList</a></code>, <code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>, <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GET FILE DIRECTORY FOR PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET FILES TO LOAD
file &lt;- paste0(fdir, "lm_2d_a3_v", 1:2, "_wna.txt")

## LOAD FILES INTO A MATRIX
readLandmarksToMatrix(file=file, row.names=1)

## LOAD FILES INTO A MATRIX OMITTING NAS
readLandmarksToMatrix(file=file, row.names=1, na.omit=TRUE)
</code></pre>

<hr>
<h2 id='readShapes'>Reads a StereoMorph shape file</h2><span id='topic+readShapes'></span><span id='topic+print.shapes'></span>

<h3>Description</h3>

<p>This function reads digitized shape and scaling data from a StereoMorph shape file or files into a list structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readShapes(file, fields=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readShapes_+3A_file">file</code></td>
<td>
<p>A shape file, a vector of shape files or a folder containing shape files to be read.</p>
</td></tr>
<tr><td><code id="readShapes_+3A_fields">fields</code></td>
<td>
<p>Objects to be returned from the shape file. If <code>NULL</code>, all objects in the file will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+digitizeImage">digitizeImage</a></code> function makes it possible to save shape and scaling data into a single shape file. This shape file has an XML-like format that allows the <code>readShapes()</code> function to read multiple object types (including vectors, matrices and lists) into a list structure using a generalized routine. All these objects are saved to a list as several elements. The particular elements in the output list will depend on which objects are present in the file. If the object is not present in the file, a call to that object will return NULL. The contents will also differ if multiple files are input. For instance, if one file is input <code>landmarks.pixel</code> will be a matrix but if multiple files are input it will be an array.
</p>
<p>The output of <code>print()</code> on the entire output list is formatted for readability given the potentially large matrices contained within the list.
</p>


<h3>Value</h3>

<p>a list of class <code>"shapes"</code> containing any number of the following elements:
</p>
<table role = "presentation">
<tr><td><code>image.name</code></td>
<td>
<p>A vector of image names.</p>
</td></tr>
<tr><td><code>image.id</code></td>
<td>
<p>A vector of image IDs.</p>
</td></tr>
<tr><td><code>scaling</code></td>
<td>
<p>A vector of the scaling (real-world units per pixel) of the image.</p>
</td></tr>
<tr><td><code>scaling.units</code></td>
<td>
<p>A vector of the units of <code>scaling</code>.</p>
</td></tr>
<tr><td><code>ruler.pixel</code></td>
<td>
<p>A vector of the interval of the digitized ruler points in pixels.</p>
</td></tr>
<tr><td><code>ruler.interval</code></td>
<td>
<p>A vector of the interval of the digitized ruler points in real-world units.</p>
</td></tr>
<tr><td><code>checkerboard.nx</code></td>
<td>
<p>A vector of the number of internal corners of a checkerboard pattern along one dimension.</p>
</td></tr>
<tr><td><code>checkerboard.ny</code></td>
<td>
<p>A vector of the number of internal corners of a checkerboard pattern along the other dimension.</p>
</td></tr>
<tr><td><code>square.pixel</code></td>
<td>
<p>A vector of the best-fit checkerboard square size in pixels.</p>
</td></tr>
<tr><td><code>square.size</code></td>
<td>
<p>A vector of the best-fit checkerboard square size in real-world units.</p>
</td></tr>
<tr><td><code>landmarks.pixel</code></td>
<td>
<p>A matrix or array of landmark coordinates in pixels.</p>
</td></tr>
<tr><td><code>landmarks.scaled</code></td>
<td>
<p>A matrix or array of scaled landmark coordinates.</p>
</td></tr>
<tr><td><code>ruler.points</code></td>
<td>
<p>A matrix or array of ruler points in pixels.</p>
</td></tr>
<tr><td><code>checker.pixel</code></td>
<td>
<p>A matrix or array of checkerboard points in pixels.</p>
</td></tr>
<tr><td><code>curves.control</code></td>
<td>
<p>A list of Bezier curve control points in pixels.</p>
</td></tr>
<tr><td><code>curves.pixel</code></td>
<td>
<p>A list of Bezier curve points in pixels.</p>
</td></tr>
<tr><td><code>curves.scaled</code></td>
<td>
<p>A list of scaled Bezier curve points.</p>
</td></tr>
</table>
<p>If any of the above objects are absent from the shape file they will be <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+digitizeImage">digitizeImage</a></code>
</p>

<hr>
<h2 id='reconstructStereoSets'>3D reconstruction of landmark and curves from stereo coordinates</h2><span id='topic+reconstructStereoSets'></span>

<h3>Description</h3>

<p>This function reconstructs and unifies landmarks and curves from multiple stereo sets. This function is a wrapper integrating <code><a href="#topic+dltReconstruct">dltReconstruct</a></code>, <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code>, and <code><a href="#topic+unifyLandmarks">unifyLandmarks</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstructStereoSets(shapes.2d, shapes.3d, cal.file, set.names = NULL, 
     min.common = 3, unify = TRUE, reconstruct.curves = TRUE, 
     even.spacing = NULL, print.progress = TRUE, verbose = FALSE, 
     update.only = FALSE, min.direct.tangency = 25, min.fill.tangency = 10, 
     epi.err.weight = 0, rec.err.weight = 1, curves.as.landmarks = FALSE, 
     curve.name.width = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconstructStereoSets_+3A_shapes.2d">shapes.2d</code></td>
<td>
<p>file path to a folder containing 2D (digitized) shape files, separated by view into different folders.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_shapes.3d">shapes.3d</code></td>
<td>
<p>file path to a folder where the 3D shape files will be saved (if it does not already exist one will be created).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_cal.file">cal.file</code></td>
<td>
<p>file path to calibration file created by <code><a href="#topic+calibrateCameras">calibrateCameras</a></code>.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_set.names">set.names</code></td>
<td>
<p>vector of object or specimen names to be processed by the function. If <code>NULL</code> (default) all the files in <code>shapes.2d</code> will be processed.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_min.common">min.common</code></td>
<td>
<p>integer indicating the minimum number of common points required for unification of landmark sets.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_unify">unify</code></td>
<td>
<p>logical indicating whether to unify different aspects of the same object or specimen. If sets are to be unified, the filenames should end in '_a#' (e.g. '_a1', '_a2', etc.) to indicate different aspects of the same object.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_reconstruct.curves">reconstruct.curves</code></td>
<td>
<p>logical indicating whether to reconstruct curves.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_even.spacing">even.spacing</code></td>
<td>
<p>specifies the number of evenly spaced points to be on each curve. This can be an integer (if the number of points for all curve(s) is the same), a list (in which the names of the list elements correspond to the curve names), or a .txt file containing a two column matrix of curve names and the number of points on each curve, separated by tabs and without quotes.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_print.progress">print.progress</code></td>
<td>
<p>logical indicating whether function processes should be printed to the console.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether <code>print.progress</code> should be detailed.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_update.only">update.only</code></td>
<td>
<p>logical indicating whether function should only reconstruct sets for which the 2D data has been modified. If <code>TRUE</code> the function will not process all files in <code>shapes.2d</code>, only those which have been modified since the last function call.</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_min.direct.tangency">min.direct.tangency</code></td>
<td>
<p>input parameter passed to <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code> (see that function's documentation for details).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_min.fill.tangency">min.fill.tangency</code></td>
<td>
<p>input parameter passed to <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code> (see that function's documentation for details).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_epi.err.weight">epi.err.weight</code></td>
<td>
<p>input parameter passed to <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code> (see that function's documentation for details).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_rec.err.weight">rec.err.weight</code></td>
<td>
<p>input parameter passed to <code><a href="#topic+dltMatchCurvePoints">dltMatchCurvePoints</a></code> (see that function's documentation for details).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_curves.as.landmarks">curves.as.landmarks</code></td>
<td>
<p>logical indicating whether curve points should be saved as landmarks (will be added to any existing landmarks).</p>
</td></tr>
<tr><td><code id="reconstructStereoSets_+3A_curve.name.width">curve.name.width</code></td>
<td>
<p>integer indicating the width of numbers added to the curve name in generating curve-to-landmark names. If <code>curves.as.landmarks</code> is <code>TRUE</code>, curve landmarks will be created by adding numbers to the end of the curve name. For example, a <code>curve.name.width</code> value of 5 would be 'curve_name00001'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see <a href="https://aaronolsen.github.io/software/stereomorph.html">StereoMorph tutorials</a> for step-by-step tutorials on how to use <strong>StereoMorph</strong> for 2D or 3D shape data collection.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrateCameras">calibrateCameras</a></code>,
<code><a href="#topic+digitizeImages">digitizeImages</a></code>
</p>

<hr>
<h2 id='reflectMissingLandmarks'>Reflects missing landmarks across the plane of symmetry</h2><span id='topic+reflectMissingLandmarks'></span><span id='topic+summary.reflectMissingLandmarks'></span><span id='topic+print.summary.reflectMissingLandmarks'></span>

<h3>Description</h3>

<p>This function reflects missing bilateral landmarks across the plane of symmetry, optionally averaging left and right landmarks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	
reflectMissingLandmarks(lm.matrix, left = '(_l|_left)([_]?[0-9]*$)', 
                        right = '(_r|_right)([_]?[0-9]*$)',
                        left.remove = '\\2', right.remove = '\\2', 
                        left.replace = '_R\\2', right.replace = '_L\\2', 
                        average = FALSE)

## S3 method for class 'reflectMissingLandmarks'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reflectMissingLandmarks_+3A_lm.matrix">lm.matrix</code></td>
<td>
<p>a 2D or 3D matrix with landmark names as row names.</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_left">left</code></td>
<td>
<p>a regular expression to identify left landmarks in the row names of <code>lm.matrix</code>.</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_right">right</code></td>
<td>
<p>a regular expression to identify right landmarks in the row names of <code>lm.matrix</code>.</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_left.remove">left.remove</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating which element of <code>left</code> in parentheses should be removed to create a landmark name that is not side-specific (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_right.remove">right.remove</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating which element of <code>right</code> in parentheses should be removed to create a landmark name that is not side-specific (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_left.replace">left.replace</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating a replacement string for <code>left</code> that will turn a left landmark name into a right landmark name (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_right.replace">right.replace</code></td>
<td>
<p>an expression for input to the <code>gsub()</code> function indicating a replacement string for <code>right</code> that will turn a right landmark name into a left landmark name (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_average">average</code></td>
<td>
<p>a logical indicating whether bilateral landmarks should be averaged.</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_object">object</code></td>
<td>
<p>a list of class <code>"reflectMissingLandmarks"</code> (output of this function).</p>
</td></tr>
<tr><td><code id="reflectMissingLandmarks_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the function only accepts left/right designations by matching a regular expression to the row names of <code>lm.matrix</code>. This is preferable since it allows for easier match up between bilateral landmarks. The default regular expression identifies left landmarks by a name ending in &quot;_L&quot;, &quot;_l&quot;, &quot;_left&quot; or &quot;_LEFT&quot;, optionally followed by numbers. For example, &quot;hamulus_left&quot;, &quot;hamulus_L&quot; and &quot;zymgomatic_arch_l012&quot; would all be identified as landmarks on the left side. Similarly, &quot;hamulus_right&quot;, &quot;hamulus_R&quot; and &quot;zymgomatic_arch_r012&quot; would all be identified as landmarks on the right side. Landmarks not identified as left or right are assumed to fall on the midline.
</p>
<p>In order to find corresponding left and right landmarks, the function requires the <code>left.remove</code> and <code>right.remove</code> arguments. The <code>left.remove</code> and <code>right.remove</code> arguments are passed to the base function <code>gsub()</code> as the <code>replacement</code> argument. This is used to generate a landmark name that is not side-specific. For example, &quot;hamulus_left&quot; and &quot;zymgomatic_arch_l012&quot; would become &quot;hamulus&quot; and &quot;zymgomatic_arch012&quot;. These will be reverted to their original names at return.
</p>
<p>If only a left or right landmark is present in <code>lm.matrix</code>, <code>reflectMissingLandmarks()</code> will create new a new row in <code>lm.matrix</code> for the missing, contralateral landmark. Thus, the output matrix could be longer than the input matrix. The arguments <code>left.replace</code> and <code>right.replace</code> are used to create these new rownames by converting landmark names from left to right or vice versa. By default, the function replaces the existing side designation with &quot;_L&quot; and &quot;_R&quot;. For instance, &quot;hamulus_left&quot; and &quot;zymgomatic_arch_L012&quot; would become &quot;hamulus_R&quot; and &quot;zymgomatic_arch_R012&quot;, respectively. None of the names of existing landmarks will be modified. Users wanting a different left/right scheme can either change the <code>left.replace</code> and <code>right.replace</code> arguments or make sure that all the bilateral landmarks in <code>lm.matrix</code> are represented by both a left and right landmark (missing values being <code>NA</code>). In this case, <code>left.replace</code> and <code>right.replace</code> will be ignored and no new landmark names will be created.
</p>
<p>Once corresponding right and left landmarks have been identified, the plane of object symmetry is found as described by Klingenberg et al. (2002). This includes creating two landmark sets, reflecting one set across the xy-plane, swapping left and right landmark names in one set and performing Procrustes alignment on the two sets. The user then has the option of averaging across the plane of symmetry. This will cause all bilateral landmarks to be mirror images across the midline plane and midline landmarks to lie directly in the midline plane. The input orientation of <code>lm.matrix</code> is maintained. So if <code>average</code> is <code>FALSE</code>, landmarks that were not missing will be unchanged at output (the new landmarks having been filled in around them). If <code>average</code> is <code>TRUE</code>, the positions of the non-missing landmarks will have changed due to averaging but will only be shifted slightly from the original position.
</p>
<p><code>reflectMissingLandmarks()</code> returns an alignment error vector. This is the error (distance) between a left or right landmark and its contralateral landmark (if present) when reflected across the midline plane. This is equivalent to the Procrustes alignment error.
</p>
<p>Users with landmark names in alternative formats might find it easier to simply add '_L' and '_R' to the end of left and right landmark names, respectively, rather than re-specifying the regular expression arguments.
</p>


<h3>Value</h3>

<p>a list of class <code>"reflectMissingLandmarks"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>lm.matrix</code></td>
<td>
<p>a 2D or 3D matrix of landmarks with missing landmarks reflected. This matrix could be longer than the input landmark matrix.</p>
</td></tr>
<tr><td><code>align.error</code></td>
<td>
<p>a vector of the error (distance) between between a left or right landmark and its contralateral landmark (if present) when reflected across the plane of symmetry.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the R function <code>OSymm()</code> written by A Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>References</h3>

<p>Klingenberg, C.P., Barluengua, M., Meyer, A. (2002) Shape analysis of symmetric structures: Quantifying variation among individuals and asymmetry. <em>Evolution</em>, <b>56</b> (10), 1909&ndash;1920.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readLandmarksToMatrix">readLandmarksToMatrix</a></code>, <code><a href="#topic+alignLandmarksToMidline">alignLandmarksToMidline</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## GET LANDMARKS
file &lt;- paste0(fdir, "lm_3d_unify.txt")

## LOAD FILES INTO A MATRIX
lm.matrix &lt;- readLandmarksToMatrix(file=file, row.names=1)

## ALIGN TO MIDLINE
reflect_missing &lt;- reflectMissingLandmarks(lm.matrix=lm.matrix, average=TRUE)

## PRINT SUMMARY OF ERRORS
print(summary(reflect_missing))
</code></pre>

<hr>
<h2 id='resampleGridImagePoints'>Resamples imaged grid points</h2><span id='topic+resampleGridImagePoints'></span>

<h3>Description</h3>

<p>This function fits a 12-parameter image perspective model to imaged grid points and uses the model parameters to produce a grid with the same transformations but consisting of fewer points, effectively &quot;resampling&quot; the number of grid points. In this way, fewer points (but representing the same amount of information) can be used in more computationally intensive steps such as camera calibration. This function is called by <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>resampleGridImagePoints(pts, nx, rx, ry, fit.min.break=1, 
                        print.progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resampleGridImagePoints_+3A_pts">pts</code></td>
<td>
<p>a matrix of grid points from an image, such as the internal corners of a checkerboard image.</p>
</td></tr>
<tr><td><code id="resampleGridImagePoints_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points in <code>pts</code> are listed first by row).</p>
</td></tr>
<tr><td><code id="resampleGridImagePoints_+3A_rx">rx</code></td>
<td>
<p>the re-sampled number of points along the first dimension (corresponding to <code>nx</code>).</p>
</td></tr>
<tr><td><code id="resampleGridImagePoints_+3A_ry">ry</code></td>
<td>
<p>the re-sampled number of points along the second dimension (e.g. if <code>nx</code> is the number of points per row, this is the new number of points per column).</p>
</td></tr>
<tr><td><code id="resampleGridImagePoints_+3A_fit.min.break">fit.min.break</code></td>
<td>
<p>a minimum returned by <code>nlminb()</code> at which <code>resampleGridImagePoints()</code> will stop iterating to find a better fit.</p>
</td></tr>
<tr><td><code id="resampleGridImagePoints_+3A_print.progress">print.progress</code></td>
<td>
<p>whether the model fit error should be printed. Error is in the same units as <code>pts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>pts</code></td>
<td>
<p>a matrix of resampled grid points.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>the error (in the same units as <code>pts</code>) between the input <code>pts</code> and the model fit grid points of the same dimensions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+imagePlaneGridTransform">imagePlaneGridTransform</a></code>, <code><a href="#topic+readCheckerboardsToArray">readCheckerboardsToArray</a></code>,  <code><a href="#topic+imagePlaneGridTransformError">imagePlaneGridTransformError</a></code>, 
</p>
<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## GET GRID POINTS
file &lt;- paste0(fdir, "cal_a1_v2.txt")

## SET NUMBER OF GRID ROWS AND COLUMNS
nx &lt;- 21
ny &lt;- 14

## READ THE GRID POINTS INTO A MATRIX
## OUTPUT OF FUNCTION IS AN ARRAY SO WE TAKE THE FIRST ENTRY TO GET MATRIX
coor.2d &lt;- as.matrix(read.table(file))

## RESAMPLE THE GRID WITH THE SAME NUMBER OF POINTS AS IN ORIGINAL
coor_2d_same &lt;- resampleGridImagePoints(pts=coor.2d, nx=nx, rx=21, ry=14, 
 print.progress=TRUE)

## RESAMPLE THE GRID WITH A REDUCED NUMBER OF POINTS (4 X 4)
coor_2d_red &lt;- resampleGridImagePoints(pts=coor.2d, nx=nx, rx=4, ry=4, 
 fit.min.break=1, print.progress=TRUE)

## PLOT THE ORIGINAL IMAGED POINTS
plot(coor.2d)

## PLOT THE MODELED GRID POINTS WITHIN THE ORIGINAL POINTS
## THE MODEL GOODNESS-OF-FIT CAN BE EVALUATED VISUALLY
points(coor_2d_same$pts, col='red', cex=0.75)

## PLOT THE REDUCED NUMBER OF GRID POINTS
points(coor_2d_red$pts, col='green', lwd=2, cex=1.25)

## PLOT A HISTOGRAM OF THE FIT ERROR
## HERE UNITS ARE PIXELS - MOST POINTS ARE FIT WITHIN 2 PIXELS
hist(coor_2d_same$error)
</code></pre>

<hr>
<h2 id='TPSToShapes'>Converts TPS file to shape file</h2><span id='topic+TPSToShapes'></span>

<h3>Description</h3>

<p>Converts shape data in the TPS format into the StereoMorph shape file format, primarily for use with the StereoMorph digitizing application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPSToShapes(tps.file, shapes.file, image.file, landmark.names,
        spec.names = c("IMAGE"), scaling.units = NULL, flip.y = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TPSToShapes_+3A_tps.file">tps.file</code></td>
<td>
<p>A TPS file.</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_shapes.file">shapes.file</code></td>
<td>
<p>A folder where the shape files will be saved. If the TPS file contains landmark sets for more than one specimen, the landmarks for each specimen will be written to a separate shape file.</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_image.file">image.file</code></td>
<td>
<p>A folder containing images corresponding to each of the specimens in the TPS file. The image filenames must match the text in the <code>spec.names</code> field within the TPS file.</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_landmark.names">landmark.names</code></td>
<td>
<p>The names corresponding to the landmarks in the TPS file, in the same order in which they are listed in the TPS file. This can be either a vector of landmark names or a '.txt' file with each of the landmark names listed on a separate line.</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_spec.names">spec.names</code></td>
<td>
<p>The label in the TPS file indicating the specimen name.</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_scaling.units">scaling.units</code></td>
<td>
<p>The scaling units for the TPS landmarks (e.g 'cm', 'mm').</p>
</td></tr>
<tr><td><code id="TPSToShapes_+3A_flip.y">flip.y</code></td>
<td>
<p>A logical indicating whether the y-coordinates of the TPS landmarks should be flipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TPS is a common file format used in morphometrics. This function reads landmarks from a TPS file and converts these into the StereoMorph shape file format. This function is intended for users who have previously collected shape data in the TPS format that they would like to import into StereoMorph. The resulting shape files can be opened with the StereoMorph digitizing application (see <code><a href="#topic+digitizeImages">digitizeImages</a></code>).
</p>
<p>In most cases, <code>flip.y</code> should be <code>TRUE</code> (the default). The StereoMorph digitizing application follows the opposite convention from TPS with regard to which part of the image corresponds to the 0 y-coordinate (i.e. top versus bottom). By flipping the y-coordinates the landmarks are properly rendered on top of the image in the digitizing application. Flipping is performed using the height of the corresponding image. For this reason it is necessary to include the <code>image.file</code> parameter to determine the height of the corresponding image.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+readShapes">readShapes</a></code>, 
<code><a href="#topic+writeLMToTPS">writeLMToTPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Convert TPS file to a series of StereoMorph shape files
TPSToShapes(tps.file='tps_file.TPS', shapes.file='Shapes', image.file='Images', 
    landmark.names='landmarks.txt', scaling.units='mm') 

## End(Not run)
</code></pre>

<hr>
<h2 id='transformPlanarCalibrationCoordinates'>Performs rotational and translational transformations to a planar grid</h2><span id='topic+transformPlanarCalibrationCoordinates'></span>

<h3>Description</h3>

<p>This function rotates and translates a planar grid or grids according to specified transformation parameters. This function is called by <code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>, to find the optimal transformation parameters for a set of arbitrarily oriented grid points that minimizes DLT calibration error. This function is also called by <code><a href="#topic+dltTestCalibration">dltTestCalibration</a></code> to generate an ideal grid for accuracy testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformPlanarCalibrationCoordinates(tpar, nx, ny, sx, sy = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformPlanarCalibrationCoordinates_+3A_tpar">tpar</code></td>
<td>
<p>a vector of six transformation parameters per grid. The first three being rotational parameters (rotation about the z, y and x axes, respectively) and the second three being translational parameters (translation along the x, y and z axes, respectively). For more than one grid, these six values are concatenated as a vector.</p>
</td></tr>
<tr><td><code id="transformPlanarCalibrationCoordinates_+3A_nx">nx</code></td>
<td>
<p>the number of points along the first dimension (e.g. this would be the number of points in each row if points are listed first by row).</p>
</td></tr>
<tr><td><code id="transformPlanarCalibrationCoordinates_+3A_ny">ny</code></td>
<td>
<p>the number of points along the second dimension (e.g. this would be the number of points in each column if points are listed first by row).</p>
</td></tr>
<tr><td><code id="transformPlanarCalibrationCoordinates_+3A_sx">sx</code></td>
<td>
<p>a scaling factor along the first dimension.</p>
</td></tr>
<tr><td><code id="transformPlanarCalibrationCoordinates_+3A_sy">sy</code></td>
<td>
<p>a scaling factor along the second dimension. If the grid blocks are squares, this can be left as <code>NULL</code> and only <code>sx</code> will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of transformed 3D grid coordinates</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+dltCalibrateCameras">dltCalibrateCameras</a></code>,
<code><a href="#topic+dltTransformationParameterRMSError">dltTransformationParameterRMSError</a></code>,
<code><a href="#topic+dltTestCalibration">dltTestCalibration</a></code>
</p>

<hr>
<h2 id='unifyLandmarks'>Optimally align a set of partial landmark sets</h2><span id='topic+unifyLandmarks'></span><span id='topic+summary.unifyLandmarks'></span><span id='topic+print.summary.unifyLandmarks'></span>

<h3>Description</h3>

<p>This function aligns two or more landmark sets using shared points. Corresponding landmarks are identified by matching row names. The function selects a sequence of alignments that minimizes the step-wise alignment error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unifyLandmarks(lm.array, min.common = dim(lm.array)[2], return.on.error = FALSE)

## S3 method for class 'unifyLandmarks'
summary(object, print.tab = '', verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unifyLandmarks_+3A_lm.array">lm.array</code></td>
<td>
<p>an array of 2D or 3D landmark matrices. These can be read in from a file or files using <code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>.</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_min.common">min.common</code></td>
<td>
<p>a minimum number of landmarks to use in the alignment. Must be greater than <code>dim(lm.array)[2]</code>.</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_return.on.error">return.on.error</code></td>
<td>
<p>Logical whether to return <code>NULL</code> if there are an insufficient common points for unification.</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_object">object</code></td>
<td>
<p>a list of class <code>"unifyLandmarks"</code> (the output of <code>unifyLandmarks()</code>).</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_print.tab">print.tab</code></td>
<td>
<p>Tabs preceding lines printed to console.</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_verbose">verbose</code></td>
<td>
<p>Logical whether to print full error report.</p>
</td></tr>
<tr><td><code id="unifyLandmarks_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>lm.array</code> should be an array of 2D or 3D landmark matrices with row names, such as created by <code><a href="#topic+readLandmarksToArray">readLandmarksToArray</a></code>. The first two dimensions of <code>lm.array</code> correspond to the rows and columns of each matrix, respectively. The last dimension of <code>lm.array</code> corresponds to each separate landmark matrix.
</p>
<p><code>unifyLandmarks()</code> first aligns all pair combinations of landmark sets that share the minimum number of points specified by <code>min.common</code>. The two sets that align with the lowest root-mean-square (RMS) error are aligned and the mean positions of all points saved. If there are additional landmark sets, <code>unifyLandmarks()</code> aligns each of these with the combined matrix, again identifying the set that aligns with the least RMS error. The alignment with the least error is saved as the new combined landmark matrix. This is repeated for each remaining landmark set, sequentially aligning remaining landmark sets to the combined landmark matrix.
</p>
<p>To align two 2D landmark sets, the sets must share at least two landmarks and to align two 3D landmark sets, the sets must share at least three landmarks. These are the default minimum number of points for alignment. A greater number of common points can be specified using the <code>min.common</code> parameter. Additionally, in the 3D case, these landmarks must not be collinear. If <code>lm.array</code> contains more than two landmark matrices, it is not necessarily required that each landmark set share these minimum number of points with every other landmark set. For example, it may be that two landmark sets do not each separately share the minimum number of landmarks required for alignment with a third landmark set. But if these two landmark sets are combined, they may then share the required number of landmarks with the third set. During each alignment step, <code>unifyLandmarks()</code> skips pairs of matrices that do not share the required number of landmarks. As long as there is some combination of alignments that provide a sufficient number of shared landmarks, all landmark sets can be combined into a single matrix.
</p>
<p>If an array consisting of only one landmark matrix is input, the matrix is returned without an alignment operation.
</p>


<h3>Value</h3>

<p>a list of class <code>"unifyLandmarks"</code> with the following elements:
</p>
<table role = "presentation">
<tr><td><code>lm.matrix</code></td>
<td>
<p>a 2D or 3D landmark matrix.</p>
</td></tr>
<tr><td><code>unify.seq</code></td>
<td>
<p>a vector of the order in which landmark sets were aligned.</p>
</td></tr>
<tr><td><code>unify.error</code></td>
<td>
<p>a matrix of the alignment error for each shared landmark for each alignment (the number of sets minus one).</p>
</td></tr>
<tr><td><code>unify.rmse</code></td>
<td>
<p>a vector of the root-mean-square error of each alignment (the number of sets minus one).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was modified by A Olsen from the R function <code>unifyVD()</code> written by A Haber.</p>


<h3>Author(s)</h3>

<p>Annat Haber, Aaron Olsen</p>


<h3>References</h3>

<p>Rohlf, F.J. (1990) &quot;Chapter 10. Rotational fit (Procrustes) Methods.&quot; <em>Proceedings of the Michigan Morphometrics Workshop</em>. Ed. F. James Rohlf and Fred L. Bookstein. The University of Michigan Museum of Zoology, 1990. 227&ndash;236. <a href="http://deepblue.lib.umich.edu/handle/2027.42/49535">Info page at lib.umich.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findOptimalPointAlignment">findOptimalPointAlignment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIND THE FILE DIRECTORY FOR EXTRA R PACKAGE FILES
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

## SET LANDMARK FILES
file &lt;- paste0(fdir, "lm_3d_even_a", 1:3, ".txt")

## READ LANDMARKS INTO ARRAY
lm.array &lt;- readLandmarksToArray(file, row.names=1)

## UNIFY LANDMARKS
unify_lm &lt;- unifyLandmarks(lm.array)

## PRINT UNIFICATION SUMMARY
print(summary(unify_lm))
</code></pre>

<hr>
<h2 id='writeLMToTPS'>Writes landmarks as TPS file</h2><span id='topic+writeLMToTPS'></span>

<h3>Description</h3>

<p>Reads landmarks from a StereoMorph shape file and writes them in the TPS file format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeLMToTPS(shapes.file, tps.file, in.pixels = TRUE, 
        flip.y = TRUE, flip.x = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeLMToTPS_+3A_shapes.file">shapes.file</code></td>
<td>
<p>A single shape file or folder containing multiple shape files. If this is a folder containing multiple files then all of the landmarks from each file will be written into a single TPS file as separate specimens.</p>
</td></tr>
<tr><td><code id="writeLMToTPS_+3A_tps.file">tps.file</code></td>
<td>
<p>A TPS file where landmarks will be saved.</p>
</td></tr>
<tr><td><code id="writeLMToTPS_+3A_in.pixels">in.pixels</code></td>
<td>
<p>A logical indicating whether function should write pixel or scaled landmark coordinates to the TPS file.</p>
</td></tr>
<tr><td><code id="writeLMToTPS_+3A_flip.y">flip.y</code></td>
<td>
<p>A logical indicating whether to flip the y-coordinates of the landmarks. This may be necessary depending on how another program renders the image.</p>
</td></tr>
<tr><td><code id="writeLMToTPS_+3A_flip.x">flip.x</code></td>
<td>
<p>A logical indicating whether to flip the x-coordinates of the landmarks. This may be necessary depending on how another program renders the image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TPS is a common file format used in morphometrics. This function converts landmarks from the StereoMorph shape file format into the TPS format. This is intended for users who would like to input landmark data collected using StereoMorph into a program that reads TPS files.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Aaron Olsen</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get the path to package example files
fdir &lt;- paste0(path.package("StereoMorph"), "/extdata/")

# Write 2D landmark pixel coordinates from a single shape file to TPS
writeLMToTPS(paste0(fdir, 'Shapes_2D/mug_003.txt'), 'Mug_2D.tps')

# Write 3D landmark coordinates from a single shape file to TPS
writeLMToTPS(paste0(fdir, 'Shapes_3D/bubo_virginianus_FMNH488595.txt'), 'Owl_3D.tps')

# Write 2D landmark pixel coordinates from multiple shape file to TPS
writeLMToTPS(paste0(fdir, 'Shapes_2D'), 'Shapes_2D.tps')

# Write 3D landmark coordinates from multiple shape file to TPS
writeLMToTPS(paste0(fdir, 'Shapes_3D'), 'Shapes_3D.tps', in.pixels=FALSE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
