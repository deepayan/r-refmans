<!DOCTYPE html><html><head><title>Help for package slam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abind'><p>Combine Sparse Arrays</p></a></li>
<li><a href='#apply'>
<p>Apply Functions Over Sparse Matrix Margins</p></a></li>
<li><a href='#crossprod'>
<p>Matrix Crossproduct</p></a></li>
<li><a href='#foreign'><p>Read and Write Sparse Matrix Format Files</p></a></li>
<li><a href='#norms'><p>Row and Column Norms</p></a></li>
<li><a href='#options'><p>Options for the &lsquo;slam&rsquo; package</p></a></li>
<li><a href='#rollup'>
<p>Rollup Sparse Arrays</p></a></li>
<li><a href='#simple_sparse_array'><p>Simple Sparse Arrays</p></a></li>
<li><a href='#simple_triplet_matrix'><p>Simple Triplet Matrix</p></a></li>
<li><a href='#sums'>
<p>Form Row and Column Sums and Means</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-50</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Lightweight Arrays and Matrices</td>
</tr>
<tr>
<td>Description:</td>
<td>Data structures and algorithms for sparse arrays and matrices,
  based on index arrays and simple triplet representations, respectively.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Enhances:</td>
<td>Matrix, SparseM, spam</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-08 14:59:50 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  David Meyer [aut],
  Christian Buchta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kurt Hornik &lt;Kurt.Hornik@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-08 15:01:53 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:19:19 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='abind'>Combine Sparse Arrays</h2><span id='topic+abind_simple_sparse_array'></span><span id='topic+extend_simple_sparse_array'></span>

<h3>Description</h3>

<p>Combine a sequence of (sparse) arrays, matrices, or vectors
into a single sparse array of the same or higher dimension.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
abind_simple_sparse_array(..., MARGIN = 1L)
extend_simple_sparse_array(x, MARGIN = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abind_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects of (or coercible to) class <code>simple_sparse_array</code>.</p>
</td></tr>
<tr><td><code id="abind_+3A_margin">MARGIN</code></td>
<td>
<p>The dimension along which to bind the arrays.</p>
</td></tr>
<tr><td><code id="abind_+3A_x">x</code></td>
<td>
<p>An object of class <code>simple_sparse_array</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>abind_simple_sparse_array</code> automatically extends the dimensions
of the elements of &lsquo;...&rsquo; before it combines them along the
dimension specified in <code>MARGIN</code>. If a negative value is specified
first all elements are extended left of the target dimension.
</p>
<p><code>extend_simple_sparse_array</code> inserts one (or more) one-level
dimension(s) into <code>x</code> to the right of the position(s) specified in
<code>MARGIN</code>, or to the left if specified in negative terms. Note that
the target positions must all be in the range of the dimensions of <code>x</code>
(see Examples).
</p>


<h3>Value</h3>

<p>An object of class <code>simple_sparse_array</code> where the <code>dimnames</code>
are taken from the elements of &lsquo;...&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>See Also</h3>

<p><code><a href="slam.html#topic+simple_sparse_array">simple_sparse_array</a></code> for sparse arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## automatic
abind_simple_sparse_array(1:3, array(4:6, c(1,3)))
abind_simple_sparse_array(1:3, array(4:6, c(3,1)), MARGIN = 2L)

## manual
abind_simple_sparse_array(1:3, 4:6)
abind_simple_sparse_array(1:3, 4:6, MARGIN = -2L)   ## by columns
abind_simple_sparse_array(1:3, 4:6, MARGIN = -1L)   ## by rows

##
a &lt;- as.simple_sparse_array(1:3)
a
extend_simple_sparse_array(a, c( 0L, 1L))
extend_simple_sparse_array(a, c(-1L,-2L))   ## the same
extend_simple_sparse_array(a, c( 1L, 1L))
</code></pre>

<hr>
<h2 id='apply'>
Apply Functions Over Sparse Matrix Margins
</h2><span id='topic+rowapply_simple_triplet_matrix'></span><span id='topic+colapply_simple_triplet_matrix'></span><span id='topic+crossapply_simple_triplet_matrix'></span><span id='topic+tcrossapply_simple_triplet_matrix'></span>

<h3>Description</h3>

<p>Apply functions to (the cross-pairs of) the rows or columns of a sparse
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowapply_simple_triplet_matrix(x, FUN, ...)
colapply_simple_triplet_matrix(x, FUN, ...)

crossapply_simple_triplet_matrix(x, y = NULL, FUN, ...) 
tcrossapply_simple_triplet_matrix(x, y = NULL, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_+3A_x">x</code>, <code id="apply_+3A_y">y</code></td>
<td>
<p>a matrix in <code>simple_triplet_matrix</code>-form or, one of
<code>x</code> and <code>y</code>, of class <code>matrix</code>.
</p>
</td></tr>
<tr><td><code id="apply_+3A_fun">FUN</code></td>
<td>
<p>the name of the function to be applied.
</p>
</td></tr>
<tr><td><code id="apply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>colapply_simple_triplet_matrix</code> temporarily expands each column of
<code>x</code> to dense <code>vector</code> representation and applies the function
specified in <code>FUN</code>.
</p>
<p><code>crossapply_simple_triplet_matrix</code> temporarily expands each cross-pair
of columns of <code>x</code> (and <code>y</code>) to dense <code>vector</code> representation
and applies the function specified in <code>FUN</code>.
</p>
<p>Note that if <code>y = NULL</code> then only the entries in the lower triangle
and the diagonal are computed, assuming that <code>FUN</code> is symmetric.
</p>


<h3>Value</h3>

<p>A <code>vector</code> (<code>matrix</code>) of length (dimensionality) of the margin(s)
used. The type depends on the result of <code>FUN</code>.
</p>
<p>Note that the result of <code>colapply_simple_triplet_matrix</code> is never
simplified to <code>matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code> for dense-on-dense computations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 
x &lt;- matrix(c(1, 0, 0, 2, 1, 0), nrow = 3, 
    dimnames = list(1:3, LETTERS[1:2]))
x
s &lt;- as.simple_triplet_matrix(x)
colapply_simple_triplet_matrix(s, FUN = var)
##
simplify2array(colapply_simple_triplet_matrix(s, identity))
##
crossapply_simple_triplet_matrix(s, FUN = var)
</code></pre>

<hr>
<h2 id='crossprod'>
Matrix Crossproduct
</h2><span id='topic+tcrossprod_simple_triplet_matrix'></span><span id='topic+crossprod_simple_triplet_matrix'></span><span id='topic+matprod_simple_triplet_matrix'></span>

<h3>Description</h3>

<p>Compute the matrix cross-product of a sparse and a dense or sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcrossprod_simple_triplet_matrix(x, y = NULL)
##
crossprod_simple_triplet_matrix(x, y = NULL)
matprod_simple_triplet_matrix(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprod_+3A_x">x</code>, <code id="crossprod_+3A_y">y</code></td>
<td>
<p>a matrix in <code>simple_triplet_matrix</code>-form and/or a dense
matrix, where one must be of the form indicated by the suffix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>tcrossprod_simple_triplet_matrix</code> implements fast computation 
of <code>x %*% t(x)</code> and <code>x %*% t(y)</code> (<code>tcrossprod</code>). The
remaining functions are (optimized) wrappers.
</p>


<h3>Value</h3>

<p>A double matrix, with appropriate <code>dimnames</code> taken from <code>x</code>
and <code>y</code>.
</p>


<h3>Note</h3>

<p>The computation is delegated to <code>tcrossprod</code> if <code>y</code> (or <code>x</code>
if <code>y == NULL</code>) contains any of the special values <code>NA</code>,
<code>NaN</code>, or <code>Inf</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+crossprod">crossprod</a></code> for dense-on-dense computations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 
x &lt;- matrix(c(1, 0, 0, 2, 1, 0), nrow = 3)
x
s &lt;- as.simple_triplet_matrix(x)
tcrossprod_simple_triplet_matrix(s, x)
##
tcrossprod_simple_triplet_matrix(s)
##
tcrossprod_simple_triplet_matrix(s[1L, ], s[2:3, ])
</code></pre>

<hr>
<h2 id='foreign'>Read and Write Sparse Matrix Format Files</h2><span id='topic+read_stm_CLUTO'></span><span id='topic+write_stm_CLUTO'></span><span id='topic+read_stm_MC'></span><span id='topic+write_stm_MC'></span>

<h3>Description</h3>

<p>Read and write CLUTO sparse matrix format files, or the CCS format
variant employed by the MC toolkit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_stm_CLUTO(file)
write_stm_CLUTO(x, file)
read_stm_MC(file, scalingtype = NULL)
write_stm_MC(x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreign_+3A_file">file</code></td>
<td>
<p>a character string with the name of the file to read or
write.</p>
</td></tr>
<tr><td><code id="foreign_+3A_x">x</code></td>
<td>
<p>a matrix object.</p>
</td></tr>
<tr><td><code id="foreign_+3A_scalingtype">scalingtype</code></td>
<td>
<p>a character string specifying the type of scaling
to be used, or <code>NULL</code> (default), in which case the scaling will
be inferred from the names of the files with non-zero entries found
(see <b>Details</b>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Documentation for CLUTO including its sparse matrix format is
available from <a href="https://www-users.cs.umn.edu/~karypis/cluto/">https://www-users.cs.umn.edu/~karypis/cluto/</a>.
</p>
<p><code>read_stm_CLUTO</code> reads CLUTO sparse matrices, returning a
<a href="#topic+matrix">simple triplet matrix</a>.
</p>
<p><code>write_stm_CLUTO</code> writes CLUTO sparse matrices.
Argument <code>x</code> must be coercible to a simple triplet matrix via
<code><a href="#topic+matrix">as.simple_triplet_matrix</a></code>.
</p>
<p>MC is a toolkit for creating vector models from text documents (see 
<a href="https://www.cs.utexas.edu/users/dml/software/mc/">https://www.cs.utexas.edu/users/dml/software/mc/</a>).  It employs a
variant of Compressed Column Storage (CCS) sparse matrix format,
writing data into several files with suitable names: e.g., a file with
&lsquo;<span class="file">_dim</span>&rsquo; appended to the base file name stores the matrix
dimensions.  The non-zero entries are stored in a file the name of
which indicates the scaling type used: e.g., &lsquo;<span class="file">_tfx_nz</span>&rsquo; indicates
scaling by term frequency (&lsquo;<span class="samp">&#8288;t&#8288;</span>&rsquo;), inverse document frequency
(&lsquo;<span class="samp">&#8288;f&#8288;</span>&rsquo;) and no normalization (&lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;).  See &lsquo;<span class="file">README</span>&rsquo; in the
MC sources for more information.
</p>
<p><code>read_stm_MC</code> reads such sparse matrix information with argument
<code>file</code> giving the path with the base file name, and returns a
<a href="#topic+matrix">simple triplet matrix</a>.
</p>
<p><code>write_stm_MC</code> writes matrices in MC CCS sparse matrix format.
Argument <code>x</code> must be coercible to a simple triplet matrix via
<code><a href="#topic+matrix">as.simple_triplet_matrix</a></code>.
</p>

<hr>
<h2 id='norms'>Row and Column Norms</h2><span id='topic+row_norms'></span><span id='topic+col_norms'></span>

<h3>Description</h3>

<p>Compute row and column <code class="reqn">p</code>-norms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_norms(x, p = 2)
col_norms(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norms_+3A_x">x</code></td>
<td>
<p>a sparse <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code>, or a dense
matrix.</p>
</td></tr>
<tr><td><code id="norms_+3A_p">p</code></td>
<td>
<p>a numeric at least one.  Using <code>Inf</code> gives the maximum
norm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the row or column <code class="reqn">p</code>-norms for the given matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1 : 9, 3L)
## Row lengths:
row_norms(x)
## Column maxima:
col_norms(x, Inf)
</code></pre>

<hr>
<h2 id='options'>Options for the &lsquo;slam&rsquo; package</h2><span id='topic+slam_options'></span>

<h3>Description</h3>

<p>Function for getting and setting options for the
<span class="pkg">slam</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>slam_options(option, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="options_+3A_option">option</code></td>
<td>
<p>character string indicating the option to get
or set (see details). If missing, all options are returned as a list.</p>
</td></tr>
<tr><td><code id="options_+3A_value">value</code></td>
<td>
<p>Value to be set. If omitted, the current value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the following options are available:
</p>

<dl>
<dt><code>"max_dense"</code>:</dt><dd><p>numeric specifying the maximum <code>length</code>
of dense vectors (default: <code>2^24</code>).
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="slam.html#topic+simple_sparse_array">simple_sparse_array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## save defaults
.slam_options &lt;- slam_options()
.slam_options

slam_options("max_dense", 2^25)
slam_options("max_dense")

## reset
slam_options("max_dense", .slam_options$max_dense)
</code></pre>

<hr>
<h2 id='rollup'>
Rollup Sparse Arrays
</h2><span id='topic+rollup'></span><span id='topic+rollup.array'></span><span id='topic+rollup.matrix'></span><span id='topic+rollup.simple_triplet_matrix'></span><span id='topic+rollup.simple_sparse_array'></span>

<h3>Description</h3>

<p>Rollup (aggregate) sparse arrays along arbitrary dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollup(x, MARGIN, INDEX, FUN, ...)

## S3 method for class 'simple_triplet_matrix'
rollup(x, MARGIN, INDEX = NULL, FUN = sum, ...,
       REDUCE = FALSE)
## S3 method for class 'simple_sparse_array'
rollup(x, MARGIN, INDEX = NULL, FUN = sum, ..., 
       DROP = FALSE, EXPAND = c("none", "sparse", "dense", "all"), 
       MODE = "double")
## S3 method for class 'matrix'
rollup(x, MARGIN, INDEX = NULL, FUN = sum, ...,
       DROP = FALSE, MODE = "double")
## S3 method for class 'array'
rollup(x, MARGIN, INDEX = NULL, FUN = sum, ..., 
       DROP = FALSE, MODE = "double")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollup_+3A_x">x</code></td>
<td>
<p>a sparse (or dense) array, typically of numeric or logical values.
</p>
</td></tr>
<tr><td><code id="rollup_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts (names) of the dimensions to be rolled up.
</p>
</td></tr>
<tr><td><code id="rollup_+3A_index">INDEX</code></td>
<td>
<p>a corresponding (<code>list</code> of) <code>factor</code> (components) in the sense that <code>as.factor</code> defines the grouping(s). If <code>NULL</code> collapses the corresponding dimension(s) (default).</p>
</td></tr>
<tr><td><code id="rollup_+3A_fun">FUN</code></td>
<td>
<p>the name of the function to be applied.
</p>
</td></tr>
<tr><td><code id="rollup_+3A_reduce">REDUCE</code></td>
<td>
<p>option to remove zeros from the result.</p>
</td></tr>
<tr><td><code id="rollup_+3A_drop">DROP</code></td>
<td>
<p>option to delete the dimensions of the result which have only one level.</p>
</td></tr>
<tr><td><code id="rollup_+3A_expand">EXPAND</code></td>
<td>
<p>the cell expansion method to use (see Details).
</p>
</td></tr>
<tr><td><code id="rollup_+3A_mode">MODE</code></td>
<td>
<p>the type to use for the values if the result is empty.
</p>
</td></tr>
<tr><td><code id="rollup_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides aggregation of sparse and dense arrays, in particular fast summation over the rows or columns of sparse matrices in
<code>simple_triplet</code>-form.
</p>
<p>If (a component of) <code>INDEX</code> contains <code>NA</code> values the
corresponding parts of <code>x</code> are omitted.
</p>
<p>For <code>simple_sparse_array</code> the following cell expansion methods are
provided:
</p>

<dl>
<dt><code>none</code>:</dt><dd><p>The <em>non-zero</em> entries of a cell, if any, are
supplied to <code>FUN</code> as a <code>vector</code>.</p>
</dd>
<dt><code>sparse</code>:</dt><dd><p>The number of <em>zero</em> entries of a cell is 
supplied in addition to above, as a second argument.</p>
</dd>
<dt><code>dense</code>:</dt><dd><p>Cells with <em>non-zero</em> entries are expanded to
a dense <code>array</code> and supplied to <code>FUN</code>.</p>
</dd>
<dt><code>all</code>:</dt><dd><p>All cells are expanded to a dense <code>array</code>
and supplied to <code>FUN</code>.</p>
</dd>
</dl>

<p>Note that the memory and time consumption increases with the level
of expansion.
</p>
<p>Note that the default method tries to coerce <code>x</code> to <code>array</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> where for class
<code>simple_triplet_matrix</code> the values are always of type <code>double</code>
if <code>FUN = sum</code> (default).
</p>
<p>The <code>dimnames</code> corresponding to <code>MARGIN</code> are based on (the 
components of) <code>INDEX</code>.
</p>


<h3>Note</h3>

<p>Currently most of the code is written in R and, therefore, the memory
and time it consumes is not optimal.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>See Also</h3>

<p><code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> and <code><a href="slam.html#topic+simple_sparse_array">simple_sparse_array</a></code>
for sparse arrays.
</p>
<p><code><a href="base.html#topic+apply">apply</a></code> for dense arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
x &lt;- matrix(c(1, 0, 0, 2, 1, NA), nrow = 2, 
	    dimnames = list(A = 1:2, B = 1:3))
x
apply(x, 1L, sum, na.rm = TRUE)
##
rollup(x, 2L, na.rm = TRUE)
##
rollup(x, 2L, c(1,2,1), na.rm = TRUE)
## omit
rollup(x, 2L, c(1,NA,1), na.rm = TRUE)
## expand
a &lt;- as.simple_sparse_array(x)
a
r &lt;- rollup(a, 1L, FUN = mean, na.rm = TRUE, EXPAND = "dense")
as.array(r)
## 
r &lt;- rollup(a, 1L, FUN = function(x, nz) 
	length(x) / (length(x) + nz), 
    EXPAND = "sparse"
)
as.array(r)
</code></pre>

<hr>
<h2 id='simple_sparse_array'>Simple Sparse Arrays</h2><span id='topic+simple_sparse_array'></span><span id='topic+simple_sparse_zero_array'></span><span id='topic+as.simple_sparse_array'></span><span id='topic+is.simple_sparse_array'></span><span id='topic+simplify_simple_sparse_array'></span><span id='topic+reduce_simple_sparse_array'></span><span id='topic+drop_simple_sparse_array'></span>

<h3>Description</h3>

<p>Data structures and operators for sparse arrays based on
a representation by index matrix and value vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_sparse_array(i, v, dim = NULL, dimnames = NULL)

as.simple_sparse_array(x)
is.simple_sparse_array(x)

simplify_simple_sparse_array(x, higher = TRUE)
reduce_simple_sparse_array(x, strict = FALSE, order = FALSE)
drop_simple_sparse_array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_sparse_array_+3A_i">i</code></td>
<td>
<p>Integer matrix of array indices.</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_v">v</code></td>
<td>
<p>Vector of values.</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_dim">dim</code></td>
<td>
<p>Integer vector specifying the size of the dimensions.</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_dimnames">dimnames</code></td>
<td>
<p>either <code>NULL</code> or the names for the dimensions.
This is a list
with one component for each dimension, either <code>NULL</code> or a
character vector of the length given by <code>dim</code> for that
dimension.  The list can be named, and the list names will be
used as names for the dimensions.  If the list is shorter
than the number of dimensions, it is extended by <code>NULL</code>'s to
the length required.</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object; an object of class <code>simple_sparse_array</code>
(see Note).</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_higher">higher</code></td>
<td>
<p>Option to use the dimensions of the values (see Note).</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_strict">strict</code></td>
<td>
<p>Option to treat violations of sparse representation as error
(see Note).</p>
</td></tr>
<tr><td><code id="simple_sparse_array_+3A_order">order</code></td>
<td>
<p>Option to reorder elements (see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simple_sparse_array</code> is a generator for
a class of &ldquo;lightweight&rdquo; sparse arrays, 
represented by index matrices and value vectors.
Currently, only methods for indexing and coercion are implemented.
</p>


<h3>Note</h3>

<p>The <em>zero</em> element is defined as <code>vector(typeof(v), 1L)</code>,
for example, <code>FALSE</code> for <code>logical</code> values (see
<code><a href="base.html#topic+vector">vector</a></code>). Clearly, sparse arrays should not contain
<em>zero</em> elements, however, for performance reasons the class
generator does not remove them.
</p>
<p>If <code>strict = FALSE</code> (default) <code>reduce_simple_sparse_array</code> tries
to repair violations of sparse representation (<em>zero, multiple</em>
elements), otherwise it stops. If <code>order = TRUE</code> the elements are
further reordered (see <code><a href="base.html#topic+array">array</a></code>).
</p>
<p><code>simplify_simple_sparse_array</code> tries to reduce <code>v</code>. If
<code>higher = TRUE</code> (default) augments <code>x</code> by the common dimensions
of <code>v</code> (from the left), or the common length. Note that <em>scalar</em>
elements are never extended and unused dimensions never dropped.
</p>
<p><code>drop_simple_sparse_array</code> drops unused dimensions.
</p>
<p>If <code>prod(dim(x)) &gt; slam_options("max_dense")</code> empty and negative
indexing are disabled
for <code>[</code> and <code>[&lt;-</code>. Further, non-negative single (vector)
indexing is limited to 52 bits of representation.
</p>


<h3>See Also</h3>

<p><code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> for sparse matrices.
</p>
<p><code><a href="slam.html#topic+slam_options">slam_options</a></code> for options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(c(1, 0, 0, 2, 0, 0, 0, 3), dim = c(2, 2, 2))
s &lt;- as.simple_sparse_array(x)
identical(x, as.array(s))

simple_sparse_array(matrix(c(1, 3, 1, 3, 1, 3), nrow = 2), c(1, 2))
</code></pre>

<hr>
<h2 id='simple_triplet_matrix'>Simple Triplet Matrix</h2><span id='topic+simple_triplet_matrix'></span><span id='topic+simple_triplet_zero_matrix'></span><span id='topic+simple_triplet_diag_matrix'></span><span id='topic+as.simple_triplet_matrix'></span><span id='topic+is.simple_triplet_matrix'></span>

<h3>Description</h3>

<p>Data structures and operators for sparse matrices based on
simple triplet representation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_triplet_matrix(i, j, v, nrow = max(i), ncol = max(j),
                      dimnames = NULL)
simple_triplet_zero_matrix(nrow, ncol = nrow, mode = "double")
simple_triplet_diag_matrix(v, nrow = length(v))

as.simple_triplet_matrix(x)
is.simple_triplet_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_triplet_matrix_+3A_i">i</code>, <code id="simple_triplet_matrix_+3A_j">j</code></td>
<td>
<p>Integer vectors of row and column indices, respectively.</p>
</td></tr>
<tr><td><code id="simple_triplet_matrix_+3A_v">v</code></td>
<td>
<p>Vector of values.</p>
</td></tr>
<tr><td><code id="simple_triplet_matrix_+3A_nrow">nrow</code>, <code id="simple_triplet_matrix_+3A_ncol">ncol</code></td>
<td>
<p>Integer values specifying the number of rows and
columns, respectively. Defaults are the maximum row and column indices, respectively.</p>
</td></tr>
<tr><td><code id="simple_triplet_matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>A <code>dimnames</code> attribute for the matrix:
<code>NULL</code> or a <code>list</code> of
length 2 giving the row and column names respectively.  An
empty list is treated as <code>NULL</code>,
and a list of length one as
row names.  The list can be named, and the list names will be
used as names for the dimensions.</p>
</td></tr>
<tr><td><code id="simple_triplet_matrix_+3A_mode">mode</code></td>
<td>
<p>Character string specifying the mode of the values.</p>
</td></tr>
<tr><td><code id="simple_triplet_matrix_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simple_triplet_matrix</code> is a generator for
a class of &ldquo;lightweight&rdquo; sparse matrices, &ldquo;simply&rdquo;
represented by triplets <code>(i, j, v)</code> of row indices <code>i</code>, column
indices <code>j</code>, and values <code>v</code>, respectively.
<code>simple_triplet_zero_matrix</code> and
<code>simple_triplet_diag_matrix</code> are convenience functions for the
creation of empty and diagonal matrices.
</p>
<p>Currently implemented operations include the addition, subtraction,
multiplication and division of compatible simple triplet matrices,
as well as the multiplication and division of a simple triplet matrix
and a vector.  Comparisons of the elements of a simple triplet
matrices with a number are also provided. In addition, 
methods for indexing, combining by rows
(<code>rbind</code>) and columns (<code>cbind</code>), transposing (<code>t</code>),
concatenating (<code>c</code>), and detecting/extracting duplicated and
unique rows are implemented.
</p>


<h3>See Also</h3>

<p><code><a href="slam.html#topic+simple_sparse_array">simple_sparse_array</a></code> for sparse arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 0, 0, 2), nrow = 2)
s &lt;- as.simple_triplet_matrix(x)
identical(x, as.matrix(s))

simple_triplet_matrix(c(1, 4), c(1, 2), c(1, 2))
simple_triplet_zero_matrix(3)
simple_triplet_diag_matrix(1:3)

cbind(rbind(s, t(s)), rbind(s, s))
## Not run: 
## map to default Matrix class
stopifnot(require("Matrix"))
sparseMatrix(i = s$i, j = s$j, x = s$v, dims = dim(s), 
	     dimnames = dimnames(s))

## End(Not run)
</code></pre>

<hr>
<h2 id='sums'>
Form Row and Column Sums and Means
</h2><span id='topic+row_sums'></span><span id='topic+row_sums.simple_triplet_matrix'></span><span id='topic+col_sums'></span><span id='topic+col_sums.simple_triplet_matrix'></span><span id='topic+row_means'></span><span id='topic+row_means.simple_triplet_matrix'></span><span id='topic+col_means'></span><span id='topic+col_means.simple_triplet_matrix'></span>

<h3>Description</h3>

<p>Form row and column sums and means for sparse arrays (currently
<code>simple_triplet_matrix</code> only).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_sums(x, na.rm = FALSE, dims = 1, ...)
col_sums(x, na.rm = FALSE, dims = 1, ...)
row_means(x, na.rm = FALSE, dims = 1, ...)
col_means(x, na.rm = FALSE, dims = 1, ...)

## S3 method for class 'simple_triplet_matrix'
row_sums(x, na.rm = FALSE, dims = 1, ...)
## S3 method for class 'simple_triplet_matrix'
col_sums(x, na.rm = FALSE, dims = 1, ...)
## S3 method for class 'simple_triplet_matrix'
row_means(x, na.rm = FALSE, dims = 1, ...)
## S3 method for class 'simple_triplet_matrix'
col_means(x, na.rm = FALSE, dims = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sums_+3A_x">x</code></td>
<td>
<p>a sparse array containing numeric, integer, or logical values.
</p>
</td></tr>
<tr><td><code id="sums_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values (including <code>NaN</code>)
be omitted from the calculations?
</p>
</td></tr>
<tr><td><code id="sums_+3A_dims">dims</code></td>
<td>
<p>currently not used for sparse arrays.
</p>
</td></tr>
<tr><td><code id="sums_+3A_...">...</code></td>
<td>
<p>currently not used for sparse arrays.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides fast summation over the rows or columns of sparse matrices in
<code>simple_triplet</code>-form.
</p>


<h3>Value</h3>

<p>A numeric (double) array of suitable size, or a vector if the result
is one-dimensional. The <code>dimnames</code> (or <code>names</code> for a vector
result) are taken from the original array.
</p>


<h3>Note</h3>

<p>Results are always of storage type <code>double</code> to avoid (integer)
overflows.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>See Also</h3>

<p><code>simple_triplet_matrix</code>, <code><a href="base.html#topic+colSums">colSums</a></code> for dense
numeric arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
x &lt;- matrix(c(1, 0, 0, 2, 1, NA), nrow = 3)
x
s &lt;- as.simple_triplet_matrix(x)
row_sums(s)
row_sums(s, na.rm = TRUE)
col_sums(s)
col_sums(s, na.rm = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
