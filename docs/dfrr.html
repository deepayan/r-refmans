<!DOCTYPE html><html lang="en"><head><title>Help for package dfrr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dfrr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dfrr-package'><p>Dichotomizd functional response regression (dfrr) model</p></a></li>
<li><a href='#basis'><p>Get the basis functions from a dfrr-object</p></a></li>
<li><a href='#coef.dfrr'><p>Get estimated coefficients from a dfrr fit</p></a></li>
<li><a href='#dfrr'><p>Dichotomized Functional Response Regression (dfrr)</p></a></li>
<li><a href='#fitted.dfrr'><p>Obtain fitted curves for a dfrr model</p></a></li>
<li><a href='#fpca'><p>Functional principal component analysis (fpca) of a dfrr fit</p></a></li>
<li><a href='#madras'><p>Madras Longitudinal Schizophrenia Study.</p></a></li>
<li><a href='#model.matrix.dfrr'><p>Obtain model matrix for a dfrr fit</p></a></li>
<li><a href='#plot.coef.dfrr'><p>Plot dfrr coefficients</p></a></li>
<li><a href='#plot.dfrr'><p>Plot a dfrr fit</p></a></li>
<li><a href='#plot.fitted.dfrr'><p>Plot dfrr fitted latent functions</p></a></li>
<li><a href='#plot.fpca.dfrr'><p>Plot dfrr functional principal components</p></a></li>
<li><a href='#plot.predict.dfrr'><p>Plot  dfrr predictions</p></a></li>
<li><a href='#plot.residuals.dfrr'><p>QQ-plot for dfrr residuals</p></a></li>
<li><a href='#predict.dfrr'><p>Prediction for dichotomized function-on-scalar regression</p></a></li>
<li><a href='#qq'><p>qq-plot Generic function</p></a></li>
<li><a href='#residuals.dfrr'><p>Obtain residuals for a dfrr model</p></a></li>
<li><a href='#simulate_simple_dfrr'><p>Simulating a Simple <code>dfrr</code> Model</p></a></li>
<li><a href='#summary.dfrr'><p>Summary for a dfrr fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dichotomized Functional Response Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fatemeh Asgari &lt;fatemeh.asgari@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementing Function-on-Scalar Regression model in which the response function is dichotomized and observed sparsely. This package provides smooth estimations of functional regression coefficients and principal components for the dichotomized functional response regression (dfrr) model.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), tmvtnorm (&ge; 1.4-10), fda (&ge; 5.1.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, ggplot2, plotly</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/asgari-fatemeh/dfrr">https://github.com/asgari-fatemeh/dfrr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asgari-fatemeh/dfrr/issues">https://github.com/asgari-fatemeh/dfrr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-30 17:14:11 UTC; fatema</td>
</tr>
<tr>
<td>Author:</td>
<td>Fatemeh Asgari [aut, cre],
  Saeed Hayati [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-31 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dfrr-package'>Dichotomizd functional response regression (dfrr) model</h2><span id='topic+dfrr-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Implementing Function-on-Scalar Regression model, in which the response function
is dichotomized and observed sparsely.
This function fits the dichotomized functional response regression (dfrr) model as
</p>
<p style="text-align: center;"><code class="reqn">Y_{i}(t)=I(\beta_0(t)+\beta_1(t)*x_{1i}+\ldots+\beta_{q-1}(t)*x_{(q-1)i}+\varepsilon_{i}(t)+\epsilon_{i}(t)\times\sigma^2&gt;0),</code>
</p>

<p>where <code class="reqn">I(.)</code> is the indicator function, <code class="reqn">\varepsilon_{i}</code> is a Gaussian random function, and <code class="reqn">\epsilon_{i}(t)</code> are iid standard normal for each <code class="reqn">i</code> and <code class="reqn">t</code> independent of <code class="reqn">\varepsilon_{i}</code>.
<code class="reqn">\beta_k</code> and <code class="reqn">x_k</code> for <code class="reqn">k=0,1,\ldots,q-1</code> are the functional regression coefficients and scalar covariates, respectively.
</p>


<h3>Details</h3>

<p>@details
Implementing Function-on-Scalar Regression model in which the response
function is dichotomized and observed sparsely.
This package provides smooth estimations of
functional regression coefficients and principal components for the
dichotomized funtional response regression (dfrr) model.
The main function in the dfrr-package is <a href="#topic+dfrr">dfrr</a>().
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Fatemeh Asgari <a href="mailto:fatemeh.asgari@medisin.uio.no">fatemeh.asgari@medisin.uio.no</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Saeed Hayati <a href="mailto:saeed.hayati@medisin.uio.no">saeed.hayati@medisin.uio.no</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/asgari-fatemeh/dfrr">https://github.com/asgari-fatemeh/dfrr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/asgari-fatemeh/dfrr/issues">https://github.com/asgari-fatemeh/dfrr/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)

coefs&lt;-coef(dfrr_fit)
  plot(coefs)

fitteds&lt;-fitted(dfrr_fit)
  plot(fitteds)

resids&lt;-residuals(dfrr_fit)
plot(resids)

fpcs&lt;-fpca(dfrr_fit)
plot(fpcs,plot.contour=TRUE,plot.3dsurface = TRUE)

newdata&lt;-data.frame(X=c(1,0))
  preds&lt;-predict(dfrr_fit,newdata=newdata)
  plot(preds)


newdata&lt;-data.frame(X=c(1,0))
newydata&lt;-data.frame(.obs=rep(1,5),.index=c(0.0,0.1,0.2,0.3,0.7),.value=c(1,1,1,0,0))
preds&lt;-predict(dfrr_fit,newdata=newdata,newydata = newydata)
plot(preds)

</code></pre>

<hr>
<h2 id='basis'>Get the basis functions from a dfrr-object</h2><span id='topic+basis'></span>

<h3>Description</h3>

<p>Returns the basis functions employed in fitting a dfrr-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basis_+3A_object">object</code></td>
<td>
<p>a fitted <code>dfrr</code>-object obtained from invoking the function <code><a href="#topic+dfrr">dfrr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a basis object used in fitting the functional parameters.
The basis object is the one created by the functions <code>create.*.basis</code> of
the 'fda' package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
coefs&lt;-coef(dfrr_fit,return.fourier.coefs=TRUE)

basis&lt;-basis(dfrr_fit)
evaluated_coefs&lt;-coefs%*%t(fda::eval.basis(time,basis))

#Plotting the regression coefficients
oldpar&lt;-par(mfrow=c(1,2))

plot(time,evaluated_coefs[1,],'l',main="Intercept")
plot(time,evaluated_coefs[2,],'l',main="X")

par(oldpar)

</code></pre>

<hr>
<h2 id='coef.dfrr'>Get estimated coefficients from a dfrr fit</h2><span id='topic+coef.dfrr'></span>

<h3>Description</h3>

<p>Returns estimations of the smooth functional regression coefficients <code class="reqn">\beta(t)</code>.
The result is a matrix of either Fourier coefficients or evaluations. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
coef(
  object,
  standardized = NULL,
  unstandardized = !standardized,
  return.fourier.coefs = NULL,
  return.evaluations = !return.fourier.coefs,
  time_to_evaluate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.dfrr_+3A_object">object</code></td>
<td>
<p>a <code>dfrr</code>-object</p>
</td></tr>
<tr><td><code id="coef.dfrr_+3A_standardized">standardized</code>, <code id="coef.dfrr_+3A_unstandardized">unstandardized</code></td>
<td>
<p>a <code>boolean</code> indicating whether stanadrdized/unstandardized regression coefficients are reported.
Only standardized regression coefficients are identifiable, thus the arugment is defaults to <code>standardized=TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.dfrr_+3A_return.fourier.coefs">return.fourier.coefs</code>, <code id="coef.dfrr_+3A_return.evaluations">return.evaluations</code></td>
<td>
<p>a <code>boolean</code> indicating whether the Fourier coefficients of regression coefficients are returned
(<code>return.fourier.coefs=TRUE</code>), or evaluations of the regression coefficients (<code>return.evaluations=TRUE</code>).
Defaults to <code>return.fourier.coefs=TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.dfrr_+3A_time_to_evaluate">time_to_evaluate</code></td>
<td>
<p>a numeric vector indicating the set of time points for evaluating the functional regression  coefficients, for the case of <code>return.evaluations=TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return either the Fourier coefficients or the evaluation of
estimated coefficients. Fourier coefficients which are reported are
based on the a set of basis which can be determined by <code><a href="#topic+basis">basis</a>(dfrr_fit)</code>.
Thus the evaluation of regression coefficients on the set of time points specified by vector <code>time</code>,
equals to <code>fitted(dfrr_fit)%*%t(<a href="fda.html#topic+eval.basis">eval.basis</a>(time,<a href="#topic+basis">basis</a>(dfrr_fit)))</code>.
</p>
<p>Consider that the unstandardized estimations are not identifiable. So, it is recommended to
extract and report the standardized estimations.
</p>


<h3>Value</h3>

<p>This function returns a <code>matrix</code> of dimension NxM or NxJ, depending
the argument 'return.evaluations'. If <code>return.evaluations=FALSE</code>,
the returned matrix is NxJ, where N denotes the number of functional regression coefficients, (the number of rows of the argument 'newData'),
and J denotes the number of basis functions. Then, the NxJ matrix is
the fourier coefficients of functional regression coefficients.
If <code>return.evaluations=TRUE</code>,
the returned matrix is NxM, where M is the length of the argument <code>time_to_evaluate</code>.
Then, the NxM matrix is the  functional regression coefficients
evaluated at time points given in <code>time_to_evaluate</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.coef.dfrr">plot.coef.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
coefs&lt;-coef(dfrr_fit)
plot(coefs)
</code></pre>

<hr>
<h2 id='dfrr'>Dichotomized Functional Response Regression (dfrr)</h2><span id='topic+dfrr'></span>

<h3>Description</h3>

<p>Implementing Function-on-Scalar Regression model, in which the response function
is dichotomized and observed sparsely.
This function fits the dichotomized functional response regression (dfrr) model as
</p>
<p style="text-align: center;"><code class="reqn">Y_{i}(t)=I(\beta_0(t)+\beta_1(t)*x_{1i}+\ldots+\beta_{q-1}(t)*x_{(q-1)i}+\varepsilon_{i}(t)+\epsilon_{i}(t)\times\sigma^2&gt;0),</code>
</p>

<p>where <code class="reqn">I(.)</code> is the indicator function, <code class="reqn">\varepsilon_{i}</code> is a Gaussian random function, and <code class="reqn">\epsilon_{i}(t)</code> are iid standard normal for each <code class="reqn">i</code> and <code class="reqn">t</code> independent of <code class="reqn">\varepsilon_{i}</code>.
<code class="reqn">\beta_k</code> and <code class="reqn">x_k</code> for <code class="reqn">k=0,1,\ldots,q-1</code> are the functional regression coefficients and scalar covariates, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrr(
  formula,
  yind = NULL,
  data = NULL,
  ydata = NULL,
  method = c("REML", "ML"),
  rangeval = NULL,
  basis = NULL,
  times_to_evaluate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfrr_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class with <code>as.formula</code>:
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_yind">yind</code></td>
<td>
<p>a vector with length equal to the number of columns of the matrix of functional
responses giving the vector of evaluation points <code class="reqn">(t_1,...,t_{G})</code>.
If not supplied, <code>yind</code> is set to <code>1:ncol(&lt;response&gt;)</code>.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_data">data</code></td>
<td>
<p>an (optional) <code>data.frame</code> containing the covariate data.
the variable terms will be searched from the columns of <code>data</code>,
covariates also can be read from the workspace if it is not available in <code>data</code>.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_ydata">ydata</code></td>
<td>
<p>an (optional) <code>data.frame</code> consists of three columns <code>.obs</code>, <code>.index</code> and <code>.value</code>,
supplying the functional responses that are not observed on a regular grid.
ydata must be provided if the sampling design is irregular.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_method">method</code></td>
<td>
<p>detrmines the estimation method of functional parameters. Defaults to &quot;<code>REML</code>&quot; estimation.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_rangeval">rangeval</code></td>
<td>
<p>an (optional) vector of length two, indicating the lower and upper limit of the domain of
latent functional response. If not specified, it will set by minimum and maximum of <code>yind</code> or <code>.index</code> column of <code>ydata</code>.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_basis">basis</code></td>
<td>
<p>an (optional) object of class <code>'basisfd'</code>. Defaults to cubic bspline basis.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_times_to_evaluate">times_to_evaluate</code></td>
<td>
<p>a numeric vector indicating the set of time points for evaluating the functional regression coefficients and principal components.</p>
</td></tr>
<tr><td><code id="dfrr_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to the inner function <code>AMCEM</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a <code>dfrr</code>-object, which then can be injected into other methods/functions
to postprocess the fitted model, including:
<code><a href="#topic+coef.dfrr">coef.dfrr</a></code>,<code><a href="#topic+fitted.dfrr">fitted.dfrr</a></code>, <code><a href="#topic+basis">basis</a></code>, <code><a href="#topic+residuals.dfrr">residuals.dfrr</a></code>, <code><a href="#topic+predict.dfrr">predict.dfrr</a></code>,
<code><a href="#topic+fpca">fpca</a></code>, <code><a href="#topic+summary.dfrr">summary.dfrr</a></code>, <code><a href="#topic+model.matrix.dfrr">model.matrix.dfrr</a></code>,
<code><a href="#topic+plot.coef.dfrr">plot.coef.dfrr</a></code>, <code><a href="#topic+plot.fitted.dfrr">plot.fitted.dfrr</a></code>, <code><a href="#topic+plot.residuals.dfrr">plot.residuals.dfrr</a></code>,
<code><a href="#topic+plot.predict.dfrr">plot.predict.dfrr</a></code>, <code><a href="#topic+plot.fpca.dfrr">plot.fpca.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24
X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)
#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
plot(dfrr_fit)

#Fitting dfrr model to the Madras Longitudinal Schizophrenia data
data(madras)
ids&lt;-unique(madras$id)
N&lt;-length(ids)

ydata&lt;-data.frame(.obs=madras$id,.index=madras$month,.value=madras$y)

xdata&lt;-data.frame(Age=rep(NA,N),Gender=rep(NA,N))
for(i in 1:N){
  dt&lt;-madras[madras$id==ids[i],]
  xdata[i,]&lt;-c(dt$age[1],dt$gender[1])
}
rownames(xdata)&lt;-ids

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
#J is the number of basis functions that will be used in estimating the functional parameters.
madras_dfrr&lt;-dfrr(Y~Age+Gender+Age*Gender, data=xdata, ydata=ydata, J=11,T_E=1)


coefs&lt;-coef(madras_dfrr)
plot(coefs)

fpcs&lt;-fpca(madras_dfrr)
plot(fpcs)
plot(fpcs,plot.eigen.functions=FALSE,plot.contour=TRUE,plot.3dsurface = TRUE)

oldpar&lt;-par(mfrow=c(2,2))

fitteds&lt;-fitted(madras_dfrr) #Plot first four fitted functions
  plot(fitteds,id=c(1,2,3,4))
par(oldpar)

resids&lt;-residuals(madras_dfrr)
plot(resids)


newdata&lt;-data.frame(Age=c(1,1,0,0),Gender=c(1,0,1,0))
  preds&lt;-predict(madras_dfrr,newdata=newdata)
  plot(preds)


newdata&lt;-data.frame(Age=c(1,1,0,0),Gender=c(1,0,1,0))
newydata&lt;-data.frame(.obs=rep(1,5),.index=c(0,1,3,4,5),.value=c(1,1,1,0,0))
preds&lt;-predict(madras_dfrr,newdata=newdata,newydata = newydata)
plot(preds)


</code></pre>

<hr>
<h2 id='fitted.dfrr'>Obtain fitted curves for a dfrr model</h2><span id='topic+fitted.dfrr'></span>

<h3>Description</h3>

<p>Fitted curves refer to the estimations of latent functional response curves.
The results can be either the Fourier coefficients or evaluation of the
fitted functions. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
fitted(
  object,
  return.fourier.coefs = NULL,
  return.evaluations = !return.fourier.coefs,
  time_to_evaluate = NULL,
  standardized = NULL,
  unstandardized = !standardized,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.dfrr_+3A_object">object</code></td>
<td>
<p>a fitted <code>dfrr</code>-object obtained from invoking the function <code><a href="#topic+dfrr">dfrr</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.dfrr_+3A_return.fourier.coefs">return.fourier.coefs</code>, <code id="fitted.dfrr_+3A_return.evaluations">return.evaluations</code></td>
<td>
<p>a <code>boolean</code> indicating whether the Fourier coefficients of the fitted curves are returned
(<code>return.fourier.coefs=TRUE</code>), or evaluations of the fitted curves (<code>return.evaluations=TRUE</code>).
Defaults to <code>return.fourier.coefs=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.dfrr_+3A_time_to_evaluate">time_to_evaluate</code></td>
<td>
<p>a numeric vector indicating the set of time points for evaluating the fitted latent functions, for the case of <code>return.evaluations=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.dfrr_+3A_standardized">standardized</code>, <code id="fitted.dfrr_+3A_unstandardized">unstandardized</code></td>
<td>
<p>a <code>boolean</code> indicating whether stanadrdized/unstandardized fitted latent curves is reported.
Only standardized fitted curves are identifiable, thus the arugment is defaults to <code>standardized=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return either the Fourier coefficients or the evaluation of
fitted curves to the binary sequences. Fourier coefficients which are reported are
based on the a set of basis which can be determined by <code><a href="#topic+basis">basis</a>(dfrr_fit)</code>.
Thus the evaluation of fitted latent curves on the set of time points specified by vector <code>time</code>,
equals to <code>fitted(dfrr_fit)%*%t(<a href="fda.html#topic+eval.basis">eval.basis</a>(time,<a href="#topic+basis">basis</a>(dfrr_fit)))</code>.
</p>
<p>Consider that the unstandardized estimations are not identifiable. So, it is recommended to
extract and report the standardized estimations.
</p>


<h3>Value</h3>

<p>This function returns a <code>matrix</code> of dimension NxM or NxJ, depending
the argument <code>return.evaluations</code>. If <code>return.evaluations=FALSE</code>,
the returned matrix is NxJ, where N denotes the sample size (the number of rows of the argument 'newData'),
and J denotes the number of basis functions. Then, the NxJ matrix is
the fourier coefficients of the fitted curves.
If <code>return.evaluations=TRUE</code>,
the returned matrix is NxM, where M is the length of the argument <code>time_to_evaluate</code>.
Then, the NxM matrix is the fitted curves
evaluated at time points given in <code>time_to_evaluate</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fitted.dfrr">plot.fitted.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
fitteds&lt;-fitted(dfrr_fit)
plot(fitteds)

</code></pre>

<hr>
<h2 id='fpca'>Functional principal component analysis (fpca) of a dfrr fit</h2><span id='topic+fpca'></span>

<h3>Description</h3>

<p><code>fpca()</code>  returns estimations of the smooth principal components/eigen-functions
and the corresponding eigen-values of the residual function in the <code>dfrr</code> model.
The result is a named list containing  the vector of eigen-values and the matrix of Fourier coefficients. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca(object, standardized = NULL, unstandardized = !standardized)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpca_+3A_object">object</code></td>
<td>
<p>a fitted <code>dfrr</code>-object obtained from invoking the function <code><a href="#topic+dfrr">dfrr</a></code>.</p>
</td></tr>
<tr><td><code id="fpca_+3A_standardized">standardized</code>, <code id="fpca_+3A_unstandardized">unstandardized</code></td>
<td>
<p>a <code>boolean</code> indicating whether stanadrdized/unstandardized pricipal components/eigen-functions are reported.
Only standardized pricipal components/eigen-functions are identifiable, thus the arugment is defaults to <code>standardized=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fourier coefficients which are reported are
based on the a set of basis which can be determined by <code><a href="#topic+basis">basis</a>(dfrr_fit)</code>.
Thus the evaluation of pricipal component/eigen-function on the set of time points specified by vector <code>time</code>,
equals to <code>fpca(dfrr_fit)%*%t(<a href="fda.html#topic+eval.basis">eval.basis</a>(time,<a href="#topic+basis">basis</a>(dfrr_fit)))</code>.
</p>
<p>Consider that the unstandardized estimations are not identifiable. So, it is recommended to
extract and report the standardized estimations.
</p>


<h3>Value</h3>

<p><code>fpca(dfrr_fit)</code> returns a list containtng the following components:
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>a vector containing the eigen-values of the standaridized/unstandardized covariance operator of
the residual function term in <code>dfrr</code> model,
sorted in decreasing order.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>a matrix whose columns contain the Fourier coefficients of the
principal components/eigen-functions of the standaridized/unstandardized covariance operator of
the residual function term in <code>dfrr</code> model,
sorted based on the corresponding eigen-values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fpca.dfrr">plot.fpca.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
fpcs&lt;-fpca(dfrr_fit)
plot(fpcs,plot.eigen.functions=TRUE,plot.contour=TRUE,plot.3dsurface = TRUE)

</code></pre>

<hr>
<h2 id='madras'>Madras Longitudinal Schizophrenia Study.</h2><span id='topic+madras'></span>

<h3>Description</h3>

<p>Monthly records of presence/abscence of psychiatric symptom 'thought disorder' of 86 patients
over the first year after initial hospitalisation for disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madras
</code></pre>


<h3>Format</h3>

<p>A data frame with 1032 observations and 5 variables
</p>

<dl>
<dt>id</dt><dd><p>identification number of a patient</p>
</dd>
<dt>y</dt><dd><p>response 'thought disorder': 0 = absent, 1 = present</p>
</dd>
<dt>month</dt><dd><p>month since hospitalisation</p>
</dd>
<dt>age</dt><dd><p>age indicator: 0 = less than 20 years, 1 = 20 or over</p>
</dd>
<dt>gender</dt><dd><p>sex indicator: 0 = male, 1 = female</p>
</dd>
</dl>



<h3>Source</h3>

<p>Diggle PJ, Heagerty P, Liang KY, Zeger SL (2002). The analysis of Longitudinal Data, second ed., pp. 234-43. Oxford University Press, Oxford.<br />
&lt;http://faculty.washington.edu/heagerty/Books/AnalysisLongitudinal/datasets.html&gt;
</p>


<h3>References</h3>

<p>Jokinen J. Fast estimation algorithm for likelihood-based
analysis of repeated categorical responses.
<em>Computational Statistics and Data Analysis</em> 2006; 51:1509-1522.
</p>

<hr>
<h2 id='model.matrix.dfrr'>Obtain model matrix for a dfrr fit</h2><span id='topic+model.matrix.dfrr'></span>

<h3>Description</h3>

<p>Obtain model matrix for a dfrr fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.dfrr_+3A_object">object</code></td>
<td>
<p>a <code>dfrr</code>-object</p>
</td></tr>
<tr><td><code id="model.matrix.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'@return
This function returns the model matrix.
</p>

<hr>
<h2 id='plot.coef.dfrr'>Plot dfrr coefficients</h2><span id='topic+plot.coef.dfrr'></span>

<h3>Description</h3>

<p>Plot a  <code>coef.dfrr</code> object. The output is the plot of regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coef.dfrr'
plot(x, select = NULL, ask.hit.return = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.coef.dfrr_+3A_x">x</code></td>
<td>
<p>a <code>coef.dfrr</code>-object.</p>
</td></tr>
<tr><td><code id="plot.coef.dfrr_+3A_select">select</code></td>
<td>
<p>a vector of length one or more of indices of regression
coefficients to plot.</p>
</td></tr>
<tr><td><code id="plot.coef.dfrr_+3A_ask.hit.return">ask.hit.return</code></td>
<td>
<p>a boolean indicating whether to wait for interaction of the user between any two plots.</p>
</td></tr>
<tr><td><code id="plot.coef.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates the plot of functional regression coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
coefs&lt;-coef(dfrr_fit)
plot(coefs)

</code></pre>

<hr>
<h2 id='plot.dfrr'>Plot a dfrr fit</h2><span id='topic+plot.dfrr'></span>

<h3>Description</h3>

<p>Plot the regression coefficients, principal components, kernel function and residuals of a <code>dfrr</code>-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
plot(x, plot.kernel = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dfrr_+3A_x">x</code></td>
<td>
<p>the output of the function <a href="#topic+fitted.dfrr">fitted.dfrr</a></p>
</td></tr>
<tr><td><code id="plot.dfrr_+3A_plot.kernel">plot.kernel</code></td>
<td>
<p>a boolean indicating whether plots the kernel function or not.
<code>ggplot2</code>-package and <code>plotly</code>-package is required to plot contour and 3d surface of kernel function.</p>
</td></tr>
<tr><td><code id="plot.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code><a href="#topic+plot.coef.dfrr">plot.coef.dfrr</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contour plot of the kernel function is produced if the package <code>ggplot2</code> is installed.
Plotting the 3d surface  of the kernel function is also depends on the package <code>plotly</code>.
To produce the qq-plot, the package <code>car</code> must be installed.
</p>


<h3>Value</h3>

<p>This function generates a set of plots, including
functional regression coefficients, principal components, 2-d contour and 3d-surface of kernel function, and QQ-plot of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
plot(dfrr_fit)


</code></pre>

<hr>
<h2 id='plot.fitted.dfrr'>Plot dfrr fitted latent functions</h2><span id='topic+plot.fitted.dfrr'></span>

<h3>Description</h3>

<p>Plot a  <code>fitted.dfrr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitted.dfrr'
plot(
  x,
  id = NULL,
  main = NULL,
  col = "blue",
  lwd = 2,
  lty = "solid",
  cex.circle = 1,
  col.circle = "black",
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fitted.dfrr_+3A_x">x</code></td>
<td>
<p>the output of the function <a href="#topic+fitted.dfrr">fitted.dfrr</a></p>
</td></tr>
<tr><td><code id="plot.fitted.dfrr_+3A_id">id</code></td>
<td>
<p>a vector of length one or more containing subject ids to plot. Must be matched with
<code>rownames(&lt;response&gt;)</code> or the <code>.obs</code> column of <code>ydata</code>. Defaults to
all  subject ids.</p>
</td></tr>
<tr><td><code id="plot.fitted.dfrr_+3A_main">main</code></td>
<td>
<p>a vector of length one or <code>length(id)</code> containing the title of
plots.</p>
</td></tr>
<tr><td><code id="plot.fitted.dfrr_+3A_col">col</code>, <code id="plot.fitted.dfrr_+3A_lwd">lwd</code>, <code id="plot.fitted.dfrr_+3A_lty">lty</code>, <code id="plot.fitted.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.fitted.dfrr_+3A_cex.circle">cex.circle</code>, <code id="plot.fitted.dfrr_+3A_col.circle">col.circle</code></td>
<td>
<p>size and color of circles and filled circles.</p>
</td></tr>
<tr><td><code id="plot.fitted.dfrr_+3A_ylim">ylim</code></td>
<td>
<p>a vector of length two indicating the range of y-axis of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is the plot of latent curves over the observed binary sequence.
The binary sequence is illustrated with circles and filled circles for the values
of zero and one, respectively.
</p>


<h3>Value</h3>

<p>This function generates plot of fitted curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
fitteds&lt;-fitted(dfrr_fit)
plot(fitteds)

</code></pre>

<hr>
<h2 id='plot.fpca.dfrr'>Plot dfrr functional principal components</h2><span id='topic+plot.fpca.dfrr'></span>

<h3>Description</h3>

<p>Plot a <code>fpca.dfrr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpca.dfrr'
plot(
  x,
  plot.eigen.functions = TRUE,
  select = NULL,
  plot.contour = FALSE,
  plot.3dsurface = FALSE,
  plot.contour.pars = list(breaks = NULL, minor_breaks = NULL, n.breaks = NULL, labels =
    NULL, limits = NULL, colors = NULL, xlab = NULL, ylab = NULL, title = NULL),
  plot.3dsurface.pars = list(xlab = NULL, ylab = NULL, zlab = NULL, title = NULL, colors
    = NULL),
  ask.hit.return = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fpca.dfrr_+3A_x">x</code></td>
<td>
<p>a <code>fpca.dfrr</code>-object to be plotted. It is the output of the function <code><a href="#topic+fpca">fpca</a>()</code></p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_plot.eigen.functions">plot.eigen.functions</code></td>
<td>
<p>a <code>boolean</code> indicating whether to print the principal components/eigen-functions. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_select">select</code></td>
<td>
<p>a vector of length one or more of indices of eigenfunctions to be plotted.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_plot.contour">plot.contour</code></td>
<td>
<p>a <code>boolean</code> indicating whether to print the contour plot of the kernel function.
It requires <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> to be installed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_plot.3dsurface">plot.3dsurface</code></td>
<td>
<p>a <code>boolean</code> indicating whether to print the 3d surface plot of the kernel function.
It requires the package <code><a href="plotly.html#topic+plotly">plotly</a></code> to be installed. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_plot.contour.pars">plot.contour.pars</code></td>
<td>
<p>a named list of graphical parameters passed to the function <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_plot.3dsurface.pars">plot.3dsurface.pars</code></td>
<td>
<p>a named list of graphical parameters passed to the function <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_ask.hit.return">ask.hit.return</code></td>
<td>
<p>a boolean indicating whether to wait for interaction of the user between any two plots.</p>
</td></tr>
<tr><td><code id="plot.fpca.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>plot</code> function in drawing 2D eigenfunctions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the functional principal components,  contour plot and 3d surface of
the kernel function.
</p>
<p>If <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> is installed, the contour plot of
the kernel function is produced by setting the argument <code>plot.contour=TRUE</code>.
Some graphical parameters of the contour plot can be modified by setting the (optional) argument
<code>plot.contour.pars</code>.
</p>
<p>If the package <code><a href="plotly.html#topic+plotly">plotly</a></code> is installed, the 3d surface  of
the kernel function is produced by setting the argument <code>plot.3dsurface=TRUE</code>.
Some graphical parameters of the 3d surface can be modified by setting the (optional) argument
<code>plot.3dsurface.pars</code>.
</p>


<h3>Value</h3>

<p>This function generates the plot of principal components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

 #The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
fpcs&lt;-fpca(dfrr_fit)
plot(fpcs,plot.eigen.functions=TRUE,plot.contour=TRUE,plot.3dsurface=TRUE)

</code></pre>

<hr>
<h2 id='plot.predict.dfrr'>Plot  dfrr predictions</h2><span id='topic+plot.predict.dfrr'></span>

<h3>Description</h3>

<p>Plot a  <code>predict.dfrr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.dfrr'
plot(
  x,
  id = NULL,
  main = id,
  col = "blue",
  lwd = 2,
  lty = "solid",
  cex.circle = 1,
  col.circle = "black",
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predict.dfrr_+3A_x">x</code></td>
<td>
<p>a <code>predict.dfrr</code>-object</p>
</td></tr>
<tr><td><code id="plot.predict.dfrr_+3A_id">id</code></td>
<td>
<p>a vector of length one or more containing subject ids to plot. Must be matched with
<code>rownames(newdata)</code>. Defaults to
all subject ids.</p>
</td></tr>
<tr><td><code id="plot.predict.dfrr_+3A_main">main</code></td>
<td>
<p>a vector of length one or <code>length(id)</code> containing the title of plots.</p>
</td></tr>
<tr><td><code id="plot.predict.dfrr_+3A_col">col</code>, <code id="plot.predict.dfrr_+3A_lwd">lwd</code>, <code id="plot.predict.dfrr_+3A_lty">lty</code>, <code id="plot.predict.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.predict.dfrr_+3A_cex.circle">cex.circle</code>, <code id="plot.predict.dfrr_+3A_col.circle">col.circle</code></td>
<td>
<p>size and color of circles and filled circles.</p>
</td></tr>
<tr><td><code id="plot.predict.dfrr_+3A_ylim">ylim</code></td>
<td>
<p>a vector of length two indicating the range of y-axis of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is the plot of predictions of latent functions given the new covariates.
For the case in which <code>newydata</code> is also given, the predictions are plotted
over the observed binary sequence.
The binary sequence is illustrated with circles and filled circles for the values
of zero and one, respectively.
</p>


<h3>Value</h3>

<p>This function generates the plot of predictions.
</p>


<h3>References</h3>

<p>Choi, H., &amp; Reimherr, M.  A geometric approach to confidence regions and bands for functional parameters .
<em>Journal of the Royal Statistical Society, Series B Statistical methodology</em> 2018; 80:239-260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

 #The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)

newdata&lt;-data.frame(X=c(1,0))
  preds&lt;-predict(dfrr_fit,newdata=newdata)
  plot(preds)

newdata&lt;-data.frame(X=c(1,0))
newydata&lt;-data.frame(.obs=rep(1,5),.index=c(0.0,0.1,0.2,0.3,0.7),.value=c(1,1,1,0,0))
preds&lt;-predict(dfrr_fit,newdata=newdata,newydata = newydata)
plot(preds)

</code></pre>

<hr>
<h2 id='plot.residuals.dfrr'>QQ-plot for dfrr residuals</h2><span id='topic+plot.residuals.dfrr'></span><span id='topic+qq.dfrr'></span>

<h3>Description</h3>

<p>The output gives the qq-plot of estimated measurment error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'residuals.dfrr'
plot(x, ...)

## S3 method for class 'dfrr'
qq(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.residuals.dfrr_+3A_x">x</code></td>
<td>
<p>a <code>residuals.dfrr</code>-object.</p>
</td></tr>
<tr><td><code id="plot.residuals.dfrr_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>car::<a href="car.html#topic+qqPlot">qqPlot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates the QQ-plot of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
resid&lt;-residuals(dfrr_fit)
plot(resid)
# We can also use the qq function to draw the QQ-plot.

</code></pre>

<hr>
<h2 id='predict.dfrr'>Prediction for dichotomized function-on-scalar regression</h2><span id='topic+predict.dfrr'></span>

<h3>Description</h3>

<p>Takes a <code>dfrr</code>-object created by <code><a href="#topic+dfrr">dfrr</a>()</code> and returns predictions
given a new set of values for a model covariates and an optional <code>ydata</code>-like
<code>data.frame</code> of observations for the dichotomized response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
predict(
  object,
  newdata,
  newydata = NULL,
  standardized = NULL,
  unstandardized = !standardized,
  return.fourier.coefs = NULL,
  return.evaluations = !return.fourier.coefs,
  time_to_evaluate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dfrr_+3A_object">object</code></td>
<td>
<p>a fitted <code>dfrr</code>-object obtained from invoking the function <code><a href="#topic+dfrr">dfrr</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_newdata">newdata</code></td>
<td>
<p>a <code>data.frame</code> containing the values of all of the
model covariates at which the latent functional response is going  to be
predicted.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_newydata">newydata</code></td>
<td>
<p>(optional) a <code>ydata</code>-like <code>data.frame</code> containing
the values of dichotomized response sparsly observed in the domain of function.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_standardized">standardized</code>, <code id="predict.dfrr_+3A_unstandardized">unstandardized</code></td>
<td>
<p>a <code>boolean</code> indicating whether stanadrdized/unstandardized predictions are reported.
Defaults to <code>standardized=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_return.fourier.coefs">return.fourier.coefs</code>, <code id="predict.dfrr_+3A_return.evaluations">return.evaluations</code></td>
<td>
<p>a <code>boolean</code> indicating whether the Fourier coefficients of predictions are returned
(<code>return.fourier.coefs=TRUE</code>), or evaluations of the predictions (<code>return.evaluations=TRUE</code>).
Defaults to <code>return.evaluations=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_time_to_evaluate">time_to_evaluate</code></td>
<td>
<p>a numeric vector indicating the set of time points for evaluating the predictions, for the case of <code>return.evaluations=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will return either the Fourier coefficients or the evaluation of
predictions. Fourier coefficients which are reported are
based on the a set of basis which can be determined by <code><a href="#topic+basis">basis</a>(dfrr_fit)</code>.
Thus the evaluation of predictions on the set of time points specified by vector <code>time</code>,
equals to <code>fitted(dfrr_fit,return.fourier.coefs=T)%*%t(<a href="fda.html#topic+eval.basis">eval.basis</a>(time,<a href="#topic+basis">basis</a>(dfrr_fit)))</code>.
</p>


<h3>Value</h3>

<p>This function returns a <code>matrix</code> of dimension NxM or NxJ, depending
the argument 'return.evaluations'. If <code>return.evaluations=FALSE</code>,
the returned matrix is NxJ, where N denotes the sample size (the number of rows of the argument 'newData'),
and J denotes the number of basis functions. Then, the NxJ matrix is
the fourier coefficients of the predicted curves.
If <code>return.evaluations=TRUE</code>,
the returned matrix is NxM, where M is the length of the argument <code>time_to_evaluate</code>.
Then, the NxM matrix is the predicted curves
evaluated at time points given in <code>time_to_evaluate</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.predict.dfrr">plot.predict.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)

newdata&lt;-data.frame(X=c(1,0))
  preds&lt;-predict(dfrr_fit,newdata=newdata)
  plot(preds)

newdata&lt;-data.frame(X=c(1,0))
newydata&lt;-data.frame(.obs=rep(1,5),.index=c(0.0,0.1,0.2,0.3,0.7),.value=c(1,1,1,0,0))
preds&lt;-predict(dfrr_fit,newdata=newdata,newydata = newydata)
plot(preds)

</code></pre>

<hr>
<h2 id='qq'>qq-plot Generic function</h2><span id='topic+qq'></span>

<h3>Description</h3>

<p>This is a generic function for qq() method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qq_+3A_x">x</code></td>
<td>
<p>an <code>dfrr-fit</code> object</p>
</td></tr>
<tr><td><code id="qq_+3A_...">...</code></td>
<td>
<p>extra parameters passed to S3 methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates the QQ-plot of residuals.
</p>

<hr>
<h2 id='residuals.dfrr'>Obtain residuals for a dfrr model</h2><span id='topic+residuals.dfrr'></span>

<h3>Description</h3>

<p>Returns the residuals of a fitted <code>dfrr</code> model.
A <code>dfrr</code> model is of the form:
</p>
<p style="text-align: center;"><code class="reqn">Y_{i}(t)=I(W_{i}(t)&gt;0),</code>
</p>

<p>in which   <code class="reqn">I(.)</code> is the indicator function and <code class="reqn">W_{i}(t)=Z_{i}(t)+\epsilon_{i}(t)\times\sigma^2</code>, where <code class="reqn">Z_{i}(t)</code> is the functional part of the model and <code class="reqn">epsilon_{i}(t)\times\sigma^2</code> is the measurement error.
The functional part of the model, consisting a location and a residual function of the form:
</p>
<p style="text-align: center;"><code class="reqn">Z_{i}(t)=\sum_{j=1}^{q}\beta_{j}(t)*x_{ji}+\varepsilon_{i}(t),</code>
</p>

<p>and <code class="reqn">\epsilon_{i}(t)</code> are iid standard normal for each <code class="reqn">i</code> and <code class="reqn">t</code>.
The residuals reported in the output of this functions is the estimation of the
measurement error of the model i.e. <code class="reqn">\epsilon_{i}(t)\times\sigma^2</code>, which is estimated by:
</p>
<p style="text-align: center;"><code class="reqn">E(W_{i}(t)-Z_{i}(t)\mid Y_{i}(t)).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
residuals(object, standardized = NULL, unstandardized = !standardized, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.dfrr_+3A_object">object</code></td>
<td>
<p>a fitted <code>dfrr</code>-object obtained from invoking the function <code><a href="#topic+dfrr">dfrr</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.dfrr_+3A_standardized">standardized</code>, <code id="residuals.dfrr_+3A_unstandardized">unstandardized</code></td>
<td>
<p>a <code>boolean</code> indicating whether stanadrdized/unstandardized residuals are reported.
Defaults to <code>standardized=TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns either a <code>matrix</code> or  a <code>data.frame</code>.
If the argument ydata is specified, the return value is 'ydata' with
a column added, namely 'residual'. Otherwise, the return value
is a matrix of residuals of dimension NxM where N is the number of sample curves,
and  M is the length of argument 'yind' passed to the function <code>dfrr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.residuals.dfrr">plot.residuals.dfrr</a></code>, <code><a href="#topic+qq.dfrr">qq.dfrr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2000)
N&lt;-50;M&lt;-24

X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)

#The argument T_E indicates the number of EM algorithm.
#T_E is set to 1 for the demonstration purpose only.
#Remove this argument for the purpose of converging the EM algorithm.
dfrr_fit&lt;-dfrr(Y~X,yind=time,T_E=1)
resid&lt;-residuals(dfrr_fit)


plot(resid)
# We can also use the qq function to draw the QQ-plot.

</code></pre>

<hr>
<h2 id='simulate_simple_dfrr'>Simulating a Simple <code>dfrr</code> Model</h2><span id='topic+simulate_simple_dfrr'></span>

<h3>Description</h3>

<p>Simulation from a simple dfrr model:
</p>
<p style="text-align: center;"><code class="reqn">Y_{i}(t)=I(\beta_0(t)+\beta_1(t)*x_{i}+\varepsilon_{i}(t)+\epsilon_{i}(t)\times\sigma^2&gt;0),</code>
</p>

<p>where <code class="reqn">I(.)</code> is the indicator function, <code class="reqn">\varepsilon_{i}</code> is a Gaussian random function, and <code class="reqn">\epsilon_{i}(t)</code> are iid standard normal for each <code class="reqn">i</code> and <code class="reqn">t</code> independent of <code class="reqn">\varepsilon_{i}</code>.
For demonstration purpose only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_simple_dfrr(
  beta0 = function(t) {
     cos(pi * t + pi)
 },
  beta1 = function(t) {
     2 * t
 },
  X = rnorm(50),
  time = seq(0, 1, length.out = 24),
  sigma2 = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_simple_dfrr_+3A_beta0">beta0</code>, <code id="simulate_simple_dfrr_+3A_beta1">beta1</code></td>
<td>
<p>(optional) functional intercept and slope parameters</p>
</td></tr>
<tr><td><code id="simulate_simple_dfrr_+3A_x">X</code></td>
<td>
<p>an (optional) vector consists of scalar covariate</p>
</td></tr>
<tr><td><code id="simulate_simple_dfrr_+3A_time">time</code></td>
<td>
<p>an (optional) vector of time points for which, each sample curve is observed at.</p>
</td></tr>
<tr><td><code id="simulate_simple_dfrr_+3A_sigma2">sigma2</code></td>
<td>
<p>variance of the measurement error in the <code>dfrr</code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a martix of binary values of dimension NxM where
N denotes the length of X and M stands for the length of time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N&lt;-50;M&lt;-24
X&lt;-rnorm(N,mean=0)
time&lt;-seq(0,1,length.out=M)
Y&lt;-simulate_simple_dfrr(beta0=function(t){cos(pi*t+pi)},
                        beta1=function(t){2*t},
                        X=X,time=time)
</code></pre>

<hr>
<h2 id='summary.dfrr'>Summary for a dfrr fit</h2><span id='topic+summary.dfrr'></span>

<h3>Description</h3>

<p>Summarise a fitted <code>dfrr</code>-object. Not implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfrr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dfrr_+3A_object">object</code></td>
<td>
<p>a <code>dfrr</code>-object</p>
</td></tr>
<tr><td><code id="summary.dfrr_+3A_...">...</code></td>
<td>
<p>dot argument, just for consistency with the generic function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.dfrr</code> computes and returns a list of summary statistics of the fitted dfrr model given in <code>dfrr</code>-object. Not implemented.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
