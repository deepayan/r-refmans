<!DOCTYPE html><html><head><title>Help for package spatialrisk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatialrisk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_gh_bbox_sum'><p>Determine total sum for each geohash with buffer of 200m</p></a></li>
<li><a href='#add_gh_nghbrs_sum'><p>Determine total insured sum of all neighbours (including hash itself)</p>
df should contain a column called hash and a column with sum per hash</a></li>
<li><a href='#choropleth'><p>Create choropleth map</p></a></li>
<li><a href='#choropleth_ggplot2'><p>Map object of class sf using ggplot2</p></a></li>
<li><a href='#concentration'><p>Concentration risk</p></a></li>
<li><a href='#Groningen'><p>Coordinates of houses in Groningen</p></a></li>
<li><a href='#haversine'><p>Haversine great circle distance</p></a></li>
<li><a href='#highest_concentration'><p>Highest concentration risk</p></a></li>
<li><a href='#insurance'><p>Sum insured per postal code in the Netherlands</p></a></li>
<li><a href='#interpolate_krige'><p>Ordinary kriging</p></a></li>
<li><a href='#interpolate_spline'><p>Splines on the sphere</p></a></li>
<li><a href='#knmi_historic_data'><p>Retrieve historic weather data for the Netherlands</p></a></li>
<li><a href='#knmi_stations'><p>KNMI stations</p></a></li>
<li><a href='#lower_bound_fn'><p>Determine a lower bound for highest concentration</p>
Calculate concentration for the coordinates of the highest insured sums</a></li>
<li><a href='#neighborhood_gh_search'><p>Search for coordinates with higher concentrations within geohash</p></a></li>
<li><a href='#nl_corop'><p>Object of class <code>sf</code> for COROP regions in the Netherlands</p></a></li>
<li><a href='#nl_gemeente'><p>Object of class <code>sf</code> for municipalities in the Netherlands</p></a></li>
<li><a href='#nl_postcode2'><p>Object of class <code>sf</code> for 2-digit postcode regions in the Netherlands</p></a></li>
<li><a href='#nl_postcode3'><p>Object of class <code>sf</code> for 3-digit postcode regions in the Netherlands</p></a></li>
<li><a href='#nl_postcode4'><p>Object of class <code>sf</code> for 4-digit postcode regions in the Netherlands</p></a></li>
<li><a href='#nl_provincie'><p>Object of class <code>sf</code> for provinces in the Netherlands</p></a></li>
<li><a href='#plot_points'><p>Create map with points</p></a></li>
<li><a href='#plot.concentration'><p>Automatically create a plot for objects obtained from highest_concentration()</p></a></li>
<li><a href='#plot.neighborhood'><p>Automatically create a plot for objects obtained from</p>
neighborhood_gh_search()</a></li>
<li><a href='#points_in_circle'><p>Points in circle</p></a></li>
<li><a href='#points_to_polygon'><p>Aggregate attributes of coordinates to area level</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculating Spatial Risk</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Haringa &lt;mtharinga@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mharinga/spatialrisk/issues">https://github.com/mharinga/spatialrisk/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for spatial risk calculations. It offers an efficient approach to determine the sum of all observations within a 
     circle of a certain radius. This might be beneficial for insurers who are required (by a recent European Commission regulation) to determine 
     the maximum value of insured fire risk policies of all buildings that are partly or fully located within a circle of a radius of 200m. See 
     Church (1974) &lt;<a href="https://doi.org/10.1007%2FBF01942293">doi:10.1007/BF01942293</a>&gt; for a description of the problem.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mharinga/spatialrisk">https://github.com/mharinga/spatialrisk</a>,
<a href="https://mharinga.github.io/spatialrisk/">https://mharinga.github.io/spatialrisk/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Imports:</td>
<td>classInt, colourvalues, data.table, dplyr, fs, GenSA,
geohashTools, ggplot2, leafem, leafgl, leaflet, methods, Rcpp,
RcppProgress, sf, tmap, units, viridis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>automap, gstat, knitr, mgcv, rmarkdown, testthat, vroom</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 12:29:23 UTC; martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Haringa [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_gh_bbox_sum'>Determine total sum for each geohash with buffer of 200m</h2><span id='topic+add_gh_bbox_sum'></span>

<h3>Description</h3>

<p>Determine total sum for each geohash with buffer of 200m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_gh_bbox_sum(hash_decode, full, lon_nm, lat_nm, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_gh_bbox_sum_+3A_hash_decode">hash_decode</code></td>
<td>
<p>data.frame as output from 'geohashTools::gh_decode()'</p>
</td></tr>
<tr><td><code id="add_gh_bbox_sum_+3A_full">full</code></td>
<td>
<p>data.frame with portfolio with lon, lat and sum insured</p>
</td></tr>
</table>

<hr>
<h2 id='add_gh_nghbrs_sum'>Determine total insured sum of all neighbours (including hash itself)
df should contain a column called hash and a column with sum per hash</h2><span id='topic+add_gh_nghbrs_sum'></span>

<h3>Description</h3>

<p>Determine total insured sum of all neighbours (including hash itself)
df should contain a column called hash and a column with sum per hash
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_gh_nghbrs_sum(df, colname_sum)
</code></pre>

<hr>
<h2 id='choropleth'>Create choropleth map</h2><span id='topic+choropleth'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>points_to_polygon()</code>, and
creates the corresponding choropleth map. The given clustering is according
to the Fisher-Jenks algorithm. This commonly used method for choropleths
seeks to reduce the variance within classes and maximize the variance
between classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choropleth(
  sf_object,
  value = "output",
  id_name = "areaname",
  mode = "plot",
  n = 7,
  legend_title = "Clustering",
  palette = "viridis"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choropleth_+3A_sf_object">sf_object</code></td>
<td>
<p>object of class sf</p>
</td></tr>
<tr><td><code id="choropleth_+3A_value">value</code></td>
<td>
<p>column name to shade the polygons</p>
</td></tr>
<tr><td><code id="choropleth_+3A_id_name">id_name</code></td>
<td>
<p>column name of ids to plot</p>
</td></tr>
<tr><td><code id="choropleth_+3A_mode">mode</code></td>
<td>
<p>choose between static ('plot' is default) and interactive
map ('view')</p>
</td></tr>
<tr><td><code id="choropleth_+3A_n">n</code></td>
<td>
<p>number of clusters (default is 7)</p>
</td></tr>
<tr><td><code id="choropleth_+3A_legend_title">legend_title</code></td>
<td>
<p>title of legend</p>
</td></tr>
<tr><td><code id="choropleth_+3A_palette">palette</code></td>
<td>
<p>palette name or a vector of colors. See
tmaptools::palette_explorer() for the named palettes.
Use a &quot;-&quot; as prefix to reverse the palette. The default palette is &quot;viridis&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tmap
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- points_to_polygon(nl_provincie, insurance, sum(amount, na.rm = TRUE))
choropleth(test)
choropleth(test, id_name = "areaname", mode = "view")
</code></pre>

<hr>
<h2 id='choropleth_ggplot2'>Map object of class sf using ggplot2</h2><span id='topic+choropleth_ggplot2'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>choropleth_sf()</code>, and creates
the correspoding choropleth map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choropleth_ggplot2(
  sf_object,
  value = output,
  n = 7,
  dig.lab = 2,
  legend_title = "Class",
  option = "D",
  direction = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choropleth_ggplot2_+3A_sf_object">sf_object</code></td>
<td>
<p>object of class sf</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_value">value</code></td>
<td>
<p>column to shade the polygons</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_n">n</code></td>
<td>
<p>number of clusters (default is 7)</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_dig.lab">dig.lab</code></td>
<td>
<p>number of digits in legend (default is 2)</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_legend_title">legend_title</code></td>
<td>
<p>title of legend</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_option">option</code></td>
<td>
<p>a character string indicating the colormap option to use. Four
options are available: &quot;magma&quot; (or &quot;A&quot;), &quot;inferno&quot; (or &quot;B&quot;), &quot;plasma&quot;
(or &quot;C&quot;), &quot;viridis&quot; (or &quot;D&quot;, the default option) and &quot;cividis&quot; (or &quot;E&quot;).</p>
</td></tr>
<tr><td><code id="choropleth_ggplot2_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot map
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- points_to_polygon(nl_postcode2, insurance, sum(amount, na.rm = TRUE))
choropleth_ggplot2(test)
</code></pre>

<hr>
<h2 id='concentration'>Concentration risk</h2><span id='topic+concentration'></span>

<h3>Description</h3>

<p>The sum of all observations within a circle of a certain radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentration(
  sub,
  full,
  value,
  lon_sub = lon,
  lat_sub = lat,
  lon_full = lon,
  lat_full = lat,
  radius = 200,
  display_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentration_+3A_sub">sub</code></td>
<td>
<p>data.frame of locations to calculate concentration risk for
(target points). <code>sub</code> should include at least columns for longitude
and latitude.</p>
</td></tr>
<tr><td><code id="concentration_+3A_full">full</code></td>
<td>
<p>data.frame to find the locations within radius <code>r</code> from
locations in <code>sub</code> (reference locations). <code>full</code> should include at
least columns for longitude, latitude and value of interest to summarize.</p>
</td></tr>
<tr><td><code id="concentration_+3A_value">value</code></td>
<td>
<p>column name with value of interest to summarize in <code>full</code>.</p>
</td></tr>
<tr><td><code id="concentration_+3A_lon_sub">lon_sub</code></td>
<td>
<p>column name in <code>sub</code> with longitude (lon is default).</p>
</td></tr>
<tr><td><code id="concentration_+3A_lat_sub">lat_sub</code></td>
<td>
<p>column name in <code>sub</code> with latitude (lat is default).</p>
</td></tr>
<tr><td><code id="concentration_+3A_lon_full">lon_full</code></td>
<td>
<p>column name in <code>full</code> with longitude in <code>full</code>
(lon is default).</p>
</td></tr>
<tr><td><code id="concentration_+3A_lat_full">lat_full</code></td>
<td>
<p>column name in <code>full</code> with latitude in <code>full</code>
(lat is default).</p>
</td></tr>
<tr><td><code id="concentration_+3A_radius">radius</code></td>
<td>
<p>radius (in meters) (default is 200m).</p>
</td></tr>
<tr><td><code id="concentration_+3A_display_progress">display_progress</code></td>
<td>
<p>show progress bar (TRUE/FALSE). Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame equal to data.frame <code>sub</code> including an extra column
<code>concentration</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(location = c("p1", "p2"), lon = c(6.561561, 6.561398),
 lat = c(53.21369, 53.21326))
concentration(df, Groningen, value = amount, radius = 100)

</code></pre>

<hr>
<h2 id='Groningen'>Coordinates of houses in Groningen</h2><span id='topic+Groningen'></span>

<h3>Description</h3>

<p>A dataset of postal codes and the corresponding spatial locations in terms of
a latitude and a longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Groningen
</code></pre>


<h3>Format</h3>

<p>A data frame with 25000 rows and 8 variables:
</p>

<dl>
<dt>street</dt><dd><p>Name of street</p>
</dd>
<dt>number</dt><dd><p>Number of house</p>
</dd>
<dt>letter</dt><dd><p>Letter of house</p>
</dd>
<dt>suffix</dt><dd><p>Suffix to number of house</p>
</dd>
<dt>postal_code</dt><dd><p>Postal code of house</p>
</dd>
<dt>city</dt><dd><p>The name of the city</p>
</dd>
<dt>lon</dt><dd><p>Longitude (in degrees)</p>
</dd>
<dt>lat</dt><dd><p>Latitude (in degrees)</p>
</dd>
<dt>amount</dt><dd><p>Random value</p>
</dd>
</dl>



<h3>Source</h3>

<p>The BAG is the Dutch registry for Buildings and adresses
(Basisregistratie adressen en gebouwen).
</p>

<hr>
<h2 id='haversine'>Haversine great circle distance</h2><span id='topic+haversine'></span>

<h3>Description</h3>

<p>The shortest distance between two points (i.e., the
'great-circle-distance' or 'as the crow flies'), according to the 'haversine
method'. This method assumes a spherical earth, ignoring ellipsoidal effects.
Note that this version is implemented in C++. A quick benchmark to the
version of geosphere showed it to be a non-insignificant speed enhancement.
The algorithm converges in one-twentieth of the original time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine(lat_from, lon_from, lat_to, lon_to, r = 6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haversine_+3A_lat_from">lat_from</code></td>
<td>
<p>Latitude of point.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lon_from">lon_from</code></td>
<td>
<p>Longitude of point.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lat_to">lat_to</code></td>
<td>
<p>Latitude of point.</p>
</td></tr>
<tr><td><code id="haversine_+3A_lon_to">lon_to</code></td>
<td>
<p>Longitude of point.</p>
</td></tr>
<tr><td><code id="haversine_+3A_r">r</code></td>
<td>
<p>Radius of the earth; default = 6378137m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Haversine ('half-versed-sine') formula was published by R.W.
Sinnott in 1984, although it has been known for much longer.
</p>


<h3>Value</h3>

<p>Vector of distances in the same unit as <code>r</code> (default in meters).
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Sinnott, R.W, 1984. Virtues of the Haversine. Sky and Telescope
68(2): 159.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>haversine(53.24007, 6.520386, 53.24054, 6.520386)

</code></pre>

<hr>
<h2 id='highest_concentration'>Highest concentration risk</h2><span id='topic+highest_concentration'></span>

<h3>Description</h3>

<p>Find the centre coordinates of a circle with a fixed radius that
maximizes the coverage of total fire risk insured. 'highest_concentration()'
returns the coordinates (lon/lat) and the corresponding concentration. The
concentration is defined as the sum of all observations within a circle of a
certain radius. See <code><a href="#topic+concentration">concentration</a></code> for determining concentration
for pre-defined coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highest_concentration(
  df,
  value,
  lon = lon,
  lat = lat,
  lowerbound = NULL,
  radius = 200,
  grid_distance = 25,
  gh_precision = 6,
  display_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highest_concentration_+3A_df">df</code></td>
<td>
<p>data.frame of locations, should at least include column for
longitude, latitude and sum insured</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_value">value</code></td>
<td>
<p>column name with value of interest to summarize (e.g. sum
insured)</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_lon">lon</code></td>
<td>
<p>column name with longitude (defaults to 'lon')</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_lat">lat</code></td>
<td>
<p>column name with latitude (defaults to 'lat')</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_lowerbound">lowerbound</code></td>
<td>
<p>set lower bound for outcome (defaults to NULL)</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_radius">radius</code></td>
<td>
<p>radius (in meters) (default is 200m)</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_grid_distance">grid_distance</code></td>
<td>
<p>distance (in meters) for precision of concentration risk
(default is 25m). 'neighborhood_search()' can be used to search for
coordinates with even higher concentrations in the neighborhood of the
highest concentrations.</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_gh_precision">gh_precision</code></td>
<td>
<p>positive integer to define geohash precision. See
details.</p>
</td></tr>
<tr><td><code id="highest_concentration_+3A_display_progress">display_progress</code></td>
<td>
<p>show progress bar (TRUE/FALSE). Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A recently European Commission regulation requires insurance
companies to determine the maximum value of insured fire risk policies of
all buildings that are partly or fully located within circle of a radius of
200m (Commission Delegated Regulation (EU), 2015, Article 132). The problem
can be stated as: &quot;find the centre coordinates of a circle with a fixed
radius that maximizes the coverage of total fire risk insured&quot;. This can be
viewed as a particular instance of the Maximal Covering Location Problem
(MCLP) with fixed radius. See Gomes (2018) for a solution to the maximum fire
risk insured capital problem using a multi-start local search meta-heuristic.
The computational performance of <code>highest_concentration()</code> is
investigated to overcome the long times the MCLP algorithm is taking.
<code>highest_concentration()</code> is written in C++, and for 500,000 buildings
it needs about 5-10 seconds to determine the maximum value of insured fire
risk policies that are partly or fully located within circle of a radius of
200m.
</p>
<p>&lsquo;highest_concentration()' uses Gustavo Niemeyer&rsquo;s wonderful and elegant
geohash coordinate system. Niemeyer's Geohash method encodes latitude and
longitude as binary string where each binary value derived from a decision
as to where the point lies in a bisected region of latitude or longitudinal
space. The first step is to convert all latitude/longitude coordinates into
geohash-encoded strings.
</p>
<p>The length of the geohash (&lsquo;gh_precision') controls the &rsquo;zoom level':
</p>

<ul>
<li><p> precision 5 is 4.89 x 4.89km;
</p>
</li>
<li><p> precision 6 is 1.22km x 0.61km;
</p>
</li>
<li><p> precision 7 is 153m x 153m;
</p>
</li>
<li><p> precision 8 is 39m x 19m.
</p>
</li></ul>

<p>For a circle with a radius of 200m the precision of the geohash should
be set equal to 6 (default). Then the 'value' column is aggregated (sum)
per geohash (with a buffer of size 'radius' around each geohash,
since the coordinates of the highest concentration can be near the edge of
the geohash). The geohashes with a aggregated value below the lowerbound
are removed, where the lowerbound is equal to the maximum of the
'value' column. Then a grid is created, with a distance of 'grid_distance'
between the points. See example section for a illustration of the algorithm.
As a last step for each grid point the concentration is calculated.
</p>


<h3>Value</h3>

<p>data.frame with coordinates (lon/lat) with the highest concentrations
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Commission Delegated Regulation (EU) (2015). Solvency II
Delegated Act 2015/35. Official Journal of the European Union, 58:124.
</p>
<p>Gomes M.I., Afonso L.B., Chibeles-Martins N., Fradinho J.M.
(2018). Multi-start Local Search Procedure for the Maximum Fire Risk Insured
Capital Problem. In: Lee J., Rinaldi G., Mahjoub A. (eds) Combinatorial
Optimization. ISCO 2018. Lecture Notes in Computer Science, vol 10856.
Springer, Cham. &lt;doi:10.1007/978-3-319-96151-4_19&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# Find highest concentration with a precision of a grid of 25 meters
hc1 &lt;- highest_concentration(Groningen, amount, radius = 200,
 grid_distance = 25)

# Look for coordinates with even higher concentrations in the
# neighborhood of the coordinates with the highest concentration
hc1_nghb &lt;- neighborhood_gh_search(hc1, max.call = 7000)
print(hc1_nghb)

# Create map with geohashes above the lowerbound
# The highest concentration lies in one of the geohashes
plot(hc1)

# Create map with highest concentration
plot(hc1_nghb)

## End(Not run)

</code></pre>

<hr>
<h2 id='insurance'>Sum insured per postal code in the Netherlands</h2><span id='topic+insurance'></span>

<h3>Description</h3>

<p>A dataset of postal codes with their sum insured, population
and the corresponding spatial locations in terms of a latitude and a
longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insurance
</code></pre>


<h3>Format</h3>

<p>A data frame with 29,990 rows and 5 variables:
</p>

<dl>
<dt>postcode</dt><dd><p>6-digit postal code</p>
</dd>
<dt>population_pc4</dt><dd><p>Population per 4-digit postal code</p>
</dd>
<dt>amount</dt><dd><p>Sum insured</p>
</dd>
<dt>lon</dt><dd><p>Longitude (in degrees) of the corresponding 6-digit postal code</p>
</dd>
<dt>lat</dt><dd><p>Latitude (in degrees) of the corresponding 6-digit postal code</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='interpolate_krige'>Ordinary kriging</h2><span id='topic+interpolate_krige'></span>

<h3>Description</h3>

<p>Interpolation and smoothing on the sphere by means of ordinary
kriging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_krige(
  observations,
  targets,
  value,
  lon_obs = lon,
  lat_obs = lat,
  lon_targets = lon,
  lat_targets = lat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_krige_+3A_observations">observations</code></td>
<td>
<p>data.frame of observations.</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_targets">targets</code></td>
<td>
<p>data.frame of locations to calculate the interpolated and
smoothed values for (target points).</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_value">value</code></td>
<td>
<p>Column with values in <code>observations</code>.</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_lon_obs">lon_obs</code></td>
<td>
<p>Column in <code>observations</code> with longitude (lon is default).</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_lat_obs">lat_obs</code></td>
<td>
<p>Column in <code>observations</code> with latitude (lat is default).</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_lon_targets">lon_targets</code></td>
<td>
<p>Column in <code>targets</code> with longitude (lon is default).</p>
</td></tr>
<tr><td><code id="interpolate_krige_+3A_lat_targets">lat_targets</code></td>
<td>
<p>Column in <code>targets</code> with latitude (lat is default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>observations</code> should include at least columns for longitude
and latitude.
</p>
<p><code>targets</code> should include at least columns for longitude,
latitude and value of interest to interpolate and smooth.
</p>
<p>Kriging can be considered as linear regression with spatially
correlated residuals. Kriging is most appropriate when it is known there is
a spatially correlated distance or directional bias in the data. It is often
used in soil science and geology.
</p>
<p>See <code><a href="#topic+interpolate_spline">splines on the
sphere</a></code> for interpolation and smoothing on the sphere by means of splines.
</p>


<h3>Value</h3>

<p>Object equal to object <code>targets</code> including extra columns for
the predicted value and the variance.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p><code><a href="gstat.html#topic+krige">gstat::krige</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
target &lt;- sf::st_drop_geometry(nl_postcode3)
obs &lt;- insurance %&gt;% dplyr::sample_n(1000)
pop_df &lt;- interpolate_krige(obs, target, population_pc4)
pop_sf &lt;- left_join(nl_postcode3, pop_df)
choropleth(pop_sf, value = "population_pc4_pred", n = 13)
choropleth(pop_sf, value = "population_pc4_var", n = 13)

## End(Not run)

</code></pre>

<hr>
<h2 id='interpolate_spline'>Splines on the sphere</h2><span id='topic+interpolate_spline'></span>

<h3>Description</h3>

<p>Spline interpolation and smoothing on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_spline(
  observations,
  targets,
  value,
  lon_obs = lon,
  lat_obs = lat,
  lon_targets = lon,
  lat_targets = lat,
  k = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_spline_+3A_observations">observations</code></td>
<td>
<p>data.frame of observations.</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_targets">targets</code></td>
<td>
<p>data.frame of locations to calculate the interpolated and
smoothed values for (target points).</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_value">value</code></td>
<td>
<p>Column with values in <code>observations</code>.</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_lon_obs">lon_obs</code></td>
<td>
<p>Column in <code>observations</code> with longitude (lon is default).</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_lat_obs">lat_obs</code></td>
<td>
<p>Column in <code>observations</code> with latitude (lat is default).</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_lon_targets">lon_targets</code></td>
<td>
<p>Column in <code>targets</code> with longitude (lon is default).</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_lat_targets">lat_targets</code></td>
<td>
<p>Column in <code>targets</code> with latitude (lat is default).</p>
</td></tr>
<tr><td><code id="interpolate_spline_+3A_k">k</code></td>
<td>
<p>(default 50) is the basis dimension. For small data sets reduce
<code>k</code> manually rather than using default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>observations</code> should include at least columns for longitude
and latitude.
</p>
<p><code>targets</code> should include at least columns for longitude,
latitude and value of interest to interpolate and smooth.
</p>
<p>A smooth of the general type discussed in Duchon (1977) is used:
the sphere is embedded in a 3D Euclidean space, but smoothing employs a
penalty based on second derivatives (so that locally as the smoothing
parameter tends to zero we recover a &quot;normal&quot; thin plate spline on the
tangent space). This is an unpublished suggestion of Jean Duchon.
</p>
<p>See <code><a href="#topic+interpolate_krige">ordinary kriging</a></code>
for interpolation and smoothing on the sphere by means of kriging.
</p>


<h3>Value</h3>

<p>Object equal to object <code>targets</code> including an extra column
with predicted values.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p><code><a href="mgcv.html#topic+smooth.construct.sos.smooth.spec">Splines on
the sphere</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
target &lt;- sf::st_drop_geometry(nl_postcode3)
obs &lt;- dplyr::sample_n(insurance, 1000)
pop_df &lt;- interpolate_spline(obs, target, population_pc4, k = 20)
pop_sf &lt;- left_join(nl_postcode3, pop_df)
choropleth(pop_sf, value = "population_pc4_pred", n = 13)

## End(Not run)

</code></pre>

<hr>
<h2 id='knmi_historic_data'>Retrieve historic weather data for the Netherlands</h2><span id='topic+knmi_historic_data'></span>

<h3>Description</h3>

<p>This function retrieves historic weather data collected by the official KNMI
weather stations. See spatialrisk::knmi_stations for a list of the official
KNMI weather stations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knmi_historic_data(startyear, endyear)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knmi_historic_data_+3A_startyear">startyear</code></td>
<td>
<p>start year for historic weather data.</p>
</td></tr>
<tr><td><code id="knmi_historic_data_+3A_endyear">endyear</code></td>
<td>
<p>end year for historic weather data.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>The returned data frame contains the following columns:
</p>

<ul>
<li><p> station = ID of measurement station;
</p>
</li>
<li><p> date = Date;
</p>
</li>
<li><p> FH	= Hourly mean wind speed (in 0.1 m/s);
</p>
</li>
<li><p> FX	= Maximum wind gust (in 0.1 m/s) during the hourly division;
</p>
</li>
<li><p> DR	= Precipitation duration (in 0.1 hour) during the hourly division;
</p>
</li>
<li><p> RH	= Hourly precipitation amount (in 0.1 mm) (-1 for &lt;0.05 mm);
</p>
</li>
<li><p> city = City where the measurement station is located;
</p>
</li>
<li><p> lon = Longitude of station (crs = 4326);
</p>
</li>
<li><p> lat = Latitude of station (crs = 4326).
</p>
</li></ul>



<h3>Value</h3>

<p>Data frame containing weather data and meta data for weather station
locations.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
knmi_historic_data(2015, 2019)

## End(Not run)

</code></pre>

<hr>
<h2 id='knmi_stations'>KNMI stations</h2><span id='topic+knmi_stations'></span>

<h3>Description</h3>

<p>A data frame containing the IDs and meta-data on the official
KNMI weather stations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knmi_stations
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 7 variables:
</p>

<dl>
<dt>station</dt><dd><p>ID of the station (209-391)</p>
</dd>
<dt>city</dt><dd><p>City where the station is located</p>
</dd>
<dt>lon</dt><dd><p>Longitude of station (crs = 4326)</p>
</dd>
<dt>lat</dt><dd><p>Latitude of the station (crs = 4326)</p>
</dd>
<dt>altitude</dt><dd><p>Altitude of the station (in meters)</p>
</dd>
<dt>X</dt><dd><p>X coordinate of the station (crs = 32631)</p>
</dd>
<dt>Y</dt><dd><p>Y coordinate of the station (crs = 32631)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='lower_bound_fn'>Determine a lower bound for highest concentration
Calculate concentration for the coordinates of the highest insured sums</h2><span id='topic+lower_bound_fn'></span>

<h3>Description</h3>

<p>Determine a lower bound for highest concentration
Calculate concentration for the coordinates of the highest insured sums
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower_bound_fn(df, col, lat_nm, lon_nm, radius, highest = 50)
</code></pre>

<hr>
<h2 id='neighborhood_gh_search'>Search for coordinates with higher concentrations within geohash</h2><span id='topic+neighborhood_gh_search'></span>

<h3>Description</h3>

<p><code><a href="#topic+highest_concentration">highest_concentration</a></code> returns the highest concentration within
a portfolio based on grid points. However, higher concentrations can be
found within two grid points. 'neighborhood_gh_search()' looks for even
higher concentrations in the neighborhood of the grid points with the highest
concentrations. This optimization is done by means of Simulated Annealing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood_gh_search(
  hc,
  highest_geohash = 1,
  max.call = 1000,
  verbose = TRUE,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhood_gh_search_+3A_hc">hc</code></td>
<td>
<p>object of class 'concentration' obtained from
'highest_concentration()'</p>
</td></tr>
<tr><td><code id="neighborhood_gh_search_+3A_highest_geohash">highest_geohash</code></td>
<td>
<p>the number of geohashes the searching algorithm is
applied to. Defaults to 1 (i.e. algorithm is only applied to the geohash
with the highest concentration).</p>
</td></tr>
<tr><td><code id="neighborhood_gh_search_+3A_max.call">max.call</code></td>
<td>
<p>maximum number of calls to the concentration function (i.e.
the number of coordinates in the neighborhood of the highest concentration).
Defaults to 1000.</p>
</td></tr>
<tr><td><code id="neighborhood_gh_search_+3A_verbose">verbose</code></td>
<td>
<p>show messages from the algorithm (TRUE/FALSE). Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="neighborhood_gh_search_+3A_seed">seed</code></td>
<td>
<p>set seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Find highest concentration with a precision of a grid of 25 meters
hc1 &lt;- highest_concentration(Groningen, amount, radius = 200,
 grid_distance = 25)

# Increase the number of calls for more extensive search
hc1_nghb &lt;- neighborhood_gh_search(hc1, max.call = 7000, highest_geohash = 1)
hc2_nghb &lt;- neighborhood_gh_search(hc1, max.call = 7000, highest_geohash = 2)
plot(hc1_nghb)
plot(hc2_nghb)

## End(Not run)

</code></pre>

<hr>
<h2 id='nl_corop'>Object of class <code>sf</code> for COROP regions in the Netherlands</h2><span id='topic+nl_corop'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for COROP regions
in the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_corop
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 40 rows and 5 variables:
</p>

<dl>
<dt>corop_nr</dt><dd><p>corop number</p>
</dd>
<dt>areaname</dt><dd><p>corop name</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of COROP region</p>
</dd>
<dt>lon</dt><dd><p>longitude of the corop centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the corop centroid</p>
</dd>
</dl>



<h3>Details</h3>

<p>A COROP region is a regional area within the Netherlands. These
regions are used for analytical purposes by, among others, Statistics
Netherlands. The Dutch abbreviation stands for Coordinatiecommissie Regionaal
Onderzoeksprogramma, literally the Coordination Commission Regional Research
Programme.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='nl_gemeente'>Object of class <code>sf</code> for municipalities in the Netherlands</h2><span id='topic+nl_gemeente'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for municipalities
(Dutch: gemeentes) in the Netherlands in the year 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_gemeente
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 380 rows and 6 variables:
</p>

<dl>
<dt>id</dt><dd><p>id of gemeente</p>
</dd>
<dt>code</dt><dd><p>code of gemeente</p>
</dd>
<dt>areaname</dt><dd><p>name of gemeente</p>
</dd>
<dt>lon</dt><dd><p>longitude of the gemeente centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the gemeente centroid</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of gemeente</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='nl_postcode2'>Object of class <code>sf</code> for 2-digit postcode regions in the Netherlands</h2><span id='topic+nl_postcode2'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for 2-digit postal
codes (Dutch: postcode) regions in the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_postcode2
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 90 rows and 4 variables:
</p>

<dl>
<dt>areaname</dt><dd><p>2-digit postal code</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of postal code</p>
</dd>
<dt>lon</dt><dd><p>longitude of the 2-digit postal code centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the 2-digit postal code centroid</p>
</dd>
</dl>



<h3>Details</h3>

<p>Postal codes in the Netherlands, known as postcodes, are
alphanumeric, consisting of four digits followed by two uppercase letters.
The first two digits indicate a city and a region, the second two digits and
the two letters indicate a range of house numbers, usually on the same
street.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='nl_postcode3'>Object of class <code>sf</code> for 3-digit postcode regions in the Netherlands</h2><span id='topic+nl_postcode3'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for 3-digit postal
codes (Dutch: postcode) regions in the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_postcode3
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 799 rows and 3 variables:
</p>

<dl>
<dt>areaname</dt><dd><p>3-digit postal code</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of postal code</p>
</dd>
<dt>lon</dt><dd><p>longitude of the 3-digit postal code centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the 3-digit postal code centroid</p>
</dd>
</dl>



<h3>Details</h3>

<p>Postal codes in the Netherlands, known as postcodes, are
alphanumeric, consisting of four digits followed by two uppercase letters.
The first two digits indicate a city and a region, the second two digits and
the two letters indicate a range of house numbers, usually on the same
street.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='nl_postcode4'>Object of class <code>sf</code> for 4-digit postcode regions in the Netherlands</h2><span id='topic+nl_postcode4'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for 4-digit postal
codes (Dutch: postcode) regions in the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_postcode4
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 4053 rows and 7 variables:
</p>

<dl>
<dt>pc4</dt><dd><p>4-digit postal code</p>
</dd>
<dt>areaname</dt><dd><p>name of corresponding 4-digit postal code</p>
</dd>
<dt>city</dt><dd><p>name of city</p>
</dd>
<dt>biggest_20cities</dt><dd><p>pc4 is in one of the following twenty (biggest)
cities in the Netherlands: Amsterdam, Rotterdam, 's-Gravenhage, Utrecht,
Eindhoven, Tilburg, Groningen, Almere, Breda, Nijmegen, Enschede,
Apeldoorn, Haarlem, Amersfoort, Arnhem, 's-Hertogenbosch, Zoetermeer,
Zwolle, Maastricht, Leiden.</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of postal code</p>
</dd>
<dt>lon</dt><dd><p>longitude of the 4-digit postal code centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the 4-digit postal code centroid</p>
</dd>
</dl>



<h3>Details</h3>

<p>Postal codes in the Netherlands, known as postcodes, are
alphanumeric, consisting of four digits followed by two uppercase letters.
The first two digits indicate a city and a region, the second two digits and
the two letters indicate a range of house numbers, usually on the same
street.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='nl_provincie'>Object of class <code>sf</code> for provinces in the Netherlands</h2><span id='topic+nl_provincie'></span>

<h3>Description</h3>

<p>An object of class <code>sf</code> (simple feature) for provinces
(Dutch: provincies) in the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl_provincie
</code></pre>


<h3>Format</h3>

<p>A simple feature object with 12 rows and 4 variables:
</p>

<dl>
<dt>areaname</dt><dd><p>province name</p>
</dd>
<dt>geometry</dt><dd><p>geometry object of province</p>
</dd>
<dt>lon</dt><dd><p>longitude of the province centroid</p>
</dd>
<dt>lat</dt><dd><p>latitude of the province centroid</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='plot_points'>Create map with points</h2><span id='topic+plot_points'></span>

<h3>Description</h3>

<p>Create map for data.frame with points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_points(
  df,
  value,
  lon = lon,
  lat = lat,
  palette = "viridis",
  legend_position = "bottomleft",
  crs = 4326,
  providers = c("CartoDB.Positron", "nlmaps.luchtfoto")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_points_+3A_df">df</code></td>
<td>
<p>data.framw with column for lon and lat</p>
</td></tr>
<tr><td><code id="plot_points_+3A_value">value</code></td>
<td>
<p>column in df</p>
</td></tr>
<tr><td><code id="plot_points_+3A_lon">lon</code></td>
<td>
<p>column with lon</p>
</td></tr>
<tr><td><code id="plot_points_+3A_lat">lat</code></td>
<td>
<p>column with lat</p>
</td></tr>
<tr><td><code id="plot_points_+3A_palette">palette</code></td>
<td>
<p>color palette</p>
</td></tr>
<tr><td><code id="plot_points_+3A_legend_position">legend_position</code></td>
<td>
<p>position for legend (default is &quot;bottomleft&quot;)</p>
</td></tr>
<tr><td><code id="plot_points_+3A_crs">crs</code></td>
<td>
<p>crs (default is 4326)</p>
</td></tr>
<tr><td><code id="plot_points_+3A_providers">providers</code></td>
<td>
<p>providers to show. See 'leaflet::providers' for a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>leaflet map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot_points(Groningen, value = amount)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.concentration'>Automatically create a plot for objects obtained from highest_concentration()</h2><span id='topic+plot.concentration'></span>

<h3>Description</h3>

<p>Takes an object produced by 'highest_concentration()',
and creates an interactive map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'concentration'
plot(
  x,
  grid_points = TRUE,
  legend_title = NULL,
  palette = "viridis",
  legend_position = "bottomleft",
  providers = c("CartoDB.Positron", "nlmaps.luchtfoto"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.concentration_+3A_x">x</code></td>
<td>
<p>object of class 'concentration' obtained from
'highest_concentration()'</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_grid_points">grid_points</code></td>
<td>
<p>show grid points (TRUE), or objects (FALSE)</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_legend_title">legend_title</code></td>
<td>
<p>title of legend</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_palette">palette</code></td>
<td>
<p>palette for grid points (defaults to &quot;viridis&quot;)</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_legend_position">legend_position</code></td>
<td>
<p>legend position for grid points legend (defaults to
&quot;bottomleft&quot;)</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_providers">providers</code></td>
<td>
<p>providers to show. See 'leaflet::providers' for a list.</p>
</td></tr>
<tr><td><code id="plot.concentration_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the interactive map produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Interactive view of geohashes with highest concentrations
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='plot.neighborhood'>Automatically create a plot for objects obtained from
neighborhood_gh_search()</h2><span id='topic+plot.neighborhood'></span>

<h3>Description</h3>

<p>Takes an object produced by 'neighborhood_gh_search()', and
creates an interactive map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neighborhood'
plot(
  x,
  buffer = 0,
  legend_title = NULL,
  palette = "viridis",
  legend_position = "bottomleft",
  palette_circle = "YlOrRd",
  legend_position_circle = "bottomright",
  legend_title_circle = "Highest concentration",
  providers = c("CartoDB.Positron", "nlmaps.luchtfoto"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.neighborhood_+3A_x">x</code></td>
<td>
<p>object neighborhood object produced by 'neighborhood_gh_search()'</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_buffer">buffer</code></td>
<td>
<p>numeric value, show objects within buffer (in meters) from
circle (defaults to 0)</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_legend_title">legend_title</code></td>
<td>
<p>title of legend</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_palette">palette</code></td>
<td>
<p>palette for points (defaults to &quot;viridis&quot;)</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_legend_position">legend_position</code></td>
<td>
<p>legend position for points legend (defaults to
&quot;bottomleft&quot;)</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_palette_circle">palette_circle</code></td>
<td>
<p>palette for circles (default to &quot;YlOrRd&quot;)</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_legend_position_circle">legend_position_circle</code></td>
<td>
<p>legend position for circles legend (defaults
to &quot;bottomright&quot;)</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_legend_title_circle">legend_title_circle</code></td>
<td>
<p>title of legend for circles</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_providers">providers</code></td>
<td>
<p>providers to show. See 'leaflet::providers' for a list.</p>
</td></tr>
<tr><td><code id="plot.neighborhood_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the interactive map produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Interactive view of highest concentration on map
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='points_in_circle'>Points in circle</h2><span id='topic+points_in_circle'></span>

<h3>Description</h3>

<p>Find all observations in a data.frame within a circle of a
certain radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_in_circle(
  data,
  lon_center,
  lat_center,
  lon = lon,
  lat = lat,
  radius = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_in_circle_+3A_data">data</code></td>
<td>
<p>data.frame with at least columns for longitude and latitude.</p>
</td></tr>
<tr><td><code id="points_in_circle_+3A_lon_center">lon_center</code></td>
<td>
<p>numeric value referencing to the longitude of the center
of the circle</p>
</td></tr>
<tr><td><code id="points_in_circle_+3A_lat_center">lat_center</code></td>
<td>
<p>numeric value referencing to the latitude of the center of
the circle</p>
</td></tr>
<tr><td><code id="points_in_circle_+3A_lon">lon</code></td>
<td>
<p>column name in <code>data</code> with longitudes (<code>lon</code> is
default).</p>
</td></tr>
<tr><td><code id="points_in_circle_+3A_lat">lat</code></td>
<td>
<p>column name in <code>data</code> with latitudes (<code>lat</code> is default).</p>
</td></tr>
<tr><td><code id="points_in_circle_+3A_radius">radius</code></td>
<td>
<p>radius (in meters) (defaults to 200m).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame. Column <code>distance_m</code> gives the distance to the center
of the circle (in meters).
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_in_circle(Groningen, lon_center = 6.571561, lat_center = 53.21326,
radius = 60)

</code></pre>

<hr>
<h2 id='points_to_polygon'>Aggregate attributes of coordinates to area level</h2><span id='topic+points_to_polygon'></span>

<h3>Description</h3>

<p>A data.frame containing coordinates (in terms of longitude and
latitude) is joined to the polygon level. Then arithmetic operations on the
attributes of the coordinates are applied to obtain aggregated values for
each polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_to_polygon(sf_map, df, oper, crs = 4326, outside_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_to_polygon_+3A_sf_map">sf_map</code></td>
<td>
<p>object of class sf</p>
</td></tr>
<tr><td><code id="points_to_polygon_+3A_df">df</code></td>
<td>
<p>data.frame containing coordinates (column names should be 'lon'
and 'lat')</p>
</td></tr>
<tr><td><code id="points_to_polygon_+3A_oper">oper</code></td>
<td>
<p>an arithmetic operation on the polygon level</p>
</td></tr>
<tr><td><code id="points_to_polygon_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or
character with proj4string</p>
</td></tr>
<tr><td><code id="points_to_polygon_+3A_outside_print">outside_print</code></td>
<td>
<p>print points that are not within a polygon (default is
FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>sf</code>
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_to_polygon(nl_postcode2, insurance, sum(amount, na.rm = TRUE))
## Not run: 
shp_read &lt;- sf::st_read("~/path/to/file.shp")
points_to_polygon(shp_read, insurance, sum(amount, na.rm = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
