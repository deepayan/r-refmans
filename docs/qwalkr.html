<!DOCTYPE html><html><head><title>Help for package qwalkr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qwalkr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#act_eigfun'><p>Apply a Function to an Operator</p></a></li>
<li><a href='#act_eigfun.spectral'><p>Apply a Function to a Hermitian Matrix</p></a></li>
<li><a href='#avg_matrix'><p>The Average Mixing Matrix of a Quantum Walk</p></a></li>
<li><a href='#avg_matrix.ctqwalk'><p>The Average Mixing Matrix of a Continuous-Time Quantum Walk</p></a></li>
<li><a href='#cartesian'><p>Adjacency Matrix of the Cartesian Product</p></a></li>
<li><a href='#ctqwalk'><p>Create a Continuous-time Quantum Walk</p></a></li>
<li><a href='#gavg_matrix'><p>The Generalized Average Mixing Matrix of a Quantum Walk</p></a></li>
<li><a href='#gavg_matrix.ctqwalk'><p>The Generalized Average Mixing Matrix of a Continuous-Time Quantum Walk</p></a></li>
<li><a href='#get_eigproj'><p>Extract an Eigen-Projector from an operator</p></a></li>
<li><a href='#get_eigproj.spectral'><p>Extract an Eigen-Projector from a Hermitian Matrix</p></a></li>
<li><a href='#get_eigschur'><p>Extract a Schur Cross-Product from an Operator</p></a></li>
<li><a href='#get_eigschur.spectral'><p>Extract a Schur Cross-Product from a Hermitian Matrix</p></a></li>
<li><a href='#get_eigspace'><p>Extract an Eigenspace from an Operator</p></a></li>
<li><a href='#get_eigspace.spectral'><p>Extract an Eigenspace from a Hermitian Matrix</p></a></li>
<li><a href='#J'><p>The All-Ones Matrix</p></a></li>
<li><a href='#mixing_matrix'><p>The Mixing Matrix of a Quantum Walk</p></a></li>
<li><a href='#mixing_matrix.ctqwalk'><p>The Mixing Matrix of a Continuous-Time Quantum Walk</p></a></li>
<li><a href='#print.ctqwalk'><p>Print the ctqwalk output</p></a></li>
<li><a href='#qwalkr-package'><p>qwalkr: Handle Continuous-Time Quantum Walks with R</p></a></li>
<li><a href='#spectral'><p>Spectral Decomposition of a Hermitian Matrix</p></a></li>
<li><a href='#tr'><p>The Trace of a Matrix</p></a></li>
<li><a href='#trdot'><p>The Trace Inner Product of Matrices</p></a></li>
<li><a href='#unitary_matrix'><p>The Unitary Time Evolution Operator of a Quantum Walk</p></a></li>
<li><a href='#unitary_matrix.ctqwalk'><p>The Unitary Time Evolution Operator of a Continuous-Time Quantum Walk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Handle Continuous-Time Quantum Walks with R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and tools for creating, visualizing, and investigating properties of continuous-time quantum walks, including efficient calculation of matrices such as the mixing matrix, average mixing matrix, and spectral decomposition of the Hamiltonian. E. Farhi (1997): &lt;<a href="https://arxiv.org/abs/quant-ph/9706062v2">arXiv:quant-ph/9706062v2</a>&gt;; C. Godsil (2011) &lt;<a href="https://arxiv.org/abs/1103.2578v3">arXiv:1103.2578v3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vitormarquesr/qwalkr">https://github.com/vitormarquesr/qwalkr</a>,
<a href="https://vitormarquesr.github.io/qwalkr/">https://vitormarquesr.github.io/qwalkr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vitormarquesr/qwalkr/issues">https://github.com/vitormarquesr/qwalkr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 19:31:20 UTC; Vmrod</td>
</tr>
<tr>
<td>Author:</td>
<td>Vitor Marques [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vitor Marques &lt;vmrodriguespro@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='act_eigfun'>Apply a Function to an Operator</h2><span id='topic+act_eigfun'></span>

<h3>Description</h3>

<p>Apply a Function to an Operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>act_eigfun(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="act_eigfun_+3A_object">object</code></td>
<td>
<p>a representation of the operator.</p>
</td></tr>
<tr><td><code id="act_eigfun_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting operator from the application of the function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+act_eigfun.spectral">act_eigfun.spectral()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- spectral(rbind(c(0.5, 0.3), c(0.3,0.7)))

act_eigfun(s, function(x) x^2) #-&gt; act_eigfun.spectral(...)

</code></pre>

<hr>
<h2 id='act_eigfun.spectral'>Apply a Function to a Hermitian Matrix</h2><span id='topic+act_eigfun.spectral'></span>

<h3>Description</h3>

<p>Apply a function to a Hermitian matrix based on the representation
given by class <code>spectral</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
act_eigfun(object, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="act_eigfun.spectral_+3A_object">object</code></td>
<td>
<p>an instance of class <code>spectral</code>.</p>
</td></tr>
<tr><td><code id="act_eigfun.spectral_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to the matrix.</p>
</td></tr>
<tr><td><code id="act_eigfun.spectral_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix resulting from the application of <code>FUN</code>.
</p>
<p>A Hermitian Matrix admits the spectral decomposition
</p>
<p style="text-align: center;"><code class="reqn">H = \sum_k \lambda_k E_k</code>
</p>

<p>where <code class="reqn">\lambda_k</code> are its eigenvalues and <code class="reqn">E_k</code> the
orthogonal projector onto the <code class="reqn">\lambda_k</code>-eigenspace.
</p>
<p>If <code class="reqn">f</code>=<code>FUN</code> is defined on the eigenvalues of <code>H</code>, then
<code>act_eigfun</code> performs the following calculation
</p>
<p style="text-align: center;"><code class="reqn">f(H) = \sum_k f(\lambda_k) E_k</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+spectral">spectral()</a></code>, <code><a href="#topic+act_eigfun">act_eigfun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- matrix(c(0,1,1,1,0,1,1,1,0), nrow=3)
decomp &lt;- spectral(H)

# Calculates H^2.
act_eigfun(decomp, FUN = function(x) x^2)

# Calculates sin(H).
act_eigfun(decomp, FUN = function(x) sin(x))

# Calculates H^3.
act_eigfun(decomp, FUN = function(x, y) x^y, 3)

</code></pre>

<hr>
<h2 id='avg_matrix'>The Average Mixing Matrix of a Quantum Walk</h2><span id='topic+avg_matrix'></span>

<h3>Description</h3>

<p>The Average Mixing Matrix of a Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_matrix_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="avg_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average mixing matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixing_matrix">mixing_matrix()</a></code>, <code><a href="#topic+gavg_matrix">gavg_matrix()</a></code>, <code><a href="#topic+avg_matrix.ctqwalk">avg_matrix.ctqwalk()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

avg_matrix(w) #-&gt; avg_matrix.ctqwalk(...)

</code></pre>

<hr>
<h2 id='avg_matrix.ctqwalk'>The Average Mixing Matrix of a Continuous-Time Quantum Walk</h2><span id='topic+avg_matrix.ctqwalk'></span>

<h3>Description</h3>

<p>The Average Mixing Matrix of a Continuous-Time Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqwalk'
avg_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_matrix.ctqwalk_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="avg_matrix.ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">M(t)</code> be the mixing matrix of the quantum walk, then the average mixing matrix is defined as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{M} := \lim_{T \to \infty} \frac{1}{T}\int_{0}^T M(t)\textrm{d}t</code>
</p>

<p>and encodes the long-term average behavior of the walk. Given the Hamiltonian
<code class="reqn">H = \sum_r \lambda_r E_r</code>, it is possible to prove that
</p>
<p style="text-align: center;"><code class="reqn">\widehat{M} = \sum_r E_r \circ E_r</code>
</p>



<h3>Value</h3>

<p><code>avg_matrix()</code> returns the average mixing matrix
as a square matrix of the same order as the walk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqwalk">ctqwalk()</a></code>, <code><a href="#topic+avg_matrix">avg_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>walk &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

# Return the average mixing matrix
avg_matrix(walk)
</code></pre>

<hr>
<h2 id='cartesian'>Adjacency Matrix of the Cartesian Product</h2><span id='topic+cartesian'></span>

<h3>Description</h3>

<p>Returns the adjacency matrix of the cartesian product of two graphs
given the adjacency matrix of each one, <code class="reqn">G</code> and <code class="reqn">H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesian(G, H = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cartesian_+3A_g">G</code></td>
<td>
<p>adjacency matrix of the first graph.</p>
</td></tr>
<tr><td><code id="cartesian_+3A_h">H</code></td>
<td>
<p>adjacency matrix of the second graph. If not provided,
it takes the same value as <code>G</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Let <code class="reqn">A(G),\ A(H)</code> be the adjacency matrices of
the graphs <code class="reqn">G,\ H</code> such that <code class="reqn">|V(G)| = n</code> and <code class="reqn">|V(H)| = m</code>,
then the adjacency matrix of the cartesian product <code class="reqn">G \times H</code> is
given by
</p>
<p style="text-align: center;"><code class="reqn">A(G \times H) = A(G) \otimes I_{m\ x\ m} + I_{n\ x\ n} \otimes A(H)</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+J">J()</a></code>, <code><a href="#topic+tr">tr()</a></code>, <code><a href="#topic+trdot">trdot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P3 &lt;- matrix(c(0,1,0,1,0,1,0,1,0), nrow=3)
K3 &lt;- matrix(c(0,1,1,1,0,1,1,1,0), nrow=3)

# Return the adjacency matrix of P3 X K3
cartesian(P3, K3)

# Return the adjacency matrix of P3 X P3
cartesian(P3)
</code></pre>

<hr>
<h2 id='ctqwalk'>Create a Continuous-time Quantum Walk</h2><span id='topic+ctqwalk'></span>

<h3>Description</h3>

<p><code>ctqwalk()</code> creates a quantum walk object from a hamiltonian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctqwalk(hamiltonian, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctqwalk_+3A_hamiltonian">hamiltonian</code></td>
<td>
<p>a Hermitian Matrix representing the Hamiltonian of the system.</p>
</td></tr>
<tr><td><code id="ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+spectral">spectral()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the walk related objects, i.e the hamiltonian and its spectral
decomposition (See <code><a href="#topic+spectral">spectral()</a></code> for further details)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral">spectral()</a></code>, <code><a href="#topic+unitary_matrix.ctqwalk">unitary_matrix.ctqwalk()</a></code>,
<code><a href="#topic+mixing_matrix.ctqwalk">mixing_matrix.ctqwalk()</a></code>, <code><a href="#topic+avg_matrix.ctqwalk">avg_matrix.ctqwalk()</a></code>,
<code><a href="#topic+gavg_matrix.ctqwalk">gavg_matrix.ctqwalk()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a walk from the adjacency matrix of the graph P3.
ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))


</code></pre>

<hr>
<h2 id='gavg_matrix'>The Generalized Average Mixing Matrix of a Quantum Walk</h2><span id='topic+gavg_matrix'></span>

<h3>Description</h3>

<p>The Generalized Average Mixing Matrix of a Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gavg_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gavg_matrix_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="gavg_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generalized average mixing matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixing_matrix">mixing_matrix()</a></code>, <code><a href="#topic+avg_matrix">avg_matrix()</a></code>, <code><a href="#topic+gavg_matrix.ctqwalk">gavg_matrix.ctqwalk()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

gavg_matrix(w, rnorm(100)) #-&gt; gavg_matrix.ctqwalk(...)

</code></pre>

<hr>
<h2 id='gavg_matrix.ctqwalk'>The Generalized Average Mixing Matrix of a Continuous-Time Quantum Walk</h2><span id='topic+gavg_matrix.ctqwalk'></span>

<h3>Description</h3>

<p>The Generalized Average Mixing Matrix of a Continuous-Time Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqwalk'
gavg_matrix(object, R, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gavg_matrix.ctqwalk_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="gavg_matrix.ctqwalk_+3A_r">R</code></td>
<td>
<p>samples from the random variable <code class="reqn">R</code> (For performance, it is recommended at most 10000 samples).</p>
</td></tr>
<tr><td><code id="gavg_matrix.ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">M(t)</code> be the mixing matrix of the quantum walk and <code class="reqn">R</code> a random variable
with associated probability density function <code class="reqn">f_R(t)</code>. Then the generalized average mixing
matrix under <code class="reqn">R</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{M}_R := \mathbb{E}[M(R)] = \int_{-\infty}^{\infty} M(t)f_R(t)\textrm{d}t</code>
</p>



<h3>Value</h3>

<p><code>gavg_matrix()</code> returns the generalized average mixing matrix
as a square matrix of the same order as the walk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqwalk">ctqwalk()</a></code>, <code><a href="#topic+gavg_matrix">gavg_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>walk &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

# Return the average mixing matrix under a Standard Gaussian distribution
gavg_matrix(walk, rnorm(1000))
</code></pre>

<hr>
<h2 id='get_eigproj'>Extract an Eigen-Projector from an operator</h2><span id='topic+get_eigproj'></span>

<h3>Description</h3>

<p>Extract an Eigen-Projector from an operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigproj(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigproj_+3A_object">object</code></td>
<td>
<p>a representation of the operator.</p>
</td></tr>
<tr><td><code id="get_eigproj_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A representation of the requested eigen-projector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_eigspace">get_eigspace()</a></code>, <code><a href="#topic+get_eigschur">get_eigschur()</a></code>,
<code><a href="#topic+get_eigproj.spectral">get_eigproj.spectral()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- spectral(rbind(c(0.5, 0.3), c(0.3,0.7)))

get_eigproj(s, 1) #-&gt; get_eigproj.spectral(...)

</code></pre>

<hr>
<h2 id='get_eigproj.spectral'>Extract an Eigen-Projector from a Hermitian Matrix</h2><span id='topic+get_eigproj.spectral'></span>

<h3>Description</h3>

<p>Get the orthogonal projector associated with an eigenspace based on the representation
of a Hermitian Matrix given by class <code>spectral</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
get_eigproj(object, id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigproj.spectral_+3A_object">object</code></td>
<td>
<p>an instance of class <code>spectral</code>.</p>
</td></tr>
<tr><td><code id="get_eigproj.spectral_+3A_id">id</code></td>
<td>
<p>index for the desired eigenspace according to the ordered (decreasing) spectra.</p>
</td></tr>
<tr><td><code id="get_eigproj.spectral_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The orthogonal projector of the desired eigenspace.
</p>
<p>A Hermitian matrix <code>S</code> admits the spectral decomposition <code class="reqn">S = \sum_{r}\lambda_r E_r</code>
such that <code class="reqn">E_r</code> is the orthogonal projector onto the <code class="reqn">\lambda_r</code>-eigenspace. If <code class="reqn">V_{id}</code>
is the matrix associated to the eigenspace, then
</p>
<p style="text-align: center;"><code class="reqn">E_{id} = V_{id}V_{id}^*</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+spectral">spectral()</a></code>, <code><a href="#topic+get_eigproj">get_eigproj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Spectra is {2, -1} with multiplicities one and two respectively.
decomp &lt;- spectral(matrix(c(0,1,1,1,0,1,1,1,0), nrow=3))

# Returns the projector associated to the eigenvalue -1.
get_eigproj(decomp, id=2)

# Returns the projector associated to the eigenvalue 2.
get_eigproj(decomp, id=1)

</code></pre>

<hr>
<h2 id='get_eigschur'>Extract a Schur Cross-Product from an Operator</h2><span id='topic+get_eigschur'></span>

<h3>Description</h3>

<p>Extract a Schur Cross-Product from an Operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigschur(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigschur_+3A_object">object</code></td>
<td>
<p>a representation of the operator.</p>
</td></tr>
<tr><td><code id="get_eigschur_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A representation of the requested Schur cross-product.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_eigspace">get_eigspace()</a></code>, <code><a href="#topic+get_eigproj">get_eigproj()</a></code>,
<code><a href="#topic+get_eigschur.spectral">get_eigschur.spectral()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- spectral(rbind(c(0.5, 0.3), c(0.3,0.7)))

get_eigschur(s, 1, 2) #-&gt; get_eigschur.spectral(...)

</code></pre>

<hr>
<h2 id='get_eigschur.spectral'>Extract a Schur Cross-Product from a Hermitian Matrix</h2><span id='topic+get_eigschur.spectral'></span>

<h3>Description</h3>

<p>Get the Schur product between eigen-projectors based  on the representation of a
Hermitian Matrix given by class <code>spectral</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
get_eigschur(object, id1, id2 = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigschur.spectral_+3A_object">object</code></td>
<td>
<p>an instance of class <code>spectral</code>.</p>
</td></tr>
<tr><td><code id="get_eigschur.spectral_+3A_id1">id1</code></td>
<td>
<p>index for the first eigenspace according to the ordered (decreasing) spectra.</p>
</td></tr>
<tr><td><code id="get_eigschur.spectral_+3A_id2">id2</code></td>
<td>
<p>index for the second eigenspace according to the ordered (decreasing) spectra. If not provided,
it takes the same value as <code>id1</code>.</p>
</td></tr>
<tr><td><code id="get_eigschur.spectral_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Schur product of the corresponding eigenprojectors, <code class="reqn">E_{id_1} \circ E_{id_2}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral">spectral()</a></code>, <code><a href="#topic+get_eigschur">get_eigschur()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Spectra is {2, -1} with multiplicities one and two respectively.
decomp &lt;- spectral(matrix(c(0,1,1,1,0,1,1,1,0), nrow=3))

# Returns the Schur product between the 2-projector and -1-projector.
get_eigschur(decomp, id1=2, id2=1)

# Returns the Schur square of the 2-projector.
get_eigschur(decomp, id1=1, id2=1)

# Also returns the Schur square of the 2-projector
get_eigschur(decomp, id1=1)

</code></pre>

<hr>
<h2 id='get_eigspace'>Extract an Eigenspace from an Operator</h2><span id='topic+get_eigspace'></span>

<h3>Description</h3>

<p>Extract an Eigenspace from an Operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigspace(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigspace_+3A_object">object</code></td>
<td>
<p>a representation of the operator.</p>
</td></tr>
<tr><td><code id="get_eigspace_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A representation of the requested eigenspace.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_eigproj">get_eigproj()</a></code>, <code><a href="#topic+get_eigschur">get_eigschur()</a></code>,
<code><a href="#topic+get_eigspace.spectral">get_eigspace.spectral()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- spectral(rbind(c(0.5, 0.3), c(0.3,0.7)))

get_eigspace(s, 1) #-&gt; get_eigspace.spectral(...)

</code></pre>

<hr>
<h2 id='get_eigspace.spectral'>Extract an Eigenspace from a Hermitian Matrix</h2><span id='topic+get_eigspace.spectral'></span>

<h3>Description</h3>

<p>Get the eigenbasis associated with an eigenvalue based on the representation
of a Hermitian Matrix given by class <code>spectral</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spectral'
get_eigspace(object, id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigspace.spectral_+3A_object">object</code></td>
<td>
<p>an instance of class <code>spectral</code>.</p>
</td></tr>
<tr><td><code id="get_eigspace.spectral_+3A_id">id</code></td>
<td>
<p>index for the desired eigenspace according to the ordered (decreasing) spectra.</p>
</td></tr>
<tr><td><code id="get_eigspace.spectral_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose columns form the orthonormal eigenbasis.
</p>
<p>If <code>s &lt;- spectral(A)</code> and <code>V &lt;- s$eigvectors</code>, then the extracted eigenspace
<code class="reqn">V_{id}</code> is some submatrix <code style="white-space: pre;">&#8288;V[, _]&#8288;</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral">spectral()</a></code>, <code><a href="#topic+get_eigspace">get_eigspace()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Spectra is {2, -1} with multiplicities one and two respectively.
decomp &lt;- spectral(matrix(c(0,1,1,1,0,1,1,1,0), nrow=3))

# Returns the two orthonormal eigenvectors corresponding to the eigenvalue -1.
get_eigspace(decomp, id=2)

# Returns the eigenvector corresponding to the eigenvalue 2.
get_eigspace(decomp, id=1)

</code></pre>

<hr>
<h2 id='J'>The All-Ones Matrix</h2><span id='topic+J'></span>

<h3>Description</h3>

<p>Returns the all-ones matrix of order <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_n">n</code></td>
<td>
<p>the order of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix of order <code class="reqn">n</code> in which every entry is
equal to 1. The all-ones matrix is given by
<code class="reqn">J_{n\ x\ n} = 1_{n\ x\ 1}1_{n\ x\ 1}^T</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tr">tr()</a></code>, <code><a href="#topic+trdot">trdot()</a></code>, <code><a href="#topic+cartesian">cartesian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the all-ones matrix of order 5.
J(5)
</code></pre>

<hr>
<h2 id='mixing_matrix'>The Mixing Matrix of a Quantum Walk</h2><span id='topic+mixing_matrix'></span>

<h3>Description</h3>

<p>The Mixing Matrix of a Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixing_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixing_matrix_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="mixing_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mixing matrix of the quantum walk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitary_matrix">unitary_matrix()</a></code>, <code><a href="#topic+avg_matrix">avg_matrix()</a></code>, <code><a href="#topic+gavg_matrix">gavg_matrix()</a></code>,
<code><a href="#topic+mixing_matrix.ctqwalk">mixing_matrix.ctqwalk()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

mixing_matrix(w, t = 2*pi) #-&gt; mixing_matrix.ctqwalk(...)

</code></pre>

<hr>
<h2 id='mixing_matrix.ctqwalk'>The Mixing Matrix of a Continuous-Time Quantum Walk</h2><span id='topic+mixing_matrix.ctqwalk'></span>

<h3>Description</h3>

<p>The Mixing Matrix of a Continuous-Time Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqwalk'
mixing_matrix(object, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixing_matrix.ctqwalk_+3A_object">object</code></td>
<td>
<p>an instance of class <code>ctqwalk</code>.</p>
</td></tr>
<tr><td><code id="mixing_matrix.ctqwalk_+3A_t">t</code></td>
<td>
<p>it will be returned the mixing matrix at time <code>t</code>.</p>
</td></tr>
<tr><td><code id="mixing_matrix.ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">U(t)</code> be the time evolution operator of the quantum walk at
time <code class="reqn">t</code>, then the mixing matrix is given by
</p>
<p style="text-align: center;"><code class="reqn">M(t) = U(t) \circ \overline{U(t)}</code>
</p>

<p><code class="reqn">M(t)</code> is a doubly stochastic real symmetric matrix, which encodes the
probability density of the quantum system at time <code class="reqn">t</code>.
</p>
<p>More precisely, the <code class="reqn">(M(t))_{ab}</code> entry gives us the probability
of measuring the standard basis state <code class="reqn">|b \rangle</code> at time <code class="reqn">t</code>, given that
the quantum walk started at <code class="reqn">|a \rangle</code>.
</p>


<h3>Value</h3>

<p><code>mixing_matrix()</code> returns the  mixing matrix of the CTQW
evaluated at time <code>t</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqwalk">ctqwalk()</a></code>, <code><a href="#topic+mixing_matrix">mixing_matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>walk &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

# Returns the mixing matrix at time t = 2*pi, M(2pi)
mixing_matrix(walk, t = 2*pi)

</code></pre>

<hr>
<h2 id='print.ctqwalk'>Print the ctqwalk output</h2><span id='topic+print.ctqwalk'></span>

<h3>Description</h3>

<p>Print the ctqwalk output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqwalk'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ctqwalk_+3A_x">x</code></td>
<td>
<p>an object of the class ctqwalk.</p>
</td></tr>
<tr><td><code id="print.ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called mainly for its side effects. However, also
returns <code>x</code> invisibly.
</p>

<hr>
<h2 id='qwalkr-package'>qwalkr: Handle Continuous-Time Quantum Walks with R</h2><span id='topic+qwalkr'></span><span id='topic+qwalkr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Functions and tools for creating, visualizing, and investigating properties of continuous-time quantum walks, including efficient calculation of matrices such as the mixing matrix, average mixing matrix, and spectral decomposition of the Hamiltonian. E. Farhi (1997): <a href="https://arxiv.org/abs/quant-ph/9706062v2">arXiv:quant-ph/9706062v2</a>; C. Godsil (2011) <a href="https://arxiv.org/abs/1103.2578v3">arXiv:1103.2578v3</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vitor Marques <a href="mailto:vmrodriguespro@gmail.com">vmrodriguespro@gmail.com</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/vitormarquesr/qwalkr">https://github.com/vitormarquesr/qwalkr</a>
</p>
</li>
<li> <p><a href="https://vitormarquesr.github.io/qwalkr/">https://vitormarquesr.github.io/qwalkr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/vitormarquesr/qwalkr/issues">https://github.com/vitormarquesr/qwalkr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='spectral'>Spectral Decomposition of a Hermitian Matrix</h2><span id='topic+spectral'></span>

<h3>Description</h3>

<p><code>spectral()</code> is a wrapper around <code><a href="base.html#topic+eigen">base::eigen()</a></code> designed for Hermitian matrices,
which can handle repeated eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral(S, multiplicity = TRUE, tol = .Machine$double.eps^0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_+3A_s">S</code></td>
<td>
<p>a Hermitian matrix. <em>Obs</em>: The matrix is always assumed to be Hermitian,
and only its lower triangle (diagonal included) is used.</p>
</td></tr>
<tr><td><code id="spectral_+3A_multiplicity">multiplicity</code></td>
<td>
<p>if <code>TRUE</code> (default), tries to infer eigenvalue multiplicity. If set to
<code>FALSE</code>, each eigenvalue is considered unique with multiplicity one.</p>
</td></tr>
<tr><td><code id="spectral_+3A_tol">tol</code></td>
<td>
<p>two eigenvalues <code>x</code>, <code>y</code> are considered equal if <code>abs(x-y) &lt; tol</code>. Defaults to
<code>tol=.Machine$double.eps^0.5</code>.</p>
</td></tr>
<tr><td><code id="spectral_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="base.html#topic+eigen">base::eigen()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spectral decomposition of <code>S</code> is returned as a list with components
</p>
<table>
<tr><td><code>eigvals</code></td>
<td>
<p>vector containing the unique eigenvalues of <code>S</code> in <em>decreasing</em> order.</p>
</td></tr>
<tr><td><code>multiplicity</code></td>
<td>
<p>multiplicities of the eigenvalues in <code>eigvals</code>.</p>
</td></tr>
<tr><td><code>eigvectors</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;nrow(S) x nrow(S)&#8288;</code> unitary matrix whose columns are eigenvectors ordered
according to <code>eigvals</code>. Note that there may be more eigenvectors than eigenvalues if
<code>multiplicity=TRUE</code>, however eigenvectors of the same eigenspace are next to each other.</p>
</td></tr>
</table>
<p>The Spectral Theorem ensures the eigenvalues of <code>S</code> are real and that the vector space
admits an orthonormal basis consisting of eigenvectors of <code>S</code>. Thus, if <code>s &lt;- spectral(S)</code>,
and <code style="white-space: pre;">&#8288;V &lt;- s$eigvectors; lam &lt;- s$eigvals&#8288;</code>, then
</p>
<p style="text-align: center;"><code class="reqn">S = V \Lambda V^{*}</code>
</p>

<p>where <code class="reqn">\Lambda =\ </code><code>diag(rep(lam, times=s$multiplicity))</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">base::eigen()</a></code>, <code><a href="#topic+get_eigspace.spectral">get_eigspace.spectral()</a></code>,
<code><a href="#topic+get_eigproj.spectral">get_eigproj.spectral()</a></code>, <code><a href="#topic+get_eigschur.spectral">get_eigschur.spectral()</a></code>,
<code><a href="#topic+act_eigfun.spectral">act_eigfun.spectral()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectral(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

# Use "tol" to set the tolerance for numerical equality
spectral(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3), tol=10e-5)

# Use "multiplicity=FALSE" to force each eigenvalue to be considered unique
spectral(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3), multiplicity = FALSE)

</code></pre>

<hr>
<h2 id='tr'>The Trace of a Matrix</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Computes the trace of a matrix <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_a">A</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code class="reqn">A</code> has order <code class="reqn">n</code>,
then <code class="reqn">tr(A) = \sum_{i=1}^{n}a_{ii}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+J">J()</a></code>, <code><a href="#topic+trdot">trdot()</a></code>, <code><a href="#topic+cartesian">cartesian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(1:5, 2:6, 3:7)

# Calculate the trace of A
tr(A)
</code></pre>

<hr>
<h2 id='trdot'>The Trace Inner Product of Matrices</h2><span id='topic+trdot'></span>

<h3>Description</h3>

<p>Computes the trace inner product of two matrices <code>A</code> and <code>B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trdot(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trdot_+3A_a">A</code>, <code id="trdot_+3A_b">B</code></td>
<td>
<p>square matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trace inner product on <code class="reqn">Mat_{n\ x\ n}(\mathbb{C})</code> is
defined as
</p>
<p style="text-align: center;"><code class="reqn">\langle A, B \rangle := tr(A^*B)</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+J">J()</a></code>, <code><a href="#topic+tr">tr()</a></code>, <code><a href="#topic+cartesian">cartesian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(1:5, 2:6, 3:7)
B &lt;- rbind(7:11, 8:12, 9:13)

# Compute the trace inner product of A and B
trdot(A, B)
</code></pre>

<hr>
<h2 id='unitary_matrix'>The Unitary Time Evolution Operator of a Quantum Walk</h2><span id='topic+unitary_matrix'></span>

<h3>Description</h3>

<p>The Unitary Time Evolution Operator of a Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitary_matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitary_matrix_+3A_object">object</code></td>
<td>
<p>a representation of the quantum walk.</p>
</td></tr>
<tr><td><code id="unitary_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unitary time evolution operator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixing_matrix">mixing_matrix()</a></code>, <code><a href="#topic+unitary_matrix.ctqwalk">unitary_matrix.ctqwalk()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

unitary_matrix(w, t = 2*pi) #-&gt; unitary_matrix.ctqwalk(...)

</code></pre>

<hr>
<h2 id='unitary_matrix.ctqwalk'>The Unitary Time Evolution Operator of a Continuous-Time Quantum Walk</h2><span id='topic+unitary_matrix.ctqwalk'></span>

<h3>Description</h3>

<p>The Unitary Time Evolution Operator of a Continuous-Time Quantum Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctqwalk'
unitary_matrix(object, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitary_matrix.ctqwalk_+3A_object">object</code></td>
<td>
<p>an instance of class <code>ctqwalk</code>.</p>
</td></tr>
<tr><td><code id="unitary_matrix.ctqwalk_+3A_t">t</code></td>
<td>
<p>it will be returned the evolution operator at time <code>t</code>.</p>
</td></tr>
<tr><td><code id="unitary_matrix.ctqwalk_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">|\psi(t) \rangle</code> is the quantum state of the system at time <code class="reqn">t</code>, and
<code class="reqn">H</code> the Hamiltonian operator, then the evolution is governed by
the Schrodinger equation
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial}{\partial t}|\psi(t) \rangle = iH|\psi(t) \rangle</code>
</p>

<p>and if <code class="reqn">H</code> is time-independent its solution is given by
</p>
<p style="text-align: center;"><code class="reqn">|\psi(t) \rangle = U(t)|\psi(0) \rangle = e^{iHt}|\psi(0) \rangle</code>
</p>

<p>The evolution operator is the result of the complex matrix exponential
and it can be calculated as
</p>
<p style="text-align: center;"><code class="reqn">U(t) = e^{iHt} = \sum_r e^{i t \lambda_r}E_r</code>
</p>

<p>in which <code class="reqn">H = \sum_r \lambda_r E_r</code>.
</p>


<h3>Value</h3>

<p><code>unitary_matrix()</code> returns the unitary time evolution operator of the
CTQW evaluated at time <code>t</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctqwalk">ctqwalk()</a></code>, <code><a href="#topic+unitary_matrix">unitary_matrix()</a></code>,
<code><a href="#topic+act_eigfun">act_eigfun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>walk &lt;- ctqwalk(matrix(c(0,1,0,1,0,1,0,1,0), nrow=3))

# Returns the operator at time t = 2*pi, U(2pi)
unitary_matrix(walk, t = 2*pi)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
