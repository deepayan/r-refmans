<!DOCTYPE html><html><head><title>Help for package BSL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BSL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BSL-package'><p>Bayesian synthetic likelihood</p></a></li>
<li><a href='#bsl'><p>Performing BSL, uBSL, semiBSL and BSLmisspec</p></a></li>
<li><a href='#BSL-class'><p>S4 class &ldquo;BSL&rdquo;.</p></a></li>
<li><a href='#cell'><p>Cell biology example</p></a></li>
<li><a href='#combinePlotsBSL'><p>Plot the densities of multiple &ldquo;bsl&rdquo; class objects.</p></a></li>
<li><a href='#cor2cov'><p>Convert a correlation matrix to a covariance matrix</p></a></li>
<li><a href='#estimateLoglike'><p>Estimate the synthetic likelihood</p></a></li>
<li><a href='#estimateWhiteningMatrix'><p>Estimate the Whitening matrix to be used in the &ldquo;wBSL&rdquo; method of</p>
Priddle et al. (2021)</a></li>
<li><a href='#gaussianRankCorr'><p>Gaussian rank correlation</p></a></li>
<li><a href='#gaussianSynLike'><p>Estimate the Gaussian synthetic (log) likelihood</p></a></li>
<li><a href='#gaussianSynLikeGhuryeOlkin'><p>Estimate the Gaussian synthetic (log) likelihood with an unbiased estimator</p></a></li>
<li><a href='#getGamma'><p>Obtain the gamma samples (the latent parameters for BSLmisspec method) from a</p>
&quot;BSL&quot; object</a></li>
<li><a href='#getLoglike'><p>Obtain the log-likelihoods from a &quot;BSL&quot; object</p></a></li>
<li><a href='#getPenalty'><p>Obtain the selected penalty values from a &quot;PENALTY&quot; object</p></a></li>
<li><a href='#getTheta'><p>Obtain the samples from a &quot;BSL&quot; object</p></a></li>
<li><a href='#ma2'><p>An MA(2) model</p></a></li>
<li><a href='#mgnk'><p>The multivariate G&amp;K example</p></a></li>
<li><a href='#MODEL-class'><p>S4 class &ldquo;MODEL&rdquo;</p></a></li>
<li><a href='#myMiniProgressBar'><p>Progress Bar</p></a></li>
<li><a href='#obsMat2deltax'><p>Convert an observation matrix to a vector of n-day displacements</p></a></li>
<li><a href='#PENALTY-class'><p>S4 class &ldquo;PENALTY&rdquo;</p></a></li>
<li><a href='#rstable'><p>Generate a random sample from the zero-centered stable distribution</p></a></li>
<li><a href='#selectPenalty'><p>Selecting the Penalty Parameter</p></a></li>
<li><a href='#semiparaKernelEstimate'><p>Estimate the semi-parametric synthetic (log) likelihood</p></a></li>
<li><a href='#sim_toad'><p>The simulation function for the toad example</p></a></li>
<li><a href='#simulate_cell'><p>Simulation function of the cell biology example</p></a></li>
<li><a href='#simulation'><p>Run simulations with a give &quot;MODEL&quot; object</p></a></li>
<li><a href='#sliceGammaMean'><p>Generate a random sample of gamma for the R-BSL-M method of</p>
Frazier and Drovandi (2021) using slice sampling</a></li>
<li><a href='#sliceGammaVariance'><p>Generate a random sample of gamma for the R-BSL-V method of</p>
Frazier and Drovandi (2021) using slice sampling</a></li>
<li><a href='#summStat'><p>Compute the summary statistics with the given data</p></a></li>
<li><a href='#synLikeMisspec'><p>Estimate the Gaussian synthetic (log) likelihood whilst acknowledging model</p>
incompatibility</a></li>
<li><a href='#toad'><p>Toad example</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Synthetic Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian synthetic likelihood (BSL, Price et al. (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1302882">doi:10.1080/10618600.2017.1302882</a>&gt;)
    is an alternative to standard, non-parametric approximate Bayesian 
	computation (ABC). BSL assumes a multivariate normal distribution 
	for the summary statistic likelihood and it is suitable when the 
	distribution of the model summary statistics is sufficiently regular. 
	This package provides a Metropolis Hastings Markov chain Monte Carlo 
	implementation of four methods (BSL, uBSL, semiBSL and BSLmisspec) and two 
	shrinkage estimators (graphical lasso and Warton's estimator).
	uBSL (Price et al. (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1302882">doi:10.1080/10618600.2017.1302882</a>&gt;) uses 
	an unbiased estimator to the normal density. A semi-parametric version 
	of BSL (semiBSL, An et al. (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1809.05800">doi:10.48550/arXiv.1809.05800</a>&gt;) is more robust 
	to non-normal summary statistics. BSLmisspec (Frazier et al. 2019 
	&lt;<a href="https://doi.org/10.48550/arXiv.1904.04551">doi:10.48550/arXiv.1904.04551</a>&gt;) estimates the Gaussian synthetic likelihood whilst 
	acknowledging that there may be incompatibility between the model and the 
	observed summary statistic. Shrinkage estimation can help to decrease the
	number of model simulations when the dimension of the summary statistic is 
	high (e.g., BSLasso, An et al. (2019) &lt;<a href="https://doi.org/10.1080%2F10618600.2018.1537928">doi:10.1080/10618600.2018.1537928</a>&gt;). 
	Extensions to this package are planned. For a journal article describing how
	to use this package, see An et al. (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i11">doi:10.18637/jss.v101.i11</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>glasso, ggplot2, MASS, mvtnorm, copula, whitening, graphics,
gridExtra, foreach, coda, Rcpp, doRNG, methods, stringr, Rdpack
(&ge; 0.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>elliplot, doParallel, rbenchmark, mixtools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'BSL-package.R' 'RcppExports.R' 's4-MODEL.R' 's4-BSL.R'
'bsl.R' 'cell.R' 'combinePlotsBSL.R' 'covWarton.R'
'estimateLoglike.R' 'estimateWhiteningMatrix.R'
'gaussianRankCorr.R' 'gaussianSynLike.R'
'gaussianSynLikeGhuryeOlkin.R' 'imports.R' 'kernelCDF.R'
'logitTransform.R' 'ma2.R' 'mgnk.R' 'myMiniProgressBar.R'
's4-PENALTY.R' 'selectPenalty.R' 'semiparaKernelEstimate.R'
'sliceGammaMean.R' 'sliceGammaVariance.R' 'synLikeMisspec.R'
'toad.R'</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-02 05:28:19 UTC; southl</td>
</tr>
<tr>
<td>Author:</td>
<td>Ziwen An <a href="https://orcid.org/0000-0002-9947-5182"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Leah F. South <a href="https://orcid.org/0000-0002-5646-2963"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Christopher C. Drovandi
    <a href="https://orcid.org/0000-0001-9222-8763"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leah F. South &lt;l1.south@qut.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-03 09:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='BSL-package'>Bayesian synthetic likelihood</h2><span id='topic+BSL'></span><span id='topic+BSL-package'></span>

<h3>Description</h3>

<p>Bayesian synthetic likelihood (BSL,
Price et al. (2018)) is an alternative to standard,
non-parametric approximate Bayesian computation (ABC). BSL assumes a
multivariate normal distribution for the summary statistic likelihood and it
is suitable when the distribution of the model summary statistics is
sufficiently regular.
</p>
<p>In this package, a Metropolis Hastings Markov chain Monte Carlo (MH-MCMC)
implementation of BSL is available. We also include implementations of four
methods (BSL, uBSL, semiBSL and BSLmisspec) and two shrinkage estimators
(graphical lasso and Warton's estimator).
</p>
<p>Methods: (1) BSL (Price et al. 2018), which is the standard form of
Bayesian synthetic likelihood, assumes the summary statistic is roughly
multivariate normal; (2) uBSL (Price et al. 2018), which uses an
unbiased estimator to the normal density; (3) semiBSL
(An et al. 2019), which relaxes the normality assumption to an
extent and maintains the computational advantages of BSL without any tuning;
and (4) BSLmisspec (Frazier and Drovandi 2021), which estimates the
Gaussian synthetic likelihood whilst acknowledging that there may be
incompatibility between the model and the observed summary statistic.
</p>
<p>Shrinkage estimators are designed particularly to reduce the number of
simulations if method is BSL or semiBSL: (1) graphical lasso
(Friedman et al. 2008) finds a sparse precision matrix with an
L1-regularised log-likelihood. An et al. (2019) use
graphical lasso within BSL to bring down the number of simulations
significantly when the dimension of the summary statistic is high; and (2)
Warton's estimator (Warton 2008) penalises the correlation
matrix and is straightforward to compute. When using the Warton's shrinkage
estimator, it is also possible to utilise the Whitening transformation
(Kessy et al. 2018) to help decorrelate the summary statsitics, thus
encouraging sparsity of the synthetic likelihood covariance matrix.
</p>
<p>Parallel computing is supported through the <code>foreach</code> package and users
can specify their own parallel backend by using packages like
<code>doParallel</code> or <code>doMC</code>. The <code>n</code> model simulations required to
estimate the synthetic likelihood at each iteration of MCMC will be
distributed across multiple cores. Alternatively a vectorised simulation
function that simultaneously generates <code>n</code> model simulations is also
supported.
</p>
<p>The main functionality is available through:
</p>
 <ul>
<li> <p><code><a href="#topic+bsl">bsl</a></code>: The general function to perform BSL,
uBSL, or semiBSL (with or without parallel computing). </p>
</li>
<li>
<p><code><a href="#topic+selectPenalty">selectPenalty</a></code>: A function to select the penalty when using
shrinkage estimation within BSL or semiBSL. </p>
</li></ul>

<p>Several examples have also been included. These examples can be used to
reproduce the results of An et al. (2019), and can help practitioners learn
how to use the package.
</p>

<ul>
<li> <p><code><a href="#topic+ma2">ma2</a></code>: The MA(2) example from
An et al. (2019).
</p>
</li>
<li> <p><code><a href="#topic+mgnk">mgnk</a></code>: The multivariate G&amp;K example from
An et al. (2019).
</p>
</li>
<li> <p><code><a href="#topic+cell">cell</a></code>: The cell biology example from
Price et al. (2018) and An et al. (2019).
</p>
</li>
<li> <p><code><a href="#topic+toad">toad</a></code>: The toad example from
Marchand et al. (2017), and also considered in
An et al. (2019).
</p>
</li></ul>

<p>Extensions to this package are planned. For a journal article describing how
to use this package, including full descriptions on the MA(2) and toad examples,
see An et al. (2022).
</p>


<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, Nott DJ, Drovandi C (2019).
&ldquo;Robust Bayesian Synthetic Likelihood via a Semi-Parametric Approach.&rdquo;
<em>Statistics and Computing (In Press)</em>.<br /><br /> An Z, South LF, Drovandi CC (2022).
&ldquo;BSL: An R Package for Efficient Parameter Estimation for Simulation-Based Models via Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Statistical Software</em>, <b>101</b>(11), 1&ndash;33.
doi: <a href="https://doi.org/10.18637/jss.v101.i11">10.18637/jss.v101.i11</a>.<br /><br /> An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Kessy A, Lewin A, Strimmer K (2018).
&ldquo;Optimal Whitening and Decorrelation.&rdquo;
<em>The American Statistician</em>, <b>72</b>(4), 309&ndash;314.
doi: <a href="https://doi.org/10.1080/00031305.2016.1277159">10.1080/00031305.2016.1277159</a>.<br /><br /> Marchand P, Boenke M, Green DM (2017).
&ldquo;A stochastic movement model reproduces patterns of site fidelity and long-distance dispersal in a population of Fowlers toads (Anaxyrus fowleri).&rdquo;
<em>Ecological Modelling</em>, <b>360</b>, 63&ndash;69.
ISSN 0304-3800, doi: <a href="https://doi.org/10.1016/j.ecolmodel.2017.06.025">10.1016/j.ecolmodel.2017.06.025</a>.<br /><br /> Price LF, Drovandi CC, Lee A, Nott DJ (2018).
&ldquo;Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 1&ndash;11.
doi: <a href="https://doi.org/10.1080/10618600.2017.1302882">10.1080/10618600.2017.1302882</a>.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>

<hr>
<h2 id='bsl'>Performing BSL, uBSL, semiBSL and BSLmisspec</h2><span id='topic+bsl'></span>

<h3>Description</h3>

<p>This is the main function for performing MCMC BSL (with a
standard or non-standard likelihood estimator) to sample from the
approximate posterior distribution. A couple of extentions to the standard
approach are available by changing the following arguments, <code>method</code>,
<code>shrinkage</code>, <code>whitening</code>, <code>misspecType</code>. Parallel computing
is supported with the R package <code>foreach</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsl(
  y,
  n,
  M,
  model,
  covRandWalk,
  theta0,
  fnSim,
  fnSum,
  method = c("BSL", "uBSL", "semiBSL", "BSLmisspec"),
  shrinkage = NULL,
  penalty = NULL,
  fnPrior = NULL,
  simArgs = NULL,
  sumArgs = NULL,
  logitTransformBound = NULL,
  standardise = FALSE,
  GRC = FALSE,
  whitening = NULL,
  misspecType = NULL,
  tau = 1,
  parallel = FALSE,
  parallelArgs = NULL,
  thetaNames = NULL,
  plotOnTheFly = FALSE,
  verbose = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsl_+3A_y">y</code></td>
<td>
<p>The observed data. Note this should be the raw dataset NOT the
set of summary statistics.</p>
</td></tr>
<tr><td><code id="bsl_+3A_n">n</code></td>
<td>
<p>The number of simulations from the model per MCMC iteration for
estimating the synthetic likelihood.</p>
</td></tr>
<tr><td><code id="bsl_+3A_m">M</code></td>
<td>
<p>The number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="bsl_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; object generated with function
<code>newModel</code>. See <code><a href="#topic+newModel">newModel</a></code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_covrandwalk">covRandWalk</code></td>
<td>
<p>The covariance matrix of a multivariate normal random walk
proposal distribution used in the MCMC.</p>
</td></tr>
<tr><td><code id="bsl_+3A_theta0">theta0</code></td>
<td>
<p>Deprecated, will be removed in the future, use <code>model</code>
instead. Initial guess of the parameter value, which is used as the
starting value for MCMC.</p>
</td></tr>
<tr><td><code id="bsl_+3A_fnsim">fnSim</code></td>
<td>
<p>Deprecated, will be removed in the future, use
<code>model</code> instead. A function that simulates data for a given parameter
value. The first argument should be the parameters. Other necessary
arguments (optional) can be specified with <code>simArgs</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_fnsum">fnSum</code></td>
<td>
<p>Deprecated, will be removed in the future, use
<code>model</code> instead. A function for computing summary statistics of data.
The first argument should be the observed or simulated dataset. Other
necessary arguments (optional) can be specified with <code>sumArgs</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_method">method</code></td>
<td>
<p>A string argument indicating the method to be used. The
default, &ldquo;BSL&rdquo;, runs standard BSL. &ldquo;uBSL&rdquo; uses the unbiased estimator
of a normal density of Ghurye and Olkin (1969). &ldquo;semiBSL&rdquo;
runs the semi-parametric BSL algorithm and is more robust to non-normal
summary statistics. &ldquo;BSLmisspec&rdquo; estimates the Gaussian synthetic
likelihood whilst acknowledging that there may be incompatibility between
the model and the observed summary statistic (Frazier and Drovandi 2021).</p>
</td></tr>
<tr><td><code id="bsl_+3A_shrinkage">shrinkage</code></td>
<td>
<p>A string argument indicating which shrinkage method to
be used. The default is <code>NULL</code>, which means no shrinkage is used.
Shrinkage estimation is only available for methods &ldquo;BSL&rdquo; and &ldquo;semiBSL&rdquo;.
Current options are &ldquo;glasso&rdquo; for the graphical lasso method of
Friedman et al. (2008) and &ldquo;Warton&rdquo; for the ridge
regularisation method of Warton (2008).</p>
</td></tr>
<tr><td><code id="bsl_+3A_penalty">penalty</code></td>
<td>
<p>The penalty value to be used for the specified shrinkage
method. Must be between zero and one if the shrinkage method is &ldquo;Warton&rdquo;.</p>
</td></tr>
<tr><td><code id="bsl_+3A_fnprior">fnPrior</code></td>
<td>
<p>Deprecated, will be removed in the future, use
<code>model</code> instead. A function that computes the log prior density for a
parameter. The default is <code>NULL</code>, which uses an improper flat prior
over the real line for each parameter. The function must have a single
input: a vector of parameter values.</p>
</td></tr>
<tr><td><code id="bsl_+3A_simargs">simArgs</code></td>
<td>
<p>Deprecated, will be removed in the future, use
<code>model</code> instead. A list of additional arguments to pass into the
simulation function. Only use when the input <code>fnSim</code> requires
additional arguments. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_sumargs">sumArgs</code></td>
<td>
<p>Deprecated, will be removed in the future, use
<code>model</code> instead. A list of additional arguments to pass into the
summary statistics function. Only use when the input <code>fnSum</code> requires
additional arguments. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_logittransformbound">logitTransformBound</code></td>
<td>
<p>A <code class="reqn">p</code> by <code class="reqn">2</code> numeric matrix indicating the
upper and lower bounds of parameters if a logit transformation is used on
the parameter space, where <code class="reqn">p</code> is the number of parameters. The default
is <code>NULL</code>, which means no logit transformation is used. It is also
possible to define other transformations within the simulation and prior
function from <code>model</code>. The first column contains the lower bound of
each parameter and the second column contains the upper bound. Infinite
lower or upper bounds are also supported, eg.
<code>matrix(c(1,Inf,0,10,-Inf,0.5),3,2,byrow=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_standardise">standardise</code></td>
<td>
<p>A logical argument that determines whether to standardise
the summary statistics before applying the graphical lasso. This is only
valid if method is &ldquo;BSL&rdquo;, shrinkage is &ldquo;glasso&rdquo; and penalty is not
<code>NULL</code>. The diagonal elements will not be penalised if the shrinkage
method is &ldquo;glasso&rdquo;. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_grc">GRC</code></td>
<td>
<p>A logical argument indicating whether the Gaussian rank
correlation matrix (Boudt et al. 2012) should be used to estimate
the covariance matrix in &ldquo;BSL&rdquo; method. The default is <code>FALSE</code>, which
uses the sample covariance by default.</p>
</td></tr>
<tr><td><code id="bsl_+3A_whitening">whitening</code></td>
<td>
<p>This argument determines whether Whitening transformation
should be used in &ldquo;BSL&rdquo; method with Warton's shrinkage. Whitening
transformation helps decorrelate the summary statistics, thus encouraging
sparsity of the synthetic likelihood covariance matrix. This might allow
heavier shrinkage to be applied without losing much accuracy, hence
allowing the number of simulations to be reduced. By default, <code>NULL</code>
represents no Whitening transformation. Otherwise this is enabled if a
Whitening matrix is provided. See <code><a href="#topic+estimateWhiteningMatrix">estimateWhiteningMatrix</a></code> for
the function to estimate the Whitening matrix.</p>
</td></tr>
<tr><td><code id="bsl_+3A_misspectype">misspecType</code></td>
<td>
<p>A string argument indicating which type of model
misspecification to be used. The two options are &quot;mean&quot; and &quot;variance&quot;.
Only used when method is &ldquo;BSLmisspec&rdquo;. The default, <code>NULL</code>, means no
model misspecification is considered.</p>
</td></tr>
<tr><td><code id="bsl_+3A_tau">tau</code></td>
<td>
<p>A numeric argument, parameter of the prior distribution
for &quot;BSLmisspec&quot; method. For mean adjustment, <code>tau</code> is the scale of
the Laplace distribution. For variance inflation, <code>tau</code> is the mean of
the exponential distribution. Only used when method is &ldquo;BSLmisspec&rdquo;.</p>
</td></tr>
<tr><td><code id="bsl_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether parallel computing should
be used for simulation and summary statistic evaluation. The default is
<code>FALSE</code>. When model simulation is fast, it may be preferable to
perform serial or vectorised computations to avoid significant
communication overhead between workers. Parallel computation can only be
used if not using a vectorised simulation function, see <code><a href="#topic+MODEL">MODEL</a></code>
for options of vectorised simulation function.</p>
</td></tr>
<tr><td><code id="bsl_+3A_parallelargs">parallelArgs</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>foreach</code> function. Only used when parallel computing is enabled,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_thetanames">thetaNames</code></td>
<td>
<p>Deprecated, will be removed in the future, use <code>model</code>
instead. A string vector of parameter names, which must have the same
length as the parameter vector. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_plotonthefly">plotOnTheFly</code></td>
<td>
<p>A logical or numeric argument defining whether or by how
many iterations a posterior figure will be plotted during running. If
<code>TRUE</code>, a plot of approximate univariate posteriors based on the
current accepted samples will be shown every one thousand iterations.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bsl_+3A_verbose">verbose</code></td>
<td>
<p>An integer indicating the verbose style. 0L
means no verbose messages will be printed. 1L uses a custom progress bar to
track the progress. 2L prints the iteration numbers (<code>1:M</code>) to track
the progress. The default is 1L.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bsl</code> is returned, see <code><a href="#topic+BSL">BSL</a></code>
for more information of the S4 class.
</p>


<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>Boudt K, Cornelissen J, Croux C (2012).
&ldquo;The Gaussian Rank Correlation Estimator: Robustness Properties.&rdquo;
<em>Statistics and Computing</em>, <b>22</b>(2), 471&ndash;483.
doi: <a href="https://doi.org/10.1007/s11222-011-9237-0">10.1007/s11222-011-9237-0</a>.<br /><br /> Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Ghurye SG, Olkin I (1969).
&ldquo;Unbiased Estimation of Some Multivariate Probability Densities and Related Functions.&rdquo;
<em>Ann. Math. Statist.</em>, <b>40</b>(4), 1261&ndash;1271.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>
<p>Price LF, Drovandi CC, Lee A, Nott DJ (2018).
&ldquo;Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 1&ndash;11.
doi: <a href="https://doi.org/10.1080/10618600.2017.1302882">10.1080/10618600.2017.1302882</a>.
</p>
<p>An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.
</p>
<p>An Z, Nott DJ, Drovandi C (2019).
&ldquo;Robust Bayesian Synthetic Likelihood via a Semi-Parametric Approach.&rdquo;
<em>Statistics and Computing (In Press)</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ma2">ma2</a></code>, <code><a href="#topic+cell">cell</a></code>, <code><a href="#topic+mgnk">mgnk</a></code> and
<code><a href="#topic+toad">toad</a></code> for examples. <code><a href="#topic+selectPenalty">selectPenalty</a></code> for a function
to tune the BSLasso tuning parameter and <code><a href="graphics.html#topic+plot">plot</a></code> for functions
related to visualisation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# This is just a minimal test run, please see package built-in examples for more
# comprehensive usages of the function
toy_sim &lt;- function(n, theta) matrix(rnorm(n, theta), nrow = n)
toy_sum &lt;- function(x) x
model &lt;- newModel(fnSimVec = toy_sim, fnSum = toy_sum, theta0 = 0)

result_toy &lt;- bsl(y = 1, n = 100, M = 1e4, model = model, covRandWalk = matrix(1),
    method = "BSL", plotOnTheFly = TRUE)
summary(result_toy)
plot(result_toy)

## End(Not run)

</code></pre>

<hr>
<h2 id='BSL-class'>S4 class &ldquo;BSL&rdquo;.</h2><span id='topic+BSL-class'></span><span id='topic+BSLclass'></span><span id='topic+show+2CBSL-method'></span><span id='topic+summary+2CBSL-method'></span><span id='topic+plot+2CBSL+2CANY-method'></span><span id='topic+getTheta+2CBSL-method'></span><span id='topic+getLoglike+2CBSL-method'></span><span id='topic+getGamma+2CBSL-method'></span>

<h3>Description</h3>

<p>The S4 class &ldquo;BSL&rdquo; is produced by running function
<code><a href="#topic+bsl">bsl</a></code> and contains the result of a BSL run. Basic S4 methods
<code>show</code>, <code>summary</code> and <code>plot</code> are provided. <code>theta</code> and
<code>loglike</code> returns the MCMC samples of parameter values and estimated
log-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BSL'
show(object)

## S4 method for signature 'BSL'
summary(object, burnin = 0, thetaNames = NULL)

## S4 method for signature 'BSL,ANY'
plot(
  x,
  which = 1L,
  thin = 1,
  burnin = 0,
  thetaTrue = NULL,
  options.plot = NULL,
  top = "Approximate Univariate Posteriors",
  options.density = list(),
  options.theme = list()
)

## S4 method for signature 'BSL'
getTheta(object, burnin = 0, thin = 1)

## S4 method for signature 'BSL'
getLoglike(object, burnin = 0, thin = 1)

## S4 method for signature 'BSL'
getGamma(object, burnin = 0, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSL-class_+3A_object">object</code></td>
<td>
<p>A &ldquo;BSL&rdquo; class object.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_burnin">burnin</code></td>
<td>
<p>the number of MCMC burn-in steps to be taken.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_thetanames">thetaNames</code></td>
<td>
<p>Parameter names to be shown in the summary table. If not
given, parameter names of the &ldquo;BSL&rdquo; object will be used by default.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_x">x</code></td>
<td>
<p>A &ldquo;BSL&rdquo; class object to plot.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_which">which</code></td>
<td>
<p>An integer argument indicating which plot function to be
used. The default, <code>1L</code>, uses the plain <code>plot</code> to visualise the
result. <code>2L</code> uses ggplot2 to draw the plot.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_thin">thin</code></td>
<td>
<p>A numeric argument indicating the gap between samples to
be taken when thinning the MCMC draws. The default is <code>1</code>, which means
no thinning is used.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_thetatrue">thetaTrue</code></td>
<td>
<p>A set of true parameter values to be included on the plots
as a reference line. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_options.plot">options.plot</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>plot</code> function. Only use when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_top">top</code></td>
<td>
<p>A character argument of the combined plot title if
<code>which</code> is <code>2L</code>.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_options.density">options.density</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>geom_density</code> function. Only use when <code>which</code> is <code>2L</code>.</p>
</td></tr>
<tr><td><code id="BSL-class_+3A_options.theme">options.theme</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>theme</code> function. Only use when <code>which</code> is <code>2L</code>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>theta</code></dt><dd><p>Object of class &ldquo;matrix&rdquo;. MCMC samples from the joint
approximate posterior distribution of the parameters.</p>
</dd>
<dt><code>loglike</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. Accepted MCMC samples of the
estimated log-likelihood values.</p>
</dd>
<dt><code>call</code></dt><dd><p>Object of class &ldquo;call&rdquo;. The original code that was used to call
the method.</p>
</dd>
<dt><code>model</code></dt><dd><p>Object of class &ldquo;MODEL&rdquo;.</p>
</dd>
<dt><code>acceptanceRate</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. The acceptance rate of the
MCMC algorithm.</p>
</dd>
<dt><code>earlyRejectionRate</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. The early rejection
rate of the algorithm (early rejection may occur when using bounded prior
distributions).</p>
</dd>
<dt><code>errorRate</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. The error rate. If any infinite
summary statistic or infinite log-likelihood estimate occurs during the
process, it is marked as an error and the proposed parameter will be
rejected.</p>
</dd>
<dt><code>y</code></dt><dd><p>Object of class &ldquo;ANY&rdquo;. The observed data.</p>
</dd>
<dt><code>n</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. The number of simulations from the model
per MCMC iteration to estimate the synthetic likelihood.</p>
</dd>
<dt><code>M</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. The number of MCMC iterations.</p>
</dd>
<dt><code>covRandWalk</code></dt><dd><p>Object of class &ldquo;matrix&rdquo;. The covariance matrix used in
multivariate normal random walk proposals.</p>
</dd>
<dt><code>method</code></dt><dd><p>Object of class &ldquo;character&rdquo;. The character argument indicating
the used method.</p>
</dd>
<dt><code>shrinkage</code></dt><dd><p>Object of class &ldquo;characterOrNULL&rdquo;. The character argument
indicating the shrinkage method.</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Object of class &ldquo;numericOrNULL&rdquo;. The penalty value.</p>
</dd>
<dt><code>GRC</code></dt><dd><p>Object of class &ldquo;logical&rdquo;. Whether the Gaussian rank correlation
matrix is used.</p>
</dd>
<dt><code>logitTransform</code></dt><dd><p>Object of class &ldquo;logical&rdquo;. The logical argument
indicating whether a logit transformation is used in the algorithm.</p>
</dd>
<dt><code>logitTransformBound</code></dt><dd><p>Object of class &ldquo;matrixOrNULL&rdquo;. The matrix of
logitTransformBound.</p>
</dd>
<dt><code>standardise</code></dt><dd><p>Object of class &ldquo;logical&rdquo;. The logical argument that
determines whether to standardise the summary statistics.</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Object of class &ldquo;logical&rdquo;. The logical value indicating
whether parallel computing is used in the process.</p>
</dd>
<dt><code>parallelArgs</code></dt><dd><p>Object of class &ldquo;listOrNULL&rdquo;. The list of additional
arguments to pass into the <code>foreach</code> function.</p>
</dd>
<dt><code>time</code></dt><dd><p>Object of class &ldquo;difftime&rdquo;. The running time.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. MCMC samples of gamma parameter
values of the mean adjustment or variance inflation for method
&ldquo;BSLmisspec&rdquo;.</p>
</dd>
<dt><code>misspecType</code></dt><dd><p>Object of class &ldquo;characterOrNULL&rdquo;. The character argument
indicating whether mean adjustment (&quot;mean&quot;) or variance inflation
(&quot;variance&quot;) to be used in &quot;BSLmisspec&quot; method.</p>
</dd>
<dt><code>tau</code></dt><dd><p>Object of class &ldquo;numeric&rdquo;. Parameter of the prior distribution
for &quot;BSLmisspec&quot; method. For mean adjustment, <code>tau</code> is the scale of
the Laplace distribution. For variance inflation, <code>tau</code> is the mean of
the exponential distribution.</p>
</dd>
<dt><code>whitening</code></dt><dd><p>Object of class &ldquo;logicalOrMatrixOrNULL&rdquo;. A logical argument
determines whether Whitening transformation is used in &ldquo;BSL&rdquo; method with
Warton's shrinkage, or just the Whitening matrix used.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# a toy example
toy_simVec &lt;- function(n, theta) matrix(rnorm(n, theta), nrow = n) # the simulation function
toy_sum &lt;- function(x) x # the summary statistic function
model &lt;- newModel(fnSimVec = toy_simVec, fnSum = toy_sum, theta0 = 0) # create the model object
result_toy &lt;- bsl(y = 1, n = 100, M = 1e4, model = model, covRandWalk = matrix(1))
summary(result_toy)
plot(result_toy)

## End(Not run)

</code></pre>

<hr>
<h2 id='cell'>Cell biology example</h2><span id='topic+cell'></span><span id='topic+cell_sim'></span><span id='topic+cell_sum'></span><span id='topic+cell_prior'></span>

<h3>Description</h3>

<p>This example estimates the probabilities of cell motility and
cell proliferation for a discrete-time stochastic model of cell spreading.
We provide the data and tuning parameters required to reproduce the results
in An et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ma2)

cell_sim(theta, Yinit, rows, cols, sim_iters, num_obs)

cell_sum(Y, Yinit)

cell_prior(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_+3A_theta">theta</code></td>
<td>
<p>A vector of proposed model parameters,
<code class="reqn">P_m</code> and <code class="reqn">P_p</code>.</p>
</td></tr>
<tr><td><code id="cell_+3A_yinit">Yinit</code></td>
<td>
<p>The initial matrix of cell presences of size <code>rows</code>
<code class="reqn">\times</code> <code>cols</code>.</p>
</td></tr>
<tr><td><code id="cell_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the lattice (rows in the cell location
matrix).</p>
</td></tr>
<tr><td><code id="cell_+3A_cols">cols</code></td>
<td>
<p>The number of columns in the lattice (columns in the cell
location matrix).</p>
</td></tr>
<tr><td><code id="cell_+3A_sim_iters">sim_iters</code></td>
<td>
<p>The number of discretisation steps to get to when an
observation is actually taken. For example, if observations are taken every
5 minutes but the discretisation level is 2.5 minutes, then
<code>sim_iters</code> would be 2. Larger values of <code>sim_iters</code> lead to more
&ldquo;accurate&rdquo; simulations from the model, but they also increase the
simulation time.</p>
</td></tr>
<tr><td><code id="cell_+3A_num_obs">num_obs</code></td>
<td>
<p>The total number of images taken after initialisation.</p>
</td></tr>
<tr><td><code id="cell_+3A_y">Y</code></td>
<td>
<p>A <code>rows</code> <code class="reqn">\times</code>
<code>cols</code> <code class="reqn">\times</code> <code>num_obs</code> array
of the cell presences at times <code>1:num_obs</code> (not time 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cell motility (movement) and proliferation (reproduction) cause
tumors to spread and wounds to heal. If we can measure cell proliferation
and cell motility under different situations, then we may be able to use
this information to determine the efficacy of different medical treatments.
</p>
<p>A common method for measuring in vitro cell movement and proliferation is
the scratch assay. Cells form a layer on an assay and, once they are
completely covering the assay, a scratch is made to separate the cells.
Images of the cells are taken until the scratch has closed up and the cells
are in contact again. Each image can be converted to a binary matrix by
forming a lattice and recording the binary matrix (of size <code>rows</code>
<code class="reqn">\times</code> <code>cols</code>) of cell presences.
</p>
<p>The model that we consider is a random walk model with parameters for the
probability of cell movement
(<code class="reqn">P_m</code>) and the probability
of cell proliferation
(<code class="reqn">P_p</code>) and it has no
tractable likelihood function. We use the vague priors
<code class="reqn">P_m \sim U(0,1)</code>
and <code class="reqn">P_p \sim U(0,1)</code>.
</p>
<p>We have a total of 145 summary statistics, which are made up of the Hamming
distances between the binary matrices for each time point and the total
number of cells at the final time.
</p>
<p>Details about the types of cells that this model is suitable for and other
information can be found in Price et al. (2018) and
An et al. (2019). Johnston et al. (2014)
use a different ABC method and different summary statistics for a similar
example.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cell_sim</code>: The function <code>cell_sim(theta, Yinit, rows, cols,
sim_iters, num_obs)</code> simulates data from the model, using C++ in the
backend.
</p>
</li>
<li> <p><code>cell_sum</code>: The function <code>cell_sum(Y,sum_options)</code> calculates the
summary statistics for this example.
</p>
</li>
<li> <p><code>cell_prior</code>: The function <code>cell_prior(theta)</code> evaluates the log
prior density at the parameter value
<code class="reqn">\theta</code>.
</p>
</li></ul>


<h3>A simulated dataset</h3>

<p>An example &ldquo;observed&rdquo; dataset and the tuning parameters relevant to that
example can be obtained using <code>data(cell)</code>. This &ldquo;observed&rdquo; data is
a simulated dataset with <code class="reqn">P_m = 0.35</code> and 
<code class="reqn">P_p = 0.001</code>. The lattice has 27 <code>rows</code> and 36
<code>cols</code> and there are <code>num_obs = 144</code> observations after time 0
(to mimic images being taken every 5 minutes for 12 hours). The simulation
is based on there initially being 110 cells in the assay.
</p>
<p>Further information about the specific choices of tuning parameters used in
BSL and BSLasso can be found in An et al. (2019).
</p>

<ul>
<li> <p><code>data</code>:  The <code>rows</code>
<code class="reqn">\times</code> <code>cols</code>
<code class="reqn">\times</code> <code>num_obs</code> array of the cell
presences at times 1:144.
</p>
</li>
<li> <p><code>sim_args</code>: Values of <code>sim_args</code> relevant to this example.
</p>
</li>
<li> <p><code>sum_args</code>: Values of <code>sum_args</code> relevant to this example,
i.e. just the value of <code>Yinit</code>.
</p>
</li>
<li> <p><code>start</code>: A vector of suitable initial values of the parameters
for MCMC.
</p>
</li>
<li> <p><code>cov</code>: The covariance matrix of a multivariate normal random
walk proposal distribution used in the MCMC, in the form of a 2
<code class="reqn">\times</code> 2 matrix.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Johnston ST, Simpson MJ, McElwain DLS, Binder BJ, Ross JV (2014).
&ldquo;Interpreting scratch assays using pair density dynamics and approximate Bayesian computation.&rdquo;
<em>Open Biology</em>, <b>4</b>(9), 140097.
doi: <a href="https://doi.org/10.1098/rsob.140097">10.1098/rsob.140097</a>.<br /><br /> Price LF, Drovandi CC, Lee A, Nott DJ (2018).
&ldquo;Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 1&ndash;11.
doi: <a href="https://doi.org/10.1080/10618600.2017.1302882">10.1080/10618600.2017.1302882</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(doParallel) # You can use a different package to set up the parallel backend

# Loading the data for this example
data(cell)
model &lt;- newModel(fnSim = cell_sim, fnSum = cell_sum, simArgs = cell$sim_args,
                  sumArgs = cell$sum_args, theta0 = cell$start, fnLogPrior = cell_prior,
                  thetaNames = expression(P[m], P[p]))
thetaExact &lt;- c(0.35, 0.001)

# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultCellBSL &lt;- bsl(cell$data, n = 5000, M = 10000, model = model, covRandWalk = cell$cov,
                     parallel = TRUE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultCellBSL)
summary(resultCellBSL)
plot(resultCellBSL, thetaTrue = thetaExact, thin = 20)

# Performing uBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultCelluBSL &lt;- bsl(cell$data, n = 5000, M = 10000, model = model, covRandWalk = cell$cov,
                      method = "uBSL", parallel = TRUE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultCelluBSL)
summary(resultCelluBSL)
plot(resultCelluBSL, thetaTrue = thetaExact, thin = 20)

# Performing tuning for BSLasso
ssy &lt;- cell_sum(cell$data, cell$sum_args$Yinit)
lambda_all &lt;- list(exp(seq(0.5,2.5,length.out=20)), exp(seq(0,2,length.out=20)),
                   exp(seq(-1,1,length.out=20)), exp(seq(-1,1,length.out=20)))
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
set.seed(100)
sp_cell &lt;- selectPenalty(ssy, n = c(500, 1000, 1500, 2000), lambda_all, theta = thetaExact,
    M = 100, sigma = 1.5, model = model, method = "BSL", shrinkage = "glasso",
    parallelSim = TRUE, parallelMain = FALSE)
stopCluster(cl)
registerDoSEQ()
sp_cell
plot(sp_cell)

# Performing BSLasso with a fixed penalty (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultCellBSLasso &lt;- bsl(cell$data, n = 1500, M = 10000, model = model, covRandWalk = cell$cov, 
                         shrinkage = "glasso", penalty = 1.3, parallel = TRUE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultCellBSLasso)
summary(resultCellBSLasso)
plot(resultCellBSLasso, thetaTrue = thetaExact, thin = 20)

# Performing semiBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultCellSemiBSL &lt;- bsl(cell$data, n = 5000, M = 10000, model = model, covRandWalk = cell$cov, 
                         method = "semiBSL", parallel = TRUE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultCellSemiBSL)
summary(resultCellSemiBSL)
plot(resultCellSemiBSL, thetaTrue = thetaExact, thin = 20)

# Plotting the results together for comparison
# plot using the R default plot function
oldpar &lt;- par()
par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultCellBSL, resultCelluBSL, resultCellBSLasso, resultCellSemiBSL),
    which = 1, thetaTrue = thetaExact, thin = 20, label = c("bsl", "ubsl", "bslasso", "semiBSL"),
    col = 1:4, lty = 1:4, lwd = 1)
mtext("Approximate Univariate Posteriors", outer = TRUE, cex = 1.5)
par(mar = oldpar$mar, oma = oldpar$oma)


## End(Not run)

</code></pre>

<hr>
<h2 id='combinePlotsBSL'>Plot the densities of multiple &ldquo;bsl&rdquo; class objects.</h2><span id='topic+combinePlotsBSL'></span>

<h3>Description</h3>

<p>The function <code>combinePlotsBSL</code> can be used to plot multiple
BSL densities together, optionally with the true values for the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinePlotsBSL(
  objectList,
  which = 1L,
  thin = 1,
  burnin = 0,
  thetaTrue = NULL,
  label = NULL,
  legendPosition = c("auto", "right", "bottom")[1],
  legendNcol = NULL,
  col = NULL,
  lty = NULL,
  lwd = NULL,
  cex.lab = 1,
  cex.axis = 1,
  cex.legend = 0.75,
  top = "Approximate Marginal Posteriors",
  options.color = list(),
  options.linetype = list(),
  options.size = list(),
  options.theme = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinePlotsBSL_+3A_objectlist">objectList</code></td>
<td>
<p>A list of &ldquo;bsl&rdquo; class objects.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_which">which</code></td>
<td>
<p>An integer argument indicating which plot function to be
used. The default, <code>1L</code>, uses the plain <code>plot</code> to visualise the
result. <code>2L</code> uses ggplot2 to draw the plot.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_thin">thin</code></td>
<td>
<p>A numeric argument indicating the gap between samples to
be taken when thinning the MCMC draws. The default is <code>1</code>, which means
no thinning is used.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_burnin">burnin</code></td>
<td>
<p>the number of MCMC burn-in steps to be taken.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_thetatrue">thetaTrue</code></td>
<td>
<p>A set of true parameter values to be included on the plots
as a reference line. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_label">label</code></td>
<td>
<p>A string vector indicating the labels to be shown in
the plot legend. The default is <code>NULL</code>, which uses the names from
<code>objectList</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_legendposition">legendPosition</code></td>
<td>
<p>One of the three string arguments, &ldquo;auto&rdquo;, &ldquo;right&rdquo;
or &ldquo;bottom&rdquo;, indicating the legend position. The default is &ldquo;auto&rdquo;,
which automatically choose from &ldquo;right&rdquo; and &ldquo;bottom&rdquo;. Only used when
<code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_legendncol">legendNcol</code></td>
<td>
<p>An integer argument indicating the number of columns of
the legend. The default, <code>NULL</code>, put all legends in the same row or
column depending on <code>legendPosition</code>. Only used when <code>which</code> is
<code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_col">col</code></td>
<td>
<p>A vector argument containing the plotting color for
each density curve. Each element of the vector will be passed into
<code>lines</code>. Only used when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_lty">lty</code></td>
<td>
<p>A vector argument containing the line type for each
density curve. Each element of the vector will be passed into <code>lines</code>.
Only used when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_lwd">lwd</code></td>
<td>
<p>A vector argument containing the line width for each
density curve. Each element of the vector will be passed into <code>lines</code>.
Only used when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels
relative to the current setting of cex. To be passed into <code>plot</code>. Only
used when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation
relative to the current setting of cex. To be passed into <code>plot</code>. Only
used when <code>which</code> is <code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The magnification to be used for legend annotation
relative to the current setting of cex. Only used when <code>which</code> is
<code>1L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_top">top</code></td>
<td>
<p>A string argument of the combined plot title. Only used
when <code>which</code> is <code>2L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_options.color">options.color</code></td>
<td>
<p>A list of additional arguments to pass into function
<code>ggplot2::scale_color_manual</code>. Only used when <code>which</code> is
<code>2L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_options.linetype">options.linetype</code></td>
<td>
<p>A list of additional arguments to pass into function
<code>ggplot2::scale_linetype_manual</code>. Only used when <code>which</code> is
<code>2L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_options.size">options.size</code></td>
<td>
<p>A list of additional arguments to pass into function
<code>ggplot2::scale_size_manual</code>. Only used when <code>which</code> is
<code>2L</code>.</p>
</td></tr>
<tr><td><code id="combinePlotsBSL_+3A_options.theme">options.theme</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>theme</code> function. Only use when <code>which</code> is <code>2L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for the plots produced.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ma2">ma2</a></code>, <code><a href="#topic+cell">cell</a></code>, <code><a href="#topic+mgnk">mgnk</a></code> and
<code><a href="#topic+toad">toad</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
toy_sim &lt;- function(n, theta) matrix(rnorm(2*n, theta), nrow = n)
toy_sum &lt;- ma2_sum

model &lt;- newModel(fnSimVec = toy_sim, fnSum = toy_sum, sumArgs = list(epsilon = 2), theta0 = 0)

result1 &lt;- bsl(y = 1:2, n = 100, M = 5e3, model = model, covRandWalk = matrix(1),
               method = "BSL", plotOnTheFly = TRUE)
result2 &lt;- bsl(y = 1:2, n = 100, M = 5e3, model = model, covRandWalk = matrix(1),
               method = "uBSL", plotOnTheFly = TRUE)
result3 &lt;- bsl(y = 1:2, n = 100, M = 5e3, model = model, covRandWalk = matrix(1),
               method = "semiBSL", plotOnTheFly = TRUE)
combinePlotsBSL(list(result1, result2, result3), label = c("BSL","uBSL","semiBSL"), thin = 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='cor2cov'>Convert a correlation matrix to a covariance matrix</h2><span id='topic+cor2cov'></span>

<h3>Description</h3>

<p>This function converts a correlation matrix to a covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2cov(corr, std)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2cov_+3A_corr">corr</code></td>
<td>
<p>The correlation matrix to be converted. This must be symmetric.</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_std">std</code></td>
<td>
<p>A vector that contains the standard deviations of the variables in the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix.
</p>

<hr>
<h2 id='estimateLoglike'>Estimate the synthetic likelihood</h2><span id='topic+estimateLoglike'></span>

<h3>Description</h3>

<p>This function computes the estimated synthetic (log) likelihood
using one of the four methods (&ldquo;BSL&rdquo;, &ldquo;uBSL&rdquo;, &ldquo;semiBSL&rdquo; and
&ldquo;BSLmisspec&rdquo;). Please find the links below in the see also section for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateLoglike(
  ssy,
  ssx,
  method = c("BSL", "uBSL", "semiBSL", "BSLmisspec"),
  log = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateLoglike_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="estimateLoglike_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="estimateLoglike_+3A_method">method</code></td>
<td>
<p>A string argument indicating the method to be used. The
default, &ldquo;BSL&rdquo;, runs standard BSL. &ldquo;uBSL&rdquo; uses the unbiased estimator
of a normal density of Ghurye and Olkin (1969). &ldquo;semiBSL&rdquo;
runs the semi-parametric BSL algorithm and is more robust to non-normal
summary statistics. &ldquo;BSLmisspec&rdquo; estimates the Gaussian synthetic
likelihood whilst acknowledging that there may be incompatibility between
the model and the observed summary statistic (Frazier and Drovandi 2021).</p>
</td></tr>
<tr><td><code id="estimateLoglike_+3A_log">log</code></td>
<td>
<p>A logical argument indicating if the log of likelihood is
given as the result. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimateLoglike_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument indicating whether an error message
should be printed if the function fails to compute a likelihood. The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimateLoglike_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.
</p>

<ul>
<li> <p><code>shrinkage</code> Available for methods &ldquo;BSL&rdquo; and &ldquo;semiBSL&rdquo;. A
string argument indicating which shrinkage method to be used. The default
is <code>NULL</code>, which means no shrinkage is used. Shrinkage estimation is
only available for methods &ldquo;BSL&rdquo; and &ldquo;semiBSL&rdquo;. Current options are
&ldquo;glasso&rdquo; for the graphical lasso method of
Friedman et al. (2008) and &ldquo;Warton&rdquo; for the ridge
regularisation method of Warton (2008).
</p>
</li>
<li> <p><code>penalty</code> Available for methods &ldquo;BSL&rdquo; and &ldquo;semiBSL&rdquo;. The
penalty value to be used for the specified shrinkage method. Must be
between zero and one if the shrinkage method is &ldquo;Warton&rdquo;.
</p>
</li>
<li> <p><code>standardise</code> Available for method &ldquo;BSL&rdquo;. A logical argument
that determines whether to standardise the summary statistics before
applying the graphical lasso. This is only valid if method is &ldquo;BSL&rdquo;,
shrinkage is &ldquo;glasso&rdquo; and penalty is not <code>NULL</code>. The diagonal
elements will not be penalised if the shrinkage method is &ldquo;glasso&rdquo;. The
default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>GRC</code> Available for method &ldquo;BSL&rdquo;. A logical argument
indicating whether the Gaussian rank correlation matrix
(Boudt et al. 2012) should be used to estimate the covariance
matrix in &ldquo;BSL&rdquo; method. The default is <code>FALSE</code>, which uses the
sample covariance by default.
</p>
</li>
<li> <p><code>whitening</code> Available for method &ldquo;BSL&rdquo;. This argument determines
whether Whitening transformation should be used in &ldquo;BSL&rdquo; method with
Warton's shrinkage. Whitening transformation helps decorrelate the summary
statistics, thus encourages sparsity of the synthetic likelihood covariance
matrix. This might allow heavier shrinkage to be applied without losing
much accuracy, hence allowing the number of simulations to be reduced. By
default, <code>NULL</code> represents no Whitening transformation. Otherwise this
is enabled if a Whitening matrix is provided. See
<code><a href="#topic+estimateWhiteningMatrix">estimateWhiteningMatrix</a></code> for the function to estimate the
Whitening matrix.
</p>
</li>
<li> <p><code>ssyTilde</code> Available for method &ldquo;BSL&rdquo;. The whitened observed
summary statisic. If this is not <code>NULL</code>, it will be used to save
computation effort. Only used if Whitening is enabled.
</p>
</li>
<li> <p><code>kernel</code> Available for method &ldquo;semiBSL&rdquo;.  A string argument
indicating the smoothing kernel to pass into <code>density</code> for estimating
the marginal distribution of each summary statistic. Only &ldquo;gaussian&quot; and
&ldquo;epanechnikov&quot; are available. The default is &ldquo;gaussian&quot;.
</p>
</li>
<li> <p><code>type</code> Available for method &ldquo;BSLmisspec&rdquo;.  A string argument
indicating which method is used to account for and detect potential
incompatibility. The two options are &quot;mean&quot; and &quot;variance&quot;.
</p>
</li>
<li> <p><code>gamma</code> Available for method &ldquo;BSLmisspec&rdquo;. The additional
latent parameter to account for possible incompatability between the model
and observed summary statistic. In &ldquo;BSLmisspec&rdquo; method, this is updated
with a slice sampler (Neal 2003).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated synthetic (log) likelihood value.
</p>


<h3>References</h3>

<p>Boudt K, Cornelissen J, Croux C (2012).
&ldquo;The Gaussian Rank Correlation Estimator: Robustness Properties.&rdquo;
<em>Statistics and Computing</em>, <b>22</b>(2), 471&ndash;483.
doi: <a href="https://doi.org/10.1007/s11222-011-9237-0">10.1007/s11222-011-9237-0</a>.<br /><br /> Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Ghurye SG, Olkin I (1969).
&ldquo;Unbiased Estimation of Some Multivariate Probability Densities and Related Functions.&rdquo;
<em>Ann. Math. Statist.</em>, <b>40</b>(4), 1261&ndash;1271.<br /><br /> Neal RM (2003).
&ldquo;Slice sampling.&rdquo;
<em>The Annals of Statistics</em>, <b>31</b>(3), 705&ndash;767.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code>,
<code><a href="#topic+gaussianSynLikeGhuryeOlkin">gaussianSynLikeGhuryeOlkin</a></code>,
<code><a href="#topic+semiparaKernelEstimate">semiparaKernelEstimate</a></code> and <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ma2)
ssy &lt;- ma2_sum(ma2$data)
m &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
                  theta0 = ma2$start)
ssx &lt;- simulation(m, n = 300, theta = c(0.6, 0.2), seed = 10)$ssx
estimateLoglike(ssy, ssx, method = "BSL")
estimateLoglike(ssy, ssx, method = "uBSL")
estimateLoglike(ssy, ssx, method = "semiBSL")
estimateLoglike(ssy, ssx, method = "BSLmisspec", type = "mean", gamma = rep(0.1, 50))

</code></pre>

<hr>
<h2 id='estimateWhiteningMatrix'>Estimate the Whitening matrix to be used in the &ldquo;wBSL&rdquo; method of
Priddle et al. (2021)</h2><span id='topic+estimateWhiteningMatrix'></span>

<h3>Description</h3>

<p>This function estimates the Whitening matrix to be used in BSL
with Warton's shrinkage and Whitening (&ldquo;wBSL&rdquo; method of
Priddle et al. (2021)). The Whitening transformation and
decorrelation methods are detailed in Kessy et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateWhiteningMatrix(
  n,
  model,
  method = c("PCA", "ZCA", "Cholesky", "ZCA-cor", "PCA-cor"),
  thetaPoint = NULL,
  parallel = FALSE,
  parallelArgs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateWhiteningMatrix_+3A_n">n</code></td>
<td>
<p>The number of model simulations to estimate the Whitening matrix.</p>
</td></tr>
<tr><td><code id="estimateWhiteningMatrix_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; object generated with function
<code>newModel</code>. See <code><a href="#topic+newModel">newModel</a></code>.</p>
</td></tr>
<tr><td><code id="estimateWhiteningMatrix_+3A_method">method</code></td>
<td>
<p>The type of Whitening method to be used. The default is
&ldquo;PCA&rdquo;.</p>
</td></tr>
<tr><td><code id="estimateWhiteningMatrix_+3A_thetapoint">thetaPoint</code></td>
<td>
<p>A point estimate of the parameter value with non-negligible
posterior support.</p>
</td></tr>
<tr><td><code id="estimateWhiteningMatrix_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether parallel computing should
be used for simulation and summary statistic evaluation. The default is
<code>FALSE</code>. When model simulation is fast, it may be preferable to
perform serial or vectorised computations to avoid significant
communication overhead between workers. Parallel computation can only be
used if not using a vectorised simulation function, see <code><a href="#topic+MODEL">MODEL</a></code>
for options of vectorised simulation function.</p>
</td></tr>
<tr><td><code id="estimateWhiteningMatrix_+3A_parallelargs">parallelArgs</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>foreach</code> function. Only used when parallel computing is enabled,
default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated Whitening matrix.
</p>


<h3>References</h3>

<p>Kessy A, Lewin A, Strimmer K (2018).
&ldquo;Optimal Whitening and Decorrelation.&rdquo;
<em>The American Statistician</em>, <b>72</b>(4), 309&ndash;314.
doi: <a href="https://doi.org/10.1080/00031305.2016.1277159">10.1080/00031305.2016.1277159</a>.<br /><br /> Priddle JW, Sisson SA, Frazier DT, Turner I, Drovandi C (2021).
&ldquo;Efficient Bayesian Synthetic Likelihood with Whitening Transformations.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1909.04857">https://arxiv.org/abs/1909.04857</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(ma2)
model &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args, theta0 = ma2$start)
W &lt;- estimateWhiteningMatrix(20000, model, method = "PCA", thetaPoint = c(0.6, 0.2))

## End(Not run)

</code></pre>

<hr>
<h2 id='gaussianRankCorr'>Gaussian rank correlation</h2><span id='topic+gaussianRankCorr'></span>

<h3>Description</h3>

<p>This function computes the Gaussian rank correlation of
Boudt et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianRankCorr(x, vec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianRankCorr_+3A_x">x</code></td>
<td>
<p>A numeric matrix representing data where the number of rows
is the number of independent data points and the number of columns is the
number of variables in the dataset.</p>
</td></tr>
<tr><td><code id="gaussianRankCorr_+3A_vec">vec</code></td>
<td>
<p>A logical argument indicating if the vector of correlations
should be returned instead of a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gaussian rank correlation matrix (default) or a vector of
pair correlations.
</p>


<h3>References</h3>

<p>Boudt K, Cornelissen J, Croux C (2012).
&ldquo;The Gaussian Rank Correlation Estimator: Robustness Properties.&rdquo;
<em>Statistics and Computing</em>, <b>22</b>(2), 471&ndash;483.
doi: <a href="https://doi.org/10.1007/s11222-011-9237-0">10.1007/s11222-011-9237-0</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor2cov">cor2cov</a></code> for conversion from correlation matrix
to covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ma2)
model &lt;- newModel(fnSimVec = ma2_sim_vec, fnSum = ma2_sum, simArgs = list(TT = 10),
                  theta0 = ma2$start, fnLogPrior = ma2_prior)
set.seed(100)

# generate 1000 simualtions from the ma2 model
x &lt;- simulation(model, n = 1000, theta = c(0.6, 0.2))$x

corr1 &lt;- cor(x) # traditional correlation matrix
corr2 &lt;- gaussianRankCorr(x) # Gaussian rank correlation matrix
oldpar &lt;- par()
par(mfrow = c(1, 2))
image(corr1, main = 'traditional correlation matrix')
image(corr2, main = 'Gaussian rank correlation matrix')
par(mfrow = oldpar$mfrow)

std &lt;- apply(x, MARGIN = 2, FUN = sd) # standard deviations
cor2cov(gaussianRankCorr(x), std) # convert to covariance matrix

</code></pre>

<hr>
<h2 id='gaussianSynLike'>Estimate the Gaussian synthetic (log) likelihood</h2><span id='topic+gaussianSynLike'></span>

<h3>Description</h3>

<p>This function estimates the Gaussian synthetic log-likelihood
(see Wood 2010 and Price et al. 2018). Several extensions are
provided in this function: <code>shrinkage</code> enables shrinkage estimation of
the covariance matrix and is helpful to bring down the number of model
simulations (see An et al. (2019) for an example of BSL
with glasso (Friedman et al. 2008) shrinkage estimation);
<code>GRC</code> uses Gaussian rank correlation (Boudt et al. 2012) to
find a more robust correlation matrix; <code>whitening</code>
(Kessy et al. 2018) could further reduce the number of model
simulations upon Warton's shrinkage (Warton 2008) by
decorrelating the summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianSynLike(
  ssy,
  ssx,
  shrinkage = NULL,
  penalty = NULL,
  standardise = FALSE,
  GRC = FALSE,
  whitening = NULL,
  ssyTilde = NULL,
  log = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianSynLike_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_shrinkage">shrinkage</code></td>
<td>
<p>A string argument indicating which shrinkage method to
be used. The default is <code>NULL</code>, which means no shrinkage is used.
Shrinkage estimation is only available for methods &ldquo;BSL&rdquo; and &ldquo;semiBSL&rdquo;.
Current options are &ldquo;glasso&rdquo; for the graphical lasso method of
Friedman et al. (2008) and &ldquo;Warton&rdquo; for the ridge
regularisation method of Warton (2008).</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_penalty">penalty</code></td>
<td>
<p>The penalty value to be used for the specified shrinkage
method. Must be between zero and one if the shrinkage method is &ldquo;Warton&rdquo;.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_standardise">standardise</code></td>
<td>
<p>A logical argument that determines whether to standardise
the summary statistics before applying the graphical lasso. This is only
valid if method is &ldquo;BSL&rdquo;, shrinkage is &ldquo;glasso&rdquo; and penalty is not
<code>NULL</code>. The diagonal elements will not be penalised if the shrinkage
method is &ldquo;glasso&rdquo;. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_grc">GRC</code></td>
<td>
<p>A logical argument indicating whether the Gaussian rank
correlation matrix (Boudt et al. 2012) should be used to estimate
the covariance matrix in &ldquo;BSL&rdquo; method. The default is <code>FALSE</code>, which
uses the sample covariance by default.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_whitening">whitening</code></td>
<td>
<p>This argument determines whether Whitening transformation
should be used in &ldquo;BSL&rdquo; method with Warton's shrinkage. Whitening
transformation helps decorrelate the summary statistics, thus encouraging
sparsity of the synthetic likelihood covariance matrix. This might allow
heavier shrinkage to be applied without losing much accuracy, hence
allowing the number of simulations to be reduced. By default, <code>NULL</code>
represents no Whitening transformation. Otherwise this is enabled if a
Whitening matrix is provided. See <code><a href="#topic+estimateWhiteningMatrix">estimateWhiteningMatrix</a></code> for
the function to estimate the Whitening matrix.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_ssytilde">ssyTilde</code></td>
<td>
<p>The whitened observed summary statisic. If this is not
<code>NULL</code>, it will be used to save computation effort. Only used if
Whitening is enabled.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_log">log</code></td>
<td>
<p>A logical argument indicating if the log of likelihood is
given as the result. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gaussianSynLike_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument indicating whether an error message
should be printed if the function fails to compute a likelihood. The
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated synthetic (log) likelihood value.
</p>


<h3>References</h3>

<p>An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Boudt K, Cornelissen J, Croux C (2012).
&ldquo;The Gaussian Rank Correlation Estimator: Robustness Properties.&rdquo;
<em>Statistics and Computing</em>, <b>22</b>(2), 471&ndash;483.
doi: <a href="https://doi.org/10.1007/s11222-011-9237-0">10.1007/s11222-011-9237-0</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Kessy A, Lewin A, Strimmer K (2018).
&ldquo;Optimal Whitening and Decorrelation.&rdquo;
<em>The American Statistician</em>, <b>72</b>(4), 309&ndash;314.
doi: <a href="https://doi.org/10.1080/00031305.2016.1277159">10.1080/00031305.2016.1277159</a>.<br /><br /> Price LF, Drovandi CC, Lee A, Nott DJ (2018).
&ldquo;Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 1&ndash;11.
doi: <a href="https://doi.org/10.1080/10618600.2017.1302882">10.1080/10618600.2017.1302882</a>.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.<br /><br /> Wood SN (2010).
&ldquo;Statistical Inference for Noisy Nonlinear Ecological Dynamic Systems.&rdquo;
<em>Nature</em>, <b>466</b>, 1102&ndash;1107.
doi: <a href="https://doi.org/10.1038/nature09319">10.1038/nature09319</a>.
</p>


<h3>See Also</h3>

<p>Other available synthetic likelihood estimators:
<code><a href="#topic+gaussianSynLikeGhuryeOlkin">gaussianSynLikeGhuryeOlkin</a></code> for the unbiased synthetic
likelihood estimator, <code><a href="#topic+semiparaKernelEstimate">semiparaKernelEstimate</a></code> for the
semi-parametric likelihood estimator, <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> for the
Gaussian synthetic likelihood estimator for model misspecification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ma2)
ssy &lt;- ma2_sum(ma2$data)
m &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
              theta0 = ma2$start)
ssx &lt;- simulation(m, n = 300, theta = c(0.6, 0.2), seed = 10)$ssx

# the standard Gaussian synthetic likelihood (the likelihood estimator used in BSL)
gaussianSynLike(ssy, ssx)
# the Gaussian synthetic likelihood with glasso shrinkage estimation
# (the likelihood estimator used in BSLasso)
gaussianSynLike(ssy, ssx, shrinkage = 'glasso', penalty = 0.1)
# the Gaussian synthetic likelihood with Warton's shrinkage estimation
gaussianSynLike(ssy, ssx, shrinkage = 'Warton', penalty = 0.9)
# the Gaussian synthetic likelihood with Warton's shrinkage estimation and Whitening transformation
W &lt;- estimateWhiteningMatrix(20000, m)
gaussianSynLike(ssy, ssx, shrinkage = 'Warton', penalty = 0.9, whitening = W)

</code></pre>

<hr>
<h2 id='gaussianSynLikeGhuryeOlkin'>Estimate the Gaussian synthetic (log) likelihood with an unbiased estimator</h2><span id='topic+gaussianSynLikeGhuryeOlkin'></span>

<h3>Description</h3>

<p>This function computes an unbiased, nonnegative estimate of a
normal density function from simulations assumed to be drawn from it. See
Price et al. (2018) and
Ghurye and Olkin (1969).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianSynLikeGhuryeOlkin(ssy, ssx, log = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianSynLikeGhuryeOlkin_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="gaussianSynLikeGhuryeOlkin_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="gaussianSynLikeGhuryeOlkin_+3A_log">log</code></td>
<td>
<p>A logical argument indicating if the log of likelihood is
given as the result. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gaussianSynLikeGhuryeOlkin_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument indicating whether an error message
should be printed if the function fails to compute a likelihood. The
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated synthetic (log) likelihood value.
</p>


<h3>References</h3>

<p>Ghurye SG, Olkin I (1969).
&ldquo;Unbiased Estimation of Some Multivariate Probability Densities and Related Functions.&rdquo;
<em>Ann. Math. Statist.</em>, <b>40</b>(4), 1261&ndash;1271.<br /><br /> Price LF, Drovandi CC, Lee A, Nott DJ (2018).
&ldquo;Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>27</b>, 1&ndash;11.
doi: <a href="https://doi.org/10.1080/10618600.2017.1302882">10.1080/10618600.2017.1302882</a>.
</p>


<h3>See Also</h3>

<p>Other available synthetic likelihood estimators:
<code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> for the standard synthetic likelihood
estimator, <code><a href="#topic+semiparaKernelEstimate">semiparaKernelEstimate</a></code> for the semi-parametric
likelihood estimator, <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> for the Gaussian
synthetic likelihood estimator for model misspecification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ma2)
ssy &lt;- ma2_sum(ma2$data)
m &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
              theta0 = ma2$start)
ssx &lt;- simulation(m, n = 300, theta = c(0.6, 0.2), seed = 10)$ssx

# unbiased estimate of the Gaussian synthetic likelihood
# (the likelihood estimator used in uBSL)
gaussianSynLikeGhuryeOlkin(ssy, ssx)

</code></pre>

<hr>
<h2 id='getGamma'>Obtain the gamma samples (the latent parameters for BSLmisspec method) from a
&quot;BSL&quot; object</h2><span id='topic+getGamma'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+BSLclass">BSLclass</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGamma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGamma_+3A_object">object</code></td>
<td>
<p>A &ldquo;BSL&rdquo; class object.</p>
</td></tr>
<tr><td><code id="getGamma_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of gamma samples (the latent parameters for BSLmisspec
method), after removing burn-in and thinning.
</p>

<hr>
<h2 id='getLoglike'>Obtain the log-likelihoods from a &quot;BSL&quot; object</h2><span id='topic+getLoglike'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+BSLclass">BSLclass</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLoglike(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLoglike_+3A_object">object</code></td>
<td>
<p>A &ldquo;BSL&rdquo; class object.</p>
</td></tr>
<tr><td><code id="getLoglike_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of log likelihood evaluations, after removing burn-in and thinning.
</p>

<hr>
<h2 id='getPenalty'>Obtain the selected penalty values from a &quot;PENALTY&quot; object</h2><span id='topic+getPenalty'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+PENALTYclass">PENALTYclass</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPenalty(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPenalty_+3A_object">object</code></td>
<td>
<p>A &ldquo;PENALTY&rdquo; class object.</p>
</td></tr>
<tr><td><code id="getPenalty_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selecty penalty values.
</p>

<hr>
<h2 id='getTheta'>Obtain the samples from a &quot;BSL&quot; object</h2><span id='topic+getTheta'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+BSLclass">BSLclass</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTheta(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTheta_+3A_object">object</code></td>
<td>
<p>A &ldquo;BSL&rdquo; class object.</p>
</td></tr>
<tr><td><code id="getTheta_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of samples, after removing burn-in and thinning.
</p>

<hr>
<h2 id='ma2'>An MA(2) model</h2><span id='topic+ma2'></span><span id='topic+ma2_sim'></span><span id='topic+ma2_sim_vec'></span><span id='topic+ma2_sum'></span><span id='topic+ma2_prior'></span>

<h3>Description</h3>

<p>In this example we wish to estimate the parameters of a simple
MA(2) time series model. We provide the data and tuning parameters required
to reproduce the results in An et al. (2019).
The journal article An et al. (2022) provides a full
description of how to use this package for the toad example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ma2)

ma2_sim(theta, TT)

ma2_sim_vec(n, theta, TT)

ma2_sum(x, epsilon = 0, delta = 1)

ma2_prior(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma2_+3A_theta">theta</code></td>
<td>
<p>A vector of proposed model parameters,
<code class="reqn">\theta_1</code> and
<code class="reqn">\theta_2</code>.</p>
</td></tr>
<tr><td><code id="ma2_+3A_tt">TT</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="ma2_+3A_n">n</code></td>
<td>
<p>The number of simulations to run with the vectorised
simulation function.</p>
</td></tr>
<tr><td><code id="ma2_+3A_x">x</code></td>
<td>
<p>Observed or simulated data in the format of a vector of length
<code class="reqn">TT</code>.</p>
</td></tr>
<tr><td><code id="ma2_+3A_epsilon">epsilon</code></td>
<td>
<p>The skewness parameter in the sinh-arcsinh transformation.</p>
</td></tr>
<tr><td><code id="ma2_+3A_delta">delta</code></td>
<td>
<p>The kurtosis parameter in the sinh-arcsinh transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This example is based on estimating the parameters of a basic MA(2)
time series model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_t = z_t + \theta_1 z_{t-1} + \theta_2 z_{t-2},</code>
</p>

<p>where <code class="reqn">t=1,\ldots,TT</code> and <code class="reqn">z_t \sim N(0,1)</code>
for <code class="reqn">t=-1,0,\ldots,TT</code>. A uniform
prior is used for this example, subject to the restrictions that
<code class="reqn">-2&lt;\theta_1&lt;2</code>,
<code class="reqn">\theta_1+\theta_2&gt;-1</code>
and
<code class="reqn">\theta_1-\theta_2&lt;1</code>
so that invertibility of the time series is satisfied. The summary
statistics are simply the full data.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ma2_sim</code>: Simulates an MA(2) time series.
</p>
</li>
<li> <p><code>ma2_sim_vec</code>: Simulates n MA(2) time series with a vectorised simulation
function.
</p>
</li>
<li> <p><code>ma2_sum</code>: Returns the summary statistics for a given data set. The
skewness and kurtosis of the summary statistics can be controlled via the
<code class="reqn">\epsilon</code> and
<code class="reqn">\delta</code> parameters. This is the
sinh-arcsinnh transformation of Jones and Pewsey (2009). By default,
the summary statistics function simply returns the raw data. Otherwise, the
transformation is introduced to motivate the &ldquo;semiBSL&rdquo; method.
</p>
</li>
<li> <p><code>ma2_prior</code>: Evaluates the (unnormalised) log prior, which is uniform
subject to several restrictions related to invertibility of the time
series.
</p>
</li></ul>


<h3>A simulated dataset</h3>

<p>An example &ldquo;observed&rdquo; dataset and the tuning parameters relevant to that
example can be obtained using <code>data(ma2)</code>. This &ldquo;observed&rdquo; data is a
simulated dataset with
<code class="reqn">\theta_1 = 0.6</code>,
<code class="reqn">\theta_2=0.2</code> and
<code class="reqn">TT=50</code>. Further information about this model and the specific choices
of tuning parameters used in BSL and BSLasso can be found in An et al.
(2019).
</p>

<ul>
<li> <p><code>data</code>: A time series dataset, in the form of a vector of length
<code class="reqn">TT</code>
</p>
</li>
<li> <p><code>sim_args</code>: A list containing <code class="reqn">TT=50</code>
</p>
</li>
<li> <p><code>start</code>: A vector of suitable initial values of the parameters
for MCMC
</p>
</li>
<li> <p><code>cov</code>: The covariance matrix of a multivariate normal random
walk proposal distribution used in the MCMC, in the form of a 2
<code class="reqn">\times</code> 2 matrix </p>
</li></ul>



<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, South LF, Drovandi CC (2022).
&ldquo;BSL: An R Package for Efficient Parameter Estimation for Simulation-Based Models via Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Statistical Software</em>, <b>101</b>(11), 1&ndash;33.
doi: <a href="https://doi.org/10.18637/jss.v101.i11">10.18637/jss.v101.i11</a>.<br /><br /> An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Jones MC, Pewsey A (2009).
&ldquo;Sinh-arcsinh distributions.&rdquo;
<em>Biometrika</em>, <b>96</b>(4), 761&ndash;780.
ISSN 0006-3444.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the data for this example and set up the model object
data(ma2)
model &lt;- newModel(fnSimVec = ma2_sim_vec, fnSum = ma2_sum, simArgs = ma2$sim_args,
                  theta0 = ma2$start, fnLogPrior = ma2_prior)
thetaExact &lt;- c(0.6, 0.2)

# reduce the number of iterations M if desired for all methods below
# Method 1: standard BSL
resultMa2BSL &lt;- bsl(y = ma2$data, n = 500, M = 300000, model = model, covRandWalk = ma2$cov,
                    method = "BSL", verbose = 1L)
show(resultMa2BSL)
summary(resultMa2BSL)
plot(resultMa2BSL, thetaTrue = thetaExact, thin = 20)

# Method 2: unbiased BSL
resultMa2uBSL &lt;- bsl(y = ma2$data, n = 500, M = 300000, model = model, covRandWalk=ma2$cov,
                     method = "uBSL", verbose = 1L)
show(resultMa2uBSL)
summary(resultMa2uBSL)
plot(resultMa2uBSL, thetaTrue = thetaExact, thin = 20)

# Method 3: BSLasso (BSL with glasso shrinkage estimation)
# tune the penalty parameter fisrt
ssy &lt;- ma2_sum(ma2$data)
lambdaAll &lt;- list(exp(seq(-5.5,-1.5,length.out=20)))
set.seed(100)
penaltyGlasso &lt;- selectPenalty(ssy = ssy, n = 300, lambdaAll, theta = thetaExact,
                        M = 100, sigma = 1.5, model = model, method = "BSL", shrinkage = "glasso")
penaltyGlasso
plot(penaltyGlasso)

resultMa2BSLasso &lt;- bsl(y = ma2$data, n = 300, M = 250000, model = model, covRandWalk=ma2$cov,
                        method = "BSL", shrinkage = "glasso", penalty = 0.027, verbose = 1L)
show(resultMa2BSLasso)
summary(resultMa2BSLasso)
plot(resultMa2BSLasso, thetaTrue = thetaExact, thin = 20)

# Method 4: BSL with Warton's shrinkage and Whitening
# estimate the Whtieing matrix and tune the penalty parameter first
W &lt;- estimateWhiteningMatrix(20000, model, method = "PCA", thetaPoint = ma2$start)
gammaAll &lt;- list(seq(0.3, 0.8, 0.02))
set.seed(100)
penaltyWarton &lt;- selectPenalty(ssy = ssy, n = 300, gammaAll, theta = thetaExact,
                        M = 100, sigma = 1.2, model = model, method = "BSL", shrinkage = "Warton",
                        whitening = W)
penaltyWarton
plot(penaltyWarton, logscale = FALSE)

resultMa2Whitening &lt;- bsl(y = ma2$data, n = 300, M = 250000, model = model, covRandWalk=ma2$cov,
                        method = "BSL", shrinkage = "Warton", whitening = W,
                        penalty = 0.52, verbose = 1L)
show(resultMa2Whitening)
summary(resultMa2Whitening)
plot(resultMa2Whitening, thetaTrue = thetaExact, thin = 20)

# Method 5: semiBSL, the summary statistics function is different from previous methods
model2 &lt;- newModel(fnSimVec = ma2_sim_vec, fnSum = ma2_sum, simArgs = ma2$sim_args,
                  sumArgs = list(epsilon = 2), theta0 = ma2$start, fnLogPrior = ma2_prior)
sim &lt;- simulation(model, n = 1e4, theta = ma2$start, seed = 1) # run a short simulation
plot(density(sim$ssx[, 1])) # the first marginal summary statistic is right-skewed
resultMa2SemiBSL &lt;- bsl(y = ma2$data, n = 500, M = 200000, model = model2, covRandWalk=ma2$cov,
                        method = "semiBSL", verbose = 1L)
show(resultMa2SemiBSL)
summary(resultMa2SemiBSL)
plot(resultMa2SemiBSL, thetaTrue = thetaExact, thin = 20)

# Method 6: BSL with consideration of model misspecification (mean adjustment)
resultMa2Mean &lt;- bsl(y = ma2$data, n = 500, M = 200000, model = model, covRandWalk=ma2$cov,
                        method = "BSLmisspec", misspecType = "mean", verbose = 1L)
show(resultMa2Mean)
summary(resultMa2Mean)
plot(resultMa2Mean, thetaTrue = thetaExact, thin = 20)

# Method 7: BSL with consideration of model misspecification (variance inflation)
resultMa2Variance &lt;- bsl(y = ma2$data, n = 500, M = 200000, model = model, covRandWalk=ma2$cov,
                     method = "BSLmisspec", misspecType = "variance", verbose = 1L)
show(resultMa2Variance)
summary(resultMa2Variance)
plot(resultMa2Variance, thetaTrue = thetaExact, thin = 20)

# Plotting the results together for comparison
# plot using the R default plot function
oldpar &lt;- par()
par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMa2BSL, resultMa2uBSL, resultMa2BSLasso, resultMa2SemiBSL), which = 1,
                thetaTrue = thetaExact, thin = 20, label = c("bsl", "uBSL", "bslasso", "semiBSL"),
                col = c("black", "red", "blue", "green"), lty = 1:4, lwd = 1)
mtext("Approximate Univariate Posteriors", outer = TRUE, cex = 1.5)

# plot using the ggplot2 package
combinePlotsBSL(list(resultMa2BSL, resultMa2uBSL, resultMa2BSLasso, resultMa2SemiBSL), which = 2,
    thetaTrue = thetaExact, thin = 20, label = c("bsl", "ubsl", "bslasso", "semiBSL"),
    options.color = list(values=c("black", "red", "blue", "green")),
    options.linetype = list(values = 1:4), options.size = list(values = rep(1, 4)),
    options.theme = list(plot.margin = grid::unit(rep(0.03,4), "npc"),
        axis.title = ggplot2::element_text(size=12), axis.text = ggplot2::element_text(size = 8),
        legend.text = ggplot2::element_text(size = 12)))
par(mar = oldpar$mar, oma = oldpar$oma)

## End(Not run)

</code></pre>

<hr>
<h2 id='mgnk'>The multivariate G&amp;K example</h2><span id='topic+mgnk'></span><span id='topic+mgnk_sim'></span><span id='topic+mgnk_sum'></span>

<h3>Description</h3>

<p>Here we provide the data and tuning parameters required to reproduce
the results from the multivariate G &amp; K (Drovandi and Pettitt 2011) example from An et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mgnk)

mgnk_sim(theta_tilde, TT, J, bound)

mgnk_sum(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgnk_+3A_theta_tilde">theta_tilde</code></td>
<td>
<p>A vector with 15 elements for the proposed model parameters.</p>
</td></tr>
<tr><td><code id="mgnk_+3A_tt">TT</code></td>
<td>
<p>The number of observations in the data.</p>
</td></tr>
<tr><td><code id="mgnk_+3A_j">J</code></td>
<td>
<p>The number of variables in the data.</p>
</td></tr>
<tr><td><code id="mgnk_+3A_bound">bound</code></td>
<td>
<p>A matrix of boundaries for the uniform prior.</p>
</td></tr>
<tr><td><code id="mgnk_+3A_y">y</code></td>
<td>
<p>A <code>TT</code> <code class="reqn">\times</code> <code>J</code> matrix of data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not practical to give a reasonable explanation of this example through R documentation
given the number of equations involved. We refer the reader to the BSLasso paper (An et al. 2019)
at &lt;doi:10.1080/10618600.2018.1537928&gt; for information on the model and summary statistic used in this example.
</p>


<h3>An example dataset</h3>

<p>We use the foreign currency exchange data available from <a href="https://www.rba.gov.au/statistics/historical-data.html">https://www.rba.gov.au/statistics/historical-data.html</a>
as in An et al. (2019).
</p>

<ul>
<li> <p><code>data</code>:  A <code>1651</code> <code class="reqn">\times</code> <code>3</code> matrix of data.
</p>
</li>
<li> <p><code>sim_args</code>: Values of <code>sim_args</code> relevant to this example.
</p>
</li>
<li> <p><code>start</code>: A vector of suitable initial values of the parameters for MCMC.
</p>
</li>
<li> <p><code>cov</code>: The covariance matrix of a multivariate normal random walk proposal distribution used in the MCMC, in the form of a 15 by 15 matrix
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Drovandi CC, Pettitt AN (2011).
&ldquo;Likelihood-free Bayesian estimation of multivariate quantile distributions.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>55</b>(9), 2541&ndash;2556.
ISSN 0167-9473, doi: <a href="https://doi.org/10.1016/j.csda.2011.03.019">10.1016/j.csda.2011.03.019</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(doParallel) # You can use a different package to set up the parallel backend
require(MASS)
require(elliplot)

# Loading the data for this example
data(mgnk)
model &lt;- newModel(fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_args, theta0 = mgnk$start,
    thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],
                            a[3],b[3],g[3],k[3],delta[12],delta[13],delta[23]))

# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultMgnkBSL &lt;- bsl(mgnk$data, n = 60, M = 80000, model = model, covRandWalk = mgnk$cov,
    method = "BSL", parallel = FALSE, verbose = 1L, plotOnTheFly = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkBSL)
summary(resultMgnkBSL)
plot(resultMgnkBSL, which = 2, thin = 20)

# Performing uBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultMgnkuBSL &lt;- bsl(mgnk$data, n = 60, M = 80000, model = model, covRandWalk = mgnk$cov,
    method = "uBSL", parallel = FALSE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkuBSL)
summary(resultMgnkuBSL)
plot(resultMgnkuBSL, which = 2, thin = 20)


# Performing tuning for BSLasso
ssy &lt;- mgnk_sum(mgnk$data)
lambda_all &lt;- list(exp(seq(-2.5,0.5,length.out=20)), exp(seq(-2.5,0.5,length.out=20)),
                   exp(seq(-4,-0.5,length.out=20)), exp(seq(-5,-2,length.out=20)))

# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
set.seed(100)
sp_mgnk &lt;- selectPenalty(ssy, n = c(15, 20, 30, 50), lambda = lambda_all, theta = mgnk$start,
    M = 100, sigma = 1.5, model = model, method = "BSL", shrinkage = "glasso", standardise = TRUE,
    parallelSim = TRUE, parallelSimArgs = list(.packages = "MASS", .export = "ninenum"),
    parallelMain = TRUE)
stopCluster(cl)
registerDoSEQ()
sp_mgnk
plot(sp_mgnk)

# Performing BSLasso with a fixed penalty (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultMgnkBSLasso &lt;- bsl(mgnk$data, n = 20, M = 80000, model = model, covRandWalk = mgnk$cov,
    method = "BSL", shrinkage = "glasso", penalty = 0.3, standardise = TRUE, parallel = FALSE,
    verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkBSLasso)
summary(resultMgnkBSLasso)
plot(resultMgnkBSLasso, which = 2, thin = 20)


# Performing semiBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultMgnkSemiBSL &lt;- bsl(mgnk$data, n = 60, M = 80000, model = model, covRandWalk = mgnk$cov,
    method = "semiBSL", parallel = FALSE, verbose = 1L)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkSemiBSL)
summary(resultMgnkSemiBSL)
plot(resultMgnkSemiBSL, which = 2, thin = 20)

# Plotting the results together for comparison
# plot using the R default plot function
oldpar &lt;- par()
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkuBSL, resultMgnkBSLasso, resultMgnkSemiBSL),
                which = 1, thin = 20, label = c("bsl", "ubsl", "bslasso", "semiBSL"),
                col = c("red", "yellow", "blue", "green"), lty = 2:5, lwd = 1)
mtext("Approximate Univariate Posteriors", outer = TRUE, line = 0.75, cex = 1.2)

# plot using the ggplot2 package
combinePlotsBSL(list(resultMgnkBSL, resultMgnkuBSL, resultMgnkBSLasso, resultMgnkSemiBSL),
    which = 2, thin = 20, label=c("bsl","ubsl","bslasso","semiBSL"),
    options.color=list(values=c("red","yellow","blue","green")),
    options.linetype = list(values = 2:5), options.size = list(values = rep(1, 4)),
    options.theme = list(plot.margin = grid::unit(rep(0.03,4),"npc"),
        axis.title = ggplot2::element_text(size=12), axis.text = ggplot2::element_text(size = 8),
        legend.text = ggplot2::element_text(size = 12)))
par(mar = oldpar$mar, oma = oldpar$oma)

## End(Not run)

</code></pre>

<hr>
<h2 id='MODEL-class'>S4 class &ldquo;MODEL&rdquo;</h2><span id='topic+MODEL-class'></span><span id='topic+MODEL'></span><span id='topic+newModel'></span><span id='topic+simulation+2CMODEL-method'></span><span id='topic+summStat+2CANY+2CMODEL-method'></span>

<h3>Description</h3>

<p>The S4 class contains the simulation and summary statistics
function and other necessary arguments for a model to run in the main
<code>bsl</code> function.
</p>
<p><code>newModel</code> is the constructor function for a <code>MODEL</code>
object.
</p>
<p><code>simulation</code> runs a number of simulations and computes the
correponding summary statistics with the provided model.
</p>
<p><code>summStat</code> computes the summary statistics with the given data and model object.
The summary statistics function and relevant arguments are obtained from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newModel(
  fnSim,
  fnSimVec,
  fnSum,
  fnLogPrior,
  simArgs,
  sumArgs,
  theta0,
  thetaNames,
  test = TRUE,
  verbose = TRUE
)

## S4 method for signature 'MODEL'
simulation(
  model,
  n = 1,
  theta = model@theta0,
  summStat = TRUE,
  parallel = FALSE,
  parallelArgs = NULL,
  seed = NULL
)

## S4 method for signature 'ANY,MODEL'
summStat(x, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MODEL-class_+3A_fnsim">fnSim</code></td>
<td>
<p>A function that simulates data for a given parameter
value. The first argument should be the parameters. Other necessary
arguments (optional) can be specified with <code>simArgs</code>.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_fnsimvec">fnSimVec</code></td>
<td>
<p>A vectorised function that simulates a number of
datasets simultaneously for a given parameter value. The first two
arguments should be the number of simulations to run and parameters,
respectively. Other necessary arguments (optional) can be specified with
<code>simArgs</code>. The output must be a list of each simulation result or a
matrix with each row corresponding to a simulation.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_fnsum">fnSum</code></td>
<td>
<p>A function for computing summary statistics of data. The
first argument should be the observed or simulated dataset. Other necessary
arguments (optional) can be specified with <code>sumArgs</code>.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_fnlogprior">fnLogPrior</code></td>
<td>
<p>A function that computes the log of prior density for a
parameter. If this is missing, the prior by default is an improper flat
prior over the real line for each parameter. The function must have a
single input: a vector of parameter values.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_simargs">simArgs</code></td>
<td>
<p>A list of additional arguments to pass into the simulation
function. Only use when the input <code>fnSim</code> requires additional
arguments.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_sumargs">sumArgs</code></td>
<td>
<p>A list of additional arguments to pass into the summary
statistics function. Only use when the input <code>fnSum</code> requires
additional arguments.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_theta0">theta0</code></td>
<td>
<p>Initial guess of the parameter value.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_thetanames">thetaNames</code></td>
<td>
<p>A string vector of parameter names, which must have the
same length as the parameter vector.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_test">test</code></td>
<td>
<p>Logical, whether a short simulation test will be ran
upon initialisation.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to print verbose messages when
initialising a &ldquo;MODEL&rdquo; object.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; class object.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_n">n</code></td>
<td>
<p>The number of simulations to run.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_theta">theta</code></td>
<td>
<p>The parameter value.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_summstat">summStat</code></td>
<td>
<p>Logical indicator whether the correpsonding summary statistics
should be returned or not. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether parallel computing should
be used for simulation and summary statistic evaluation. The default is
<code>FALSE</code>. When model simulation is fast, it may be preferable to
perform serial or vectorised computations to avoid significant
communication overhead between workers. Parallel computation can only be
used if not using a vectorised simulation function, see <code><a href="#topic+MODEL">MODEL</a></code>
for options of vectorised simulation function.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_parallelargs">parallelArgs</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>foreach</code> function. Only used when parallel computing is enabled,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_seed">seed</code></td>
<td>
<p>A seed number to pass to the <code>set.seed</code> function. The
default is <code>NULL</code>, when no seed number is specified. Please note
<code>parallel</code> also affects the result even with the same seed.</p>
</td></tr>
<tr><td><code id="MODEL-class_+3A_x">x</code></td>
<td>
<p>The data to pass to the summary statistics function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of simulation results using the given parameter. <code>x</code>
contains the raw simulated datasets. <code>ssx</code> contains the summary
statistics.
</p>
<p>A vector of the summary statistics.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fnSim</code></dt><dd><p>A function that simulates data for a given parameter value. The
first argument should be the parameters. Other necessary arguments
(optional) can be specified with <code>simArgs</code>.</p>
</dd>
<dt><code>fnSimVec</code></dt><dd><p>A vectorised function that simulates a number of datasets
simultaneously for a given parameter value. If this is not <code>NULL</code>,
vectorised simulation function will be used instead of <code>fnSim</code>. The
first two arguments should be the number of simulations to run and
parameters, respectively. Other necessary arguments (optional) can be
specified with <code>simArgs</code>. The output must be a list of each simulation
result.</p>
</dd>
<dt><code>fnSum</code></dt><dd><p>A function for computing summary statistics of data. The first
argument should be the observed or simulated dataset. Other necessary
arguments (optional) can be specified with <code>sumArgs</code>. The users should
code this function carefully so the output have fixed length and never
contain any <code>Inf</code> value.</p>
</dd>
<dt><code>fnLogPrior</code></dt><dd><p>A function that computes the log of prior density for a
parameter. The default is <code>NULL</code>, which uses an improper flat prior
over the real line for each parameter. The function must have a single
input: a vector of parameter values.</p>
</dd>
<dt><code>simArgs</code></dt><dd><p>A list of additional arguments to pass into the simulation
function. Only use when the input <code>fnSim</code> or <code>fnSimVec</code> requires
additional arguments. The default is <code>NULL</code>.</p>
</dd>
<dt><code>sumArgs</code></dt><dd><p>A list of additional arguments to pass into the summary
statistics function. Only use when the input <code>fnSum</code> requires
additional arguments. The default is <code>NULL</code>.</p>
</dd>
<dt><code>theta0</code></dt><dd><p>Initial guess of the parameter value, which is used as the
starting value for MCMC.</p>
</dd>
<dt><code>thetaNames</code></dt><dd><p>Expression, parameter names.</p>
</dd>
<dt><code>ns</code></dt><dd><p>The number of summary statistics of a single observation. Note this
will be generated automatically, thus is not required for initialisation.</p>
</dd>
<dt><code>test</code></dt><dd><p>Logical, whether a short simulation test will be ran upon
initialisation.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical, whether to print verbose messages when initialising a
&ldquo;MODEL&rdquo; object.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># set up the model for the ma2 example
data(ma2)
m &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
                  theta0 = ma2$start, fnLogPrior = ma2_prior, verbose = FALSE)
validObject(m)

# benchmark the serial and vectorised simulation function (require the rbenchmark package)
m1 &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
            theta0 = ma2$start, fnLogPrior = ma2_prior)
m2 &lt;- newModel(fnSimVec = ma2_sim_vec, fnSum = ma2_sum, simArgs = ma2$sim_args,
            theta0 = ma2$start, fnLogPrior = ma2_prior)
require("rbenchmark")

## Not run: 
benchmark(serial  = simulation(m1, n = 1000, theta = c(0.6, 0.2)),
          vectorised  = simulation(m2, n = 1000, theta = c(0.6, 0.2)))

## End(Not run)

</code></pre>

<hr>
<h2 id='myMiniProgressBar'>Progress Bar</h2><span id='topic+myMiniProgressBar'></span>

<h3>Description</h3>

<p>Print a customisable progress bar in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myMiniProgressBar(p, txt1 = "", txt2 = "", style = 1, label = c("=", "-", "|"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myMiniProgressBar_+3A_p">p</code></td>
<td>
<p>Numeric, percentage of finished progress, between 0 and 1.</p>
</td></tr>
<tr><td><code id="myMiniProgressBar_+3A_txt1">txt1</code></td>
<td>
<p>String to put before the progress bar</p>
</td></tr>
<tr><td><code id="myMiniProgressBar_+3A_txt2">txt2</code></td>
<td>
<p>String to put after the progress bar</p>
</td></tr>
<tr><td><code id="myMiniProgressBar_+3A_style">style</code></td>
<td>
<p>The display style. 1 is single-lined; 2 is double-lined; 3 display the progress in a 5-lined block.</p>
</td></tr>
<tr><td><code id="myMiniProgressBar_+3A_label">label</code></td>
<td>
<p>Character labels for &quot;finished&quot;, &quot;un-finished&quot;, and &quot;side bars&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='obsMat2deltax'>Convert an observation matrix to a vector of n-day displacements</h2><span id='topic+obsMat2deltax'></span>

<h3>Description</h3>

<p>Convert an observation matrix to a vector of n-day
displacements. This is a function for the toad example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsMat2deltax(X, lag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obsMat2deltax_+3A_x">X</code></td>
<td>
<p>The observation matrix to be converted.</p>
</td></tr>
<tr><td><code id="obsMat2deltax_+3A_lag">lag</code></td>
<td>
<p>Interger, the number of day lags to compute the displacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of displacements.
</p>

<hr>
<h2 id='PENALTY-class'>S4 class &ldquo;PENALTY&rdquo;</h2><span id='topic+PENALTY-class'></span><span id='topic+PENALTY'></span><span id='topic+PENALTYclass'></span><span id='topic+show+2CPENALTY-method'></span><span id='topic+plot+2CPENALTY+2CANY-method'></span><span id='topic+getPenalty+2CBSL-method'></span>

<h3>Description</h3>

<p>This S4 class contains the penalty selection result from
function <code><a href="#topic+selectPenalty">selectPenalty</a></code>. <code>show</code> display the penalty
selection result. <code>plot</code> plot the penalty selection result using
ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PENALTY'
show(object)

## S4 method for signature 'PENALTY,ANY'
plot(x, logscale = TRUE)

## S4 method for signature 'BSL'
getPenalty(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PENALTY-class_+3A_object">object</code></td>
<td>
<p>The S4 object of class &ldquo;PENALTY&rdquo; to show.</p>
</td></tr>
<tr><td><code id="PENALTY-class_+3A_x">x</code></td>
<td>
<p>The S4 object of class &ldquo;PENALTY&rdquo; to plot.</p>
</td></tr>
<tr><td><code id="PENALTY-class_+3A_logscale">logscale</code></td>
<td>
<p>A logical argument whether the x-axis (penalty) should be log transformed. The
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>loglike</code></dt><dd><p>A list of the log-likelihood values. The list contains multiple
matrices (each corresponds to the result for a specific n value). The
number of row of the matrix equals to the number of repeats <code>M</code>. The
columns of the matrix stands for different penalty values.</p>
</dd>
<dt><code>n</code></dt><dd><p>A vector of <code>n</code>, the number of simulations from the model per
MCMC iteration for estimating the synthetic likelihood.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>A list, with each entry containing the vector of penalty values
for the corresponding choice of <code>n</code>.</p>
</dd>
<dt><code>M</code></dt><dd><p>The number of repeats used in estimating the standard deviation of
the estimated log synthetic likelihood.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>The standard deviation of the log synthetic likelihood estimator
to aim for, usually a value between 1 and 2. This reflects the mixing of a
Markov chain.</p>
</dd>
<dt><code>model</code></dt><dd><p>A &ldquo;MODEL&rdquo; object generated with function <code>newModel</code>.
See <code><a href="#topic+newModel">newModel</a></code>.</p>
</dd>
<dt><code>stdLoglike</code></dt><dd><p>A list contains the estimated standard deviations of
log-likelihoods.</p>
</dd>
<dt><code>penalty</code></dt><dd><p>The vector stores the selected penalty values for each given
<code>n</code> by choosing from the candidate <code>lambda</code> list. The selected
values produce closest standard deviations <code>stdLoglike</code> to the target
<code>sigma</code>.</p>
</dd>
<dt><code>result</code></dt><dd><p>The result data frame.</p>
</dd>
<dt><code>call</code></dt><dd><p>The original code used to run <code><a href="#topic+selectPenalty">selectPenalty</a></code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+selectPenalty">selectPenalty</a></code> for the function that selects the
penalty parameter.
</p>

<hr>
<h2 id='rstable'>Generate a random sample from the zero-centered stable distribution</h2><span id='topic+rstable'></span>

<h3>Description</h3>

<p>Draw a sample from a symmetric, zero-centered stable distribution with
given scale and stability (alpha) parameters, using the CMS algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstable(scale, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstable_+3A_scale">scale</code></td>
<td>
<p>The scale parameter.</p>
</td></tr>
<tr><td><code id="rstable_+3A_alpha">alpha</code></td>
<td>
<p>The stability parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random sample from the zero-centered stable distribution.
</p>

<hr>
<h2 id='selectPenalty'>Selecting the Penalty Parameter</h2><span id='topic+selectPenalty'></span>

<h3>Description</h3>

<p>This is the main function for selecting the shrinkage (graphical
lasso or Warton's estimator) penalty parameter for method BSL or semiBSL
based on a point estimate of the parameters. Parallel computing is
supported with the R package <code>foreach</code>. The penalty selection method
is outlined in An et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectPenalty(
  ssy,
  n,
  lambda,
  M,
  sigma = 1.5,
  model,
  theta = NULL,
  method = c("BSL", "semiBSL"),
  shrinkage = c("glasso", "Warton"),
  parallelSim = FALSE,
  parallelSimArgs = NULL,
  parallelMain = FALSE,
  verbose = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectPenalty_+3A_ssy">ssy</code></td>
<td>
<p>A summary statistic vector for the observed
data.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_n">n</code></td>
<td>
<p>A vector of possible values of <code>n</code>, the
number of simulations from the model per MCMC iteration for estimating the
synthetic likelihood.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_lambda">lambda</code></td>
<td>
<p>A list, with each entry containing the vector of
penalty values to test for the corresponding choice of <code>n</code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_m">M</code></td>
<td>
<p>The number of repeats to use in estimating the
standard deviation of the estimated log synthetic likelihood.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_sigma">sigma</code></td>
<td>
<p>The standard deviation of the log synthetic
likelihood estimator to aim for, usually a value between 1 and 2. This
parameter helps to control the mixing of a Markov chain.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; object generated with function
<code>newModel</code>. See <code><a href="#topic+newModel">newModel</a></code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_theta">theta</code></td>
<td>
<p>A point estimate of the parameter value which
all of the simulations will be based on. By default, if <code>theta</code> is
<code>NULL</code>, it will be replaced by <code>theta0</code> from the given
<code>model</code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_method">method</code></td>
<td>
<p>A string argument indicating the method to be
used. If the method is &ldquo;BSL&rdquo;, the shrinkage is applied to the Gaussian
covariance matrix. Otherwise if the method is &ldquo;semiBSL&rdquo;, the shrinkage is
applied to the correlation matrix of the Gaussian copula.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_shrinkage">shrinkage</code></td>
<td>
<p>A string argument indicating which shrinkage method to
be used. Current options are &ldquo;glasso&rdquo; for the graphical lasso method of
Friedman et al. (2008) and &ldquo;Warton&rdquo; for the ridge
regularisation method of Warton (2008).</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_parallelsim">parallelSim</code></td>
<td>
<p>A logical value indicating whether parallel
computing should be used for simulation and summary statistic evaluation.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_parallelsimargs">parallelSimArgs</code></td>
<td>
<p>A list of additional arguments to pass into the
<code>foreach</code> function. Only used when <code>parallelSim</code> is <code>TRUE</code>,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_parallelmain">parallelMain</code></td>
<td>
<p>A logical value indicating whether parallel
computing should be used to computing the graphical lasso function. Notice
that this should only be turned on when there are a lot of candidate values
in <code>lambda</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_verbose">verbose</code></td>
<td>
<p>An integer indicating the verbose style. 0L
means no verbose messages will be printed. 1L uses a custom progress bar to
track the progress. 2L prints the iteration numbers (<code>1:M</code>) to track
the progress. The default is 1L.</p>
</td></tr>
<tr><td><code id="selectPenalty_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> (&ldquo;BSL&rdquo;
method) or <code><a href="#topic+semiparaKernelEstimate">semiparaKernelEstimate</a></code> (&ldquo;semiBSL&rdquo; method).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object <code>PENALTY</code> of the penalty selection results. The
<code>show</code> and <code>plot</code> methods are provided with the S4 class.
</p>


<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, South LF, Nott DJ, Drovandi CC (2019).
&ldquo;Accelerating Bayesian Synthetic Likelihood With the Graphical Lasso.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>28</b>(2), 471&ndash;475.
doi: <a href="https://doi.org/10.1080/10618600.2018.1537928">10.1080/10618600.2018.1537928</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>


<h3>See Also</h3>

<p><code>PENALTY</code> for the usage of the S4 class. <code><a href="#topic+ma2">ma2</a></code>,
<code><a href="#topic+cell">cell</a></code> and <code><a href="#topic+mgnk">mgnk</a></code> for examples. <code><a href="#topic+bsl">bsl</a></code>
for the main function to run BSL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ma2)
model &lt;- newModel(fnSimVec = ma2_sim_vec, fnSum = ma2_sum, simArgs = ma2$sim_args,
                  theta0 = ma2$start, fnLogPrior = ma2_prior)
theta &lt;- c(0.6,0.2)

# Performing tuning for BSLasso (BSL with glasso shrinkage estimation)
ssy &lt;- ma2_sum(ma2$data)
lambda_all &lt;- list(exp(seq(-3,0.5,length.out=20)), exp(seq(-4,-0.5,length.out=20)),
                   exp(seq(-5.5,-1.5,length.out=20)), exp(seq(-7,-2,length.out=20)))
set.seed(100)
sp_ma2 &lt;- selectPenalty(ssy = ssy, n = c(50, 150, 300, 500), lambda_all, theta = theta,
    M = 100, sigma = 1.5, model = model, method = 'BSL', shrinkage = 'glasso')
sp_ma2
plot(sp_ma2)

## End(Not run)

</code></pre>

<hr>
<h2 id='semiparaKernelEstimate'>Estimate the semi-parametric synthetic (log) likelihood</h2><span id='topic+semiparaKernelEstimate'></span>

<h3>Description</h3>

<p>This function computes the semi-parametric synthetic likelihood
estimator of (An et al. 2019). The advantage of this
semi-parametric estimator over the standard synthetic likelihood estimator
is that the semi-parametric one is more robust to non-normal summary
statistics. Kernel density estimation is used for modelling each univariate
marginal distribution, and the dependence structure between summaries are
captured using a Gaussian copula. Shrinkage on the correlation matrix
parameter of the Gaussian copula is helpful in decreasing the number of
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semiparaKernelEstimate(
  ssy,
  ssx,
  kernel = "gaussian",
  shrinkage = NULL,
  penalty = NULL,
  log = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semiparaKernelEstimate_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="semiparaKernelEstimate_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="semiparaKernelEstimate_+3A_kernel">kernel</code></td>
<td>
<p>A string argument indicating the smoothing kernel to pass
into <code>density</code> for estimating the marginal distribution of each
summary statistic. Only &ldquo;gaussian&quot; and &ldquo;epanechnikov&quot; are available. The
default is &ldquo;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="semiparaKernelEstimate_+3A_shrinkage">shrinkage</code></td>
<td>
<p>A string argument indicating which shrinkage method to
be used. The default is <code>NULL</code>, which means no shrinkage is used.
Current options are &ldquo;glasso&rdquo; for the graphical lasso method of
Friedman et al. (2008) and &ldquo;Warton&rdquo; for the ridge
regularisation method of Warton (2008).</p>
</td></tr>
<tr><td><code id="semiparaKernelEstimate_+3A_penalty">penalty</code></td>
<td>
<p>The penalty value to be used for the specified shrinkage
method. Must be between zero and one if the shrinkage method is &ldquo;Warton&rdquo;.</p>
</td></tr>
<tr><td><code id="semiparaKernelEstimate_+3A_log">log</code></td>
<td>
<p>A logical argument indicating if the log of likelihood is
given as the result. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated synthetic (log) likelihood value.
</p>


<h3>References</h3>

<p>An Z, Nott DJ, Drovandi C (2019).
&ldquo;Robust Bayesian Synthetic Likelihood via a Semi-Parametric Approach.&rdquo;
<em>Statistics and Computing (In Press)</em>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>
<p>Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse Inverse Covariance Estimation with the Graphical Lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.
</p>
<p>Warton DI (2008).
&ldquo;Penalized Normal Likelihood and Ridge Regularization of Correlation and Covariance Matrices.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>103</b>(481), 340&ndash;349.
doi: <a href="https://doi.org/10.1198/016214508000000021">10.1198/016214508000000021</a>.
</p>
<p>Boudt K, Cornelissen J, Croux C (2012).
&ldquo;The Gaussian Rank Correlation Estimator: Robustness Properties.&rdquo;
<em>Statistics and Computing</em>, <b>22</b>(2), 471&ndash;483.
doi: <a href="https://doi.org/10.1007/s11222-011-9237-0">10.1007/s11222-011-9237-0</a>.
</p>


<h3>See Also</h3>

<p>Other available synthetic likelihood estimators:
<code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> for the standard synthetic likelihood
estimator, <code><a href="#topic+gaussianSynLikeGhuryeOlkin">gaussianSynLikeGhuryeOlkin</a></code> for the unbiased
synthetic likelihood estimator, <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> for the
Gaussian synthetic likelihood estimator for model misspecification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ma2)
ssy &lt;- ma2_sum(ma2$data)
m &lt;- newModel(fnSim = ma2_sim, fnSum = ma2_sum, simArgs = ma2$sim_args,
              theta0 = ma2$start, sumArgs = list(delta = 0.5))
ssx &lt;- simulation(m, n = 300, theta = c(0.6, 0.2), seed = 10)$ssx

# check the distribution of the first summary statistic: highly non-normal
plot(density(ssx[, 1]))

# the standard synthetic likelihood estimator over-estimates the likelihood here
gaussianSynLike(ssy, ssx)
# the semi-parametric synthetic likelihood estimator is more robust to non-normality
semiparaKernelEstimate(ssy, ssx)
# using shrinkage on the correlation matrix of the Gaussian copula is also possible
semiparaKernelEstimate(ssy, ssx, shrinkage = "Warton", penalty = 0.8)

</code></pre>

<hr>
<h2 id='sim_toad'>The simulation function for the toad example</h2><span id='topic+sim_toad'></span>

<h3>Description</h3>

<p>The simulation function for the toad example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_toad(params, ntoad, nday, model = 1L, d0 = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_toad_+3A_params">params</code></td>
<td>
<p>A vector of proposed model parameters, <code class="reqn">\alpha</code>,
<code class="reqn">gamma</code> and <code class="reqn">p_0</code>.</p>
</td></tr>
<tr><td><code id="sim_toad_+3A_ntoad">ntoad</code></td>
<td>
<p>The number of toads to simulate in the observation.</p>
</td></tr>
<tr><td><code id="sim_toad_+3A_nday">nday</code></td>
<td>
<p>The number of days lasted of the observation.</p>
</td></tr>
<tr><td><code id="sim_toad_+3A_model">model</code></td>
<td>
<p>Which model to be used. 1 for the random return model, 2 for the nearest return model,
and 3 for the distance-based return probability model.</p>
</td></tr>
<tr><td><code id="sim_toad_+3A_d0">d0</code></td>
<td>
<p>Characteristic distance for model 3. Only used if model is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_toad(c(1.7,36,0.6), 10, 8, 1)
</code></pre>

<hr>
<h2 id='simulate_cell'>Simulation function of the cell biology example</h2><span id='topic+simulate_cell'></span>

<h3>Description</h3>

<p>Simulation function of the cell biology example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cell(x, rows, cols, Pm, Pp, sim_iters, num_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_cell_+3A_x">x</code></td>
<td>
<p>The initial matrix of cell presences of size <code>rows</code>
<code class="reqn">\times</code> <code>cols</code>.</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the lattice (rows in the cell location
matrix).</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_cols">cols</code></td>
<td>
<p>The number of columns in the lattice (columns in the cell
location matrix).</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_pm">Pm</code></td>
<td>
<p>Parameter <code class="reqn">P_m</code>,
the probability of cell movement.</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_pp">Pp</code></td>
<td>
<p>Parameter <code class="reqn">P_p</code>,
the probability of cell proliferation.</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_sim_iters">sim_iters</code></td>
<td>
<p>The number of discretisation steps to get to when an
observation is actually taken. For example, if observations are taken every
5 minutes but the discretisation level is 2.5 minutes, then
<code>sim_iters</code> would be 2. Larger values of <code>sim_iters</code> lead to more
&ldquo;accurate&rdquo; simulations from the model, but they also increase the
simulation time.</p>
</td></tr>
<tr><td><code id="simulate_cell_+3A_num_obs">num_obs</code></td>
<td>
<p>The total number of images taken after initialisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>rows</code> <code class="reqn">\times</code> <code>cols</code>
<code class="reqn">\times</code> <code>num_obs</code> array
of the cell presences at times <code>1:num_obs</code> (not time 0).
</p>

<hr>
<h2 id='simulation'>Run simulations with a give &quot;MODEL&quot; object</h2><span id='topic+simulation'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+MODEL">MODEL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; object.</p>
</td></tr>
<tr><td><code id="simulation_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='sliceGammaMean'>Generate a random sample of gamma for the R-BSL-M method of
Frazier and Drovandi (2021) using slice sampling</h2><span id='topic+sliceGammaMean'></span>

<h3>Description</h3>

<p>This function updates the gamma of the R-BSL-M method of
Frazier and Drovandi (2021) with a slice sampler
(Neal 2003). Note this function is mainly designed for
internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceGammaMean(
  ssy,
  ssx,
  loglike,
  gamma = numeric(length(ssy)),
  tau = 1,
  w = 1,
  std = NULL,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceGammaMean_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_loglike">loglike</code></td>
<td>
<p>The current log synthetic likelihood. This is computed with
function <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> with the current gamma value.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_gamma">gamma</code></td>
<td>
<p>The additional latent parameter to account for possible
incompatability between the model and observed summary statistic. In
&ldquo;BSLmisspec&rdquo; method, this is updated with a slice sampler
(Neal 2003). The default gamma implies no model misspecification
and is equivalent to the standard <code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> estimator.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_tau">tau</code></td>
<td>
<p>Scale (or inverse rate) parameter of the Laplace prior
distribution for gamma.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_w">w</code></td>
<td>
<p>Step size for the stepping out in the slice sampler. The default
step size is 1.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_std">std</code></td>
<td>
<p>Standard deviation of the columns of ssx. If this is not
<code>NULL</code>, it will be used to save computation effort.</p>
</td></tr>
<tr><td><code id="sliceGammaMean_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iteration of the stepping out and shrink
steps of slice sampler. The default is 1e3.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Neal RM (2003).
&ldquo;Slice sampling.&rdquo;
<em>The Annals of Statistics</em>, <b>31</b>(3), 705&ndash;767.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sliceGammaVariance">sliceGammaVariance</a></code> for the slice sampler of the
variance inflated target distribution.
</p>

<hr>
<h2 id='sliceGammaVariance'>Generate a random sample of gamma for the R-BSL-V method of
Frazier and Drovandi (2021) using slice sampling</h2><span id='topic+sliceGammaVariance'></span>

<h3>Description</h3>

<p>This function updates the gamma parameter with a slice sampler
(Neal 2003). The target distribution is the variance
inflated approximate posterior of BSL with model misspecification. See
Frazier and Drovandi (2021). Note this function is mainly
designed for internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceGammaVariance(
  ssy,
  ssx,
  loglike,
  gamma = numeric(length(ssy)),
  tau = 1,
  w = 1,
  std = NULL,
  maxit = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceGammaVariance_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_loglike">loglike</code></td>
<td>
<p>The current log synthetic likelihood. This is computed with
function <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> with the current gamma value.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_gamma">gamma</code></td>
<td>
<p>The additional latent parameter to account for possible
incompatability between the model and observed summary statistic. In
&ldquo;BSLmisspec&rdquo; method, this is updated with a slice sampler
(Neal 2003). The default gamma implies no model misspecification
and is equivalent to the standard <code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> estimator.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_tau">tau</code></td>
<td>
<p>Numeric. Scale (or inverse rate) parameter of the exponential
prior distribution.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_w">w</code></td>
<td>
<p>Step size for the stepping out in the slice sampler. The default
step size is 1.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_std">std</code></td>
<td>
<p>Standard deviation of the columns of ssx. If this is not
<code>NULL</code>, it will be used to save computation effort.</p>
</td></tr>
<tr><td><code id="sliceGammaVariance_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iteration of the stepping out and shrink
steps of slice sampler. The default is 1e3.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Neal RM (2003).
&ldquo;Slice sampling.&rdquo;
<em>The Annals of Statistics</em>, <b>31</b>(3), 705&ndash;767.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sliceGammaMean">sliceGammaMean</a></code> for the slice sampler of the mean
adjusted target distribution.
</p>

<hr>
<h2 id='summStat'>Compute the summary statistics with the given data</h2><span id='topic+summStat'></span>

<h3>Description</h3>

<p>see <code><a href="#topic+MODEL">MODEL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summStat(x, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summStat_+3A_x">x</code></td>
<td>
<p>The data to pass to the summary statistics function.</p>
</td></tr>
<tr><td><code id="summStat_+3A_model">model</code></td>
<td>
<p>A &ldquo;MODEL&rdquo; object.</p>
</td></tr>
</table>

<hr>
<h2 id='synLikeMisspec'>Estimate the Gaussian synthetic (log) likelihood whilst acknowledging model
incompatibility</h2><span id='topic+synLikeMisspec'></span>

<h3>Description</h3>

<p>This function estimates the Gaussian synthetic likelihood whilst
acknowledging that there may be incompatibility between the model and the
observed summary statistic. The method has two different ways to
account for and detect incompatibility (mean adjustment and variance
inflation). An additional free parameter <code>gamma</code> is employed to account for the
model misspecification. See the R-BSL methods of
Frazier and Drovandi (2021) for more details. Note this function
is mainly designed for interal use as the latent variable <code>gamma</code> need
to be chosen otherwise. Alternatively, <code>gamma</code> is updated with a slice
sampler (Neal 2003), which is the method of
Frazier and Drovandi (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synLikeMisspec(
  ssy,
  ssx,
  type = c("mean", "variance"),
  gamma = numeric(length(ssy)),
  log = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synLikeMisspec_+3A_ssy">ssy</code></td>
<td>
<p>The observed summary statisic.</p>
</td></tr>
<tr><td><code id="synLikeMisspec_+3A_ssx">ssx</code></td>
<td>
<p>A matrix of the simulated summary statistics. The number
of rows is the same as the number of simulations per iteration.</p>
</td></tr>
<tr><td><code id="synLikeMisspec_+3A_type">type</code></td>
<td>
<p>A string argument indicating which method is used to account for
and detect potential incompatibility. The two options are &quot;mean&quot; and
&quot;variance&quot; for mean adjustment and variance inflation, respectively.</p>
</td></tr>
<tr><td><code id="synLikeMisspec_+3A_gamma">gamma</code></td>
<td>
<p>The additional latent parameter to account for possible
incompatability between the model and observed summary statistic. In
&ldquo;BSLmisspec&rdquo; method, this is updated with a slice sampler
(Neal 2003). The default gamma implies no model misspecification
and is equivalent to the standard <code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> estimator.</p>
</td></tr>
<tr><td><code id="synLikeMisspec_+3A_log">log</code></td>
<td>
<p>A logical argument indicating if the log of likelihood is
given as the result. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="synLikeMisspec_+3A_verbose">verbose</code></td>
<td>
<p>A logical argument indicating whether an error message
should be printed if the function fails to compute a likelihood. The
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated synthetic (log) likelihood value.
</p>


<h3>References</h3>

<p>Frazier DT, Drovandi C (2021).
&ldquo;Robust Approximate Bayesian Inference with Synthetic Likelihood.&rdquo;
<em>Journal of Computational and Graphical Statistics (In Press)</em>.
<a href="https://arxiv.org/abs/1904.04551">https://arxiv.org/abs/1904.04551</a>.<br /><br /> Neal RM (2003).
&ldquo;Slice sampling.&rdquo;
<em>The Annals of Statistics</em>, <b>31</b>(3), 705&ndash;767.
</p>


<h3>See Also</h3>

<p>Other available synthetic likelihood estimators:
<code><a href="#topic+gaussianSynLike">gaussianSynLike</a></code> for the standard synthetic likelihood
estimator, <code><a href="#topic+gaussianSynLikeGhuryeOlkin">gaussianSynLikeGhuryeOlkin</a></code> for the unbiased
synthetic likelihood estimator, <code><a href="#topic+semiparaKernelEstimate">semiparaKernelEstimate</a></code> for
the semi-parametric likelihood estimator, <code><a href="#topic+synLikeMisspec">synLikeMisspec</a></code> for
the Gaussian synthetic likelihood estimator for model misspecification.
Slice sampler to sample gamma <code><a href="#topic+sliceGammaMean">sliceGammaMean</a></code> and
<code><a href="#topic+sliceGammaVariance">sliceGammaVariance</a></code> (internal functions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a toy model (for details see section 4.1 from Frazier et al 2019)
# the true underlying model is a normal distribution with standard deviation equals to 0.2
# whist the data generation process has the standard deviation fixed to 1
set.seed(1)
y &lt;- rnorm(50, 1, sd = 0.2)
ssy &lt;- c(mean(y), var(y))
m &lt;- newModel(fnSim = function(theta) rnorm(50, theta), fnSum = function(x) c(mean(x), var(x)),
              theta0 = 1, fnLogPrior = function(x) log(dnorm(x, sd = sqrt(10))))
ssx &lt;- simulation(m, n = 300, theta = 1, seed = 10)$ssx

# gamma is updated with a slice sampler
gamma &lt;- rep(0.1, length(ssy))
synLikeMisspec(ssy, ssx, type = "variance", gamma = gamma)

</code></pre>

<hr>
<h2 id='toad'>Toad example</h2><span id='topic+toad'></span><span id='topic+toad_sim'></span><span id='topic+toad_sum'></span><span id='topic+toad_prior'></span>

<h3>Description</h3>

<p>This example estimates the parameter for the toad example. The
model simulates the movement of an amphibian called Fowler's toad. The
model is proposed by Marchand et al. (2017). This example
includes both simulated and real data. The real data is obtained from 
the supplementary material of Marchand et al. (2017).
The journal article An et al. (2022) provides a full
description of how to use this package for the toad example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toad)

toad_sim(
  theta,
  ntoads,
  ndays,
  model = 1,
  d0 = 100,
  na = matrix(FALSE, ndays, ntoads)
)

toad_sum(X, lag = c(1, 2, 4, 8), p = seq(0, 1, 0.1))

toad_prior(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toad_+3A_theta">theta</code></td>
<td>
<p>A vector of proposed model parameters,
<code class="reqn">\alpha</code>, <code class="reqn">\gamma</code> and <code class="reqn">p_0</code>.</p>
</td></tr>
<tr><td><code id="toad_+3A_ntoads">ntoads</code></td>
<td>
<p>The number of toads to simulate in the observation.</p>
</td></tr>
<tr><td><code id="toad_+3A_ndays">ndays</code></td>
<td>
<p>The number of days observed.</p>
</td></tr>
<tr><td><code id="toad_+3A_model">model</code></td>
<td>
<p>Which model to be used: 1 for the random return model, 2 for the
nearest return model, and 3 for the distance-based return probability
model. The default is 1.</p>
</td></tr>
<tr><td><code id="toad_+3A_d0">d0</code></td>
<td>
<p>Characteristic distance for model 3. Only used if <code>model</code> is
3.</p>
</td></tr>
<tr><td><code id="toad_+3A_na">na</code></td>
<td>
<p>Logical. This is the index matrix for missing observations. By
default, <code>matrix(FALSE, ndays, ntoads)</code> indicates there is no
missingness in the observation matrix.</p>
</td></tr>
<tr><td><code id="toad_+3A_x">X</code></td>
<td>
<p>The data matrix.</p>
</td></tr>
<tr><td><code id="toad_+3A_lag">lag</code></td>
<td>
<p>The lag of days to compute the summary statistics, default as 1,
2, 4 and 8.</p>
</td></tr>
<tr><td><code id="toad_+3A_p">p</code></td>
<td>
<p>The numeric vector of probabilities to compute the quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The example includes the three different returning models of
Marchand et al. (2017). Please see
Marchand et al. (2017) for a full description of the toad
model, and also An et al. (2019) for Bayesian inference
with the semi-BSL method.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>toad_sim</code>: Simulates data from the model, using C++ in the backend.
</p>
</li>
<li> <p><code>toad_sum</code>: Computes the summary statistics for this example. The summary 
statistics are the log differences between adjacent quantiles and also the median.
</p>
</li>
<li> <p><code>toad_prior</code>: Evaluates the log prior at the chosen parameters.
</p>
</li></ul>


<h3>datasets (simulated and real)</h3>

<p>A simulated dataset and a real dataset are provided in this example. Both
datasets contain observations from 66 toads for 63 days. The simulated
dataset is simulated with parameter
<code class="reqn">\theta = (1.7, 35,
  0.6)</code>. This is the data used in An et al. (2019). The real
dataset is obtained from the supplementary data of
Marchand et al. (2017).
</p>

<ul>
<li> <p><code>data_simulated</code>:  A 63
<code class="reqn">\times</code> 66 matrix of the observed
toad locations (simulated data).
</p>
</li>
<li> <p><code>data_real</code>:       A 63
<code class="reqn">\times</code> 66 matrix of the observed
toad locations (real data).
</p>
</li>
<li> <p><code>cov</code>: The covariance matrix of a multivariate normal random
walk proposal distribution used in the MCMC, in the form of a 3
<code class="reqn">\times</code> 3 matrix.
</p>
</li>
<li> <p><code>theta0</code>: A vector of suitable initial values of the parameters
for MCMC.
</p>
</li>
<li> <p><code>sim_args_simulated</code> and <code>sim_args_real</code>: A list of the
arguments to pass into the simulation function.
</p>

<ul>
<li> <p><code>ndays</code>: The number of days observed.
</p>
</li>
<li> <p><code>ntoads</code>: The total number of toads being observed.
</p>
</li>
<li> <p><code>model</code>: Indicator of which model to be used.
</p>
</li>
<li> <p><code>na</code>: Indicator matrix for missingness.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Ziwen An, Leah F. South and
Christopher Drovandi
</p>


<h3>References</h3>

<p>An Z, Nott DJ, Drovandi C (2019).
&ldquo;Robust Bayesian Synthetic Likelihood via a Semi-Parametric Approach.&rdquo;
<em>Statistics and Computing (In Press)</em>.<br /><br /> An Z, South LF, Drovandi CC (2022).
&ldquo;BSL: An R Package for Efficient Parameter Estimation for Simulation-Based Models via Bayesian Synthetic Likelihood.&rdquo;
<em>Journal of Statistical Software</em>, <b>101</b>(11), 1&ndash;33.
doi: <a href="https://doi.org/10.18637/jss.v101.i11">10.18637/jss.v101.i11</a>.<br /><br /> Marchand P, Boenke M, Green DM (2017).
&ldquo;A stochastic movement model reproduces patterns of site fidelity and long-distance dispersal in a population of Fowlers toads (Anaxyrus fowleri).&rdquo;
<em>Ecological Modelling</em>, <b>360</b>, 63&ndash;69.
ISSN 0304-3800, doi: <a href="https://doi.org/10.1016/j.ecolmodel.2017.06.025">10.1016/j.ecolmodel.2017.06.025</a>.()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(doParallel) # You can use a different package to set up the parallel backend

data(toad)

## run standard BSL for the simulated dataset
model1 &lt;- newModel(fnSim = toad_sim, fnSum = toad_sum, theta0 = toad$theta0,
                   fnLogPrior = toad_prior, simArgs = toad$sim_args_simulated, 
                   thetaNames = expression(alpha,gamma,p[0]))
paraBound &lt;- matrix(c(1,2,0,100,0,0.9), 3, 2, byrow = TRUE)

# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultToadSimulated &lt;- bsl(toad$data_simulated, n = 1000, M = 10000, model = model1,
                           covRandWalk = toad$cov, logitTransformBound = paraBound,
                           parallel = TRUE, verbose = 1L, plotOnTheFly = 100)
stopCluster(cl)
registerDoSEQ()
show(resultToadSimulated)
summary(resultToadSimulated)
plot(resultToadSimulated, thetaTrue = toad$theta0, thin = 20)

## run standard BSL for the real dataset
model2 &lt;- newModel(fnSim = toad_sim, fnSum = toad_sum, theta0 = toad$theta0,
                   fnLogPrior = toad_prior, simArgs = toad$sim_args_real,
                   thetaNames = expression(alpha,gamma,p[0]))
paraBound &lt;- matrix(c(1,2,0,100,0,0.9), 3, 2, byrow = TRUE)

# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl &lt;- makeCluster(min(detectCores() - 1,2))
registerDoParallel(cl)
resultToadReal &lt;- bsl(toad$data_real, n = 1000, M = 10000, model = model2,
                      covRandWalk = toad$cov, logitTransformBound = paraBound,
                      parallel = TRUE, verbose = 1L, plotOnTheFly = 100)
stopCluster(cl)
registerDoSEQ()
show(resultToadReal)
summary(resultToadReal)
plot(resultToadReal, thetaTrue = toad$theta0, thin = 20)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
