<!DOCTYPE html><html><head><title>Help for package FCSlib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FCSlib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asynACTCSPC'><p>Asynchronous Autocorrelation of Time-Correlated Single-Photon Counting</p></a></li>
<li><a href='#binMatrix'><p>Binned representation of a matrix</p></a></li>
<li><a href='#binTimeSeries'><p>Binned representation of a time series</p></a></li>
<li><a href='#Cy5'><p>Experimental data of freely diffusing Cy5 dye in water at a concentration of 33 nM.</p></a></li>
<li><a href='#detrendTimeSeries'><p>Algorithms for data detrending</p></a></li>
<li><a href='#fcs'><p>Fluorescence Correlation Spectroscopy</p></a></li>
<li><a href='#fitFCS'><p>Fitting FCS Data</p></a></li>
<li><a href='#gcf'><p>General Correlation Function</p></a></li>
<li><a href='#nbline'><p>Number &amp; Brightness (Single Image)</p></a></li>
<li><a href='#norm.vector'><p>Min-Max Feature scaling normalization</p></a></li>
<li><a href='#pcf'><p>Pair Correlation Function</p></a></li>
<li><a href='#pcomb'><p>Pair Correlation of Molecular Brightness</p></a></li>
<li><a href='#readFileFCS'><p>Read File FCS</p></a></li>
<li><a href='#readFileModel'><p>Read File Model</p></a></li>
<li><a href='#readFileSPC'><p>Read File SPC-140/150/130/830</p></a></li>
<li><a href='#readFileTiff'><p>Read File Tiff</p></a></li>
<li><a href='#simplifyFCS'><p>Simplify FCS</p></a></li>
<li><a href='#smoothCarpet'><p>Smooth Carpet (Single Image)</p></a></li>
<li><a href='#tiff_to_mtx'><p>Transformation of multiple-image TIFF files or arrays into a matrix</p></a></li>
<li><a href='#V2'><p>Line-scan data of HEK-293 cells expressing Venus (EYFP) dimers</p></a></li>
<li><a href='#writeFileTiff'><p>Write File Tiff</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Fluorescence Fluctuation Spectroscopy Analysis
Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Raúl Pinto Cámara, Adán Guerrero, Alejandro Linares, José Damián Martínez Reyes, Haydee Hernández.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raúl Pinto Cámara &lt;support.fcslib@mail.ibt.unam.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    This is a package for fluorescence fluctuation spectroscopy data analysis methods such as spFCS, FCCS, scanning-FCS, pCF, N&amp;B and pCOMB, among others.
    In addition, several data detrending tools are provided. For an extensive user's guide for the use of FCSlib, please navigate to (<a href="https://github.com/FCSlib/FCSlib/tree/master/Documentation">https://github.com/FCSlib/FCSlib/tree/master/Documentation</a>).
    Sample data can be found at (<a href="https://github.com/FCSlib/FCSlib/tree/master/Sample%20Data">https://github.com/FCSlib/FCSlib/tree/master/Sample%20Data</a>).
    The original paper where this package is presented can be found at (&lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa876">doi:10.1093/bioinformatics/btaa876</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.6.0), tiff, stringr, bitops, fields</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-18 02:57:24 UTC; raul_</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-18 09:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='asynACTCSPC'>Asynchronous Autocorrelation of Time-Correlated Single-Photon Counting</h2><span id='topic+asynACTCSPC'></span>

<h3>Description</h3>

<p>Calculates the auto-correlation of the Macrotime data, returning a correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asynACTCSPC(macro, n = 5, B = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asynACTCSPC_+3A_macro">macro</code></td>
<td>
<p>A numeric vector containig a Macrotime Data.</p>
</td></tr>
<tr><td><code id="asynACTCSPC_+3A_n">n</code></td>
<td>
<p>numeric parameter that represents the number of layers of the cascade.</p>
</td></tr>
<tr><td><code id="asynACTCSPC_+3A_b">B</code></td>
<td>
<p>numeric parameter that represents the number of values in every layer of the cascade.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates list of tau's with a length of n*B, this list is used to perform the correlation of the data.
</p>


<h3>Value</h3>

<p>A numeric vector G containing either the autocorrelation for the input vector macro, with a length of n*B.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara, José Damián Martínez Reyes.
</p>


<h3>References</h3>

<p>wahl, M., Gregor, I., Patting, M. &amp; Enderlein, J. Fast calculation of fluorescence correlation data with
asynchronous time-correlated single-photon counting. Opt. Express 11, 3583–3591 (2003).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFileSPC">readFileSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spcData &lt;- readFileSPC("atto532_atto655_m1.spc")
asynCorrData &lt;- asynACTCSPC(macro = spcData$MacroTime)

</code></pre>

<hr>
<h2 id='binMatrix'>Binned representation of a matrix</h2><span id='topic+binMatrix'></span>

<h3>Description</h3>

<p>Groups each column in a matrix into several bins of a given length for better (and faster) data plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binMatrix(f, lineTime, nIntervals, columns, mode = "mean", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binMatrix_+3A_f">f</code></td>
<td>
<p>A vector or a matrix</p>
</td></tr>
<tr><td><code id="binMatrix_+3A_linetime">lineTime</code></td>
<td>
<p>Line (row) acquisition rate (in seconds)</p>
</td></tr>
<tr><td><code id="binMatrix_+3A_nintervals">nIntervals</code></td>
<td>
<p>Number of intervals into which the all columns will be grouped</p>
</td></tr>
<tr><td><code id="binMatrix_+3A_columns">columns</code></td>
<td>
<p>Number of columns of the resulting binned matrix</p>
</td></tr>
<tr><td><code id="binMatrix_+3A_mode">mode</code></td>
<td>
<p>Set to &quot;mean&quot; (default) or &quot;sum&quot; to average or sum all the points in every interval, respectively</p>
</td></tr>
<tr><td><code id="binMatrix_+3A_plot">plot</code></td>
<td>
<p>Boolean, set to TRUE (default) to plot the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function groups all the points in each column of the matrix 'f' into 'nIntervals' bins of length = length(f)/nIntervals.
Then, averages or sums all of the points in each bin and plots the result.
If 'f' is a vector, 'columns' is used to build the resulting matrix.
If 'f' is a matrix, then 'columns' takes the value of the number of columns in 'f'.
</p>


<h3>Value</h3>

<p>A matrix of 'nIntervals' rows
</p>


<h3>Author(s)</h3>

<p>Alejandro Linares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binTimeSeries">binTimeSeries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Please navigate to
### (https://github.com/FCSlib/FCSlib/tree/master/Sample%20Data)
### to find this sample data

# Automatic plot
x &lt;- read.table("Pax.dat")
x &lt;- binMatrix(x[,1], lineTime =  1e-3, nIntervals =  500,
               columns = 64, mode = "mean", plot = T)

# Manual plot (useful for adding custom labels)
x &lt;- read.table("Pax.dat")
x &lt;- binMatrix(x[,1], lineTime =  1e-3, nIntervals =  500,
               columns = 64, mode = "mean", plot = F)
image.plot(x)

</code></pre>

<hr>
<h2 id='binTimeSeries'>Binned representation of a time series</h2><span id='topic+binTimeSeries'></span>

<h3>Description</h3>

<p>Groups large vectors into several bins of a given length for better (and faster) data plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binTimeSeries(f, acqTime, nIntervals, mode = "mean", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binTimeSeries_+3A_f">f</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="binTimeSeries_+3A_acqtime">acqTime</code></td>
<td>
<p>Point acquisition rate (in seconds)</p>
</td></tr>
<tr><td><code id="binTimeSeries_+3A_nintervals">nIntervals</code></td>
<td>
<p>Number of intervals into which the vector will be grouped</p>
</td></tr>
<tr><td><code id="binTimeSeries_+3A_mode">mode</code></td>
<td>
<p>Set to &quot;mean&quot; (default) or &quot;sum&quot; to average or sum all the points in every interval, respectively</p>
</td></tr>
<tr><td><code id="binTimeSeries_+3A_plot">plot</code></td>
<td>
<p>Boolean, set to TRUE (default) to plot the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function groups all the points in the vector 'f' into 'nIntervals' bins of length = length(f)/nIntervals.
Then, averages or sums all of the points in each bin and plots the result.
</p>


<h3>Value</h3>

<p>A data frame with two variables (Counts and Time) and 'nIntervals' observations
</p>


<h3>Author(s)</h3>

<p>Alejandro Linares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binMatrix">binMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Please navigate to
### (https://github.com/FCSlib/FCSlib/tree/master/Sample%20Data)
### to find this sample data

# Automatic plot
x &lt;- readFileTiff("Cy5.tif")
x &lt;- as.vector(x)
x &lt;- binTimeSeries(x[length(x):1], 2e-6, 100, mode = "mean", plot = T)

# Manual plot (useful for adding custom labels)
x &lt;- readFileTiff("Cy5.tif")
x &lt;- as.vector(x)
x &lt;- binTimeSeries(x[length(x):1], 2e-6, 100, mode = "mean", plot = F)
plot(x$Counts~x$Time, type = "l")

</code></pre>

<hr>
<h2 id='Cy5'>Experimental data of freely diffusing Cy5 dye in water at a concentration of 33 nM.</h2><span id='topic+Cy5'></span>

<h3>Description</h3>

<p>A single vector of single-point scan data, in the form of a TIFF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cy5)
</code></pre>


<h3>Format</h3>

<p>A matrix with 2048 columns and 5000 rows
</p>


<h3>Details</h3>

<p>To analyze this data set with FCSlib, import by typing: readFileTiff(&quot;Cy5.tif&quot;)
</p>

<hr>
<h2 id='detrendTimeSeries'>Algorithms for data detrending</h2><span id='topic+detrendTimeSeries'></span>

<h3>Description</h3>

<p>Allows to perform Exponential, Polynomial or Boxcar Filter detrending over a time series vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrendTimeSeries(f, acqTime, nIntervals, algorithm, degree, w, pois = FALSE,
 max = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrendTimeSeries_+3A_f">f</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_acqtime">acqTime</code></td>
<td>
<p>Point acquisition rate (in seconds)</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_nintervals">nIntervals</code></td>
<td>
<p>Number of intervals into which the vector will be grouped prior to the detrending process</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_algorithm">algorithm</code></td>
<td>
<p>A character string. Choose between Exponential (&quot;exp&quot;), Polynomial (&quot;poly&quot;) or Boxcar Filter (&quot;boxcar&quot;) detrending</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial function</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_w">w</code></td>
<td>
<p>Moving average time window size</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_pois">pois</code></td>
<td>
<p>Logical, set to TRUE for detrending performance by adding random, uncorrelated numbers sampled from a Poisson distribution (see details)</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_max">max</code></td>
<td>
<p>Logical, set to TRUE for detrending performance based on the highest value of the original data, rather than the first one (see details)</p>
</td></tr>
<tr><td><code id="detrendTimeSeries_+3A_plot">plot</code></td>
<td>
<p>Logical, set to TRUE (default) to plot de result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the binTimeSeries() function is used to obtain a binned version of 'f' of 'nIntervals' points.
</p>
<p>For exponential detrending, a model of the form (A0*e^(k*t) is adjusted to the binned vector.
</p>
<p>A polynomial function of user-specified degree is rather used for polynomial detrending.
</p>
<p>For the case of boxcar filtering, the moving average vector is calculated from the original series.
An amount of zeroes equal to (w-1) is added at the tail of 'f' to compensate for the moving average
effect when position (length(f) - w + 1) is reached.
</p>
<p>In either case, the residuals are then obtained and added a constant value for trend correction.
When 'max' is set to TRUE, said value will be the highest in the binned vector of 'f'.
</p>
<p>When 'pois' is set to FALSE (default), the trend correction value is directly added to the obtained residuals,
in a quantity that will make the average counts remain constant throughout the whole time series.
On the other hand, when 'pois = TRUE', the trend correction value is instead used as the 'lambda'
parameter for a Poisson distribution from which uncorrelated counts will be randomly sampled and
added to the whole series for trend correction. This procedure asures that only integer counts will
be obtained after detrending, at the cost of adding some noise and making the detrending process a lengthier task.
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>Author(s)</h3>

<p>Alejandro Linares, Ad?n Guerrero, Haydee Hern?ndez
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binTimeSeries">binTimeSeries</a></code>
</p>

<hr>
<h2 id='fcs'>Fluorescence Correlation Spectroscopy</h2><span id='topic+fcs'></span>

<h3>Description</h3>

<p>Calculates either the auto-correlation or cross-correlation between vectors x and y, returning a correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcs(x , y = NULL, nPoints, pcf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcs_+3A_x">x</code></td>
<td>
<p>Numeric vector of length N.</p>
</td></tr>
<tr><td><code id="fcs_+3A_y">y</code></td>
<td>
<p>Numeric vector of length N.</p>
</td></tr>
<tr><td><code id="fcs_+3A_npoints">nPoints</code></td>
<td>
<p>The size of the sub-vectors in which the input vectors will be divided. This number must be less than N/2.</p>
</td></tr>
<tr><td><code id="fcs_+3A_pcf">pcf</code></td>
<td>
<p>A boolean parameter to determine if an alternate version of the correlation function is used for the calculation of de pCF and pComb functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fluorescence correlation spectroscopy (FCS) is a technique with high spatial and temporal resolution used to analyze the kinetics of particles diffusing at low concentrations. The detected fluorescence intensity as a function of time is: F(t).
</p>
<p>The correlation function is computed as the normalized autocorrelation function, G(tau) = &lt;deltaF(t)deltaF(t+tau)&gt;/(&lt;F(t)&gt;*&lt;F(t)&gt;), to the collected data set, where t refers to a time point of flourescence acquisition, and tau refers to the temporal delay between acquisitions and &lt;...&gt; indicates average. 
</p>
<p>The correlation between deltaF(t) = F(t) - &lt;F(t)&gt; and deltaF(t+tau) = F(t+tau) - &lt;F(t)&gt; is calculated for a range of delay times.
For temporal acquisitions as FCS point, x takes the value of F(t) and y = NULL.
For cross-correlation experiments between two fluorescent signals x = F1(t) and y = F2(t), as channels, the correlation function is: G(tau) = &lt;deltaF1(t) deltaF2(t+tau)&gt; / (&lt;F1(t)&gt; &lt;F2(t)&gt;).
</p>
<p>The function separate the original vector in sub-vectors of same length (n-points), then calculate an autocorrelation function form each sub-vector. The final result will be an average of all the autocorrelation functions.
</p>


<h3>Value</h3>

<p>A numeric vector G containing either the autocorrelation for the input vector x, or the cross-correlation between x and y vectors, with a length of nPoints.
</p>


<h3>Note</h3>

<p>The argument nPoints must be smaller than the total number of temporal observations N, it is recommended to set nPoints = 2^n, with n = 2, ..., infinity.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara, Adan O. Guerrero
</p>


<h3>References</h3>

<p>R.A. Migueles-Ramirez, A.G. Velasco-Felix, R. Pinto-Cámara, C.D. Wood, A. Guerrero. Fluorescence fluctuation spectroscopy in living cells.
Microscopy and imaging science: practical approaches to applied research and education, 138-151,2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcf">gcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Load the FCSlib package

library(FCSlib)

# As an example, we will use data from experiment adquisition
# of free Cy5 molecules diffusing in water at a concentration of 100 nM.
# Use readFileTiff() function to read the fcs data in TIFF format.

f&lt;-readFileTiff("Cy5_100nM.tif")

### Note that $f$ is a matrix of 2048 x 5000 x 1 dimentions.
# This is due to the fact that this single-point FCS experimen twas collected
# at intervals of 2048 points each, with an acquisition time of 2 mu s.
# Let's now create a dataframe with the FCS data wich here-and-after will be called Cy5.

acqTime = 2E-6
f&lt;-as.vector(f)
time &lt;- (1:length(f))*acqTime
Cy5&lt;-data.frame(t = time, f)

### The first 100 ms of the time series are:

plot(Cy5[1:5000,], type ="l", xlab = "t(s)", ylab ="Fluorescence Intensity", main = "Cy5")

# The fcs() function receives three parameters: 'x' (mandatory),
# 'y'(optional) and 'nPoints' (optional), where x is the main signal to analyze,
#  y is a secondary signal (for the case of cross-correlation instead of autocorrelation)
# and nPoints is the final length of the calculated correlation curve.
# This function divides the original N-size signal into sub-vectors with a size of nPoints*2.
# Once all the sub-vectors are analyzed, these are then averaged.
# To use the fcs() function type

g &lt;- fcs(x = Cy5$f, nPoints = length(Cy5$f)/2)

# The result of the function is assigned to the variable 'g',
# which contains the autocorrelation curve

length &lt;- 1:length(g)
tau &lt;-Cy5$t[length]
G&lt;-data.frame(tau,g)
plot(G, log = "x", type = "l", xlab = expression(tau(s)), ylab = expression(G(tau)), main = "Cy5")

# It is important to remove the first point from the data,
# where G(\tau=0) it is not properly computed

G&lt;-G[-1,]
plot(G, log = "x", type = "l", xlab = expression(tau(s)), ylab = expression(G(tau)), main = "Cy5")

# The variable 'nPoints' can be adjusted to better assess the transport phenomena
# in study (i.e. free diffusion in three dimensions in the case of this example) and
# for better understanding of the diffusive nature of the molecules.
# In this example 'nPoints' will be set to 2048.

g &lt;- fcs(x = Cy5$f,nPoints = 2048)
length &lt;- 1:length(g)
tau &lt;-Cy5$t[length]
G&lt;-data.frame(tau,g)
G&lt;-G[-1,]
plot(G, log = "x", type = "l", xlab = expression(tau(s)), ylab = expression(G(tau)), main = "Cy5")

</code></pre>

<hr>
<h2 id='fitFCS'>Fitting FCS Data</h2><span id='topic+fitFCS'></span>

<h3>Description</h3>

<p>Estimates the parameters based on a given equation, on the data generated with the fcs() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitFCS(data = parent.frame(), start, low = -Inf, up = Inf,
              type = "D3D", model = NULL, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitFCS_+3A_data">data</code></td>
<td>
<p>data frame in which to evaluate the variables in formula and weights.</p>
</td></tr>
<tr><td><code id="fitFCS_+3A_start">start</code></td>
<td>
<p>a named list or named numeric vector of starting estimates.</p>
</td></tr>
<tr><td><code id="fitFCS_+3A_low">low</code>, <code id="fitFCS_+3A_up">up</code></td>
<td>
<p>a named list or named numeric vector of lower and upper bounds, replicated to be as long as start. If unspecified, all parameters are assumed to be -Inf and Inf.</p>
</td></tr>
<tr><td><code id="fitFCS_+3A_type">type</code></td>
<td>
<p>specification for the equation to model, is a character string. The default value is &quot;D3D&quot; equation for three-dimensional free diffusion.
Another possibles values are: &quot;D2D&quot; for two-dimensional free diffusion,  &quot;D2DT&quot; for two-dimensional free diffusion with triplet exited state, and &quot;D3DT&quot; for three-dimensional free diffusion with triplet exited state
and D3D2S for two species in three-dimensional free diffusion.</p>
</td></tr>
<tr><td><code id="fitFCS_+3A_model">model</code></td>
<td>
<p>a character type variable, that must contain the custom equation if needed, NULL by default.</p>
</td></tr>
<tr><td><code id="fitFCS_+3A_trace">trace</code></td>
<td>
<p>logical value that indicates whether the progress of the non-linear regression (nls) should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A transport model, containing physical information about the diffusive nature of the fluorophores, can be fitted to the autocorrelation data to obtain parameters such as the diffusion coeficient D and the number of molecules within the observation volume N.
</p>
<p>The fitFCS() function uses the 'Non-linear Least Squares' function to fit a physical model into a data set. There are four possible models to be fit:
</p>
<p>&quot;D2D&quot; for two-dimensional diffusion
</p>
<p>&quot;D2DT&quot; for two-dimensional diffusion with triplet state
</p>
<p>&quot;D3D&quot; for three-dimensional diffusion
</p>
<p>&quot;D3DT&quot; for three-dimensional diffusion with triplet state
</p>
<p>Inside the equations for each model, gamma a geometric factor that depends on the illumination profile. For confocal excitation its magnitude approaches gamma = 1/sqrt8 ??? 0.35 fl. The diffusion time is defined as tau_D = s^2/4D, where s and u are the radius and the half-length of the focal volume, respectively. The parameter u is usually expressed as u = ks, with k being the eccentricity of the focal volume; for confocal excitation k ??? 3. The fraction of molecules in the triplet state is B, and tau_B is a time constant for the triplet state.
</p>


<h3>Value</h3>

<p>A nls object (from nls).
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="#topic+fcs">fcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the FCSlib package

library(FCSlib)

g &lt;- fcs(x = Cy5$f,nPoints = 2048)
len &lt;- 1:length(g)
tau &lt;-Cy5_100nM$t[len]
G&lt;-data.frame(tau,g)
G&lt;-G[-1,]

# Once the correlation curve 'g' has been generated,
# a data frame containing known parameters must be then defined

df&lt;-data.frame(G, s = 0.27, k = 3)
head(df)

# The radius of the focal volume must computed experimentally.
# For this example, we choose a s = 0.27~ mu m
# Then, three lists that contain the initial values of the data,
# as well as the upper and lower limits of these values, must be defined.
# The input values here are the expected values for the real experimental data
# to be very similar or close to, so that the function calculates them accurately.
# Initial values:

start &lt;- list(D = 100, G0 = 0.1)
up &lt;- list(D = 1E3, G0 = 10)
low &lt;- list(D = 1E-1, G0 = 1E-2)

# Once the known parameters are defined, we now proceed to use the fitFCS() function.
# The result will be a nls object

modelFCS &lt;- fitFCS(df, start, low, up, type = "D3D", trace = F)
# summary(modelFCS)

# By using the predict() function, the object generated in the previous step
# is transformed into a vector that contains the curve fitted by the desired model.

fit &lt;- predict(modelFCS, tau)

# Finally, use the following command to obtain the resulting graph,
# where the blue line corresponds to the fitted data and the black surface
# corresponds to the unfitted

plot (G, log = "x", type = "l", xlab = expression(tau(s)),
      ylab = expression(G(tau)), main = "Cy5")
lines(fit~G$tau, col = "blue")

# To acquire access to the physical coefficients of the model type

s&lt;-summary(modelFCS)
s$coefficients[,1]

</code></pre>

<hr>
<h2 id='gcf'>General Correlation Function</h2><span id='topic+gcf'></span>

<h3>Description</h3>

<p>Performs either the auto-correlation or cross-correlation between vectors x and y, returning a correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcf(x, y, xmean = 1, ymean = 1, c = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcf_+3A_x">x</code></td>
<td>
<p>A numerical signal with dimensions M x N x Z.</p>
</td></tr>
<tr><td><code id="gcf_+3A_y">y</code></td>
<td>
<p>A numerical signal with dimensions M x N x Z.</p>
</td></tr>
<tr><td><code id="gcf_+3A_xmean">xmean</code></td>
<td>
<p>The mean value of the signal x.</p>
</td></tr>
<tr><td><code id="gcf_+3A_ymean">ymean</code></td>
<td>
<p>The mean value of the signal y.</p>
</td></tr>
<tr><td><code id="gcf_+3A_c">c</code></td>
<td>
<p>A numeric variable to restrict the correlation to positives values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of emission events per unit time is determined and used to generate autocorrelation and cross-correlation curves from the intensity traces F(t) and the fluctuations deltaF(t) = F(t)-&lt;F(t)&gt;.
The auto-correlation function of the collected data set, is computed as the normalized auto-correlation function, when y=x. The general auto-correlation function is defined as:
G(tau) = (deltaF(t) deltaF(t+tau) )/(&lt;F(t)&gt; &lt;F(t)&gt;),
where t refers to a time point of fluorescence acquisition, and tau refers to the temporal delay between acquisitions. &lt;...&gt; is the temporal average of F(t); and deltaF(t) = F(t)-&lt;F(t)&gt;, deltaF(t+tau) = F(t+tau)-&lt;F(t)&gt;.
</p>
<p>For temporal acquisitions such as point FCS, x and y are F(t).
The cross-correlation function between two channels of fluorescent signals, x = F1(t) and y = F2(t), the cross-correlation function is defined as:
G(tau) = (deltaF1(t) deltaF2(t+tau) )/(&lt;F1(t)&gt;&lt;F2(t)&gt;),
where xmean = &lt;F1(t)&gt; and ymean = &lt;F2(t)&gt; are the mean values of the fluorescent signals.
</p>


<h3>Value</h3>

<p>G   A numerical signal with dimension N' x M' x Z'
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>References</h3>

<p>Siegel, A. P., Hays, N. M., &amp; Day, R. N. (2013). Unraveling transcription factor interactions with heterochromatin protein 1 using fluorescence lifetime imaging microscopy and fluorescence correlation spectroscopy. Journal of biomedical optics, 18(2), 025002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fcs">fcs</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the FCSlib package

library(FCSlib)

# As an example, we will use data from experiment adquisition
# of free Cy5 molecules diffusing in water at a concentration of 100 nM.

oldpar &lt;- par(no.readonly = TRUE)
g &lt;- gcf(x = Cy5$f, y = Cy5$f, xmean = mean(Cy5$f), ymean = mean(Cy5$f))
length &lt;- 1:length(g)
par(mfrow=c(1,1))
plot(y = g, x = Cy5$t[length], log = 'x', type = 'l',
xlab = expression(tau(mu~s)), ylab = expression(G(tau)),
main = "Cy5 100nM")
par(oldpar)

</code></pre>

<hr>
<h2 id='nbline'>Number &amp; Brightness (Single Image)</h2><span id='topic+nbline'></span>

<h3>Description</h3>

<p>Performs the Number and Brightness Analysis (N&amp;B) on an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbline(img, sigma0 = 0, offset = 0, S = 1, w = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbline_+3A_img">img</code></td>
<td>
<p>The image to analyze.</p>
</td></tr>
<tr><td><code id="nbline_+3A_sigma0">sigma0</code></td>
<td>
<p>Variance of the optical system readout noise</p>
</td></tr>
<tr><td><code id="nbline_+3A_offset">offset</code></td>
<td>
<p>Constant number that depends on the optical system configuration. Signal values smaller that the offset should be considered zero.</p>
</td></tr>
<tr><td><code id="nbline_+3A_s">S</code></td>
<td>
<p>Proportionality factor S. Indicates the ratio between the amount inicident photons in the detector and those converted to an electronic signal.</p>
</td></tr>
<tr><td><code id="nbline_+3A_w">w</code></td>
<td>
<p>Time window at which the running average is calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Number and Brightness (N&amp;B) method is a time-independent technique that provides an estimate of molecular concentration and aggregation state (or stoichiometry), based on the statistical moments of the fluorescence intensity fluctuations. In other words, this tool allows to distinguish between two or more homo-oligomeric states of a molecule present in a given region in the sample (Brightness) while also providing a direct indicator of the molecules relative abundance (Number).
The intensity of the fluorescence signal is mostly due to the mere presence of fluorophores in the media, affected by the fluorophore quantum yield, the sensitivity of the detector and the photophysical characteristics of the optical instrumentation.
The average particle number and brightness are calculated directly from the mean value &lt;k&gt; and variance (sigma^2) of the fluorescence intensity data (image) for a given pixel as follows: 
N = (&lt;k&gt;^2)/(sigma^2)
and
B = (sigma^2)/&lt;k&gt;
</p>


<h3>Value</h3>

<p>A list containing two vectors, the Brightness and the Number of the image.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a>, <a href="base.html#topic+mean">mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### Load the FCSlib package

library(FCSlib)

# As an example, we will use a data set that corresponds
# to a population of Venus dimers and hexamers diffusing in HEK-293 cells.
# Use the readFileTiff() function to extract the information from the '.tiff' files.

nbv2 &lt;- nbline(V2)
pixelSize = 0.05
r&lt;- (1:dim(V2)[1])*pixelSize

</code></pre>

<hr>
<h2 id='norm.vector'>Min-Max Feature scaling normalization</h2><span id='topic+norm.vector'></span>

<h3>Description</h3>

<p>Normalizes a vector using the Min-Max Feature scaling method (a.k.a unity-based normalization)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.vector(x, a.b = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.vector_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="norm.vector_+3A_a.b">a.b</code></td>
<td>
<p>A vector that indicates the minimum and maximum scaling values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Feature scaling is used to bring all values into the range [0,1]. This is also called unity-based normalization.
When 'a.b = NULL' (default), the highest and lowest values in 'x' will turn to 1 and 0, respectively, while all values in between will be re-scaled.
Defining 'a.b' will bring all values into the range [a,b].
</p>


<h3>Value</h3>

<p>A normalized vector
</p>


<h3>Author(s)</h3>

<p>Alejandro Linares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from = 1, to = 100, by = 0.1)
y &lt;- sin(sqrt(x))
plot(y~x, type = "l")

y.n &lt;- norm.vector(y)
plot(y.n~x, type = "l")

y.ab &lt;- norm.vector(y, a.b = c(5,20))
plot(y.ab~x, type = "l")

</code></pre>

<hr>
<h2 id='pcf'>Pair Correlation Function</h2><span id='topic+pcf'></span>

<h3>Description</h3>

<p>Calculates the correlation between the pixel i and pixel i + dr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcf(img, nPoints = 1000, one.col = FALSE, dr = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcf_+3A_img">img</code></td>
<td>
<p>The image to analyze</p>
</td></tr>
<tr><td><code id="pcf_+3A_npoints">nPoints</code></td>
<td>
<p>The size of the sub-vectors in which the input vectors will be divided. This number must be less than N/2.</p>
</td></tr>
<tr><td><code id="pcf_+3A_one.col">one.col</code></td>
<td>
<p>By default FALSE. If TRUE the correlation will be performed in the fixed colum mode, else the distance mode.</p>
</td></tr>
<tr><td><code id="pcf_+3A_dr">dr</code></td>
<td>
<p>Distance between pixel at which the correlation is calculated. For a value of delta_r = 3, the columns are correlated as follows: (1,4), (2,5), ..., (n-3, n), with n being the last column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair correlation function (pCF) analyzes data of a periodically scanned line, measuring the time it takes a particle to go from one pixel to another, i.e. calculates the spatial cross-correlation function
between pixels.
G(tau,deltar) = (&lt;F(t,0) F(t + tau, deltar)&gt;/&lt;F(t,0)&gt; &lt;F(t,deltar)&gt;)-1
</p>


<h3>Value</h3>

<p>An image depicting the correlation between the pixel i and pixel i + dr.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fcs">fcs</a>, <a href="#topic+pcomb">pcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Load the FCSlib package

library(FCSlib)

### As an example, we will use a data set that corresponds to a population of Venus dimers
# diffusing in HEK-293 cells. Use the readFileTiff() function to extract the information
# from the '.tiff' files.

dmv2 &lt;- data.matrix(V2)
pB &lt;- pcf(dmv2, nPoints = 2500, dr = 10)

### Plot the result
library(fields)
di &lt;- dim(pB)
tau &lt;- (1:(di[2]))
image.plot( x = 1:di[1], y = log10(tau), z = pB, main = "Column Distance 10",
xlab = "Pixel", ylab = "Logarithmic tau",
cex.lab = 1.2, cex.main = 1.2, cex.axis = 1)

</code></pre>

<hr>
<h2 id='pcomb'>Pair Correlation of Molecular Brightness</h2><span id='topic+pcomb'></span>

<h3>Description</h3>

<p>Performs the pair correlation of molecular brightness (pCOMB) analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcomb(img, nPoints = 25000, one.col = FALSE, dr = 1, w = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcomb_+3A_img">img</code></td>
<td>
<p>The image to analyze.</p>
</td></tr>
<tr><td><code id="pcomb_+3A_npoints">nPoints</code></td>
<td>
<p>The size of the sub-vectors in which the input vectors will be divided. This number must be less than N/2.</p>
</td></tr>
<tr><td><code id="pcomb_+3A_one.col">one.col</code></td>
<td>
<p>By default FALSE. If TRUE the correlation will be performed in the fixed colum mode, else the distance mode.</p>
</td></tr>
<tr><td><code id="pcomb_+3A_dr">dr</code></td>
<td>
<p>Is the distance between the two columns that will be correlated. For a value of deltar = 3, the columns are correlated as follows: (1,4), (2,5), ..., (n-3, n), with n as the last column.</p>
</td></tr>
<tr><td><code id="pcomb_+3A_w">w</code></td>
<td>
<p>Range value that is used to calculate the brightness in the image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the Pair Correlation of Molecular Brightness (pCOMB) method, one can distinguish between different homo-oligomeric species of the same molecule coexisting in the same microenvironment, while separately and specifically tracking each species' moblity across the cellular compartments. This technique amplifies the signal from the brightest species present and filters the dynamics of the extracted oligomeric population based on arrival time between two locations. This method is suitable for mapping the impact oligomerization on transcription factor dynamics.
The resulting intensity fluctuations, pCF, are transformed into brightness fluctuations using B = (sigma^2)/mean, and the pair correlation analysis is then performed on the brightness fluctuations along the line scan , at a distance (delta(r)).
</p>
<p>If the pcf is set as FALSE the pComb data will not be generated and will be NULL. In order to generate that data the pcf function must be used on the BCarpet data.
</p>


<h3>Value</h3>

<p>A list containing the Brightness Carpet and the Pair Correlation of that carpet
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fcs">fcs</a>, <a href="#topic+pcf">pcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Load the FCSlib package

library(FCSlib)

# As an example, we will use a data set that corresponds to a population of Venus dimers
# diffusing in HEK-293 cells. Use the readFileTiff() function to extract the information
# from the '.tiff' files.

dmv2 &lt;- data.matrix(V2)
pC &lt;- pcomb(dmv2[1:32,1:2001], nPoints = 1000, type = 'd', dr = 10, w = 2, pcf = FALSE)
dmv2 &lt;- data.matrix(v2DataSet)
pC &lt;- pcomb(dmv2, nPoints = 5000, type = 'd', dr = 10, w = 100)
di &lt;- dim(pC$pComb)
tau &lt;- (1:(di[2]))

# Plot the result
library("fields")
image.plot( x = 1:di[1], y = log10(tau), z = pC$pComb, main = "pComb",
xlab = "Pixel", ylab = "Logarithmic tau",
cex.lab = 1.2, cex.main = 1.2, cex.axis = 1)

</code></pre>

<hr>
<h2 id='readFileFCS'>Read File FCS</h2><span id='topic+readFileFCS'></span>

<h3>Description</h3>

<p>Reads a FCS file and returns the data sets within the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFileFCS(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFileFCS_+3A_filename">filename</code></td>
<td>
<p>the name of the file to read from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a FCS file using the scan function and extract the data contained in the file.
</p>


<h3>Value</h3>

<p>dataList   A list containing the data sets within the file.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raw_fcs &lt;- readFileFCS(FileName)

</code></pre>

<hr>
<h2 id='readFileModel'>Read File Model</h2><span id='topic+readFileModel'></span>

<h3>Description</h3>

<p>Reads a txt file and returns the parameters and the model (equation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFileModel(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFileModel_+3A_filename">filename</code></td>
<td>
<p>The name of the file to read from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a txt file using the scan function and extracts the parameters and the model (equation) in the file.
</p>


<h3>Value</h3>

<p>params   A list containing the parameters as well as the model.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitFCS">fitFCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
modelData &lt;- readFileModel(filename)

</code></pre>

<hr>
<h2 id='readFileSPC'>Read File SPC-140/150/130/830</h2><span id='topic+readFileSPC'></span>

<h3>Description</h3>

<p>Reads a SPC file and returns the Macrotime and Microtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFileSPC(filename, nData = 1E8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFileSPC_+3A_filename">filename</code></td>
<td>
<p>the name of the file to read from.</p>
</td></tr>
<tr><td><code id="readFileSPC_+3A_ndata">nData</code></td>
<td>
<p>parameter that defines the length of data to read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a SPC file, with SPC-140/150/130/830 version, using the readBin function and extract the data contained in the file.
</p>


<h3>Value</h3>

<p>A list containing the Macrotime and the Microtime vectors.
</p>


<h3>Note</h3>

<p>The nData parameter is used to overestimate the amount of data that the file can contain.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara, José Damián Martínez Reyes.
</p>


<h3>References</h3>

<p>Becker, W., 2019. The Bh TCSPC Handbook. 8th ed. Berlin, Germany: Becker &amp; Hickl GmbH, pp. 855-856.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asynACTCSPC">asynACTCSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spcData &lt;- readFileSPC(FileName)

</code></pre>

<hr>
<h2 id='readFileTiff'>Read File Tiff</h2><span id='topic+readFileTiff'></span>

<h3>Description</h3>

<p>Reads a TIFF file and converts it into a 2D-array. If the file contains multiple pages, a 3D-array will be then returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFileTiff(filename, invert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFileTiff_+3A_filename">filename</code></td>
<td>
<p>Either name of the file to read from or a raw vector representing the TIFF file content.</p>
</td></tr>
<tr><td><code id="readFileTiff_+3A_invert">invert</code></td>
<td>
<p>If set to TRUE then the order of the data will be reversed. Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a TIFF file image using readTIFF and converts it to a matrix with n-dimensions.
</p>


<h3>Value</h3>

<p>A matrix containing the image data.
</p>


<h3>Note</h3>

<p>This function must be used in order to extract the information from the TIFF files needed to test the functions in this package. The TIFF file must be grayscale.
</p>


<h3>Author(s)</h3>

<p>Adan O. Guerrero Cardenas.
</p>


<h3>See Also</h3>

<p><code>readTIFF</code> <code><a href="#topic+writeFileTiff">writeFileTiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
raw &lt;- readFileTiff(FileName)

</code></pre>

<hr>
<h2 id='simplifyFCS'>Simplify FCS</h2><span id='topic+simplifyFCS'></span>

<h3>Description</h3>

<p>Reduces the amount of data in a data set without altering its overall structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyFCS(g, tau, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifyFCS_+3A_g">g</code></td>
<td>
<p>A vector containing the FCS data analysis</p>
</td></tr>
<tr><td><code id="simplifyFCS_+3A_tau">tau</code></td>
<td>
<p>A vector that represents the time frame between data acquisitions</p>
</td></tr>
<tr><td><code id="simplifyFCS_+3A_step">step</code></td>
<td>
<p>A numeric value that affects the final length of the vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplifyFCS function performs a log10 weighted binning of the autocorrelation function (acf). It balance the weight of the long-time scale trending behavior of the acf curve, which commonly contain G(tau) points that fluctuate around the zero-correlation regime, hence overweighting fitting with ‘noisy data’. simplifyFCS reduce the weight of the long-time scale trending behavior (ms to sec), preserving the structure of the short-time scales.
</p>


<h3>Value</h3>

<p>A vector of the FCS data with reduced length
</p>


<h3>Note</h3>

<p>the step parameter must be between 0 and 1
</p>


<h3>Author(s)</h3>

<p>Adan O. Guerrero
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcf">gcf</a></code>, <code><a href="stats.html#topic+var">var</a>, <a href="base.html#topic+mean">mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- Cy5_100nM$f
acqTime &lt;- 2E-6
f &lt;- as.vector(f)
time &lt;- (1:length(f))*acqTime
cy5 &lt;- data.frame(t = time, f)

g &lt;- fcs(x = cy5$f)
len &lt;- 1:length(g)
tau &lt;-cy5$t[len]
G &lt;- data.frame(tau,g)

sfcs &lt;- simplifyFCS(G$g, G$tau, step = 0.5)
plot(sfcs$g~sfcs$tau, log = "x", type = "l",
     xlab = expression(tau(s)),
     ylab = expression(G(tau)), main = "Cy5")

# Comparison, original with simplify
plot(G, type = 'l', log = 'x')
lines(sfcs$g~sfcs$tau, col = "red")

</code></pre>

<hr>
<h2 id='smoothCarpet'>Smooth Carpet (Single Image)</h2><span id='topic+smoothCarpet'></span>

<h3>Description</h3>

<p>Generates a smooth carpet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothCarpet(img, dfV = 0, dfH = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothCarpet_+3A_img">img</code></td>
<td>
<p>The image to analyze.</p>
</td></tr>
<tr><td><code id="smoothCarpet_+3A_dfv">dfV</code></td>
<td>
<p>The desired equivalent number of degrees of freedom in the vertical axis.</p>
</td></tr>
<tr><td><code id="smoothCarpet_+3A_dfh">dfH</code></td>
<td>
<p>The desired equivalent number of degrees of freedom in the horizontal axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smoothCarpet function makes use of the smooth.spline method to smooth the vertical and horizontal axes of an image.
The magnitude of the smoothing depends on the degrees of freedom set for and vertical ('dfV') and horizontal ('dfH') axes of the image.
</p>


<h3>Value</h3>

<p>Smooth Carpet   A smooth image.
</p>


<h3>Author(s)</h3>

<p>Raúl Pinto Cámara.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcomb">pcomb</a>, <a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Load the FCSlib package

library(FCSlib)

### As an example, we will use a data set that corresponds to a population of Venus dimers
# diffusing in HEK-293 cells. Use the readFileTiff() function to extract the information
# from the '.tiff' files.

v2 &lt;- data.matrix(V2)
nbv2 &lt;- nbline(img = v2, S=3.5, sigma0 = 1,offset = 0, wSigma = 100);
sC &lt;- smoothCarpet(img = nbv2$number, dfV = 5, dfH = 5)

</code></pre>

<hr>
<h2 id='tiff_to_mtx'>Transformation of multiple-image TIFF files or arrays into a matrix</h2><span id='topic+tiff_to_mtx'></span>

<h3>Description</h3>

<p>Transforms multiple-image TIFF files or 3D arrays into 2D matrices with a user-specified number of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiff_to_mtx(data, columns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiff_to_mtx_+3A_data">data</code></td>
<td>
<p>A character string indicating the name of a TIFF file or a 3D array</p>
</td></tr>
<tr><td><code id="tiff_to_mtx_+3A_columns">columns</code></td>
<td>
<p>The number of columns of the resulting matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a matrix with a user-specified number of columns and a number of rows equal to the total amount of points in 'data' divided by 'columns'.
</p>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Author(s)</h3>

<p>Alejandro Linares
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binMatrix">binMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Please navigate to
### (https://github.com/FCSlib/FCSlib/tree/master/Sample%20Data)
### to find this sample data

x &lt;- readFileTiff("Example_file_name.tif")
class(x); dim(x)

x.m &lt;- tiff_to_mtx(data = x, columns = 64)
class(x.m); dim(x.m)

</code></pre>

<hr>
<h2 id='V2'>Line-scan data of HEK-293 cells expressing Venus (EYFP) dimers</h2><span id='topic+V2'></span>

<h3>Description</h3>

<p>This data set consists on a raster line scan performed over HEK-293 cells expressing dimers of the fluorescent protein Venus, also known as SEYFP-F46L.
The scan line is 64 pixels long, and the scanning direction is from the cytoplasm to the nucleus, across the nuclear envelope.
A pixel size of 50 nm was used, as well as a pixel dwell time of 12.5 us and a line scan time of 1.925 ms.
Fluorescence excitation was provided by a 488 nm laser at 0.1
Fluorescence intensity data was collected using the photon-counting mode in an Olympus FV1000 Upright BX61WI confocal microscope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(V2)
</code></pre>


<h3>Format</h3>

<p>A matrix with 64 rows and 25000 columns
</p>


<h3>Details</h3>

<p>To analyze this data set with FCSlib, import by typing: readFileTiff(&quot;V2.tif&quot;)[,,1]
</p>

<hr>
<h2 id='writeFileTiff'>Write File Tiff</h2><span id='topic+writeFileTiff'></span>

<h3>Description</h3>

<p>Create a TIFF file from a 3D-array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFileTiff(img,  file.name, invert = TRUE, bits.per.sample = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFileTiff_+3A_img">img</code></td>
<td>
<p>Either an image or a list of images. An image is a real matrix or array of three dimensions.</p>
</td></tr>
<tr><td><code id="writeFileTiff_+3A_file.name">file.name</code></td>
<td>
<p>Either the name of the file or the name of a raw vector.</p>
</td></tr>
<tr><td><code id="writeFileTiff_+3A_invert">invert</code></td>
<td>
<p>If set to TRUE then the order of the data will be reversed. Default TRUE.</p>
</td></tr>
<tr><td><code id="writeFileTiff_+3A_bits.per.sample">bits.per.sample</code></td>
<td>
<p>Number of bits per sample (numeric scalar). Supported values in this version are 8, 16, and 32.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a TIFF file using writeTIFF, converting a 2D-array. If the file contains multiple pages, a 3D-array is turned into a 2D-array to implement the aforementioned function.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adan O. Guerrero Cardenas.
</p>


<h3>References</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code>writeTIFF</code> <code><a href="#topic+readFileTiff">readFileTiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imagsave &lt;- array(data = 1:10, dim = c(100,100,10))
writeFileTiff(imagsave, paste(tempdir(), "/image_Test.tif", sep = ""))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
