<!DOCTYPE html><html lang="en"><head><title>Help for package DSWE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DSWE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMK'><p>Additive Multiplicative Kernel Regression</p></a></li>
<li><a href='#ComparePCurve'><p>Power curve comparison</p></a></li>
<li><a href='#ComputeWeightedDifference'><p>Percentage weighted difference between power curves</p></a></li>
<li><a href='#CovMatch'><p>Covariate Matching</p></a></li>
<li><a href='#data1'><p>Wind Energy data set containing 47,542 data points</p></a></li>
<li><a href='#data2'><p>Wind Energy data set containing 48,068 data points</p></a></li>
<li><a href='#deltaEnergy'><p>Energy decomposition for wind turbine performance comparison</p></a></li>
<li><a href='#funGP'><p>Function comparison using Gaussian Process and Hypothesis testing</p></a></li>
<li><a href='#imptPower'><p>Power imputation</p></a></li>
<li><a href='#KnnPCFit'><p>KNN : Fit</p></a></li>
<li><a href='#KnnPredict'><p>KNN : Predict</p></a></li>
<li><a href='#KnnUpdate'><p>KNN : Update</p></a></li>
<li><a href='#predict.tempGP'><p>predict from temporal Gaussian process</p></a></li>
<li><a href='#SplinePCFit'><p>Smoothing spline Anova method</p></a></li>
<li><a href='#SvmPCFit'><p>SVM based power curve modelling</p></a></li>
<li><a href='#syncSize'><p>Data synchronization</p></a></li>
<li><a href='#tempGP'><p>temporal Gaussian process</p></a></li>
<li><a href='#updateData'><p>Updating data in a model</p></a></li>
<li><a href='#updateData.tempGP'><p>Update the data in a tempGP object</p></a></li>
<li><a href='#XgbPCFit'><p>xgboost based power curve modelling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Data Science for Wind Energy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Data science methods used in wind energy applications. 
              Current functionalities include creating a multi-dimensional power curve model, 
              performing power curve function comparison, covariate matching, and energy decomposition. 
              Relevant works for the developed functions are: 
              funGP() - Prakash et al. (2022) &lt;<a href="https://doi.org/10.1080%2F00401706.2021.1905073">doi:10.1080/00401706.2021.1905073</a>&gt;, 
              AMK() - Lee et al. (2015) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.977385">doi:10.1080/01621459.2014.977385</a>&gt;, 
              tempGP() - Prakash et al. (2022) &lt;<a href="https://doi.org/10.1080%2F00401706.2022.2069158">doi:10.1080/00401706.2022.2069158</a>&gt;, 
              ComparePCurve() - Ding et al. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.renene.2021.02.136">doi:10.1016/j.renene.2021.02.136</a>&gt;,
              deltaEnergy() - Latiffianti et al. (2022) &lt;<a href="https://doi.org/10.1002%2Fwe.2722">doi:10.1002/we.2722</a>&gt;,
              syncSize() - Latiffianti et al. (2022) &lt;<a href="https://doi.org/10.1002%2Fwe.2722">doi:10.1002/we.2722</a>&gt;,
              imptPower() - Latiffianti et al. (2022) &lt;<a href="https://doi.org/10.1002%2Fwe.2722">doi:10.1002/we.2722</a>&gt;,
              All other functions - Ding (2019, ISBN:9780429956508).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TAMU-AML/DSWE-Package">https://github.com/TAMU-AML/DSWE-Package</a>,
<a href="https://aml.engr.tamu.edu/book-dswe/">https://aml.engr.tamu.edu/book-dswe/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TAMU-AML/DSWE-Package/issues">https://github.com/TAMU-AML/DSWE-Package/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.4.6) , RcppArmadillo (&ge; 0.9.870.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.4.6) , matrixStats (&ge; 0.55.0) , FNN (&ge; 1.1.3) ,
KernSmooth (&ge; 2.23-16) , mixtools (&ge; 1.1.0), gss (&ge; 2.2-2),
e1071 (&ge; 1.7-3), stats (&ge; 3.5.0), dplyr (&ge; 1.0.9), xgboost
(&ge; 1.7.7.1)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 11:31:00 UTC; 19797</td>
</tr>
<tr>
<td>Author:</td>
<td>Nitesh Kumar [aut],
  Abhinav Prakash [aut],
  Yu Ding [aut, cre],
  Effi Latiffianti [ctb, cph],
  Ahmadreza Chokhachian [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yu Ding &lt;yuding2007@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMK'>Additive Multiplicative Kernel Regression</h2><span id='topic+AMK'></span>

<h3>Description</h3>

<p>An additive multiplicative kernel regression based on Lee et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMK(
  trainX,
  trainY,
  testX,
  bw = "dpi_gap",
  nMultiCov = 3,
  fixedCov = c(1, 2),
  cirCov = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AMK_+3A_trainx">trainX</code></td>
<td>
<p>a matrix or dataframe of input variable values in the training dataset.</p>
</td></tr>
<tr><td><code id="AMK_+3A_trainy">trainY</code></td>
<td>
<p>a numeric vector for response values in the training dataset.</p>
</td></tr>
<tr><td><code id="AMK_+3A_testx">testX</code></td>
<td>
<p>a matrix or dataframe of test input variable values to compute predictions.</p>
</td></tr>
<tr><td><code id="AMK_+3A_bw">bw</code></td>
<td>
<p>a numeric vector or a character input for bandwidth. If character, bandwidth computed internally; the input should be either <code>'dpi'</code> or <code>'dpi_gap'</code>. Default is <code>'dpi_gap'</code>. See <code>details</code> for more information.</p>
</td></tr>
<tr><td><code id="AMK_+3A_nmulticov">nMultiCov</code></td>
<td>
<p>an integer or a character input specifying the number of multiplicative covariates in each additive term. Default is 3 (same as Lee et al., 2015). The character inputs can be: <code>'all'</code> for a completely multiplicative model, or <code>'none'</code> for a completely additive model. Ignored if the number of covariates is 1.</p>
</td></tr>
<tr><td><code id="AMK_+3A_fixedcov">fixedCov</code></td>
<td>
<p>an integer vector specifying the fixed covariates column number(s), default value is <code>c(1,2)</code>. Ignored if <code>nMultiCov</code> is set to <code>'all'</code> or <code>'none'</code> or if the number of covariates is less than 3.</p>
</td></tr>
<tr><td><code id="AMK_+3A_circov">cirCov</code></td>
<td>
<p>an integer vector specifying the circular covariates column number(s) in <code>trainX</code>, default value is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on Lee et al. (2015). Main features  are: 
</p>

<ul>
<li><p> Flexible number of multiplicative covariates in each additive term, which can be set using <code>nMultiCov</code>.
</p>
</li>
<li><p> Flexible number and columns for fixed covariates, which can be set using <code>fixedCov</code>. The default option <code>c(1,2)</code> sets the first two columns as fixed covariates in each additive term.
</p>
</li>
<li><p> Handling the data with gaps when the direct plug-in estimator used in Lee et al. fails to return a finite bandwidth. This is set using the option <code>bw = 'dpi_gap'</code> for bandwidth estimation.  
</p>
</li></ul>



<h3>Value</h3>

<p>a numeric vector for predictions at the data points in <code>testX</code>.
</p>


<h3>References</h3>

<p>Lee, Ding, Genton, and Xie, 2015, “Power curve estimation with multivariate environmental factors for inland and offshore wind farms,” Journal of the American Statistical Association, Vol. 110, pp. 56-67, <a href="https://doi.org/10.1080/01621459.2014.977385">doi:10.1080/01621459.2014.977385</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data1
trainX = as.matrix(data[c(1:100),2])
trainY = data[c(1:100),7]
testX = as.matrix(data[c(101:110),2])
AMK_prediction = AMK(trainX, trainY, testX, bw = 'dpi_gap', cirCov = NA)

</code></pre>

<hr>
<h2 id='ComparePCurve'>Power curve comparison</h2><span id='topic+ComparePCurve'></span>

<h3>Description</h3>

<p>Power curve comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComparePCurve(
  data,
  xCol,
  xCol.circ = NULL,
  yCol,
  testCol,
  testSet = NULL,
  thrs = 0.2,
  conflevel = 0.95,
  gridSize = c(50, 50),
  powerbins = 15,
  baseline = 1,
  limitMemory = TRUE,
  opt_method = "nlminb",
  sampleSize = list(optimSize = 500, bandSize = 5000),
  rngSeed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComparePCurve_+3A_data">data</code></td>
<td>
<p>A list of data sets to be compared, the difference in the mean function is always computed as (f(data2) - f(data1))</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_xcol">xCol</code></td>
<td>
<p>A numeric or vector stating column number of covariates</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_xcol.circ">xCol.circ</code></td>
<td>
<p>A numeric or vector stating column number of circular covariates</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_ycol">yCol</code></td>
<td>
<p>A numeric value stating the column number of the response</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_testcol">testCol</code></td>
<td>
<p>A numeric/vector stating column number of covariates to used in generating test set. Maximum of two columns to be used.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_testset">testSet</code></td>
<td>
<p>A matrix or dataframe consisting of test points, default value NULL, if NULL computes test points internally using testCol variables. If not NULL, total number of test points must be less than or equal to 2500.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_thrs">thrs</code></td>
<td>
<p>A numeric or vector representing threshold for each covariates</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_conflevel">conflevel</code></td>
<td>
<p>A numeric between (0,1) representing the statistical significance level for constructing the band</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_gridsize">gridSize</code></td>
<td>
<p>A numeric / vector to be used in constructing test set, should be provided when testSet is NuLL, else it is ignored. Default is <code>c(50,50)</code> for 2-dim input which is converted internally to a default of <code>c(1000)</code> for 1-dim input. Total number of test points (product of gridSize vector components) must be less than or equal to 2500.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_powerbins">powerbins</code></td>
<td>
<p>A numeric stating the number of power bins for computing the scaled difference, default is 15.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_baseline">baseline</code></td>
<td>
<p>An integer between 0 to 2, where 1 indicates to use power curve of first dataset as the base for metric calculation, 2 indicates to use the power curve of second dataset as the base, and 0 indicates to use the average of both power curves as the base. Default is set to 1.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_limitmemory">limitMemory</code></td>
<td>
<p>A boolean (True/False) indicating whether to limit the memory use or not. Default is true. If set to true, 5000 datapoints are randomly sampled from each dataset under comparison for inference</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_opt_method">opt_method</code></td>
<td>
<p>A string specifying the optimization method to be used for hyperparameter estimation. Current options are: <code>'L-BFGS-B'</code>, <code>'BFGS'</code>, and <code>'nlminb'</code>. Default is set to <code>'nlminb'</code>.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_samplesize">sampleSize</code></td>
<td>
<p>A named list of two integer items: <code>optimSize</code> and <code>bandSize</code>, denoting the sample size for each dataset for hyperparameter optimization and confidence band computation, respectively, when <code>limitMemory = TRUE</code>. Default value is <code>list(optimSize = 500, bandSize = 5000)</code>.</p>
</td></tr>
<tr><td><code id="ComparePCurve_+3A_rngseed">rngSeed</code></td>
<td>
<p>Random seed for sampling data when <code>limitMemory = TRUE</code>. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> weightedDiff - a numeric,  % difference between the functions weighted using the density of the covariates
</p>
</li>
<li><p> weightedStatDiff - a numeric, % statistically significant difference between the functions weighted using the density of the covariates
</p>
</li>
<li><p> scaledDiff -  a numeric, % difference between the functions scaled to the orginal data
</p>
</li>
<li><p> scaledStatDiff - a numeric, % statistically significant difference between the functions scaled to the orginal data
</p>
</li>
<li><p> unweightedDiff - a numeric,  % difference between the functions unweighted
</p>
</li>
<li><p> unweightedStatDiff - a numeric,  % statistically significant difference between the functions unweighted
</p>
</li>
<li><p> reductionRatio -  a list consisting of shrinkage ratio of features used in testSet
</p>
</li>
<li><p> mu1 - a vector of prediction on testset using the first data set
</p>
</li>
<li><p> mu2 - a vector of prediction on testset using the second data set
</p>
</li>
<li><p> muDiff - a vector of the difference in prediction (mu2 - mu1) for each test point
</p>
</li>
<li><p> band - a vector for the confidence band at all the testpoints for the two functions to be the same at a given cofidence level.
</p>
</li>
<li><p> confLevel - a numeric representing the statistical significance level for constructing the band
</p>
</li>
<li><p> testSet - a vector/matrix of the test points either provided by user, or generated internally
</p>
</li>
<li><p> estimatedParams - a list of estimated hyperaparameters for the Gaussian process model
</p>
</li>
<li><p> matchedData - a list of two matched datasets as generated by covariate matching
</p>
</li></ul>



<h3>References</h3>

<p>For details, see Ding et al. (2021) available <a href="https://doi.org/10.1016/j.renene.2021.02.136">doi:10.1016/j.renene.2021.02.136</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 = data1[1:100, ]
data2 = data2[1:100, ]
data = list(data1, data2)
xCol = 2
xCol.circ = NULL
yCol = 7
testCol = 2
testSet = NULL
thrs = 0.2
confLevel = 0.95
gridSize = 20
function_comparison = ComparePCurve(data, xCol, xCol.circ, yCol,
testCol, testSet, thrs, confLevel, gridSize)

</code></pre>

<hr>
<h2 id='ComputeWeightedDifference'>Percentage weighted difference between power curves</h2><span id='topic+ComputeWeightedDifference'></span>

<h3>Description</h3>

<p>Computes percentage weighted difference between power curves based on user provided weights instead of the weights computed from the data. Please see <code>details</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeWeightedDifference(
  muDiff,
  weights,
  base,
  statDiff = FALSE,
  confBand = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputeWeightedDifference_+3A_mudiff">muDiff</code></td>
<td>
<p>a vector of pointwise difference between two power curves on a testset as obtained from <code>ComparePCurve()</code> or <code>funGP()</code> function.</p>
</td></tr>
<tr><td><code id="ComputeWeightedDifference_+3A_weights">weights</code></td>
<td>
<p>a vector of user specified weights for each element of <code>muDiff</code>. It can be based on any probability distribution of user's choice. The weights must sum to 1.</p>
</td></tr>
<tr><td><code id="ComputeWeightedDifference_+3A_base">base</code></td>
<td>
<p>a vector of predictions from a power curve; to be used as the denominator in computing the percentage difference. It can be either <code>mu1</code> or <code>mu2</code> as obtained from <code>ComparePCurve()</code> or <code>funGP()</code> function.</p>
</td></tr>
<tr><td><code id="ComputeWeightedDifference_+3A_statdiff">statDiff</code></td>
<td>
<p>a boolean specifying whether to compute the statistical significant difference or not. Default is set to <code>FALSE</code>, i.e. statistical significant difference is not computed. If set to <code>TRUE</code>, <code>confBand</code> must be provided.</p>
</td></tr>
<tr><td><code id="ComputeWeightedDifference_+3A_confband">confBand</code></td>
<td>
<p>a vector of pointwise confidence band for all the points in the testset as obtained from <code>ComparePCurve()</code> or <code>funGP()</code> function, named as <code>band</code>. Should only be provided when <code>statDiff</code> is set to <code>TRUE</code>. Default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a modification to the percentage weighted difference defined in Ding et al. (2021). It computes a weighted difference between power curves on a testset, where the weights have to be provided by the user based on any probability distribution of their choice rather than the weights being computed from the data. The weights must sum to 1 to be valid.
</p>


<h3>Value</h3>

<p>a numeric percentage weighted difference or statistical significant percetage weighted difference based on whether statDiff is set to <code>FALSE</code> or <code>TRUE</code>.
</p>


<h3>References</h3>

<p>For details, see Ding et al. (2021) available at <a href="https://doi.org/10.1016/j.renene.2021.02.136">doi:10.1016/j.renene.2021.02.136</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ws_test = as.matrix(seq(4.5,8.5,length.out = 10))

userweights = dweibull(ws_test, shape = 2.25, scale = 6.5) 
userweights = userweights/sum(userweights) 
data1 = data1[1:100, ]
data2 = data2[1:100, ]
datalist = list(data1, data2)
xCol = 2
xCol.circ = NULL
yCol = 7
testCol = 2
output = ComparePCurve(data = datalist, xCol = xCol, yCol = yCol, 
testCol = testCol, testSet = ws_test) 
weightedDiff = ComputeWeightedDifference(output$muDiff, userweights, output$mu1)
weightedStatDiff = ComputeWeightedDifference(output$muDiff, userweights, output$mu1, 
statDiff = TRUE, confBand = output$band)

</code></pre>

<hr>
<h2 id='CovMatch'>Covariate Matching</h2><span id='topic+CovMatch'></span>

<h3>Description</h3>

<p>The function aims to take list of two data sets and returns the after
matched data sets using user specified covariates and threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovMatch(data, xCol, xCol.circ, thrs, priority)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CovMatch_+3A_data">data</code></td>
<td>
<p>a list, consisting of data sets to match, also each of the individual data set can be dataframe or a matrix</p>
</td></tr>
<tr><td><code id="CovMatch_+3A_xcol">xCol</code></td>
<td>
<p>a vector stating the column position of covariates used</p>
</td></tr>
<tr><td><code id="CovMatch_+3A_xcol.circ">xCol.circ</code></td>
<td>
<p>a vector stating the column position of circular variables</p>
</td></tr>
<tr><td><code id="CovMatch_+3A_thrs">thrs</code></td>
<td>
<p>a numerical or a vector of threshold values for each covariates, against which matching happens
It should be a single value or a vector of values representing threshold for each of the covariate</p>
</td></tr>
<tr><td><code id="CovMatch_+3A_priority">priority</code></td>
<td>
<p>a boolean, default value False, otherwise computes the sequence of matching</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> originalData - The data sets provided for matching
</p>
</li>
<li><p> matchedData - The data sets after matching
</p>
</li>
<li><p> MinMaxOriginal - The minimum and maximum value in original data for each covariate used in matching
</p>
</li>
<li><p> MinMaxMatched - The minimum and maximum value in matched data for each covariates used in matching
</p>
</li></ul>



<h3>References</h3>

<p>Ding, Y. (2019). Data Science for Wind Energy. Chapman &amp; Hall, Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 = data1[1:100, ]
data2 = data2[1:100, ]
data = list(data1, data2)
xCol = 2
xCol.circ = NULL
thrs = 0.1
priority = FALSE
matched_data = CovMatch(data, xCol, xCol.circ, thrs, priority)

</code></pre>

<hr>
<h2 id='data1'>Wind Energy data set containing 47,542 data points</h2><span id='topic+data1'></span>

<h3>Description</h3>

<p>A dataset containing the power produced and other attributes of almost 47,542
records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 47,542 rows and 7 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Data.point - sequence of integers displaying each record
</p>
</li>
<li><p> V - wind speed
</p>
</li>
<li><p> D - wind direction
</p>
</li>
<li><p> air.density - air density
</p>
</li>
<li><p> I - turbulence intensity
</p>
</li>
<li><p> S_b - wind shear
</p>
</li>
<li><p> Y - wind power
</p>
</li></ul>


<hr>
<h2 id='data2'>Wind Energy data set containing 48,068 data points</h2><span id='topic+data2'></span>

<h3>Description</h3>

<p>A dataset containing the power produced and other attributes of almost 48,068
records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 48,068 rows and 7 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Data.point - sequence of integers displaying each record
</p>
</li>
<li><p> V - wind speed
</p>
</li>
<li><p> D - wind direction
</p>
</li>
<li><p> air.density - air density
</p>
</li>
<li><p> I - turbulence intensity
</p>
</li>
<li><p> S_b - wind shear
</p>
</li>
<li><p> Y - wind power
</p>
</li></ul>


<hr>
<h2 id='deltaEnergy'>Energy decomposition for wind turbine performance comparison</h2><span id='topic+deltaEnergy'></span>

<h3>Description</h3>

<p>Energy decomposition compares energy production from two datasets and separates it into turbine effects (deltaE.turb) and weather/environment effects (deltaE.weather).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaEnergy(
  data,
  powercol,
  timecol = 0,
  xcol,
  sync.method = "minimum power",
  imput = TRUE,
  vcol = NULL,
  vrange = NULL,
  rated.power = NULL,
  sample = TRUE,
  size = 2500,
  timestamp.min = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaEnergy_+3A_data">data</code></td>
<td>
<p>A list of two data sets to be compared. A difference  is always computed as (data2 - data1).</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_powercol">powercol</code></td>
<td>
<p>A numeric stating the column number of power production.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_timecol">timecol</code></td>
<td>
<p>A numeric stating the column number of data time stamp. Default value is zero. A value other than zero should be provided when <code>sync.method = 'time'</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_xcol">xcol</code></td>
<td>
<p>A numeric or vector stating the column number(s) of power curve input covariates/features (environmental or weather variables are recommended).</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_sync.method">sync.method</code></td>
<td>
<p>A string specifying data synchronization method. Default value <code>'minimum power'</code>; other options include <code>'time'</code> and <code>'random'</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_imput">imput</code></td>
<td>
<p>A boolean (TRUE/FALSE) indicating whether power imputation should be performed before calculating energy decomposition. The recommended and default value is TRUE. Change to FALSE when data have been preprocessed or imputed before.#' @param vcol A numeric stating the column number of wind speed. It is required when <code>imput = TRUE</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_vcol">vcol</code></td>
<td>
<p>A numeric stating the column number of wind speed.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_vrange">vrange</code></td>
<td>
<p>A vector of cut-in, rated, and cut-out wind speed. Values should be provided when <code>imput = TRUE</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_rated.power">rated.power</code></td>
<td>
<p>A numerical value stating the wind turbine rated power.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_sample">sample</code></td>
<td>
<p>A boolean (TRUE/FALSE) indicating whether to use sample or the whole data sets to train the power curve to be used for power imputation. Default value is TRUE. It is only used when <code>imput = TRUE</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_size">size</code></td>
<td>
<p>A numeric stating the size of sample when <code>sample = TRUE</code>. Default value is 2500. It is only used when <code>imput = TRUE</code> and <code>sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="deltaEnergy_+3A_timestamp.min">timestamp.min</code></td>
<td>
<p>A numerical value stating the resolution of the datasets in minutes. It is the difference between two consecutive time stamps at which data were recorded. Default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> deltaE.turb - A numeric, 
</p>
</li>
<li><p> deltaE.weather - A numeric, 
</p>
</li>
<li><p> deltaE.hat - A numeric, 
</p>
</li>
<li><p> deltaE.obs - A numeric, 
</p>
</li>
<li><p> estimated.energy - A numeric vector of the total energy calculated from each of f1(x2), f1(x1),  f2(x2), f1(x2). If power is in kW, these values will be in kWh.
</p>
</li>
<li><p> data - A list of two datasets used to calculate energy decomposition, i.e. synchronized. When <code>imput = TRUE</code>, the power column is the result from imputation.
</p>
</li></ul>



<h3>References</h3>

<p>Latiffianti, E, Ding, Y, Sheng, S, Williams, L, Morshedizadeh, M, Rodgers, M (2022). &quot;Analysis of leading edge protection application on wind turbine performance through energy and power decomposition approaches&quot;. Wind Energy. 2022; 1-19. <a href="https://doi.org/10.1002/we.2722">doi:10.1002/we.2722</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = list(data1[1:50,], data2[1:60,])
powercol = 7
timecol = 1
xcol = c(2:6)
sync.method = 'time'
imput = TRUE
vcol = 2
vrange = c(5,12,25)
rated.power = 100
sample = FALSE
Decomposition = deltaEnergy(data, powercol, timecol, xcol, sync.method, imput,
vcol, vrange, rated.power, sample)

</code></pre>

<hr>
<h2 id='funGP'>Function comparison using Gaussian Process and Hypothesis testing</h2><span id='topic+funGP'></span>

<h3>Description</h3>

<p>Function comparison using Gaussian Process and Hypothesis testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funGP(
  datalist,
  xCol,
  yCol,
  confLevel = 0.95,
  testset,
  limitMemory = TRUE,
  opt_method = "nlminb",
  sampleSize = list(optimSize = 500, bandSize = 5000),
  rngSeed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="funGP_+3A_datalist">datalist</code></td>
<td>
<p>A list of data sets to compute a function for each of them</p>
</td></tr>
<tr><td><code id="funGP_+3A_xcol">xCol</code></td>
<td>
<p>A numeric or vector stating the column number of covariates</p>
</td></tr>
<tr><td><code id="funGP_+3A_ycol">yCol</code></td>
<td>
<p>A numeric value stating the column number of target</p>
</td></tr>
<tr><td><code id="funGP_+3A_conflevel">confLevel</code></td>
<td>
<p>A single value representing the statistical significance level for constructing the band</p>
</td></tr>
<tr><td><code id="funGP_+3A_testset">testset</code></td>
<td>
<p>Test points at which the functions will be compared</p>
</td></tr>
<tr><td><code id="funGP_+3A_limitmemory">limitMemory</code></td>
<td>
<p>A boolean (True/False) indicating whether to limit the memory use or not. Default is true. If set to true, 5000 datapoints are randomly sampled from each dataset under comparison for inference.</p>
</td></tr>
<tr><td><code id="funGP_+3A_opt_method">opt_method</code></td>
<td>
<p>A string specifying the optimization method to be used for hyperparameter estimation. Current options are: <code>'L-BFGS-B'</code>, <code>'BFGS'</code>, and <code>'nlminb'</code>. Default is set to <code>'nlminb'</code>.</p>
</td></tr>
<tr><td><code id="funGP_+3A_samplesize">sampleSize</code></td>
<td>
<p>A named list of two integer items: <code>optimSize</code> and <code>bandSize</code>, denoting the sample size for each dataset for hyperparameter optimization and confidence band computation, respectively, when <code>limitMemory = TRUE</code>. Default value is <code>list(optimSize = 500, bandSize = 5000)</code>.</p>
</td></tr>
<tr><td><code id="funGP_+3A_rngseed">rngSeed</code></td>
<td>
<p>Random seed for sampling data when <code>limitMemory = TRUE</code>. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> muDiff - A vector of pointwise difference between the predictions from the two datasets <code>(mu2- mu1)</code>
</p>
</li>
<li><p> mu1 - A vector of test prediction for first data set
</p>
</li>
<li><p> mu2 - A vector of test prediction for second data set
</p>
</li>
<li><p> band - A vector of the allowed statistical difference between functions at testpoints in testset
</p>
</li>
<li><p> confLevel - A numeric representing the statistical significance level for constructing the band
</p>
</li>
<li><p> testset - A matrix of test points to compare the functions
</p>
</li>
<li><p> estimatedParams - A list of estimated hyperparameters for GP
</p>
</li></ul>



<h3>References</h3>

<p>Prakash, A., Tuo, R., &amp; Ding, Y. (2022). &quot;Gaussian process aided function comparison using noisy scattered data,&quot; Technometrics, Vol. 64, No. 1, pp. 92-102, <a href="https://doi.org/10.1080/00401706.2021.1905073">doi:10.1080/00401706.2021.1905073</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datalist = list(data1[1:50,], data2[1:50, ])
xCol = 2
yCol = 7
confLevel = 0.95
testset = seq(4,10,length.out = 10)
function_diff = funGP(datalist, xCol, yCol, confLevel, testset)

</code></pre>

<hr>
<h2 id='imptPower'>Power imputation</h2><span id='topic+imptPower'></span>

<h3>Description</h3>

<p>Good power curve modeling requires valid power values in the region between cut-in and cut-out wind speed. However, when turbine is not operating, the power production will be recorded as zero or negative. This function replaces those values with predicted values obtained from the estimated tempGP power curve model using one input variable - the wind speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imptPower(
  data,
  powercol,
  vcol,
  vrange,
  rated.power = NULL,
  sample = TRUE,
  size = 2500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imptPower_+3A_data">data</code></td>
<td>
<p>A list of two data sets that require imputation.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_powercol">powercol</code></td>
<td>
<p>A numeric stating the column number of power production.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_vcol">vcol</code></td>
<td>
<p>A numeric stating the column number of wind speed.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_vrange">vrange</code></td>
<td>
<p>A vector of cut-in, rated, and cut-out wind speed.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_rated.power">rated.power</code></td>
<td>
<p>A numerical value stating the wind turbine rated power.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_sample">sample</code></td>
<td>
<p>A boolean (TRUE/FALSE) indicating whether to use sample or the whole data sets to train the power curve.</p>
</td></tr>
<tr><td><code id="imptPower_+3A_size">size</code></td>
<td>
<p>A numeric stating the size of sample when <code>sample = TRUE</code>. Default value is 2500. It is only used when <code>sample = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing datasets with the imputed power.
</p>


<h3>References</h3>

<p>Latiffianti, E, Ding, Y, Sheng, S, Williams, L, Morshedizadeh, M, Rodgers, M (2022). &quot;Analysis of leading edge protection application on wind turbine performance through energy and power decomposition approaches&quot;. Wind Energy. 2022; 1-19. <a href="https://doi.org/10.1002/we.2722">doi:10.1002/we.2722</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = list(data1[1:100,], data2[1:120, ])
powercol = 7
vcol = 2
vrange = c(5,12,25)
rated.power = 100
sample = FALSE

imputed.dat = imptPower(data, powercol, vcol, vrange, rated.power, sample)

</code></pre>

<hr>
<h2 id='KnnPCFit'>KNN : Fit</h2><span id='topic+KnnPCFit'></span>

<h3>Description</h3>

<p>The function models the powercurve using KNN, against supplied arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KnnPCFit(data, xCol, yCol, subsetSelection = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KnnPCFit_+3A_data">data</code></td>
<td>
<p>a dataframe or a matrix, to be used in modelling</p>
</td></tr>
<tr><td><code id="KnnPCFit_+3A_xcol">xCol</code></td>
<td>
<p>a vector or numeric values stating the column number of features</p>
</td></tr>
<tr><td><code id="KnnPCFit_+3A_ycol">yCol</code></td>
<td>
<p>a numerical or a vector value stating the column number of target</p>
</td></tr>
<tr><td><code id="KnnPCFit_+3A_subsetselection">subsetSelection</code></td>
<td>
<p>a boolean, default value is FALSE, if TRUE returns the best feature column number as xCol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> data - The data set provided by user
</p>
</li>
<li><p> xCol - The column number of features provided by user or the best subset column number
</p>
</li>
<li><p> yCol - The column number of target provided by user
</p>
</li>
<li><p> bestK - The best k nearest neighbor calculated using the function
</p>
</li>
<li><p> RMSE - The RMSE calculated using the function for provided data using user defined features and best obtained K
</p>
</li>
<li><p> MAE - The MAE calculated using the function for provided data using user defined features and best obtained K
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data = data1[c(1:100),]
xCol = 2
yCol = 7
subsetSelection = FALSE

knn_model = KnnPCFit(data, xCol, yCol, subsetSelection)

</code></pre>

<hr>
<h2 id='KnnPredict'>KNN : Predict</h2><span id='topic+KnnPredict'></span>

<h3>Description</h3>

<p>The function can be used to make prediction on test data using trained model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KnnPredict(knnMdl, testData)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KnnPredict_+3A_knnmdl">knnMdl</code></td>
<td>
<p>a list containing:
</p>

<ul>
<li><p> knnMdl$data - The data set provided by user
</p>
</li>
<li><p> knnMdl$xCol - The column number of features provided by user or the best subset column number
</p>
</li>
<li><p> knnMdl$yCol - The column number of target provided by user
</p>
</li>
<li><p> knn$bestK - The best k nearest neighbor calculated using the function KnnFit
</p>
</li></ul>
</td></tr>
<tr><td><code id="KnnPredict_+3A_testdata">testData</code></td>
<td>
<p>a data frame or matrix, to compute the predictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric / vector with prediction on test data using model generated by KnnFit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = data1[c(1:100),]
xCol = 2
yCol = 7
subsetSelection = FALSE

knn_model = KnnPCFit(data, xCol, yCol, subsetSelection)
testData = data1[c(101:110), ]

prediction = KnnPredict(knn_model, testData)

</code></pre>

<hr>
<h2 id='KnnUpdate'>KNN : Update</h2><span id='topic+KnnUpdate'></span>

<h3>Description</h3>

<p>The function can be used to update KNN model when new data is provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KnnUpdate(knnMdl, newData)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KnnUpdate_+3A_knnmdl">knnMdl</code></td>
<td>
<p>a list containing:
</p>

<ul>
<li><p> knnMdl$data - The data set provided by user
</p>
</li>
<li><p> knnMdl$xCol - The column number of features provided by user or the best subset column number
</p>
</li>
<li><p> knnMdl$yCol - The column number of target provided by user
</p>
</li>
<li><p> knn$bestK - The best k nearest neighbor calculated using the function KnnFit
</p>
</li></ul>
</td></tr>
<tr><td><code id="KnnUpdate_+3A_newdata">newData</code></td>
<td>
<p>a dataframe or a matrix, to be used for updating the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing :
</p>

<ul>
<li><p> data - The updated data using old data set and new data
</p>
</li>
<li><p> xCol - The column number of features provided by user or the best subset column number
</p>
</li>
<li><p> yCol - The column number of target provided by user
</p>
</li>
<li><p> bestK - The best k nearest neighbor calculated for the new data using user specified features and target
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data = data1[c(1:100),]
xCol = 2
yCol = 7
subsetSelection = FALSE

knn_model = KnnPCFit(data, xCol, yCol, subsetSelection)
newData = data1[c(101:110), ]

knn_newmodel = KnnUpdate(knn_model, newData)

</code></pre>

<hr>
<h2 id='predict.tempGP'>predict from temporal Gaussian process</h2><span id='topic+predict.tempGP'></span>

<h3>Description</h3>

<p>predict function for tempGP objects. This function computes the prediction <code>f(x)</code> or <code>f(x) + g(t)</code> depending on the temporal distance between training and test points and whether the time indices for the test points are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tempGP'
predict(object, testX, testT = NULL, trainT = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tempGP_+3A_object">object</code></td>
<td>
<p>An object of class tempGP.</p>
</td></tr>
<tr><td><code id="predict.tempGP_+3A_testx">testX</code></td>
<td>
<p>A matrix with each column corresponding to one input variable.</p>
</td></tr>
<tr><td><code id="predict.tempGP_+3A_testt">testT</code></td>
<td>
<p>A vector of time indices of the test points. When <code>NULL</code>, only function <code>f(x)</code> is used for prediction. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.tempGP_+3A_traint">trainT</code></td>
<td>
<p>Optional argument to override the existing trainT indices of the <code>tempGP</code> object.</p>
</td></tr>
<tr><td><code id="predict.tempGP_+3A_...">...</code></td>
<td>
<p>additional arguments for future development</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predictions at the testpoints in <code>testX</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data = DSWE::data1
   trainindex = 1:50 #using the first 50 data points to train the model
   traindata = data[trainindex,]
   xCol = 2 #input variable columns
   yCol = 7 #response column
   trainX = as.matrix(traindata[,xCol])
   trainY = as.numeric(traindata[,yCol])
   tempGPObject = tempGP(trainX, trainY)
   testdata = DSWE::data1[101:110,] # defining test data 
   testX = as.matrix(testdata[,xCol, drop = FALSE])
   predF = predict(tempGPObject, testX)

</code></pre>

<hr>
<h2 id='SplinePCFit'>Smoothing spline Anova method</h2><span id='topic+SplinePCFit'></span>

<h3>Description</h3>

<p>Smoothing spline Anova method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplinePCFit(data, xCol, yCol, testX, modelFormula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplinePCFit_+3A_data">data</code></td>
<td>
<p>a matrix or dataframe to be used in modelling</p>
</td></tr>
<tr><td><code id="SplinePCFit_+3A_xcol">xCol</code></td>
<td>
<p>a numeric or vector stating the column number of feature covariates</p>
</td></tr>
<tr><td><code id="SplinePCFit_+3A_ycol">yCol</code></td>
<td>
<p>a numeric value stating the column number of target</p>
</td></tr>
<tr><td><code id="SplinePCFit_+3A_testx">testX</code></td>
<td>
<p>a matrix or dataframe, to be used in computing the predictions</p>
</td></tr>
<tr><td><code id="SplinePCFit_+3A_modelformula">modelFormula</code></td>
<td>
<p>default is NULL else a model formula specifying target and features.Please refer 'gss' package documentation for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or numeric predictions on user provided test data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = data1[c(1:100),]
xCol = 2
yCol = 7
testX = data1[c(101:110), ]
Spline_prediction = SplinePCFit(data, xCol, yCol, testX)

</code></pre>

<hr>
<h2 id='SvmPCFit'>SVM based power curve modelling</h2><span id='topic+SvmPCFit'></span>

<h3>Description</h3>

<p>SVM based power curve modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SvmPCFit(trainX, trainY, testX, kernel = "radial")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SvmPCFit_+3A_trainx">trainX</code></td>
<td>
<p>a matrix or dataframe to be used in modelling</p>
</td></tr>
<tr><td><code id="SvmPCFit_+3A_trainy">trainY</code></td>
<td>
<p>a numeric or vector as a target</p>
</td></tr>
<tr><td><code id="SvmPCFit_+3A_testx">testX</code></td>
<td>
<p>a matrix or dataframe, to be used in computing the predictions</p>
</td></tr>
<tr><td><code id="SvmPCFit_+3A_kernel">kernel</code></td>
<td>
<p>default is 'radial' else can be 'linear', 'polynomial' and 'sigmoid'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or numeric predictions on user provided test data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = data1
trainX = as.matrix(data[c(1:100),2])
trainY = data[c(1:100),7]
testX = as.matrix(data[c(101:110),2])

Svm_prediction = SvmPCFit(trainX, trainY, testX)

</code></pre>

<hr>
<h2 id='syncSize'>Data synchronization</h2><span id='topic+syncSize'></span>

<h3>Description</h3>

<p>Data synchronization is meant to make a pair of data to have the same size. It is performed by removing some data points from the larger dataset. This step is important when comparing energy production between two data sets because energy production is time-based.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncSize(data, powercol, timecol = 0, xcol, method = "minimum power")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="syncSize_+3A_data">data</code></td>
<td>
<p>A list of two data sets to be synchronized.</p>
</td></tr>
<tr><td><code id="syncSize_+3A_powercol">powercol</code></td>
<td>
<p>A numeric stating the column number of power production.</p>
</td></tr>
<tr><td><code id="syncSize_+3A_timecol">timecol</code></td>
<td>
<p>A numeric stating the column number of data time stamp. Default value is zero. A value other than zero should be provided when <code>method = 'time'</code>.</p>
</td></tr>
<tr><td><code id="syncSize_+3A_xcol">xcol</code></td>
<td>
<p>A numeric or vector stating the column number(s) of power curve input covariates/features (to be used for energy decomposition).</p>
</td></tr>
<tr><td><code id="syncSize_+3A_method">method</code></td>
<td>
<p>A string specifying data synchronization method. Default value <code>'minimum power'</code>; other options include <code>'time'</code> and <code>'random'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the synchronized datasets.
</p>


<h3>References</h3>

<p>Latiffianti, E, Ding, Y, Sheng, S, Williams, L, Morshedizadeh, M, Rodgers, M (2022). &quot;Analysis of leading edge protection application on wind turbine performance through energy and power decomposition approaches&quot;. Wind Energy. 2022; 1-19. <a href="https://doi.org/10.1002/we.2722">doi:10.1002/we.2722</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = list(data1[1:200,], data2[1:180, ])
powercol = 7
timecol = 1
xcol = c(2:6)
method = 'random'
sync.dat = syncSize(data, powercol, timecol, xcol, method)

data = list(data1[500:700,], data2[600:750, ])
powercol = 7
timecol = 1
xcol = c(2:6)
method = 'time'
sync.dat = syncSize(data, powercol, timecol, xcol, method)

</code></pre>

<hr>
<h2 id='tempGP'>temporal Gaussian process</h2><span id='topic+tempGP'></span>

<h3>Description</h3>

<p>A Gaussian process based power curve model which explicitly models the temporal aspect of the power curve. The model consists of two parts: <code>f(x)</code> and <code>g(t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempGP(
  trainX,
  trainY,
  trainT = NULL,
  fast_computation = TRUE,
  limit_memory = 5000L,
  max_thinning_number = 20L,
  vecchia = TRUE,
  optim_control = list(batch_size = 100L, learn_rate = 0.05, max_iter = 5000L, tol =
    1e-06, beta1 = 0.9, beta2 = 0.999, epsilon = 1e-08, logfile = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tempGP_+3A_trainx">trainX</code></td>
<td>
<p>A matrix with each column corresponding to one input variable.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_trainy">trainY</code></td>
<td>
<p>A vector with each element corresponding to the output at the corresponding row of <code>trainX</code>.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_traint">trainT</code></td>
<td>
<p>A vector for time indices of the data points. By default, the function assigns natural numbers starting from 1 as the time indices.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_fast_computation">fast_computation</code></td>
<td>
<p>A Boolean that specifies whether to do exact inference or fast approximation. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_limit_memory">limit_memory</code></td>
<td>
<p>An integer or <code>NULL</code>. The integer is used sample training points during prediction to limit the total memory requirement. Setting the value to <code>NULL</code> would result in no sampling, that is, full training data is used for prediction. Default value is <code>5000</code>.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_max_thinning_number">max_thinning_number</code></td>
<td>
<p>An integer specifying the max lag to compute the thinning number. If the PACF does not become insignificant till <code>max_thinning_number</code>, then <code>max_thinning_number</code> is used for thinning.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_vecchia">vecchia</code></td>
<td>
<p>A Boolean that specifies whether to do exact inference or vecchia approximation. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tempGP_+3A_optim_control">optim_control</code></td>
<td>
<p>A list parameters passed to the Adam optimizer when <code>fast_computation</code> is set to <code>TRUE</code>. The default values have been tested rigorously and tend to strike a balance between accuracy and speed. </p>

<ul>
<li> <p><code>batch_size</code>: Number of training points sampled at each iteration of Adam.
</p>
</li>
<li> <p><code>learn_rate</code>: The step size for the Adam optimizer.
</p>
</li>
<li> <p><code>max_iter</code>: The maximum number of iterations to be performed by Adam.
</p>
</li>
<li> <p><code>tol</code>: Gradient tolerance.
</p>
</li>
<li> <p><code>beta1</code>: Decay rate for the first moment of the gradient.
</p>
</li>
<li> <p><code>beta2</code>: Decay rate for the second moment of the gradient.
</p>
</li>
<li> <p><code>epsilon</code>: A small number to avoid division by zero.
</p>
</li>
<li> <p><code>logfile</code>: A string specifying a file name to store hyperparameters value for each iteration.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tempGP</code> with the following attributes:
</p>

<ul>
<li><p> trainX - same as the input matrix <code>trainX</code>.
</p>
</li>
<li><p> trainY - same as the input vector <code>trainY</code>.
</p>
</li>
<li><p> thinningNumber - the thinning number computed by the algorithm.
</p>
</li>
<li><p> modelF - A list containing the details of the model for predicting function <code>f(x)</code>:
</p>

<ul>
<li><p> X - The input variable matrix for computing the cross-covariance for predictions, same as <code>trainX</code> unless the model is updated. See <code><a href="#topic+updateData.tempGP">updateData.tempGP</a></code> method for details on updating the model.
</p>
</li>
<li><p> y - The response vector, again same as <code>trainY</code> unless the model is updated.
</p>
</li>
<li><p> weightedY - The weighted response, that is, the response left multiplied by the inverse of the covariance matrix.
</p>
</li></ul>
 
</li>
<li><p> modelG - A list containing the details of the model for predicting function <code>g(t)</code>:
</p>

<ul>
<li><p> residuals - The residuals after subtracting function <code>f(x)</code> from the response. Used to predict <code>g(t)</code>. See <code><a href="#topic+updateData.tempGP">updateData.tempGP</a></code> method for updating the residuals.
</p>
</li>
<li><p> time_index - The time indices of the residuals, same as <code>trainT</code>.
</p>
</li></ul>

</li>
<li><p> estimatedParams - Estimated hyperparameters for function <code>f(x)</code>.
</p>
</li>
<li><p> llval - log-likelihood value of the hyperparameter optimization for <code>f(x)</code>.
</p>
</li>
<li><p> gradval - gradient vector at the optimal log-likelihood value.
</p>
</li></ul>



<h3>References</h3>

<p>Prakash, A., Tuo, R., &amp; Ding, Y. (2022). &quot;The temporal overfitting problem with applications in wind power curve modeling.&quot; Technometrics. <a href="https://doi.org/10.1080/00401706.2022.2069158">doi:10.1080/00401706.2022.2069158</a>.
</p>
<p>Katzfuss, M., &amp; Guinness, J. (2021). &quot;A General Framework for Vecchia Approximations of Gaussian Processes.&quot; Statistical Science. <a href="https://doi.org/10.1214/19-STS755">doi:10.1214/19-STS755</a>.
</p>
<p>Guinness, J. (2018). &quot;Permutation and Grouping Methods for Sharpening Gaussian Process Approximations.&quot; Technometrics. <a href="https://doi.org/10.1080/00401706.2018.1437476">doi:10.1080/00401706.2018.1437476</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.tempGP">predict.tempGP</a></code> for computing predictions and <code><a href="#topic+updateData.tempGP">updateData.tempGP</a></code> for updating data in a tempGP object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data = DSWE::data1
    trainindex = 1:50 #using the first 50 data points to train the model
    traindata = data[trainindex,]
    xCol = 2 #input variable columns
    yCol = 7 #response column
    trainX = as.matrix(traindata[,xCol])
    trainY = as.numeric(traindata[,yCol])
    tempGPObject = tempGP(trainX, trainY)


</code></pre>

<hr>
<h2 id='updateData'>Updating data in a model</h2><span id='topic+updateData'></span>

<h3>Description</h3>

<p><code>updateData</code> is a generic function to update data in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateData(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateData_+3A_object">object</code></td>
<td>
<p>A model object</p>
</td></tr>
<tr><td><code id="updateData_+3A_...">...</code></td>
<td>
<p>additional arguments for passing to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value would depend on the class of its argument <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateData.tempGP">updateData.tempGP</a></code>
</p>

<hr>
<h2 id='updateData.tempGP'>Update the data in a tempGP object</h2><span id='topic+updateData.tempGP'></span>

<h3>Description</h3>

<p>This function updates <code>trainX</code>, <code>trainY</code>, and <code>trainT</code> in a <code>tempGP</code> object. By default, if the new data has <code>m</code> data points, the function removes top <code>m</code> data points from the tempGP object and appends the new data at the bottom, thus keeping the total number of data points the same. This can be overwritten by setting <code>replace = FALSE</code> to keep all the data points (old and new). The method also updates <code>modelG</code> by computing and updating residuals at the new data points. <code>modelF</code> can be also be updated by setting the argument <code>updateModelF</code> to <code>TRUE</code>, though not required generally (see comments in the <code>Arguments</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tempGP'
updateData(
  object,
  newX,
  newY,
  newT = NULL,
  replace = TRUE,
  updateModelF = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateData.tempGP_+3A_object">object</code></td>
<td>
<p>An object of class tempGP.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_newx">newX</code></td>
<td>
<p>A matrix with each column corresponding to one input variable.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_newy">newY</code></td>
<td>
<p>A vector with each element corresponding to the output at the corresponding row of <code>newX</code>.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_newt">newT</code></td>
<td>
<p>A vector with time indices of the new datapoints. If <code>NULL</code>, the function assigns natural numbers starting with one larger than the existing time indices in <code>trainT</code>.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_replace">replace</code></td>
<td>
<p>A boolean to specify whether to replace the old data with the new one, or to add the new data while still keeping all the old data. Default is TRUE, which replaces the top <code>m</code> rows from the old data, where <code>m</code> is the number of data points in the new data.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_updatemodelf">updateModelF</code></td>
<td>
<p>A boolean to specify whether to update <code>modelF</code> as well. If the original <code>tempGP</code> model is trained on a sufficiently large dataset (say one year), updating <code>modelF</code> regularly may not result in any significant improvement, but can be computationally expensive.</p>
</td></tr>
<tr><td><code id="updateData.tempGP_+3A_...">...</code></td>
<td>
<p>additional arguments for future development</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object of class <code>tempGP</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data = DSWE::data1
   trainindex = 1:50 #using the first 50 data points to train the model
   traindata = data[trainindex,]
   xCol = 2 #input variable columns
   yCol = 7 #response column
   trainX = as.matrix(traindata[,xCol])
   trainY = as.numeric(traindata[,yCol])
   tempGPObject = tempGP(trainX, trainY)
   newdata = DSWE::data1[101:110,] # defining new data  
   newX = as.matrix(newdata[,xCol, drop = FALSE])
   newY = as.numeric(newdata[,yCol])
   tempGPupdated = updateData(tempGPObject, newX, newY)
</code></pre>

<hr>
<h2 id='XgbPCFit'>xgboost based power curve modelling</h2><span id='topic+XgbPCFit'></span>

<h3>Description</h3>

<p>xgboost based power curve modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XgbPCFit(
  trainX,
  trainY,
  testX,
  max.depth = 8,
  eta = 0.25,
  nthread = 2,
  nrounds = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XgbPCFit_+3A_trainx">trainX</code></td>
<td>
<p>a matrix or dataframe to be used in modelling</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_trainy">trainY</code></td>
<td>
<p>a numeric or vector as a target</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_testx">testX</code></td>
<td>
<p>a matrix or dataframe, to be used in computing the predictions</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_max.depth">max.depth</code></td>
<td>
<p>maximum depth of a tree</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_eta">eta</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_nthread">nthread</code></td>
<td>
<p>This parameter specifies the number of CPU threads that XGBoost</p>
</td></tr>
<tr><td><code id="XgbPCFit_+3A_nrounds">nrounds</code></td>
<td>
<p>number of boosting rounds or trees to build</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or numeric predictions on user provided test data
</p>


<h3>References</h3>

<p>Chen, T., &amp; Guestrin, C. (2016). &quot;XGBoost: A Scalable Tree Boosting System.&quot; Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, 785-794. <a href="https://doi.org/10.1145/2939672.2939785">doi:10.1145/2939672.2939785</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data = data1
trainX = as.matrix(data[c(1:100),2])
trainY = data[c(1:100),7]
testX = as.matrix(data[c(101:110),2])

Xgb_prediction = XgbPCFit(trainX, trainY, testX)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
