<!DOCTYPE html><html lang="en"><head><title>Help for package chkptstanr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chkptstanr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chkptstanr-package'><p>chkptstanr: Checkpoint MCMC Sampling with 'Stan'</p></a></li>
<li><a href='#chkpt_brms'><p>Checkpoint Sampling: brms</p></a></li>
<li><a href='#chkpt_setup'><p>Checkpoint Setup</p></a></li>
<li><a href='#chkpt_stan'><p>Checkpoint Sampling: Stan</p></a></li>
<li><a href='#combine_chkpt_draws'><p>Combine Checkpoint Draws</p></a></li>
<li><a href='#create_folder'><p>Create Folder for Checkpointing</p></a></li>
<li><a href='#extract_chkpt_draws'><p>Extract Draws from <code>CmdStanMCMC</code> Objects</p></a></li>
<li><a href='#extract_hmc_info'><p>Extract HMC Sampler Information</p></a></li>
<li><a href='#extract_stan_state'><p>Extract Stan State</p></a></li>
<li><a href='#make_brmsfit'><p>Make <code>brmsfit</code> Object</p></a></li>
<li><a href='#print.chkpt_brms'><p>Print <code>chkpt_brms</code> Objects</p></a></li>
<li><a href='#print.chkpt_setup'><p>Print <code>chkpt_setup</code> Object</p></a></li>
<li><a href='#print.chkpt_stan'><p>Print <code>chkpt_stan</code> Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Checkpoint MCMC Sampling with 'Stan'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian models in Stan &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt; 
  with checkpointing, that is, the ability to stop the MCMC sampler at 
  will, and then pick right back up where the MCMC sampler left off. 
  Custom 'Stan' models can be fitted, or the popular package 'brms' 
  &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i01">doi:10.18637/jss.v080.i01</a>&gt; can be used to generate the 'Stan' code. This 
  package is fully compatible with the R packages 'brms', 'posterior', 'cmdstanr', 
  and 'bayesplot'. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.16.1), abind, methods, Rdpack, rstan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cmdstanr, rmarkdown, knitr, posterior</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-27 12:50:54 UTC; Donald.Williams</td>
</tr>
<tr>
<td>Author:</td>
<td>Donald Williams [aut, cre],
  Tyler Matta [aut],
  NWEA [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Donald Williams &lt;donald.williams@nwea.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-29 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chkptstanr-package'>chkptstanr: Checkpoint MCMC Sampling with 'Stan'</h2><span id='topic+chkptstanr-package'></span>

<h3>Description</h3>

<p>Fit Bayesian models in <strong>Stan</strong> (Carpenter et al. 2017)
with checkpointing, that is, the ability to stop the MCMC sampler at will,
and then pick right back up where the MCMC sampler left off. Custom <strong>Stan</strong> models
can be fitted, or the popular package <strong>brms</strong> (Bürkner 2017)
can be used to generate the <strong>Stan</strong> code. This package is fully compatible with the
<code>R</code> packages <a href="http://paul-buerkner.github.io/brms/"><strong>brms</strong></a>,
<a href="https://mc-stan.org/posterior/"><strong>posterior</strong></a>,
<a href="https://mc-stan.org/cmdstanr/"><strong>cmdstanr</strong></a>, and
<a href="https://mc-stan.org/bayesplot/"><strong>bayesplot</strong></a>.
</p>
<p>There are a variety of use cases for <strong>chkptstanr</strong>,
including (but not limited to) the following:
</p>

<ul>
<li><p> The primary motivation for developing  <strong>chkptstanr</strong> is to
reduce the cost of fitting models with <strong>Stan</strong> when using, say, AWS,
and in particular by taking advantage of so-called <em>spot instances</em>.
These instances are &quot;a cost-effective choice if you can be flexible about
when your applications run and if your applications can be
<em>interrupted</em> [emphasis added]&quot;
(<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-spot-instances.html">AWS website</a>).
</p>
<p><strong>chkptstanr</strong> thus allows for taking advantage of spot instances by
enabling &quot;interruptions&quot; during model fitting. This can reduce the cost
by 90 %.
</p>
</li>
<li> <p><strong>Stan</strong> allows for fitting complex models. This often entails
iteratively improving the model to ensure that the MCMC algorithm
has converged. Typically this requires waiting until the model has
<em>finished sampling</em>, and then assessing MCMC diagnostics (e.g., R-hat).
</p>
<p><strong>chkptstanr</strong> can be used to make iterative model building more
efficient, e.g., by having the ability to pause sampling and examine the model
(e.g., convergence diagnostics), and then deciding to stop sampling or to continue on.
</p>
</li>
<li><p> Computationally intensive models can sometimes take several days to
finish up. When using a personal computer, this can take up all
the computing resources.
</p>
<p><strong>chkptstanr</strong> can be used with scheduling, such that the model is fitted
during certain windows (e.g., at night, weekends, etc.)
</p>
</li>
<li><p> Those familiar with Bayesian methods will know all too well that a model can take
longer than expected. This can be problematic when there is another task
that needs to be completed, because one is faced with
waiting it out or stopping the model (and loosing all of the progress).
</p>
<p><strong>chkptstanr</strong> makes it so that models can be conveniently stopped
if need be, while not loosing any of the progress.
</p>
</li></ul>



<h3>References</h3>

<p>Bürkner P (2017).
&ldquo;brms: An R package for Bayesian multilevel models using Stan.&rdquo;
<em>Journal of statistical software</em>, <b>80</b>, 1&ndash;28.<br /><br /> Carpenter B, Gelman A, Hoffman MD, Lee D, Goodrich B, Betancourt M, Brubaker M, Guo J, Li P, Riddell A (2017).
&ldquo;Stan: A probabilistic programming language.&rdquo;
<em>Journal of statistical software</em>, <b>76</b>(1).
</p>

<hr>
<h2 id='chkpt_brms'>Checkpoint Sampling: brms</h2><span id='topic+chkpt_brms'></span>

<h3>Description</h3>

<p>Fit Bayesian generalized (non-)linear multivariate multilevel models using brms
with checkpointing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkpt_brms(
  formula,
  data,
  iter_warmup = 1000,
  iter_sampling = 1000,
  iter_per_chkpt = 100,
  iter_typical = 150,
  parallel_chains = 2,
  threads_per = 1,
  chkpt_progress = TRUE,
  control = NULL,
  brmsfit = TRUE,
  seed = 1,
  path,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chkpt_brms_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="brms.html#topic+brmsformula">brmsformula</a></code>, or <code>brms{mvbrmsformula}</code>.
Further information can be found in  <code><a href="brms.html#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced to that class)
containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>(positive integer) The number of warmup iterations to run
per chain (defaults to 1000).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>(positive integer) The number of post-warmup iterations
to run per chain (defaults to 1000).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_iter_per_chkpt">iter_per_chkpt</code></td>
<td>
<p>(positive integer). The number of iterations per
checkpoint. Note that <code>iter_sampling</code> is divided
by <code>iter_per_chkpt</code> to determine the number of
checkpoints. This must result in an integer
(if not, there will be an error).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_iter_typical">iter_typical</code></td>
<td>
<p>(positive integer) The number of iterations in the
initial warmup, which finds the so-called typical set.
This is an initial phase, and not included in
<code>iter_warmup</code>. Note that a large enough value
is required to ensure convergence (defaults to 150).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_parallel_chains">parallel_chains</code></td>
<td>
<p>(positive integer) The <em>maximum number</em> of MCMC
chains to run in parallel. If parallel_chains is not
specified then the default is to look for the option
<code>mc.cores</code>, which can be set for an entire R session by
<code>options(mc.cores=value)</code>. If the <code>mc.cores</code>
option has not been set then the default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_threads_per">threads_per</code></td>
<td>
<p>(positive integer) Number of threads to use in within-chain
parallelization (defaults to <code>1</code>).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_chkpt_progress">chkpt_progress</code></td>
<td>
<p>logical. Should the <code>chkptstanr</code> progress
be printed (defaults to <code>TRUE</code>) ? If set to
<code>FALSE</code>, the standard <code>cmdstanr</code> progress
bar is printed for each checkpoint
(which does not actually keep track of
checkpointing progress)</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior.
It defaults to NULL so all the default values are used.
For a comprehensive overview see <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_brmsfit">brmsfit</code></td>
<td>
<p>Logical. Should a <code>brmsfit</code> object be returned
(defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_seed">seed</code></td>
<td>
<p>(positive integer). The seed for random number generation to
make results reproducible.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_path">path</code></td>
<td>
<p>Character string. The path to the folder, that is used for
saving the checkpoints.</p>
</td></tr>
<tr><td><code id="chkpt_brms_+3A_...">...</code></td>
<td>
<p>Additional arguments based to <code><a href="brms.html#topic+make_stancode">make_stancode</a></code>,
including, for example, user-defined prior distributions and the
<code><a href="brms.html#topic+brmsfamily">brmsfamily</a></code> (e.g., <code>family = poisson())</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>brmsfit</code> (with <code>brmsfit = TRUE</code>)
or <code>chkpt_brms</code> (with <code>brmsfit = FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(brms)
library(cmdstanr)

# path for storing checkpoint info
path &lt;- create_folder(folder_name  = "chkpt_folder_fit1")

# "random" intercept
fit1 &lt;- chkpt_brms(bf(formula = count ~ zAge + zBase * Trt + (1|patient),
                      family = poisson()), 
                   data = epilepsy, , 
                   iter_warmup = 1000, 
                   iter_sampling = 1000, 
                   iter_per_chkpt = 250, 
                   path = path)
                   
# brmsfit output
fit1

# path for storing checkpoint info
 path &lt;- create_folder(folder_name  = "chkpt_folder_fit2")

# remove "random" intercept (for model comparison)
fit2 &lt;- chkpt_brms(bf(formula = count ~ zAge + zBase * Trt, 
                      family = poisson()), 
                   data = epilepsy, , 
                   iter_warmup = 1000, 
                   iter_sampling = 1000, 
                   iter_per_chkpt = 250, 
                   path = path)
                   
# brmsfit output
fit2

# compare models
loo(fit1, fit2)


# using custom priors
path &lt;- create_folder(folder_name = "chkpt_folder_fit3")

# priors
bprior &lt;- prior(constant(1), class = "b") +
  prior(constant(2), class = "b", coef = "zBase") +
  prior(constant(0.5), class = "sd")

# fit model
fit3 &lt;-
  chkpt_brms(
    bf(
      formula = count ~ zAge + zBase + (1 | patient),
      family = poisson()
    ),
    data = epilepsy,
    path  = path,
    prior = bprior,
    iter_warmup = 1000,
    iter_sampling = 1000,
    iter_per_chkpt = 250, 
  )


# check priors
prior_summary(fit3)


## End(Not run)
</code></pre>

<hr>
<h2 id='chkpt_setup'>Checkpoint Setup</h2><span id='topic+chkpt_setup'></span>

<h3>Description</h3>

<p>Deterimine the number of checkpoints for the warmup and
sampling, given the desired number of iterations for each
and the iterations per checkpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkpt_setup(iter_sampling, iter_warmup, iter_per_chkpt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chkpt_setup_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>(positive integer) The number of post-warmup iterations
to run per chain. Note: in the CmdStan User's Guide this
is referred to as num_samples.</p>
</td></tr>
<tr><td><code id="chkpt_setup_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>(positive integer) The number of warmup iterations to
run per chain. Note: in the CmdStan User's Guide this
is referred to as num_warmup.</p>
</td></tr>
<tr><td><code id="chkpt_setup_+3A_iter_per_chkpt">iter_per_chkpt</code></td>
<td>
<p>(positive integer) The number of iterations per
check point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following:
</p>

<ul>
<li> <p><code>warmup_chkpts</code>: Number of warmup checkpoints
</p>
</li>
<li> <p><code>sample_chkpts</code>: Number of sampling checkpoints
</p>
</li>
<li> <p><code>total_chkpts</code>: Total number of checkpoints
(warmup_chkpts + sample_chkpts)
</p>
</li>
<li> <p><code>iter_per_chkpt</code>: Iterations per checkpoint
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>chkpt_setup &lt;- chkpt_setup(
  iter_sampling = 5000,
  iter_warmup = 2000,
  iter_per_chkpt = 10
)

chkpt_setup
</code></pre>

<hr>
<h2 id='chkpt_stan'>Checkpoint Sampling: Stan</h2><span id='topic+chkpt_stan'></span>

<h3>Description</h3>

<p>Fit Bayesian  models using Stan with checkpointing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkpt_stan(
  model_code,
  data,
  iter_warmup = 1000,
  iter_sampling = 1000,
  iter_per_chkpt = 100,
  iter_typical = 150,
  parallel_chains = 2,
  threads_per = 1,
  chkpt_progress = TRUE,
  control = NULL,
  seed = 1,
  path,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chkpt_stan_+3A_model_code">model_code</code></td>
<td>
<p>Character string corresponding to the Stan model.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_data">data</code></td>
<td>
<p>A named list of R objects (like for RStan).
Further details can be found in <code><a href="cmdstanr.html#topic+sample">sample</a></code>.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>(positive integer) The number of warmup iterations to run
per chain (defaults to 1000).</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>(positive integer) The number of post-warmup iterations
to run per chain (defaults to 1000).</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_iter_per_chkpt">iter_per_chkpt</code></td>
<td>
<p>(positive integer). The number of iterations per
checkpoint. Note that <code>iter_sampling</code> is divided
by <code>iter_per_chkpt</code> to determine the number of
checkpoints. This must result in an integer
(if not, there will be an error).</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_iter_typical">iter_typical</code></td>
<td>
<p>(positive integer) The number of iterations in the
initial warmup, which finds the so-called typical set.
This is an initial phase, and not included in
<code>iter_warmup</code>. Note that a large enough value
is required to ensure converge (defaults to 150).</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_parallel_chains">parallel_chains</code></td>
<td>
<p>(positive integer) The <em>maximum number</em> of MCMC
chains to run in parallel. If parallel_chains is not
specified then the default is to look for the option
<code>mc.cores</code>, which can be set for an entire R session by
<code>options(mc.cores=value)</code>. If the <code>mc.cores</code>
option has not been set then the default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_threads_per">threads_per</code></td>
<td>
<p>(positive integer) Number of threads to use in within-chain
parallelization (defaults to <code>1</code>).</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_chkpt_progress">chkpt_progress</code></td>
<td>
<p>logical. Should the <code>chkptstanr</code> progress
be printed (defaults to <code>TRUE</code>) ? If set to
<code>FALSE</code>, the standard <code>cmdstanr</code> progress
bar is printed for each checkpoint
(which does not actually keep track of
checkpointing progress)</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behavior.
It defaults to NULL so all the default values are used.
For a comprehensive overview see <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_seed">seed</code></td>
<td>
<p>(positive integer). The seed for random number generation to
make results reproducible.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_path">path</code></td>
<td>
<p>Character string. The path to the folder, that is used for
saving the checkpoints.</p>
</td></tr>
<tr><td><code id="chkpt_stan_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objet of class <code>chkpt_stan</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# path for storing checkpoint info
path &lt;- create_folder(folder_name = "chkpt_folder_fit1")

stan_code &lt;- make_stancode(bf(formula = count ~ zAge + zBase * Trt + (1|patient),
                              family = poisson()),
                           data = epilepsy)
stan_data &lt;- make_standata(bf(formula = count ~ zAge + zBase * Trt + (1|patient),
                              family = poisson()),
                           data = epilepsy)

# "random" intercept
fit1 &lt;- chkpt_stan(model_code = stan_code, 
                   data = stan_data,
                   iter_warmup = 1000,
                   iter_sampling = 1000,
                   iter_per_chkpt = 250,
                   path = path)

draws &lt;- combine_chkpt_draws(object = fit1)

posterior::summarise_draws(draws)


# eight schools example
 
# path for storing checkpoint info
path &lt;- create_folder(parent_folder = "chkpt_folder_fit2")

stan_code &lt;- "
data {
 int&lt;lower=0&gt; n;
  real y[n]; 
  real&lt;lower=0&gt; sigma[n]; 
}
parameters {
  real mu;
  real&lt;lower=0&gt; tau; 
  vector[n] eta; 
}
transformed parameters {
  vector[n] theta; 
  theta = mu + tau * eta; 
}
model {
  target += normal_lpdf(eta | 0, 1); 
  target += normal_lpdf(y | theta, sigma);  
}
"
stan_data &lt;- schools.data &lt;- list(
  n = 8,
  y = c(28,  8, -3,  7, -1,  1, 18, 12),
  sigma = c(15, 10, 16, 11,  9, 11, 10, 18)
)

fit2 &lt;- chkpt_stan(model_code = stan_code, 
                   data = stan_data,
                   iter_warmup = 1000,
                   iter_sampling = 1000,
                   iter_per_chkpt = 250,
                   path = path)

draws &lt;- combine_chkpt_draws(object = fit2)

posterior::summarise_draws(draws)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine_chkpt_draws'>Combine Checkpoint Draws</h2><span id='topic+combine_chkpt_draws'></span>

<h3>Description</h3>

<p>Combine Checkpoint Draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_chkpt_draws(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_chkpt_draws_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmsfit</code> or <code>chkpt_stan</code>.</p>
</td></tr>
<tr><td><code id="combine_chkpt_draws_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>draws_array</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run:   
path &lt;- create_folder(folder_name = "chkpt_folder_fit1")

stan_code &lt;- "
data {
 int&lt;lower=0&gt; n;
  real y[n];
  real&lt;lower=0&gt; sigma[n];
}
parameters {
  real mu;
  real&lt;lower=0&gt; tau;
  vector[n] eta;
}
transformed parameters {
  vector[n] theta;
  theta = mu + tau * eta;
}
model {
  target += normal_lpdf(eta | 0, 1);
  target += normal_lpdf(y | theta, sigma);
}
"

stan_data &lt;- schools.data &lt;- list(
  n = 8,
  y = c(28,  8, -3,  7, -1,  1, 18, 12),
  sigma = c(15, 10, 16, 11,  9, 11, 10, 18)
)

fit2 &lt;- chkpt_stan(model_code = stan_code,
                   data = stan_data,
                   iter_warmup = 1000,
                   iter_sampling = 1000,
                   iter_per_chkpt = 250,
                   path = path)

draws &lt;- combine_chkpt_draws(object = fit2)

draws

## End(Not run)
</code></pre>

<hr>
<h2 id='create_folder'>Create Folder for Checkpointing</h2><span id='topic+create_folder'></span>

<h3>Description</h3>

<p>Create the folder for checkingpointing, which
will &quot;house&quot; additional folders for the <code>.stan</code>
model, checkpointing information, and draws from the
posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_folder(folder_name = "cp_folder", path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_folder_+3A_folder_name">folder_name</code></td>
<td>
<p>Character string. Desired name for the &quot;parent&quot;
folder (defaults to <code>checkpoint</code>).</p>
</td></tr>
<tr><td><code id="create_folder_+3A_path">path</code></td>
<td>
<p>Character string, when specified. Defaults to <code>NULL</code>,
which then makes the folder in the working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, and instead creates a directory with
folders that will contain the checkpointing samples and other
information.
</p>


<h3>Note</h3>

<p>This creates a directory with four folders:
</p>

<ul>
<li> <p><strong>cmd_fit</strong>: The cmdstanr fittted models (one for each checkpoint).
</p>
</li>
<li> <p><strong>cp_info</strong>: Mass matrix, step size, and initial values for
next checkpoint (last iteration from previous checkpoint).
</p>
</li>
<li> <p><strong>cp_samples</strong>: Samples from the posterior distribution
(post warmup)
</p>
</li>
<li> <p><strong>stan_model</strong>: Complied <strong>Stan</strong> model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- create_folder(folder_name = "cp_folder")

# remove folder
unlink("cp_folder", recursive = TRUE)
</code></pre>

<hr>
<h2 id='extract_chkpt_draws'>Extract Draws from <code>CmdStanMCMC</code> Objects</h2><span id='topic+extract_chkpt_draws'></span>

<h3>Description</h3>

<p>A convenience function for extracting the draws from a
<code>CmdStanMCMC</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_chkpt_draws(object, phase)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_chkpt_draws_+3A_object">object</code></td>
<td>
<p>An object of class <code>CmdStanMCMC</code>.</p>
</td></tr>
<tr><td><code id="extract_chkpt_draws_+3A_phase">phase</code></td>
<td>
<p>Character string. Which phase during checkpointing?
The options included <code>warmup</code> and <code>sample</code>.
The latter extracts the draws with
<code>inc_warmup = FALSE</code>, which is the default in
<code><a href="cmdstanr.html#topic+draws">draws</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-D <code>draws_array</code> object
(iteration <em>x</em> chain <em>x</em> variable).
</p>


<h3>Note</h3>

<p>This can be used to extract the draws in general by setting
<code>phase = "sample"</code> which then only includes the post-warmup
draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 library(cmdstanr)

# eight schools example
fit_schools_ncp_mcmc &lt;- cmdstanr_example("schools_ncp")

drws &lt;- extract_chkpt_draws(object = fit_schools_ncp_mcmc,
                            phase = "sample")

# compare to cmdstanr
all.equal(drws, fit_schools_ncp_mcmc$draws())

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_hmc_info'>Extract HMC Sampler Information</h2><span id='topic+extract_hmc_info'></span>

<h3>Description</h3>

<p>Extract the inverse metric and step size adaption from
<code>CmdStanMCMC</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_hmc_info(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_hmc_info_+3A_object">object</code></td>
<td>
<p>An object of class <code>CmdStanMCMC</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including
</p>

<ul>
<li> <p><code>inv_metric</code>: Inverse metric for each chain
(with <code>matrix = FALSE</code>).
</p>
</li>
<li> <p><code>step_size_adapt</code>: Step size adaptation for each chain.
</p>
</li></ul>



<h3>Note</h3>

<p>This is primarily used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(cmdstanr)

fit_schools_ncp_mcmc &lt;- cmdstanr_example("schools_ncp")

extract_hmc_info(fit_schools_ncp_mcmc)


## End(Not run)
</code></pre>

<hr>
<h2 id='extract_stan_state'>Extract Stan State</h2><span id='topic+extract_stan_state'></span>

<h3>Description</h3>

<p>Extract Stan State
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_stan_state(object, phase)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_stan_state_+3A_object">object</code></td>
<td>
<p>An object of class <code>cmdstanr</code></p>
</td></tr>
<tr><td><code id="extract_stan_state_+3A_phase">phase</code></td>
<td>
<p>Character string indicating the current phase.
Options include <code>wormup</code> and <code>sample</code>/</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the inverse metric, step size, and last MCMC
draw (to be used as the initial value for the next checkpoint)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(cmdstanr)

# eight schools example
fit_schools_ncp_mcmc &lt;- cmdstanr_example("schools_ncp")

extract_stan_state(fit_schools_ncp_mcmc, "sample")

## End(Not run)
</code></pre>

<hr>
<h2 id='make_brmsfit'>Make <code>brmsfit</code> Object</h2><span id='topic+make_brmsfit'></span>

<h3>Description</h3>

<p>This is primarily used internally, wherein the <code>cmdstanr</code>
object is converted into a <code>brmsfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_brmsfit(object, formula = NULL, data = NULL, prior = NULL, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_brmsfit_+3A_object">object</code></td>
<td>
<p>An object of class <code>chkpt_brms</code></p>
</td></tr>
<tr><td><code id="make_brmsfit_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="brms.html#topic+brmsformula">brmsformula</a></code>, or <code>brms{mvbrmsformula}</code>.
Further information can be found in  <code><a href="brms.html#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="make_brmsfit_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced to that class)
containing data of all variables used in the model.</p>
</td></tr>
<tr><td><code id="make_brmsfit_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>brmsprior</code>.</p>
</td></tr>
<tr><td><code id="make_brmsfit_+3A_path">path</code></td>
<td>
<p>Character string. The path to the folder, that is used for
saving the checkpoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>brmsfit</code>
</p>


<h3>Note</h3>

<p>This is primarily an internal function that constructs
a <code>brmsfit</code> object.
</p>

<hr>
<h2 id='print.chkpt_brms'>Print <code>chkpt_brms</code> Objects</h2><span id='topic+print.chkpt_brms'></span>

<h3>Description</h3>

<p>Print <code>chkpt_brms</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chkpt_brms'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.chkpt_brms_+3A_x">x</code></td>
<td>
<p>Object of class <code>chkpt_brms</code></p>
</td></tr>
<tr><td><code id="print.chkpt_brms_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, and used to print the <code>chkpt_brms</code> object.
</p>


<h3>Note</h3>

<p>This function mainly avoids printing out a list,
and it is only used when <code>brmsfit = "FALSE"</code> in <code><a href="#topic+chkpt_brms">chkpt_brms</a></code>.
</p>
<p>Typically, after fitting, the posterior draws should be summarized with
<code><a href="#topic+combine_chkpt_draws">combine_chkpt_draws</a></code> (assuming <code>brmsfit = "FALSE"</code>).
</p>

<hr>
<h2 id='print.chkpt_setup'>Print <code>chkpt_setup</code> Object</h2><span id='topic+print.chkpt_setup'></span>

<h3>Description</h3>

<p>Print <code>chkpt_setup</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chkpt_setup'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.chkpt_setup_+3A_x">x</code></td>
<td>
<p>An object of class <code>chkpt_setup</code>.</p>
</td></tr>
<tr><td><code id="print.chkpt_setup_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, and used to print the <code>chkpt_setup</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chkpt_setup &lt;- chkpt_setup(
  iter_sampling = 5000,
  iter_warmup = 2000,
  iter_per_chkpt = 10
)


chkpt_setup
</code></pre>

<hr>
<h2 id='print.chkpt_stan'>Print <code>chkpt_stan</code> Objects</h2><span id='topic+print.chkpt_stan'></span>

<h3>Description</h3>

<p>Print <code>chkpt_stan</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chkpt_stan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.chkpt_stan_+3A_x">x</code></td>
<td>
<p>Object of class <code>chkpt_stan</code></p>
</td></tr>
<tr><td><code id="print.chkpt_stan_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, and used to print the <code>chkpt_stan</code> object.
</p>


<h3>Note</h3>

<p>This function mainly avoids printing out a list.
</p>
<p>Typically, after fitting, the posterior draws should be summarized with
<code><a href="#topic+combine_chkpt_draws">combine_chkpt_draws</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
