<!DOCTYPE html><html lang="en"><head><title>Help for package princurve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {princurve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#princurve-package'><p>Fit a Principal Curve in Arbitrary Dimension</p></a></li>
<li><a href='#principal_curve'><p>Fit a Principal Curve</p></a></li>
<li><a href='#principal.curve'><p>Deprecated functions</p></a></li>
<li><a href='#project_to_curve'><p>Project a set of points to the closest point on a curve</p></a></li>
<li><a href='#smoother_functions'><p>Smoother functions</p></a></li>
<li><a href='#start_circle'><p>Generate circle as initial curve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.1.6</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit a Principal Curve in Arbitrary Dimension</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting a principal curve to a data matrix in arbitrary dimensions. 
  Hastie and Stuetzle (1989) &lt;<a href="https://doi.org/10.2307%2F2289936">doi:10.2307/2289936</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rcannood/princurve">https://github.com/rcannood/princurve</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rcannood/princurve/issues">https://github.com/rcannood/princurve/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'bias_correct_curve.R' 'deprecated.R'
'package.R' 'periodic_lowess.R' 'smoother_functions.R'
'principal_curve.R' 'start_circle.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-17 18:16:00 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor Hastie [aut],
  Andreas Weingessel [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Henrik Bengtsson [ctb] (github: HenrikBengtsson),
  Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (github: rcannood)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-18 16:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='princurve-package'>Fit a Principal Curve in Arbitrary Dimension</h2><span id='topic+princurve-package'></span><span id='topic+princurve'></span>

<h3>Description</h3>

<p>Fit a principal curve which describes a smooth curve that passes through the <code>middle</code>
of the data <code>x</code> in an orthogonal sense. This curve is a non-parametric generalization
of a linear principal component. If a closed curve is fit (using <code>smoother = "periodic_lowess"</code>)
then the starting curve defaults to a circle, and each fit is followed by a bias correction
suggested by Jeff Banfield.
</p>


<h3>References</h3>

<p>Hastie, T. and Stuetzle, W.,
<a href="https://www.jstor.org/stable/2289936">Principal Curves</a>,
JASA, Vol. 84, No. 406 (Jun., 1989), pp. 502-516,
doi: <a href="https://doi.org/10.2307/2289936">10.2307/2289936</a>
(<a href="https://web.stanford.edu/~hastie/Papers/principalcurves.pdf">PDF</a>).
</p>
<p>See also Banfield and Raftery (JASA, 1992).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+principal_curve">principal_curve</a></code>, <code><a href="#topic+project_to_curve">project_to_curve</a></code>
</p>

<hr>
<h2 id='principal_curve'>Fit a Principal Curve</h2><span id='topic+principal_curve'></span><span id='topic+lines.principal_curve'></span><span id='topic+plot.principal_curve'></span><span id='topic+points.principal_curve'></span><span id='topic+whiskers'></span>

<h3>Description</h3>

<p>Fit a principal curve which describes a smooth curve that passes through the <code>middle</code>
of the data <code>x</code> in an orthogonal sense. This curve is a non-parametric generalization
of a linear principal component. If a closed curve is fit (using <code>smoother = "periodic_lowess"</code>)
then the starting curve defaults to a circle, and each fit is followed by a bias correction
suggested by Jeff Banfield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>principal_curve(
  x,
  start = NULL,
  thresh = 0.001,
  maxit = 10,
  stretch = 2,
  smoother = c("smooth_spline", "lowess", "periodic_lowess"),
  approx_points = FALSE,
  trace = FALSE,
  plot_iterations = FALSE,
  ...
)

## S3 method for class 'principal_curve'
lines(x, ...)

## S3 method for class 'principal_curve'
plot(x, ...)

## S3 method for class 'principal_curve'
points(x, ...)

whiskers(x, s, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="principal_curve_+3A_x">x</code></td>
<td>
<p>a matrix of points in arbitrary dimension.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_start">start</code></td>
<td>
<p>either a previously fit principal curve, or else a matrix
of points that in row order define a starting curve. If missing or NULL,
then the first principal component is used.  If the smoother is
<code>"periodic_lowess"</code>, then a circle is used as the start.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_thresh">thresh</code></td>
<td>
<p>convergence threshold on shortest distances to the curve.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_stretch">stretch</code></td>
<td>
<p>A stretch factor for the endpoints of the curve,
allowing the curve to grow to avoid bunching at the end.
Must be a numeric value between 0 and 2.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_smoother">smoother</code></td>
<td>
<p>choice of smoother. The default is
<code>"smooth_spline"</code>, and other choices are <code>"lowess"</code> and
<code>"periodic_lowess"</code>. The latter allows one to fit closed curves.
Beware, you may want to use <code>iter = 0</code> with <code>lowess()</code>.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_approx_points">approx_points</code></td>
<td>
<p>Approximate curve after smoothing to reduce computational time.
If <code>FALSE</code>, no approximation of the curve occurs. Otherwise,
<code>approx_points</code> must be equal to the number of points the curve
gets approximated to; preferably about 100.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, the iteration information is printed</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_plot_iterations">plot_iterations</code></td>
<td>
<p>If <code>TRUE</code> the iterations are plotted.</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_...">...</code></td>
<td>
<p>additional arguments to the smoothers</p>
</td></tr>
<tr><td><code id="principal_curve_+3A_s">s</code></td>
<td>
<p>a parametrized curve, represented by a polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"principal_curve"</code> is returned. For this object
the following generic methods a currently available: <code>plot, points, lines</code>.
</p>
<p>It has components:
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>a matrix corresponding to <code>x</code>, giving their projections
onto the curve.</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>an index, such that <code>s[order, ]</code> is smooth.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>for each point, its arc-length from the beginning of the
curve. The curve is parametrized approximately by arc-length, and
hence is <code>unit-speed</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>the sum-of-squared distances from the points to their
projections.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical indicating whether the algorithm converged
or not.</p>
</td></tr>
<tr><td><code>num_iterations</code></td>
<td>
<p>Number of iterations completed before returning.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call that created this object; allows it to be
<code>updated()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hastie, T. and Stuetzle, W.,
<a href="https://www.jstor.org/stable/2289936">Principal Curves</a>,
JASA, Vol. 84, No. 406 (Jun., 1989), pp. 502-516,
doi: <a href="https://doi.org/10.2307/2289936">10.2307/2289936</a>
(<a href="https://web.stanford.edu/~hastie/Papers/principalcurves.pdf">PDF</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project_to_curve">project_to_curve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100,-1,1)
x &lt;- cbind(x, x ^ 2 + rnorm(100, sd = 0.1))
fit &lt;- principal_curve(x)
plot(fit)
lines(fit)
points(fit)
whiskers(x, fit$s)
</code></pre>

<hr>
<h2 id='principal.curve'>Deprecated functions</h2><span id='topic+principal.curve'></span><span id='topic+lines.principal.curve'></span><span id='topic+plot.principal.curve'></span><span id='topic+points.principal.curve'></span><span id='topic+get.lam'></span>

<h3>Description</h3>

<p>This function is deprecated, please use
<code><a href="#topic+principal_curve">principal_curve</a></code> and <code><a href="#topic+project_to_curve">project_to_curve</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>principal.curve(...)

## S3 method for class 'principal.curve'
lines(...)

## S3 method for class 'principal.curve'
plot(...)

## S3 method for class 'principal.curve'
points(...)

get.lam(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="principal.curve_+3A_...">...</code></td>
<td>
<p>Catch-all for old parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='project_to_curve'>Project a set of points to the closest point on a curve</h2><span id='topic+project_to_curve'></span>

<h3>Description</h3>

<p>Finds the projection index for a matrix of points <code>x</code>, when
projected onto a curve <code>s</code>. The curve need not be of the same
length as the number of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_to_curve(x, s, stretch = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_to_curve_+3A_x">x</code></td>
<td>
<p>a matrix of data points.</p>
</td></tr>
<tr><td><code id="project_to_curve_+3A_s">s</code></td>
<td>
<p>a parametrized curve, represented by a polygon.</p>
</td></tr>
<tr><td><code id="project_to_curve_+3A_stretch">stretch</code></td>
<td>
<p>A stretch factor for the endpoints of the curve,
allowing the curve to grow to avoid bunching at the end.
Must be a numeric value between 0 and 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure is returned which represents a fitted curve.  It has components
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>The fitted points on the curve corresponding to each point <code>x</code></p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>the order of the fitted points</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The projection index for each point</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>The total squared distance from the curve</p>
</td></tr>
<tr><td><code>dist_ind</code></td>
<td>
<p>The squared distances from the curve to each of the respective points</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+principal_curve">principal_curve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- runif(100, -1, 1)
x &lt;- cbind(t, t ^ 2) + rnorm(200, sd = 0.05)
s &lt;- matrix(c(-1, 0, 1, 1, 0, 1), ncol = 2)

proj &lt;- project_to_curve(x, s)

plot(x)
lines(s)
segments(x[, 1], x[, 2], proj$s[, 1], proj$s[, 2])
</code></pre>

<hr>
<h2 id='smoother_functions'>Smoother functions</h2><span id='topic+smoother_functions'></span>

<h3>Description</h3>

<p>Each of these functions have an interface <code>function(lambda, xj, ...)</code>, and
return smoothed values for xj. The output is expected to be ordered along an ordered lambda.
This means that the following is true:
</p>
<pre>
x &lt;- runif(100)
y &lt;- runif(100)
ord &lt;- sample.int(100)
sfun &lt;- smoother_functions[[1]]
all(sfun(x, y) == sfun(x[ord], y[ord]))
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>smoother_functions
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='start_circle'>Generate circle as initial curve</h2><span id='topic+start_circle'></span>

<h3>Description</h3>

<p>The starting circle is defined in the first two dimensions,
and has zero values in all other dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_circle(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_circle_+3A_x">x</code></td>
<td>
<p>The data for which to generate the initial circle</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- cbind(
  rnorm(100, 1, .2),
  rnorm(100, -5, .2),
  runif(100, 1.9, 2.1),
  runif(100, 2.9, 3.1)
)
circ &lt;- start_circle(x)
plot(x)
lines(circ)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
