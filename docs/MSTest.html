<!DOCTYPE html><html lang="en"><head><title>Help for package MSTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MSTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MSTest-package'>
<p>Testing Markov Switching Models</p></a></li>
<li><a href='#AIC.ARmdl'><p>AIC of a <code>ARmdl</code> object</p></a></li>
<li><a href='#AIC.HMmdl'><p>AIC of a <code>HMmdl</code> object</p></a></li>
<li><a href='#AIC.MSARmdl'><p>AIC of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#AIC.MSVARmdl'><p>AIC of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#AIC.Nmdl'><p>AIC of a <code>Nmdl</code> object</p></a></li>
<li><a href='#AIC.VARmdl'><p>AIC of a <code>VARmdl</code> object</p></a></li>
<li><a href='#approx_dist_loop'><p>Loop for <code>approxDistDL</code></p></a></li>
<li><a href='#approxDistDL'><p>Approximate CDF distribution</p></a></li>
<li><a href='#argrid_MSARmdl'><p>Autoregressive moment grid</p></a></li>
<li><a href='#argrid_MSVARmdl'><p>Vector autoregressive moment grid</p></a></li>
<li><a href='#ARmdl'><p>Autoregressive Model</p></a></li>
<li><a href='#arP'><p>Autoregressive transition matrix</p></a></li>
<li><a href='#ARXmdl'><p>Autoregressive X Model</p></a></li>
<li><a href='#BIC.ARmdl'><p>BIC of a <code>ARmdl</code> object</p></a></li>
<li><a href='#BIC.HMmdl'><p>BIC of a <code>HMmdl</code> object</p></a></li>
<li><a href='#BIC.MSARmdl'><p>BIC of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#BIC.MSVARmdl'><p>BIC of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#BIC.Nmdl'><p>BIC of a <code>Nmdl</code> object</p></a></li>
<li><a href='#BIC.VARmdl'><p>BIC of a <code>VARmdl</code> object</p></a></li>
<li><a href='#calc_DLmoments'><p>Moment-based test statistics</p></a></li>
<li><a href='#calc_mu2t'><p>Test statistic for switch in mean only</p></a></li>
<li><a href='#calc_mu2t_mv'><p>Test statistic for switch in mean and variance</p></a></li>
<li><a href='#calcResid_MSARmdl'><p>Markov-switching autoregressive model residuals</p></a></li>
<li><a href='#calcResid_MSARXmdl'><p>Markov-switching autoregressive model residuals</p></a></li>
<li><a href='#calcResid_MSVARmdl'><p>Markov-switching vector autoregressive model residuals</p></a></li>
<li><a href='#calcResid_MSVARXmdl'><p>Markov-switching VARX model residuals</p></a></li>
<li><a href='#chp10GNP'><p>Carrasco, Hu, &amp; Ploberger 2010 GNP data</p></a></li>
<li><a href='#CHPbootCV'><p>Bootstrap critical values for CHP 2014 parameter stability test</p></a></li>
<li><a href='#chpDmat'><p>Derivative matrix</p></a></li>
<li><a href='#chpStat'><p>Test statistic for CHP 2014 parameter stability test</p></a></li>
<li><a href='#CHPTest'><p>Carrasco, Hu, and Ploberger (2014) parameter stability test</p></a></li>
<li><a href='#clike'><p>Parameter vector &amp; likelihood function used by <code>HLRTest()</code></p></a></li>
<li><a href='#coef.ARmdl'><p>coef of a <code>ARmdl</code> object</p></a></li>
<li><a href='#coef.HMmdl'><p>coef of a <code>HMmdl</code> object</p></a></li>
<li><a href='#coef.MSARmdl'><p>coef of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#coef.MSVARmdl'><p>coef of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#coef.Nmdl'><p>coef of a <code>Nmdl</code> object</p></a></li>
<li><a href='#coef.VARmdl'><p>coef of a <code>VARmdl</code> object</p></a></li>
<li><a href='#combine_stat'><p>Combine p-values</p></a></li>
<li><a href='#companionMat'><p>Companion Matrix</p></a></li>
<li><a href='#compu_tstat'><p>Computes test stat using new parameter vectors</p></a></li>
<li><a href='#cov2corr'><p>Covariance to correlation matrix</p></a></li>
<li><a href='#covar_unvech'><p>Covariance vech to matrix</p></a></li>
<li><a href='#covar_vech'><p>Covariance vech function</p></a></li>
<li><a href='#DLMCTest'><p>Monte Carlo moment-based test for Markov switching model</p></a></li>
<li><a href='#DLMMC_bounds'><p>MMC nuisance parameter bounds for Moment-based test</p></a></li>
<li><a href='#DLMMCpval_fun'><p>Moment-based MMC test p-value</p></a></li>
<li><a href='#DLMMCpval_fun_min'><p>Moment-based MMC test (negative) p-value</p></a></li>
<li><a href='#DLMMCTest'><p>Maximized Monte Carlo moment-based test for Markov switching model</p></a></li>
<li><a href='#dmclike'><p>Gradient of likelihood function.</p></a></li>
<li><a href='#EMaximization_HMmdl'><p>Maximization step of EM algorithm for Hidden Markov model</p></a></li>
<li><a href='#EMaximization_MSARmdl'><p>Maximization step of EM algorithm for Markov-switching autoregressive model</p></a></li>
<li><a href='#EMaximization_MSARXmdl'><p>Maximization step of EM algorithm for Markov-switching ARX model</p></a></li>
<li><a href='#EMaximization_MSVARmdl'><p>Maximization step of EM algorithm for Markov-switching vector autoregressive model</p></a></li>
<li><a href='#EMaximization_MSVARXmdl'><p>Maximization step of EM algorithm for Markov-switching VARX model</p></a></li>
<li><a href='#EMiter_HMmdl'><p>EM algorithm iteration for Hidden Markov model</p></a></li>
<li><a href='#EMiter_MSARmdl'><p>EM algorithm iteration for Markov-switching autoregressive model</p></a></li>
<li><a href='#EMiter_MSARXmdl'><p>EM algorithm iteration for Markov-switching ARX model</p></a></li>
<li><a href='#EMiter_MSVARmdl'><p>EM algorithm iteration for Markov-switching vector autoregressive model</p></a></li>
<li><a href='#EMiter_MSVARXmdl'><p>EM algorithm iteration for Markov-switching VARX model</p></a></li>
<li><a href='#estimMdl'><p>Estimate model for likelihood ratio test</p></a></li>
<li><a href='#ExpectationM_HMmdl'><p>Hidden Markov model log-likelihood function</p></a></li>
<li><a href='#ExpectationM_MSARmdl'><p>Markov-switching autoregressive log-likelihood function</p></a></li>
<li><a href='#ExpectationM_MSARXmdl'><p>Markov-switching ARX log-likelihood function</p></a></li>
<li><a href='#ExpectationM_MSVARmdl'><p>Markov-switching vector autoregressive log-likelihood function</p></a></li>
<li><a href='#ExpectationM_MSVARXmdl'><p>Markov-switching VARX log-likelihood function</p></a></li>
<li><a href='#fitted.ARmdl'><p>fitted values of a <code>ARmdl</code> object</p></a></li>
<li><a href='#fitted.HMmdl'><p>fitted values of a <code>HMmdl</code> object</p></a></li>
<li><a href='#fitted.MSARmdl'><p>fitted values of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#fitted.MSVARmdl'><p>fitted values of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#fitted.Nmdl'><p>fitted values of a <code>Nmdl</code> object</p></a></li>
<li><a href='#fitted.VARmdl'><p>fitted values of a <code>VARmdl</code> object</p></a></li>
<li><a href='#getHessian'><p>Hessian matrix</p></a></li>
<li><a href='#getHessian.ARmdl'><p>Hessian matrix of autoregressive model</p></a></li>
<li><a href='#getHessian.HMmdl'><p>Hessian matrix of Hidden Markov model</p></a></li>
<li><a href='#getHessian.MSARmdl'><p>Hessian matrix of Markov-switching autoregressive model</p></a></li>
<li><a href='#getHessian.MSVARmdl'><p>Hessian matrix of Markov-switching vector autoregressive model</p></a></li>
<li><a href='#getHessian.Nmdl'><p>Hessian matrix of normal model</p></a></li>
<li><a href='#getHessian.VARmdl'><p>Hessian matrix of vector autoregressive model</p></a></li>
<li><a href='#hamilton84GNP'><p>Hamilton 1984 &amp; Hansen 1992 GNP data</p></a></li>
<li><a href='#HLRparamSearch'><p>HLR param search</p></a></li>
<li><a href='#HLRTest'><p>Hansen (1992) likelihood ratio test</p></a></li>
<li><a href='#HMmdl'><p>Hidden Markov model</p></a></li>
<li><a href='#HMmdl_em'><p>Estimation of Hidden Markov model by EM Algorithm</p></a></li>
<li><a href='#HMmdl_mle'><p>Hidden Markov model maximum likelihood estimation</p></a></li>
<li><a href='#initVals_HMmdl'><p>Initial values for Hidden Markov model</p></a></li>
<li><a href='#initVals_MSARmdl'><p>Initial values for Markov-switching autoregressive model</p></a></li>
<li><a href='#initVals_MSARXmdl'><p>Initial values for Markov-switching ARX model</p></a></li>
<li><a href='#initVals_MSVARmdl'><p>Initial values for Markov-switching vector autoregressive model</p></a></li>
<li><a href='#initVals_MSVARXmdl'><p>Initial values for Markov-switching VARX model</p></a></li>
<li><a href='#interMSARmdl'><p>Intercept from mu for MSARmdl</p></a></li>
<li><a href='#interMSVARmdl'><p>Intercept from mu for MSVARmdl</p></a></li>
<li><a href='#limP'><p>Ergodic (limiting) probabilities of states</p></a></li>
<li><a href='#LMCLRTest'><p>Monte Carlo Likelihood Ratio Test</p></a></li>
<li><a href='#logLik.ARmdl'><p>Log likelihood for autoregressive model</p></a></li>
<li><a href='#logLik.HMmdl'><p>Log likelihood for Hidden Markov model</p></a></li>
<li><a href='#logLik.MSARmdl'><p>Log likelihood for Markov-switching autoregressive model</p></a></li>
<li><a href='#logLik.MSVARmdl'><p>Log likelihood for Markov-switching vector autoregressive model</p></a></li>
<li><a href='#logLik.Nmdl'><p>Log likelihood for Normal model</p></a></li>
<li><a href='#logLik.VARmdl'><p>Log likelihood for vector autoregressive model</p></a></li>
<li><a href='#logLike_ARmdl'><p>Autoregressive log-likelihood objective function</p></a></li>
<li><a href='#logLike_ARXmdl'><p>ARX log-likelihood objective function</p></a></li>
<li><a href='#logLike_HMmdl'><p>Hidden Markov model log-likelihood function</p></a></li>
<li><a href='#logLike_HMmdl_min'><p>Hidden Markov model log-likelihood function  (minimization version)</p></a></li>
<li><a href='#logLike_MSARmdl'><p>Markov-switching autoregressive log-likelihood objective function</p></a></li>
<li><a href='#logLike_MSARmdl_min'><p>Markov-switching autoregressive log-likelihood objective function (minimization version)</p></a></li>
<li><a href='#logLike_MSARXmdl'><p>Markov-switching ARX log-likelihood objective function</p></a></li>
<li><a href='#logLike_MSARXmdl_min'><p>Markov-switching ARX log-likelihood objective function (minimization version)</p></a></li>
<li><a href='#logLike_MSVARmdl'><p>Markov-switching vector autoregressive log-likelihood objective function</p></a></li>
<li><a href='#logLike_MSVARmdl_min'><p>Markov-switching vector autoregressive log-likelihood objective function (minimization version)</p></a></li>
<li><a href='#logLike_MSVARXmdl'><p>Markov-switching VARX log-likelihood objective function</p></a></li>
<li><a href='#logLike_MSVARXmdl_min'><p>Markov-switching VARX log-likelihood objective function (minimization version)</p></a></li>
<li><a href='#logLike_Nmdl'><p>Normal log-likelihood objective function</p></a></li>
<li><a href='#logLike_VARmdl'><p>Vector autoregressive log-likelihood objective function</p></a></li>
<li><a href='#logLike_VARXmdl'><p>VARX log-likelihood objective function</p></a></li>
<li><a href='#LR_samp_dist'><p>Likelihood Ratio Test Statistic Sample Distribution</p></a></li>
<li><a href='#LR_samp_dist_par'><p>Monte Carlo Likelihood Ratio Test sample distribution (parallel version)</p></a></li>
<li><a href='#marklike'><p>Likelihood function used by <code>HLRTest()</code></p></a></li>
<li><a href='#mclike'><p>Sum of likelihood used by <code>HLRTest()</code></p></a></li>
<li><a href='#MCpval'><p>Monte Carlo P-value</p></a></li>
<li><a href='#mdledit'><p>Change model List with new parameters</p></a></li>
<li><a href='#MMC_bounds'><p>MMC nuisance parameter bounds</p></a></li>
<li><a href='#MMCLRpval_fun'><p>Monte Carlo Likelihood Ratio Test P-value Function</p></a></li>
<li><a href='#MMCLRpval_fun_min'><p>Monte Carlo Likelihood Ratio Test P-value Function</p></a></li>
<li><a href='#MMCLRTest'><p>Maximized Monte Carlo Likelihood Ratio Test</p></a></li>
<li><a href='#MSARmdl'><p>Markov-switching autoregressive model</p></a></li>
<li><a href='#MSARmdl_em'><p>Estimation of Markov-switching autoregressive model by EM Algorithm</p></a></li>
<li><a href='#MSARmdl_mle'><p>Markov-switching autoregressive maximum likelihood estimation</p></a></li>
<li><a href='#MSARXmdl'><p>Markov-switching autoregressive model</p></a></li>
<li><a href='#MSARXmdl_em'><p>Estimation of Markov-switching ARX model by EM Algorithm</p></a></li>
<li><a href='#MSVARmdl'><p>Markov-switching vector autoregressive model</p></a></li>
<li><a href='#MSVARmdl_em'><p>Estimation of Markov-switching vector autoregressive model by EM Algorithm</p></a></li>
<li><a href='#MSVARmdl_mle'><p>Markov-switching vector autoregressive maximum likelihood estimation</p></a></li>
<li><a href='#MSVARXmdl'><p>Markov-switching vector autoregressive model</p></a></li>
<li><a href='#MSVARXmdl_em'><p>Estimation of Markov-switching VARX model by EM Algorithm</p></a></li>
<li><a href='#Nmdl'><p>Normal distribution model</p></a></li>
<li><a href='#nobs.ARmdl'><p>Nobs of a <code>ARmdl</code> object</p></a></li>
<li><a href='#nobs.HMmdl'><p>Nobs of a <code>HMmdl</code> object</p></a></li>
<li><a href='#nobs.MSARmdl'><p>Nobs of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#nobs.MSVARmdl'><p>Nobs of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#nobs.Nmdl'><p>Nobs of a <code>Nmdl</code> object</p></a></li>
<li><a href='#nobs.VARmdl'><p>Nobs of a <code>VARmdl</code> object</p></a></li>
<li><a href='#paramList_MSARmdl'><p>Parameter list for Markov-switching autoregressive model</p></a></li>
<li><a href='#paramList_MSARXmdl'><p>Parameter list for Markov-switching ARX model</p></a></li>
<li><a href='#paramList_MSVARmdl'><p>Parameter list for Markov-switching vector autoregressive model</p></a></li>
<li><a href='#paramList_MSVARXmdl'><p>Parameter list for Markov-switching VARX model</p></a></li>
<li><a href='#plot.ARmdl'><p>Plot of a <code>ARmdl</code> object</p></a></li>
<li><a href='#plot.Hmmdl'><p>Plot of a <code>HMmdl</code> object</p></a></li>
<li><a href='#plot.MSARmdl'><p>Plot of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#plot.MSVARmdl'><p>Plot of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#plot.Nmdl'><p>Plot of a <code>Nmdl</code> object</p></a></li>
<li><a href='#plot.simuAR'><p>Plot of a <code>simuAR</code> object</p></a></li>
<li><a href='#plot.simuARX'><p>Plot of a <code>simuARX</code> object</p></a></li>
<li><a href='#plot.simuHMM'><p>Plot of a <code>simuHMM</code> object</p></a></li>
<li><a href='#plot.simuMSAR'><p>Plot of a <code>simuMSAR</code> object</p></a></li>
<li><a href='#plot.simuMSARX'><p>Plot of a <code>simuMSARX</code> object</p></a></li>
<li><a href='#plot.simuMSVAR'><p>Plot of a <code>simuMSVAR</code> object</p></a></li>
<li><a href='#plot.simuMSVARX'><p>Plot of a <code>simuMSVARX</code> object</p></a></li>
<li><a href='#plot.simuNorm'><p>Plot of a <code>simuNorm</code> object</p></a></li>
<li><a href='#plot.simuVAR'><p>Plot of a <code>simuVAR</code> object</p></a></li>
<li><a href='#plot.simuVARX'><p>Plot of a <code>simuVARX</code> object</p></a></li>
<li><a href='#plot.VARmdl'><p>Plot of a <code>VARmdl</code> object</p></a></li>
<li><a href='#predict.ARmdl'><p>Predict for a <code>ARmdl</code> object</p></a></li>
<li><a href='#predict.HMmdl'><p>Predict for a <code>HMmdl</code> object</p></a></li>
<li><a href='#predict.MSARmdl'><p>Predict for a <code>MSARmdl</code> object</p></a></li>
<li><a href='#predict.MSVARmdl'><p>Predict for a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#predict.Nmdl'><p>Predict for a <code>Nmdl</code> object</p></a></li>
<li><a href='#predict.VARmdl'><p>Predict for a <code>VARmdl</code> object</p></a></li>
<li><a href='#print.ARmdl'><p>Print summary of an <code>ARmdl</code> object</p></a></li>
<li><a href='#print.BootLRTest'><p>Print summary of a <code>BootLRTest</code> object</p></a></li>
<li><a href='#print.CHPTest'><p>Print summary of a <code>CHPTest</code> object</p></a></li>
<li><a href='#print.DLMCTest'><p>Print summary of a <code>DLMCTest</code> object</p></a></li>
<li><a href='#print.DLMMCTest'><p>Print summary of a <code>DLMMCTest</code> object</p></a></li>
<li><a href='#print.HLRTest'><p>Print summary of a <code>CHPTest</code> object</p></a></li>
<li><a href='#print.HMmdl'><p>Print summary of a <code>HMmdl</code> object</p></a></li>
<li><a href='#print.LMCLRTest'><p>Print summary of a <code>LMCLRTest</code> object</p></a></li>
<li><a href='#print.MMCLRTest'><p>Print summary of a <code>MMCLRTest</code> object</p></a></li>
<li><a href='#print.MSARmdl'><p>Print summary of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#print.MSVARmdl'><p>Print summary of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#print.Nmdl'><p>Print summary of a <code>Nmdl</code> object</p></a></li>
<li><a href='#print.VARmdl'><p>Print summary of an <code>VARmdl</code> object</p></a></li>
<li><a href='#randP'><p>Random Transition Matrix</p></a></li>
<li><a href='#randSN'><p>Standard normal errors using box Muller</p></a></li>
<li><a href='#residuals.ARmdl'><p>residuals of a <code>ARmdl</code> object</p></a></li>
<li><a href='#residuals.HMmdl'><p>residuals of a <code>HMmdl</code> object</p></a></li>
<li><a href='#residuals.MSARmdl'><p>residuals of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#residuals.MSVARmdl'><p>residuals of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#residuals.Nmdl'><p>residuals of a <code>Nmdl</code> object</p></a></li>
<li><a href='#residuals.VARmdl'><p>residuals of a <code>VARmdl</code> object</p></a></li>
<li><a href='#sim_DLmoments'><p>Simulated moment-based test statistics</p></a></li>
<li><a href='#simuAR'><p>Simulate autoregressive process</p></a></li>
<li><a href='#simuAR_cpp'><p>Simulate autoregressive process</p></a></li>
<li><a href='#simuARX'><p>Simulate autoregressive X process</p></a></li>
<li><a href='#simuARX_cpp'><p>Simulate autoregressive process with exogenous regressors</p></a></li>
<li><a href='#simuHMM'><p>Simulate Hidden Markov model with normally distributed errors</p></a></li>
<li><a href='#simuHMM_cpp'><p>Simulate Hidden Markov model with normally distributed errors</p></a></li>
<li><a href='#simuMdl'><p>Likelihood ratio test statistic sample distribution</p></a></li>
<li><a href='#simuMSAR'><p>Simulate Markov-switching autoregressive process</p></a></li>
<li><a href='#simuMSAR_cpp'><p>Simulate Markov-switching autoregressive process</p></a></li>
<li><a href='#simuMSARX'><p>Simulate Markov-switching ARX process</p></a></li>
<li><a href='#simuMSARX_cpp'><p>Simulate Markov-switching ARX process</p></a></li>
<li><a href='#simuMSVAR'><p>Simulate Markov-switching vector autoregressive process</p></a></li>
<li><a href='#simuMSVAR_cpp'><p>Simulate Markov-switching vector autoregressive process</p></a></li>
<li><a href='#simuMSVARX'><p>Simulate Markov-switching VARX process</p></a></li>
<li><a href='#simuMSVARX_cpp'><p>Simulate Markov-switching VARX process</p></a></li>
<li><a href='#simuNorm'><p>Simulate normally distributed process</p></a></li>
<li><a href='#simuNorm_cpp'><p>Simulate normally distributed process</p></a></li>
<li><a href='#simuVAR'><p>Simulate VAR process</p></a></li>
<li><a href='#simuVAR_cpp'><p>Simulate VAR process</p></a></li>
<li><a href='#simuVARX'><p>Simulate VAR process</p></a></li>
<li><a href='#simuVARX_cpp'><p>Simulate VARX process</p></a></li>
<li><a href='#summary.ARmdl'><p>Summary of an <code>ARmdl</code> object</p></a></li>
<li><a href='#summary.BootLRTest'><p>Summary of a <code>BootLRTest</code> object</p></a></li>
<li><a href='#summary.CHPTest'><p>Summary of a <code>CHPTest</code> object</p></a></li>
<li><a href='#summary.DLMCTest'><p>summaryummary of a <code>DLMCTest</code> object</p></a></li>
<li><a href='#summary.DLMMCTest'><p>Summary of a <code>DLMMCTest</code> object</p></a></li>
<li><a href='#summary.HLRTest'><p>Summary of a <code>CHPTest</code> object</p></a></li>
<li><a href='#summary.HMmdl'><p>Summary of a <code>HMmdl</code> object</p></a></li>
<li><a href='#summary.LMCLRTest'><p>Summary of a <code>LMCLRTest</code> object</p></a></li>
<li><a href='#summary.MMCLRTest'><p>Summary of a <code>MMCLRTest</code> object</p></a></li>
<li><a href='#summary.MSARmdl'><p>Summary of a <code>MSARmdl</code> object</p></a></li>
<li><a href='#summary.MSVARmdl'><p>Summary of a <code>MSVARmdl</code> object</p></a></li>
<li><a href='#summary.Nmdl'><p>Summary of a <code>Nmdl</code> object</p></a></li>
<li><a href='#summary.VARmdl'><p>Summary of an <code>VARmdl</code> object</p></a></li>
<li><a href='#thetaSE'><p>Theta standard errors</p></a></li>
<li><a href='#ts_lagged'><p>Lagged Time Series Data</p></a></li>
<li><a href='#USGNP'><p>US GNP data 1947Q2 - 2024Q2</p></a></li>
<li><a href='#USRGDP'><p>US Real GDP data 1947Q2 - 2024Q2</p></a></li>
<li><a href='#VARmdl'><p>Vector autoregressive model</p></a></li>
<li><a href='#VARXmdl'><p>Vector X autoregressive model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hypothesis Testing for Markov Switching Models</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-24</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Rodriguez Rondon &lt;gabriel.rodriguezrondon@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of hypothesis testing procedures described in Hansen (1992) &lt;<a href="https://doi.org/10.1002%2Fjae.3950070506">doi:10.1002/jae.3950070506</a>&gt;, Carrasco, Hu, &amp; Ploberger (2014) &lt;<a href="https://doi.org/10.3982%2FECTA8609">doi:10.3982/ECTA8609</a>&gt;, Dufour &amp; Luger (2017) &lt;<a href="https://doi.org/10.1080%2F07474938.2017.1307548">doi:10.1080/07474938.2017.1307548</a>&gt;, and Rodriguez Rondon &amp; Dufour (2024) <a href="https://grodriguezrondon.com/files/RodriguezRondon_Dufour_2024_MonteCarlo_LikelihoodRatioTest_MarkovSwitchingModels_20241015.pdf">https://grodriguezrondon.com/files/RodriguezRondon_Dufour_2024_MonteCarlo_LikelihoodRatioTest_MarkovSwitchingModels_20241015.pdf</a> that can be used to identify the number of regimes in Markov switching models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/roga11/MSTest">https://github.com/roga11/MSTest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/roga11/MSTest/issues">https://github.com/roga11/MSTest/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, rlang, nloptr, Rcpp (&ge; 1.0.1), numDeriv, pracma,
foreach, GenSA, pso, GA, graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-24 18:23:58 UTC; gabrielrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriel Rodriguez Rondon [cre, aut],
  Jean-Marie Dufour [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 18:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='MSTest-package'>
Testing Markov Switching Models
</h2><span id='topic+MSTest-package'></span><span id='topic+MSTest'></span>

<h3>Description</h3>

<p>This package implements hypothesis testing procedures that can be used to identify the number of regimes in a Markov-Switching model.
</p>


<h3>Author(s)</h3>

<p>Gabriel Rodriguez Rondon, gabriel.rodriguezrondon@mail.mcgill.ca (Maintainer)
</p>
<p>Jean-Marie Dufour, jean-marie.dufour@mcgill.ca
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>
<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Dufour, Jean-Marie, and Richard Luger. 2017. “Identification-robust moment-based tests for Markov switching in autoregressive models.” <em>Econometric Reviews</em> 36 (6-9): 713–727.
</p>
<p>Kasahara, Hiroyuk, and Katsum Shimotsu. 2018. “Testing the number of regimes in Markov regime switching models.” arXiv preprint arXiv:1801.06862.
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. <em>Springer</em>.
</p>
<p>Hamilton, James D. 1989. “A new approach to the economic analysis of nonstationary time series and the business cycle.” <em>Econometrica</em> 57 (2): 357–384.
</p>
<p>Hamilton, James D. 1994. &quot;Time series analysis&quot;. <em>Princeton university press</em>.
</p>
<p>Hansen, Bruce E. 1992. “The likelihood ratio test under nonstandard conditions: testing the Markov switching model of GNP.” <em>Journal of applied Econometrics</em> 7 (S1): S61–S82.
</p>
<p>Rodriguez Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez Rondon, Gabriel and Jean-Marie Dufour. 2022. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>
<p>Rodriguez Rondon, Gabriel and Jean-Marie Dufour. 2022. “MSTest: An R-package for Testing Markov-Switching Models.” <em>Unpublished manuscript</em>.
</p>
<p>Qu, Zhongjun, and Fan Zhuo. 2021. “Likelihood Ratio-Based Tests for Markov Regime Switching.” <em>The Review of Economic Studies</em> 88 (2): 937–968.
</p>

<hr>
<h2 id='AIC.ARmdl'>AIC of a <code>ARmdl</code> object</h2><span id='topic+AIC.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.ARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.ARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.ARmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='AIC.HMmdl'>AIC of a <code>HMmdl</code> object</h2><span id='topic+AIC.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.HMmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.HMmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.HMmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='AIC.MSARmdl'>AIC of a <code>MSARmdl</code> object</h2><span id='topic+AIC.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.MSARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.MSARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.MSARmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='AIC.MSVARmdl'>AIC of a <code>MSVARmdl</code> object</h2><span id='topic+AIC.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.MSVARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.MSVARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.MSVARmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='AIC.Nmdl'>AIC of a <code>Nmdl</code> object</h2><span id='topic+AIC.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.Nmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.Nmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.Nmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='AIC.VARmdl'>AIC of a <code>VARmdl</code> object</h2><span id='topic+AIC.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>AIC()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.VARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.VARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.VARmdl_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC value.
</p>

<hr>
<h2 id='approx_dist_loop'>Loop for <code><a href="#topic+approxDistDL">approxDistDL</a></code></h2><span id='topic+approx_dist_loop'></span>

<h3>Description</h3>

<p>This function performs the loop in required in <code><a href="#topic+approxDistDL">approxDistDL</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_dist_loop(SN2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approx_dist_loop_+3A_sn2">SN2</code></td>
<td>
<p>A (<code>T x 4</code>) matrix of  test-statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The test statistics from simulated data. Used for NLS to get <code>params</code> needed to combine p-values.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='approxDistDL'>Approximate CDF distribution</h2><span id='topic+approxDistDL'></span>

<h3>Description</h3>

<p>This function obtains the parameters in eq. 16 of the CDF distribution needed for combining moment-based test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxDistDL(Tsize, simdist_N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxDistDL_+3A_tsize">Tsize</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="approxDistDL_+3A_simdist_n">simdist_N</code></td>
<td>
<p>Number of simulations to approximate CDF distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>2 x 4</code>) matrix with parameters of CDF distributions. The first row contains <code class="reqn">\gamma_0</code> for each moment and the second row contains <code class="reqn">\gamma_1</code> for each moment.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='argrid_MSARmdl'>Autoregressive moment grid</h2><span id='topic+argrid_MSARmdl'></span>

<h3>Description</h3>

<p>This function creates a grid of mean and variance consistent with a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argrid_MSARmdl(mu, sig, k, ar, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argrid_MSARmdl_+3A_mu">mu</code></td>
<td>
<p>vector (<code>k x 1</code>) of mu in each regime.</p>
</td></tr>
<tr><td><code id="argrid_MSARmdl_+3A_sig">sig</code></td>
<td>
<p>vector (<code>k x 1</code>) of sigma in each regime.</p>
</td></tr>
<tr><td><code id="argrid_MSARmdl_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="argrid_MSARmdl_+3A_ar">ar</code></td>
<td>
<p>number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="argrid_MSARmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code> mean is subject to change. If <code>FALSE</code> mean is constant across regimes.</p>
</td></tr>
<tr><td><code id="argrid_MSARmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code> variance is subject to change. If <code>FALSE</code> variance is constant across regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with (<code>M x ar+1</code>) matrix of means for each regime <code>M</code> (where <code>M = k^(ar+1)</code>) and each time <code>t,... t-ar</code>, vector with variance for each regime <code>M</code>, and vector indicating the corresponded <code>1,..., k</code> regime.
</p>

<hr>
<h2 id='argrid_MSVARmdl'>Vector autoregressive moment grid</h2><span id='topic+argrid_MSVARmdl'></span>

<h3>Description</h3>

<p>Creates grid of means and covariance matrices consistent with a Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argrid_MSVARmdl(mu, sigma, k, ar, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argrid_MSVARmdl_+3A_mu">mu</code></td>
<td>
<p>a (<code>k x q</code>) matrix of means in each regime (for <code>k</code> regimes and <code>q</code> time series).</p>
</td></tr>
<tr><td><code id="argrid_MSVARmdl_+3A_sigma">sigma</code></td>
<td>
<p>list with <code>k</code> regime specific (<code>q x q</code>) covariance matrices.</p>
</td></tr>
<tr><td><code id="argrid_MSVARmdl_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="argrid_MSVARmdl_+3A_ar">ar</code></td>
<td>
<p>number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="argrid_MSVARmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code> mean is subject to change. If <code>FALSE</code> mean is constant across regimes.</p>
</td></tr>
<tr><td><code id="argrid_MSVARmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code> variance is subject to change. If <code>FALSE</code> variance is constant across regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with M regime specific (<code>q x k</code>) matrices of means, List with <code>M</code> regime specific covariance matrices, and vector indicating the corresponded <code>1,..., k</code> regime.
</p>

<hr>
<h2 id='ARmdl'>Autoregressive Model</h2><span id='topic+ARmdl'></span>

<h3>Description</h3>

<p>This function estimates an autoregresive model with <code>p</code> lags. This can be used for the null hypothesis of a linear model against an alternative hypothesis of a Markov switching autoregressive model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARmdl(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARmdl_+3A_y">Y</code></td>
<td>
<p>A <code>(T x 1)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="ARmdl_+3A_p">p</code></td>
<td>
<p>Integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="ARmdl_+3A_control">control</code></td>
<td>
<p>List with model options including: 
</p>

<ul>
<li><p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>ARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x 1)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p + const)</code> matrix of lagged observations with a leading column of <code>1</code>s if <code>const=TRUE</code> or not if <code>const=FALSE</code>.
</p>
</li>
<li><p> x: a <code>(T-p x p)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T-p x 1)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T-p x 1)</code> matrix of residuals.
</p>
</li>
<li><p> mu: estimated mean of the process.
</p>
</li>
<li><p> beta: a <code>((1 + p) x 1)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> intercept: estimate of intercept.
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> stdev: estimated standard deviation of the process.
</p>
</li>
<li><p> sigma: estimated variance of the process.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code>, <code>sigma</code>, and <code>phi</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variance with <code>1</code> and <code>0</code> otherwise. This is the same as <code>theta_sig_ind</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> theta_phi_ind: vector indicating location of autoregressive coefficients with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations after lag transformation (i.e., <code>n = T-p</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series. This is always <code>1</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> k: number of regimes. This is always <code>1</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MSARmdl">MSARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of AR process
mdl_ar &lt;- list(n     = 500, 
               mu    = 5,
               sigma = 2,
               phi   = c(0.5,0.2))

# Simulate process using simuAR() function
y_simu &lt;- simuAR(mdl_ar)

# Set options for model estimation
control &lt;- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_ar_mdl &lt;- ARmdl(y_simu$y, p = 2, control)
y_ar_mdl

</code></pre>

<hr>
<h2 id='arP'>Autoregressive transition matrix</h2><span id='topic+arP'></span>

<h3>Description</h3>

<p>This function converts a transition matrix to the transition matrix consistent with a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arP(P, k, ar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arP_+3A_p">P</code></td>
<td>
<p>original transition matrix.</p>
</td></tr>
<tr><td><code id="arP_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="arP_+3A_ar">ar</code></td>
<td>
<p>number of autoregressive lags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed transition matrix.
</p>

<hr>
<h2 id='ARXmdl'>Autoregressive X Model</h2><span id='topic+ARXmdl'></span>

<h3>Description</h3>

<p>This function estimates an ARX model with <code>p</code> lags. 
This can be used for the null hypothesis of a linear model against an 
alternative hypothesis of a Markov switching autoregressive model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARXmdl(Y, p, Z, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARXmdl_+3A_y">Y</code></td>
<td>
<p>A <code>(T x 1)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="ARXmdl_+3A_p">p</code></td>
<td>
<p>Integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="ARXmdl_+3A_z">Z</code></td>
<td>
<p>A  <code>(T x qz)</code> matrix of exogenous regressors.</p>
</td></tr>
<tr><td><code id="ARXmdl_+3A_control">control</code></td>
<td>
<p>List with model options including: 
</p>

<ul>
<li><p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>ARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x 1)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p + const)</code> matrix of lagged observations with a leading column of <code>1</code>s if <code>const=TRUE</code> or not if <code>const=FALSE</code>.
</p>
</li>
<li><p> x: a <code>(T-p x p)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T-p x 1)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T-p x 1)</code> matrix of residuals.
</p>
</li>
<li><p> mu: estimated mean of the process.
</p>
</li>
<li><p> beta: a <code>((1 + p + qz) x 1)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients.
</p>
</li>
<li><p> intercept: estimate of intercept.
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> stdev: estimated standard deviation of the process.
</p>
</li>
<li><p> sigma: estimated variance of the process.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code>, <code>sigma</code>, and <code>phi</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variance with <code>1</code> and <code>0</code> otherwise. This is the same as <code>theta_sig_ind</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> theta_phi_ind: vector indicating location of autoregressive coefficients with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations after lag transformation (i.e., <code>n = T-p</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series. This is always <code>1</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> k: number of regimes. This is always <code>1</code> in <code>ARmdl</code>.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MSARmdl">MSARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of AR process
mdl_ar &lt;- list(n     = 500, 
               mu    = 5,
               sigma = 2,
               phi   = c(0.5,0.2))

# Simulate process using simuAR() function
y_simu &lt;- simuAR(mdl_ar)

# Set options for model estimation
control &lt;- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_ar_mdl &lt;- ARmdl(y_simu$y, p = 2, control)
y_ar_mdl

</code></pre>

<hr>
<h2 id='BIC.ARmdl'>BIC of a <code>ARmdl</code> object</h2><span id='topic+BIC.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.ARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.ARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='BIC.HMmdl'>BIC of a <code>HMmdl</code> object</h2><span id='topic+BIC.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.HMmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.HMmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='BIC.MSARmdl'>BIC of a <code>MSARmdl</code> object</h2><span id='topic+BIC.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.MSARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.MSARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='BIC.MSVARmdl'>BIC of a <code>MSVARmdl</code> object</h2><span id='topic+BIC.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.MSVARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.MSVARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='BIC.Nmdl'>BIC of a <code>Nmdl</code> object</h2><span id='topic+BIC.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.Nmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.Nmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='BIC.VARmdl'>BIC of a <code>VARmdl</code> object</h2><span id='topic+BIC.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>BIC()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BIC.VARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.VARmdl_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BIC value.
</p>

<hr>
<h2 id='calc_DLmoments'>Moment-based test statistics</h2><span id='topic+calc_DLmoments'></span>

<h3>Description</h3>

<p>This function computes the four moment-based test statistics (eq. <code>11</code> - <code>14</code>) discussed in Dufour &amp; Luger 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_DLmoments(ehat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_DLmoments_+3A_ehat">ehat</code></td>
<td>
<p>A (<code>T x 1</code>) vector of restricted model residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing the four test statistics.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='calc_mu2t'>Test statistic for switch in mean only</h2><span id='topic+calc_mu2t'></span>

<h3>Description</h3>

<p>This function computes part of the test statistic given by 
eq. 2.5 of CHP 2014 when the alternative has switching mean only. The output 
is used in <code><a href="#topic+chpStat">chpStat</a></code> which computes the full test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu2t(mdl, rho, ltmt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_mu2t_+3A_mdl">mdl</code></td>
<td>
<p>List containing model attributes (see <code><a href="#topic+ARmdl">ARmdl</a></code>).</p>
</td></tr>
<tr><td><code id="calc_mu2t_+3A_rho">rho</code></td>
<td>
<p>Number determining value of <code>rho</code>.</p>
</td></tr>
<tr><td><code id="calc_mu2t_+3A_ltmt">ltmt</code></td>
<td>
<p>List containing derivatives output from <code><a href="#topic+chpDmat">chpDmat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Part of test statistic given <code>rho</code> and <code>hv</code> value.
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='calc_mu2t_mv'>Test statistic for switch in mean and variance</h2><span id='topic+calc_mu2t_mv'></span>

<h3>Description</h3>

<p>This function computes part of the test statistic given by 
eq. 2.5 of CHP 2014 when the alternative has switching mean and variance. 
The output is used in <code><a href="#topic+chpStat">chpStat</a></code> which computes the full test
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu2t_mv(mdl, rho, ltmt, hv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_mu2t_mv_+3A_mdl">mdl</code></td>
<td>
<p>List containing model attributes (see <code><a href="#topic+ARmdl">ARmdl</a></code>).</p>
</td></tr>
<tr><td><code id="calc_mu2t_mv_+3A_rho">rho</code></td>
<td>
<p>Number determining value of <code>rho</code>.</p>
</td></tr>
<tr><td><code id="calc_mu2t_mv_+3A_ltmt">ltmt</code></td>
<td>
<p>List containing derivatives output from <code><a href="#topic+chpDmat">chpDmat</a></code>.</p>
</td></tr>
<tr><td><code id="calc_mu2t_mv_+3A_hv">hv</code></td>
<td>
<p>Number determining value of <code>h</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Part of test statistic given <code>rho</code> and <code>hv</code> value.
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal 
test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='calcResid_MSARmdl'>Markov-switching autoregressive model residuals</h2><span id='topic+calcResid_MSARmdl'></span>

<h3>Description</h3>

<p>This function computes residuals of a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcResid_MSARmdl(mdl, mu, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcResid_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List containing relevant parameters.</p>
</td></tr>
<tr><td><code id="calcResid_MSARmdl_+3A_mu">mu</code></td>
<td>
<p>Vector with mean in each regime.</p>
</td></tr>
<tr><td><code id="calcResid_MSARmdl_+3A_k">k</code></td>
<td>
<p>number of regimes. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>TxM</code>) matrix of residuals in each regime <code>M</code> where <code>M=k^(ar+1)</code>.
</p>

<hr>
<h2 id='calcResid_MSARXmdl'>Markov-switching autoregressive model residuals</h2><span id='topic+calcResid_MSARXmdl'></span>

<h3>Description</h3>

<p>This function computes residuals of a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcResid_MSARXmdl(mdl, mu, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcResid_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List containing relevant parameters.</p>
</td></tr>
<tr><td><code id="calcResid_MSARXmdl_+3A_mu">mu</code></td>
<td>
<p>Vector with mean in each regime.</p>
</td></tr>
<tr><td><code id="calcResid_MSARXmdl_+3A_k">k</code></td>
<td>
<p>number of regimes. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>TxM</code>) matrix of residuals in each regime <code>M</code> where <code>M=k^(ar+1)</code>.
</p>

<hr>
<h2 id='calcResid_MSVARmdl'>Markov-switching vector autoregressive model residuals</h2><span id='topic+calcResid_MSVARmdl'></span>

<h3>Description</h3>

<p>This function computes residuals of a Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcResid_MSVARmdl(mdl, mu, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcResid_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List containing relevant parameters.</p>
</td></tr>
<tr><td><code id="calcResid_MSVARmdl_+3A_mu">mu</code></td>
<td>
<p>Vector with mean in each regime.</p>
</td></tr>
<tr><td><code id="calcResid_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>M</code> (<code>Txq</code>) matrices of residuals in each regime <code>M</code> where <code>M=k^(ar+1)</code>.
</p>

<hr>
<h2 id='calcResid_MSVARXmdl'>Markov-switching VARX model residuals</h2><span id='topic+calcResid_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function computes residuals of a Markov-switching VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcResid_MSVARXmdl(mdl, mu, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcResid_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List containing relevant parameters.</p>
</td></tr>
<tr><td><code id="calcResid_MSVARXmdl_+3A_mu">mu</code></td>
<td>
<p>Vector with mean in each regime.</p>
</td></tr>
<tr><td><code id="calcResid_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>M</code> (<code>Txq</code>) matrices of residuals in each regime <code>M</code> where <code>M=k^(ar+1)</code>.
</p>

<hr>
<h2 id='chp10GNP'>Carrasco, Hu, &amp; Ploberger 2010 GNP data</h2><span id='topic+chp10GNP'></span>

<h3>Description</h3>

<p>Carrasco, Hu, &amp; Ploberger 2010 GNP data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chp10GNP
</code></pre>


<h3>Format</h3>

<p>This data is the extension of the GNP series used in CHP (2014), Econometrica. This series ranges from 
1951Q2 to 2010Q4. 
</p>
<dl>
<dt>Date</dt><dd><p>Vector of dates</p>
</dd>
<dt>GNP</dt><dd><p>US GNP series</p>
</dd>
<dt>GNP_gr</dt><dd><p>log difference of US GNP series</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.econometricsociety.org/content/supplement-optimal-test-markov-switching-parameters">https://www.econometricsociety.org/content/supplement-optimal-test-markov-switching-parameters</a>
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='CHPbootCV'>Bootstrap critical values for CHP 2014 parameter stability test</h2><span id='topic+CHPbootCV'></span>

<h3>Description</h3>

<p>This bootstrap procedure is described on pg. 771 of CHP 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CHPbootCV(mdl, rho_b, N, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CHPbootCV_+3A_mdl">mdl</code></td>
<td>
<p>List containing model attributes (see <code><a href="#topic+ARmdl">ARmdl</a></code>).</p>
</td></tr>
<tr><td><code id="CHPbootCV_+3A_rho_b">rho_b</code></td>
<td>
<p>Number determining bounds for distribution of <code>rh0</code> (i.e. <code>rho</code> ~ <code>[-rho_b,rho_b]</code>).</p>
</td></tr>
<tr><td><code id="CHPbootCV_+3A_n">N</code></td>
<td>
<p>Number of bootstrap simulations.</p>
</td></tr>
<tr><td><code id="CHPbootCV_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code>, there is a switch in variance. If <code>FALSE</code> only switch in mean is considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bootstrap critical values
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal 
test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='chpDmat'>Derivative matrix</h2><span id='topic+chpDmat'></span>

<h3>Description</h3>

<p>This function organizes the first and second derivatives of the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chpDmat(mdl, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chpDmat_+3A_mdl">mdl</code></td>
<td>
<p>List containing output from <code><a href="#topic+ARmdl">ARmdl</a></code>.</p>
</td></tr>
<tr><td><code id="chpDmat_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code>, there is a switch in variance. If <code>FALSE</code> only switch in mean is considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing relevant first and second derivatives of log-likelihood function.
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='chpStat'>Test statistic for CHP 2014 parameter stability test</h2><span id='topic+chpStat'></span>

<h3>Description</h3>

<p>This function computes the supTS and expTS test-statistics 
proposed in CHP 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chpStat(mdl, rho_b, ltmt, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chpStat_+3A_mdl">mdl</code></td>
<td>
<p>List containing model attributes (see <code><a href="#topic+ARmdl">ARmdl</a></code>).</p>
</td></tr>
<tr><td><code id="chpStat_+3A_rho_b">rho_b</code></td>
<td>
<p>Number determining bounds for distribution of <code>rh0</code> (i.e. <code>rho</code> ~ <code>[-rho_b,rho_b]</code>).</p>
</td></tr>
<tr><td><code id="chpStat_+3A_ltmt">ltmt</code></td>
<td>
<p>List containing derivatives output from <code><a href="#topic+chpDmat">chpDmat</a></code>.</p>
</td></tr>
<tr><td><code id="chpStat_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicator. If <code>TRUE</code>, there is a switch in variance. If <code>FALSE</code> only switch in mean is considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>2 x 1</code>) vector with supTS test statistic as first element and expTS test-statistics as second element.
</p>


<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal 
test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>

<hr>
<h2 id='CHPTest'>Carrasco, Hu, and Ploberger (2014) parameter stability test</h2><span id='topic+CHPTest'></span>

<h3>Description</h3>

<p>This function performs the CHP (2014) parameter stability test as outline in Carrasco, M., Hu, L. and Ploberger, W. (2014).
Original source code can be found <a href="https://www.econometricsociety.org/content/supplement-optimal-test-markov-switching-parametershere">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CHPTest(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CHPTest_+3A_y">Y</code></td>
<td>
<p>A (<code>T x 1</code>) matrix of observations.</p>
</td></tr>
<tr><td><code id="CHPTest_+3A_p">p</code></td>
<td>
<p>Integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="CHPTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> N: Integer determining the number of Bootstrap iterations. Default is set to <code>3000</code> as in paper.
</p>
</li>
<li><p> rho_b: Number determining bounds for distribution of <code>rh0</code> (i.e. <code>rho</code> ~ <code>[-rho_b,rho_b]</code>).
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, there is a switch in variance. If <code>FALSE</code> only switch in mean is considered.
</p>
</li>
<li><p> getSE: Boolean indicator. If <code>TRUE</code>, standard errors for restricted model are estimated. If <code>FALSE</code> no standard errors are estimated. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>CHPTest</code> (<code>S3</code> object) with model attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. This will be of class <code>ARmdl</code> (<code>S3</code> object). See <code><a href="#topic+ARmdl">ARmdl</a></code>.
</p>
</li>
<li><p> supTS: supTS test statistic value.
</p>
</li>
<li><p> expTS: expTS test statistic value.
</p>
</li>
<li><p> supTS_N: A (<code>N x 1</code>) vector with simulated supTS test statistics under null hypothesis.
</p>
</li>
<li><p> expTS_N: A (<code>N x 1</code>) vector with simulated expTS test statistics under null hypothesis.
</p>
</li>
<li><p> pval_supTS: P-value for supTS version of parameter stability test.
</p>
</li>
<li><p> pval_expTS: P-value for expTS version of parameter stability test.
</p>
</li>
<li><p> supTS_cv: Vector with 90%, 95%, and 99% bootstrap critical values for supTS version of parameter stability test.
</p>
</li>
<li><p> expTS_cv: Vector with 90%, 95%, and 99% bootstrap critical values for expTS version of parameter stability test.
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li></ul>



<h3>References</h3>

<p>Carrasco, Marine, Liang Hu, and Werner Ploberger. 2014. “Optimal test for Markov switching parameters.” <em>Econometrica</em> 82 (2): 765–784.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data used in Hamilton 1989 
y84 &lt;- as.matrix(hamilton84GNP$GNP_gr)


# Set test procedure options
control = list(N = 1000, 
               rho_b = 0.7, 
               msvar = FALSE)

# perform test with switch in mean only on Hamilton 1989 data

  mdl_84_msmu &lt;- CHPTest(y84, p = 4, control = control)
  summary(mdl_84_msmu)

</code></pre>

<hr>
<h2 id='clike'>Parameter vector &amp; likelihood function used by <code>HLRTest()</code></h2><span id='topic+clike'></span>

<h3>Description</h3>

<p>This function combines parameters of restricted model 
with parameters of unrestricted model and then computes the likelihood using 
<code>marklike()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clike(b, HLR_opt_ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clike_+3A_b">b</code></td>
<td>
<p>vector of parameters from restricted model.</p>
</td></tr>
<tr><td><code id="clike_+3A_hlr_opt_ls">HLR_opt_ls</code></td>
<td>
<p>List with model properties and test controls defined in <code>HLRTest()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of likelihood at each period <code>t</code>.
</p>

<hr>
<h2 id='coef.ARmdl'>coef of a <code>ARmdl</code> object</h2><span id='topic+coef.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.ARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.ARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='coef.HMmdl'>coef of a <code>HMmdl</code> object</h2><span id='topic+coef.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.HMmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.HMmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='coef.MSARmdl'>coef of a <code>MSARmdl</code> object</h2><span id='topic+coef.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.MSARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.MSARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='coef.MSVARmdl'>coef of a <code>MSVARmdl</code> object</h2><span id='topic+coef.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.MSVARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.MSVARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='coef.Nmdl'>coef of a <code>Nmdl</code> object</h2><span id='topic+coef.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.Nmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.Nmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='coef.VARmdl'>coef of a <code>VARmdl</code> object</h2><span id='topic+coef.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>coef()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.VARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef.VARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coefficients.
</p>

<hr>
<h2 id='combine_stat'>Combine p-values</h2><span id='topic+combine_stat'></span>

<h3>Description</h3>

<p>This function is used to combine the four moment-based p-values as in eq. <code>17</code> and <code>18</code> of Dufour &amp; Luger 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_stat(stats, params, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_stat_+3A_stats">stats</code></td>
<td>
<p>A (<code>l x 4</code>) matrix where <code>l</code> is the number of moment-based test statistics.</p>
</td></tr>
<tr><td><code id="combine_stat_+3A_params">params</code></td>
<td>
<p>A (<code>2 x 4</code>) matrix with parameters to combine test statistics. See <code><a href="#topic+approxDistDL">approxDistDL</a></code>.</p>
</td></tr>
<tr><td><code id="combine_stat_+3A_type">type</code></td>
<td>
<p>String determining the type of method used to combine p-values. If set to &quot;min&quot; the min method of combining p-values 
is used as in Fisher 1932 and Pearson 1933. If set to &quot;prod&quot; the product of p-values is used as in Tippett 1931 and Wilkinson 1951.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>N x 1</code>) vector with test statistics. The last element is the test statistic from observed data.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>
<p>Tippett, L. 1931. &quot;The Method of Statistics&quot;. London: Williams &amp; Norgate.
</p>
<p>Wilkinson, B. 1951. &quot;A statistical consideration in psychological research.&quot; <em>Psychology Bulletin</em> 48:156–158.
</p>
<p>Pearson, K. 1933. &quot;On a method of determining whether a sample of size n
supposed to have been drawn from a parent population having a known probability integral has probably been drawn at random&quot;. <em>Biometrika</em> 25:379–410.
</p>
<p>Fisher, R. 1932. &quot;Statistical Methods for Research Workers.&quot; Edinburgh: Oliver and Boyd.
</p>

<hr>
<h2 id='companionMat'>Companion Matrix</h2><span id='topic+companionMat'></span>

<h3>Description</h3>

<p>This function converts the (<code>q x 1</code>)  vector of constants and (<code>q x qp</code>) matrix of autoregressive coefficients into (<code>qp x qp</code>) matrix belonging to the companion form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>companionMat(phi, p, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="companionMat_+3A_phi">phi</code></td>
<td>
<p>matrix of dimension (<code>q x qp</code>) containing autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="companionMat_+3A_p">p</code></td>
<td>
<p>integer for number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="companionMat_+3A_q">q</code></td>
<td>
<p>integer for number of series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of dimension (<code>qp x qp</code>) of companion form.
</p>

<hr>
<h2 id='compu_tstat'>Computes test stat using new parameter vectors</h2><span id='topic+compu_tstat'></span>

<h3>Description</h3>

<p>This function computes the LRT statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compu_tstat(theta_h0, mdl_h0, LT_h1, p, q, k0, exog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compu_tstat_+3A_theta_h0">theta_h0</code></td>
<td>
<p>estimated parameter values for restricted model.</p>
</td></tr>
<tr><td><code id="compu_tstat_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="compu_tstat_+3A_lt_h1">LT_h1</code></td>
<td>
<p>Double specifying maximum log likelihood under alternative.</p>
</td></tr>
<tr><td><code id="compu_tstat_+3A_p">p</code></td>
<td>
<p>integer specifying the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="compu_tstat_+3A_q">q</code></td>
<td>
<p>integer specifying the number of series.</p>
</td></tr>
<tr><td><code id="compu_tstat_+3A_k0">k0</code></td>
<td>
<p>integer specifying the number of regimes under the null hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LRT statistic
</p>

<hr>
<h2 id='cov2corr'>Covariance to correlation matrix</h2><span id='topic+cov2corr'></span>

<h3>Description</h3>

<p>This function takes an (<code>n x n</code>) covariance matrix and returns the associated (<code>n x n</code>) correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov2corr(cov_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov2corr_+3A_cov_mat">cov_mat</code></td>
<td>
<p>A (<code>n x n</code>) covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>n x n</code>) correlation matrix.
</p>

<hr>
<h2 id='covar_unvech'>Covariance vech to matrix</h2><span id='topic+covar_unvech'></span>

<h3>Description</h3>

<p>This function undoes the half-vectorization of a covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar_unvech(sig, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covar_unvech_+3A_sig">sig</code></td>
<td>
<p>A (n+1)*n/2 vector.</p>
</td></tr>
<tr><td><code id="covar_unvech_+3A_n">n</code></td>
<td>
<p>Integer determining shape of the original matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>n x n</code>) covariance matrix.
</p>

<hr>
<h2 id='covar_vech'>Covariance vech function</h2><span id='topic+covar_vech'></span>

<h3>Description</h3>

<p>This function returns the half-vectorization of an input matrix as a column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar_vech(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covar_vech_+3A_mat">mat</code></td>
<td>
<p>A (<code>n x n</code>) covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>(n+1)*n/2</code> column vector.
</p>

<hr>
<h2 id='DLMCTest'>Monte Carlo moment-based test for Markov switching model</h2><span id='topic+DLMCTest'></span>

<h3>Description</h3>

<p>This function performs the Local Monte Carlo moment-based test for
Markov switching autoregressive models proposed in Dufour &amp; Luger (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLMCTest(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLMCTest_+3A_y">Y</code></td>
<td>
<p>Series to be tested</p>
</td></tr>
<tr><td><code id="DLMCTest_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="DLMCTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> N: Integer determining the number of Monte Carlo simulations. Default is set to <code>99</code> as in paper.
</p>
</li>
<li><p> simdist_N: Integer determining the number of simulations for CDF distribution approximation. Default is set to <code>10000</code>.
</p>
</li>
<li><p> getSE: Boolean indicator. If <code>TRUE</code>, standard errors for restricted model are estimated. If <code>FALSE</code> no standard errors are estimated. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>DLMCTest</code> (<code>S3</code> object) with attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. This will be of class <code>ARmdl</code> if <code>p&gt;0</code> or <code>Nmdl</code> otherwise (<code>S3</code> objects). See <code><a href="#topic+ARmdl">ARmdl</a></code> or <code><a href="#topic+Nmdl">Nmdl</a></code>.    
</p>
</li>
<li><p> theta: Value of nuisance parameters. Specifically, these are the consistent estimates of nuisance parameters as discussed in Dufour &amp; Luger (2017) LMC procedure.
</p>
</li>
<li><p> S0: A (<code>1 x 4</code>)) matrix containing the four moment-based test statistics defined in (<code>11</code>) - (<code>14</code>) in Dufour &amp; Luger (2017).
</p>
</li>
<li><p> F0_min: Test statistic value for min version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> F0_prod: Test statistic value for prod version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_min: A (<code>N x 1</code>) vector with simulated test statistics for min version of Local Monte Carlo moment-based test under null hypothesis.
</p>
</li>
<li><p> FN_prod: A (<code>N x 1</code>) vector with simulated test statistics for prod version of Local Monte Carlo moment-based test under null hypothesis.
</p>
</li>
<li><p> pval_min: P-value for min version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> pval_prod: P-value for prod version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_min_cv: Vector with 90%, 95%, and 99% Monte Carlo critical values for min version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_prod_cv: Vector with 90%, 95%, and 99% Monte Carlo critical values for prod version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li></ul>



<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based tests for 
Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# load data used in Hamilton 1989 and extended data used in CHP 2014 
y84 &lt;- as.matrix(hamilton84GNP$GNP_gr)
y10 &lt;- as.matrix(chp10GNP$GNP_gr)

# Set test procedure options
lmc_control = list(N = 99,
                   simdist_N = 10000,
                   getSE = TRUE)

# perform test on Hamilton 1989 data
lmc_gnp84 &lt;- DLMCTest(y84, p = 4, control = lmc_control)
summary(lmc_gnp84)

</code></pre>

<hr>
<h2 id='DLMMC_bounds'>MMC nuisance parameter bounds for Moment-based test</h2><span id='topic+DLMMC_bounds'></span>

<h3>Description</h3>

<p>This function is used to determine the lower and upper bounds for the MMC LRT parameter search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLMMC_bounds(mdl_h0, con)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLMMC_bounds_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="DLMMC_bounds_+3A_con">con</code></td>
<td>
<p>List with control options provided to <code>DLMMCTest</code> procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>theta_low</code>, vector of parameter lower bounds, and <code>theta_upp</code>, vector of parameter upper bounds.
</p>

<hr>
<h2 id='DLMMCpval_fun'>Moment-based MMC test p-value</h2><span id='topic+DLMMCpval_fun'></span>

<h3>Description</h3>

<p>This functions is used by numerical optimization algorithms for find maximum p-value given parameter vector <code>theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLMMCpval_fun(
  theta,
  y,
  x,
  params,
  sim_stats,
  pval_type,
  stationary_ind,
  lambda
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLMMCpval_fun_+3A_theta">theta</code></td>
<td>
<p>Value of nuisance parameters. Specifically, these are the consistent estimates of nuisance parameters as discussed in Dufour &amp; Luger (2017) LMC procedure.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_y">y</code></td>
<td>
<p>series being tested.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_x">x</code></td>
<td>
<p>lagged values of series.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_params">params</code></td>
<td>
<p>A (<code>2 x 4</code>) matrix with parameters to combine test statistics. See <code><a href="#topic+approxDistDL">approxDistDL</a></code>.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_sim_stats">sim_stats</code></td>
<td>
<p>A (<code>N x 1</code>) vector with test statistics. The last element is the test statistic from observed data.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_pval_type">pval_type</code></td>
<td>
<p>String determining the type of method used to combine p-values. If set to &quot;min&quot; the min method of combining p-values is used as in Fisher 1932 and Pearson 1933. If set to &quot;prod&quot; the product of p-values is used as in Tippett 1931 and Wilkinson 1951.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_stationary_ind">stationary_ind</code></td>
<td>
<p>Boolean indicator determining if only stationary solutions should be considered if <code>TRUE</code> or any solution can be considered if <code>FALSE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value for penalty on stationary constraint not being met. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximized Monte Carlo p-value.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='DLMMCpval_fun_min'>Moment-based MMC test (negative) p-value</h2><span id='topic+DLMMCpval_fun_min'></span>

<h3>Description</h3>

<p>This functions is used by numerical optimization algorithms for find negative of maximum p-value given parameter vector <code>theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLMMCpval_fun_min(
  theta,
  y,
  x,
  params,
  sim_stats,
  pval_type,
  stationary_ind,
  lambda
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLMMCpval_fun_min_+3A_theta">theta</code></td>
<td>
<p>Value of nuisance parameters. Specifically, these are the consistent estimates of nuisance parameters as discussed in Dufour &amp; Luger (2017) LMC procedure.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_y">y</code></td>
<td>
<p>series being tested.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_x">x</code></td>
<td>
<p>lagged values of series.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_params">params</code></td>
<td>
<p>A (<code>2 x 4</code>) matrix with parameters to combine test statistics. See <code><a href="#topic+approxDistDL">approxDistDL</a></code>.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_sim_stats">sim_stats</code></td>
<td>
<p>A (<code>N x 1</code>) vector with test statistics. The last element is the test statistic from observed data.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_pval_type">pval_type</code></td>
<td>
<p>String determining the type of method used to combine p-values. If set to &quot;min&quot; the min method of combining p-values is used as in Fisher 1932 and Pearson 1933. If set to &quot;prod&quot; the product of p-values is used as in Tippett 1931 and Wilkinson 1951.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_stationary_ind">stationary_ind</code></td>
<td>
<p>Boolean indicator determining if only stationary solutions should be considered if <code>TRUE</code> or any solution can be considered if <code>FALSE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DLMMCpval_fun_min_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value for penalty on stationary constraint not being met. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Maximized Monte Carlo p-value.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='DLMMCTest'>Maximized Monte Carlo moment-based test for Markov switching model</h2><span id='topic+DLMMCTest'></span>

<h3>Description</h3>

<p>This function performs the maximized Monte Carlo moment-based test for
Markov switching autoregressive models proposed in Dufour &amp; Luger (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLMMCTest(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLMMCTest_+3A_y">Y</code></td>
<td>
<p>Series to be tested</p>
</td></tr>
<tr><td><code id="DLMMCTest_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="DLMMCTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> N: Integer determining the number of Monte Carlo simulations. Default is set to <code>99</code> as in paper.
</p>
</li>
<li><p> simdist_N: Integer determining the number of simulations for CDF distribution approximation. Default is set to <code>10000</code>.
</p>
</li>
<li><p> getSE: Boolean indicator. If <code>TRUE</code>, standard errors for restricted model are estimated. If <code>FALSE</code> no standard errors are estimated. Default is <code>TRUE</code>.
</p>
</li>
<li><p> eps: Fixed positive constant that does not depend on <code>T</code> used to determine lower and upper bounds on consistent set considered for nuisance parameter space.
</p>
</li>
<li><p> CI_union: Boolean indicator determining if union between <code>eps</code> and confidence interval is used to determine lower and upper bound on consistent set considered for nuisance parameter space. If <code>TRUE</code> union is used and if <code>FALSE</code> only <code>eps</code> is used. Note that if standard errors obtained are not finite then only <code>eps</code> is used. Default is <code>FALSE</code>.       
</p>
</li>
<li><p> lambda: Numeric value for penalty on stationary constraint not being met. Default is <code>100</code>.
</p>
</li>
<li><p> stationary_ind: Boolean indicator determining if only stationary solutions should be considered if <code>TRUE</code> or any solution can be considered if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> phi_low: Vector with lower bound for autoregressive parameters when optimizing. Default is <code>NULL</code>.
</p>
</li>
<li><p> phi_upp: Vector with upper bound for autoregressive parameters when optimizing. Default is <code>NULL</code>.
</p>
</li>
<li><p> optim_type: String determining type of numerical optimization algorithm to use. Available options are: <code><a href="pso.html#topic+pso">pso</a></code>, <code><a href="GenSA.html#topic+GenSA">GenSA</a></code>, <code><a href="GA.html#topic+GA">GA</a></code>. Default is <code><a href="pso.html#topic+pso">pso</a></code>.
</p>
</li>
<li><p> silence: Boolean indicator determining if optimization updates should be silenced if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>FALSE</code>.
</p>
</li>
<li><p> threshold_stop: Numeric value determining the maximum possible p-value attainable. Default is <code>1</code>.
</p>
</li>
<li><p> maxit: Int determining the maximum number of function evaluations. Default is <code>1000</code>.
</p>
</li>
<li><p> optim_control: List containing other optimization options specific to the numerical optimization algorithm used. For other options see documentation of numerical algorithm chosen.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>DLMCTest</code> (<code>S3</code> object) with attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. This will be of class <code>ARmdl</code> if <code>p&gt;0</code> or <code>Nmdl</code> otherwise (<code>S3</code> objects). See <code><a href="#topic+ARmdl">ARmdl</a></code> or <code><a href="#topic+Nmdl">Nmdl</a></code>.    
</p>
</li>
<li><p> theta_max_min: Value of nuisance parameters when min version of p-value is maximized as discussed in Dufour &amp; Luger (2017) MMC procedure.
</p>
</li>
<li><p> theta_max_prod: Value of nuisance parameters when prod version of p-value is maximized as discussed in Dufour &amp; Luger (2017) MMC procedure.
</p>
</li>
<li><p> theta_low: Lower bound on nuisance parameter values used when searching for maximum p-value.
</p>
</li>
<li><p> theta_upp: Upper bound on nuisance parameter values used when searching for maximum p-value.
</p>
</li>
<li><p> S0_min: A (<code>1 x 4</code>)) matrix containing the four moment-based test statistics defined in (<code>11</code>) - (<code>14</code>) in Dufour &amp; Luger (2017) when <code>theta_min</code> is used.
</p>
</li>
<li><p> S0_prod: A (<code>1 x 4</code>)) matrix containing the four moment-based test statistics defined in (<code>11</code>) - (<code>14</code>) in Dufour &amp; Luger (2017) when <code>theta_prod</code> is used.
</p>
</li>
<li><p> F0_min: Test statistic value for min version of Maximized Monte Carlo moment-based test.
</p>
</li>
<li><p> F0_prod: Test statistic value for prod version of Maximized Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_min: A (<code>N x 1</code>) vector with simulated test statistics for min version of Maximized Monte Carlo moment-based test under null hypothesis.
</p>
</li>
<li><p> FN_prod: A (<code>N x 1</code>) vector with simulated test statistics for prod version of Maximized Monte Carlo moment-based test under null hypothesis.
</p>
</li>
<li><p> pval_min: Maximum p-value for min version of Maximized Monte Carlo moment-based test.
</p>
</li>
<li><p> pval_prod: Maximum p-value for prod version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_min_cv: Vector with 90%, 95%, and 99% Monte Carlo critical values for min version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> FN_prod_cv: Vector with 90%, 95%, and 99% Monte Carlo critical values for prod version of Local Monte Carlo moment-based test.
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li>
<li><p> optim_min_output: List with optimization output for min version of Maximized Monte Carlo moment-based test.
</p>
</li>
<li><p> optim_prod_output: List with optimization output for prod version of Maximized Monte Carlo moment-based test.
</p>
</li></ul>



<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based tests for 
Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# load data used in Hamilton 1989 and extended data used in CHP 2014 
y84 &lt;- as.matrix(hamilton84GNP$GNP_gr)
y10 &lt;- as.matrix(chp10GNP$GNP_gr)

# Set test procedure options
mmc_control &lt;- list(N = 99,
                    simdist_N = 10000,
                    getSE = TRUE,
                    eps = 0, 
                    CI_union = TRUE,
                    lambda = 100,
                    stationary_ind = TRUE,
                    optim_type = "GenSA",
                    silence = FALSE,
                    threshold_stop = 1,
                    maxit = 200)


# perform test on Hamilton 1989 data

  mmc_gnp84 &lt;- DLMMCTest(y84, p = 4, control = mmc_control)
  summary(mmc_gnp84)


</code></pre>

<hr>
<h2 id='dmclike'>Gradient of likelihood function.</h2><span id='topic+dmclike'></span>

<h3>Description</h3>

<p>this function computes the score vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmclike(th, HLR_opt_ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmclike_+3A_th">th</code></td>
<td>
<p>vector of parameter values.</p>
</td></tr>
<tr><td><code id="dmclike_+3A_hlr_opt_ls">HLR_opt_ls</code></td>
<td>
<p>List with model properties and test controls defined in <code>HLRTest()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with gradient of likelihood function for each parameter. Used in <code>HLRpramSearch()</code>.
</p>

<hr>
<h2 id='EMaximization_HMmdl'>Maximization step of EM algorithm for Hidden Markov model</h2><span id='topic+EMaximization_HMmdl'></span>

<h3>Description</h3>

<p>This function performs the maximization step of the Expectation Maximization algorithm for Hidden Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMaximization_HMmdl(theta, mdl, MSloglik_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMaximization_HMmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="EMaximization_HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMaximization_HMmdl_+3A_msloglik_output">MSloglik_output</code></td>
<td>
<p>List with output from <code><a href="#topic+ExpectationM_HMmdl">ExpectationM_HMmdl</a></code>.</p>
</td></tr>
<tr><td><code id="EMaximization_HMmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with new maximized parameters.
</p>

<hr>
<h2 id='EMaximization_MSARmdl'>Maximization step of EM algorithm for Markov-switching autoregressive model</h2><span id='topic+EMaximization_MSARmdl'></span>

<h3>Description</h3>

<p>This function performs the maximization step of the Expectation Maximization algorithm for Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMaximization_MSARmdl(theta, mdl, MSloglik_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMaximization_MSARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARmdl_+3A_msloglik_output">MSloglik_output</code></td>
<td>
<p>List with output from <code><a href="#topic+ExpectationM_MSARmdl">ExpectationM_MSARmdl</a></code>.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with new maximized parameters.
</p>

<hr>
<h2 id='EMaximization_MSARXmdl'>Maximization step of EM algorithm for Markov-switching ARX model</h2><span id='topic+EMaximization_MSARXmdl'></span>

<h3>Description</h3>

<p>This function performs the maximization step of the Expectation Maximization algorithm for Markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMaximization_MSARXmdl(theta, mdl, MSloglik_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMaximization_MSARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARXmdl_+3A_msloglik_output">MSloglik_output</code></td>
<td>
<p>List with output from <code><a href="#topic+ExpectationM_MSARmdl">ExpectationM_MSARmdl</a></code>.</p>
</td></tr>
<tr><td><code id="EMaximization_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with new maximized parameters.
</p>

<hr>
<h2 id='EMaximization_MSVARmdl'>Maximization step of EM algorithm for Markov-switching vector autoregressive model</h2><span id='topic+EMaximization_MSVARmdl'></span>

<h3>Description</h3>

<p>This function performs the maximization step of the Expectation Maximization algorithm for Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMaximization_MSVARmdl(theta, mdl, MSloglik_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMaximization_MSVARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARmdl_+3A_msloglik_output">MSloglik_output</code></td>
<td>
<p>List with output from <code><a href="#topic+ExpectationM_MSVARmdl">ExpectationM_MSVARmdl</a></code>.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with new maximized parameters.
</p>

<hr>
<h2 id='EMaximization_MSVARXmdl'>Maximization step of EM algorithm for Markov-switching VARX model</h2><span id='topic+EMaximization_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function performs the maximization step of the Expectation Maximization algorithm for Markov-switching VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMaximization_MSVARXmdl(theta, mdl, MSloglik_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMaximization_MSVARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARXmdl_+3A_msloglik_output">MSloglik_output</code></td>
<td>
<p>List with output from <code><a href="#topic+ExpectationM_MSVARmdl">ExpectationM_MSVARmdl</a></code>.</p>
</td></tr>
<tr><td><code id="EMaximization_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with new maximized parameters.
</p>

<hr>
<h2 id='EMiter_HMmdl'>EM algorithm iteration for Hidden Markov model</h2><span id='topic+EMiter_HMmdl'></span>

<h3>Description</h3>

<p>This function performs the one iteration (E-step and M-step) of the Expectation Maximization algorithm for a Hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiter_HMmdl(mdl, EMest_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiter_HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMiter_HMmdl_+3A_emest_output">EMest_output</code></td>
<td>
<p>List with attributes from previous iteration.</p>
</td></tr>
<tr><td><code id="EMiter_HMmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with attributes from new iteration.
</p>

<hr>
<h2 id='EMiter_MSARmdl'>EM algorithm iteration for Markov-switching autoregressive model</h2><span id='topic+EMiter_MSARmdl'></span>

<h3>Description</h3>

<p>This function performs the one iteration (E-step and M-step) of the Expectation Maximization algorithm for Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiter_MSARmdl(mdl, EMest_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiter_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMiter_MSARmdl_+3A_emest_output">EMest_output</code></td>
<td>
<p>List with attributes from previous iteration.</p>
</td></tr>
<tr><td><code id="EMiter_MSARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with attributes from new iteration.
</p>

<hr>
<h2 id='EMiter_MSARXmdl'>EM algorithm iteration for Markov-switching ARX model</h2><span id='topic+EMiter_MSARXmdl'></span>

<h3>Description</h3>

<p>This function performs the one iteration (E-step and M-step) of the Expectation Maximization algorithm for Markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiter_MSARXmdl(mdl, EMest_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiter_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMiter_MSARXmdl_+3A_emest_output">EMest_output</code></td>
<td>
<p>List with attributes from previous iteration.</p>
</td></tr>
<tr><td><code id="EMiter_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with attributes from new iteration.
</p>

<hr>
<h2 id='EMiter_MSVARmdl'>EM algorithm iteration for Markov-switching vector autoregressive model</h2><span id='topic+EMiter_MSVARmdl'></span>

<h3>Description</h3>

<p>This function performs the one iteration (E-step and M-step) of the Expectation Maximization algorithm for Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiter_MSVARmdl(mdl, EMest_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiter_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMiter_MSVARmdl_+3A_emest_output">EMest_output</code></td>
<td>
<p>List with attributes from previous iteration.</p>
</td></tr>
<tr><td><code id="EMiter_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with attributes from new iteration.
</p>

<hr>
<h2 id='EMiter_MSVARXmdl'>EM algorithm iteration for Markov-switching VARX model</h2><span id='topic+EMiter_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function performs the one iteration (E-step and M-step) of the Expectation Maximization algorithm for Markov-switching VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMiter_MSVARXmdl(mdl, EMest_output, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMiter_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="EMiter_MSVARXmdl_+3A_emest_output">EMest_output</code></td>
<td>
<p>List with attributes from previous iteration.</p>
</td></tr>
<tr><td><code id="EMiter_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with attributes from new iteration.
</p>

<hr>
<h2 id='estimMdl'>Estimate model for likelihood ratio test</h2><span id='topic+estimMdl'></span>

<h3>Description</h3>

<p>This function is used by the Monte Carlo testing procedures 
to estimate restricted and unrestricted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimMdl(Y, p, q, k, Z = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimMdl_+3A_y">Y</code></td>
<td>
<p>Series to be tested. Must be a (<code>T x q</code>) matrix.</p>
</td></tr>
<tr><td><code id="estimMdl_+3A_p">p</code></td>
<td>
<p>integer specifying the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="estimMdl_+3A_q">q</code></td>
<td>
<p>integer specifying the number of series.</p>
</td></tr>
<tr><td><code id="estimMdl_+3A_k">k</code></td>
<td>
<p>integer specifying the number of regimes.</p>
</td></tr>
<tr><td><code id="estimMdl_+3A_z">Z</code></td>
<td>
<p>exogeneous regressors. Defualt is NULL.</p>
</td></tr>
<tr><td><code id="estimMdl_+3A_control">control</code></td>
<td>
<p>List with control options for model estimation. For default values, see description of model being estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with estimated model properties.
</p>

<hr>
<h2 id='ExpectationM_HMmdl'>Hidden Markov model log-likelihood function</h2><span id='topic+ExpectationM_HMmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a Hidden Markov model and uses the Hamilton smoother to obtain smoothed probabilities of each state. This is also the expectation step in the Expectation Maximization algorithm for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectationM_HMmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectationM_HMmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="ExpectationM_HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="ExpectationM_HMmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which includes log-likelihood value and smoothed probabilities of each regime.
</p>

<hr>
<h2 id='ExpectationM_MSARmdl'>Markov-switching autoregressive log-likelihood function</h2><span id='topic+ExpectationM_MSARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching autoregressive model and uses the Hamilton smoother to obtain smoothed probabilities of each state. This is also the expectation step in the Expectation Maximization algorithm for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectationM_MSARmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectationM_MSARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which includes log-likelihood and smoothed probabilities of each regime.
</p>

<hr>
<h2 id='ExpectationM_MSARXmdl'>Markov-switching ARX log-likelihood function</h2><span id='topic+ExpectationM_MSARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching autoregressive model and uses the Hamilton smoother to obtain smoothed probabilities of each state. This is also the expectation step in the Expectation Maximization algorithm for a Markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectationM_MSARXmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectationM_MSARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which includes log-likelihood and smoothed probabilities of each regime.
</p>

<hr>
<h2 id='ExpectationM_MSVARmdl'>Markov-switching vector autoregressive log-likelihood function</h2><span id='topic+ExpectationM_MSVARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching vector autoregressive model and uses the Hamilton smoother to obtain smoothed probabilities of each state. This is also the expectation step in the Expectation Maximization algorithm for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectationM_MSVARmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectationM_MSVARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which includes log-likelihood and smoothed probabilities of each regime.
</p>

<hr>
<h2 id='ExpectationM_MSVARXmdl'>Markov-switching VARX log-likelihood function</h2><span id='topic+ExpectationM_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching VARX model and uses the Hamilton smoother to obtain smoothed probabilities of each state. This is also the expectation step in the Expectation Maximization algorithm for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectationM_MSVARXmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectationM_MSVARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="ExpectationM_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which includes log-likelihood and smoothed probabilities of each regime.
</p>

<hr>
<h2 id='fitted.ARmdl'>fitted values of a <code>ARmdl</code> object</h2><span id='topic+fitted.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.ARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.ARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='fitted.HMmdl'>fitted values of a <code>HMmdl</code> object</h2><span id='topic+fitted.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.HMmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.HMmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='fitted.MSARmdl'>fitted values of a <code>MSARmdl</code> object</h2><span id='topic+fitted.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.MSARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.MSARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='fitted.MSVARmdl'>fitted values of a <code>MSVARmdl</code> object</h2><span id='topic+fitted.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.MSVARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.MSVARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='fitted.Nmdl'>fitted values of a <code>Nmdl</code> object</h2><span id='topic+fitted.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.Nmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.Nmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='fitted.VARmdl'>fitted values of a <code>VARmdl</code> object</h2><span id='topic+fitted.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>fitted()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.VARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model fitted values is
meaningful.</p>
</td></tr>
<tr><td><code id="fitted.VARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fitted values
</p>

<hr>
<h2 id='getHessian'>Hessian matrix</h2><span id='topic+getHessian'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.ARmdl'>Hessian matrix of autoregressive model</h2><span id='topic+getHessian.ARmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for an autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.ARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.HMmdl'>Hessian matrix of Hidden Markov model</h2><span id='topic+getHessian.HMmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for a Hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.MSARmdl'>Hessian matrix of Markov-switching autoregressive model</h2><span id='topic+getHessian.MSARmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.MSVARmdl'>Hessian matrix of Markov-switching vector autoregressive model</h2><span id='topic+getHessian.MSVARmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for a Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.Nmdl'>Hessian matrix of normal model</h2><span id='topic+getHessian.Nmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for a normally distributed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.Nmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='getHessian.VARmdl'>Hessian matrix of vector autoregressive model</h2><span id='topic+getHessian.VARmdl'></span>

<h3>Description</h3>

<p>This function is used to obtain a numerical approximation of a Hessian matrix for a vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
getHessian(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHessian.VARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix.
</p>

<hr>
<h2 id='hamilton84GNP'>Hamilton 1984 &amp; Hansen 1992 GNP data</h2><span id='topic+hamilton84GNP'></span>

<h3>Description</h3>

<p>Hamilton 1984 &amp; Hansen 1992 GNP data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamilton84GNP
</code></pre>


<h3>Format</h3>

<p>This data set is used in Hansen (1992) to test the US GNP model proposed by 
Hamilton (1989). This series ranges from 1951Q2 to 1984Q4. 
</p>
<dl>
<dt>Date</dt><dd><p>Vector of dates</p>
</dd>
<dt>GNP</dt><dd><p>US GNP series</p>
</dd>
<dt>GNP_gr</dt><dd><p>US GNP log difference</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ssc.wisc.edu/~bhansen/progs/jae_92.html">https://www.ssc.wisc.edu/~bhansen/progs/jae_92.html</a>
</p>


<h3>References</h3>

<p>Hansen, Bruce E. 1992. “The likelihood ratio test under nonstandard conditions: testing the Markov switching model of GNP.” <em>Journal of applied Econometrics</em> 7 (S1): S61–S82.
</p>
<p>Hamilton, James D. 1989. “A new approach to the economic analysis of nonstationary time series and the business cycle.” <em>Econometrica</em> 57 (2): 357–384.
</p>

<hr>
<h2 id='HLRparamSearch'>HLR param search</h2><span id='topic+HLRparamSearch'></span>

<h3>Description</h3>

<p>This function performs the parameter grid search needed for 
the likelihood ratio test described in Hansen (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLRparamSearch(gx, gp, gq, b, null, HLR_opt_ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HLRparamSearch_+3A_gx">gx</code></td>
<td>
<p>matrix/grid containing values for switching parameters in second regime.</p>
</td></tr>
<tr><td><code id="HLRparamSearch_+3A_gp">gp</code></td>
<td>
<p>matrix/grid containing values for probability of going from regime 1 at (<code>t</code>) to regime 1 at (<code>t+1</code>).</p>
</td></tr>
<tr><td><code id="HLRparamSearch_+3A_gq">gq</code></td>
<td>
<p>matrix/grid containing values for probability of going from regime 2 at (<code>t</code>) to regime 2 at (<code>t+1</code>) (if not bounded to be <code>1-p</code> i.e., <code>qbound=FALSE</code>).</p>
</td></tr>
<tr><td><code id="HLRparamSearch_+3A_b">b</code></td>
<td>
<p>vector of initial parameter values of restricted model.</p>
</td></tr>
<tr><td><code id="HLRparamSearch_+3A_null">null</code></td>
<td>
<p>vector with likelihood under the null hypothesis.</p>
</td></tr>
<tr><td><code id="HLRparamSearch_+3A_hlr_opt_ls">HLR_opt_ls</code></td>
<td>
<p>List with model properties and test controls defined in <code>HLRTest()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List which contains:
</p>

<ul>
<li><p> cs: Vector with standardized LRT statistic for each grid point.
</p>
</li>
<li><p> draws: List with a (<code>nwband+1 x N</code> matrix for each grid point. Each row of these matrices is a vector of simulated test statistics under the null hypothesis for a value of bandwidth .
</p>
</li>
<li><p> coefficients: A  matrix with coefficients for each grid point.
</p>
</li></ul>


<hr>
<h2 id='HLRTest'>Hansen (1992) likelihood ratio test</h2><span id='topic+HLRTest'></span>

<h3>Description</h3>

<p>This function performs Hansen's likelihood ratio test as described in Hansen (1992).
Original source code can be found <a href="https://www.ssc.wisc.edu/~bhansen/progs/jae_92.html">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLRTest(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HLRTest_+3A_y">Y</code></td>
<td>
<p>A (<code>T x 1</code>) matrix of observations.</p>
</td></tr>
<tr><td><code id="HLRTest_+3A_p">p</code></td>
<td>
<p>Integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="HLRTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> ix: List of Markov Switching parameters. 1 = just mean c(1,2) = mean and first param, (default: 1).
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, there is a switch in variance. If <code>FALSE</code> only switch in mean is considered. Default is <code>FALSE</code>.
</p>
</li>
<li><p> qbound: Indicator that bounds q by 1-p (default: <code>FALSE</code>).
</p>
</li>
<li><p> gridsize: Integer determining the number of grid points for markov switching parameters. Default is <code>20</code>.
</p>
</li>
<li><p> pgrid_from: Double determining the initial grid point for transition probabilities. Default is <code>0.1</code>.
</p>
</li>
<li><p> pgrid_by: Double determining the step size for grid points of transition probabilities. This, along with <code>p_gridsize</code> will determine the bounds of search space. Default is <code>0.075</code>.
</p>
</li>
<li><p> pgrid_to: Double determining the end grid point for transition probabilities. Default is <code>0.925</code>.
</p>
</li>
<li><p> mugrid_from: Double determining the minimum value of mean in second regime. Default is <code>0.1</code>.
</p>
</li>
<li><p> mugrid_by: Double determining the step size for grid points of mean in second regime. This, along with <code>gridsize</code> will determine the max value of mean in second regime. Default is <code>0.1</code>.
</p>
</li>
<li><p> siggrid_from: Double determining the minimum value of sigma in second regime (if <code>msvar = TRUE</code>). Default is <code>0.1</code>.
</p>
</li>
<li><p> siggrid_by: Double determining the step size for grid points of sigma in second regime. This, along with <code>gridsize</code> will determine the max value of sigma in second regime. Default is <code>0.1</code>.
</p>
</li>
<li><p> N: Integer determining the number of replications. Default is <code>1000</code>.
</p>
</li>
<li><p> nwband: Integer determining maximum bandwidth in Bartlett kernel. Critical values and p-values are returned for each bandwidth from <code>0:nwband</code> as suggested in Hansen (1996). Default is <code>4</code>.
</p>
</li>
<li><p> theta_null_low: Vector determining lower bound on parameters under the null hypothesis. Length of vector should be number of model coefficients + 1 for variance. Default is to only bound variance at <code>0.01</code>.
</p>
</li>
<li><p> theta_null_upp: Vector determining upper bound on parameters under the null hypothesis. Length of vector should be number of model coefficients + 1 for variance. Default is to no bounds (i.e. <code>Inf</code>).
</p>
</li>
<li><p> optim_method: String determining the type of optimization procedure used. Allowed options are &quot;gp-optim&quot; for general purpose optimization using <code><a href="stats.html#topic+optim">optim</a></code> from  or <code><a href="nloptr.html#topic+slsqp">slsqp</a></code>. Default is &quot;gp-optim&quot;.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>HLRTest</code> (<code>S3</code> object) with model attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. This will be of class <code>ARmdl</code> (<code>S3</code> object). See <code><a href="#topic+ARmdl">ARmdl</a></code>.
</p>
</li>
<li><p> LR0: Likelihood ratio test statistic value.
</p>
</li>
<li><p> LRN: A (<code>N x 1</code>) vector with simulated LRT statistics under null hypothesis.
</p>
</li>
<li><p> pval: P-value.
</p>
</li>
<li><p> LR_cv: A (<code>nwband x 3</code>) matrix with 90%, 95%, and 99% critical values in each column respectively.
</p>
</li>
<li><p> coef: Vector of coefficients from restricted model and grid search that maximized standardized LRT. 
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li></ul>



<h3>References</h3>

<p>Hansen, Bruce E. 1992. “The likelihood ratio test under nonstandard conditions: testing the Markov switching model of GNP.” <em>Journal of applied Econometrics</em> 7 (S1): S61–S82.
</p>
<p>Hansen, Bruce E. 1996. “Erratum: The likelihood ratio test under nonstandard conditions: testing the Markov switching model of GNP.” <em>Journal of applied Econometrics</em> 7 (S1): S61–S82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------- Use simulated process ----------------------------
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 200, 
                mu    = c(5,1),
                sigma = c(1,1),
                phi   = c(0.5),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)

hlrt_control  &lt;- list(ix          = 1, 
                      gridsize    = 7,
                      pgrid_from  = 0.05,
                      pgrid_by    = 0.05,
                      pgrid_to    = 0.95,
                      mugrid_from = 0,
                      mugrid_by   = 1)


  hlrt &lt;- HLRTest(y_ms_simu$y, p = 1, control = hlrt_control)
  summary(hlrt)


</code></pre>

<hr>
<h2 id='HMmdl'>Hidden Markov model</h2><span id='topic+HMmdl'></span>

<h3>Description</h3>

<p>This function estimates a Hidden Markov model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMmdl(Y, k, Z = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMmdl_+3A_y">Y</code></td>
<td>
<p>a <code>(T x q)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="HMmdl_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes to use in estimation. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
<tr><td><code id="HMmdl_+3A_z">Z</code></td>
<td>
<p>an otpional  <code>(T x qz)</code> matrix of exogenous regressors. Default is NULL.</p>
</td></tr>
<tr><td><code id="HMmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> getSE: Boolean. If <code>TRUE</code> standard errors are computed and returned. If <code>FALSE</code> standard errors are not computed. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model is estimated with switch in mean. If <code>FALSE</code> model is estimated with constant mean. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model is estimated with switch in variance. If <code>FALSE</code> model is estimated with constant variance. Default is <code>TRUE</code>.
</p>
</li>
<li><p> init_theta: vector of initial values. vector must contain <code>(1 x q)</code> vector <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(P)</code> where sigma is a <code>(q x q)</code> covariance matrix.This is optional. Default is <code>NULL</code>, in which case <code><a href="#topic+initVals_MSARmdl">initVals_MSARmdl</a></code> is used to generate initial values.
</p>
</li>
<li><p> method: string determining which method to use. Options are <code>'EM'</code> for EM algorithm or <code>'MLE'</code> for Maximum Likelihood Estimation. Default is <code>'EM'</code>.
</p>
</li>
<li><p> maxit: integer determining the maximum number of EM iterations.
</p>
</li>
<li><p> thtol: double determining the convergence criterion for the absolute difference in parameter estimates <code>theta</code> between iterations. Default is <code>1e-6</code>.
</p>
</li>
<li><p> maxit_converge: integer determining the maximum number of initial values attempted until solution is finite. For example, if parameters in <code>theta</code> or <code>logLike</code> are <code>NaN</code> another set of initial values (up to <code>maxit_converge</code>) is attempted until finite values are returned. This does not occur frequently for most types of data but may be useful in some cases. Once finite values are obtained, this counts as one iteration towards <code>use_diff_init</code>. Default is <code>500</code>.
</p>
</li>
<li><p> use_diff_init: integer determining how many different initial values to try (that do not return <code>NaN</code>; see <code>maxit_converge</code>). Default is <code>1</code>.
</p>
</li>
<li><p> mle_variance_constraint: double used to determine the lower bound on the smallest eigenvalue for the covariance matrix of each regime. Default is <code>1e-3</code>.
</p>
</li>
<li><p> mle_theta_low: Vector with lower bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li>
<li><p> mle_theta_upp: Vector with upper bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>HMmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T x q)</code> matrix of observations.
</p>
</li>
<li><p> fitted: a <code>(T x q)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T x q)</code> matrix of residuals.
</p>
</li>
<li><p> mu: a <code>(k x q)</code> matrix of estimated means of each process.
</p>
</li>
<li><p> beta: if <code>q=1</code>, this is a <code>((1 + qz) x k)</code> matrix of estimated coefficients. If <code>q&gt;1</code>, this is a list containing <code>k</code> separate <code>((1 + qz) x q)</code> matrix of estimated coefficients for each regime.  
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients.
</p>
</li>
<li><p> intercept: a <code>(k x q)</code> matrix of estimated intercept of each process. If Z is Null, this is the same as mu.
</p>
</li>
<li><p> stdev: If <code>q=1</code>, this is a <code>(k x 1)</code> matrix with estimated standard. If <code>q&gt;1</code>, this is a List with <code>k</code> <code>(q x q)</code> matrices with estimated standard deviation on the diagonal.
</p>
</li>
<li><p> sigma: If <code>q=1</code>, this is a <code>(k x 1)</code> matrix with variances. If <code>q&gt;1</code>, this is a List with <code>k</code> <code>(q x q)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code> and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_P_ind: vector indicating location of transition matrix elements with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes in estimated model.
</p>
</li>
<li><p> P: a <code>(k x k)</code> transition matrix.
</p>
</li>
<li><p> pinf: a <code>(k x 1)</code> vector with limiting probabilities of each regime.
</p>
</li>
<li><p> St: a <code>(T x k)</code> vector with smoothed probabilities of each regime at each time <code>t</code>.
</p>
</li>
<li><p> deltath: double with maximum absolute difference in vector <code>theta</code> between last iteration.
</p>
</li>
<li><p> iterations: number of EM iterations performed to achieve convergence (if less than <code>maxit</code>).
</p>
</li>
<li><p> theta_0: vector of initial values used.
</p>
</li>
<li><p> init_used: number of different initial values used to get a finite solution. See description of input <code>maxit_converge</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model was estimated with switch in mean. If <code>FALSE</code> model was estimated with constant mean.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model was estimated with switch in variance. If <code>FALSE</code> model was estimated with constant variance.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> trace: List with Lists of estimation output for each initial value used due to <code>use_diff_init &gt; 1</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Hamilton, James D. 1990. “Analysis of time series subject to changes in regime.” <em>Journal of econometrics</em>, 45 (1-2): 39–70.
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Nmdl">Nmdl</a></code>
</p>

<hr>
<h2 id='HMmdl_em'>Estimation of Hidden Markov model by EM Algorithm</h2><span id='topic+HMmdl_em'></span>

<h3>Description</h3>

<p>Estimate Hidden Markov model by EM algorithm. This function is used by <code><a href="#topic+HMmdl">HMmdl</a></code> which organizes the output and takes raw data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMmdl_em(theta_0, mdl, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMmdl_em_+3A_theta_0">theta_0</code></td>
<td>
<p>vector with initial values for parameters.</p>
</td></tr>
<tr><td><code id="HMmdl_em_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="HMmdl_em_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="HMmdl_em_+3A_optim_options">optim_options</code></td>
<td>
<p>List with optimization options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model results.
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38.
</p>

<hr>
<h2 id='HMmdl_mle'>Hidden Markov model maximum likelihood estimation</h2><span id='topic+HMmdl_mle'></span>

<h3>Description</h3>

<p>This function computes estimate a Hidden Markov model using MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMmdl_mle(theta_0, mdl_in, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMmdl_mle_+3A_theta_0">theta_0</code></td>
<td>
<p>vector containing initial values to use in optimization</p>
</td></tr>
<tr><td><code id="HMmdl_mle_+3A_mdl_in">mdl_in</code></td>
<td>
<p>List with model properties (can be obtained from estimating linear model i.e., using <code><a href="#topic+ARmdl">ARmdl</a></code>)</p>
</td></tr>
<tr><td><code id="HMmdl_mle_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes</p>
</td></tr>
<tr><td><code id="HMmdl_mle_+3A_optim_options">optim_options</code></td>
<td>
<p>List containing 
</p>

<ul>
<li><p> maxit: maximum number of iterations.
</p>
</li>
<li><p> thtol: convergence criterion.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model attributes
</p>

<hr>
<h2 id='initVals_HMmdl'>Initial values for Hidden Markov model</h2><span id='topic+initVals_HMmdl'></span>

<h3>Description</h3>

<p>This function generates a random parameter vector to be used as initial values for a Hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVals_HMmdl(mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initVals_HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with parameter values of simple (one-regime) model. This includes:
</p>

<ul>
<li><p> mu: Vector of means.
</p>
</li>
<li><p> sigma: covariance matrix.
</p>
</li>
<li><p> msmu: Boolean indicator. If <code>TRUE</code>, mean is function of markov process. If <code>FALSE</code>, mean is constant across regimes.
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, standard deviation is function of markov process. If <code>FALSE</code>, standard deviation is constant across regimes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="initVals_HMmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of initial parameter values.
</p>

<hr>
<h2 id='initVals_MSARmdl'>Initial values for Markov-switching autoregressive model</h2><span id='topic+initVals_MSARmdl'></span>

<h3>Description</h3>

<p>This function generates a random parameter vector to be used as initial values for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVals_MSARmdl(mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initVals_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with parameter values of simple (one-regime) autoregressive model. This includes:
</p>

<ul>
<li><p> phi: Vector autoregressive coefficients.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> stdev: Standard deviation.
</p>
</li>
<li><p> msmu: Boolean indicator. If <code>TRUE</code>, mean is function of markov process. If <code>FALSE</code>, mean is constant across regimes.
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, standard deviation is function of markov process. If <code>FALSE</code>, standard deviation is constant across regimes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="initVals_MSARmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of initial parameter values.
</p>

<hr>
<h2 id='initVals_MSARXmdl'>Initial values for Markov-switching ARX model</h2><span id='topic+initVals_MSARXmdl'></span>

<h3>Description</h3>

<p>This function generates a random parameter vector to be used as initial values for a Markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVals_MSARXmdl(mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initVals_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with parameter values of simple (one-regime) autoregressive model. This includes:
</p>

<ul>
<li><p> phi: Vector autoregressive coefficients.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> betaZ: vector of coefficients for exogenous regressors
</p>
</li>
<li><p> stdev: Standard deviation.
</p>
</li>
<li><p> msmu: Boolean indicator. If <code>TRUE</code>, mean is function of markov process. If <code>FALSE</code>, mean is constant across regimes.
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, standard deviation is function of markov process. If <code>FALSE</code>, standard deviation is constant across regimes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="initVals_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of initial parameter values.
</p>

<hr>
<h2 id='initVals_MSVARmdl'>Initial values for Markov-switching vector autoregressive model</h2><span id='topic+initVals_MSVARmdl'></span>

<h3>Description</h3>

<p>This function generates a random parameter vector to be used as initial values for a Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVals_MSVARmdl(mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initVals_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with parameter values of simple (one-regime) vector autoregressive model. This includes:
</p>

<ul>
<li><p> phi: Matrix autoregressive coefficients.
</p>
</li>
<li><p> mu: Vector of means.
</p>
</li>
<li><p> sigma: Covariance matrix.
</p>
</li>
<li><p> msmu: Boolean indicator. If <code>TRUE</code>, mean is function of markov process. If <code>FALSE</code>, mean is constant across regimes.
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, standard deviation is function of markov process. If <code>FALSE</code>, standard deviation is constant across regimes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="initVals_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of initial parameter values.
</p>

<hr>
<h2 id='initVals_MSVARXmdl'>Initial values for Markov-switching VARX model</h2><span id='topic+initVals_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function generates a random parameter vector to be used as initial values for a Markov-switching VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initVals_MSVARXmdl(mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initVals_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with parameter values of simple (one-regime) VARX model. This includes:
</p>

<ul>
<li><p> phi: Matrix autoregressive coefficients.
</p>
</li>
<li><p> mu: Vector of means.
</p>
</li>
<li><p> betaZ: vector of coefficients for exogenous regressors
</p>
</li>
<li><p> sigma: Covariance matrix.
</p>
</li>
<li><p> msmu: Boolean indicator. If <code>TRUE</code>, mean is function of markov process. If <code>FALSE</code>, mean is constant across regimes.
</p>
</li>
<li><p> msvar: Boolean indicator. If <code>TRUE</code>, standard deviation is function of markov process. If <code>FALSE</code>, standard deviation is constant across regimes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="initVals_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of initial parameter values.
</p>

<hr>
<h2 id='interMSARmdl'>Intercept from mu for MSARmdl</h2><span id='topic+interMSARmdl'></span>

<h3>Description</h3>

<p>This function computes the intercept for each regime k for an Markov switching AR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interMSARmdl(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interMSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(k x 1)</code> vector of intercepts
</p>

<hr>
<h2 id='interMSVARmdl'>Intercept from mu for MSVARmdl</h2><span id='topic+interMSVARmdl'></span>

<h3>Description</h3>

<p>This function computes the intercept for each regime k for an Markov switching VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interMSVARmdl(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interMSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(k x q)</code> vector of intercepts
</p>

<hr>
<h2 id='limP'>Ergodic (limiting) probabilities of states</h2><span id='topic+limP'></span>

<h3>Description</h3>

<p>Takes a transition matrix and returns the limiting probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limP(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limP_+3A_p">P</code></td>
<td>
<p>Matrix with transition probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>k x 1</code>) vector of limiting probabilities.
</p>

<hr>
<h2 id='LMCLRTest'>Monte Carlo Likelihood Ratio Test</h2><span id='topic+LMCLRTest'></span>

<h3>Description</h3>

<p>This function performs the Local Monte Carlo likelihood ratio 
test (LMC-LRT) proposed in Rodriguez-Rondon &amp; Dufour (2024). As discussed in 
their work, this test can be applied in very general settings and can be used 
to compare varioous regimes under the null and under the alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMCLRTest(Y, p, k0, k1, Z = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMCLRTest_+3A_y">Y</code></td>
<td>
<p>Series to be tested. Must be a (<code>T x q</code>) matrix where T is the number of time observations and q is the number of variables.</p>
</td></tr>
<tr><td><code id="LMCLRTest_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags. Must be greater than or equal to 0.</p>
</td></tr>
<tr><td><code id="LMCLRTest_+3A_k0">k0</code></td>
<td>
<p>Number of regimes under null hypothesis. Must be greater than or equal to 1.</p>
</td></tr>
<tr><td><code id="LMCLRTest_+3A_k1">k1</code></td>
<td>
<p>Number of regimes under alternative hypothesis. Must be greater than <code>k0</code>.</p>
</td></tr>
<tr><td><code id="LMCLRTest_+3A_z">Z</code></td>
<td>
<p>Exogenous regressors. Optional input and default is NULL. When used, it should be a (<code>T x qz</code>) matrix where T is the number of time observations and q is the number of exogenous variables.</p>
</td></tr>
<tr><td><code id="LMCLRTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> N: Integer determining the number of Monte Carlo simulations. Default is set to <code>99</code> as in paper.
</p>
</li>
<li><p> burnin: Number of simulated observations to remove from beginning. Default is <code>100</code>.
</p>
</li>
<li><p> converge_check: String or NULL determining if convergence of model(s) should be verified. Allowed inputs are: &quot;null&quot;, &quot;alt&quot;, &quot;both&quot;, or <code>NULL</code>. If <code>NULL</code> (default) no model convergence is verified.
</p>
</li>
<li><p> workers: Integer determining the number of workers to use for parallel computing version of test. Note that parallel pool must already be open. Default is <code>0</code>.
</p>
</li>
<li><p> mdl_h0_control: List with restricted model options. See <code><a href="#topic+Nmdl">Nmdl</a></code>, <code><a href="#topic+ARmdl">ARmdl</a></code>, <code><a href="#topic+VARmdl">VARmdl</a></code>, <code><a href="#topic+HMmdl">HMmdl</a></code>, <code><a href="#topic+MSARmdl">MSARmdl</a></code>, or <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> documentation for available and default values.
</p>
</li>
<li><p> mdl_h1_control: List with unrestricted model options. See <code><a href="#topic+HMmdl">HMmdl</a></code>, <code><a href="#topic+MSARmdl">MSARmdl</a></code>, or <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> documentation for available and default values.
</p>
</li>
<li><p> use_diff_init_sim: Value which determines the number of initial values to use when estimating models for null distribution. Default is set to use the same as specified in <code>mdl_h0_control</code> and <code>mdl_h1_control</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>LMCLRTest</code> (<code>S3</code> object) with attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. 
</p>
</li>
<li><p> mdl_h1: List with unrestricted model attributes. 
</p>
</li>
<li><p> LRT_0: Value of test statistic from observed data.
</p>
</li>
<li><p> LRN: A (<code>N x 1</code>) vector of test statistics from data simulated under the null hypothesis.
</p>
</li>
<li><p> pval: P-value of Local Monte Carlo Likelihood Ratio Test.
</p>
</li>
<li><p> LRN_cv: Vector with 90%, 95%, and 99% Monte Carlo simulated critical values (from vector <code>LRN</code>). These are not asymptotic critical values. 
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li></ul>



<h3>References</h3>

<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2024. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 200, 
                mu    = c(5,10),
                sigma = c(1,4),
                phi   = c(0.5),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)


# ------ MS-AR example ----- #
# Set test procedure options
lmc_control = list(N = 19,
                   burnin = 100,
                   converge_check = NULL,
                   mdl_h0_control = list(const  = TRUE, 
                                         getSE  = TRUE),
                   mdl_h1_control = list(msmu   = TRUE, 
                                         msvar  = TRUE,
                                         getSE  = TRUE,
                                         method = "EM",
                                         use_diff_init = 1))


  lmctest &lt;- LMCLRTest(y_ms_simu$y, p = 1, k0 = 1 , k1 = 2, control = lmc_control)
  summary(lmctest)

</code></pre>

<hr>
<h2 id='logLik.ARmdl'>Log likelihood for autoregressive model</h2><span id='topic+logLik.ARmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for an autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.ARmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.ARmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLik.HMmdl'>Log likelihood for Hidden Markov model</h2><span id='topic+logLik.HMmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for a Hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.HMmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.HMmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLik.MSARmdl'>Log likelihood for Markov-switching autoregressive model</h2><span id='topic+logLik.MSARmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for a Markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.MSARmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.MSARmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLik.MSVARmdl'>Log likelihood for Markov-switching vector autoregressive model</h2><span id='topic+logLik.MSVARmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for a Markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.MSVARmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.MSVARmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLik.Nmdl'>Log likelihood for Normal model</h2><span id='topic+logLik.Nmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for a normally distributed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.Nmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.Nmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLik.VARmdl'>Log likelihood for vector autoregressive model</h2><span id='topic+logLik.VARmdl'></span>

<h3>Description</h3>

<p>This function is used to compute the log-likelihood for a vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.VARmdl_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.VARmdl_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_ARmdl'>Autoregressive log-likelihood objective function</h2><span id='topic+logLike_ARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for an autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_ARmdl(theta, mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_ARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_ARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_ARXmdl'>ARX log-likelihood objective function</h2><span id='topic+logLike_ARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for an autoregressive model with exogenous regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_ARXmdl(theta, mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_ARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_ARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_HMmdl'>Hidden Markov model log-likelihood function</h2><span id='topic+logLike_HMmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_HMmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_HMmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_HMmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_HMmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_HMmdl_min'>Hidden Markov model log-likelihood function  (minimization version)</h2><span id='topic+logLike_HMmdl_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) log-likelihood for a markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_HMmdl_min(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_HMmdl_min_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_HMmdl_min_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_HMmdl_min_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSARmdl'>Markov-switching autoregressive log-likelihood objective function</h2><span id='topic+logLike_MSARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSARmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSARmdl_min'>Markov-switching autoregressive log-likelihood objective function (minimization version)</h2><span id='topic+logLike_MSARmdl_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) log-likelihood for a markov-switching autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSARmdl_min(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSARmdl_min_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSARmdl_min_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSARmdl_min_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSARXmdl'>Markov-switching ARX log-likelihood objective function</h2><span id='topic+logLike_MSARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSARXmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSARXmdl_min'>Markov-switching ARX log-likelihood objective function (minimization version)</h2><span id='topic+logLike_MSARXmdl_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) log-likelihood for a markov-switching ARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSARXmdl_min(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSARXmdl_min_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSARXmdl_min_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSARXmdl_min_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSVARmdl'>Markov-switching vector autoregressive log-likelihood objective function</h2><span id='topic+logLike_MSVARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSVARmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSVARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSVARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSVARmdl_min'>Markov-switching vector autoregressive log-likelihood objective function (minimization version)</h2><span id='topic+logLike_MSVARmdl_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) log-likelihood for a markov-switching vector autoregressive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSVARmdl_min(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSVARmdl_min_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSVARmdl_min_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSVARmdl_min_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSVARXmdl'>Markov-switching VARX log-likelihood objective function</h2><span id='topic+logLike_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a markov-switching VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSVARXmdl(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSVARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSVARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_MSVARXmdl_min'>Markov-switching VARX log-likelihood objective function (minimization version)</h2><span id='topic+logLike_MSVARXmdl_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) log-likelihood for a markov-switching VARX model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_MSVARXmdl_min(theta, mdl, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_MSVARXmdl_min_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_MSVARXmdl_min_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="logLike_MSVARXmdl_min_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative log-likelihood value.
</p>

<hr>
<h2 id='logLike_Nmdl'>Normal log-likelihood objective function</h2><span id='topic+logLike_Nmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a normally distributed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_Nmdl(theta, mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_Nmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_Nmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_VARmdl'>Vector autoregressive log-likelihood objective function</h2><span id='topic+logLike_VARmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a vector autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_VARmdl(theta, mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_VARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_VARmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='logLike_VARXmdl'>VARX log-likelihood objective function</h2><span id='topic+logLike_VARXmdl'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood for a VARX model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLike_VARXmdl(theta, mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLike_VARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of model parameters.</p>
</td></tr>
<tr><td><code id="logLike_VARXmdl_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood value.
</p>

<hr>
<h2 id='LR_samp_dist'>Likelihood Ratio Test Statistic Sample Distribution</h2><span id='topic+LR_samp_dist'></span>

<h3>Description</h3>

<p>This function simulates the sample distribution under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR_samp_dist(mdl_h0, k1, N, burnin, Z, mdl_h0_control, mdl_h1_control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LR_samp_dist_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_+3A_k1">k1</code></td>
<td>
<p>integer specifying the number of regimes under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_+3A_n">N</code></td>
<td>
<p>integer specifying the number of replications.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_+3A_burnin">burnin</code></td>
<td>
<p>integer specifying the number of observations to drop from beginning of simulation.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_+3A_mdl_h0_control">mdl_h0_control</code></td>
<td>
<p>List with controls/options used to estimate restricted model.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_+3A_mdl_h1_control">mdl_h1_control</code></td>
<td>
<p>List with controls/options used to estimate unrestricted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of simulated LRT statistics
</p>


<h3>References</h3>

<p>Rodriguez Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez Rondon, Gabriel and Jean-Marie Dufour. 2022. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>

<hr>
<h2 id='LR_samp_dist_par'>Monte Carlo Likelihood Ratio Test sample distribution (parallel version)</h2><span id='topic+LR_samp_dist_par'></span>

<h3>Description</h3>

<p>This function simulates the sample distribution under the null hypothesis using a parallel pool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR_samp_dist_par(
  mdl_h0,
  k1,
  N,
  burnin,
  Z,
  mdl_h0_control,
  mdl_h1_control,
  workers
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LR_samp_dist_par_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_k1">k1</code></td>
<td>
<p>integer specifying the number of regimes under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_n">N</code></td>
<td>
<p>integer specifying the number of replications.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_burnin">burnin</code></td>
<td>
<p>integer specifying the number of observations to drop from beginning of simulation.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_mdl_h0_control">mdl_h0_control</code></td>
<td>
<p>List with controls/options used to estimate restricted model.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_mdl_h1_control">mdl_h1_control</code></td>
<td>
<p>List with controls/options used to estimate unrestricted model.</p>
</td></tr>
<tr><td><code id="LR_samp_dist_par_+3A_workers">workers</code></td>
<td>
<p>Integer determining the number of workers to use for parallel computing version of test. Note that parallel pool must already be open.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of simulated LRT statistics
</p>


<h3>References</h3>

<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2023. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>

<hr>
<h2 id='marklike'>Likelihood function used by <code>HLRTest()</code></h2><span id='topic+marklike'></span>

<h3>Description</h3>

<p>this function computes the sum Markov likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marklike(ths, HLR_opt_ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marklike_+3A_ths">ths</code></td>
<td>
<p>vector of parameter values.</p>
</td></tr>
<tr><td><code id="marklike_+3A_hlr_opt_ls">HLR_opt_ls</code></td>
<td>
<p>List with model properties and test controls defined in <code>HLRTest()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of likelihood values.
</p>

<hr>
<h2 id='mclike'>Sum of likelihood used by <code>HLRTest()</code></h2><span id='topic+mclike'></span>

<h3>Description</h3>

<p>This function computes the sum of the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclike(th, HLR_opt_ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mclike_+3A_th">th</code></td>
<td>
<p>vector of parameter values.</p>
</td></tr>
<tr><td><code id="mclike_+3A_hlr_opt_ls">HLR_opt_ls</code></td>
<td>
<p>List with model properties and test controls defined in <code>HLRTest()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of likelihood.
</p>

<hr>
<h2 id='MCpval'>Monte Carlo P-value</h2><span id='topic+MCpval'></span>

<h3>Description</h3>

<p>This function computes the Monte Carlo P-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCpval(test_stat, null_vec, type = "geq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCpval_+3A_test_stat">test_stat</code></td>
<td>
<p>Test statistic under the alternative (e.g. <code>S_0</code>).</p>
</td></tr>
<tr><td><code id="MCpval_+3A_null_vec">null_vec</code></td>
<td>
<p>A (<code>N x 1</code>) vector with test statistic under the null hypothesis.</p>
</td></tr>
<tr><td><code id="MCpval_+3A_type">type</code></td>
<td>
<p>String determining type of test. options are: &quot;geq&quot; for right-tail test, &quot;leq&quot; for left-tail test, &quot;abs&quot; for absolute value test and &quot;two-tail&quot; for two-tail test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MC p-value of test
</p>


<h3>References</h3>

<p>Dufour, Jean-Marie 2006. &quot;Monte Carlo tests with nuisance parameters: A general approach to finite-sample inference and nonstandard asymptotics&quot;. <em>Journal of Econometrics</em>, 133(2), 443-477.
</p>
<p>Dufour, Jean-Marie, and Richard Luger. 2017. &quot;Identification-robust moment-based tests for Markov switching in autoregressive models&quot;. <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='mdledit'>Change model List with new parameters</h2><span id='topic+mdledit'></span>

<h3>Description</h3>

<p>This function is used by the MMC LRT procedure. It makes a 
copy of the restricted model under the null hypothesis and changes the 
parameters used to simulate the process under the null with values being 
considered in the search/optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdledit(mdl_h0, theta_h0, p, q, k0, exog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdledit_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="mdledit_+3A_theta_h0">theta_h0</code></td>
<td>
<p>vector of parameter values under null being considered.</p>
</td></tr>
<tr><td><code id="mdledit_+3A_p">p</code></td>
<td>
<p>integer specifying the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="mdledit_+3A_q">q</code></td>
<td>
<p>integer specifying the number of series.</p>
</td></tr>
<tr><td><code id="mdledit_+3A_k0">k0</code></td>
<td>
<p>integer specifying the number of regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model properties
</p>

<hr>
<h2 id='MMC_bounds'>MMC nuisance parameter bounds</h2><span id='topic+MMC_bounds'></span>

<h3>Description</h3>

<p>This function is used to determine the lower and upper bounds for the MMC LRT parameter search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMC_bounds(mdl_h0, con)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MMC_bounds_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="MMC_bounds_+3A_con">con</code></td>
<td>
<p>List with control options provided to MMC LRT procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>theta_low</code>, vector of parameter lower bounds, and <code>theta_upp</code>, vector of parameter upper bounds.
</p>


<h3>References</h3>

<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2024. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>

<hr>
<h2 id='MMCLRpval_fun'>Monte Carlo Likelihood Ratio Test P-value Function</h2><span id='topic+MMCLRpval_fun'></span>

<h3>Description</h3>

<p>This function computes the Maximum Monte Carlo P-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMCLRpval_fun(
  theta_h0,
  mdl_h0,
  k1,
  LT_h1,
  N,
  burnin,
  workers,
  lambda,
  stationary_constraint,
  thtol,
  Z,
  exog,
  mdl_h0_control,
  mdl_h1_control
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MMCLRpval_fun_+3A_theta_h0">theta_h0</code></td>
<td>
<p>vector of parameter values under the null being considered.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_k1">k1</code></td>
<td>
<p>integer determining the number of regimes under the alternative.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_lt_h1">LT_h1</code></td>
<td>
<p>double specifying maximum log likelihood under alternative.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_n">N</code></td>
<td>
<p>integer specifying the number of replications.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_burnin">burnin</code></td>
<td>
<p>integer specifying the number of observations to drop from beginning of simulation.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_workers">workers</code></td>
<td>
<p>Integer determining the number of workers to use for parallel computing version of test. Note that parallel pool must already be open.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_lambda">lambda</code></td>
<td>
<p>Double determining penalty on nonlinear constraint.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_stationary_constraint">stationary_constraint</code></td>
<td>
<p>Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_thtol">thtol</code></td>
<td>
<p>double determining the convergence criterion used during estimation.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_mdl_h0_control">mdl_h0_control</code></td>
<td>
<p>List with controls/options used to estimate restricted model.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_+3A_mdl_h1_control">mdl_h1_control</code></td>
<td>
<p>List with controls/options used to estimate unrestricted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MMC p-value
</p>

<hr>
<h2 id='MMCLRpval_fun_min'>Monte Carlo Likelihood Ratio Test P-value Function</h2><span id='topic+MMCLRpval_fun_min'></span>

<h3>Description</h3>

<p>This function computes the (negative) Maximum Monte Carlo P-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMCLRpval_fun_min(
  theta,
  mdl_h0,
  k1,
  LT_h1,
  N,
  burnin,
  workers,
  lambda,
  stationary_constraint,
  thtol,
  Z,
  exog,
  mdl_h0_control,
  mdl_h1_control
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MMCLRpval_fun_min_+3A_theta">theta</code></td>
<td>
<p>vector of parameter values being considered.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_k1">k1</code></td>
<td>
<p>integer determining the number of regimes under the alternative.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_lt_h1">LT_h1</code></td>
<td>
<p>double specifying maximum log likelihood under alternative.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_n">N</code></td>
<td>
<p>integer specifying the number of replications.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_burnin">burnin</code></td>
<td>
<p>integer specifying the number of observations to drop from beginning of simulation.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_workers">workers</code></td>
<td>
<p>Integer determining the number of workers to use for parallel computing version of test. Note that parallel pool must already be open.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_lambda">lambda</code></td>
<td>
<p>Double determining penalty on nonlinear constraint.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_stationary_constraint">stationary_constraint</code></td>
<td>
<p>Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_thtol">thtol</code></td>
<td>
<p>double determining the convergence criterion used during estimation.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_mdl_h0_control">mdl_h0_control</code></td>
<td>
<p>List with controls/options used to estimate restricted model.</p>
</td></tr>
<tr><td><code id="MMCLRpval_fun_min_+3A_mdl_h1_control">mdl_h1_control</code></td>
<td>
<p>List with controls/options used to estimate unrestricted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>negative MMC p-value
</p>

<hr>
<h2 id='MMCLRTest'>Maximized Monte Carlo Likelihood Ratio Test</h2><span id='topic+MMCLRTest'></span>

<h3>Description</h3>

<p>This function performs the Maximized Monte Carlo likelihood ratio 
test (MMC-LRT) proposed in Rodriguez-Rondon &amp; Dufour (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMCLRTest(Y, p, k0, k1, Z = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MMCLRTest_+3A_y">Y</code></td>
<td>
<p>Series to be tested. Must be a (<code>T x q</code>) matrix  where T is the number of time observations and q is the number of variables.</p>
</td></tr>
<tr><td><code id="MMCLRTest_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags. Must be greater than or equal to 0.</p>
</td></tr>
<tr><td><code id="MMCLRTest_+3A_k0">k0</code></td>
<td>
<p>Number of regimes under null hypothesis. Must be greater than or equal to 1.</p>
</td></tr>
<tr><td><code id="MMCLRTest_+3A_k1">k1</code></td>
<td>
<p>Number of regimes under alternative hypothesis. Must be greater than <code>k0</code>.</p>
</td></tr>
<tr><td><code id="MMCLRTest_+3A_z">Z</code></td>
<td>
<p>Exogenous regressors. Optional input and default is NULL. When used, it should be a (<code>T x qz</code>) matrix where T is the number of time observations and q is the number of exogenous variables.</p>
</td></tr>
<tr><td><code id="MMCLRTest_+3A_control">control</code></td>
<td>
<p>List with test procedure options including: 
</p>

<ul>
<li><p> N: Integer determining the number of Monte Carlo simulations. Default is set to <code>99</code> as in paper.
</p>
</li>
<li><p> burnin: Number of simulated observations to remove from beginning. Default is <code>100</code>.
</p>
</li>
<li><p> converge_check: String of NULL determining if convergence of model(s) should be verified. Allowed inputs are: &quot;null&quot;, &quot;alt&quot;, &quot;both&quot;, or <code>NULL</code>. If <code>NULL</code> (default) no model convergence is verified.
</p>
</li>
<li><p> workers: Integer determining the number of workers to use for parallel computing version of test. Note that parallel pool must already be open. Default is <code>0</code>.
</p>
</li>
<li><p> type: String that determines the type of optimization algorithm used. Arguments allowed are: <code>"pso"</code>, <code>"GenSA"</code>, and <code>"GA"</code>. Default is <code>"pso"</code>.
</p>
</li>
<li><p> eps: Double determining the constant value that defines a consistent set for search. Default is <code>0.1</code>.
</p>
</li>
<li><p> CI_union: Boolean determining if union of set determined by <code>eps</code> and confidence set should be used to define consistent set for search. Default is <code>TRUE</code>.
</p>
</li>
<li><p> lambda: Double determining penalty on nonlinear constraint. Default is <code>100</code>.
</p>
</li>
<li><p> stationary_constraint: Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>TRUE</code>.
</p>
</li>
<li><p> phi_low: Vector with lower bound for autoregressive parameters when optimizing. Default is <code>NULL</code>.
</p>
</li>
<li><p> phi_upp: Vector with upper bound for autoregressive parameters when optimizing. Default is <code>NULL</code>.
</p>
</li>
<li><p> P_low: Value with lower bound for transition probabilities when optimizing. Default is <code>0</code>.
</p>
</li>
<li><p> P_upp: Value with upper bound for transition probabilities when optimizing. Default is <code>1</code>.
</p>
</li>
<li><p> variance_constraint: Double used to determine the lower bound for variance in parameter set for search. Value should be between <code>0</code> and <code>1</code> as it is multiplied by consistent point estimates of variances. Default is <code>0.01</code> (i.e., <code>1%</code> of consistent point estimates.
</p>
</li>
<li><p> silence: Boolean determining if optimization steps should be silenced (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>FALSE</code>.
</p>
</li>
<li><p> threshold_stop: Double determining the global optimum of function. Default is <code>1</code>.
</p>
</li>
<li><p> mdl_h0_control: List with restricted model options. See <code><a href="#topic+Nmdl">Nmdl</a></code>, <code><a href="#topic+ARmdl">ARmdl</a></code>, <code><a href="#topic+VARmdl">VARmdl</a></code>, <code><a href="#topic+HMmdl">HMmdl</a></code>, <code><a href="#topic+MSARmdl">MSARmdl</a></code>, or <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> documentation for available and default values.
</p>
</li>
<li><p> mdl_h1_control: List with unrestricted model options. See <code><a href="#topic+HMmdl">HMmdl</a></code>, <code><a href="#topic+MSARmdl">MSARmdl</a></code>, or <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> documentation for available and default values.
</p>
</li>
<li><p> use_diff_init_sim: Value which determines the number of initial values to use when estimating models for null distribution. Default is set to use the same as specified in <code>mdl_h0_control</code> and <code>mdl_h1_control</code>.
</p>
</li>
<li><p> optim_control: List with optimization algorithm options. See <code><a href="pso.html#topic+psoptim">psoptim</a></code>, <code><a href="GenSA.html#topic+GenSA">GenSA</a></code>, <code><a href="GA.html#topic+ga">ga</a></code>. Default is to set <code>list(maxit = 200)</code> so that maximum number of iterations is <code>200</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>LMCLRTest</code> (<code>S3</code> object) with attributes including: 
</p>

<ul>
<li><p> mdl_h0: List with restricted model attributes. 
</p>
</li>
<li><p> mdl_h1: List with unrestricted model attributes. 
</p>
</li>
<li><p> LRT_0: Value of test statistic from observed data.
</p>
</li>
<li><p> LRN: A (<code>N x 1</code>) vector of test statistics from data simulated under the null hypothesis.
</p>
</li>
<li><p> pval: P-value of Local Monte Carlo Likelihood Ratio Test.
</p>
</li>
<li><p> LRN_cv: Vector with 90%, 95%, and 99% Monte Carlo simulated critical values (from vector <code>LRN</code>). These are not asymptotic critical values. 
</p>
</li>
<li><p> control: List with test procedure options used.
</p>
</li></ul>



<h3>References</h3>

<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2022. &quot;Simulation-Based Inference for Markov Switching Models” <em>JSM Proceedings, Business and Economic Statistics Section: American Statistical Association</em>.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2024. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 200, 
                mu    = c(5,10),
                sigma = c(1,4),
                phi   = c(0.5),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)


# Set test procedure options
mmc_control = list(N = 19,
                   burnin = 100,
                   converge_check = NULL,
                   eps = 0.1,
                   CI_union = TRUE,
                   silence = FALSE,
                   threshold_stop = 0.05 + 1e-6,
                   type = "pso",
                   maxit = 100,
                   mdl_h0_control = list(const  = TRUE, 
                                         getSE  = TRUE),
                   mdl_h1_control = list(msmu   = TRUE, 
                                         msvar  = TRUE,
                                         getSE  = TRUE,
                                         method = "EM",
                                         use_diff_init = 1))

  MMCtest &lt;- MMCLRTest(y_ms_simu$y, p = 1 , k0 = 1 , k1 = 2, control = mmc_control)
  summary(MMCtest)




</code></pre>

<hr>
<h2 id='MSARmdl'>Markov-switching autoregressive model</h2><span id='topic+MSARmdl'></span>

<h3>Description</h3>

<p>This function estimates a Markov-switching autoregressive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSARmdl(Y, p, k, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSARmdl_+3A_y">Y</code></td>
<td>
<p>(T x 1) vector with observational data.</p>
</td></tr>
<tr><td><code id="MSARmdl_+3A_p">p</code></td>
<td>
<p>integer for the number of lags to use in estimation. Must be greater than or equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="MSARmdl_+3A_k">k</code></td>
<td>
<p>integer for the number of regimes to use in estimation. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
<tr><td><code id="MSARmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> getSE: Boolean. If <code>TRUE</code> standard errors are computed and returned. If <code>FALSE</code> standard errors are not computed. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model is estimated with switch in mean. If <code>FALSE</code> model is estimated with constant mean. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model is estimated with switch in variance. If <code>FALSE</code> model is estimated with constant variance. Default is <code>TRUE</code>.
</p>
</li>
<li><p> init_theta: vector of initial values. vector must contain <code>(1 x q)</code> vector <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(P)</code> where sigma is a <code>(q x q)</code> covariance matrix.This is optional. Default is <code>NULL</code>, in which case <code><a href="#topic+initVals_MSARmdl">initVals_MSARmdl</a></code> is used to generate initial values.
</p>
</li>
<li><p> method: string determining which method to use. Options are <code>'EM'</code> for EM algorithm or <code>'MLE'</code> for Maximum Likelihood Estimation.  Default is <code>'EM'</code>.
</p>
</li>
<li><p> maxit: integer determining the maximum number of EM iterations.
</p>
</li>
<li><p> thtol: double determining the convergence criterion for the absolute difference in parameter estimates <code>theta</code> between iterations. Default is <code>1e-6</code>.
</p>
</li>
<li><p> maxit_converge: integer determining the maximum number of initial values attempted until solution is finite. For example, if parameters in <code>theta</code> or <code>logLike</code> are <code>NaN</code> another set of initial values (up to <code>maxit_converge</code>) is attempted until finite values are returned. This does not occur frequently for most types of data but may be useful in some cases. Once finite values are obtained, this counts as one iteration towards <code>use_diff_init</code>. Default is <code>500</code>.
</p>
</li>
<li><p> use_diff_init: integer determining how many different initial values to try (that do not return <code>NaN</code>; see <code>maxit_converge</code>). Default is <code>1</code>.
</p>
</li>
<li><p> mle_stationary_constraint: Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>TRUE</code>.
</p>
</li>
<li><p> mle_variance_constraint: Double used to determine the lower bound for variance in each regime. Value should be between <code>0</code> and <code>1</code> as it is multiplied by single regime variance. Default is <code>0.01</code> (i.e., <code>1%</code> of single regime variance.
</p>
</li>
<li><p> mle_theta_low: Vector with lower bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li>
<li><p> mle_theta_upp: Vector with upper bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>MSARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T x 1)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p + const)</code> matrix of lagged observations with a leading column of <code>1</code>s.
</p>
</li>
<li><p> x: a <code>(T-p x p)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T x 1)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T x 1)</code> matrix of residuals.
</p>
</li>
<li><p> intercept: a <code>(k x 1)</code> vector of estimated intercepts of each process.
</p>
</li>
<li><p> mu: a <code>(k x 1)</code> vector of estimated means of each process.
</p>
</li>
<li><p> beta: a <code>((1 + p) x k)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> stdev: a <code>(k x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li><p> sigma: a <code>(k x 1)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code> and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise. This is the same as <code>theta_sig_ind</code> in <code>MSARmdl</code>.
</p>
</li>
<li><p> theta_P_ind: vector indicating location of transition matrix elements with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series. This is always <code>1</code> in <code>MSARmdl</code>.
</p>
</li>
<li><p> k: number of regimes in estimated model.
</p>
</li>
<li><p> P: a <code>(k x k)</code> transition matrix.
</p>
</li>
<li><p> pinf: a <code>(k x 1)</code> vector with limiting probabilities of each regime.
</p>
</li>
<li><p> St: a <code>(T x k)</code> vector with smoothed probabilities of each regime at each time <code>t</code>.
</p>
</li>
<li><p> deltath: double with maximum absolute difference in vector <code>theta</code> between last iteration.
</p>
</li>
<li><p> iterations: number of EM iterations performed to achieve convergence (if less than <code>maxit</code>).
</p>
</li>
<li><p> theta_0: vector of initial values used.
</p>
</li>
<li><p> init_used: number of different initial values used to get a finite solution. See description of input <code>maxit_converge</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model was estimated with switch in mean. If <code>FALSE</code> model was estimated with constant mean.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model was estimated with switch in variance. If <code>FALSE</code> model was estimated with constant variance.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> trace: List with Lists of estimation output for each initial value used due to <code>use_diff_init &gt; 1</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Hamilton, James D. 1990. “Analysis of time series subject to changes in regime.” <em>Journal of econometrics</em>, 45 (1-2): 39–70.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARmdl">ARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------- Use simulated process ----------------------------
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 200, 
                mu    = c(5,10),
                sigma = c(1,4),
                phi   = c(0.5),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)

# Set options for model estimation
control &lt;- list(msmu   = TRUE, 
                msvar  = TRUE, 
                method = "EM",
                use_diff_init = 1)

# Estimate model

  ms_mdl &lt;- MSARmdl(y_ms_simu$y, p = 1, k = 2, control = control)
  summary(ms_mdl)




</code></pre>

<hr>
<h2 id='MSARmdl_em'>Estimation of Markov-switching autoregressive model by EM Algorithm</h2><span id='topic+MSARmdl_em'></span>

<h3>Description</h3>

<p>Estimate Markov-switching autoregressive model by EM algorithm. This function is used by <code><a href="#topic+MSARmdl">MSARmdl</a></code> which organizes the output and takes raw data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSARmdl_em(theta_0, mdl, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSARmdl_em_+3A_theta_0">theta_0</code></td>
<td>
<p>vector with initial values for parameters.</p>
</td></tr>
<tr><td><code id="MSARmdl_em_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="MSARmdl_em_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="MSARmdl_em_+3A_optim_options">optim_options</code></td>
<td>
<p>List with optimization options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model results.
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38.
</p>
<p>Hamilton, James D. 1990. “Analysis of time series subject to changes in regime.” <em>Journal of econometrics</em>, 45 (1-2): 39–70.
</p>

<hr>
<h2 id='MSARmdl_mle'>Markov-switching autoregressive maximum likelihood estimation</h2><span id='topic+MSARmdl_mle'></span>

<h3>Description</h3>

<p>This function computes estimate a Markov-switching autoregressive model using MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSARmdl_mle(theta_0, mdl_in, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSARmdl_mle_+3A_theta_0">theta_0</code></td>
<td>
<p>vector containing initial values to use in optimization</p>
</td></tr>
<tr><td><code id="MSARmdl_mle_+3A_mdl_in">mdl_in</code></td>
<td>
<p>List with model properties (can be obtained from estimating linear model i.e., using <code><a href="#topic+ARmdl">ARmdl</a></code>)</p>
</td></tr>
<tr><td><code id="MSARmdl_mle_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes</p>
</td></tr>
<tr><td><code id="MSARmdl_mle_+3A_optim_options">optim_options</code></td>
<td>
<p>List containing 
</p>

<ul>
<li><p> maxit: maximum number of iterations.
</p>
</li>
<li><p> thtol: convergence criterion.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model attributes
</p>

<hr>
<h2 id='MSARXmdl'>Markov-switching autoregressive model</h2><span id='topic+MSARXmdl'></span>

<h3>Description</h3>

<p>This function estimates a Markov-switching autoregressive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSARXmdl(Y, p, k, Z, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSARXmdl_+3A_y">Y</code></td>
<td>
<p>a <code>(T x 1)</code> vector with observational data.</p>
</td></tr>
<tr><td><code id="MSARXmdl_+3A_p">p</code></td>
<td>
<p>integer for the number of lags to use in estimation. Must be greater than or equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="MSARXmdl_+3A_k">k</code></td>
<td>
<p>integer for the number of regimes to use in estimation. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
<tr><td><code id="MSARXmdl_+3A_z">Z</code></td>
<td>
<p>a <code>(T x qz)</code> matrix of exogenous regressors.</p>
</td></tr>
<tr><td><code id="MSARXmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> getSE: Boolean. If <code>TRUE</code> standard errors are computed and returned. If <code>FALSE</code> standard errors are not computed. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model is estimated with switch in mean. If <code>FALSE</code> model is estimated with constant mean. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model is estimated with switch in variance. If <code>FALSE</code> model is estimated with constant variance. Default is <code>TRUE</code>.
</p>
</li>
<li><p> init_theta: vector of initial values. vector must contain <code>(1 x q)</code> vector <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(P)</code> where sigma is a <code>(q x q)</code> covariance matrix.This is optional. Default is <code>NULL</code>, in which case <code><a href="#topic+initVals_MSARmdl">initVals_MSARmdl</a></code> is used to generate initial values.
</p>
</li>
<li><p> method: string determining which method to use. Options are <code>'EM'</code> for EM algorithm or <code>'MLE'</code> for Maximum Likelihood Estimation.  Default is <code>'EM'</code>.
</p>
</li>
<li><p> maxit: integer determining the maximum number of EM iterations.
</p>
</li>
<li><p> thtol: double determining the convergence criterion for the absolute difference in parameter estimates <code>theta</code> between iterations. Default is <code>1e-6</code>.
</p>
</li>
<li><p> maxit_converge: integer determining the maximum number of initial values attempted until solution is finite. For example, if parameters in <code>theta</code> or <code>logLike</code> are <code>NaN</code> another set of initial values (up to <code>maxit_converge</code>) is attempted until finite values are returned. This does not occur frequently for most types of data but may be useful in some cases. Once finite values are obtained, this counts as one iteration towards <code>use_diff_init</code>. Default is <code>500</code>.
</p>
</li>
<li><p> use_diff_init: integer determining how many different initial values to try (that do not return <code>NaN</code>; see <code>maxit_converge</code>). Default is <code>1</code>.
</p>
</li>
<li><p> mle_stationary_constraint: Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>TRUE</code>.
</p>
</li>
<li><p> mle_variance_constraint: Double used to determine the lower bound for variance in each regime. Value should be between <code>0</code> and <code>1</code> as it is multiplied by single regime variance. Default is <code>0.01</code> (i.e., <code>1%</code> of single regime variance.
</p>
</li>
<li><p> mle_theta_low: Vector with lower bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li>
<li><p> mle_theta_upp: Vector with upper bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>MSARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T x 1)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p + const)</code> matrix of lagged observations with a leading column of <code>1</code>s.
</p>
</li>
<li><p> x: a <code>(T-p x p)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T x 1)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T x 1)</code> matrix of residuals.
</p>
</li>
<li><p> intercept: a <code>(k x 1)</code> vector of estimated intercepts of each process.
</p>
</li>
<li><p> mu: a <code>(k x 1)</code> vector of estimated means of each process.
</p>
</li>
<li><p> beta: a <code>((1 + p + qz) x k)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients.
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> stdev: a <code>(k x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li><p> sigma: a <code>(k x 1)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code> and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise. This is the same as <code>theta_sig_ind</code> in <code>MSARmdl</code>.
</p>
</li>
<li><p> theta_P_ind: vector indicating location of transition matrix elements with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series. This is always <code>1</code> in <code>MSARmdl</code>.
</p>
</li>
<li><p> k: number of regimes in estimated model.
</p>
</li>
<li><p> P: a <code>(k x k)</code> transition matrix.
</p>
</li>
<li><p> pinf: a <code>(k x 1)</code> vector with limiting probabilities of each regime.
</p>
</li>
<li><p> St: a <code>(T x k)</code> vector with smoothed probabilities of each regime at each time <code>t</code>.
</p>
</li>
<li><p> deltath: double with maximum absolute difference in vector <code>theta</code> between last iteration.
</p>
</li>
<li><p> iterations: number of EM iterations performed to achieve convergence (if less than <code>maxit</code>).
</p>
</li>
<li><p> theta_0: vector of initial values used.
</p>
</li>
<li><p> init_used: number of different initial values used to get a finite solution. See description of input <code>maxit_converge</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model was estimated with switch in mean. If <code>FALSE</code> model was estimated with constant mean.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model was estimated with switch in variance. If <code>FALSE</code> model was estimated with constant variance.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> trace: List with Lists of estimation output for each initial value used due to <code>use_diff_init &gt; 1</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Hamilton, James D. 1990. “Analysis of time series subject to changes in regime.” <em>Journal of econometrics</em>, 45 (1-2): 39–70.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARmdl">ARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------- Use simulated process ----------------------------
set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 200, 
                mu    = c(5,10),
                sigma = c(1,4),
                phi   = c(0.5),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)

# Set options for model estimation
control &lt;- list(msmu   = TRUE, 
                msvar  = TRUE, 
                method = "EM",
                use_diff_init = 1)

# Estimate model

  ms_mdl &lt;- MSARmdl(y_ms_simu$y, p = 1, k = 2, control = control)
  summary(ms_mdl)




</code></pre>

<hr>
<h2 id='MSARXmdl_em'>Estimation of Markov-switching ARX model by EM Algorithm</h2><span id='topic+MSARXmdl_em'></span>

<h3>Description</h3>

<p>Estimate Markov-switching ARX model by EM algorithm. This function is used by <code><a href="#topic+MSARmdl">MSARmdl</a></code> which organizes the output and takes raw data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSARXmdl_em(theta_0, mdl, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSARXmdl_em_+3A_theta_0">theta_0</code></td>
<td>
<p>vector with initial values for parameters.</p>
</td></tr>
<tr><td><code id="MSARXmdl_em_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="MSARXmdl_em_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="MSARXmdl_em_+3A_optim_options">optim_options</code></td>
<td>
<p>List with optimization options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model results.
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38.
</p>
<p>Hamilton, James D. 1990. “Analysis of time series subject to changes in regime.” <em>Journal of econometrics</em>, 45 (1-2): 39–70.
</p>

<hr>
<h2 id='MSVARmdl'>Markov-switching vector autoregressive model</h2><span id='topic+MSVARmdl'></span>

<h3>Description</h3>

<p>This function estimates a Markov-switching vector autoregressive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSVARmdl(Y, p, k, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSVARmdl_+3A_y">Y</code></td>
<td>
<p>(<code>T x q</code>) vector with observational data.</p>
</td></tr>
<tr><td><code id="MSVARmdl_+3A_p">p</code></td>
<td>
<p>integer for the number of lags to use in estimation. Must be greater than or equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="MSVARmdl_+3A_k">k</code></td>
<td>
<p>integer for the number of regimes to use in estimation. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
<tr><td><code id="MSVARmdl_+3A_control">control</code></td>
<td>
<p>List with optimization options including:
</p>

<ul>
<li><p> getSE: Boolean. If <code>TRUE</code> standard errors are computed and returned. If <code>FALSE</code> standard errors are not computed. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model is estimated with switch in mean. If <code>FALSE</code> model is estimated with constant mean. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model is estimated with switch in variance. If <code>FALSE</code> model is estimated with constant variance. Default is <code>TRUE</code>.
</p>
</li>
<li><p> init_theta: vector of initial values. vector must contain <code>(1 x q)</code> vector <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(P)</code> where sigma is a <code>(q x q)</code> covariance matrix. This is optional. Default is <code>NULL</code>, in which case <code><a href="#topic+initVals_MSARmdl">initVals_MSARmdl</a></code> is used to generate initial values.
</p>
</li>
<li><p> method: string determining which method to use. Options are <code>'EM'</code> for EM algorithm or <code>'MLE'</code> for Maximum Likelihood Estimation.  Default is <code>'EM'</code>.
</p>
</li>
<li><p> maxit: integer determining the maximum number of EM iterations.
</p>
</li>
<li><p> thtol: double determining the convergence criterion for the absolute difference in parameter estimates <code>theta</code> between iterations. Default is <code>1e-6</code>.
</p>
</li>
<li><p> maxit_converge: integer determining the maximum number of initial values attempted until solution is finite. For example, if parameters in <code>theta</code> or <code>logLike</code> are <code>NaN</code> another set of initial values (up to <code>maxit_converge</code>) is attempted until finite values are returned. This does not occur frequently for most types of data but may be useful in some cases. Once finite values are obtained, this counts as one iteration towards <code>use_diff_init</code>. Default is <code>500</code>.
</p>
</li>
<li><p> use_diff_init: integer determining how many different initial values to try (that do not return <code>NaN</code>; see <code>maxit_converge</code>). Default is <code>1</code>.
</p>
</li>
<li><p> mle_stationary_constraint: Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>TRUE</code>.
</p>
</li>
<li><p> mle_variance_constraint: double used to determine the lower bound on the smallest eigenvalue for the covariance matrix of each regime. Default is <code>1e-3</code>.
</p>
</li>
<li><p> mle_theta_low: Vector with lower bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li>
<li><p> mle_theta_upp: Vector with upper bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>MSVARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x q)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p*q + const)</code> matrix of lagged observations with a leading column of <code>1</code>s.
</p>
</li>
<li><p> x: a <code>(T-p x p*q)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T x q)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T-p x q)</code> matrix of residuals.
</p>
</li>
<li><p> intercept: a <code>(k x q)</code> matrix of estimated intercepts of each process.
</p>
</li>
<li><p> mu: a <code>(k x q)</code> matrix of estimated means of each process.
</p>
</li>
<li><p> beta: a list containing <code>k</code> separate <code>((1 + p) x q)</code> matrix of estimated coefficients for each regime.  
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> Fmat: Companion matrix containing autoregressive coefficients.
</p>
</li>
<li><p> stdev: List with <code>k</code> <code>(q x q)</code> matrices with estimated standard deviation on the diagonal.
</p>
</li>
<li><p> sigma: List with <code>k</code> <code>(q x q)</code> matrices with estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code> and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_P_ind: vector indicating location of transition matrix elements with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes in estimated model.
</p>
</li>
<li><p> P: a <code>(k x k)</code> transition matrix.
</p>
</li>
<li><p> pinf: a <code>(k x 1)</code> vector with limiting probabilities of each regime.
</p>
</li>
<li><p> St: a <code>(T x k)</code> vector with smoothed probabilities of each regime at each time <code>t</code>.
</p>
</li>
<li><p> deltath: double with maximum absolute difference in vector <code>theta</code> between last iteration.
</p>
</li>
<li><p> iterations: number of EM iterations performed to achieve convergence (if less than <code>maxit</code>).
</p>
</li>
<li><p> theta_0: vector of initial values used.
</p>
</li>
<li><p> init_used: number of different initial values used to get a finite solution. See description of input <code>maxit_converge</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model was estimated with switch in mean. If <code>FALSE</code> model was estimated with constant mean.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model was estimated with switch in variance. If <code>FALSE</code> model was estimated with constant variance.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> trace: List with Lists of estimation output for each initial value used due to <code>use_diff_init &gt; 1</code>.
</p>
</li></ul>

<p>List with model characteristics
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VARmdl">VARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Define DGP of MS VAR process
mdl_msvar2 &lt;- list(n     = 200, 
                   p     = 1,
                   q     = 2,
                   mu    = rbind(c(5, -2),
                                 c(10, 2)),
                   sigma = list(rbind(c(5.0, 1.5),
                                      c(1.5, 1.0)),
                                rbind(c(7.0, 3.0),
                                      c(3.0, 2.0))),
                   phi   = rbind(c(0.50, 0.30),
                                 c(0.20, 0.70)),
                   k     = 2,
                   P     = rbind(c(0.90, 0.10),
                                 c(0.10, 0.90)))

# Simulate process using simuMSVAR() function
y_msvar_simu &lt;- simuMSVAR(mdl_msvar2)

# Set options for model estimation
control &lt;- list(msmu   = TRUE, 
                msvar  = TRUE,
                method = "EM",
                use_diff_init = 1)
                
# Estimate model

  y_msvar_mdl &lt;- MSVARmdl(y_msvar_simu$y, p = 1, k = 2, control = control)
  summary(y_msvar_mdl)

</code></pre>

<hr>
<h2 id='MSVARmdl_em'>Estimation of Markov-switching vector autoregressive model by EM Algorithm</h2><span id='topic+MSVARmdl_em'></span>

<h3>Description</h3>

<p>Estimate Markov-switching vector autoregressive model by EM algorithm. This function is used by <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> which organizes the output and takes raw data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSVARmdl_em(theta_0, mdl, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSVARmdl_em_+3A_theta_0">theta_0</code></td>
<td>
<p>vector with initial values for parameters.</p>
</td></tr>
<tr><td><code id="MSVARmdl_em_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="MSVARmdl_em_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="MSVARmdl_em_+3A_optim_options">optim_options</code></td>
<td>
<p>List with optimization options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model results.
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38.
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. Springer.
</p>

<hr>
<h2 id='MSVARmdl_mle'>Markov-switching vector autoregressive maximum likelihood estimation</h2><span id='topic+MSVARmdl_mle'></span>

<h3>Description</h3>

<p>This function computes estimate a Markov-switching vector autoregressive model using MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSVARmdl_mle(theta_0, mdl_in, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSVARmdl_mle_+3A_theta_0">theta_0</code></td>
<td>
<p>vector containing initial values to use in optimization</p>
</td></tr>
<tr><td><code id="MSVARmdl_mle_+3A_mdl_in">mdl_in</code></td>
<td>
<p>List with model properties (can be obtained from estimating linear model i.e., using <code><a href="#topic+VARmdl">VARmdl</a></code>)</p>
</td></tr>
<tr><td><code id="MSVARmdl_mle_+3A_k">k</code></td>
<td>
<p>integer determining the number of regimes</p>
</td></tr>
<tr><td><code id="MSVARmdl_mle_+3A_optim_options">optim_options</code></td>
<td>
<p>List containing 
</p>

<ul>
<li><p> maxit: maximum number of iterations.
</p>
</li>
<li><p> thtol: convergence criterion.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model attributes
</p>

<hr>
<h2 id='MSVARXmdl'>Markov-switching vector autoregressive model</h2><span id='topic+MSVARXmdl'></span>

<h3>Description</h3>

<p>This function estimates a Markov-switching vector autoregressive model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSVARXmdl(Y, p, k, Z, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSVARXmdl_+3A_y">Y</code></td>
<td>
<p>(<code>T x q</code>) vector with observational data.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_+3A_p">p</code></td>
<td>
<p>integer for the number of lags to use in estimation. Must be greater than or equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_+3A_k">k</code></td>
<td>
<p>integer for the number of regimes to use in estimation. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_+3A_z">Z</code></td>
<td>
<p>a <code>(T x qz)</code> matrix of exogenous regressors.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_+3A_control">control</code></td>
<td>
<p>List with optimization options including:
</p>

<ul>
<li><p> getSE: Boolean. If <code>TRUE</code> standard errors are computed and returned. If <code>FALSE</code> standard errors are not computed. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model is estimated with switch in mean. If <code>FALSE</code> model is estimated with constant mean. Default is <code>TRUE</code>.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model is estimated with switch in variance. If <code>FALSE</code> model is estimated with constant variance. Default is <code>TRUE</code>.
</p>
</li>
<li><p> init_theta: vector of initial values. vector must contain <code>(1 x q)</code> vector <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(P)</code> where sigma is a <code>(q x q)</code> covariance matrix. This is optional. Default is <code>NULL</code>, in which case <code><a href="#topic+initVals_MSARmdl">initVals_MSARmdl</a></code> is used to generate initial values.
</p>
</li>
<li><p> method: string determining which method to use. Options are <code>'EM'</code> for EM algorithm or <code>'MLE'</code> for Maximum Likelihood Estimation.  Default is <code>'EM'</code>.
</p>
</li>
<li><p> maxit: integer determining the maximum number of EM iterations.
</p>
</li>
<li><p> thtol: double determining the convergence criterion for the absolute difference in parameter estimates <code>theta</code> between iterations. Default is <code>1e-6</code>.
</p>
</li>
<li><p> maxit_converge: integer determining the maximum number of initial values attempted until solution is finite. For example, if parameters in <code>theta</code> or <code>logLike</code> are <code>NaN</code> another set of initial values (up to <code>maxit_converge</code>) is attempted until finite values are returned. This does not occur frequently for most types of data but may be useful in some cases. Once finite values are obtained, this counts as one iteration towards <code>use_diff_init</code>. Default is <code>500</code>.
</p>
</li>
<li><p> use_diff_init: integer determining how many different initial values to try (that do not return <code>NaN</code>; see <code>maxit_converge</code>). Default is <code>1</code>.
</p>
</li>
<li><p> mle_stationary_constraint: Boolean determining if only stationary solutions are considered (if <code>TRUE</code>) or not (if <code>FALSE</code>). Default is <code>TRUE</code>.
</p>
</li>
<li><p> mle_variance_constraint: double used to determine the lower bound on the smallest eigenvalue for the covariance matrix of each regime. Default is <code>1e-3</code>.
</p>
</li>
<li><p> mle_theta_low: Vector with lower bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li>
<li><p> mle_theta_upp: Vector with upper bounds on parameters (Used only if method = &quot;MLE&quot;). Default is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>MSVARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x q)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p*q + const)</code> matrix of lagged observations with a leading column of <code>1</code>s.
</p>
</li>
<li><p> x: a <code>(T-p x p*q)</code> matrix of lagged observations.
</p>
</li>
<li><p> resid: a <code>(T-p x q)</code> matrix of residuals.
</p>
</li>
<li><p> fitted: a <code>(T x q)</code> matrix of fitted values.
</p>
</li>
<li><p> intercept: a <code>(k x q)</code> matrix of estimated intercepts of each process.
</p>
</li>
<li><p> mu: a <code>(k x q)</code> matrix of estimated means of each process.
</p>
</li>
<li><p> beta: a list containing <code>k</code> separate <code>((1 + p + qz) x q)</code> matrix of estimated coefficients for each regime.  
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients.
</p>
</li>
<li><p> phi: estimates of autoregressive coefficients.
</p>
</li>
<li><p> Fmat: Companion matrix containing autoregressive coefficients.
</p>
</li>
<li><p> stdev: List with <code>k</code> <code>(q x q)</code> matrices with estimated standard deviation on the diagonal.
</p>
</li>
<li><p> sigma: List with <code>k</code> <code>(q x q)</code> matrices with estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code> and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_P_ind: vector indicating location of transition matrix elements with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes in estimated model.
</p>
</li>
<li><p> P: a <code>(k x k)</code> transition matrix.
</p>
</li>
<li><p> pinf: a <code>(k x 1)</code> vector with limiting probabilities of each regime.
</p>
</li>
<li><p> St: a <code>(T x k)</code> vector with smoothed probabilities of each regime at each time <code>t</code>.
</p>
</li>
<li><p> deltath: double with maximum absolute difference in vector <code>theta</code> between last iteration.
</p>
</li>
<li><p> iterations: number of EM iterations performed to achieve convergence (if less than <code>maxit</code>).
</p>
</li>
<li><p> theta_0: vector of initial values used.
</p>
</li>
<li><p> init_used: number of different initial values used to get a finite solution. See description of input <code>maxit_converge</code>.
</p>
</li>
<li><p> msmu: Boolean. If <code>TRUE</code> model was estimated with switch in mean. If <code>FALSE</code> model was estimated with constant mean.
</p>
</li>
<li><p> msvar: Boolean. If <code>TRUE</code> model was estimated with switch in variance. If <code>FALSE</code> model was estimated with constant variance.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> trace: List with Lists of estimation output for each initial value used due to <code>use_diff_init &gt; 1</code>.
</p>
</li></ul>

<p>List with model characteristics
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38..
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VARmdl">VARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Define DGP of MS VAR process
mdl_msvar2 &lt;- list(n     = 200, 
                   p     = 1,
                   q     = 2,
                   mu    = rbind(c(5, -2),
                                 c(10, 2)),
                   sigma = list(rbind(c(5.0, 1.5),
                                      c(1.5, 1.0)),
                                rbind(c(7.0, 3.0),
                                      c(3.0, 2.0))),
                   phi   = rbind(c(0.50, 0.30),
                                 c(0.20, 0.70)),
                   k     = 2,
                   P     = rbind(c(0.90, 0.10),
                                 c(0.10, 0.90)))

# Simulate process using simuMSVAR() function
y_msvar_simu &lt;- simuMSVAR(mdl_msvar2)

# Set options for model estimation
control &lt;- list(msmu   = TRUE, 
                msvar  = TRUE,
                method = "EM",
                use_diff_init = 1)
                
# Estimate model

  y_msvar_mdl &lt;- MSVARmdl(y_msvar_simu$y, p = 1, k = 2, control = control)
  summary(y_msvar_mdl)

</code></pre>

<hr>
<h2 id='MSVARXmdl_em'>Estimation of Markov-switching VARX model by EM Algorithm</h2><span id='topic+MSVARXmdl_em'></span>

<h3>Description</h3>

<p>Estimate Markov-switching VARX model by EM algorithm. This function is used by <code><a href="#topic+MSVARmdl">MSVARmdl</a></code> which organizes the output and takes raw data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSVARXmdl_em(theta_0, mdl, k, optim_options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MSVARXmdl_em_+3A_theta_0">theta_0</code></td>
<td>
<p>vector with initial values for parameters.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_em_+3A_mdl">mdl</code></td>
<td>
<p>List with model attributes.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_em_+3A_k">k</code></td>
<td>
<p>Integer determining the number of regimes.</p>
</td></tr>
<tr><td><code id="MSVARXmdl_em_+3A_optim_options">optim_options</code></td>
<td>
<p>List with optimization options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with model results.
</p>


<h3>References</h3>

<p>Dempster, A. P., N. M. Laird, and D. B. Rubin. 1977. “Maximum Likelihood from Incomplete Data via the EM Algorithm.” <em>Journal of the Royal Statistical Society</em>. Series B 39 (1): 1–38.
</p>
<p>Krolzig, Hans-Martin. 1997. “The markov-switching vector autoregressive model.”. Springer.
</p>

<hr>
<h2 id='Nmdl'>Normal distribution model</h2><span id='topic+Nmdl'></span>

<h3>Description</h3>

<p>This function estimates a univariate or multivariate normally distributed model. This can be used for the null hypothesis of a linear model against an alternative hypothesis of a HMM with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nmdl(Y, Z = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Nmdl_+3A_y">Y</code></td>
<td>
<p>a <code>(T x q)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="Nmdl_+3A_z">Z</code></td>
<td>
<p>an otpional  <code>(T x qz)</code> matrix of exogenous regressors. Default is NULL.</p>
</td></tr>
<tr><td><code id="Nmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>Nmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T x q)</code> matrix of observations.
</p>
</li>
<li><p> fitted: a <code>(T x q)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T x q)</code> matrix of residuals.
</p>
</li>
<li><p> mu: a <code>(1 x q)</code> vector of estimated means of each process.
</p>
</li>
<li><p> intercept: a <code>(1 x q)</code> vector of estimated intercept of each process. If Z is NULL, it is the same as mu. 
</p>
</li>
<li><p> beta: a <code>((1 + p + qz) x q)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients (If Z is provided). 
</p>
</li>
<li><p> stdev: a <code>(q x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li><p> sigma: a <code>(q x q)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code>, <code>betaZ</code> (if matrix Z is provided), and <code>vech(sigma)</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> n: number of observations (same as <code>T</code>).
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes. This is always <code>1</code> in <code>Nmdl</code>.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# ----- Univariate ----- # 
# Define DGP 
mdl_norm &lt;- list(n     = 1000, 
                 q     = 1,
                 mu    = as.matrix(5),
                 sigma = as.matrix(5.0))

# Simulate process using simuNorm() function
y_norm_simu &lt;- simuNorm(mdl_norm)

# estimate parameters
y_norm_mdl &lt;- Nmdl(y_norm_simu$y)
summary(y_norm_mdl)


# ----- Multivariate ----- # 
# Define DGP 
mdl_norm &lt;- list(n     = 1000, 
                 q     = 2,
                 mu    = c(5, -2),
                 sigma = rbind(c(5.0, 1.5),
                               c(1.5, 1.0)))

# Simulate process using simuNorm() function
y_norm_simu &lt;- simuNorm(mdl_norm)

# estimate parameters
y_norm_mdl &lt;- Nmdl(y_norm_simu$y)
summary(y_norm_mdl)
</code></pre>

<hr>
<h2 id='nobs.ARmdl'>Nobs of a <code>ARmdl</code> object</h2><span id='topic+nobs.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.ARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.ARmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='nobs.HMmdl'>Nobs of a <code>HMmdl</code> object</h2><span id='topic+nobs.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.HMmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.HMmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='nobs.MSARmdl'>Nobs of a <code>MSARmdl</code> object</h2><span id='topic+nobs.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.MSARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.MSARmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='nobs.MSVARmdl'>Nobs of a <code>MSVARmdl</code> object</h2><span id='topic+nobs.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.MSVARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.MSVARmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='nobs.Nmdl'>Nobs of a <code>Nmdl</code> object</h2><span id='topic+nobs.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.Nmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.Nmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='nobs.VARmdl'>Nobs of a <code>VARmdl</code> object</h2><span id='topic+nobs.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>nobs()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.VARmdl_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.VARmdl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of time series observations.
</p>

<hr>
<h2 id='paramList_MSARmdl'>Parameter list for Markov-switching autoregressive model</h2><span id='topic+paramList_MSARmdl'></span>

<h3>Description</h3>

<p>This function takes the parameter vector of interest and converts it to a list with specific parameter vectors needed for univariate Markov-switching functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramList_MSARmdl(theta, p, k, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramList_MSARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters.</p>
</td></tr>
<tr><td><code id="paramList_MSARmdl_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="paramList_MSARmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
<tr><td><code id="paramList_MSARmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicating if the mean switches with regime.</p>
</td></tr>
<tr><td><code id="paramList_MSARmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicating if the variance switches with regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the mean, variance, transition matrix, limiting probabilities, and a vector of state indicators.
</p>

<hr>
<h2 id='paramList_MSARXmdl'>Parameter list for Markov-switching ARX model</h2><span id='topic+paramList_MSARXmdl'></span>

<h3>Description</h3>

<p>This function takes the parameter vector of interest and converts it to a list with specific parameter vectors needed for univariate Markov-switching functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramList_MSARXmdl(theta, p, k, qz, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramList_MSARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters.</p>
</td></tr>
<tr><td><code id="paramList_MSARXmdl_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="paramList_MSARXmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
<tr><td><code id="paramList_MSARXmdl_+3A_qz">qz</code></td>
<td>
<p>Number of exogenous variables.</p>
</td></tr>
<tr><td><code id="paramList_MSARXmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicating if the mean switches with regime.</p>
</td></tr>
<tr><td><code id="paramList_MSARXmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicating if the variance switches with regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the mean, variance, transition matrix, limiting probabilities, and a vector of state indicators.
</p>

<hr>
<h2 id='paramList_MSVARmdl'>Parameter list for Markov-switching vector autoregressive model</h2><span id='topic+paramList_MSVARmdl'></span>

<h3>Description</h3>

<p>This function takes the parameter vector of interest and converts it to a list with specific parameter vectors needed for multivariate Markov-switching functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramList_MSVARmdl(theta, q, p, k, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramList_MSVARmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters.</p>
</td></tr>
<tr><td><code id="paramList_MSVARmdl_+3A_q">q</code></td>
<td>
<p>Number of time series.</p>
</td></tr>
<tr><td><code id="paramList_MSVARmdl_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="paramList_MSVARmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
<tr><td><code id="paramList_MSVARmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicating if the mean switches with regime.</p>
</td></tr>
<tr><td><code id="paramList_MSVARmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicating if the variance switches with regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the mean, variance, transition matrix, limiting probabilities, and a vector of state indicators.
</p>

<hr>
<h2 id='paramList_MSVARXmdl'>Parameter list for Markov-switching VARX model</h2><span id='topic+paramList_MSVARXmdl'></span>

<h3>Description</h3>

<p>This function takes the parameter vector of interest and converts it to a list with specific parameter vectors needed for multivariate Markov-switching functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramList_MSVARXmdl(theta, q, p, k, qz, msmu, msvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paramList_MSVARXmdl_+3A_theta">theta</code></td>
<td>
<p>Vector of parameters.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_q">q</code></td>
<td>
<p>Number of time series.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_p">p</code></td>
<td>
<p>Number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_k">k</code></td>
<td>
<p>Number of regimes.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_qz">qz</code></td>
<td>
<p>Number of exogenous variables.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_msmu">msmu</code></td>
<td>
<p>Boolean indicating if the mean switches with regime.</p>
</td></tr>
<tr><td><code id="paramList_MSVARXmdl_+3A_msvar">msvar</code></td>
<td>
<p>Boolean indicating if the variance switches with regime.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the mean, variance, transition matrix, limiting probabilities, and a vector of state indicators.
</p>

<hr>
<h2 id='plot.ARmdl'>Plot of a <code>ARmdl</code> object</h2><span id='topic+plot.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ARmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.ARmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.Hmmdl'>Plot of a <code>HMmdl</code> object</h2><span id='topic+plot.Hmmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hmmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Hmmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.Hmmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Hmmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.MSARmdl'>Plot of a <code>MSARmdl</code> object</h2><span id='topic+plot.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MSARmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.MSARmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.MSVARmdl'>Plot of a <code>MSVARmdl</code> object</h2><span id='topic+plot.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MSVARmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.MSVARmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSVARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.Nmdl'>Plot of a <code>Nmdl</code> object</h2><span id='topic+plot.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Nmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.Nmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Nmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuAR'>Plot of a <code>simuAR</code> object</h2><span id='topic+plot.simuAR'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuAR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuAR_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuAR_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuAR</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuARX'>Plot of a <code>simuARX</code> object</h2><span id='topic+plot.simuARX'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuARX'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuARX_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuARX_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuARX</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuHMM'>Plot of a <code>simuHMM</code> object</h2><span id='topic+plot.simuHMM'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuHMM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuHMM'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuHMM_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuHMM_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuHMM</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuMSAR'>Plot of a <code>simuMSAR</code> object</h2><span id='topic+plot.simuMSAR'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuMSAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuMSAR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuMSAR_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuMSAR_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuMSAR</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuMSARX'>Plot of a <code>simuMSARX</code> object</h2><span id='topic+plot.simuMSARX'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuMSAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuMSARX'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuMSARX_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuMSARX_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuMSARX</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuMSVAR'>Plot of a <code>simuMSVAR</code> object</h2><span id='topic+plot.simuMSVAR'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuMSVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuMSVAR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuMSVAR_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuMSVAR_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuMSVAR</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuMSVARX'>Plot of a <code>simuMSVARX</code> object</h2><span id='topic+plot.simuMSVARX'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuMSVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuMSVARX'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuMSVARX_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuMSVARX_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuMSVARX</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuNorm'>Plot of a <code>simuNorm</code> object</h2><span id='topic+plot.simuNorm'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuNorm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuNorm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuNorm_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuNorm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuNorm</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuVAR'>Plot of a <code>simuVAR</code> object</h2><span id='topic+plot.simuVAR'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuVAR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuVAR_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuVAR_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuVAR</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.simuVARX'>Plot of a <code>simuVARX</code> object</h2><span id='topic+plot.simuVARX'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>simuVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simuVARX'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simuVARX_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.simuVARX_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>simuVARX</code> object is returned invisibly.
</p>

<hr>
<h2 id='plot.VARmdl'>Plot of a <code>VARmdl</code> object</h2><span id='topic+plot.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>plot()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.VARmdl_+3A_x">x</code></td>
<td>
<p>the coordinates of points in the plot. Alternatively, a
single plotting structure, function or <em>any <span class="rlang"><b>R</b></span> object with a
<code>plot</code> method</em> can be provided.</p>
</td></tr>
<tr><td><code id="plot.VARmdl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as
<a href="graphics.html#topic+graphical+20parameters">graphical parameters</a> (see <code><a href="graphics.html#topic+par">par</a></code>).
Many methods will accept the following arguments:
</p>

<dl>
<dt><code>type</code></dt><dd><p>what type of plot should be drawn.  Possible types are
</p>

<ul>
<li> <p><code>"p"</code> for <b>p</b>oints,
</p>
</li>
<li> <p><code>"l"</code> for <b>l</b>ines,
</p>
</li>
<li> <p><code>"b"</code> for <b>b</b>oth,
</p>
</li>
<li> <p><code>"c"</code> for the lines part alone of <code>"b"</code>,
</p>
</li>
<li> <p><code>"o"</code> for both &lsquo;<b>o</b>verplotted&rsquo;,
</p>
</li>
<li> <p><code>"h"</code> for &lsquo;<b>h</b>istogram&rsquo; like (or
&lsquo;high-density&rsquo;) vertical lines,
</p>
</li>
<li> <p><code>"s"</code> for stair <b>s</b>teps,
</p>
</li>
<li> <p><code>"S"</code> for other <b>s</b>teps, see &lsquo;Details&rsquo; below,
</p>
</li>
<li> <p><code>"n"</code> for no plotting.
</p>
</li></ul>

<p>All other <code>type</code>s give a warning or an error; using, e.g.,
<code>type = "punkte"</code> being equivalent to <code>type = "p"</code> for S
compatibility.  Note that some methods,
e.g. <code><a href="graphics.html#topic+plot.factor">plot.factor</a></code>, do not accept this.
</p>
</dd>
<dt><code>main</code></dt><dd><p>an overall title for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>sub</code></dt><dd><p>a subtitle for the plot: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>xlab</code></dt><dd><p>a title for the x axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>ylab</code></dt><dd><p>a title for the y axis: see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</dd>
<dt><code>asp</code></dt><dd><p>the <code class="reqn">y/x</code> aspect ratio,
see <code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>The <code>VARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='predict.ARmdl'>Predict for a <code>ARmdl</code> object</h2><span id='topic+predict.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ARmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.ARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.ARmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='predict.HMmdl'>Predict for a <code>HMmdl</code> object</h2><span id='topic+predict.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.HMmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.HMmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.HMmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='predict.MSARmdl'>Predict for a <code>MSARmdl</code> object</h2><span id='topic+predict.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MSARmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.MSARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.MSARmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='predict.MSVARmdl'>Predict for a <code>MSVARmdl</code> object</h2><span id='topic+predict.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MSVARmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.MSVARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.MSVARmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='predict.Nmdl'>Predict for a <code>Nmdl</code> object</h2><span id='topic+predict.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.Nmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.Nmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.Nmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='predict.VARmdl'>Predict for a <code>VARmdl</code> object</h2><span id='topic+predict.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>predict()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
predict(object, ..., h = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.VARmdl_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict.VARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
<tr><td><code id="predict.VARmdl_+3A_h">h</code></td>
<td>
<p>max number of prediction periods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(h x q)</code> matrix with predicted value values.
</p>

<hr>
<h2 id='print.ARmdl'>Print summary of an <code>ARmdl</code> object</h2><span id='topic+print.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ARmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.ARmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.ARmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.BootLRTest'>Print summary of a <code>BootLRTest</code> object</h2><span id='topic+print.BootLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>BootLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BootLRTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.BootLRTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.BootLRTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.BootLRTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>BootLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.CHPTest'>Print summary of a <code>CHPTest</code> object</h2><span id='topic+print.CHPTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>CHPTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CHPTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CHPTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.CHPTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.CHPTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>CHPTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.DLMCTest'>Print summary of a <code>DLMCTest</code> object</h2><span id='topic+print.DLMCTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>DLMCTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DLMCTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DLMCTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.DLMCTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.DLMCTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>DLMCTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.DLMMCTest'>Print summary of a <code>DLMMCTest</code> object</h2><span id='topic+print.DLMMCTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>DLMMCTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DLMMCTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DLMMCTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.DLMMCTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.DLMMCTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>DLMMCTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.HLRTest'>Print summary of a <code>CHPTest</code> object</h2><span id='topic+print.HLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>CHPTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HLRTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.HLRTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.HLRTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.HLRTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>CHPTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.HMmdl'>Print summary of a <code>HMmdl</code> object</h2><span id='topic+print.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.HMmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.HMmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.HMmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>HMmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.LMCLRTest'>Print summary of a <code>LMCLRTest</code> object</h2><span id='topic+print.LMCLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>LMCLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMCLRTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.LMCLRTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.LMCLRTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.LMCLRTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>LMCLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.MMCLRTest'>Print summary of a <code>MMCLRTest</code> object</h2><span id='topic+print.MMCLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>MMCLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MMCLRTest'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MMCLRTest_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.MMCLRTest_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.MMCLRTest_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MMCLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.MSARmdl'>Print summary of a <code>MSARmdl</code> object</h2><span id='topic+print.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MSARmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.MSARmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.MSARmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.MSVARmdl'>Print summary of a <code>MSVARmdl</code> object</h2><span id='topic+print.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MSVARmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.MSVARmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.MSVARmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSVARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.Nmdl'>Print summary of a <code>Nmdl</code> object</h2><span id='topic+print.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Nmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.Nmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.Nmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Nmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.VARmdl'>Print summary of an <code>VARmdl</code> object</h2><span id='topic+print.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>print()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.VARmdl_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.VARmdl_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="print.VARmdl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>VARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='randP'>Random Transition Matrix</h2><span id='topic+randP'></span>

<h3>Description</h3>

<p>This function creates a random transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randP(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randP_+3A_k">k</code></td>
<td>
<p>Number of regimes. Must be greater than or equal to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transition matrix with randomly generated entries.
</p>

<hr>
<h2 id='randSN'>Standard normal errors using box Muller</h2><span id='topic+randSN'></span>

<h3>Description</h3>

<p>This function generates uncorrelated standard normal processes using box Muller method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randSN(n, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randSN_+3A_n">n</code></td>
<td>
<p>Integer determining the length of the process to be simulated</p>
</td></tr>
<tr><td><code id="randSN_+3A_q">q</code></td>
<td>
<p>Integer determining the number of processes to be simulated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>T x q</code>) matrix of standard normal distributed errors
</p>

<hr>
<h2 id='residuals.ARmdl'>residuals of a <code>ARmdl</code> object</h2><span id='topic+residuals.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.ARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.ARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='residuals.HMmdl'>residuals of a <code>HMmdl</code> object</h2><span id='topic+residuals.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.HMmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.HMmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='residuals.MSARmdl'>residuals of a <code>MSARmdl</code> object</h2><span id='topic+residuals.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.MSARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.MSARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='residuals.MSVARmdl'>residuals of a <code>MSVARmdl</code> object</h2><span id='topic+residuals.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.MSVARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.MSVARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='residuals.Nmdl'>residuals of a <code>Nmdl</code> object</h2><span id='topic+residuals.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.Nmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.Nmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='residuals.VARmdl'>residuals of a <code>VARmdl</code> object</h2><span id='topic+residuals.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>residuals()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.VARmdl_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.VARmdl_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals.
</p>

<hr>
<h2 id='sim_DLmoments'>Simulated moment-based test statistics</h2><span id='topic+sim_DLmoments'></span>

<h3>Description</h3>

<p>This function computes the four moment-based test statistics (eq. <code>11</code> - <code>14</code>) discussed in Dufour &amp; Luger 2017 for <code>N</code> different simulated series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_DLmoments(Tsize, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_DLmoments_+3A_tsize">Tsize</code></td>
<td>
<p>Length of sample size for simulation.</p>
</td></tr>
<tr><td><code id="sim_DLmoments_+3A_n">N</code></td>
<td>
<p>Number of simulated samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>N x 4</code>) matrix with <code>N</code> different simulated moment-based test statistics.
</p>


<h3>References</h3>

<p>Dufour, J. M., &amp; Luger, R. 2017. &quot;Identification-robust moment-based 
tests for Markov switching in autoregressive models.&quot; <em>Econometric Reviews</em>, 36(6-9), 713-727.
</p>

<hr>
<h2 id='simuAR'>Simulate autoregressive process</h2><span id='topic+simuAR'></span>

<h3>Description</h3>

<p>This function simulates an autoregresive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuAR(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuAR_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> sigma: Standard deviation of process.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuAR_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated autoregressive series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of AR process
mdl_ar &lt;- list(n     = 500, 
               mu    = 5,
               sigma = 2,
               phi   = c(0.5,0.2))

# Simulate process using simuAR() function
y_simu &lt;- simuAR(mdl_ar)

plot(y_simu)
</code></pre>

<hr>
<h2 id='simuAR_cpp'>Simulate autoregressive process</h2><span id='topic+simuAR_cpp'></span>

<h3>Description</h3>

<p>This function simulates an autoregresive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuAR_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuAR_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> sigma: variance of process.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuAR_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuARX'>Simulate autoregressive X process</h2><span id='topic+simuARX'></span>

<h3>Description</h3>

<p>This function simulates an autoregresive X process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuARX(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuARX_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> sigma: Standard deviation of process.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x 1</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuARX_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated autoregressive series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of AR process
mdl_ar &lt;- list(n     = 500, 
               mu    = 5,
               sigma = 2,
               phi   = c(0.5,0.2))

# Simulate process using simuAR() function
y_simu &lt;- simuAR(mdl_ar)

plot(y_simu)
</code></pre>

<hr>
<h2 id='simuARX_cpp'>Simulate autoregressive process with exogenous regressors</h2><span id='topic+simuARX_cpp'></span>

<h3>Description</h3>

<p>This function simulates an ARX process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuARX_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuARX_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: Mean of process.
</p>
</li>
<li><p> sigma: variance of process.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x 1</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuARX_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuHMM'>Simulate Hidden Markov model with normally distributed errors</h2><span id='topic+simuHMM'></span>

<h3>Description</h3>

<p>This function simulates a Hidden Markov Model process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuHMM(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuHMM_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuHMM_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# ----- Univariate ----- #
# Define DGP 
mdl_hmm &lt;- list(n     = 1000, 
                q     = 1,
                mu    = as.matrix(c(5,
                                   -2)),
                sigma = list(as.matrix(5.0),
                             as.matrix(7.0)),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuHMM() function
y_hmm_simu &lt;- simuHMM(mdl_hmm)

plot(y_hmm_simu)

# ----- Multivariate ----- #
# Define DGP 
mdl_hmm &lt;- list(n     = 1000, 
                q     = 2,
                mu    = rbind(c(5, -2),
                              c(10, 2)),
                sigma = list(rbind(c(5.0, 1.5),
                                   c(1.5, 1.0)),
                             rbind(c(7.0, 3.0),
                                   c(3.0, 2.0))),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuHMM() function
y_hmm_simu &lt;- simuHMM(mdl_hmm)


plot(y_hmm_simu)
</code></pre>

<hr>
<h2 id='simuHMM_cpp'>Simulate Hidden Markov model with normally distributed errors</h2><span id='topic+simuHMM_cpp'></span>

<h3>Description</h3>

<p>This function simulates a Hidden Markov Model process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuHMM_cpp(mdl_h0, burnin = 100L, exog = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuHMM_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuHMM_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="simuHMM_cpp_+3A_exog">exog</code></td>
<td>
<p>bool determining if there are exogenous variables (<code>true</code>) or not (<code>false</code>). Default is <code>false</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated series and its DGP parameters.
</p>

<hr>
<h2 id='simuMdl'>Likelihood ratio test statistic sample distribution</h2><span id='topic+simuMdl'></span>

<h3>Description</h3>

<p>This function is used by Monte Carlo Likelihood ratio testing 
procedures to simulate processes under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMdl(mdl_h0, p, q, k, burnin, exog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMdl_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List with restricted model properties.</p>
</td></tr>
<tr><td><code id="simuMdl_+3A_p">p</code></td>
<td>
<p>integer specifying the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="simuMdl_+3A_q">q</code></td>
<td>
<p>integer specifying the number of series.</p>
</td></tr>
<tr><td><code id="simuMdl_+3A_k">k</code></td>
<td>
<p>integer specifying the number of regimes.</p>
</td></tr>
<tr><td><code id="simuMdl_+3A_burnin">burnin</code></td>
<td>
<p>integer specifying the number of observations to drop from beginning of simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated process properties.
</p>

<hr>
<h2 id='simuMSAR'>Simulate Markov-switching autoregressive process</h2><span id='topic+simuMSAR'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSAR(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSAR_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x 1</code>) vector with mean of process in each regime.
</p>
</li>
<li><p> sigma: A (<code>k x 1</code>) vector with standard deviation of process in each regime.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSAR_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated Markov-switching autoregressive process and its DGP properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 500, 
                mu    = c(5,10),
                sigma = c(1,2),
                phi   = c(0.5, 0.2),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)

plot(y_ms_simu)
</code></pre>

<hr>
<h2 id='simuMSAR_cpp'>Simulate Markov-switching autoregressive process</h2><span id='topic+simuMSAR_cpp'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSAR_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSAR_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x 1</code>) vector with mean of process in each regime.
</p>
</li>
<li><p> sigma: A (<code>k x 1</code>) vector with variance of process in each regime.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSAR_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated Markov-switching autoregressive process and its DGP properties.
</p>

<hr>
<h2 id='simuMSARX'>Simulate Markov-switching ARX process</h2><span id='topic+simuMSARX'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSARX(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSARX_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x 1</code>) vector with mean of process in each regime.
</p>
</li>
<li><p> sigma: A (<code>k x 1</code>) vector with standard deviation of process in each regime.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x 1</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSARX_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated Markov-switching autoregressive process and its DGP properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of MS AR process
mdl_ms2 &lt;- list(n     = 500, 
                mu    = c(5,10),
                sigma = c(1,2),
                phi   = c(0.5, 0.2),
                k     = 2,
                P     = rbind(c(0.90, 0.10),
                              c(0.10, 0.90)))

# Simulate process using simuMSAR() function
y_ms_simu &lt;- simuMSAR(mdl_ms2)

plot(y_ms_simu)
</code></pre>

<hr>
<h2 id='simuMSARX_cpp'>Simulate Markov-switching ARX process</h2><span id='topic+simuMSARX_cpp'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching ARX process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSARX_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSARX_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x 1</code>) vector with mean of process in each regime.
</p>
</li>
<li><p> sigma: A (<code>k x 1</code>) vector with variance of process in each regime.
</p>
</li>
<li><p> phi: Vector of autoregressive coefficients.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x 1</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSARX_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated Markov-switching autoregressive process and its DGP properties.
</p>

<hr>
<h2 id='simuMSVAR'>Simulate Markov-switching vector autoregressive process</h2><span id='topic+simuMSVAR'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching vector autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSVAR(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSVAR_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) matrix of means.
</p>
</li>
<li><p> sigma: List with <code>k</code> (<code>q x q</code>) covariance matrices.
</p>
</li>
<li><p> phi: A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSVAR_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of MS VAR process
mdl_msvar2 &lt;- list(n     = 1000, 
                   p     = 1,
                   q     = 2,
                   mu    = rbind(c(5, -2),
                                 c(10, 2)),
                   sigma = list(rbind(c(5.0, 1.5),
                                      c(1.5, 1.0)),
                                rbind(c(7.0, 3.0),
                                      c(3.0, 2.0))),
                   phi   = rbind(c(0.50, 0.30),
                                 c(0.20, 0.70)),
                   k     = 2,
                   P     = rbind(c(0.90, 0.10),
                                 c(0.10, 0.90)))

# Simulate process using simuMSVAR() function
y_msvar_simu &lt;- simuMSVAR(mdl_msvar2)

plot(y_msvar_simu)
</code></pre>

<hr>
<h2 id='simuMSVAR_cpp'>Simulate Markov-switching vector autoregressive process</h2><span id='topic+simuMSVAR_cpp'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching vector autoregressive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSVAR_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSVAR_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) matrix of means.
</p>
</li>
<li><p> sigma: List with <code>k</code> (<code>q x q</code>) covariance matrices.
</p>
</li>
<li><p> phi: A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSVAR_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuMSVARX'>Simulate Markov-switching VARX process</h2><span id='topic+simuMSVARX'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching VARX process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSVARX(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSVARX_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) matrix of means.
</p>
</li>
<li><p> sigma: List with <code>k</code> (<code>q x q</code>) covariance matrices.
</p>
</li>
<li><p> phi: A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSVARX_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP of MS VAR process
mdl_msvar2 &lt;- list(n     = 1000, 
                   p     = 1,
                   q     = 2,
                   mu    = rbind(c(5, -2),
                                 c(10, 2)),
                   sigma = list(rbind(c(5.0, 1.5),
                                      c(1.5, 1.0)),
                                rbind(c(7.0, 3.0),
                                      c(3.0, 2.0))),
                   phi   = rbind(c(0.50, 0.30),
                                 c(0.20, 0.70)),
                   k     = 2,
                   P     = rbind(c(0.90, 0.10),
                                 c(0.10, 0.90)))

# Simulate process using simuMSVAR() function
y_msvar_simu &lt;- simuMSVAR(mdl_msvar2)

plot(y_msvar_simu)
</code></pre>

<hr>
<h2 id='simuMSVARX_cpp'>Simulate Markov-switching VARX process</h2><span id='topic+simuMSVARX_cpp'></span>

<h3>Description</h3>

<p>This function simulates a Markov-switching VARX process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuMSVARX_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuMSVARX_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> k: Number of regimes.
</p>
</li>
<li><p> mu: A (<code>k x q</code>) matrix of means.
</p>
</li>
<li><p> sigma: List with <code>k</code> (<code>q x q</code>) covariance matrices.
</p>
</li>
<li><p> phi: A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> P: A (<code>k x k</code>) transition matrix (columns must sum to one).
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuMSVARX_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuNorm'>Simulate normally distributed process</h2><span id='topic+simuNorm'></span>

<h3>Description</h3>

<p>This function simulates a normally distributed process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuNorm(mdl_h0, burnin = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuNorm_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuNorm_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated series and its DGP parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
# Define DGP 
mdl_norm &lt;- list(n     = 1000, 
                 q     = 2,
                 mu    = c(5, -2),
                 sigma = rbind(c(5.0, 1.5),
                               c(1.5, 1.0)))

# Simulate process using simuNorm() function
y_norm_simu &lt;- simuNorm(mdl_norm)

plot(y_norm_simu)
</code></pre>

<hr>
<h2 id='simuNorm_cpp'>Simulate normally distributed process</h2><span id='topic+simuNorm_cpp'></span>

<h3>Description</h3>

<p>This function simulates a normally distributed process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuNorm_cpp(mdl_h0, burnin = 0L, exog = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuNorm_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuNorm_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
<tr><td><code id="simuNorm_cpp_+3A_exog">exog</code></td>
<td>
<p>bool determining if there are exogenous variables (<code>true</code>) or not (<code>false</code>). Default is <code>false</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated series and its DGP parameters.
</p>

<hr>
<h2 id='simuVAR'>Simulate VAR process</h2><span id='topic+simuVAR'></span>

<h3>Description</h3>

<p>This function simulates a vector autoregresive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuVAR(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuVAR_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> phi:  A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuVAR_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuVAR_cpp'>Simulate VAR process</h2><span id='topic+simuVAR_cpp'></span>

<h3>Description</h3>

<p>This function simulates a vector autoregresive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuVAR_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuVAR_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> phi:  A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuVAR_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuVARX'>Simulate VAR process</h2><span id='topic+simuVARX'></span>

<h3>Description</h3>

<p>This function simulates a vector autoregresive process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuVARX(mdl_h0, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuVARX_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> phi:  A (<code>q x (q x p)</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuVARX_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='simuVARX_cpp'>Simulate VARX process</h2><span id='topic+simuVARX_cpp'></span>

<h3>Description</h3>

<p>This function simulates a VARX process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuVARX_cpp(mdl_h0, burnin = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuVARX_cpp_+3A_mdl_h0">mdl_h0</code></td>
<td>
<p>List containing the following DGP parameters
</p>

<ul>
<li><p> n: Length of series.
</p>
</li>
<li><p> mu: A (<code>q x 1</code>) vector of means.
</p>
</li>
<li><p> sigma: A (<code>q x q</code>) covariance matrix.
</p>
</li>
<li><p> phi:  A (<code>q x qp</code>) matrix of autoregressive coefficients.
</p>
</li>
<li><p> p: Number of autoregressive lags.
</p>
</li>
<li><p> q: Number of series.
</p>
</li>
<li><p> eps: An optional (<code>T+burnin x q</code>) matrix with standard normal errors to be used. Errors will be generated if not provided.
</p>
</li>
<li><p> Z: A (<code>T x qz</code>) matrix with exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li>
<li><p> betaZ: A (<code>qz x q</code>) matrix  true coefficients on exogenous regressors (Optional) and where qz is the number of exogenous variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simuVARX_cpp_+3A_burnin">burnin</code></td>
<td>
<p>Number of simulated observations to remove from beginning. Default is <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with simulated vector autoregressive series and its DGP parameters.
</p>

<hr>
<h2 id='summary.ARmdl'>Summary of an <code>ARmdl</code> object</h2><span id='topic+summary.ARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>ARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ARmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.ARmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.ARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.BootLRTest'>Summary of a <code>BootLRTest</code> object</h2><span id='topic+summary.BootLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>BootLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BootLRTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BootLRTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.BootLRTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.BootLRTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>BootLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.CHPTest'>Summary of a <code>CHPTest</code> object</h2><span id='topic+summary.CHPTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>CHPTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CHPTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CHPTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.CHPTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.CHPTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>CHPTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.DLMCTest'>summaryummary of a <code>DLMCTest</code> object</h2><span id='topic+summary.DLMCTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>DLMCTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DLMCTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DLMCTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.DLMCTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.DLMCTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>DLMCTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.DLMMCTest'>Summary of a <code>DLMMCTest</code> object</h2><span id='topic+summary.DLMMCTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>DLMMCTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DLMMCTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DLMMCTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.DLMMCTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.DLMMCTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>DLMMCTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.HLRTest'>Summary of a <code>CHPTest</code> object</h2><span id='topic+summary.HLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>CHPTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HLRTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.HLRTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.HLRTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.HLRTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>CHPTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.HMmdl'>Summary of a <code>HMmdl</code> object</h2><span id='topic+summary.HMmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>HMmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.HMmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.HMmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.HMmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>HMmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.LMCLRTest'>Summary of a <code>LMCLRTest</code> object</h2><span id='topic+summary.LMCLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>LMCLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMCLRTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.LMCLRTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.LMCLRTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.LMCLRTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>LMCLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.MMCLRTest'>Summary of a <code>MMCLRTest</code> object</h2><span id='topic+summary.MMCLRTest'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>MMCLRTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MMCLRTest'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MMCLRTest_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.MMCLRTest_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.MMCLRTest_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MMCLRTest</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.MSARmdl'>Summary of a <code>MSARmdl</code> object</h2><span id='topic+summary.MSARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>MSARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSARmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MSARmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.MSARmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.MSARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.MSVARmdl'>Summary of a <code>MSVARmdl</code> object</h2><span id='topic+summary.MSVARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>MSVARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSVARmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MSVARmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.MSVARmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.MSVARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>MSVARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.Nmdl'>Summary of a <code>Nmdl</code> object</h2><span id='topic+summary.Nmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>Nmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Nmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Nmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.Nmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.Nmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Nmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='summary.VARmdl'>Summary of an <code>VARmdl</code> object</h2><span id='topic+summary.VARmdl'></span>

<h3>Description</h3>

<p>This is a method for the function <code>summary()</code> for objects of the class <code>VARmdl</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VARmdl'
summary(object, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.VARmdl_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.VARmdl_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with
<code><a href="base.html#topic+signif">signif</a>()</code> (for <code>summary.default</code>) or
<code><a href="base.html#topic+format">format</a>()</code> (for <code>summary.data.frame</code>).  In
<code>summary.default</code>, if not specified (i.e.,
<code><a href="base.html#topic+missing">missing</a>(.)</code>), <code>signif()</code> will <em>not</em> be called
anymore (since <span class="rlang"><b>R</b></span> &gt;= 3.4.0, where the default has been changed to
only round in the <code>print</code> and <code>format</code> methods).</p>
</td></tr>
<tr><td><code id="summary.VARmdl_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>VARmdl</code> object is returned invisibly.
</p>

<hr>
<h2 id='thetaSE'>Theta standard errors</h2><span id='topic+thetaSE'></span>

<h3>Description</h3>

<p>This function computes the standard errors of the parameters in vector theta. This is done using an approximation of the Hessian matrix (using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and <code>nearPD</code> if <code>info_mat</code> is not PD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaSE(mdl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thetaSE_+3A_mdl">mdl</code></td>
<td>
<p>List with model properties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List provided as input with additional attributes <code>HESS</code>,<code>theta_se</code>, <code>info_mat</code>, and <code>nearPD_used</code>.
</p>

<hr>
<h2 id='ts_lagged'>Lagged Time Series Data</h2><span id='topic+ts_lagged'></span>

<h3>Description</h3>

<p>This function takes a (<code>T x 1</code>) vector <code>Y</code> and returns the (<code>T-p x 1</code>) vector <code>y</code> and the (<code>T-p x p</code>) matrix of lagged observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_lagged(Y, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts_lagged_+3A_y">Y</code></td>
<td>
<p>Vector with time series observations.</p>
</td></tr>
<tr><td><code id="ts_lagged_+3A_p">p</code></td>
<td>
<p>integer for the number of lags to use in estimation. Must be greater than or equal to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with vector <code>y</code> (vector of lagged <code>Y</code>) and matrix <code>X</code> of lagged observations.
</p>

<hr>
<h2 id='USGNP'>US GNP data 1947Q2 - 2024Q2</h2><span id='topic+USGNP'></span>

<h3>Description</h3>

<p>US GNP data 1947Q2 - 2024Q2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USGNP
</code></pre>


<h3>Format</h3>

<p>This data is used in Rodriguez-Rondon &amp; Dufour (2024). The series ranges from 
1947Q2 to 2024Q2.
</p>
<dl>
<dt>Date</dt><dd><p>Vector of dates</p>
</dd>
<dt>GNP</dt><dd><p>US GNP series</p>
</dd>
<dt>GNP_gr</dt><dd><p>log difference of US GNP series</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/graph/?g=UKDQ">https://fred.stlouisfed.org/graph/?g=UKDQ</a>
</p>


<h3>References</h3>

<p>U.S. Bureau of Economic Analysis, Gross National Product [GNP], retrieved from FRED, Federal Reserve Bank of St. Louis; <em><a href="https://fred.stlouisfed.org/series/GNP">https://fred.stlouisfed.org/series/GNP</a></em>, September, 2024.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2024. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>

<hr>
<h2 id='USRGDP'>US Real GDP data 1947Q2 - 2024Q2</h2><span id='topic+USRGDP'></span>

<h3>Description</h3>

<p>US Real GDP data 1947Q2 - 2024Q2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USRGDP
</code></pre>


<h3>Format</h3>

<p>This data is used in Rodriguez-Rondon &amp; Dufour (2024). The series ranges from 
1947Q2 to 2024Q2.
</p>
<dl>
<dt>Date</dt><dd><p>Vector of dates</p>
</dd>
<dt>RGDP</dt><dd><p>US Real GDP series</p>
</dd>
<dt>RGDP_gr</dt><dd><p>log difference of US Real GDP series</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>
</p>


<h3>References</h3>

<p>U.S. Bureau of Economic Analysis, Real Gross Domestic Product [GDPC1], retrieved from FRED, Federal Reserve Bank of St. Louis; <em><a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a></em>, September, 2024.
</p>
<p>Rodriguez-Rondon, Gabriel and Jean-Marie Dufour. 2024. “Monte Carlo Likelihood Ratio Tests for Markov Switching Models.” <em>Unpublished manuscript</em>.
</p>

<hr>
<h2 id='VARmdl'>Vector autoregressive model</h2><span id='topic+VARmdl'></span>

<h3>Description</h3>

<p>This function estimates a vector autoregresive model with <code>p</code> lags. This can be used for the null hypothesis of a linear model against an alternative hypothesis of a Markov switching vector autoregressive model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARmdl(Y, p, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VARmdl_+3A_y">Y</code></td>
<td>
<p>a <code>(T x q)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="VARmdl_+3A_p">p</code></td>
<td>
<p>integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="VARmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>VARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x q)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p*q + const)</code> matrix of lagged observations with a leading column of <code>1</code>s if <code>const=TRUE</code> or not if <code>const=FALSE</code>.
</p>
</li>
<li><p> x: a <code>(T-p x p*q)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T-p x q)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T-p x q)</code> matrix of residuals.
</p>
</li>
<li><p> mu: a <code>(1 x q)</code> vector of estimated means of each process.
</p>
</li>
<li><p> beta: a <code>((1 + p) x q)</code> matrix of estimated coefficients. .
</p>
</li>
<li><p> intercept: estimate of intercepts.
</p>
</li>
<li><p> phi: a <code>(q x p*q)</code> matrix of estimated autoregressive coefficients.
</p>
</li>
<li><p> Fmat: Companion matrix containing autoregressive coefficients.
</p>
</li>
<li><p> stdev: a <code>(q x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li><p> sigma: a <code>(q x q)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(t(phi))</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_phi_ind: vector indicating location of autoregressive coefficients with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations after lag transformation (i.e., <code>n = T-p</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes. This is always <code>1</code> in <code>VARmdl</code>.
</p>
</li>
<li><p> Fmat: matrix from companion form. Used to determine is process is stationary.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MSVARmdl">MSVARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ----- Bivariate VAR(1) process ----- #
set.seed(1234)
# Define DGP of VAR process
mdl_var &lt;- list(n     = 1000, 
                p     = 1,
                q     = 2,
                mu    = c(5,-2),
                sigma = rbind(c(5.0, 1.5),
                              c(1.5, 1.0)),
                phi   = rbind(c(0.50, 0.30),
                              c(0.20, 0.70)))

# Simulate process using simuVAR() function
y_simu &lt;- simuVAR(mdl_var)

# Set options for model estimation
control &lt;- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_var_mdl &lt;- VARmdl(y_simu$y, p = 2, control = control)
summary(y_var_mdl)
</code></pre>

<hr>
<h2 id='VARXmdl'>Vector X autoregressive model</h2><span id='topic+VARXmdl'></span>

<h3>Description</h3>

<p>This function estimates a vector autoregresive model with <code>p</code> lags. This can be used for the null hypothesis of a linear model against an alternative hypothesis of a Markov switching vector autoregressive model with <code>k</code> regimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARXmdl(Y, p, Z, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VARXmdl_+3A_y">Y</code></td>
<td>
<p>a <code>(T x q)</code> matrix of observations.</p>
</td></tr>
<tr><td><code id="VARXmdl_+3A_p">p</code></td>
<td>
<p>integer determining the number of autoregressive lags.</p>
</td></tr>
<tr><td><code id="VARXmdl_+3A_z">Z</code></td>
<td>
<p>a <code>(T x qz)</code> matrix of exogenous regressors.</p>
</td></tr>
<tr><td><code id="VARXmdl_+3A_control">control</code></td>
<td>
<p>List with model options including:
</p>

<ul>
<li><p> const: Boolean determining whether to estimate model with constant if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li>
<li><p> getSE: Boolean determining whether to compute standard errors of parameters if <code>TRUE</code> or not if <code>FALSE</code>. Default is <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>VARmdl</code> (<code>S3</code> object) with model attributes including:
</p>

<ul>
<li><p> y: a <code>(T-p x q)</code> matrix of observations.
</p>
</li>
<li><p> X: a <code>(T-p x p*q + const)</code> matrix of lagged observations with a leading column of <code>1</code>s if <code>const=TRUE</code> or not if <code>const=FALSE</code>.
</p>
</li>
<li><p> x: a <code>(T-p x p*q)</code> matrix of lagged observations.
</p>
</li>
<li><p> fitted: a <code>(T-p x q)</code> matrix of fitted values.
</p>
</li>
<li><p> resid: a <code>(T-p x q)</code> matrix of residuals.
</p>
</li>
<li><p> mu: a <code>(1 x q)</code> vector of estimated means of each process.
</p>
</li>
<li><p> beta: a <code>((1 + p + qz) x q)</code> matrix of estimated coefficients. 
</p>
</li>
<li><p> betaZ: a <code>(qz x q)</code> matrix of estimated exogenous regressor coefficients.
</p>
</li>
<li><p> intercept: estimate of intercepts.
</p>
</li>
<li><p> phi: a <code>(q x p*q)</code> matrix of estimated autoregressive coefficients.
</p>
</li>
<li><p> Fmat: Companion matrix containing autoregressive coefficients.
</p>
</li>
<li><p> stdev: a <code>(q x 1)</code> vector of estimated standard deviation of each process.
</p>
</li>
<li><p> sigma: a <code>(q x q)</code> estimated covariance matrix.
</p>
</li>
<li><p> theta: vector containing: <code>mu</code>, <code>vech(sigma)</code>, and <code>vec(t(phi))</code>.
</p>
</li>
<li><p> theta_mu_ind: vector indicating location of mean with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_sig_ind: vector indicating location of variance and covariances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_var_ind: vector indicating location of variances with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> theta_phi_ind: vector indicating location of autoregressive coefficients with <code>1</code> and <code>0</code> otherwise.
</p>
</li>
<li><p> stationary: Boolean indicating if process is stationary if <code>TRUE</code> or non-stationary if <code>FALSE</code>.
</p>
</li>
<li><p> n: number of observations after lag transformation (i.e., <code>n = T-p</code>).
</p>
</li>
<li><p> p: number of autoregressive lags.
</p>
</li>
<li><p> q: number of series.
</p>
</li>
<li><p> k: number of regimes. This is always <code>1</code> in <code>VARmdl</code>.
</p>
</li>
<li><p> Fmat: matrix from companion form. Used to determine is process is stationary.
</p>
</li>
<li><p> control: List with model options used.
</p>
</li>
<li><p> logLike: log-likelihood.
</p>
</li>
<li><p> AIC: Akaike information criterion.
</p>
</li>
<li><p> BIC: Bayesian (Schwarz) information criterion.
</p>
</li>
<li><p> Hess: Hessian matrix. Approximated using <code><a href="numDeriv.html#topic+hessian">hessian</a></code> and only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> info_mat: Information matrix. Computed as the inverse of <code>-Hess</code>. If matrix is not PD then nearest PD matrix is obtained using <code><a href="pracma.html#topic+nearest_spd">nearest_spd</a></code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> nearPD_used: Boolean determining whether <code>nearPD</code> function was used on <code>info_mat</code> if <code>TRUE</code> or not if <code>FALSE</code>. Only returned if <code>getSE=TRUE</code>.
</p>
</li>
<li><p> theta_se: standard errors of parameters in <code>theta</code>.  Only returned if <code>getSE=TRUE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MSVARmdl">MSVARmdl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ----- Bivariate VAR(1) process ----- #
set.seed(1234)
# Define DGP of VAR process
mdl_var &lt;- list(n     = 1000, 
                p     = 1,
                q     = 2,
                mu    = c(5,-2),
                sigma = rbind(c(5.0, 1.5),
                              c(1.5, 1.0)),
                phi   = rbind(c(0.50, 0.30),
                              c(0.20, 0.70)))

# Simulate process using simuVAR() function
y_simu &lt;- simuVAR(mdl_var)

# Set options for model estimation
control &lt;- list(const  = TRUE, 
                getSE  = TRUE)

# Estimate model
y_var_mdl &lt;- VARmdl(y_simu$y, p = 2, control = control)
summary(y_var_mdl)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
