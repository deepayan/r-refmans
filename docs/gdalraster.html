<!DOCTYPE html><html><head><title>Help for package gdalraster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gdalraster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gdalraster-package'><p>Bindings to the GDAL Raster API</p></a></li>
<li><a href='#addFilesInZip'><p>Create/append to a potentially Seek-Optimized ZIP file (SOZip)</p></a></li>
<li><a href='#apply_geotransform'><p>Apply geotransform (raster column/row to geospatial x/y)</p></a></li>
<li><a href='#bandCopyWholeRaster'><p>Copy a whole raster band efficiently</p></a></li>
<li><a href='#bbox_from_wkt'><p>Get the bounding box of a geometry specified in OGC WKT format</p></a></li>
<li><a href='#bbox_intersect'><p>Bounding box intersection / union</p></a></li>
<li><a href='#bbox_to_wkt'><p>Convert a bounding box to POLYGON in OGC WKT format</p></a></li>
<li><a href='#bbox_transform'><p>Transform a bounding box to a different projection</p></a></li>
<li><a href='#buildRAT'><p>Build a GDAL Raster Attribute Table with VALUE, COUNT</p></a></li>
<li><a href='#buildVRT'><p>Build a GDAL virtual raster from a list of datasets</p></a></li>
<li><a href='#calc'><p>Raster calculation</p></a></li>
<li><a href='#CmbTable-class'><p>Class for counting unique combinations of integers</p></a></li>
<li><a href='#combine'><p>Raster overlay for unique combinations</p></a></li>
<li><a href='#copyDatasetFiles'><p>Copy the files of a dataset</p></a></li>
<li><a href='#create'><p>Create a new uninitialized raster</p></a></li>
<li><a href='#createColorRamp'><p>Create a color ramp</p></a></li>
<li><a href='#createCopy'><p>Create a copy of a raster</p></a></li>
<li><a href='#DEFAULT_DEM_PROC'><p>List of default DEM processing options</p></a></li>
<li><a href='#DEFAULT_NODATA'><p>List of default nodata values by raster data type</p></a></li>
<li><a href='#deleteDataset'><p>Delete named dataset</p></a></li>
<li><a href='#dem_proc'><p>GDAL DEM processing</p></a></li>
<li><a href='#displayRAT'><p>Display a GDAL Raster Attribute Table</p></a></li>
<li><a href='#dump_open_datasets'><p>Report open datasets</p></a></li>
<li><a href='#epsg_to_wkt'><p>Convert spatial reference from EPSG code to OGC Well Known Text</p></a></li>
<li><a href='#fillNodata'><p>Fill selected pixels by interpolation from surrounding areas</p></a></li>
<li><a href='#footprint'><p>Compute footprint of a raster</p></a></li>
<li><a href='#g_area'><p>Compute the area of a geometry</p></a></li>
<li><a href='#g_binary_op'><p>Binary operations on WKT geometries</p></a></li>
<li><a href='#g_binary_pred'><p>Geometry binary predicates operating on WKT</p></a></li>
<li><a href='#g_buffer'><p>Compute buffer of a WKT geometry</p></a></li>
<li><a href='#g_centroid'><p>Compute the centroid of a geometry</p></a></li>
<li><a href='#g_distance'><p>Compute the distance between two geometries</p></a></li>
<li><a href='#g_is_empty'><p>Test if a geometry is empty</p></a></li>
<li><a href='#g_is_valid'><p>Test if a geometry is valid</p></a></li>
<li><a href='#g_length'><p>Compute the length of a geometry</p></a></li>
<li><a href='#g_name'><p>Extract the geometry type name from a WKT geometry</p></a></li>
<li><a href='#g_transform'><p>Apply a coordinate transformation to a WKT geometry</p></a></li>
<li><a href='#gdal_formats'><p>Retrieve information on GDAL format drivers for raster and vector</p></a></li>
<li><a href='#gdal_version'><p>Get GDAL version</p></a></li>
<li><a href='#GDALRaster-class'><p>Class encapsulating a raster dataset and associated band objects</p></a></li>
<li><a href='#geos_version'><p>Get GEOS version</p></a></li>
<li><a href='#get_cache_used'><p>Get the size of memory in use by the GDAL block cache</p></a></li>
<li><a href='#get_config_option'><p>Get GDAL configuration option</p></a></li>
<li><a href='#get_num_cpus'><p>Get the number of processors detected by GDAL</p></a></li>
<li><a href='#get_pixel_line'><p>Raster pixel/line from geospatial x,y coordinates</p></a></li>
<li><a href='#get_usable_physical_ram'><p>Get usable physical RAM reported by GDAL</p></a></li>
<li><a href='#getCreationOptions'><p>Return the list of creation options of a GDAL driver</p></a></li>
<li><a href='#has_geos'><p>Is GEOS available?</p></a></li>
<li><a href='#has_spatialite'><p>Is SpatiaLite available?</p></a></li>
<li><a href='#http_enabled'><p>Check if GDAL CPLHTTP services can be useful (libcurl)</p></a></li>
<li><a href='#inv_geotransform'><p>Invert geotransform</p></a></li>
<li><a href='#inv_project'><p>Inverse project geospatial x/y coordinates to longitude/latitude</p></a></li>
<li><a href='#ogr_define'><p>OGR feature class definition for vector data</p></a></li>
<li><a href='#ogr_manage'><p>Utility functions for managing vector data sources</p></a></li>
<li><a href='#ogr2ogr'><p>Convert vector data between different formats</p></a></li>
<li><a href='#ogrinfo'><p>Retrieve information about a vector data source</p></a></li>
<li><a href='#plot_raster'><p>Display raster data</p></a></li>
<li><a href='#polygonize'><p>Create a polygon feature layer from raster data</p></a></li>
<li><a href='#pop_error_handler'><p>Pop error handler off stack</p></a></li>
<li><a href='#proj_networking'><p>Check, enable or disable PROJ networking capabilities</p></a></li>
<li><a href='#proj_search_paths'><p>Get or set search path(s) for PROJ resource files</p></a></li>
<li><a href='#proj_version'><p>Get PROJ version</p></a></li>
<li><a href='#push_error_handler'><p>Push a new GDAL CPLError handler</p></a></li>
<li><a href='#rasterFromRaster'><p>Create a raster from an existing raster as template</p></a></li>
<li><a href='#rasterize'><p>Burn vector geometries into a raster</p></a></li>
<li><a href='#rasterToVRT'><p>Create a GDAL virtual raster derived from one source dataset</p></a></li>
<li><a href='#read_ds'><p>Convenience wrapper for <code>GDALRaster$read()</code></p></a></li>
<li><a href='#renameDataset'><p>Rename a dataset</p></a></li>
<li><a href='#RunningStats-class'><p>Class to calculate mean and variance in one pass</p></a></li>
<li><a href='#set_config_option'><p>Set GDAL configuration option</p></a></li>
<li><a href='#sieveFilter'><p>Remove small raster polygons</p></a></li>
<li><a href='#srs_is_geographic'><p>Check if WKT definition is a geographic coordinate system</p></a></li>
<li><a href='#srs_is_projected'><p>Check if WKT definition is a projected coordinate system</p></a></li>
<li><a href='#srs_is_same'><p>Do these two spatial references describe the same system?</p></a></li>
<li><a href='#srs_to_wkt'><p>Convert various spatial reference formats to Well Known Text</p></a></li>
<li><a href='#transform_xy'><p>Transform geospatial x/y coordinates</p></a></li>
<li><a href='#translate'><p>Convert raster data between different formats</p></a></li>
<li><a href='#vsi_clear_path_options'><p>Clear path specific configuration options</p></a></li>
<li><a href='#vsi_constants'><p>Constants for VSIFile$seek()</p></a></li>
<li><a href='#vsi_copy_file'><p>Copy a source file to a target filename</p></a></li>
<li><a href='#vsi_curl_clear_cache'><p>Clean cache associated with /vsicurl/ and related file systems</p></a></li>
<li><a href='#vsi_get_disk_free_space'><p>Return free disk space available on the filesystem</p></a></li>
<li><a href='#vsi_get_file_metadata'><p>Get metadata on files</p></a></li>
<li><a href='#vsi_get_fs_options'><p>Return the list of options associated with a virtual file system handler</p></a></li>
<li><a href='#vsi_get_fs_prefixes'><p>Return the list of virtual file system handlers currently registered</p></a></li>
<li><a href='#vsi_mkdir'><p>Create a directory</p></a></li>
<li><a href='#vsi_read_dir'><p>Read names in a directory</p></a></li>
<li><a href='#vsi_rename'><p>Rename a file</p></a></li>
<li><a href='#vsi_rmdir'><p>Delete a directory</p></a></li>
<li><a href='#vsi_set_path_option'><p>Set a path specific option for a given path prefix</p></a></li>
<li><a href='#vsi_stat'><p>Get filesystem object info</p></a></li>
<li><a href='#vsi_supports_rnd_write'><p>Return whether the filesystem supports random write</p></a></li>
<li><a href='#vsi_supports_seq_write'><p>Return whether the filesystem supports sequential write</p></a></li>
<li><a href='#vsi_sync'><p>Synchronize a source file/directory with a target file/directory</p></a></li>
<li><a href='#vsi_unlink'><p>Delete a file</p></a></li>
<li><a href='#vsi_unlink_batch'><p>Delete several files in a batch</p></a></li>
<li><a href='#VSIFile-class'><p>Class wrapping the GDAL VSIVirtualHandle API for binary file I/O</p></a></li>
<li><a href='#warp'><p>Raster reprojection and mosaicing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bindings to the 'Geospatial Data Abstraction Library' Raster API</td>
</tr>
<tr>
<td>Version:</td>
<td>1.11.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to the Raster API of the 'Geospatial Data Abstraction
    Library' ('GDAL', <a href="https://gdal.org">https://gdal.org</a>). Bindings are implemented in an
    exposed C++ class encapsulating a 'GDALDataset' and its raster band
    objects, along with several stand-alone functions. These support manual
    creation of uninitialized datasets, creation from existing raster as
    template, read/set dataset parameters, low level I/O, color tables, raster
    attribute tables, virtual raster (VRT), and 'gdalwarp' wrapper for
    reprojection and mosaicing. Includes 'GDAL' algorithms ('dem_proc()',
    'polygonize()', 'rasterize()', etc.), and functions for coordinate
    transformation and spatial reference systems. Calling signatures resemble
    the native C, C++ and Python APIs provided by the 'GDAL' project. Includes
    raster 'calc()' to evaluate a given R expression on a layer or stack of
    layers, with pixel x/y available as variables in the expression; and raster
    'combine()' to identify and count unique pixel combinations across multiple
    input layers, with optional output of the pixel-level combination IDs.
    Provides raster display using base 'graphics'. Bindings to a subset of the
    'OGR' API are also included for managing vector data sources. Bindings to a
    subset of the Virtual Systems Interface ('VSI') are also included to support
    operations on 'GDAL' virtual file systems. These are general utility
    functions that abstract file system operations on URLs, cloud storage
    services, 'Zip'/'GZip'/'7z'/'RAR' archives, and in-memory files.
    'gdalraster' may be useful in applications that need scalable, low-level
    I/O, or prefer a direct 'GDAL' API.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See file inst/COPYRIGHTS for details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://usdaforestservice.github.io/gdalraster/">https://usdaforestservice.github.io/gdalraster/</a>,
<a href="https://github.com/USDAForestService/gdalraster">https://github.com/USDAForestService/gdalraster</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USDAForestService/gdalraster/issues">https://github.com/USDAForestService/gdalraster/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bit64, graphics, grDevices, methods, Rcpp (&ge; 1.0.7), stats,
tools, utils, xml2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppInt64</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gt, knitr, rmarkdown, scales, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 3.1.0, built against GEOS), PROJ, libxml2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 18:20:44 UTC; ctoney</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Toney [aut, cre] (R interface/additional functionality),
  Michael D. Sumner [ctb],
  Frank Warmerdam [ctb, cph] (GDAL API documentation; src/progress_r.cpp
    from gdal/port/cpl_progress.cpp),
  Even Rouault [ctb, cph] (GDAL API documentation),
  Marius Appel [ctb, cph] (configure.ac based on
    https://github.com/appelmar/gdalcubes),
  Daniel James [ctb, cph] (Boost combine hashes method in
    src/cmb_table.h),
  Peter Dimov [ctb, cph] (Boost combine hashes method in src/cmb_table.h)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Toney &lt;chris.toney@usda.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 21:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='gdalraster-package'>Bindings to the GDAL Raster API
</h2><span id='topic+gdalraster'></span><span id='topic+gdalraster-package'></span>

<h3>Description</h3>

<p><code>gdalraster</code> is an interface to the Geospatial Data Abstraction
Library (GDAL) for low level raster I/O. Calling signatures resemble those
of the native C, C++ and Python APIs provided by the GDAL project.
See <a href="https://gdal.org/api/">https://gdal.org/api/</a> for details of the GDAL Raster API.
</p>


<h3>Details</h3>

<p>Core functionality is contained in class <code>GDALRaster</code> and several
related stand-alone functions:
</p>

<ul>
<li> <p><code><a href="#topic+GDALRaster-class">GDALRaster-class</a></code> is an exposed C++ class that allows
opening a raster dataset and calling methods on the <code>GDALDataset</code>,
<code>GDALDriver</code> and <code>GDALRasterBand</code> objects in the underlying API
(e.g., get/set parameters, read/write pixel data).
</p>
</li>
<li><p> raster creation: <code><a href="#topic+create">create()</a></code>,
<code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+rasterFromRaster">rasterFromRaster()</a></code>,
<code><a href="#topic+translate">translate()</a></code>,
<code><a href="#topic+getCreationOptions">getCreationOptions()</a></code>
</p>
</li>
<li><p> virtual raster: <code><a href="#topic+buildVRT">buildVRT()</a></code>,
<code><a href="#topic+rasterToVRT">rasterToVRT()</a></code>
</p>
</li>
<li><p> reproject/resample/crop/mosaic: <code><a href="#topic+warp">warp()</a></code>
</p>
</li>
<li><p> algorithms: <code><a href="#topic+dem_proc">dem_proc()</a></code>,
<code><a href="#topic+fillNodata">fillNodata()</a></code>,
<code><a href="#topic+footprint">footprint()</a></code>,
<code><a href="#topic+polygonize">polygonize()</a></code>,
<code><a href="#topic+rasterize">rasterize()</a></code>,
<code><a href="#topic+sieveFilter">sieveFilter()</a></code>,
<code><a href="#topic+GDALRaster">GDALRaster$getChecksum()</a></code>
</p>
</li>
<li><p> raster attribute tables: <code><a href="#topic+buildRAT">buildRAT()</a></code>,
<code><a href="#topic+displayRAT">displayRAT()</a></code>,
<code><a href="#topic+GDALRaster">GDALRaster$getDefaultRAT()</a></code>,
<code><a href="#topic+GDALRaster">GDALRaster$setDefaultRAT()</a></code>
</p>
</li>
<li><p> geotransform conversion:
<code><a href="#topic+apply_geotransform">apply_geotransform()</a></code>,
<code><a href="#topic+get_pixel_line">get_pixel_line()</a></code>,
<code><a href="#topic+inv_geotransform">inv_geotransform()</a></code>
</p>
</li>
<li><p> coordinate transformation:
<code><a href="#topic+transform_xy">transform_xy()</a></code>,
<code><a href="#topic+inv_project">inv_project()</a></code>
</p>
</li>
<li><p> spatial reference convenience functions:
<code><a href="#topic+epsg_to_wkt">epsg_to_wkt()</a></code>,
<code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>,<br />
<code><a href="#topic+srs_is_geographic">srs_is_geographic()</a></code>,
<code><a href="#topic+srs_is_projected">srs_is_projected()</a></code>,
<code><a href="#topic+srs_is_same">srs_is_same()</a></code>
</p>
</li>
<li><p> geometry convenience functions:
<code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>,
<code><a href="#topic+bbox_to_wkt">bbox_to_wkt()</a></code>,
<code><a href="#topic+bbox_intersect">bbox_intersect()</a></code>,
<code><a href="#topic+bbox_union">bbox_union()</a></code>,
<code><a href="#topic+bbox_transform">bbox_transform()</a></code>,
<code><a href="#topic+g_area">g_area()</a></code>,
<code><a href="#topic+g_buffer">g_buffer()</a></code>,
<code><a href="#topic+g_centroid">g_centroid()</a></code>,
<code><a href="#topic+g_contains">g_contains()</a></code>,
<code><a href="#topic+g_crosses">g_crosses()</a></code>,
<code><a href="#topic+g_difference">g_difference()</a></code>,
<code><a href="#topic+g_disjoint">g_disjoint()</a></code>,
<code><a href="#topic+g_distance">g_distance()</a></code>,
<code><a href="#topic+g_equals">g_equals()</a></code>,
<code><a href="#topic+g_intersection">g_intersection()</a></code>,
<code><a href="#topic+g_intersects">g_intersects()</a></code>,
<code><a href="#topic+g_is_empty">g_is_empty()</a></code>,
<code><a href="#topic+g_is_valid">g_is_valid()</a></code>,
<code><a href="#topic+g_length">g_length()</a></code>,
<code><a href="#topic+g_name">g_name()</a></code>,
<code><a href="#topic+g_overlaps">g_overlaps()</a></code>,
<code><a href="#topic+g_sym_difference">g_sym_difference()</a></code>,
<code><a href="#topic+g_touches">g_touches()</a></code>,
<code><a href="#topic+g_transform">g_transform()</a></code>,
<code><a href="#topic+g_union">g_union()</a></code>,
<code><a href="#topic+g_within">g_within()</a></code>,
<code><a href="#topic+geos_version">geos_version()</a></code>
</p>
</li>
<li><p> data management: <code><a href="#topic+addFilesInZip">addFilesInZip()</a></code>,
<code><a href="#topic+copyDatasetFiles">copyDatasetFiles()</a></code>,
<code><a href="#topic+deleteDataset">deleteDataset()</a></code>,<br />
<code><a href="#topic+renameDataset">renameDataset()</a></code>,
<code><a href="#topic+bandCopyWholeRaster">bandCopyWholeRaster()</a></code>
</p>
</li>
<li><p> OGR vector utilities:
<code><a href="#topic+ogr2ogr">ogr2ogr()</a></code>,
<code><a href="#topic+ogrinfo">ogrinfo()</a></code>,
<code><a href="#topic+ogr_manage">ogr_manage</a></code>,
<code><a href="#topic+ogr_define">ogr_define</a></code>
</p>
</li>
<li><p> virtual file systems:
<code><a href="#topic+VSIFile-class">VSIFile</a></code>,
<code><a href="#topic+vsi_clear_path_options">vsi_clear_path_options()</a></code>,
<code><a href="#topic+vsi_copy_file">vsi_copy_file()</a></code>,
<code><a href="#topic+vsi_curl_clear_cache">vsi_curl_clear_cache()</a></code>,
<code><a href="#topic+vsi_get_disk_free_space">vsi_get_disk_free_space()</a></code>,
<code><a href="#topic+vsi_get_file_metadata">vsi_get_file_metadata()</a></code>,
<code><a href="#topic+vsi_get_fs_options">vsi_get_fs_options()</a></code>,
<code><a href="#topic+vsi_get_fs_prefixes">vsi_get_fs_prefixes()</a></code>,
<code><a href="#topic+vsi_mkdir">vsi_mkdir()</a></code>,
<code><a href="#topic+vsi_read_dir">vsi_read_dir()</a></code>,
<code><a href="#topic+vsi_rename">vsi_rename()</a></code>,
<code><a href="#topic+vsi_rmdir">vsi_rmdir()</a></code>,
<code><a href="#topic+vsi_set_path_option">vsi_set_path_option()</a></code>,
<code><a href="#topic+vsi_stat">vsi_stat()</a></code>,
<code><a href="#topic+vsi_supports_rnd_write">vsi_supports_rnd_write()</a></code>,
<code><a href="#topic+vsi_supports_seq_write">vsi_supports_seq_write()</a></code>,
<code><a href="#topic+vsi_sync">vsi_sync()</a></code>,
<code><a href="#topic+vsi_unlink">vsi_unlink()</a></code>,
<code><a href="#topic+vsi_unlink_batch">vsi_unlink_batch()</a></code>
</p>
</li>
<li><p> GDAL configuration:
<code><a href="#topic+gdal_version">gdal_version()</a></code>,
<code><a href="#topic+gdal_formats">gdal_formats()</a></code>,
<code><a href="#topic+get_cache_used">get_cache_used()</a></code>,
<code><a href="#topic+get_config_option">get_config_option()</a></code>,
<code><a href="#topic+set_config_option">set_config_option()</a></code>,
<code><a href="#topic+get_num_cpus">get_num_cpus()</a></code>,
<code><a href="#topic+get_usable_physical_ram">get_usable_physical_ram()</a></code>,
<code><a href="#topic+has_spatialite">has_spatialite()</a></code>,
<code><a href="#topic+http_enabled">http_enabled()</a></code>,
<code><a href="#topic+push_error_handler">push_error_handler()</a></code>,
<code><a href="#topic+pop_error_handler">pop_error_handler()</a></code>,
<code><a href="#topic+dump_open_datasets">dump_open_datasets()</a></code>
</p>
</li>
<li><p> PROJ configuration:
<code><a href="#topic+proj_version">proj_version()</a></code>,
<code><a href="#topic+proj_search_paths">proj_search_paths()</a></code>,
<code><a href="#topic+proj_networking">proj_networking()</a></code>
</p>
</li></ul>

<p>Additional functionality includes:
</p>

<ul>
<li> <p><code><a href="#topic+RunningStats-class">RunningStats-class</a></code> calculates mean and variance in one
pass. The min, max, sum, and count are also tracked (efficient summary
statistics on data streams).
</p>
</li>
<li> <p><code><a href="#topic+CmbTable-class">CmbTable-class</a></code> implements a hash table for counting
unique combinations of integer values.
</p>
</li>
<li> <p><code><a href="#topic+combine">combine()</a></code> overlays multiple rasters so that a
unique ID is assigned to each unique combination of input values. Pixel
counts for each unique combination are obtained, and combination IDs are
optionally written to an output raster.
</p>
</li>
<li> <p><code><a href="#topic+calc">calc()</a></code> evaluates an R expression for each pixel in
a raster layer or stack of layers. Individual pixel coordinates are available
as variables in the R expression, as either x/y in the raster projected
coordinate system or inverse projected longitude/latitude.
</p>
</li>
<li> <p><code><a href="#topic+plot_raster">plot_raster()</a></code> displays raster data using
base R <code>graphics</code>. Supports single-band grayscale, RGB, color tables and
color map functions (e.g., color ramp).
</p>
</li></ul>



<h3>Note</h3>

<p>Documentation for <code>GDALRaster-class</code> and several wrapper functions
borrows from the GDAL API documentation, (c) 1998-2024, Frank Warmerdam,
Even Rouault, and others, <a href="https://gdal.org/license.html">MIT license</a>.
</p>
<p>Sample datasets included with the package are used in examples throughout
the documentation. The sample data include
<a href="https://landfire.gov/">LANDFIRE</a> raster layers describing terrain,
vegetation and wildland fuels (LF 2020 version),
Landsat C2 Analysis Ready Data from
<a href="https://earthexplorer.usgs.gov/">USGS Earth Explorer</a>, and
Monitoring Trends in Burn Severity (<a href="https://www.mtbs.gov/">MTBS</a>)
fire perimeters from 1984-2022. Metadata for the sample datasets are in
inst/extdata/metadata.zip.
</p>
<p><code>system.file()</code> is used in the examples to access the sample datasets.
This enables the code to run regardless of where R is installed. Users will
normally give file names as a regular full path or relative to the current
working directory.
</p>


<h3>Author(s)</h3>

<p>GDAL is by: Frank Warmerdam, Even Rouault and others<br />
(see <a href="https://github.com/OSGeo/gdal/graphs/contributors">https://github.com/OSGeo/gdal/graphs/contributors</a>)
</p>
<p>R interface/additional functionality: Chris Toney
</p>
<p>Maintainer: Chris Toney &lt;chris.toney at usda.gov&gt;
</p>


<h3>See Also</h3>

<p>GDAL Raster Data Model:<br />
<a href="https://gdal.org/user/raster_data_model.html">https://gdal.org/user/raster_data_model.html</a>
</p>
<p>Raster format descriptions:<br />
<a href="https://gdal.org/drivers/raster/index.html">https://gdal.org/drivers/raster/index.html</a>
</p>
<p>Geotransform tutorial:<br />
<a href="https://gdal.org/tutorials/geotransforms_tut.html">https://gdal.org/tutorials/geotransforms_tut.html</a>
</p>
<p>GDAL Virtual File Systems:<br />
<a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>
</p>

<hr>
<h2 id='addFilesInZip'>Create/append to a potentially Seek-Optimized ZIP file (SOZip)</h2><span id='topic+addFilesInZip'></span>

<h3>Description</h3>

<p><code>addFilesInZip()</code> will create new or open existing ZIP file, and
add one or more compressed files potentially using the seek optimization
extension. This function is basically a wrapper for <code>CPLAddFileInZip()</code>
in the GDAL Common Portability Library, but optionally creates a new ZIP
file first (with <code>CPLCreateZip()</code>). It provides a subset of functionality
in the GDAL <code>sozip</code> command-line utility
(<a href="https://gdal.org/programs/sozip.html">https://gdal.org/programs/sozip.html</a>). Requires GDAL &gt;= 3.7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addFilesInZip(
  zip_file,
  add_files,
  overwrite = FALSE,
  full_paths = TRUE,
  sozip_enabled = NULL,
  sozip_chunk_size = NULL,
  sozip_min_file_size = NULL,
  num_threads = NULL,
  content_type = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addFilesInZip_+3A_zip_file">zip_file</code></td>
<td>
<p>Filename of the ZIP file. Will be created if it does not
exist or if <code>overwrite = TRUE</code>. Otherwise will append to an existing file.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_add_files">add_files</code></td>
<td>
<p>Character vector of one or more input filenames to add.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical scalar. Overwrite the target zip file if it already
exists.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_full_paths">full_paths</code></td>
<td>
<p>Logical scalar. By default, the full path will be stored
(relative to the current directory). <code>FALSE</code> to store just the name of a
saved file (drop the path).</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_sozip_enabled">sozip_enabled</code></td>
<td>
<p>String. Whether to generate a SOZip index for the file.
One of <code>"AUTO"</code> (the default), <code>"YES"</code> or <code>"NO"</code> (see Details).</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_sozip_chunk_size">sozip_chunk_size</code></td>
<td>
<p>The chunk size for a seek-optimized file.
Defaults to 32768 bytes. The value is specified in bytes, or K and M
suffix can be used respectively to specify a value in kilo-bytes or
mega-bytes. Will be coerced to string.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_sozip_min_file_size">sozip_min_file_size</code></td>
<td>
<p>The minimum file size to decide if a file
should be seek-optimized, in <code>sozip_enabled="AUTO"</code> mode. Defaults to
1 MB byte. The value is specified in bytes, or K, M or G suffix can be used
respectively to specify a value in kilo-bytes, mega-bytes or giga-bytes.
Will be coerced to string.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads used for SOZip generation. Defaults to
<code>"ALL_CPUS"</code> or specify an integer value (coerced to string).</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_content_type">content_type</code></td>
<td>
<p>String Content-Type value for the file. This is stored
as a key-value pair in the extra field extension 'KV' (0x564b) dedicated to
storing key-value pair metadata.</p>
</td></tr>
<tr><td><code id="addFilesInZip_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> for quiet mode, no progress messages
emitted. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Seek-Optimized ZIP file (SOZip) contains one or more compressed files
organized and annotated such that a SOZip-aware reader can perform very
fast random access within the .zip file
(see <a href="https://github.com/sozip/sozip-spec">https://github.com/sozip/sozip-spec</a>).
Large compressed files can be accessed directly from SOZip without prior
decompression. The .zip file is otherwise fully backward compatible.
</p>
<p>If <code>sozip_enabled="AUTO"</code> (the default), a file is seek-optimized only if
its size is above the values of <code>sozip_min_file_size</code> (default 1 MB) and
<code>sozip_chunk_size</code> (default <code>32768</code>).
In <code>"YES"</code> mode, all input files will be seek-optimized. In <code>"NO"</code> mode, no
input files will be seek-optimized. The default can be changed with the
<code>CPL_SOZIP_ENABLED</code> configuration option.
</p>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p>The <code>GDAL_NUM_THREADS</code> configuration option can be set to <code>ALL_CPUS</code> or an
integer value to specify the number of threads to use for SOZip-compressed
files (see <code><a href="#topic+set_config_option">set_config_option()</a></code>).
</p>
<p>SOZip can be validated with:
</p>
<div class="sourceCode"><pre>vsi_get_file_metadata(zip_file, domain="ZIP")
</pre></div>
<p>where <code>zip_file</code> uses the /vsizip/ prefix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_get_file_metadata">vsi_get_file_metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
zip_file &lt;- file.path(tempdir(), "storml_lcp.zip")

# Requires GDAL &gt;= 3.7
if (as.integer(gdal_version()[2]) &gt;= 3070000) {
  addFilesInZip(zip_file, lcp_file, full_paths=FALSE, sozip_enabled="YES",
                num_threads=1)

  print("Files in zip archive:")
  print(unzip(zip_file, list=TRUE))

  # Open with GDAL using Virtual File System handler '/vsizip/'
  # see: https://gdal.org/user/virtual_file_systems.html#vsizip-zip-archives
  lcp_in_zip &lt;- file.path("/vsizip", zip_file, "storm_lake.lcp")
  print("SOZip metadata:")
  print(vsi_get_file_metadata(lcp_in_zip, domain="ZIP"))

  ds &lt;- new(GDALRaster, lcp_in_zip)
  ds$info()
  ds$close()

  vsi_unlink(zip_file)
}
</code></pre>

<hr>
<h2 id='apply_geotransform'>Apply geotransform (raster column/row to geospatial x/y)</h2><span id='topic+apply_geotransform'></span>

<h3>Description</h3>

<p><code>apply_geotransform()</code> applies geotransform coefficients to raster
coordinates in pixel/line space (column/row), converting into
georeferenced (x/y) coordinates. Wrapper of <code>GDALApplyGeoTransform()</code> in
the GDAL API, operating on matrix input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_geotransform(col_row, gt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_geotransform_+3A_col_row">col_row</code></td>
<td>
<p>Numeric matrix of raster column/row (pixel/line) coordinates
(or two-column data frame that will be coerced to numeric matrix).</p>
</td></tr>
<tr><td><code id="apply_geotransform_+3A_gt">gt</code></td>
<td>
<p>Either a numeric vector of length six containing the affine
geotransform for the raster, or an object of class <code>GDALRaster</code> from
which the geotransform will be obtained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix of geospatial x/y coordinates.
</p>


<h3>Note</h3>

<p>Bounds checking on the input coordinates is done if <code>gt</code> is obtained from an
object of class <code>GDALRaster</code>. See Note for <code><a href="#topic+get_pixel_line">get_pixel_line()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$getGeoTransform()</a></code>, <code><a href="#topic+get_pixel_line">get_pixel_line()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raster_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, raster_file)

# compute some raster coordinates in column/row space
set.seed(42)
col_coords &lt;- runif(10, min = 0, max = ds$getRasterXSize() - 0.00001)
row_coords &lt;- runif(10, min = 0, max = ds$getRasterYSize() - 0.00001)
col_row &lt;- cbind(col_coords, row_coords)

# convert to geospatial x/y coordinates
gt &lt;- ds$getGeoTransform()
apply_geotransform(col_row, gt)

# or, using the class method
ds$apply_geotransform(col_row)

# bounds checking
col_row &lt;- rbind(col_row, c(ds$getRasterXSize(), ds$getRasterYSize()))
ds$apply_geotransform(col_row)

ds$close()
</code></pre>

<hr>
<h2 id='bandCopyWholeRaster'>Copy a whole raster band efficiently</h2><span id='topic+bandCopyWholeRaster'></span>

<h3>Description</h3>

<p><code>bandCopyWholeRaster()</code> copies the complete raster contents of one band to
another similarly configured band. The source and destination bands must
have the same xsize and ysize. The bands do not have to have the same data
type. It implements efficient copying, in particular &quot;chunking&quot; the copy in
substantial blocks. This is a wrapper for <code>GDALRasterBandCopyWholeRaster()</code>
in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandCopyWholeRaster(
  src_filename,
  src_band,
  dst_filename,
  dst_band,
  options = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandCopyWholeRaster_+3A_src_filename">src_filename</code></td>
<td>
<p>Filename of the source raster.</p>
</td></tr>
<tr><td><code id="bandCopyWholeRaster_+3A_src_band">src_band</code></td>
<td>
<p>Band number in the source raster to be copied.</p>
</td></tr>
<tr><td><code id="bandCopyWholeRaster_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Filename of the destination raster.</p>
</td></tr>
<tr><td><code id="bandCopyWholeRaster_+3A_dst_band">dst_band</code></td>
<td>
<p>Band number in the destination raster to copy into.</p>
</td></tr>
<tr><td><code id="bandCopyWholeRaster_+3A_options">options</code></td>
<td>
<p>Optional list of transfer hints in a vector of <code>"NAME=VALUE"</code>
pairs. The currently supported <code>options</code> are:
</p>

<ul>
<li> <p><code>"COMPRESSED=YES"</code> to force alignment on target dataset block sizes to
achieve best compression.
</p>
</li>
<li> <p><code>"SKIP_HOLES=YES"</code> to skip chunks that contain only empty blocks.
Empty blocks are blocks that are generally not physically present in the
file, and when read through GDAL, contain only pixels whose value is the
nodata value when it is set, or whose value is 0 when the nodata value is
not set. The query is done in an efficient way without reading the actual
pixel values (if implemented by the raster format driver, otherwise will
not be skipped).
</p>
</li></ul>
</td></tr>
<tr><td><code id="bandCopyWholeRaster_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+rasterFromRaster">rasterFromRaster()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## copy Landsat data from a single-band file to a new multi-band image
b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
dst_file &lt;- file.path(tempdir(), "sr_multi.tif")
rasterFromRaster(b5_file, dst_file, nbands=7, init=0)
opt &lt;- c("COMPRESSED=YES", "SKIP_HOLES=YES")
bandCopyWholeRaster(b5_file, 1, dst_file, 5, options=opt)
ds &lt;- new(GDALRaster, dst_file)
ds$getStatistics(band=5, approx_ok=FALSE, force=TRUE)
ds$close()

deleteDataset(dst_file)
</code></pre>

<hr>
<h2 id='bbox_from_wkt'>Get the bounding box of a geometry specified in OGC WKT format</h2><span id='topic+bbox_from_wkt'></span>

<h3>Description</h3>

<p><code>bbox_from_wkt()</code> returns the bounding box of a WKT 2D geometry
(e.g., LINE, POLYGON, MULTIPOLYGON).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_from_wkt(wkt, extend_x = 0, extend_y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_from_wkt_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature 2D geometry.</p>
</td></tr>
<tr><td><code id="bbox_from_wkt_+3A_extend_x">extend_x</code></td>
<td>
<p>Numeric scalar. Distance to extend the output bounding box
in both directions along the x-axis
(results in <code>xmin = bbox[1] - extend_x</code>, <code>xmax = bbox[3] + extend_x</code>).</p>
</td></tr>
<tr><td><code id="bbox_from_wkt_+3A_extend_y">extend_y</code></td>
<td>
<p>Numeric scalar. Distance to extend the output bounding box
in both directions along the y-axis
(results in <code>ymin = bbox[2] - extend_y</code>, <code>ymax = bbox[4] + extend_y</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length four containing the xmin, ymin,
xmax, ymax of the geometry specified by <code>wkt</code> (possibly extended by values
in <code>extend_x</code>, <code>extend_y</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox_to_wkt">bbox_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bnd &lt;- "POLYGON ((324467.3 5104814.2, 323909.4 5104365.4, 323794.2
5103455.8, 324970.7 5102885.8, 326420.0 5103595.3, 326389.6 5104747.5,
325298.1 5104929.4, 325298.1 5104929.4, 324467.3 5104814.2))"
bbox_from_wkt(bnd, 100, 100)
</code></pre>

<hr>
<h2 id='bbox_intersect'>Bounding box intersection / union</h2><span id='topic+bbox_intersect'></span><span id='topic+bbox_union'></span>

<h3>Description</h3>

<p><code>bbox_intersect()</code> returns the bounding box intersection, and
<code>bbox_union()</code> returns the bounding box union, for input of
either raster file names or list of bounding boxes. All of the inputs
must be in the same projected coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_intersect(x, as_wkt = FALSE)

bbox_union(x, as_wkt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_intersect_+3A_x">x</code></td>
<td>
<p>Either a character vector of raster file names, or a list with
each element a bounding box numeric vector (xmin, ymin, xmax, ymax).</p>
</td></tr>
<tr><td><code id="bbox_intersect_+3A_as_wkt">as_wkt</code></td>
<td>
<p>Logical. <code>TRUE</code> to return the bounding box as a polygon
in OGC WKT format, or <code>FALSE</code> to return as a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The intersection (<code>bbox_intersect()</code>) or union (<code>bbox_union()</code>)
of inputs.
If <code>as_wkt = FALSE</code>, a numeric vector of length four containing
xmin, ymin, xmax, ymax. If <code>as_wkt = TRUE</code>, a character string
containing OGC WKT for the bbox as POLYGON.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>, <code><a href="#topic+bbox_to_wkt">bbox_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bbox_list &lt;-list()

elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
bbox_list[[1]] &lt;- ds$bbox()
ds$close()

b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
ds &lt;- new(GDALRaster, b5_file)
bbox_list[[2]] &lt;- ds$bbox()
ds$close()

bnd &lt;- "POLYGON ((324467.3 5104814.2, 323909.4 5104365.4, 323794.2
5103455.8, 324970.7 5102885.8, 326420.0 5103595.3, 326389.6 5104747.5,
325298.1 5104929.4, 325298.1 5104929.4, 324467.3 5104814.2))"
bbox_list[[3]] &lt;- bbox_from_wkt(bnd)

print(bbox_list)
bbox_intersect(bbox_list)
bbox_union(bbox_list)
</code></pre>

<hr>
<h2 id='bbox_to_wkt'>Convert a bounding box to POLYGON in OGC WKT format</h2><span id='topic+bbox_to_wkt'></span>

<h3>Description</h3>

<p><code>bbox_to_wkt()</code> returns a WKT POLYGON string for the given bounding box.
Requires GDAL built with the GEOS library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_to_wkt(bbox, extend_x = 0, extend_y = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_to_wkt_+3A_bbox">bbox</code></td>
<td>
<p>Numeric vector of length four containing xmin, ymin,
xmax, ymax.</p>
</td></tr>
<tr><td><code id="bbox_to_wkt_+3A_extend_x">extend_x</code></td>
<td>
<p>Numeric scalar. Distance in units of <code>bbox</code> to extend the
rectangle in both directions along the x-axis
(results in <code>xmin = bbox[1] - extend_x</code>, <code>xmax = bbox[3] + extend_x</code>).</p>
</td></tr>
<tr><td><code id="bbox_to_wkt_+3A_extend_y">extend_y</code></td>
<td>
<p>Numeric scalar. Distance in units of <code>bbox</code> to extend the
rectangle in both directions along the y-axis
(results in <code>ymin = bbox[2] - extend_y</code>, <code>ymax = bbox[4] + extend_y</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string for an OGC WKT polygon.
<code>NA</code> is returned if GDAL was built without the GEOS library.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>, <code><a href="#topic+g_buffer">g_buffer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file, read_only=TRUE)
bbox_to_wkt(ds$bbox())
ds$close()
</code></pre>

<hr>
<h2 id='bbox_transform'>Transform a bounding box to a different projection</h2><span id='topic+bbox_transform'></span>

<h3>Description</h3>

<p><code>bbox_transform()</code> is a convenience function for:
</p>
<div class="sourceCode"><pre>bbox_to_wkt(bbox) |&gt;
  g_transform(srs_from, srs_to) |&gt;
  bbox_from_wkt()
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_transform(bbox, srs_from, srs_to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_transform_+3A_bbox">bbox</code></td>
<td>
<p>Numeric vector of length four containing a bounding box
(xmin, ymin, xmax, ymax) to transform.</p>
</td></tr>
<tr><td><code id="bbox_transform_+3A_srs_from">srs_from</code></td>
<td>
<p>Character string in OGC WKT format specifying the
spatial reference system for <code>bbox</code>.</p>
</td></tr>
<tr><td><code id="bbox_transform_+3A_srs_to">srs_to</code></td>
<td>
<p>Character string in OGC WKT format specifying the target
spatial reference system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length four containing a transformed bounding box
(xmin, ymin, xmax, ymax).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g_transform">g_transform()</a></code>, <code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>, <code><a href="#topic+bbox_to_wkt">bbox_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
ds$bbox()
bbox_transform(ds$bbox(), ds$getProjection(), epsg_to_wkt(4326))
ds$close()
</code></pre>

<hr>
<h2 id='buildRAT'>Build a GDAL Raster Attribute Table with VALUE, COUNT</h2><span id='topic+buildRAT'></span>

<h3>Description</h3>

<p><code>buildRAT()</code> reads all pixels of an input raster to obtain the set of
unique values and their counts. The result is returned as a data frame
suitable for use with the class method <code>GDALRaster$setDefaultRAT()</code>. The
returned data frame might be further modified before setting as a Raster
Attribute Table in a dataset, for example, by adding columns containing
class names, color values, or other information (see Details).
An optional input data frame containing such attributes may be given, in
which case <code>buildRAT()</code> will attempt to join the additional columns and
automatically assign the appropriate metadata on the output data frame
(i.e., assign R attributes on the data frame and its columns that define
usage in a GDAL Raster Attribute Table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRAT(
  raster,
  band = 1L,
  col_names = c("VALUE", "COUNT"),
  table_type = "athematic",
  na_value = NULL,
  join_df = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRAT_+3A_raster">raster</code></td>
<td>
<p>Either a <code>GDALRaster</code> object, or a character string containing
the file name of a raster dataset to open.</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_band">band</code></td>
<td>
<p>Integer scalar, band number to read (default <code>1L</code>).</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_col_names">col_names</code></td>
<td>
<p>Character vector of length two containing names to use for
column 1 (pixel values) and column 2 (pixel counts) in the output data
frame (defaults are <code>c("VALUE", "COUNT")</code>).</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_table_type">table_type</code></td>
<td>
<p>Character string describing the type of the attribute
table. One of either <code>"thematic"</code>, or <code>"athematic"</code> for continuous data
(the default).</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_na_value">na_value</code></td>
<td>
<p>Numeric scalar. If the set of unique pixel values has an
<code>NA</code>, it will be recoded to <code>na_value</code> in the returned data frame.
If <code>NULL</code> (the default), <code>NA</code> will not be recoded.</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_join_df">join_df</code></td>
<td>
<p>Optional data frame for joining additional attributes. Must
have a column of unique values with the same name as <code>col_names[1]</code>
(<code>"VALUE"</code> by default).</p>
</td></tr>
<tr><td><code id="buildRAT_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code style="white-space: pre;">&#8288;TRUE``, a progress bar will not be displayed. Defaults to &#8288;</code>FALSE&ldquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GDAL Raster Attribute Table (or RAT) provides attribute information about
pixel values. Raster attribute tables can be used to represent histograms,
color tables, and classification information. Each row in the table applies
to either a single pixel value or a range of values, and might have
attributes such as the histogram count for that value (or range), the color
that pixels of that value (or range) should be displayed, names of classes,
or various other information.
</p>
<p>Each column in a raster attribute table has a name, a type (integer,
double, or string), and a <code>GDALRATFieldUsage</code>. The usage
distinguishes columns with particular understood purposes (such as color,
histogram count, class name), and columns that have other purposes not
understood by the library (long labels, ancillary attributes, etc).
</p>
<p>In the general case, each row has a field indicating the minimum pixel
value falling into that category, and a field indicating the maximum pixel
value. In the GDAL API, these are indicated with usage values of <code>GFU_Min</code>
and <code>GFU_Max</code>. In the common case where each row is a discrete pixel value,
a single column with usage <code>GFU_MinMax</code> would be used instead.
In R, the table is represented as a data frame with column attribute <code>"GFU"</code>
containing the field usage as a string, e.g., <code>"Max"</code>, <code>"Min"</code> or <code>"MinMax"</code>
(case-sensitive).
The full set of possible field usage descriptors is:
</p>

<table>
<tr>
 <td style="text-align: left;">
GFU attr       </td><td style="text-align: left;"> GDAL enum        </td><td style="text-align: left;"> Description</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Generic"</code>    </td><td style="text-align: left;"> <code>GFU_Generic</code>    </td><td style="text-align: left;"> General purpose field</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"PixelCount"</code> </td><td style="text-align: left;"> <code>GFU_PixelCount</code> </td><td style="text-align: left;"> Histogram pixel count</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Name"</code>       </td><td style="text-align: left;"> <code>GFU_Name</code>       </td><td style="text-align: left;"> Class name</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Min"</code>        </td><td style="text-align: left;"> <code>GFU_Min</code>        </td><td style="text-align: left;"> Class range minimum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Max"</code>        </td><td style="text-align: left;"> <code>GFU_Max</code>        </td><td style="text-align: left;"> Class range maximum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"MinMax"</code>     </td><td style="text-align: left;"> <code>GFU_MinMax</code>     </td><td style="text-align: left;"> Class value (min=max)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Red"</code>        </td><td style="text-align: left;"> <code>GFU_Red</code>        </td><td style="text-align: left;"> Red class color (0-255)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Green"</code>      </td><td style="text-align: left;"> <code>GFU_Green</code>      </td><td style="text-align: left;"> Green class color (0-255)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Blue"</code>       </td><td style="text-align: left;"> <code>GFU_Blue</code>       </td><td style="text-align: left;"> Blue class color (0-255)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"Alpha"</code>      </td><td style="text-align: left;"> <code>GFU_Alpha</code>      </td><td style="text-align: left;"> Alpha transparency (0-255)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"RedMin"</code>     </td><td style="text-align: left;"> <code>GFU_RedMin</code>     </td><td style="text-align: left;"> Color range red minimum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"GreenMin"</code>   </td><td style="text-align: left;"> <code>GFU_GreenMin</code>   </td><td style="text-align: left;"> Color range green minimum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"BlueMin"</code>    </td><td style="text-align: left;"> <code>GFU_BlueMin</code>    </td><td style="text-align: left;"> Color range blue minimum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"AlphaMin"</code>   </td><td style="text-align: left;"> <code>GFU_AlphaMin</code>   </td><td style="text-align: left;"> Color range alpha minimum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"RedMax"</code>     </td><td style="text-align: left;"> <code>GFU_RedMax</code>     </td><td style="text-align: left;"> Color range red maximum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"GreenMax"</code>   </td><td style="text-align: left;"> <code>GFU_GreenMax</code>   </td><td style="text-align: left;"> Color range green maximum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"BlueMax"</code>    </td><td style="text-align: left;"> <code>GFU_BlueMax</code>    </td><td style="text-align: left;"> Color range blue maximum</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"AlphaMax"</code>   </td><td style="text-align: left;"> <code>GFU_AlphaMax</code>   </td><td style="text-align: left;"> Color range alpha maximum
</td>
</tr>

</table>

<p><code>buildRAT()</code> assigns GFU <code>"MinMax"</code> on the column of pixel values (named
<code>"VALUE"</code> by default) and GFU <code>"PixelCount"</code> on the column of counts (named
<code>"COUNT"</code> by default).
If <code>join_df</code> is given, the additional columns that result from joining will
have GFU assigned automatically based on the column names (<em>ignoring case</em>).
First, the additional column names are checked for containing
the string <code>"name"</code> (e.g., <code>"classname"</code>, <code>"TypeName"</code>, <code>"EVT_NAME"</code>, etc).
The first matching column (if any) will be assigned a GFU of <code>"Name"</code>
(=<code>GFU_Name</code>, the field usage descriptor for class names). Next, columns
named <code>"R"</code> or <code>"Red"</code> will be assigned GFU <code>"Red"</code>, columns named <code>"G"</code> or
<code>"Green"</code> will be assigned GFU <code>"Green"</code>, columns named <code>"B"</code> or <code>"Blue"</code>
will be assigned GFU <code>"Blue"</code>, and columns named <code>"A"</code> or <code>"Alpha"</code> will be
assigned GFU <code>"Alpha"</code>. Finally, any remaining columns that have not been
assigned a GFU will be assigned <code>"Generic"</code>.
</p>
<p>In a variation of RAT, all the categories are of equal size and regularly
spaced, and the categorization can be determined by knowing the value at
which the categories start and the size of a category. This is called
&quot;Linear Binning&quot; and the information is kept specially on the raster
attribute table as a whole. In R, a RAT that uses linear binning would
have the following attributes set on the data frame:
attribute <code>"Row0Min"</code> = the numeric lower bound (pixel value) of the first
category, and attribute <code>"BinSize"</code> = the numeric width of each category (in
pixel value units). <code>buildRAT()</code> does not create tables with linear binning,
but one could be created manually based on the specifications above, and
applied to a raster with the class method <code>GDALRaster$setDefaultRAT()</code>.
</p>
<p>A raster attribute table is thematic or athematic (continuous). In R, this
is defined by an attribute on the data frame named <code>"GDALRATTableType"</code> with
value of either <code>"thematic"</code> or <code>"athematic"</code>.
</p>


<h3>Value</h3>

<p>A data frame with at least two columns containing the set of unique
pixel values and their counts. These columns have attribute <code>"GFU"</code> set to
<code>"MinMax"</code> for the values, and <code>"PixelCount"</code> for the counts. If <code>join_df</code> is
given, the returned data frame will have additional columns that result from
<code>merge()</code>. The <code>"GFU"</code> attribute of the additional columns will be assigned
automatically based on the column names (<em>case-insensitive</em> matching, see
Details). The returned data frame has attribute <code>"GDALRATTableType"</code> set to
<code>table_type</code>.
</p>


<h3>Note</h3>

<p>The full raster will be scanned.
</p>
<p>If <code>na_value</code> is not specified, then an <code>NA</code> pixel value (if present)
will not be recoded in the output data frame. This may have implications
if joining to other data (<code>NA</code> will not match), or when using the returned
data frame to set a default RAT on a dataset (<code>NA</code> will be interpreted
as the value that R uses internally to represent it for the type, e.g.,
-2147483648 for <code>NA_integer_</code>). In some cases, removing the row in the output
data frame with value <code>NA</code>, rather than recoding, may be desirable (i.e., by
removing manually or by side effect of joining via <code>merge()</code>, for example).
Users should consider what is appropriate for a particular case.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$getDefaultRAT()</a></code>,
<code><a href="#topic+GDALRaster">GDALRaster$setDefaultRAT()</a></code>,
<code><a href="#topic+displayRAT">displayRAT()</a></code>
</p>
<p><code>vignette("raster-attribute-tables")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
# make a copy to modify
f &lt;- file.path(tempdir(), "storml_evt_tmp.tif")
file.copy(evt_file,  f)

ds &lt;- new(GDALRaster, f, read_only=FALSE)
ds$getDefaultRAT(band=1) # NULL

# get the full attribute table for LANDFIRE EVT from the CSV file
evt_csv &lt;- system.file("extdata/LF20_EVT_220.csv", package="gdalraster")
evt_df &lt;- read.csv(evt_csv)
nrow(evt_df)
head(evt_df)
evt_df &lt;- evt_df[,1:7]

tbl &lt;- buildRAT(ds,
                table_type = "thematic",
                na_value = -9999,
                join_df = evt_df)

nrow(tbl)
head(tbl)

# attributes on the data frame and its columns define usage in a GDAL RAT
attributes(tbl)
attributes(tbl$VALUE)
attributes(tbl$COUNT)
attributes(tbl$EVT_NAME)
attributes(tbl$EVT_LF)
attributes(tbl$EVT_PHYS)
attributes(tbl$R)
attributes(tbl$G)
attributes(tbl$B)

ds$setDefaultRAT(band=1, tbl)
ds$flushCache()

tbl2 &lt;- ds$getDefaultRAT(band=1)
nrow(tbl2)
head(tbl2)

ds$close()
deleteDataset(f)

# Display
evt_gt &lt;- displayRAT(tbl2, title = "Storm Lake EVT Raster Attribute Table")
class(evt_gt)  # an object of class "gt_tbl" from package gt
# To show the table:
# evt_gt
# or simply call `displayRAT()` as above but without assignment
# `vignette("raster-attribute-tables")` has example output
</code></pre>

<hr>
<h2 id='buildVRT'>Build a GDAL virtual raster from a list of datasets</h2><span id='topic+buildVRT'></span>

<h3>Description</h3>

<p><code>buildVRT()</code> is a wrapper of the <code>gdalbuildvrt</code> command-line
utility for building a VRT (Virtual Dataset) that is a mosaic of the list
of input GDAL datasets
(see <a href="https://gdal.org/programs/gdalbuildvrt.html">https://gdal.org/programs/gdalbuildvrt.html</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildVRT(vrt_filename, input_rasters, cl_arg = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildVRT_+3A_vrt_filename">vrt_filename</code></td>
<td>
<p>Character string. Filename of the output VRT.</p>
</td></tr>
<tr><td><code id="buildVRT_+3A_input_rasters">input_rasters</code></td>
<td>
<p>Character vector of input raster filenames.</p>
</td></tr>
<tr><td><code id="buildVRT_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments to
<code>gdalbuildvrt</code>.</p>
</td></tr>
<tr><td><code id="buildVRT_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several command-line options are described in the GDAL documentation at the
URL above. By default, the input files are considered as tiles of a larger
mosaic and the VRT file has as many bands as one of the input files.
Alternatively, the <code>-separate</code> argument can be used to put each input
raster into a separate band in the VRT dataset.
</p>
<p>Some amount of checks are done to assure that all files that will be put in
the resulting VRT have similar characteristics: number of bands,
projection, color interpretation.... If not, files that do not match the
common characteristics will be skipped. (This is true in the default
mode for virtual mosaicing, and not when using the <code>-separate</code> option).
</p>
<p>In a virtual mosaic, if there is spatial overlap between
input rasters then the order of files appearing in the list of
sources matter: files that are listed at the end are the ones
from which the data will be fetched. Note that nodata will be taken into
account to potentially fetch data from less priority datasets.
</p>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterToVRT">rasterToVRT()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a virtual 3-band RGB raster from individual Landsat band files
b4_file &lt;- system.file("extdata/sr_b4_20200829.tif", package="gdalraster")
b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
b6_file &lt;- system.file("extdata/sr_b6_20200829.tif", package="gdalraster")
band_files &lt;- c(b6_file, b5_file, b4_file)
vrt_file &lt;- file.path(tempdir(), "storml_b6_b5_b4.vrt")
buildVRT(vrt_file, band_files, cl_arg = "-separate")
ds &lt;- new(GDALRaster, vrt_file)
ds$getRasterCount()
plot_raster(ds, nbands=3, main="Landsat 6-5-4 (vegetative analysis)")
ds$close()

vsi_unlink(vrt_file)
</code></pre>

<hr>
<h2 id='calc'>Raster calculation</h2><span id='topic+calc'></span>

<h3>Description</h3>

<p><code>calc()</code> evaluates an R expression for each pixel in a raster layer or
stack of layers. Each layer is defined by a raster filename, band number,
and a variable name to use in the R expression. If not specified, band
defaults to 1 for each input raster.
Variable names default to <code>LETTERS</code> if not specified
(<code>A</code> (layer 1), <code>B</code> (layer 2), ...).
All of the input layers must have the same extent and cell size.
The projection will be read from the first raster in the list
of inputs.
Individual pixel coordinates are also available as variables in the
R expression, as either x/y in the raster projected coordinate system or
inverse projected longitude/latitude.
Multiband output is supported as of gdalraster 1.11.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc(
  expr,
  rasterfiles,
  bands = NULL,
  var.names = NULL,
  dstfile = tempfile("rastcalc", fileext = ".tif"),
  fmt = NULL,
  dtName = "Int16",
  out_band = NULL,
  options = NULL,
  nodata_value = NULL,
  setRasterNodataValue = FALSE,
  usePixelLonLat = NULL,
  write_mode = "safe",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_+3A_expr">expr</code></td>
<td>
<p>An R expression as a character string (e.g., <code>"A + B"</code>).</p>
</td></tr>
<tr><td><code id="calc_+3A_rasterfiles">rasterfiles</code></td>
<td>
<p>Character vector of source raster filenames.</p>
</td></tr>
<tr><td><code id="calc_+3A_bands">bands</code></td>
<td>
<p>Integer vector of band numbers to use for each raster layer.</p>
</td></tr>
<tr><td><code id="calc_+3A_var.names">var.names</code></td>
<td>
<p>Character vector of variable names to use for each raster
layer.</p>
</td></tr>
<tr><td><code id="calc_+3A_dstfile">dstfile</code></td>
<td>
<p>Character filename of output raster.</p>
</td></tr>
<tr><td><code id="calc_+3A_fmt">fmt</code></td>
<td>
<p>Output raster format name (e.g., &quot;GTiff&quot; or &quot;HFA&quot;). Will attempt
to guess from the output filename if not specified.</p>
</td></tr>
<tr><td><code id="calc_+3A_dtname">dtName</code></td>
<td>
<p>Character name of output data type (e.g., Byte, Int16,
UInt16, Int32, UInt32, Float32).</p>
</td></tr>
<tr><td><code id="calc_+3A_out_band">out_band</code></td>
<td>
<p>Integer band number(s) in <code>dstfile</code> for writing output.
Defaults to <code>1</code>. Multiband output is supported as of gdalraster 1.11.0,
in which case <code>out_band</code> would be a vector of band numbers.</p>
</td></tr>
<tr><td><code id="calc_+3A_options">options</code></td>
<td>
<p>Optional list of format-specific creation options in a
vector of &quot;NAME=VALUE&quot; pairs
(e.g., <code>options = c("COMPRESS=LZW")</code> to set LZW compression
during creation of a GTiff file).</p>
</td></tr>
<tr><td><code id="calc_+3A_nodata_value">nodata_value</code></td>
<td>
<p>Numeric value to assign if <code>expr</code> returns NA.</p>
</td></tr>
<tr><td><code id="calc_+3A_setrasternodatavalue">setRasterNodataValue</code></td>
<td>
<p>Logical. <code>TRUE</code> will attempt to set the raster
format nodata value to <code>nodata_value</code>, or <code>FALSE</code> not to set a raster
nodata value.</p>
</td></tr>
<tr><td><code id="calc_+3A_usepixellonlat">usePixelLonLat</code></td>
<td>
<p>This argument is deprecated and will be removed in a
future version. Variable names <code>pixelLon</code> and <code>pixelLat</code> can be used in
<code>expr</code>, and the pixel x/y coordinates will be inverse projected to
longitude/latitude (adds computation time).</p>
</td></tr>
<tr><td><code id="calc_+3A_write_mode">write_mode</code></td>
<td>
<p>Character. Name of the file write mode for output.
One of:
</p>

<ul>
<li> <p><code>safe</code> - execution stops if <code>dstfile</code> already exists (no output written)
</p>
</li>
<li> <p><code>overwrite</code> - if <code>dstfile</code> exists if will be overwritten with a new file
</p>
</li>
<li> <p><code>update</code> - if <code>dstfile</code> exists, will attempt to open in update mode
and write output to <code>out_band</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variables in <code>expr</code> are vectors of length raster xsize
(row vectors of the input raster layer(s)).
The expression should return a vector also of length raster xsize
(an output row).
Four special variable names are available in <code>expr</code>:
<code>pixelX</code> and <code>pixelY</code> provide pixel center coordinates in projection units.
<code>pixelLon</code> and <code>pixelLat</code> can also be used, in which case the pixel x/y
coordinates will be inverse projected to longitude/latitude
(in the same geographic coordinate system used by the input projection,
which is read from the first input raster). Note that inverse projection
adds computation time.
</p>
<p>To refer to specific bands in a multi-band input file, repeat the filename in
<code>rasterfiles</code> and specify corresponding band numbers in <code>bands</code>, along with
optional variable names in <code>var.names</code>, for example,
</p>
<pre>
rasterfiles = c("multiband.tif", "multiband.tif")
bands = c(4, 5)
var.names = c("B4", "B5")
</pre>
<p>Output will be written to <code>dstfile</code>. To update a file that already
exists, set <code>write_mode = "update"</code> and set <code>out_band</code> to an existing
band number(s) in <code>dstfile</code> (new bands cannot be created in <code>dstfile</code>).
</p>
<p>To write multiband output, <code>expr</code> must return a vector of values
interleaved by band. This is equivalent to, and can also be returned as,
a matrix <code>m</code> with <code>nrow(m)</code> equal to <code>length()</code> of an input vector, and
<code>ncol(m)</code> equal to the number of output bands. In matrix form, each column
contains a vector of output values for a band.
<code>length(m)</code> must be equal to the <code>length()</code> of an input vector multiplied by
<code>length(out_band)</code>. The dimensions described above are assumed and not
read from the return value of <code>expr</code>.
</p>


<h3>Value</h3>

<p>Returns the output filename invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+combine">combine()</a></code>, <code><a href="#topic+rasterToVRT">rasterToVRT()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using pixel longitude/latitude

# Hopkins bioclimatic index (HI) as described in:
# Bechtold, 2004, West. J. Appl. For. 19(4):245-251.
# Integrates elevation, latitude and longitude into an index of the
# phenological occurrence of springtime. Here it is relativized to
# mean values for an eight-state region in the western US.
# Positive HI means spring is delayed by that number of days relative
# to the reference position, while negative values indicate spring is
# advanced. The original equation had elevation units as feet, so
# converting m to ft in `expr`.

elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")

# expression to calculate HI
expr &lt;- "round( ((ELEV_M * 3.281 - 5449) / 100) +
                ((pixelLat - 42.16) * 4) +
                ((-116.39 - pixelLon) * 1.25) )"

# calc() writes to a tempfile by default
hi_file &lt;- calc(expr = expr,
                rasterfiles = elev_file,
                var.names = "ELEV_M",
                dtName = "Int16",
                nodata_value = -32767,
                setRasterNodataValue = TRUE)

ds &lt;- new(GDALRaster, hi_file)
# min, max, mean, sd
ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
ds$close()
deleteDataset(hi_file)


## Calculate normalized difference vegetation index (NDVI)

# Landast band 4 (red) and band 5 (near infrared):
b4_file &lt;- system.file("extdata/sr_b4_20200829.tif", package="gdalraster")
b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")

expr &lt;- "((B5 * 0.0000275 - 0.2) - (B4 * 0.0000275 - 0.2)) /
         ((B5 * 0.0000275 - 0.2) + (B4 * 0.0000275 - 0.2))"
ndvi_file &lt;- calc(expr = expr,
                  rasterfiles = c(b4_file, b5_file),
                  var.names = c("B4", "B5"),
                  dtName = "Float32",
                  nodata_value = -32767,
                  setRasterNodataValue = TRUE)

ds &lt;- new(GDALRaster, ndvi_file)
ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
ds$close()
deleteDataset(ndvi_file)


## Reclassify a variable by rule set

# Combine two raster layers and look for specific combinations. Then
# recode to a new value by rule set.
#
# Based on example in:
#   Stratton, R.D. 2009. Guidebook on LANDFIRE fuels data acquisition,
#   critique, modification, maintenance, and model calibration.
#   Gen. Tech. Rep. RMRS-GTR-220. U.S. Department of Agriculture,
#   Forest Service, Rocky Mountain Research Station. 54 p.
# Context: Refine national-scale fuels data to improve fire simulation
#   results in localized applications.
# Issue: Areas with steep slopes (40+ degrees) were mapped as
#   GR1 (101; short, sparse dry climate grass) and
#   GR2 (102; low load, dry climate grass) but were not carrying fire.
# Resolution: After viewing these areas in Google Earth,
#   NB9 (99; bare ground) was selected as the replacement fuel model.

# look for combinations of slope &gt;= 40 and FBFM 101 or 102
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
rasterfiles &lt;- c(lcp_file, lcp_file)
var.names &lt;- c("SLP", "FBFM")
bands &lt;- c(2, 4)
tbl &lt;- combine(rasterfiles, var.names, bands)
nrow(tbl)
tbl_subset &lt;- subset(tbl, SLP &gt;= 40 &amp; FBFM %in% c(101,102))
print(tbl_subset)       # twelve combinations meet the criteria
sum(tbl_subset$count)   # 85 total pixels

# recode these pixels to 99 (bare ground)
# the LCP driver does not support in-place write so make a copy as GTiff
tif_file &lt;- file.path(tempdir(), "storml_lndscp.tif")
createCopy("GTiff", tif_file, lcp_file)

expr &lt;- "ifelse( SLP &gt;= 40 &amp; FBFM %in% c(101,102), 99, FBFM)"
calc(expr = expr,
     rasterfiles = c(lcp_file, lcp_file),
     bands = c(2, 4),
     var.names = c("SLP", "FBFM"),
     dstfile = tif_file,
     out_band = 4,
     write_mode = "update")

# verify the ouput
rasterfiles &lt;- c(tif_file, tif_file)
tbl &lt;- combine(rasterfiles, var.names, bands)
tbl_subset &lt;- subset(tbl, SLP &gt;= 40 &amp; FBFM %in% c(101,102))
print(tbl_subset)
sum(tbl_subset$count)

# if LCP file format is needed:
# createCopy("LCP", "storml_edited.lcp", tif_file)

deleteDataset(tif_file)
</code></pre>

<hr>
<h2 id='CmbTable-class'>Class for counting unique combinations of integers</h2><span id='topic+CmbTable-class'></span><span id='topic+Rcpp_CmbTable'></span><span id='topic+Rcpp_CmbTable-class'></span><span id='topic+CmbTable'></span>

<h3>Description</h3>

<p><code>CmbTable</code> implements a hash table having a vector of integers as the key,
and the count of occurrences of each unique integer combination as the
value. A unique ID is assigned to each unique combination of input values.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="CmbTable-class_+3A_keylen">keyLen</code></td>
<td>
<p>The number of integer values comprising each combination.</p>
</td></tr>
<tr><td><code id="CmbTable-class_+3A_varnames">varNames</code></td>
<td>
<p>Character vector of names for the variables in the
combination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>CmbTable</code>. Contains a hash table having a
vector of <code>keyLen</code> integers as the key and the count of occurrences of
each unique integer combination as the value, along with methods that
operate on the table as described in Details.
<code>CmbTable</code> is a C++ class exposed directly to R (via <code>RCPP_EXPOSED_CLASS</code>).
Methods of the class are accessed in R using the <code>$</code> operator.
</p>


<h3>Usage</h3>

<pre>
## Constructors
cmb &lt;- new(CmbTable, keyLen)
# or, with variable names
cmb &lt;- new(CmbTable, keyLen, varNames)

## Methods (see Details)
cmb$update(int_cmb, incr)
cmb$updateFromMatrix(int_cmbs, incr)
cmb$updateFromMatrixByRow(int_cmbs, incr)
cmb$asDataFrame()
cmb$asMatrix()
</pre>


<h3>Details</h3>

<p><code>new(CmbTable, keyLen)</code>
Constructor. Variable names will be assigned as <code>V1</code>, <code>V2</code>, ....
Returns an object of class <code>CmbTable</code>.
</p>
<p><code>new(CmbTable, keyLen, varNames)</code>
Alternate constructor to specify variable names.
Returns an object of class <code>CmbTable</code>.
</p>
<p><code>$update(int_cmb, incr)</code>
Updates the hash table for the integer combination in the numeric vector
<code>int_cmb</code> (coerced to integer by truncation).
If this combination exists in the table, its count will be
incremented by <code>incr</code>. If the combination is not found in the table,
it will be inserted with count set to <code>incr</code>.
Returns the unique ID assigned to this combination.
Combination IDs are sequential integers starting at <code>1</code>.
</p>
<p><code>$updateFromMatrix(int_cmbs, incr)</code>
This method is the same as <code style="white-space: pre;">&#8288;$update()&#8288;</code> but for a numeric matrix of
integer combinations <code>int_cmbs</code> (coerced to integer by truncation).
The matrix is arranged with each column vector forming an integer
combination. For example, the rows of the matrix could be
one row each from a set of <code>keyLen</code> rasters all read at the
same extent and pixel resolution (i.e., row-by-row raster overlay).
The method calls <code style="white-space: pre;">&#8288;$update()&#8288;</code> on each combination (each column of
<code>int_cmbs</code>), incrementing count by <code>incr</code> for existing
combinations, or inserting new combinations with count set to <code>incr</code>.
Returns a numeric vector of length <code>ncol(int_cmbs)</code> containing the
IDs assigned to the combinations.
</p>
<p><code>$updateFromMatrixByRow(int_cmbs, incr)</code>
This method is the same as <code style="white-space: pre;">&#8288;$updateFromMatrix()&#8288;</code> above except the
integer combinations are in rows of the matrix <code>int_cmbs</code> (columns
are the variables).
The method calls <code style="white-space: pre;">&#8288;$update()&#8288;</code> on each combination (each row of
<code>int_cmbs</code>), incrementing count by <code>incr</code> for existing
combinations, or inserting new combinations with count set to <code>incr</code>.
Returns a numeric vector of length <code>nrow(int_cmbs)</code> containing the
IDs assigned to the combinations.
</p>
<p><code>$asDataFrame()</code>
Returns the <code>CmbTable</code> as a data frame with column <code>cmbid</code> containing
the unique combination IDs, column <code>count</code> containing the counts of
occurrences, and <code>keyLen</code> columns (with names from <code>varNames</code>) containing
the integer values comprising each unique combination.
</p>
<p><code>$asMatrix()</code>
Returns the <code>CmbTable</code> as a matrix with column <code>1</code> (<code>cmbid</code>)
containing the unique combination IDs, column <code>2</code> (<code>count</code>)
containing the counts of occurrences, and columns <code>3:keyLen+2</code>
(with names from <code>varNames</code>) containing the integer values comprising each
unique combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1,2,3,1,2,3,4,5,6,1,3,2,4,5,6,1,1,1), 3, 6, byrow=FALSE)
rownames(m) &lt;- c("layer1", "layer2", "layer3")
print(m)
cmb &lt;- new(CmbTable, 3, rownames(m))
cmb$updateFromMatrix(m, 1)
cmb$asDataFrame()
cmb$update(c(4,5,6), 1)
cmb$update(c(1,3,5), 1)
cmb$asDataFrame()

# same as above but matrix arranged with integer combinations in the rows
m &lt;- matrix(c(1,2,3,1,2,3,4,5,6,1,3,2,4,5,6,1,1,1), 6, 3, byrow=TRUE)
colnames(m) &lt;- c("V1", "V2", "V3")
print(m)
cmb &lt;- new(CmbTable, 3)
cmb$updateFromMatrixByRow(m, 1)
cmb$asDataFrame()
cmb$update(c(4,5,6), 1)
cmb$update(c(1,3,5), 1)
cmb$asDataFrame()
</code></pre>

<hr>
<h2 id='combine'>Raster overlay for unique combinations</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p><code>combine()</code> overlays multiple rasters so that a unique ID is assigned to
each unique combination of input values. The input raster layers
typically have integer data types (floating point will be coerced to
integer by truncation), and must have the same projection, extent and cell
size. Pixel counts for each unique combination are obtained, and
combination IDs are optionally written to an output raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(
  rasterfiles,
  var.names = NULL,
  bands = NULL,
  dstfile = NULL,
  fmt = NULL,
  dtName = "UInt32",
  options = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_rasterfiles">rasterfiles</code></td>
<td>
<p>Character vector of raster filenames to combine.</p>
</td></tr>
<tr><td><code id="combine_+3A_var.names">var.names</code></td>
<td>
<p>Character vector of <code>length(rasterfiles)</code> containing
variable names for each raster layer. Defaults will be assigned if
<code>var.names</code> are omitted.</p>
</td></tr>
<tr><td><code id="combine_+3A_bands">bands</code></td>
<td>
<p>Numeric vector of <code>length(rasterfiles)</code> containing the band
number to use for each raster in <code>rasterfiles</code>. Band 1 will be used for
each input raster if <code>bands</code> are not specified.</p>
</td></tr>
<tr><td><code id="combine_+3A_dstfile">dstfile</code></td>
<td>
<p>Character. Optional output raster filename for writing the
per-pixel combination IDs. The output raster will be created (and
overwritten if it already exists).</p>
</td></tr>
<tr><td><code id="combine_+3A_fmt">fmt</code></td>
<td>
<p>Character. Output raster format name (e.g., &quot;GTiff&quot; or &quot;HFA&quot;).</p>
</td></tr>
<tr><td><code id="combine_+3A_dtname">dtName</code></td>
<td>
<p>Character. Output raster data type name. Combination IDs are
sequential integers starting at 1. The data type for the output raster
should be large enough to accommodate the potential number of unique
combinations of the input values
(e.g., &quot;UInt16&quot; or the default &quot;UInt32&quot;).</p>
</td></tr>
<tr><td><code id="combine_+3A_options">options</code></td>
<td>
<p>Optional list of format-specific creation options in a
vector of &quot;NAME=VALUE&quot; pairs
(e.g., <code>options = c("COMPRESS=LZW")</code> to set LZW compression
during creation of a GTiff file).</p>
</td></tr>
<tr><td><code id="combine_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, progress bar and messages will be
suppressed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To specify input raster layers that are bands of a multi-band
raster file, repeat the filename in <code>rasterfiles</code> and provide the
corresponding band numbers in <code>bands</code>. For example:
</p>
<pre>
rasterfiles &lt;- c("multi-band.tif", "multi-band.tif", "other.tif")
bands &lt;- c(4, 5, 1)
var.names &lt;- c("multi_b4", "multi_b5", "other")
</pre>
<p><code><a href="#topic+rasterToVRT">rasterToVRT()</a></code> provides options for virtual clipping, resampling and pixel
alignment, which may be helpful here if the input rasters are not already
aligned on a common extent and cell size.
</p>
<p>If an output raster of combination IDs is written, the user should verify
that the number of combinations obtained did not exceed the range of the
output data type. Combination IDs are sequential integers starting at 1.
Typical output data types are the unsigned types:
Byte (0 to 255), UInt16 (0 to 65,535) and UInt32 (the default, 0 to
4,294,967,295).
</p>


<h3>Value</h3>

<p>A data frame with column <code>cmbid</code> containing the combination IDs,
column <code>count</code> containing the pixel counts for each combination,
and <code>length(rasterfiles)</code> columns named <code>var.names</code> containing the integer
values comprising each unique combination.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CmbTable">CmbTable-class</a></code>, <code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+calc">calc()</a></code>,
<code><a href="#topic+rasterToVRT">rasterToVRT()</a></code>
</p>
<p><code><a href="#topic+buildRAT">buildRAT()</a></code> to compute a table of the unique pixel values and their counts
for a single raster layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
evc_file &lt;- system.file("extdata/storml_evc.tif", package="gdalraster")
evh_file &lt;- system.file("extdata/storml_evh.tif", package="gdalraster")
rasterfiles &lt;- c(evt_file, evc_file, evh_file)
var.names &lt;- c("veg_type", "veg_cov", "veg_ht")
tbl &lt;- combine(rasterfiles, var.names)
nrow(tbl)
tbl &lt;- tbl[order(-tbl$count),]
head(tbl, n = 20)

# combine two bands from a multi-band file and write the combination IDs
# to an output raster
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
rasterfiles &lt;- c(lcp_file, lcp_file)
bands &lt;- c(4, 5)
var.names &lt;- c("fbfm", "tree_cov")
cmb_file &lt;- file.path(tempdir(), "fbfm_cov_cmbid.tif")
opt &lt;- c("COMPRESS=LZW")
tbl &lt;- combine(rasterfiles, var.names, bands, cmb_file, options = opt)
head(tbl)
ds &lt;- new(GDALRaster, cmb_file)
ds$info()
ds$close()
deleteDataset(cmb_file)
</code></pre>

<hr>
<h2 id='copyDatasetFiles'>Copy the files of a dataset</h2><span id='topic+copyDatasetFiles'></span>

<h3>Description</h3>

<p><code>copyDatasetFiles()</code> copies all the files associated with a dataset.
Wrapper for <code>GDALCopyDatasetFiles()</code> in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyDatasetFiles(new_filename, old_filename, format = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copyDatasetFiles_+3A_new_filename">new_filename</code></td>
<td>
<p>New name for the dataset (copied to).</p>
</td></tr>
<tr><td><code id="copyDatasetFiles_+3A_old_filename">old_filename</code></td>
<td>
<p>Old name for the dataset (copied from).</p>
</td></tr>
<tr><td><code id="copyDatasetFiles_+3A_format">format</code></td>
<td>
<p>Raster format short name (e.g., &quot;GTiff&quot;). If set to empty
string <code>""</code> (the default), will attempt to guess the raster format from
<code>old_filename</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> if no error or <code>FALSE</code> on failure.
</p>


<h3>Note</h3>

<p>If <code>format</code> is set to an empty string <code>""</code> (the default) then the function
will try to identify the driver from <code>old_filename</code>. This is done
internally in GDAL by invoking the <code>Identify</code> method of each registered
<code>GDALDriver</code> in turn. The first driver that successful identifies the file
name will be returned. An error is raised if a format cannot be determined
from the passed file name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+deleteDataset">deleteDataset()</a></code>, <code><a href="#topic+renameDataset">renameDataset()</a></code>, <code><a href="#topic+vsi_copy_file">vsi_copy_file()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, lcp_file)
ds$getFileList()
ds$close()

lcp_tmp &lt;- file.path(tempdir(), "storm_lake_copy.lcp")
copyDatasetFiles(lcp_tmp, lcp_file)
ds_copy &lt;- new(GDALRaster, lcp_tmp)
ds_copy$getFileList()
ds_copy$close()

deleteDataset(lcp_tmp)
</code></pre>

<hr>
<h2 id='create'>Create a new uninitialized raster</h2><span id='topic+create'></span>

<h3>Description</h3>

<p><code>create()</code> makes an empty raster in the specified format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create(format, dst_filename, xsize, ysize, nbands, dataType, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_+3A_format">format</code></td>
<td>
<p>Raster format short name (e.g., &quot;GTiff&quot;).</p>
</td></tr>
<tr><td><code id="create_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Filename to create.</p>
</td></tr>
<tr><td><code id="create_+3A_xsize">xsize</code></td>
<td>
<p>Integer width of raster in pixels.</p>
</td></tr>
<tr><td><code id="create_+3A_ysize">ysize</code></td>
<td>
<p>Integer height of raster in pixels.</p>
</td></tr>
<tr><td><code id="create_+3A_nbands">nbands</code></td>
<td>
<p>Integer number of bands.</p>
</td></tr>
<tr><td><code id="create_+3A_datatype">dataType</code></td>
<td>
<p>Character data type name.
(e.g., common data types include Byte, Int16, UInt16, Int32, Float32).</p>
</td></tr>
<tr><td><code id="create_+3A_options">options</code></td>
<td>
<p>Optional list of format-specific creation options in a
vector of <code>"NAME=VALUE"</code> pairs
(e.g., <code>options = c("COMPRESS=LZW")</code> to set LZW
compression during creation of a GTiff file).
The APPEND_SUBDATASET=YES option can be
specified to avoid prior destruction of existing dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>, <code><a href="#topic+rasterFromRaster">rasterFromRaster()</a></code>,
<code><a href="#topic+getCreationOptions">getCreationOptions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_file &lt;- file.path(tempdir(), "newdata.tif")
create(format="GTiff", dst_filename=new_file, xsize=143, ysize=107,
       nbands=1, dataType="Int16")
ds &lt;- new(GDALRaster, new_file, read_only=FALSE)
## EPSG:26912 - NAD83 / UTM zone 12N
ds$setProjection(epsg_to_wkt(26912))
gt &lt;- c(323476.1, 30, 0, 5105082.0, 0, -30)
ds$setGeoTransform(gt)
ds$setNoDataValue(band = 1, -9999)
ds$fillRaster(band = 1, -9999, 0)
## ...
## close the dataset when done
ds$close()

deleteDataset(new_file)
</code></pre>

<hr>
<h2 id='createColorRamp'>Create a color ramp</h2><span id='topic+createColorRamp'></span>

<h3>Description</h3>

<p><code>createColorRamp()</code> is a wrapper for <code>GDALCreateColorRamp()</code> in the GDAL
API. It automatically creates a color ramp from one color entry to another.
Output is an integer matrix in color table format for use with
<code><a href="#topic+GDALRaster">GDALRaster$setColorTable()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createColorRamp(
  start_index,
  start_color,
  end_index,
  end_color,
  palette_interp = "RGB"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createColorRamp_+3A_start_index">start_index</code></td>
<td>
<p>Integer start index (raster value).</p>
</td></tr>
<tr><td><code id="createColorRamp_+3A_start_color">start_color</code></td>
<td>
<p>Integer vector of length three or four.
A color entry value to start the ramp (e.g., RGB values).</p>
</td></tr>
<tr><td><code id="createColorRamp_+3A_end_index">end_index</code></td>
<td>
<p>Integer end index (raster value).</p>
</td></tr>
<tr><td><code id="createColorRamp_+3A_end_color">end_color</code></td>
<td>
<p>Integer vector of length three or four.
A color entry value to end the ramp (e.g., RGB values).</p>
</td></tr>
<tr><td><code id="createColorRamp_+3A_palette_interp">palette_interp</code></td>
<td>
<p>One of &quot;Gray&quot;, &quot;RGB&quot; (the default), &quot;CMYK&quot; or &quot;HLS&quot;
describing interpretation of <code>start_color</code> and <code>end_color</code> values
(see <a href="https://gdal.org/user/raster_data_model.html#color-table">GDAL
Color Table</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix with five columns containing the color ramp from
<code>start_index</code> to <code>end_index</code>, with raster index values in column 1 and
color entries in columns 2:5).
</p>


<h3>Note</h3>

<p><code>createColorRamp()</code> could be called several times, using <code>rbind()</code> to
combine multiple ramps into the same color table. Possible duplicate rows
in the resulting table are not a problem when used in
<code>GDALRaster$setColorTable()</code> (i.e., when <code>end_color</code> of one ramp is the
same as <code>start_color</code> of the next ramp).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$getColorTable()</a></code>,
<code><a href="#topic+GDALRaster">GDALRaster$getPaletteInterp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a color ramp for tree canopy cover percent
# band 5 of an LCP file contains canopy cover
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, lcp_file)
ds$getDescription(band=5)
ds$getMetadata(band=5, domain="")
ds$close()

# create a GTiff file with Byte data type for the canopy cover band
# recode nodata -9999 to 255
tcc_file &lt;- calc(expr = "ifelse(CANCOV == -9999, 255, CANCOV)",
                 rasterfiles = lcp_file,
                 bands = 5,
                 var.names = "CANCOV",
                 fmt = "GTiff",
                 dtName = "Byte",
                 nodata_value = 255,
                 setRasterNodataValue = TRUE)

ds_tcc &lt;- new(GDALRaster, tcc_file, read_only=FALSE)

# create a color ramp from 0 to 100 and set as the color table
colors &lt;- createColorRamp(start_index = 0,
                          start_color = c(211, 211, 211),
                          end_index = 100,
                          end_color = c(0, 100, 0))

print(colors)
ds_tcc$setColorTable(band=1, col_tbl=colors, palette_interp="RGB")
ds_tcc$setRasterColorInterp(band=1, col_interp="Palette")

# close and re-open the dataset in read_only mode
ds_tcc$open(read_only=TRUE)

plot_raster(ds_tcc, interpolate=FALSE, legend=TRUE,
            main="Storm Lake Tree Canopy Cover (%)")
ds_tcc$close()

deleteDataset(tcc_file)
</code></pre>

<hr>
<h2 id='createCopy'>Create a copy of a raster</h2><span id='topic+createCopy'></span>

<h3>Description</h3>

<p><code>createCopy()</code> copies a raster dataset, optionally changing the format.
The extent, cell size, number of bands, data type, projection, and
geotransform are all copied from the source raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCopy(
  format,
  dst_filename,
  src_filename,
  strict = FALSE,
  options = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCopy_+3A_format">format</code></td>
<td>
<p>Format short name for the output raster
(e.g., &quot;GTiff&quot; or &quot;HFA&quot;).</p>
</td></tr>
<tr><td><code id="createCopy_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Filename to create.</p>
</td></tr>
<tr><td><code id="createCopy_+3A_src_filename">src_filename</code></td>
<td>
<p>Filename of source raster.</p>
</td></tr>
<tr><td><code id="createCopy_+3A_strict">strict</code></td>
<td>
<p>Logical. TRUE if the copy must be strictly equivalent,
or more normally FALSE indicating that the copy may adapt as needed for
the output format.</p>
</td></tr>
<tr><td><code id="createCopy_+3A_options">options</code></td>
<td>
<p>Optional list of format-specific creation options in a
vector of <code>"NAME=VALUE"</code> pairs
(e.g., <code>options = c("COMPRESS=LZW")</code> to set <code>LZW</code>
compression during creation of a GTiff file).
The APPEND_SUBDATASET=YES option can be
specified to avoid prior destruction of existing dataset.</p>
</td></tr>
<tr><td><code id="createCopy_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will be not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+rasterFromRaster">rasterFromRaster()</a></code>,
<code><a href="#topic+getCreationOptions">getCreationOptions()</a></code>, <code><a href="#topic+translate">translate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
tif_file &lt;- file.path(tempdir(), "storml_lndscp.tif")
opt &lt;- c("COMPRESS=LZW")
createCopy(format="GTiff", dst_filename=tif_file, src_filename=lcp_file,
           options=opt)
file.size(lcp_file)
file.size(tif_file)
ds &lt;- new(GDALRaster, tif_file, read_only=FALSE)
ds$getMetadata(band=0, domain="IMAGE_STRUCTURE")
for (band in 1:ds$getRasterCount())
    ds$setNoDataValue(band, -9999)
ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
ds$close()

deleteDataset(tif_file)
</code></pre>

<hr>
<h2 id='DEFAULT_DEM_PROC'>List of default DEM processing options</h2><span id='topic+DEFAULT_DEM_PROC'></span>

<h3>Description</h3>

<p>These values are used in <code>dem_proc()</code> as the default processing options:
</p>
<pre>
    list(
         hillshade =    c("-z", "1", "-s", "1", "-az", "315",
                          "-alt", "45", "-alg", "Horn",
                          "-combined", "-compute_edges"),
         slope =        c("-s", "1", "-alg", "Horn", "-compute_edges"),
         aspect =       c("-alg", "Horn", "-compute_edges"),
         color_relief = character(),
         TRI =          c("-alg", "Riley", "-compute_edges"),
         TPI =          c("-compute_edges"),
         roughness =    c("-compute_edges")
         )
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>DEFAULT_DEM_PROC
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dem_proc">dem_proc()</a></code>
</p>
<p><a href="https://gdal.org/programs/gdaldem.html">https://gdal.org/programs/gdaldem.html</a> for a description of all
available command-line options for each processing mode
</p>

<hr>
<h2 id='DEFAULT_NODATA'>List of default nodata values by raster data type</h2><span id='topic+DEFAULT_NODATA'></span>

<h3>Description</h3>

<p>These values are currently used in <code>gdalraster</code> when a nodata value is
needed but has not been specified:
</p>
<pre>
    list("Byte" = 255, "Int8" = -128,
         "UInt16" = 65535, "Int16" = -32767,
         "UInt32" = 4294967293, "Int32" = -2147483647,
         "Float32" = -99999.0, "Float64" = -99999.0)
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>DEFAULT_NODATA
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>

<hr>
<h2 id='deleteDataset'>Delete named dataset</h2><span id='topic+deleteDataset'></span>

<h3>Description</h3>

<p><code>deleteDataset()</code> will attempt to delete the named dataset in a format
specific fashion. Full featured drivers will delete all associated files,
database objects, or whatever is appropriate. The default behavior when no
format specific behavior is provided is to attempt to delete all the files
that would be returned by <code>GDALRaster$getFileList()</code> on the dataset.
The named dataset should not be open in any existing <code>GDALRaster</code> objects
when <code>deleteDataset()</code> is called. Wrapper for <code>GDALDeleteDataset()</code> in the
GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteDataset(filename, format = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteDataset_+3A_filename">filename</code></td>
<td>
<p>Filename to delete (should not be open in a <code>GDALRaster</code>
object).</p>
</td></tr>
<tr><td><code id="deleteDataset_+3A_format">format</code></td>
<td>
<p>Raster format short name (e.g., &quot;GTiff&quot;). If set to empty
string <code>""</code> (the default), will attempt to guess the raster format from
<code>filename</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> if no error or <code>FALSE</code> on failure.
</p>


<h3>Note</h3>

<p>If <code>format</code> is set to an empty string <code>""</code> (the default) then the function
will try to identify the driver from <code>filename</code>. This is done internally in
GDAL by invoking the <code>Identify</code> method of each registered <code>GDALDriver</code> in
turn. The first driver that successful identifies the file name will be
returned. An error is raised if a format cannot be determined from the
passed file name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+copyDatasetFiles">copyDatasetFiles()</a></code>, <code><a href="#topic+renameDataset">renameDataset()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
b5_tmp &lt;- file.path(tempdir(), "b5_tmp.tif")
file.copy(b5_file,  b5_tmp)

ds &lt;- new(GDALRaster, b5_tmp)
ds$buildOverviews("BILINEAR", levels = c(2, 4, 8), bands = c(1))
files &lt;- ds$getFileList()
print(files)
ds$close()
file.exists(files)
deleteDataset(b5_tmp)
file.exists(files)
</code></pre>

<hr>
<h2 id='dem_proc'>GDAL DEM processing</h2><span id='topic+dem_proc'></span>

<h3>Description</h3>

<p><code>dem_proc()</code> generates DEM derivatives from an input elevation raster. This
function is a wrapper for the <code>gdaldem</code> command-line utility.
See <a href="https://gdal.org/programs/gdaldem.html">https://gdal.org/programs/gdaldem.html</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem_proc(
  mode,
  srcfile,
  dstfile,
  mode_options = DEFAULT_DEM_PROC[[mode]],
  color_file = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dem_proc_+3A_mode">mode</code></td>
<td>
<p>Character. Name of the DEM processing mode. One of hillshade,
slope, aspect, color-relief, TRI, TPI or roughness.</p>
</td></tr>
<tr><td><code id="dem_proc_+3A_srcfile">srcfile</code></td>
<td>
<p>Filename of the source elevation raster.</p>
</td></tr>
<tr><td><code id="dem_proc_+3A_dstfile">dstfile</code></td>
<td>
<p>Filename of the output raster.</p>
</td></tr>
<tr><td><code id="dem_proc_+3A_mode_options">mode_options</code></td>
<td>
<p>An optional character vector of command-line options
(see <a href="#topic+DEFAULT_DEM_PROC">DEFAULT_DEM_PROC</a> for default values).</p>
</td></tr>
<tr><td><code id="dem_proc_+3A_color_file">color_file</code></td>
<td>
<p>Filename of a text file containing lines formatted as:
&quot;elevation_value red green blue&quot;. Only used when <code>mode = "color-relief"</code>.</p>
</td></tr>
<tr><td><code id="dem_proc_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p>Band 1 of the source elevation raster is read by default, but this can be
changed by including a <code>-b</code> command-line argument in <code>mode_options</code>.
See the <a href="https://gdal.org/programs/gdaldem.html">documentation for
<code>gdaldem</code></a> for a description of all available options for each processing
mode.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
slp_file &lt;- file.path(tempdir(), "storml_slp.tif")
dem_proc("slope", elev_file, slp_file)

deleteDataset(slp_file)
</code></pre>

<hr>
<h2 id='displayRAT'>Display a GDAL Raster Attribute Table</h2><span id='topic+displayRAT'></span>

<h3>Description</h3>

<p><code>displayRAT()</code> generates a presentation table. Colors are shown if the
Raster Attribute Table contains RGB columns.
This function requires package <code>gt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayRAT(tbl, title = "Raster Attribute Table")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displayRAT_+3A_tbl">tbl</code></td>
<td>
<p>A data frame formatted as a GDAL RAT (e.g., as returned by
<code>buildRAT()</code> or <code>GDALRaster$getDefaultRAT()</code>).</p>
</td></tr>
<tr><td><code id="displayRAT_+3A_title">title</code></td>
<td>
<p>Character string to be used in the table title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"gt_tbl"</code> (i.e., a table created with
<code>gt::gt()</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildRAT">buildRAT()</a></code>, <code><a href="#topic+GDALRaster">GDALRaster$getDefaultRAT()</a></code>
</p>
<p><code>vignette("raster-attribute-tables")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples for `buildRAT()`
</code></pre>

<hr>
<h2 id='dump_open_datasets'>Report open datasets</h2><span id='topic+dump_open_datasets'></span>

<h3>Description</h3>

<p><code>dump_open_datasets()</code> dumps a list of all open datasets (shared or not) to
the console. This function is primarily intended to assist in debugging
&quot;dataset leaks&quot; and reference counting issues. The information reported
includes the dataset name, referenced count, shared status, driver name,
size, and band count. This a wrapper for <code>GDALDumpOpenDatasets()</code> with
output to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dump_open_datasets()
</code></pre>


<h3>Value</h3>

<p>Number of open datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
dump_open_datasets()
ds2 &lt;- new(GDALRaster, elev_file)
dump_open_datasets()
# open without using shared mode
ds3 &lt;- new(GDALRaster, elev_file, read_only = TRUE,
           open_options = NULL, shared = FALSE)
dump_open_datasets()
ds$close()
dump_open_datasets()
ds2$close()
dump_open_datasets()
ds3$close()
dump_open_datasets()
</code></pre>

<hr>
<h2 id='epsg_to_wkt'>Convert spatial reference from EPSG code to OGC Well Known Text</h2><span id='topic+epsg_to_wkt'></span>

<h3>Description</h3>

<p><code>epsg_to_wkt()</code> exports the spatial reference for an EPSG code to
WKT format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epsg_to_wkt(epsg, pretty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epsg_to_wkt_+3A_epsg">epsg</code></td>
<td>
<p>Integer EPSG code.</p>
</td></tr>
<tr><td><code id="epsg_to_wkt_+3A_pretty">pretty</code></td>
<td>
<p>Logical. <code>TRUE</code> to return a nicely formatted WKT string
for display to a person. <code>FALSE</code> for a regular WKT string (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of GDAL 3.0, the default format for WKT export is OGC WKT 1.
The WKT version can be overridden by using the OSR_WKT_FORMAT
configuration option (see <code><a href="#topic+set_config_option">set_config_option()</a></code>).
Valid values are one of: SFSQL, WKT1_SIMPLE, WKT1, WKT1_GDAL,
WKT1_ESRI, WKT2_2015, WKT2_2018, WKT2, DEFAULT.
If SFSQL, a WKT1 string without AXIS, TOWGS84, AUTHORITY or
EXTENSION node is returned. If WKT1_SIMPLE, a WKT1 string without
AXIS, AUTHORITY or EXTENSION node is returned. WKT1 is an alias of
WKT1_GDAL. WKT2 will default to the latest revision implemented
(currently WKT2_2018). WKT2_2019 can be used as an alias of
WKT2_2018 since GDAL 3.2
</p>


<h3>Value</h3>

<p>Character string containing OGC WKT.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>epsg_to_wkt(5070)
writeLines(epsg_to_wkt(5070, pretty=TRUE))
set_config_option("OSR_WKT_FORMAT", "WKT2")
writeLines(epsg_to_wkt(5070, pretty=TRUE))
set_config_option("OSR_WKT_FORMAT", "")
</code></pre>

<hr>
<h2 id='fillNodata'>Fill selected pixels by interpolation from surrounding areas</h2><span id='topic+fillNodata'></span>

<h3>Description</h3>

<p><code>fillNodata()</code> is a wrapper for <code>GDALFillNodata()</code> in the GDAL Algorithms
API. This algorithm will interpolate values for all designated nodata
pixels (pixels having an intrinsic nodata value, or marked by zero-valued
pixels in the optional raster specified in <code>mask_file</code>). For each nodata
pixel, a four direction conic search is done to find values to interpolate
from (using inverse distance weighting).
Once all values are interpolated, zero or more smoothing iterations
(3x3 average filters on interpolated pixels) are applied to smooth out
artifacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillNodata(
  filename,
  band,
  mask_file = "",
  max_dist = 100,
  smooth_iterations = 0L,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillNodata_+3A_filename">filename</code></td>
<td>
<p>Filename of input raster in which to fill nodata pixels.</p>
</td></tr>
<tr><td><code id="fillNodata_+3A_band">band</code></td>
<td>
<p>Integer band number to modify in place.</p>
</td></tr>
<tr><td><code id="fillNodata_+3A_mask_file">mask_file</code></td>
<td>
<p>Optional filename of raster to use as a validity mask
(band 1 is used, zero marks nodata pixels, non-zero marks valid pixels).</p>
</td></tr>
<tr><td><code id="fillNodata_+3A_max_dist">max_dist</code></td>
<td>
<p>Maximum distance (in pixels) that the algorithm
will search out for values to interpolate (100 pixels by default).</p>
</td></tr>
<tr><td><code id="fillNodata_+3A_smooth_iterations">smooth_iterations</code></td>
<td>
<p>The number of 3x3 average filter smoothing
iterations to run after the interpolation to dampen artifacts
(0 by default).</p>
</td></tr>
<tr><td><code id="fillNodata_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p>The input raster will be modified in place. It should not be open in a
<code>GDALRaster</code> object while processing with <code>fillNodata()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## fill nodata edge pixels in the elevation raster
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")

## get count of nodata
tbl &lt;- buildRAT(elev_file)
head(tbl)
tbl[is.na(tbl$VALUE),]

## make a copy that will be modified
mod_file &lt;- file.path(tempdir(), "storml_elev_fill.tif")
file.copy(elev_file,  mod_file)

fillNodata(mod_file, band=1)

mod_tbl = buildRAT(mod_file)
head(mod_tbl)
mod_tbl[is.na(mod_tbl$VALUE),]

deleteDataset(mod_file)
</code></pre>

<hr>
<h2 id='footprint'>Compute footprint of a raster</h2><span id='topic+footprint'></span>

<h3>Description</h3>

<p><code>footprint()</code> is a wrapper of the <code>gdal_footprint</code> command-line
utility (see <a href="https://gdal.org/programs/gdal_footprint.html">https://gdal.org/programs/gdal_footprint.html</a>).
The function can be used to compute the footprint of a raster file, taking
into account nodata values (or more generally the mask band attached to
the raster bands), and generating polygons/multipolygons corresponding to
areas where pixels are valid, and write to an output vector file.
Refer to the GDAL documentation at the URL above for a list of command-line
arguments that can be passed in <code>cl_arg</code>. Requires GDAL &gt;= 3.8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>footprint(src_filename, dst_filename, cl_arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="footprint_+3A_src_filename">src_filename</code></td>
<td>
<p>Character string. Filename of the source raster.</p>
</td></tr>
<tr><td><code id="footprint_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Character string. Filename of the destination vector.
If the file and the output layer exist, the new footprint is appended to
them, unless the <code>-overwrite</code> command-line argument is used.</p>
</td></tr>
<tr><td><code id="footprint_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments for
<code>gdal_footprint</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Post-vectorization geometric operations are applied in the following order:
</p>

<ul>
<li><p> optional splitting (<code>-split_polys</code>)
</p>
</li>
<li><p> optional densification (<code>-densify</code>)
</p>
</li>
<li><p> optional reprojection (<code>-t_srs</code>)
</p>
</li>
<li><p> optional filtering by minimum ring area (<code>-min_ring_area</code>)
</p>
</li>
<li><p> optional application of convex hull (<code>-convex_hull</code>)
</p>
</li>
<li><p> optional simplification (<code>-simplify</code>)
</p>
</li>
<li><p> limitation of number of points (<code>-max_points</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polygonize">polygonize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
out_file &lt;- file.path(tempdir(), "storml.geojson")

# Requires GDAL &gt;= 3.8
if (as.integer(gdal_version()[2]) &gt;= 3080000) {
  # command-line arguments for gdal_footprint
  args &lt;- c("-t_srs", "EPSG:4326")
  footprint(evt_file, out_file, args)

  deleteDataset(out_file)
}
</code></pre>

<hr>
<h2 id='g_area'>Compute the area of a geometry</h2><span id='topic+g_area'></span>

<h3>Description</h3>

<p><code>g_area()</code> computes the area for a <code>LinearRing</code>, <code>Polygon</code> or
<code>MultiPolygon</code>. Undefined for all other geometry types (returns zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_area(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_area_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scalar. Area of the geometry or <code>0</code>.
</p>


<h3>Note</h3>

<p><code>LinearRing</code> is a non-standard geometry type, used in GDAL just for geometry
creation.
</p>

<hr>
<h2 id='g_binary_op'>Binary operations on WKT geometries</h2><span id='topic+g_binary_op'></span><span id='topic+g_intersection'></span><span id='topic+g_union'></span><span id='topic+g_difference'></span><span id='topic+g_sym_difference'></span>

<h3>Description</h3>

<p>These functions implement operations on pairs of geometries in OGC WKT
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_intersection(this_geom, other_geom)

g_union(this_geom, other_geom)

g_difference(this_geom, other_geom)

g_sym_difference(this_geom, other_geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_binary_op_+3A_this_geom">this_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
<tr><td><code id="g_binary_op_+3A_other_geom">other_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use the GEOS library via GDAL headers.
</p>
<p><code>g_intersection()</code> returns a new geometry which is the region of
intersection of the two geometries operated on. <code>g_intersects()</code> can be used
to test if two geometries intersect.
</p>
<p><code>g_union()</code> returns a new geometry which is the region of
union of the two geometries operated on.
</p>
<p><code>g_difference()</code> returns a new geometry which is the region of this geometry
with the region of the other geometry removed.
</p>
<p><code>g_sym_difference()</code> returns a new geometry which is the symmetric
difference of this geometry and the other geometry (union minus
intersection).
</p>


<h3>Value</h3>

<p>Character string. The resulting geometry as OGC WKT.
</p>


<h3>Note</h3>

<p>Geometry validity is not checked. In case you are unsure of the validity
of the input geometries, call <code>g_is_valid()</code> before, otherwise the result
might be wrong.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
g1 &lt;- ds$bbox() |&gt; bbox_to_wkt()
ds$close()

g2 &lt;- "POLYGON ((327381.9 5104541.2, 326824.0 5104092.5, 326708.8 5103182.9,
  327885.2 5102612.9, 329334.5 5103322.4, 329304.2 5104474.5,328212.7
  5104656.4, 328212.7 5104656.4, 327381.9 5104541.2))"

# see spatial predicate defintions at https://en.wikipedia.org/wiki/DE-9IM
g_intersects(g1, g2)  # TRUE
g_overlaps(g1, g2)  # TRUE
# therefore,
g_contains(g1, g2)  # FALSE

g_sym_difference(g1, g2) |&gt; g_area()

g3 &lt;- g_intersection(g1, g2)
g4 &lt;- g_union(g1, g2)
g_difference(g4, g3) |&gt; g_area()
</code></pre>

<hr>
<h2 id='g_binary_pred'>Geometry binary predicates operating on WKT</h2><span id='topic+g_binary_pred'></span><span id='topic+g_intersects'></span><span id='topic+g_disjoint'></span><span id='topic+g_touches'></span><span id='topic+g_contains'></span><span id='topic+g_within'></span><span id='topic+g_crosses'></span><span id='topic+g_overlaps'></span><span id='topic+g_equals'></span>

<h3>Description</h3>

<p>These functions implement tests for pairs of geometries in OGC WKT format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_intersects(this_geom, other_geom)

g_disjoint(this_geom, other_geom)

g_touches(this_geom, other_geom)

g_contains(this_geom, other_geom)

g_within(this_geom, other_geom)

g_crosses(this_geom, other_geom)

g_overlaps(this_geom, other_geom)

g_equals(this_geom, other_geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_binary_pred_+3A_this_geom">this_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
<tr><td><code id="g_binary_pred_+3A_other_geom">other_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use the GEOS library via GDAL headers.
</p>
<p><code>g_intersects()</code> tests whether two geometries intersect.
</p>
<p><code>g_disjoint()</code> tests if this geometry and the other geometry are disjoint.
</p>
<p><code>g_touches()</code> tests if this geometry and the other geometry are touching.
</p>
<p><code>g_contains()</code> tests if this geometry contains the other geometry.
</p>
<p><code>g_within()</code> tests if this geometry is within the other geometry.
</p>
<p><code>g_crosses()</code> tests if this geometry and the other geometry are crossing.
</p>
<p><code>g_overlaps()</code> tests if this geometry and the other geometry overlap, that
is, their intersection has a non-zero area (they have some but not all
points in common).
</p>
<p><code>g_equals()</code> tests whether two geometries are equivalent.
The GDAL documentation says: &quot;This operation implements the SQL/MM
<code>ST_OrderingEquals()</code> operation. The comparison is done in a structural way,
that is to say that the geometry types must be identical, as well as the
number and ordering of sub-geometries and vertices. Or equivalently, two
geometries are considered equal by this method if their WKT/WKB
representation is equal. Note: this must be distinguished from equality in
a spatial way.&quot;
</p>


<h3>Value</h3>

<p>Logical scalar
</p>


<h3>Note</h3>

<p>Geometry validity is not checked. In case you are unsure of the validity
of the input geometries, call <code>g_is_valid()</code> before, otherwise the result
might be wrong.
</p>


<h3>See Also</h3>

<p><a href="https://en.wikipedia.org/wiki/DE-9IM">https://en.wikipedia.org/wiki/DE-9IM</a>
</p>

<hr>
<h2 id='g_buffer'>Compute buffer of a WKT geometry</h2><span id='topic+g_buffer'></span>

<h3>Description</h3>

<p><code>g_buffer()</code> builds a new geometry containing the buffer region around
the geometry on which it is invoked. The buffer is a polygon containing
the region within the buffer distance of the original geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_buffer(wkt, dist, quad_segs = 30L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_buffer_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature 2D geometry.</p>
</td></tr>
<tr><td><code id="g_buffer_+3A_dist">dist</code></td>
<td>
<p>Numeric buffer distance in units of the <code>wkt</code> geometry.</p>
</td></tr>
<tr><td><code id="g_buffer_+3A_quad_segs">quad_segs</code></td>
<td>
<p>Integer number of segments used to define a 90 degree
curve (quadrant of a circle). Large values result in large numbers of
vertices in the resulting buffer geometry while small numbers reduce the
accuracy of the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string for an OGC WKT polygon.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>, <code><a href="#topic+bbox_to_wkt">bbox_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_buffer(wkt = "POINT (0 0)", dist = 10)
</code></pre>

<hr>
<h2 id='g_centroid'>Compute the centroid of a geometry</h2><span id='topic+g_centroid'></span>

<h3>Description</h3>

<p><code>g_centroid()</code> returns a vector of point X, point Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_centroid(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_centroid_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GDAL documentation states &quot;This method relates to the SFCOM
<code>ISurface::get_Centroid()</code> method however the current implementation based
on GEOS can operate on other geometry types such as multipoint, linestring,
geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the
operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for
surfaces and multisurfaces (multipolygons).&quot;
</p>


<h3>Value</h3>

<p>Numeric vector of length 2 containing the centroid (X, Y).
</p>

<hr>
<h2 id='g_distance'>Compute the distance between two geometries</h2><span id='topic+g_distance'></span>

<h3>Description</h3>

<p><code>g_distance()</code> returns the distance between two geometries or <code>-1</code> if an
error occurs. Returns the shortest distance between the two geometries.
The distance is expressed into the same unit as the coordinates of the
geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_distance(this_geom, other_geom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_distance_+3A_this_geom">this_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
<tr><td><code id="g_distance_+3A_other_geom">other_geom</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Distance or '-1' if an error occurs.
</p>


<h3>Note</h3>

<p>Geometry validity is not checked. In case you are unsure of the validity
of the input geometries, call <code>g_is_valid()</code> before, otherwise the result
might be wrong.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_distance("POINT (0 0)", "POINT (5 12)")
</code></pre>

<hr>
<h2 id='g_is_empty'>Test if a geometry is empty</h2><span id='topic+g_is_empty'></span>

<h3>Description</h3>

<p><code>g_is_empty()</code> tests whether a geometry has no points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_is_empty(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_is_empty_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar. <code>TRUE</code> if the geometry has no points, otherwise
<code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- "POLYGON ((0 0, 10 10, 10 0, 0 0))"
g2 &lt;- "POLYGON ((5 1, 9 5, 9 1, 5 1))"
g_difference(g2, g1) |&gt; g_is_empty()
</code></pre>

<hr>
<h2 id='g_is_valid'>Test if a geometry is valid</h2><span id='topic+g_is_valid'></span>

<h3>Description</h3>

<p><code>g_is_valid()</code> tests whether a geometry is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_is_valid(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_is_valid_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar. <code>TRUE</code> if the geometry is valid, otherwise
<code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- "POLYGON ((0 0, 10 10, 10 0, 0 0))"
g_is_valid(g1)

g2 &lt;- "POLYGON ((0 0, 10 10, 10 0, 0 1))"
g_is_valid(g2)
</code></pre>

<hr>
<h2 id='g_length'>Compute the length of a geometry</h2><span id='topic+g_length'></span>

<h3>Description</h3>

<p><code>g_length()</code> computes the length for <code>LineString</code> or <code>MultiCurve</code> objects.
Undefined for all other geometry types (returns zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_length(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_length_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scalar. Length of the geometry or <code>0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_length("LINESTRING (0 0, 3 4)")
</code></pre>

<hr>
<h2 id='g_name'>Extract the geometry type name from a WKT geometry</h2><span id='topic+g_name'></span>

<h3>Description</h3>

<p><code>g_name()</code> returns the name for this geometry type in well known text
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_name(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_name_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>WKT name for this geometry type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
bbox_to_wkt(ds$bbox()) |&gt; g_name()
ds$close()
</code></pre>

<hr>
<h2 id='g_transform'>Apply a coordinate transformation to a WKT geometry</h2><span id='topic+g_transform'></span>

<h3>Description</h3>

<p><code>g_transform()</code> will transform the coordinates of a geometry from their
current spatial reference system to a new target spatial reference system.
Normally this means reprojecting the vectors, but it could include datum
shifts, and changes of units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_transform(
  wkt,
  srs_from,
  srs_to,
  wrap_date_line = FALSE,
  date_line_offset = 10L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_transform_+3A_wkt">wkt</code></td>
<td>
<p>Character. OGC WKT string for a simple feature geometry.</p>
</td></tr>
<tr><td><code id="g_transform_+3A_srs_from">srs_from</code></td>
<td>
<p>Character string in OGC WKT format specifying the
spatial reference system for the geometry given by <code>wkt</code>.</p>
</td></tr>
<tr><td><code id="g_transform_+3A_srs_to">srs_to</code></td>
<td>
<p>Character string in OGC WKT format specifying the target
spatial reference system.</p>
</td></tr>
<tr><td><code id="g_transform_+3A_wrap_date_line">wrap_date_line</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to correct geometries that
incorrectly go from a longitude on a side of the antimeridian to the other
side. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="g_transform_+3A_date_line_offset">date_line_offset</code></td>
<td>
<p>Integer scalar. Longitude gap in degree. Defaults
to <code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string for a transformed OGC WKT geometry.
</p>


<h3>Note</h3>

<p>This function uses the <code>OGR_GeomTransformer_Create()</code> and
<code>OGR_GeomTransformer_Transform()</code> functions in the GDAL API: &quot;This is an
enhanced version of <code>OGR_G_Transform()</code>. When reprojecting geometries from
a Polar Stereographic projection or a projection naturally crossing the
antimeridian (like UTM Zone 60) to a geographic CRS, it will cut geometries
along the antimeridian. So a <code>LineString</code> might be returned as a
<code>MultiLineString</code>.&quot;
</p>
<p>The <code>wrap_date_line = TRUE</code> option might be specified for circumstances to
correct geometries that incorrectly go from a longitude on a side of the
antimeridian to the other side, e.g., <code style="white-space: pre;">&#8288;LINESTRING (-179 0,179 0)&#8288;</code> will be
transformed to <code style="white-space: pre;">&#8288;MULTILINESTRING ((-179 0,-180 0),(180 0,179 0))&#8288;</code>. For that
use case, <code>srs_to</code> might be the same as <code>srs_from</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bbox_transform">bbox_transform()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)

# the convenience function bbox_transform() does this:
bbox_to_wkt(ds$bbox()) |&gt;
  g_transform(ds$getProjection(), epsg_to_wkt(4326)) |&gt;
  bbox_from_wkt()

ds$close()

# correct geometries that incorrectly go from a longitude on a side of the
# antimeridian to the other side
geom &lt;- "LINESTRING (-179 0,179 0)"
srs &lt;- epsg_to_wkt(4326)
g_transform(geom, srs, srs, wrap_date_line = TRUE)
</code></pre>

<hr>
<h2 id='gdal_formats'>Retrieve information on GDAL format drivers for raster and vector</h2><span id='topic+gdal_formats'></span>

<h3>Description</h3>

<p><code>gdal_formats()</code> returns a table of the supported raster and vector
formats, with information about the capabilities of each format driver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_formats(format = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdal_formats_+3A_format">format</code></td>
<td>
<p>A character string containing a driver short name. By default,
information for all configured raster and vector format drivers will be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the format short name, long name, raster
(logical), vector (logical), read/write flag (<code>ro</code> is read-only,
<code>w</code> supports CreateCopy, <code style="white-space: pre;">&#8288;w+&#8288;</code> supports Create), virtual I/O supported
(logical), and subdatasets (logical).
</p>


<h3>Note</h3>

<p>Virtual I/O refers to operations on GDAL Virtual File Systems. See
<a href="https://gdal.org/user/virtual_file_systems.html#virtual-file-systems">https://gdal.org/user/virtual_file_systems.html#virtual-file-systems</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrow(gdal_formats())
head(gdal_formats())

gdal_formats("GPKG")
</code></pre>

<hr>
<h2 id='gdal_version'>Get GDAL version</h2><span id='topic+gdal_version'></span>

<h3>Description</h3>

<p><code>gdal_version()</code> returns runtime version information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_version()
</code></pre>


<h3>Value</h3>

<p>Character vector of length four containing:
</p>

<ul>
<li><p> &quot;–version&quot; - one line version message, e.g., “GDAL 3.6.3, released
2023/03/12”
</p>
</li>
<li><p> &quot;GDAL_VERSION_NUM&quot; - formatted as a string, e.g., “3060300” for
GDAL 3.6.3.0
</p>
</li>
<li><p> &quot;GDAL_RELEASE_DATE&quot; - formatted as a string, e.g., “20230312”
</p>
</li>
<li><p> &quot;GDAL_RELEASE_NAME&quot; - e.g., “3.6.3”
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gdal_version()
</code></pre>

<hr>
<h2 id='GDALRaster-class'>Class encapsulating a raster dataset and associated band objects</h2><span id='topic+GDALRaster-class'></span><span id='topic+Rcpp_GDALRaster'></span><span id='topic+Rcpp_GDALRaster-class'></span><span id='topic+GDALRaster'></span>

<h3>Description</h3>

<p><code>GDALRaster</code> provides an interface for accessing a raster dataset via GDAL
and calling methods on the underlying <code>GDALDataset</code>, <code>GDALDriver</code> and
<code>GDALRasterBand</code> objects. See <a href="https://gdal.org/api/index.html">https://gdal.org/api/index.html</a> for
details of the GDAL Raster API.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="GDALRaster-class_+3A_filename">filename</code></td>
<td>
<p>Character string containing the file name of a raster
dataset to open, as full path or relative to the current working directory.
In some cases, <code>filename</code> may not refer to a local file system, but instead
contain format-specific information on how to access a dataset such
as database connection string, URL, /vsiPREFIX/, etc. (see GDAL
raster format descriptions:
<a href="https://gdal.org/drivers/raster/index.html">https://gdal.org/drivers/raster/index.html</a>).</p>
</td></tr>
<tr><td><code id="GDALRaster-class_+3A_read_only">read_only</code></td>
<td>
<p>Logical. <code>TRUE</code> to open the dataset read-only (the default),
or <code>FALSE</code> to open with write access.</p>
</td></tr>
<tr><td><code id="GDALRaster-class_+3A_open_options">open_options</code></td>
<td>
<p>Optional character vector of <code>NAME=VALUE</code> pairs
specifying dataset open options.</p>
</td></tr>
<tr><td><code id="GDALRaster-class_+3A_shared">shared</code></td>
<td>
<p>Logical. <code>FALSE</code> to open the dataset without using shared
mode. Default is <code>TRUE</code> (see Note).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>GDALRaster</code> which contains a pointer to the
opened dataset, and methods that operate on the dataset as described in
Details. <code>GDALRaster</code> is a C++ class exposed directly to R (via
<code>RCPP_EXPOSED_CLASS</code>). Fields and methods of the class are accessed using
the <code>$</code> operator. The read/write fields can be used for per-object settings.
</p>


<h3>Usage</h3>

<pre>
## Constructors
# read-only by default:
ds &lt;- new(GDALRaster, filename)
# for update access:
ds &lt;- new(GDALRaster, filename, read_only = FALSE)
# to use dataset open options:
ds &lt;- new(GDALRaster, filename, read_only = TRUE|FALSE, open_options)
# to open without shared mode:
new(GDALRaster, filename, read_only, open_options, shared = FALSE)

## Read/write fields (see Details)
ds$infoOptions
ds$quiet
ds$readByteAsRaw

## Methods (see Details)
ds$getFilename()
ds$open(read_only)
ds$isOpen()
ds$getFileList()

ds$info()
ds$infoAsJSON()

ds$getDriverShortName()
ds$getDriverLongName()

ds$getRasterXSize()
ds$getRasterYSize()
ds$getGeoTransform()
ds$setGeoTransform(transform)
ds$getProjection()
ds$getProjectionRef()
ds$setProjection(projection)
ds$bbox()
ds$res()
ds$dim()
ds$apply_geotransform(col_row)
ds$get_pixel_line(xy)

ds$getRasterCount()
ds$getDescription(band)
ds$setDescription(band, desc)
ds$getBlockSize(band)
ds$getActualBlockSize(band, xblockoff, yblockoff)
ds$getOverviewCount(band)
ds$buildOverviews(resampling, levels, bands)
ds$getDataTypeName(band)
ds$getNoDataValue(band)
ds$setNoDataValue(band, nodata_value)
ds$deleteNoDataValue(band)
ds$getUnitType(band)
ds$setUnitType(band, unit_type)
ds$getScale(band)
ds$setScale(band, scale)
ds$getOffset(band)
ds$setOffset(band, offset)
ds$getRasterColorInterp(band)
ds$setRasterColorInterp(band, col_interp)

ds$getMinMax(band, approx_ok)
ds$getStatistics(band, approx_ok, force)
ds$clearStatistics()
ds$getHistogram(band, min, max, num_buckets, incl_out_of_range, approx_ok)
ds$getDefaultHistogram(band, force)

ds$getMetadata(band, domain)
ds$getMetadataItem(band, mdi_name, domain)
ds$setMetadataItem(band, mdi_name, mdi_value, domain)
ds$getMetadataDomainList(band)

ds$read(band, xoff, yoff, xsize, ysize, out_xsize, out_ysize)
ds$write(band, xoff, yoff, xsize, ysize, rasterData)
ds$fillRaster(value, ivalue)

ds$getColorTable(band)
ds$getPaletteInterp(band)
ds$setColorTable(band, col_tbl, palette_interp)

ds$getDefaultRAT(band)
ds$setDefaultRAT(band, df)

ds$flushCache()

ds$getChecksum(band, xoff, yoff, xsize, ysize)

ds$close()
</pre>


<h3>Details</h3>

<p><code>new(GDALRaster, filename, read_only)</code>
Constructor. Returns an object of class <code>GDALRaster</code>.
<code>read_only</code> defaults to <code>TRUE</code> if not specified.
</p>
<p><code>new(GDALRaster, filename, read_only, open_options)</code>
Alternate constructor for passing dataset <code>open_options</code>, a character
vector of <code>NAME=VALUE</code> pairs.
<code>read_only</code> is required for this form of the constructor, <code>TRUE</code> for
read-only, or <code>FALSE</code> to open with write access.
Returns an object of class <code>GDALRaster</code>.
</p>
<p><code>new(GDALRaster, filename, read_only, open_options, shared)</code>
Alternate constructor for specifying the <code>shared</code> mode for dataset opening.
<code>shared</code> defaults to <code>TRUE</code> but can be set to <code>FALSE</code> with this constructor
(see Note).
All parameters are required with this form of the constructor, but
<code>open_options</code> can be <code>NULL</code>.
Returns an object of class <code>GDALRaster</code>.
</p>
<p><code>$infoOptions</code>
Read/write field.
A character vector of command-line arguments to control the output of
<code style="white-space: pre;">&#8288;$info()&#8288;</code> and <code style="white-space: pre;">&#8288;$infoAsJSON()&#8288;</code> (see below).
Defaults to <code>character(0)</code>. Can be set to a vector of strings specifying
arguments to the <code>gdalinfo</code> command-line utility, e.g.,
<code>c("-nomd", "-norat", "-noct")</code>.
Restore the default by setting to empty string (<code>""</code>) or <code>character(0)</code>.
</p>
<p><code>$quiet</code>
Read/write field.
A logical value, <code>FALSE</code> by default. This field can be set to <code>TRUE</code> which
will suppress various messages as well as progress reporting for potentially
long-running processes such as building overviews and computation of
statistics and histograms.
</p>
<p><code>$readByteAsRaw</code>
Read/write field.
A logical value, <code>FALSE</code> by default. This field can be set to <code>TRUE</code> which
will affect the data type returned by <code style="white-space: pre;">&#8288;$read()&#8288;</code> and <code><a href="#topic+read_ds">read_ds()</a></code>. When the
underlying band data type is 'Byte' and <code>readByteAsRaw</code> is <code>TRUE</code> the output
type will be raw rather than integer. See also the <code>as_raw</code> argument to
<code><a href="#topic+read_ds">read_ds()</a></code> to control this in a non-persistent setting. If the underlying
band data type is not Byte this setting has no effect.
</p>
<p><code>$getFilename()</code>
Returns a character string containing the <code>filename</code> associated with this
<code>GDALRaster</code> object (<code>filename</code> originally used to open the dataset).
</p>
<p><code>$open(read_only)</code>
(Re-)opens the raster dataset on the existing filename. Use this method to
open a dataset that has been closed using <code>$close()</code>. May be used to
re-open a dataset with a different read/write access (<code>read_only</code> set to
<code>TRUE</code> or <code>FALSE</code>). The method will first close an open dataset, so it is
not required to call <code>$close()</code> explicitly in this case.
No return value, called for side effects.
</p>
<p><code>$isOpen()</code>
Returns logical indicating whether the associated raster dataset is open.
</p>
<p><code>$getFileList()</code>
Returns a character vector of files believed to be part of this dataset.
If it returns an empty string (<code>""</code>) it means there is believed to be no
local file system files associated with the dataset (e.g., a virtual file
system). The returned filenames will normally be relative or absolute
paths depending on the path used to originally open the dataset.
</p>
<p><code>$info()</code>
Prints various information about the raster dataset to the console (no
return value, called for that side effect only).
Equivalent to the output of the <code>gdalinfo</code> command-line utility
(<code>gdalinfo filename</code>, if using the default <code>infoOptions</code>).
See the field <code style="white-space: pre;">&#8288;$infoOptions&#8288;</code> above for setting the arguments to <code>gdalinfo</code>.
</p>
<p><code>$infoAsJSON()</code>
Returns information about the raster dataset as a JSON-formatted string.
Equivalent to the output of the <code>gdalinfo</code> command-line utility
(<code>gdalinfo -json filename</code>, if using the default <code>infoOptions</code>).
See the field <code style="white-space: pre;">&#8288;$infoOptions&#8288;</code> above for setting the arguments to <code>gdalinfo</code>.
</p>
<p><code>$getDriverShortName()</code>
Returns the short name of the raster format driver.
</p>
<p><code>$getDriverLongName()</code>
Returns the long name of the raster format driver.
</p>
<p><code>$getRasterXSize()</code>
Returns the number of pixels along the x dimension.
</p>
<p><code>$getRasterYSize()</code>
Returns the number of pixels along the y dimension.
</p>
<p><code>$getGeoTransform()</code>
Returns the affine transformation coefficients for transforming between
pixel/line raster space (column/row) and projection coordinate space
(geospatial x/y). The return value is a numeric vector of length six.
See <a href="https://gdal.org/tutorials/geotransforms_tut.html">https://gdal.org/tutorials/geotransforms_tut.html</a>
for details of the affine transformation. <em>With 1-based indexing
in R</em>, the geotransform vector contains (in map units of the raster spatial
reference system):
</p>

<table>
<tr>
 <td style="text-align: right;">
GT[1] </td><td style="text-align: left;"> x-coordinate of upper-left corner of the upper-left pixel</td>
</tr>
<tr>
 <td style="text-align: right;">
GT[2] </td><td style="text-align: left;"> x-component of pixel width</td>
</tr>
<tr>
 <td style="text-align: right;">
GT[3] </td><td style="text-align: left;"> row rotation (zero for north-up raster)</td>
</tr>
<tr>
 <td style="text-align: right;">
GT[4] </td><td style="text-align: left;"> y-coordinate of upper-left corner of the upper-left pixel</td>
</tr>
<tr>
 <td style="text-align: right;">
GT[5] </td><td style="text-align: left;"> column rotation (zero for north-up raster)</td>
</tr>
<tr>
 <td style="text-align: right;">
GT[6] </td><td style="text-align: left;"> y-component of pixel height (negative for north-up raster)
</td>
</tr>

</table>

<p><code>$setGeoTransform(transform)</code>
Sets the affine transformation coefficients on this dataset.
<code>transform</code> is a numeric vector of length six.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the geotransform
could not be set.
</p>
<p><code>$getProjection()</code>
Returns the coordinate reference system of the raster as an OGC WKT
format string. Equivalent to <code>ds$getProjectionRef()</code>.
</p>
<p><code>$getProjectionRef()</code>
Returns the coordinate reference system of the raster as an OGC WKT
format string.
An empty string is returned when a projection definition is not available.
</p>
<p><code>$setProjection(projection)</code>
Sets the projection reference for this dataset.
<code>projection</code> is a string in OGC WKT format.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the projection
could not be set.
</p>
<p><code>$bbox()</code>
Returns a numeric vector of length four containing the bounding box
(xmin, ymin, xmax, ymax) assuming this is a north-up raster.
</p>
<p><code>$res()</code>
Returns a numeric vector of length two containing the resolution
(pixel width, pixel height as positive values) assuming this is a north-up
raster.
</p>
<p><code>$dim()</code>
Returns an integer vector of length three containing the raster dimensions.
Equivalent to:
<code>c(ds$getRasterXSize(), ds$getRasterYSize(), ds$getRasterCount())</code>
</p>
<p><code>$apply_geotransform(col_row)</code>
Applies geotransform coefficients to raster coordinates in pixel/line space
(column/row), converting into georeferenced (x/y) coordinates.
<code>col_row</code> is a numeric matrix of raster col/row coordinates (or two-column
data frame that will be coerced to numeric matrix).
Returns a numeric matrix of geospatial x/y coordinates.
See the stand-alone function of the same name (<code><a href="#topic+apply_geotransform">apply_geotransform()</a></code>) for
more info and examples.
</p>
<p><code>$get_pixel_line(xy)</code>
Converts geospatial coordinates to pixel/line (raster column/row numbers).
<code>xy</code> is a numeric matrix of geospatial x,y coordinates in the same spatial
reference system as the raster (or two-column data frame that will be
coerced to numeric matrix). Returns an integer matrix of raster pixel/line.
See the stand-alone function of the same name (<code><a href="#topic+get_pixel_line">get_pixel_line()</a></code>) for more
info and examples.
</p>
<p><code>$getRasterCount()</code>
Returns the number of raster bands on this dataset. For the methods
described below that operate on individual bands, the <code>band</code>
argument is the integer band number (1-based).
</p>
<p><code>$getDescription(band)</code>
Returns a string containing the description for <code>band</code>. An empty
string is returned if no description is set for the band.
(Setting <code>band = 0</code> will return the dataset-level description.)
</p>
<p><code>$setDescription(band, desc)</code>
Sets a description for <code>band</code>. <code>desc</code> is the character string
to set. No return value.
</p>
<p><code>$getBlockSize(band)</code>
Returns an integer vector of length two (xsize, ysize) containing the
&quot;natural&quot; block size of <code>band</code>. GDAL has a concept of the natural block
size of rasters so that applications can organize data access efficiently
for some file formats. The natural block size is the block size that is
most efficient for accessing the format. For many formats this is simply a
whole row in which case block xsize is the same as <code>$getRasterXSize()</code>
and block ysize is 1. However, for tiled images block size will typically
be the tile size. Note that the X and Y block sizes don't have to divide
the image size evenly, meaning that right and bottom edge blocks may be
incomplete.
</p>
<p><code>$getActualBlockSize(band, xblockoff, yblockoff)</code>
Returns an integer vector of length two (xvalid, yvalid) containing the
actual block size for a given block offset in <code>band</code>. Handles partial
blocks at the edges of the raster and returns the true number of pixels.
<code>xblockoff</code> is an integer scalar, the horizontal block offset for which to
calculate the number of valid pixels, with zero indicating the left most
block, 1 the next block, etc. <code>yblockoff</code> is likewise the vertical block
offset, with zero indicating the top most block, 1 the next block, etc.
</p>
<p><code>$getOverviewCount(band)</code>
Returns the number of overview layers (a.k.a. pyramids) available for
<code>band</code>.
</p>
<p><code>$buildOverviews(resampling, levels, bands)</code>
Build one or more raster overview images using the specified downsampling
algorithm.
<code>resampling</code> is a character string, one of <code>AVERAGE</code>,
<code>AVERAGE_MAGPHASE</code>, <code>RMS</code>, <code>BILINEAR</code>, <code>CUBIC</code>, <code>CUBICSPLINE</code>, <code>GAUSS</code>,
<code>LANCZOS</code>, <code>MODE</code>, <code>NEAREST</code> or <code>NONE</code>.
<code>levels</code> is an integer vector giving the list of overview decimation
factors to build (e.g., <code>c(2, 4, 8)</code>), or <code>0</code> to delete all overviews
(at least for external overviews (.ovr) and GTiff internal overviews).
<code>bands</code> is an integer vector giving a list of band numbers to build
overviews for, or <code>0</code> to build for all bands.
Note that for GTiff, overviews will be created internally if the dataset is
open in update mode, while external overviews (.ovr) will be created if the
dataset is open read-only.
External overviews created in GTiff format may be compressed using the
<code>COMPRESS_OVERVIEW</code> configuration option. All compression methods supported
by the GTiff driver are available
(e.g., <code>set_config_option("COMPRESS_OVERVIEW", "LZW")</code>).
Since GDAL 3.6, <code>COMPRESS_OVERVIEW</code> is honoured when creating internal
overviews of GTiff files. The <a href="https://gdal.org/programs/gdaladdo.html">GDAL documentation for <code>gdaladdo</code></a> command-line utility
describes additional configuration for overview building.
See also <code><a href="#topic+set_config_option">set_config_option()</a></code>. No return value, called for side effects.
</p>
<p><code>$getDataTypeName(band)</code>
Returns the name of the pixel data type for <code>band</code>. The possible data
types are:
</p>

<table>
<tr>
 <td style="text-align: right;">
Unknown   </td><td style="text-align: left;">  Unknown or unspecified type</td>
</tr>
<tr>
 <td style="text-align: right;">
Byte      </td><td style="text-align: left;">  8-bit unsigned integer</td>
</tr>
<tr>
 <td style="text-align: right;">
Int8      </td><td style="text-align: left;">  8-bit signed integer (GDAL &gt;= 3.7)</td>
</tr>
<tr>
 <td style="text-align: right;">
UInt16    </td><td style="text-align: left;">  16-bit unsigned integer</td>
</tr>
<tr>
 <td style="text-align: right;">
Int16     </td><td style="text-align: left;">  16-bit signed integer</td>
</tr>
<tr>
 <td style="text-align: right;">
UInt32    </td><td style="text-align: left;">  32-bit unsigned integer</td>
</tr>
<tr>
 <td style="text-align: right;">
Int32     </td><td style="text-align: left;">  32-bit signed integer</td>
</tr>
<tr>
 <td style="text-align: right;">
UInt64    </td><td style="text-align: left;">  64-bit unsigned integer (GDAL &gt;= 3.5)</td>
</tr>
<tr>
 <td style="text-align: right;">
Int64     </td><td style="text-align: left;">  64-bit signed integer (GDAL &gt;= 3.5)</td>
</tr>
<tr>
 <td style="text-align: right;">
Float32   </td><td style="text-align: left;">  32-bit floating point</td>
</tr>
<tr>
 <td style="text-align: right;">
Float64   </td><td style="text-align: left;">  64-bit floating point</td>
</tr>
<tr>
 <td style="text-align: right;">
CInt16    </td><td style="text-align: left;">  Complex Int16</td>
</tr>
<tr>
 <td style="text-align: right;">
CInt32    </td><td style="text-align: left;">  Complex Int32</td>
</tr>
<tr>
 <td style="text-align: right;">
CFloat32  </td><td style="text-align: left;">  Complex Float32</td>
</tr>
<tr>
 <td style="text-align: right;">
CFloat64  </td><td style="text-align: left;">  Complex Float64
</td>
</tr>

</table>

<p>Some raster formats including GeoTIFF (&quot;GTiff&quot;) and Erdas Imagine .img
(&quot;HFA&quot;) support sub-byte data types. Rasters can be created with these
data types by specifying the &quot;NBITS=n&quot; creation option where n=1...7 for
GTiff or n=1/2/4 for HFA. In these cases, <code>$getDataTypeName()</code> reports
the apparent type <code>"Byte"</code>. GTiff also supports n=9...15 (UInt16 type) and
n=17...31 (UInt32 type), and n=16 is accepted for Float32 to generate
half-precision floating point values.
</p>
<p><code>$getNoDataValue(band)</code>
Returns the nodata value for <code>band</code> if one exists.
This is generally a special value defined to mark pixels that are not
valid data. <code>NA</code> is returned if a nodata value is not defined for
<code>band</code>. Not all raster formats support a designated nodata value.
</p>
<p><code>$setNoDataValue(band, nodata_value)</code>
Sets the nodata value for <code>band</code>.
<code>nodata_value</code> is a numeric value to be defined as the nodata marker.
Depending on the format, changing the nodata value may or may not have an
effect on the pixel values of a raster that has just been created (often
not). It is thus advised to call <code>$fillRaster()</code> explicitly if the
intent is to initialize the raster to the nodata value. In any case,
changing an existing nodata value, when one already exists on an initialized
dataset, has no effect on the pixels whose values matched the previous
nodata value.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the nodata value
could not be set.
</p>
<p><code>$deleteNoDataValue(band)</code>
Removes the nodata value for <code>band</code>.
This affects only the definition of the nodata value for raster formats
that support one (does not modify pixel values). No return value.
An error is raised if the nodata value cannot be removed.
</p>
<p><code>$getUnitType(band)</code>
Returns the name of the unit type of the pixel values for <code>band</code>
(e.g., &quot;m&quot; or &quot;ft&quot;).
An empty string <code>""</code> is returned if no units are available.
</p>
<p><code>$setUnitType(band, unit_type)</code>
Sets the name of the unit type of the pixel values for <code>band</code>.
<code>unit_type</code> should be one of empty string <code>""</code> (the default indicating it is
unknown), &quot;m&quot; indicating meters, or &quot;ft&quot; indicating feet, though other
nonstandard values are allowed.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the unit type
could not be set.
</p>
<p><code>$getScale(band)</code>
Returns the pixel value scale (units value = (raw value * scale) + offset)
for <code>band</code>.
This value (in combination with the <code>$getOffset()</code> value) can be used to
transform raw pixel values into the units returned by <code>$getUnitType()</code>.
Returns <code>NA</code> if a scale value is not defined for this <code>band</code>.
</p>
<p><code>$setScale(band, scale)</code>
Sets the pixel value scale (units value = (raw value * scale) + offset)
for <code>band</code>. Many raster formats do not implement this method.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the scale could
not be set.
</p>
<p><code>$getOffset(band)</code>
Returns the pixel value offset (units value = (raw value * scale) + offset)
for <code>band</code>.
This value (in combination with the <code>$getScale()</code> value) can be used to
transform raw pixel values into the units returned by <code>$getUnitType()</code>.
Returns <code>NA</code> if an offset value is not defined for this <code>band</code>.
</p>
<p><code>$setOffset(band, offset)</code>
Sets the pixel value offset (units value = (raw value * scale) + offset)
for <code>band</code>. Many raster formats do not implement this method.
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the offset could
not be set.
</p>
<p><code>$getRasterColorInterp(band)</code>
Returns a string describing the color interpretation for <code>band</code>.
The color interpretation values and their meanings are:
</p>

<table>
<tr>
 <td style="text-align: right;">
Undefined  </td><td style="text-align: left;"> Undefined</td>
</tr>
<tr>
 <td style="text-align: right;">
Gray       </td><td style="text-align: left;"> Grayscale</td>
</tr>
<tr>
 <td style="text-align: right;">
Palette    </td><td style="text-align: left;"> Paletted (see associated color table)</td>
</tr>
<tr>
 <td style="text-align: right;">
Red        </td><td style="text-align: left;"> Red band of RGBA image</td>
</tr>
<tr>
 <td style="text-align: right;">
Green      </td><td style="text-align: left;"> Green band of RGBA image</td>
</tr>
<tr>
 <td style="text-align: right;">
Blue       </td><td style="text-align: left;"> Blue band of RGBA image</td>
</tr>
<tr>
 <td style="text-align: right;">
Alpha      </td><td style="text-align: left;"> Alpha (0=transparent, 255=opaque)</td>
</tr>
<tr>
 <td style="text-align: right;">
Hue        </td><td style="text-align: left;"> Hue band of HLS image</td>
</tr>
<tr>
 <td style="text-align: right;">
Saturation </td><td style="text-align: left;"> Saturation band of HLS image</td>
</tr>
<tr>
 <td style="text-align: right;">
Lightness  </td><td style="text-align: left;"> Lightness band of HLS image</td>
</tr>
<tr>
 <td style="text-align: right;">
Cyan       </td><td style="text-align: left;"> Cyan band of CMYK image</td>
</tr>
<tr>
 <td style="text-align: right;">
Magenta    </td><td style="text-align: left;"> Magenta band of CMYK image</td>
</tr>
<tr>
 <td style="text-align: right;">
Yellow     </td><td style="text-align: left;"> Yellow band of CMYK image</td>
</tr>
<tr>
 <td style="text-align: right;">
Black      </td><td style="text-align: left;"> Black band of CMYK image</td>
</tr>
<tr>
 <td style="text-align: right;">
YCbCr_Y    </td><td style="text-align: left;"> Y Luminance</td>
</tr>
<tr>
 <td style="text-align: right;">
YCbCr_Cb   </td><td style="text-align: left;"> Cb Chroma</td>
</tr>
<tr>
 <td style="text-align: right;">
YCbCr_Cr   </td><td style="text-align: left;"> Cr Chroma
</td>
</tr>

</table>

<p><code>$setRasterColorInterp(band, col_interp)</code>
Sets the color interpretation for <code>band</code>. See above for the list of
valid values for <code>col_interp</code> (passed as a string).
</p>
<p><code>$getMinMax(band, approx_ok)</code>
Returns a numeric vector of length two containing the min/max values for
<code>band</code>. If <code>approx_ok</code> is <code>TRUE</code> and the raster format knows these
values intrinsically then those values will be returned. If that doesn't
work, a subsample of blocks will be read to get an approximate min/max. If
the band has a nodata value it will be excluded from the minimum and
maximum. If <code>approx_ok</code> is <code>FALSE</code>, then all pixels will be read and
used to compute an exact range.
</p>
<p><code>$getStatistics(band, approx_ok, force)</code>
Returns a numeric vector of length four containing the minimum, maximum,
mean and standard deviation of pixel values in <code>band</code> (excluding
nodata pixels). Some raster formats will cache statistics allowing fast
retrieval after the first request.
</p>
<p><code>approx_ok</code>:
</p>

<ul>
<li> <p><code>TRUE</code>: Approximate statistics are sufficient, in which case overviews
or a subset of raster tiles may be used in computing the statistics.
</p>
</li>
<li> <p><code>FALSE</code>: All pixels will be read and used to compute statistics (if
computation is forced).
</p>
</li></ul>

<p><code>force</code>:
</p>

<ul>
<li> <p><code>TRUE</code>: The raster will be scanned to compute statistics. Once computed,
statistics will generally be “set” back on the raster band if the format
supports caching statistics.
(Note: <code>ComputeStatistics()</code> in the GDAL API is called automatically here.
This is a change in the behavior of <code>GetStatistics()</code> in the API, to a
definitive <code>force</code>.)
</p>
</li>
<li> <p><code>FALSE</code>: Results will only be returned if it can be done quickly (i.e.,
without scanning the raster, typically by using pre-existing
STATISTICS_xxx metadata items). <code>NA</code>s will be returned if statistics
cannot be obtained quickly.
</p>
</li></ul>

<p><code>$clearStatistics()</code>
Clear statistics. Only implemented for now in PAM supported datasets
(Persistable Auxiliary Metadata via .aux.xml file). GDAL &gt;= 3.2.
</p>
<p><code>$getHistogram(band, min, max, num_buckets, incl_out_of_range,
  approx_ok)</code><br />
Computes raster histogram for <code>band</code>. <code>min</code> is the lower bound of
the histogram. <code>max</code> is the upper bound of the histogram.
<code>num_buckets</code> is the number of buckets to use (bucket size is
<code>(max - min) / num_buckets</code>).
<code>incl_out_of_range</code> is a logical scalar: if <code>TRUE</code> values below the
histogram range will be mapped into the first bucket and values above will
be mapped into the last bucket, if <code>FALSE</code> out of range values are discarded.
<code>approx_ok</code> is a logical scalar: <code>TRUE</code> if an approximate histogram is
OK (generally faster), or <code>FALSE</code> for an exactly computed histogram.
Returns the histogram as a numeric vector of length <code>num_buckets</code>.
</p>
<p><code>$getDefaultHistogram(band, force)</code>
Returns a default raster histogram for <code>band</code>. In the GDAL API, this
method is overridden by derived classes (such as GDALPamRasterBand,
VRTDataset, HFADataset...) that may be able to fetch efficiently an already
stored histogram. <code>force</code> is a logical scalar: <code>TRUE</code> to force the
computation of a default histogram; or if <code>FALSE</code> and no default histogram
is available, a warning is emitted and the returned list has a 0-length
histogram vector.
Returns a list of length four containing named elements <code style="white-space: pre;">&#8288;$min&#8288;</code> (lower
bound), <code style="white-space: pre;">&#8288;$max&#8288;</code> (upper bound), <code style="white-space: pre;">&#8288;$num_buckets&#8288;</code> (number of buckets), and
<code style="white-space: pre;">&#8288;$histogram&#8288;</code> (a numeric vector of length <code>num_buckets</code>).
</p>
<p><code>$getMetadata(band, domain)</code>
Returns a character vector of all metadata <code>name=value</code> pairs that exist in
the specified <code>domain</code>, or <code>""</code> (empty string) if there are no
metadata items in <code>domain</code> (metadata in the context of the GDAL
Raster Data Model: <a href="https://gdal.org/user/raster_data_model.html">https://gdal.org/user/raster_data_model.html</a>).
Set <code>band = 0</code> to retrieve dataset-level metadata, or to an integer
band number to retrieve band-level metadata.
Set <code>domain = ""</code> (empty string) to retrieve metadata in the
default domain.
</p>
<p><code>$getMetadataItem(band, mdi_name, domain)</code>
Returns the value of a specific metadata item named <code>mdi_name</code> in the
specified <code>domain</code>, or <code>""</code> (empty string) if no matching item
is found.
Set <code>band = 0</code> to retrieve dataset-level metadata, or to an integer
band number to retrieve band-level metadata.
Set <code>domain = ""</code> (empty string) to retrieve an item in the
default domain.
</p>
<p><code>$setMetadataItem(band, mdi_name, mdi_value, domain)</code>
Sets the value (<code>mdi_value</code>) of a specific metadata item named
<code>mdi_name</code> in the specified <code>domain</code>.
Set <code>band = 0</code> to set dataset-level metadata, or to an integer
band number to set band-level metadata.
Set <code>domain = ""</code> (empty string) to set an item in the default domain.
</p>
<p><code>$getMetadataDomainList(band)</code>
Returns a character vector of metadata domains or <code>""</code> (empty string).
Set <code>band = 0</code> to retrieve dataset-level domains, or to an integer
band number to retrieve band-level domains.
</p>
<p><code>$read(band, xoff, yoff, xsize, ysize, out_xsize, out_ysize)</code>
Reads a region of raster data from <code>band</code>. The method takes care of
pixel decimation / replication if the output size
(<code>out_xsize * out_ysize</code>) is different than the size of the region
being accessed (<code>xsize * ysize</code>).
<code>xoff</code> is the pixel (column) offset to the top left corner of the
region of the band to be accessed (zero to start from the left side).
<code>yoff</code> is the line (row) offset to the top left corner of the region of
the band to be accessed (zero to start from the top).
<em>Note that raster row/column offsets use 0-based indexing.</em>
<code>xsize</code> is the width in pixels of the region to be accessed.
<code>ysize</code> is the height in pixels of the region to be accessed.
<code>out_xsize</code> is the width of the output array into which the desired
region will be read (typically the same value as xsize).
<code>out_ysize</code> is the height of the output array into which the desired
region will be read (typically the same value as ysize).
Returns a numeric or complex vector containing the values that were read.
It is organized in left to right, top to bottom pixel order.
<code>NA</code> will be returned in place of the nodata value if the
raster dataset has a nodata value defined for this band.
Data are read as R integer type when possible for the raster data type
(<code>Byte</code>, <code>Int8</code>, <code>Int16</code>, <code>UInt16</code>, <code>Int32</code>), otherwise as type double
(<code>UInt32</code>, <code>Float32</code>, <code>Float64</code>).
No rescaling of the data is performed (see <code>$getScale()</code> and
<code>$getOffset()</code> above).
An error is raised if the read operation fails. See also the setting
<code style="white-space: pre;">&#8288;$readByteAsRaw&#8288;</code> above.
</p>
<p><code>$write(band, xoff, yoff, xsize, ysize, rasterData)</code>
Writes a region of raster data to <code>band</code>.
<code>xoff</code> is the pixel (column) offset to the top left corner of the
region of the band to be accessed (zero to start from the left side).
<code>yoff</code> is the line (row) offset to the top left corner of the region of
the band to be accessed (zero to start from the top).
<em>Note that raster row/column offsets use 0-based indexing.</em>
<code>xsize</code> is the width in pixels of the region to write.
<code>ysize</code> is the height in pixels of the region to write.
<code>rasterData</code> is a numeric or complex vector containing values to write.
It is organized in left to right, top to bottom pixel order. <code>NA</code> in
<code>rasterData</code> should be replaced with a suitable nodata value prior to
writing (see <code>$getNoDataValue()</code> and <code>$setNoDataValue()</code> above).
An error is raised if the operation fails (no return value).
</p>
<p><code>$getColorTable(band)</code>
Returns the color table associated with <code>band</code>, or <code>NULL</code> if
there is no associated color table. The color table is returned as an
integer matrix with five columns. To associate a color with a raster pixel,
the pixel value is used as a subscript into the color table. This means that
the colors are always applied starting at zero and ascending
(see <a href="https://gdal.org/user/raster_data_model.html#color-table">GDAL
Color Table</a>).
Column 1 contains the pixel values. Interpretation of columns 2:5 depends
on the value of <code style="white-space: pre;">&#8288;$getPaletteInterp()&#8288;</code> (see below). For &quot;RGB&quot;, columns 2:5
contain red, green, blue, alpha as 0-255 integer values.
</p>
<p><code>$getPaletteInterp(band)</code>
If <code>band</code> has an associated color table, this method returns a
character string with the palette interpretation for columns 2:5 of the
table. An empty string (<code>""</code>) is returned if <code>band</code> does not have
an associated color table. The palette interpretation values and their
meanings are:
</p>

<table>
<tr>
 <td style="text-align: right;">
Gray </td><td style="text-align: left;"> column 2 contains grayscale values (columns 3:5 unused)</td>
</tr>
<tr>
 <td style="text-align: right;">
RGB  </td><td style="text-align: left;"> columns 2:5 contain red, green, blue, alpha</td>
</tr>
<tr>
 <td style="text-align: right;">
CMYK </td><td style="text-align: left;"> columns 2:5 contain cyan, magenta, yellow, black</td>
</tr>
<tr>
 <td style="text-align: right;">
HLS  </td><td style="text-align: left;"> columns 2:4 contain hue, lightness, saturation (column 5 unused)
</td>
</tr>

</table>

<p><code>$setColorTable(band, col_tbl, palette_interp)</code>
Sets the raster color table for <code>band</code>
(see <a href="https://gdal.org/user/raster_data_model.html#color-table">GDAL
Color Table</a>).
<code>col_tbl</code> is an integer matrix or data frame with either four or five
columns (see <code>$getColorTable()</code> above). Column 1 contains the pixel
values. Valid values are integers 0 and larger (note that GTiff format
supports color tables only for Byte and UInt16 bands). Negative values
will be skipped with a warning emitted. Interpretation of columns 2:5
depends on the value of <code style="white-space: pre;">&#8288;$getPaletteInterp()&#8288;</code> (see above). For RGB,
columns 2:4 contain red, green, blue as 0-255 integer values, and an
optional column 5 contains alpha transparency values (defaults to 255
opaque).
<code>palette_interp</code> is a string, one of <code>Gray</code>, <code>RGB</code>, <code>CMYK</code> or <code>HLS</code>
(see <code>$getPaletteInterp()</code> above).
Returns logical <code>TRUE</code> on success or <code>FALSE</code> if the color table
could not be set.
</p>
<p><code>$getDefaultRAT(band)</code>
Returns the Raster Attribute Table for <code>band</code> as a data frame,
or <code>NULL</code> if there is no associated Raster Attribute Table. See the
stand-alone function <code><a href="#topic+buildRAT">buildRAT()</a></code> for details of the Raster Attribute Table
format.
</p>
<p><code>$setDefaultRAT(band, df)</code>
Sets a default Raster Attribute Table for <code>band</code> from data frame <code>df</code>.
The input data frame will be checked for attribute <code>"GDALRATTableType"</code>
which can have values of <code>"thematic"</code> or <code>"athematic"</code> (for continuous data).
Columns of the data frame will be checked for attribute <code>"GFU"</code> (for &quot;GDAL
field usage&quot;). If the <code>"GFU"</code> attribute is missing, a value of <code>"Generic"</code>
will be used (corresponding to <code>GFU_Generic</code> in the GDAL API, for general
purpose field). Columns with other, specific field usage values should
generally be present in <code>df</code>, such as fields containing the set of unique
(discrete) pixel values (GFU <code>"MinMax"</code>), pixel counts (GFU <code>"PixelCount"</code>),
class names (GFU <code>"Name"</code>), color values (GFUs <code>"Red"</code>, &quot;<code style="white-space: pre;">&#8288;Green"&#8288;</code>, <code>"Blue"</code>),
etc. The data frame will also be checked for attributes <code>"Row0Min"</code> and
<code>"BinSize"</code> which can have numeric values that describe linear binning.
See the stand-alone function <code><a href="#topic+buildRAT">buildRAT()</a></code> for details of the GDAL Raster
Attribute Table format and its representation as data frame.
</p>
<p><code>$flushCache()</code>
Flush all write cached data to disk. Any raster data written via GDAL calls,
but buffered internally will be written to disk. Using this method does not
preclude calling <code style="white-space: pre;">&#8288;$close()&#8288;</code> to properly close the dataset and ensure that
important data not addressed by <code style="white-space: pre;">&#8288;$flushCache()&#8288;</code> is written in the file
(see also <code style="white-space: pre;">&#8288;$open()&#8288;</code> above). No return value, called for side effect.
</p>
<p><code>$getChecksum(band, xoff, yoff, xsize, ysize)</code>
Returns a 16-bit integer (0-65535) checksum from a region of raster data
on <code>band</code>.
Floating point data are converted to 32-bit integer so decimal portions of
such raster data will not affect the checksum. Real and imaginary
components of complex bands influence the result.
<code>xoff</code> is the pixel (column) offset of the window to read.
<code>yoff</code> is the line (row) offset of the window to read.
<em>Raster row/column offsets use 0-based indexing.</em>
<code>xsize</code> is the width in pixels of the window to read.
<code>ysize</code> is the height in pixels of the window to read.
</p>
<p><code>$close()</code>
Closes the GDAL dataset (no return value, called for side effects).
Calling <code>$close()</code> results in proper cleanup, and flushing of any
pending writes. Forgetting to close a dataset opened in update mode on some
formats such as GTiff could result in being unable to open it afterwards.
The <code>GDALRaster</code> object is still available after calling <code>$close()</code>.
The dataset can be re-opened on the existing <code>filename</code> with
<code>$open(read_only=TRUE)</code> or <code>$open(read_only=FALSE)</code>.
</p>


<h3>Note</h3>

<p>If a dataset object is opened with update access (<code>read_only = FALSE</code>), it
is not recommended to open a new dataset on the same underlying <code>filename</code>.
</p>
<p>Datasets are opened in shared mode by default. This allows the sharing of
<code>GDALDataset</code> handles for a dataset with other callers that open shared on
the same <code>filename</code>, if the dataset is opened from the same thread.
Functions in <code>gdalraster</code> that do processing will open input datasets in
shared mode. This provides potential efficiency for cases when an object of
class <code>GDALRaster</code> is already open in read-only mode on the same <code>filename</code>
(avoids overhead associated with initial dataset opening by using the
existing handle, and potentially makes use of existing data in the GDAL
block cache). Opening in shared mode can be disabled by specifying the
optional <code>shared</code> parameter in the class constructor.
</p>
<p>The <code style="white-space: pre;">&#8288;$read()&#8288;</code> method will perform automatic resampling if the
specified output size (<code>out_xsize * out_ysize</code>) is different than
the size of the region being read (<code>xsize * ysize</code>). In that case, the
<code>GDAL_RASTERIO_RESAMPLING</code> configuration option could also be set to
override the default resampling to one of <code>BILINEAR</code>, <code>CUBIC</code>,
<code>CUBICSPLINE</code>, <code>LANCZOS</code>, <code>AVERAGE</code> or <code>MODE</code> (see <code><a href="#topic+set_config_option">set_config_option()</a></code>).
</p>


<h3>See Also</h3>

<p>Package overview in <code><a href="#topic+gdalraster-package">help(&quot;gdalraster-package&quot;)</a></code>
</p>
<p><code>vignette("raster-api-tutorial")</code>
</p>
<p><code><a href="#topic+read_ds">read_ds()</a></code> convenience wrapper for <code>GDALRaster$read()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, lcp_file)

## print information about the dataset to the console
ds$info()

## retrieve the raster format name
ds$getDriverShortName()
ds$getDriverLongName()

## retrieve a list of files composing the dataset
ds$getFileList()

## retrieve dataset parameters
ds$getRasterXSize()
ds$getRasterYSize()
ds$getGeoTransform()
ds$getProjection()
ds$getRasterCount()
ds$bbox()
ds$res()
ds$dim()

## retrieve some band-level parameters
ds$getDescription(band = 1)
ds$getBlockSize(band = 1)
ds$getOverviewCount(band = 1)
ds$getDataTypeName(band = 1)
# LCP format does not support an intrinsic nodata value so this returns NA:
ds$getNoDataValue(band = 1)

## LCP driver reports several dataset- and band-level metadata
## see the format description at https://gdal.org/drivers/raster/lcp.html
## set band = 0 to retrieve dataset-level metadata
## set domain = "" (empty string) for the default metadata domain
ds$getMetadata(band = 0, domain = "")

## retrieve metadata for a band as a vector of name=value pairs
ds$getMetadata(band = 4, domain = "")

## retrieve the value of a specific metadata item
ds$getMetadataItem(band = 2, mdi_name = "SLOPE_UNIT_NAME", domain = "")

## read one row of pixel values from band 1 (elevation)
## raster row/column index are 0-based
## the upper left corner is the origin
## read the tenth row:
ncols &lt;- ds$getRasterXSize()
rowdata &lt;- ds$read(band = 1, xoff = 0, yoff = 9,
                   xsize = ncols, ysize = 1,
                   out_xsize = ncols, out_ysize = 1)
head(rowdata)

ds$close()

## create a new raster using lcp_file as a template
new_file &lt;- file.path(tempdir(), "storml_newdata.tif")
rasterFromRaster(srcfile = lcp_file,
                 dstfile = new_file,
                 nbands = 1,
                 dtName = "Byte",
                 init = -9999)

ds_new &lt;- new(GDALRaster, new_file, read_only = FALSE)

## write random values to all pixels
set.seed(42)
ncols &lt;- ds_new$getRasterXSize()
nrows &lt;- ds_new$getRasterYSize()
for (row in 0:(nrows - 1)) {
    rowdata &lt;- round(runif(ncols, 0, 100))
    ds_new$write(band = 1,
                 xoff = 0,
                 yoff = row,
                 xsize = ncols,
                 ysize = 1,
                 rowdata)
}

## re-open in read-only mode when done writing
## this will ensure flushing of any pending writes (implicit $close)
ds_new$open(read_only = TRUE)

## getStatistics returns min, max, mean, sd, and sets stats in the metadata
ds_new$getStatistics(band = 1, approx_ok = FALSE, force = TRUE)
ds_new$getMetadataItem(band = 1, "STATISTICS_MEAN", "")

## close the dataset for proper cleanup
ds_new$close()
deleteDataset(new_file)


## using a GDAL Virtual File System handler '/vsicurl/'
## see: https://gdal.org/user/virtual_file_systems.html
url &lt;- "/vsicurl/https://raw.githubusercontent.com/"
url &lt;- paste0(url, "usdaforestservice/gdalraster/main/sample-data/")
url &lt;- paste0(url, "lf_elev_220_mt_hood_utm.tif")

set_config_option("GDAL_HTTP_CONNECTTIMEOUT", "20")
set_config_option("GDAL_HTTP_TIMEOUT", "20")
if (http_enabled() &amp;&amp; vsi_stat(url)) {
  ds &lt;- new(GDALRaster, url)
  plot_raster(ds, legend = TRUE, main = "Mount Hood elevation (m)")
  ds$close()
}
set_config_option("GDAL_HTTP_CONNECTTIMEOUT", "")
set_config_option("GDAL_HTTP_TIMEOUT", "")

</code></pre>

<hr>
<h2 id='geos_version'>Get GEOS version</h2><span id='topic+geos_version'></span>

<h3>Description</h3>

<p><code>geos_version()</code> returns version information for the GEOS library in use by
GDAL. Requires GDAL &gt;= 3.4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geos_version()
</code></pre>


<h3>Value</h3>

<p>A list of length four containing:
</p>

<ul>
<li> <p><code>name</code> - a string formatted as &quot;major.minor.patch&quot;
</p>
</li>
<li> <p><code>major</code> - major version as integer
</p>
</li>
<li> <p><code>minor</code> - minor version as integer
</p>
</li>
<li> <p><code>patch</code> - patch version as integer
</p>
</li></ul>

<p>List elements will be <code>NA</code> if GDAL &lt; 3.4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdal_version">gdal_version()</a></code>, <code><a href="#topic+proj_version">proj_version()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geos_version()
</code></pre>

<hr>
<h2 id='get_cache_used'>Get the size of memory in use by the GDAL block cache</h2><span id='topic+get_cache_used'></span>

<h3>Description</h3>

<p><code>get_cache_used()</code> returns the amount of memory currently in use for
GDAL block caching. This a wrapper for <code>GDALGetCacheUsed64()</code> with return
value as MB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cache_used()
</code></pre>


<h3>Value</h3>

<p>Integer. Amount of cache memory in use in MB.
</p>


<h3>See Also</h3>

<p><a href="https://usdaforestservice.github.io/gdalraster/articles/gdal-block-cache.html">GDAL Block Cache</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_cache_used()
</code></pre>

<hr>
<h2 id='get_config_option'>Get GDAL configuration option</h2><span id='topic+get_config_option'></span>

<h3>Description</h3>

<p><code>get_config_option()</code> gets the value of GDAL runtime configuration option.
Configuration options are essentially global variables the user can set.
They are used to alter the default behavior of certain raster format
drivers, and in some cases the GDAL core. For a full description and
listing of available options see
<a href="https://gdal.org/user/configoptions.html">https://gdal.org/user/configoptions.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_config_option(key)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_config_option_+3A_key">key</code></td>
<td>
<p>Character name of a configuration option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. The value of a (key, value) option previously set with
<code>set_config_option()</code>. An empty string (<code>""</code>) is returned if <code>key</code> is not
found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_config_option">set_config_option()</a></code>
</p>
<p><code>vignette("gdal-config-quick-ref")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this option is set during initialization of the gdalraster package
get_config_option("OGR_CT_FORCE_TRADITIONAL_GIS_ORDER")
</code></pre>

<hr>
<h2 id='get_num_cpus'>Get the number of processors detected by GDAL</h2><span id='topic+get_num_cpus'></span>

<h3>Description</h3>

<p><code>get_num_cpus()</code> returns the number of processors detected by GDAL.
Wrapper of <code>CPLGetNumCPUs()</code> in the GDAL Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_num_cpus()
</code></pre>


<h3>Value</h3>

<p>Integer scalar, number of CPUs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_num_cpus()
</code></pre>

<hr>
<h2 id='get_pixel_line'>Raster pixel/line from geospatial x,y coordinates</h2><span id='topic+get_pixel_line'></span>

<h3>Description</h3>

<p><code>get_pixel_line()</code> converts geospatial coordinates to pixel/line (raster
column, row numbers).
The upper left corner pixel is the raster origin (0,0) with column, row
increasing left to right, top to bottom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pixel_line(xy, gt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pixel_line_+3A_xy">xy</code></td>
<td>
<p>Numeric matrix of geospatial x,y coordinates in the same spatial
reference system as <code>gt</code> (or two-column data frame that will be coerced
to numeric matrix).</p>
</td></tr>
<tr><td><code id="get_pixel_line_+3A_gt">gt</code></td>
<td>
<p>Either a numeric vector of length six containing the affine
geotransform for the raster, or an object of class <code>GDALRaster</code> from
which the geotransform will be obtained (see Note).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix of raster pixel/line.
</p>


<h3>Note</h3>

<p>This function applies the inverse geotransform to the input points. If <code>gt</code>
is given as the numeric vector, no bounds checking is done (i.e., min
pixel/line could be less than zero and max pixel/line could be greater than
the raster x/y size). If <code>gt</code> is obtained from an object of class
<code>GDALRaster</code>, then <code>NA</code> is returned for points that fall outside the
raster extent and a warning emitted giving the number points that were
outside. This latter case is equivalent to calling the <code style="white-space: pre;">&#8288;$get_pixel_line()&#8288;</code>
class method on the <code>GDALRaster</code> object (see Examples).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$getGeoTransform()</a></code>, <code><a href="#topic+inv_geotransform">inv_geotransform()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt_file &lt;- system.file("extdata/storml_pts.csv", package="gdalraster")
# id, x, y in NAD83 / UTM zone 12N
pts &lt;- read.csv(pt_file)
print(pts)

raster_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, raster_file)
gt &lt;- ds$getGeoTransform()
get_pixel_line(pts[, -1], gt)

# or, using the class method
ds$get_pixel_line(pts[, -1])

# add a point outside the raster extent
pts[11, ] &lt;- c(11, 323318, 5105104)
get_pixel_line(pts[, -1], gt)

# with bounds checking on the raster extent
ds$get_pixel_line(pts[, -1])

ds$close()
</code></pre>

<hr>
<h2 id='get_usable_physical_ram'>Get usable physical RAM reported by GDAL</h2><span id='topic+get_usable_physical_ram'></span>

<h3>Description</h3>

<p><code>get_usable_physical_ram()</code> returns the total physical RAM, usable by a
process, in bytes. It will limit to 2 GB for 32 bit processes. Starting
with GDAL 2.4.0, it will also take into account resource limits (virtual
memory) on Posix systems. Starting with GDAL 3.6.1, it will also take into
account RLIMIT_RSS on Linux. Wrapper of <code>CPLGetUsablePhysicalRAM()</code> in the
GDAL Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_usable_physical_ram()
</code></pre>


<h3>Value</h3>

<p>Numeric scalar, number of bytes as <code>bit64::integer64</code> type (or 0 in
case of failure).
</p>


<h3>Note</h3>

<p>This memory may already be partly used by other processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_usable_physical_ram()
</code></pre>

<hr>
<h2 id='getCreationOptions'>Return the list of creation options of a GDAL driver</h2><span id='topic+getCreationOptions'></span>

<h3>Description</h3>

<p><code>getCreationOptions()</code> returns the list of creation options supported by a
GDAL format driver as an XML string (invisibly).
Wrapper for <code>GDALGetDriverCreationOptionList()</code> in the GDAL API.
Information about the available creation options is also printed to the
console by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCreationOptions(format, filter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCreationOptions_+3A_format">format</code></td>
<td>
<p>Raster format short name (e.g., &quot;GTiff&quot;).</p>
</td></tr>
<tr><td><code id="getCreationOptions_+3A_filter">filter</code></td>
<td>
<p>Optional character vector of creation option names. Controls
only the amount of information printed to the console.
By default, information for all creation options is printed. Can be set to
empty string <code>""</code> to disable printing information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, an XML string that describes the full list of creation
options or empty string <code>""</code> (full output of
<code>GDALGetDriverCreationOptionList()</code> in the GDAL API).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getCreationOptions("GTiff", filter="COMPRESS")
</code></pre>

<hr>
<h2 id='has_geos'>Is GEOS available?</h2><span id='topic+has_geos'></span>

<h3>Description</h3>

<p><code>has_geos()</code> returns a logical value indicating whether GDAL was built
against the GEOS library. GDAL built with GEOS is a system requirement
as of <code>gdalraster</code> 1.10.0, so this function will always return <code>TRUE</code>
(may be removed in a future version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_geos()
</code></pre>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if GEOS is available, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_geos()
</code></pre>

<hr>
<h2 id='has_spatialite'>Is SpatiaLite available?</h2><span id='topic+has_spatialite'></span>

<h3>Description</h3>

<p><code>has_spatialite()</code> returns a logical value indicating whether GDAL was
built with support for the SpatiaLite library. SpatiaLite extends the
SQLite core to support full Spatial SQL capabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_spatialite()
</code></pre>


<h3>Details</h3>

<p>GDAL supports executing SQL statements against a datasource. For most file
formats (e.g. Shapefiles, GeoJSON, FlatGeobuf files), the built-in OGR SQL
dialect will be used by default. It is also possible to request the
alternate <code>"SQLite"</code>  dialect, which will use the SQLite engine to evaluate
commands on GDAL datasets. This assumes that GDAL is built with support for
SQLite, and preferably with Spatialite support too to benefit from spatial
functions.
</p>


<h3>Value</h3>

<p>Logical scalar. <code>TRUE</code> if SpatiaLite is available to GDAL.
</p>


<h3>Note</h3>

<p>All GDAL/OGR drivers for database systems, e.g., PostgreSQL / PostGIS,
Oracle Spatial, SQLite / Spatialite RDBMS, GeoPackage, etc., override the
<code>GDALDataset::ExecuteSQL()</code> function with a dedicated implementation and, by
default, pass the SQL statements directly to the underlying RDBMS. In these
cases the SQL syntax varies in some particulars from OGR SQL. Also, anything
possible in SQL can then be accomplished for these particular databases. For
those drivers, it is also possible to explicitly request the <code>OGRSQL</code> or
<code>SQLite</code> dialects, although performance will generally be much less than the
native SQL engine of those database systems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ogrinfo">ogrinfo()</a></code>, <code><a href="#topic+ogr_execute_sql">ogr_execute_sql()</a></code>
</p>
<p>OGR SQL dialect and SQLITE SQL dialect:<br />
<a href="https://gdal.org/user/ogr_sql_sqlite_dialect.html">https://gdal.org/user/ogr_sql_sqlite_dialect.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_spatialite()
</code></pre>

<hr>
<h2 id='http_enabled'>Check if GDAL CPLHTTP services can be useful (libcurl)</h2><span id='topic+http_enabled'></span>

<h3>Description</h3>

<p><code>http_enabled()</code> returns <code>TRUE</code> if <code>libcurl</code> support is enabled.
Wrapper of <code>CPLHTTPEnabled()</code> in the GDAL Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_enabled()
</code></pre>


<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> if GDAL was built with <code>libcurl</code> support.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>http_enabled()
</code></pre>

<hr>
<h2 id='inv_geotransform'>Invert geotransform</h2><span id='topic+inv_geotransform'></span>

<h3>Description</h3>

<p><code>inv_geotransform()</code> inverts a vector of geotransform coefficients. This
converts the equation from being:<br />
raster pixel/line (column/row) -&gt; geospatial x/y coordinate<br />
to:<br />
geospatial x/y coordinate -&gt; raster pixel/line (column/row)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_geotransform(gt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_geotransform_+3A_gt">gt</code></td>
<td>
<p>Numeric vector of length six containing the geotransform to
invert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length six containing the inverted
geotransform. The output vector will contain NAs if the input geotransform
is uninvertable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$getGeoTransform()</a></code>, <code><a href="#topic+get_pixel_line">get_pixel_line()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)
invgt &lt;- ds$getGeoTransform() |&gt; inv_geotransform()
ds$close()

ptX = 324181.7
ptY = 5103901.4

## for a point x, y in the spatial reference system of elev_file
## raster pixel (column number):
pixel &lt;- floor(invgt[1] +
               invgt[2] * ptX +
               invgt[3] * ptY)

## raster line (row number):
line &lt;- floor(invgt[4] +
              invgt[5] * ptX +
              invgt[6] * ptY)

## get_pixel_line() applies this conversion
</code></pre>

<hr>
<h2 id='inv_project'>Inverse project geospatial x/y coordinates to longitude/latitude</h2><span id='topic+inv_project'></span>

<h3>Description</h3>

<p><code>inv_project()</code> transforms geospatial x/y coordinates to
longitude/latitude in the same geographic coordinate system used by the
given projected spatial reference system. The output long/lat can
optionally be set to a specific geographic coordinate system by specifying
a well known name (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_project(pts, srs, well_known_gcs = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_project_+3A_pts">pts</code></td>
<td>
<p>A two-column data frame or numeric matrix containing geospatial
x/y coordinates.</p>
</td></tr>
<tr><td><code id="inv_project_+3A_srs">srs</code></td>
<td>
<p>Character string in OGC WKT format specifying the projected
spatial reference system for <code>pts</code>.</p>
</td></tr>
<tr><td><code id="inv_project_+3A_well_known_gcs">well_known_gcs</code></td>
<td>
<p>Optional character string containing a supported
well known name of a geographic coordinate system (see Details for
supported values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the geographic coordinate system of the projection specified
by <code>srs</code> will be used. If a specific geographic coordinate system is
desired, then <code>well_known_gcs</code> can be set to one of the values below:
</p>

<table>
<tr>
 <td style="text-align: right;">
EPSG:n </td><td style="text-align: left;"> where n is the code of a geographic coordinate system</td>
</tr>
<tr>
 <td style="text-align: right;">
WGS84  </td><td style="text-align: left;"> same as EPSG:4326</td>
</tr>
<tr>
 <td style="text-align: right;">
WGS72  </td><td style="text-align: left;"> same as EPSG:4322</td>
</tr>
<tr>
 <td style="text-align: right;">
NAD83  </td><td style="text-align: left;"> same as EPSG:4269</td>
</tr>
<tr>
 <td style="text-align: right;">
NAD27  </td><td style="text-align: left;"> same as EPSG:4267</td>
</tr>
<tr>
 <td style="text-align: right;">
CRS84  </td><td style="text-align: left;"> same as WGS84</td>
</tr>
<tr>
 <td style="text-align: right;">
CRS72  </td><td style="text-align: left;"> same as WGS72</td>
</tr>
<tr>
 <td style="text-align: right;">
CRS27  </td><td style="text-align: left;"> same as NAD27
</td>
</tr>

</table>

<p>The returned array will always be in longitude, latitude order
(traditional GIS order) regardless of the axis order defined for the
names above.
</p>


<h3>Value</h3>

<p>Numeric array of longitude, latitude. An error is raised if the
transformation cannot be performed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transform_xy">transform_xy()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt_file &lt;- system.file("extdata/storml_pts.csv", package="gdalraster")
## id, x, y in NAD83 / UTM zone 12N
pts &lt;- read.csv(pt_file)
print(pts)
inv_project(pts[,-1], epsg_to_wkt(26912))
inv_project(pts[,-1], epsg_to_wkt(26912), "NAD27")
</code></pre>

<hr>
<h2 id='ogr_define'>OGR feature class definition for vector data</h2><span id='topic+ogr_define'></span><span id='topic+ogr_def_field'></span><span id='topic+ogr_def_geom_field'></span><span id='topic+ogr_def_layer'></span>

<h3>Description</h3>

<p>This topic contains documentation and helper functions for defining an
OGR feature class.
<code>ogr_def_field()</code> creates an attribute field definition, a list
containing the field data type and potentially other optional field
properties.
<code>ogr_def_geom_field()</code> similarly creates a geometry field definition.
A list containing zero or more attribute field definitions, along with one
or more geometry field definitions, comprise an OGR feature class definition
(a.k.a. layer definition). <code>ogr_def_layer()</code> initializes such a list with a
geometry field. Attribute fields can be added to a feature class definition
with calls to <code>ogr_def_field()</code> as in the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ogr_def_field(
  fld_type,
  fld_subtype = NULL,
  fld_width = NULL,
  fld_precision = NULL,
  is_nullable = NULL,
  is_unique = NULL,
  is_ignored = NULL,
  default_value = NULL
)

ogr_def_geom_field(
  geom_type,
  srs = NULL,
  is_nullable = NULL,
  is_ignored = NULL
)

ogr_def_layer(geom_type, geom_fld_name = "geom", srs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ogr_define_+3A_fld_type">fld_type</code></td>
<td>
<p>Character string containing the name of a field data type
(e.g., <code>OFTInteger</code>, <code>OFTReal</code>, <code>OFTString</code>).</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_fld_subtype">fld_subtype</code></td>
<td>
<p>Character string containing the name of a field subtype.
One of  <code>OFSTNone</code> (the default), <code>OFSTBoolean</code>, <code>OFSTInt16</code>, <code>OFSTFloat32</code>,
<code>OFSTJSON</code>, <code>OFSTUUID</code>.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_fld_width">fld_width</code></td>
<td>
<p>Optional integer scalar specifying max number of characters.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_fld_precision">fld_precision</code></td>
<td>
<p>Optional integer scalar specifying number of digits
after the decimal point.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_is_nullable">is_nullable</code></td>
<td>
<p>Optional NOT NULL field constraint (logical scalar).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_is_unique">is_unique</code></td>
<td>
<p>Optional UNIQUE constraint on the field (logical scalar).
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_is_ignored">is_ignored</code></td>
<td>
<p>Whether field is ignored when retrieving features (logical
scalar). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_default_value">default_value</code></td>
<td>
<p>Optional default value for the field as a character
string.</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_geom_type">geom_type</code></td>
<td>
<p>Character string specifying a geometry type (see Details).</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_srs">srs</code></td>
<td>
<p>Character string containing a spatial reference system definition
as OGC WKT or other well-known format (e.g., the input formats usable with
<code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>).</p>
</td></tr>
<tr><td><code id="ogr_define_+3A_geom_fld_name">geom_fld_name</code></td>
<td>
<p>Character string specifying a geometry field name
Defaults to <code>"geometry"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All features in an OGR Layer share a common schema (feature class), modeled
in GDAL as OGR Feature Definition. The feature class definition includes the
set of attribute fields and their data types and the geometry field(s).
In R, a feature class definition is represented as a list, having as names
the attribute/geometry field names, with each list element holding a field
definition.
</p>
<p>An attribute field definition is a list with named elements:
</p>
<div class="sourceCode"><pre>$type       : OGR Field Type ("OFTReal", "OFTString" etc.)
$subtype    : optional ("OFSTBoolean", ...)
$width      : optional max number of characters
$precision  : optional number of digits after the decimal point
$is_nullable: optional NOT NULL constraint (logical scalar)
$is_unique  : optional UNIQUE constraint (logical scalar)
$default    : optional default value as character string
$is_ignored : optionally ignored when retrieving features (logical scalar)
$is_geom    : FALSE (the default) for attribute fields
</pre></div>
<p>An OGR field type is specified as a character string with possible values:
<code>OFTInteger</code>, <code>OFTIntegerList</code>, <code>OFTReal</code>, <code>OFTRealList</code>, <code>OFTString</code>,
<code>OFTStringList</code>, <code>OFTBinary</code>,  <code>OFTDate</code>, <code>OFTTime</code>, <code>OFTDateTime</code>,
<code>OFTInteger64</code>, <code>OFTInteger64List</code>.
</p>
<p>An optional field subtype is specified as a character string with possible
values:
<code>OFSTNone</code>, <code>OFSTBoolean</code>, <code>OFSTInt16</code>, <code>OFSTFloat32</code>, <code>OFSTJSON</code>,
<code>OFSTUUID</code>.
</p>
<p>By default, fields are nullable, have no unique constraint, and are not
ignored (i.e., not omitted when fetching features). Not-null and unique
constraints are not supported by all format drivers.
</p>
<p>A default field value is taken into account by format drivers (generally
those with a SQL interface) that support it at field creation time.
If given in the field definition, <code style="white-space: pre;">&#8288;$default&#8288;</code> must be a character string.
The accepted values are <code>"NULL"</code>, a numeric value (e.g., <code>"0"</code>), a literal
value enclosed between single quote characters (e.g., <code>"'a default value'"</code>,
with any inner single quote characters escaped by repetition of the single
quote character), <code>"CURRENT_TIMESTAMP"</code>, <code>"CURRENT_TIME"</code>, <code>"CURRENT_DATE"</code>
or a driver-specific expression (that might be ignored by other drivers).
For a datetime literal value, format should be
<code>"'YYYY/MM/DD HH:MM:SS[.sss]'"</code> (considered as UTC time).
</p>
<p>A geometry field definition is a list with named elements:
</p>
<div class="sourceCode"><pre>$type       : geom type ("Point", "Polygon", etc.)
$srs        : optional spatial reference as WKT string
$is_nullable: optional NOT NULL constraint (logical scalar)
$is_ignored : optionally ignored when retrieving features (logical scalar)
$is_geom    : TRUE (required) for geometry fields
</pre></div>
<p>Typically, there is one geometry field on a layer, but some formats support
more than one geometry column per table (e.g., PostGIS).
</p>
<p>Geometry types are specified as a character string containing OGC WKT.
Common types include: <code>Point</code>, <code>LineString</code>, <code>Polygon</code>, <code>MultiPoint</code>,
<code>MultiLineString</code>, <code>MultiPolygon</code>. See the GDAL documentation for a list
of all supported geometry types:<br />
<a href="https://gdal.org/api/vector_c_api.html#_CPPv418OGRwkbGeometryType">https://gdal.org/api/vector_c_api.html#_CPPv418OGRwkbGeometryType</a>
</p>
<p>Format drivers may or may not support not-null constraints on attribute and
geometry fields. If they support creating fields with not-null constraints,
this is generally before creating any features to the layer. In some cases,
a not-null constraint may be available as a layer creation option. For
example, GeoPackage format has a layer creation option
<code style="white-space: pre;">&#8288;GEOMETRY_NULLABLE=[YES/NO]&#8288;</code>.
</p>


<h3>Note</h3>

<p>The feature id (FID) is a special property of a feature and not treated as
an attribute of the feature. Additional information is given in the GDAL
documentation for the
<a href="https://gdal.org/user/ogr_sql_dialect.html#feature-id-fid">OGR SQL</a> and
<a href="https://gdal.org/user/sql_sqlite_dialect.html#feature-id-fid">SQLite</a>
SQL dialects. Implications for SQL statements and result sets may depend
on the dialect used.
</p>
<p>Some vector formats do not support schema definition prior to creating
features. For example, with GeoJSON only the <em>Feature</em> object has a member
with name <em>properties</em>. The specification does not require all <em>Feature</em>
objects in a collection to have the same schema of properties, nor does
it require all <em>Feature</em> objects in a collection to have geometry of the
same type (<a href="https://geojson.org/">https://geojson.org/</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ogr_ds_create">ogr_ds_create()</a></code>, <code><a href="#topic+ogr_layer_create">ogr_layer_create()</a></code>, <code><a href="#topic+ogr_field_create">ogr_field_create()</a></code>, <code><a href="#topic+ogrinfo">ogrinfo()</a></code>
</p>
<p>WKT representation of geometry:<br />
<a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsn &lt;- file.path(tempdir(), "test.sqlite")
opt &lt;- NULL
if (has_spatialite())
  opt &lt;- "SPATIALITE=YES"
ogr_ds_create("SQLite", dsn, dsco = opt)

# define a layer
defn &lt;- ogr_def_layer("Point", srs = epsg_to_wkt(4326))
defn$fld1_int64 &lt;- ogr_def_field("OFTInteger64")
defn$fld2_string &lt;- ogr_def_field("OFTString")

if (ogr_ds_test_cap(dsn)$CreateLayer)
  ogr_layer_create(dsn, "layer1", layer_defn = defn)

ogr_ds_layer_names(dsn)
ogr_layer_field_names(dsn, "layer1")

deleteDataset(dsn)
</code></pre>

<hr>
<h2 id='ogr_manage'>Utility functions for managing vector data sources</h2><span id='topic+ogr_manage'></span><span id='topic+ogr_ds_exists'></span><span id='topic+ogr_ds_format'></span><span id='topic+ogr_ds_test_cap'></span><span id='topic+ogr_ds_create'></span><span id='topic+ogr_ds_layer_count'></span><span id='topic+ogr_ds_layer_names'></span><span id='topic+ogr_layer_exists'></span><span id='topic+ogr_layer_test_cap'></span><span id='topic+ogr_layer_create'></span><span id='topic+ogr_layer_field_names'></span><span id='topic+ogr_layer_delete'></span><span id='topic+ogr_field_index'></span><span id='topic+ogr_field_create'></span><span id='topic+ogr_geom_field_create'></span><span id='topic+ogr_field_rename'></span><span id='topic+ogr_field_delete'></span><span id='topic+ogr_execute_sql'></span>

<h3>Description</h3>

<p>This set of functions can be used to create new vector datasets,
test existence of dataset/layer/field, test dataset and layer capabilities,
create new layers in an existing dataset, delete layers, create new
attribute and geometry fields on an existing layer, rename and delete
fields, and edit data with SQL statements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ogr_ds_exists(dsn, with_update = FALSE)

ogr_ds_format(dsn)

ogr_ds_test_cap(dsn, with_update = TRUE)

ogr_ds_create(
  format,
  dsn,
  layer = NULL,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  fld_name = NULL,
  fld_type = NULL,
  dsco = NULL,
  lco = NULL,
  overwrite = FALSE
)

ogr_ds_layer_count(dsn)

ogr_ds_layer_names(dsn)

ogr_layer_exists(dsn, layer)

ogr_layer_test_cap(dsn, layer, with_update = TRUE)

ogr_layer_create(
  dsn,
  layer,
  layer_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  lco = NULL
)

ogr_layer_field_names(dsn, layer)

ogr_layer_delete(dsn, layer)

ogr_field_index(dsn, layer, fld_name)

ogr_field_create(
  dsn,
  layer,
  fld_name,
  fld_defn = NULL,
  fld_type = "OFTInteger",
  fld_subtype = "OFSTNone",
  fld_width = 0L,
  fld_precision = 0L,
  is_nullable = TRUE,
  is_ignored = FALSE,
  is_unique = FALSE,
  default_value = ""
)

ogr_geom_field_create(
  dsn,
  layer,
  fld_name,
  geom_fld_defn = NULL,
  geom_type = NULL,
  srs = NULL,
  is_nullable = TRUE,
  is_ignored = FALSE
)

ogr_field_rename(dsn, layer, fld_name, new_name)

ogr_field_delete(dsn, layer, fld_name)

ogr_execute_sql(dsn, sql, spatial_filter = NULL, dialect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ogr_manage_+3A_dsn">dsn</code></td>
<td>
<p>Character string. The vector data source name, e.g., a filename
or database connection string.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_with_update">with_update</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to request update access when
opening the dataset, or <code>FALSE</code> to open read-only.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_format">format</code></td>
<td>
<p>GDAL short name of the vector format as character string.
Examples of some common output formats include: <code>"GPKG"</code>, <code>"FlatGeobuf"</code>,
<code>"ESRI Shapefile"</code>, <code>"SQLite"</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_layer">layer</code></td>
<td>
<p>Character string for a layer name in a vector dataset.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_layer_defn">layer_defn</code></td>
<td>
<p>A feature class definition for <code>layer</code> as a list of
zero or more attribute field definitions, and at least one geometry field
definition (see <a href="#topic+ogr_define">ogr_define</a>).
Each field definition is a list with named elements containing values for
the field <code style="white-space: pre;">&#8288;$type&#8288;</code> and other properties.
If <code>layer_defn</code> is given, it will be used and any additional parameters
passed that relate to the feature class definition will be ignored (i.e.,
<code>geom_type</code> and <code>srs</code>, as well as <code>fld_name</code> and <code>fld_type</code> in
<code>ogr_ds_create()</code>).
The first geometry field definition in <code>layer_defn</code> defines the
geometry type and spatial reference system for the layer (the geom field
definition must contain <code style="white-space: pre;">&#8288;$type&#8288;</code>, and should also contain <code style="white-space: pre;">&#8288;$srs&#8288;</code> when
creating a layer from a feature class definition).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_geom_type">geom_type</code></td>
<td>
<p>Character string specifying a geometry type (see Details).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_srs">srs</code></td>
<td>
<p>Character string containing a spatial reference system definition
as OGC WKT or other well-known format (e.g., the input formats usable with
<code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_name">fld_name</code></td>
<td>
<p>Character string containing the name of an attribute field
in <code>layer</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_type">fld_type</code></td>
<td>
<p>Character string containing the name of a field data type
(e.g., <code>OFTInteger</code>, <code>OFTReal</code>, <code>OFTString</code>).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_dsco">dsco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>dsn</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_lco">lco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>layer</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to overwrite <code>dsn</code> if it already
exists when calling <code>ogr_ds_create()</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_defn">fld_defn</code></td>
<td>
<p>A field definition as list (see <code><a href="#topic+ogr_def_field">ogr_def_field()</a></code>).
Additional arguments in <code>ogr_field_create()</code> will be ignored if a <code>fld_defn</code>
is given.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_subtype">fld_subtype</code></td>
<td>
<p>Character string containing the name of a field subtype.
One of  <code>OFSTNone</code> (the default), <code>OFSTBoolean</code>, <code>OFSTInt16</code>, <code>OFSTFloat32</code>,
<code>OFSTJSON</code>, <code>OFSTUUID</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_width">fld_width</code></td>
<td>
<p>Optional integer scalar specifying max number of characters.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_fld_precision">fld_precision</code></td>
<td>
<p>Optional integer scalar specifying number of digits
after the decimal point.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_is_nullable">is_nullable</code></td>
<td>
<p>Optional NOT NULL field constraint (logical scalar).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_is_ignored">is_ignored</code></td>
<td>
<p>Whether field is ignored when retrieving features (logical
scalar). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_is_unique">is_unique</code></td>
<td>
<p>Optional UNIQUE constraint on the field (logical scalar).
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_default_value">default_value</code></td>
<td>
<p>Optional default value for the field as a character
string.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_geom_fld_defn">geom_fld_defn</code></td>
<td>
<p>A geometry field definition as list
(see <code><a href="#topic+ogr_def_geom_field">ogr_def_geom_field()</a></code>).
Additional arguments in <code>ogr_geom_field_create()</code> will be ignored if a
<code>geom_fld_defn</code> is given.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_new_name">new_name</code></td>
<td>
<p>Character string containing a new name to assign.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_sql">sql</code></td>
<td>
<p>Character string containing an SQL statement (see Note).</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_spatial_filter">spatial_filter</code></td>
<td>
<p>Either a numeric vector of length four containing a
bounding box (xmin, ymin, xmax, ymax), or a character string containing a
geometry as OGC WKT, representing a spatial filter.</p>
</td></tr>
<tr><td><code id="ogr_manage_+3A_dialect">dialect</code></td>
<td>
<p>Character string specifying the SQL dialect to use.
The OGR SQL engine (<code>"OGRSQL"</code>) will be used by default if a value is not
given. The <code>"SQLite"</code> dialect can also be used (see Note).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are complementary to <code>ogrinfo()</code> and <code>ogr2ogr()</code> for
vector data management. They are also intended to support vector I/O in a
future release of gdalraster. Bindings to OGR wrap portions of the GDAL
Vector API (ogr_core.h and ogr_api.h,
<a href="https://gdal.org/api/vector_c_api.html">https://gdal.org/api/vector_c_api.html</a>).
</p>
<p><code>ogr_ds_exists()</code> tests whether a vector dataset can be opened from the
given data source name (DSN), potentially testing for update access.
Returns a logical scalar.
</p>
<p><code>ogr_ds_format()</code> returns a character string containing the short name of
the format driver for a given DSN, or <code>NULL</code> if the dataset cannot be
opened as a vector source.
</p>
<p><code>ogr_ds_test_cap()</code> tests the capabilities of a vector data source,
attempting to open it with update access by default.
Returns a list of capabilities with values <code>TRUE</code> or <code>FALSE</code>, or <code>NULL</code> is
returned if <code>dsn</code> cannot be opened with the requested access.
Wrapper of <code>GDALDatasetTestCapability()</code> in the GDAL API.
The returned list contains the following named elements:
</p>

<ul>
<li> <p><code>CreateLayer</code>: <code>TRUE</code> if this datasource can create new layers
</p>
</li>
<li> <p><code>DeleteLayer</code>: <code>TRUE</code> if this datasource can delete existing layers
</p>
</li>
<li> <p><code>CreateGeomFieldAfterCreateLayer</code>: <code>TRUE</code> if the layers of this
datasource support geometry field creation just after layer creation
</p>
</li>
<li> <p><code>CurveGeometries</code>: <code>TRUE</code> if this datasource supports curve geometries
</p>
</li>
<li> <p><code>Transactions</code>: <code>TRUE</code> if this datasource supports (efficient)
transactions
</p>
</li>
<li> <p><code>EmulatedTransactions</code>: <code>TRUE</code> if this datasource supports transactions
through emulation
</p>
</li>
<li> <p><code>RandomLayerRead</code>: <code>TRUE</code> if this datasource has a dedicated
<code>GetNextFeature()</code> implementation, potentially returning features from
layers in a non-sequential way
</p>
</li>
<li> <p><code>RandomLayerWrite</code>: <code>TRUE</code> if this datasource supports calling
<code>CreateFeature()</code> on layers in a non-sequential way
</p>
</li></ul>

<p><code>ogr_ds_create()</code> creates a new vector datasource, optionally also creating
a layer, and optionally creating one or more fields on the layer.
The attribute fields and geometry field(s) to create can be specified as a
feature class definition (<code>layer_defn</code> as list, see <a href="#topic+ogr_define">ogr_define</a>), or
alternatively, by giving the <code>geom_type</code> and <code>srs</code>, optionally along with
one <code>fld_name</code> and <code>fld_type</code> to be created in the layer. Returns a logical
scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_ds_layer_count()</code> returns the number of layers in a vector dataset.
</p>
<p><code>ogr_ds_layer_names()</code> returns a character vector of layer names in a
vector dataset, or <code>NULL</code> if no layers are found.
</p>
<p><code>ogr_layer_exists()</code> tests whether a layer can be accessed by name in a
given vector dataset. Returns a logical scalar.
</p>
<p><code>ogr_layer_test_cap()</code> tests whether a layer supports named capabilities,
attempting to open the dataset with update access by default.
Returns a list of capabilities with values <code>TRUE</code> or <code>FALSE</code>. <code>NULL</code> is
returned if <code>dsn</code> cannot be opened with the requested access, or <code>layer</code>
cannot be found. The returned list contains the following named elements:
<code>RandomRead</code>, <code>SequentialWrite</code>, <code>RandomWrite</code>, <code>UpsertFeature</code>,
<code>FastSpatialFilter</code>, <code>FastFeatureCount</code>, <code>FastGetExtent</code>,
<code>FastSetNextByIndex</code>, <code>CreateField</code>, <code>CreateGeomField</code>, <code>DeleteField</code>,
<code>ReorderFields</code>, <code>AlterFieldDefn</code>, <code>AlterGeomFieldDefn</code>, <code>DeleteFeature</code>,
<code>StringsAsUTF8</code>, <code>Transactions</code>, <code>CurveGeometries</code>.
See the GDAL documentation for
<a href="https://gdal.org/api/vector_c_api.html#_CPPv420OGR_L_TestCapability9OGRLayerHPKc"><code>OGR_L_TestCapability()</code></a>.
</p>
<p><code>ogr_layer_create()</code> creates a new layer in an existing vector data source,
with a specified geometry type and spatial reference definition.
This function also accepts a feature class definition given as a list of
field names and their definitions (see <a href="#topic+ogr_define">ogr_define</a>).
(Note: use <code>ogr_ds_create()</code> to create single-layer formats such as &quot;ESRI
Shapefile&quot;, &quot;FlatGeobuf&quot;, &quot;GeoJSON&quot;, etc.)
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_layer_field_names()</code> returns a character vector of field names on a
layer, or <code>NULL</code> if no fields are found.
</p>
<p><code>ogr_layer_delete()</code> deletes an existing layer in a vector dataset.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_index()</code> tests for existence of an attribute field by name.
Returns the field index on the layer (0-based), or <code>-1</code> if the field does
not exist.
</p>
<p><code>ogr_field_create()</code> creates a new attribute field of specified data type in
a given DSN/layer. Several optional field properties can be specified in
addition to the type. Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_geom_field_create()</code> creates a new geometry field of specified type in
a given DSN/layer. Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_rename()</code> renames an existing field on a vector layer.
Not all format drivers support this function. Some drivers may only support
renaming a field while there are still no features in the layer.
<code>AlterFieldDefn</code> is the relevant layer capability to check.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_field_delete()</code> deletes an existing field on a vector layer.
Not all format drivers support this function. Some drivers may only support
deleting a field while there are still no features in the layer.
Returns a logical scalar, <code>TRUE</code> indicating success.
</p>
<p><code>ogr_execute_sql()</code> executes an SQL statement against the data store.
This function can be used to modify the schema or edit data using SQL
(e.g., <code style="white-space: pre;">&#8288;ALTER TABLE&#8288;</code>, <code style="white-space: pre;">&#8288;DROP TABLE&#8288;</code>, <code style="white-space: pre;">&#8288;CREATE INDEX&#8288;</code>, <code style="white-space: pre;">&#8288;DROP INDEX&#8288;</code>, <code>INSERT</code>,
<code>UPDATE</code>, <code>DELETE</code>). Currently, this function does not return a result set
for a <code>SELECT</code> statement. Returns <code>NULL</code> invisibly.
Wrapper of <code>GDALDatasetExecuteSQL()</code> in the GDAL C API.
</p>


<h3>Note</h3>

<p>The OGR SQL document linked under <strong>See Also</strong> contains information on the
SQL dialect supported internally by GDAL/OGR. Some format drivers (e.g.,
PostGIS) pass the SQL directly through to the underlying RDBMS (unless
<code>OGRSQL</code> is explicitly passed as the dialect). The SQLite dialect can also
be requested with the <code>SQLite</code> string passed as the <code>dialect</code> argument of
<code>ogr_execute_sql()</code>. This assumes that GDAL/OGR is built with support for
SQLite, and preferably also with Spatialite support to benefit from spatial
functions. The GDAL document for SQLite dialect has detailed information.
</p>
<p>Other SQL dialects may also be present for some vector formats.
For example, the <code>"INDIRECT_SQLITE"</code> dialect might potentially be used with
GeoPackage format (<a href="https://gdal.org/drivers/vector/gpkg.html#sql">https://gdal.org/drivers/vector/gpkg.html#sql</a>).
</p>
<p>The function <code><a href="#topic+ogrinfo">ogrinfo()</a></code> can also be used to edit data with SQL statements
(GDAL &gt;= 3.7).
</p>
<p>The name of the geometry column of a layer is empty (<code>""</code>) with some formats
such as ESRI Shapefile and FlatGeobuf. Implications for SQL may depend on the
dialect used. See the GDAL documentation for the &quot;OGR SQL&quot; and &quot;SQLite&quot;
dialects for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdal_formats">gdal_formats()</a></code>, <code><a href="#topic+has_spatialite">has_spatialite()</a></code>, <code><a href="#topic+ogr_def_field">ogr_def_field()</a></code>, <code><a href="#topic+ogr_def_layer">ogr_def_layer()</a></code>,
<code><a href="#topic+ogrinfo">ogrinfo()</a></code>, <code><a href="#topic+ogr2ogr">ogr2ogr()</a></code>
</p>
<p>OGR SQL dialect and SQLite SQL dialect:<br />
<a href="https://gdal.org/user/ogr_sql_sqlite_dialect.html">https://gdal.org/user/ogr_sql_sqlite_dialect.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsn &lt;- file.path(tempdir(), "test1.gpkg")
ogr_ds_create("GPKG", dsn)
ogr_ds_exists(dsn, with_update = TRUE)
ogr_ds_layer_count(dsn)
ogr_ds_test_cap(dsn)
ogr_layer_exists(dsn, "layer1")
if (ogr_ds_test_cap(dsn)$CreateLayer) {
  opt &lt;- c("GEOMETRY_NULLABLE=NO", "DESCRIPTION=test layer")
  ogr_layer_create(dsn, "layer1", geom_type = "Polygon", srs = "EPSG:5070",
                   lco = opt)
}
ogr_ds_layer_count(dsn)
ogr_layer_exists(dsn, "layer1")
ogr_ds_layer_names(dsn)

ogr_layer_field_names(dsn, "layer1")
ogr_field_index(dsn, "layer1", "field1")
if (ogr_layer_test_cap(dsn, "layer1")$CreateField) {
  ogr_field_create(dsn, "layer1", "field1",
                   fld_type = "OFTInteger64",
                   is_nullable = FALSE)
  ogr_field_create(dsn, "layer1", "field2",
                   fld_type = "OFTString")
}
ogr_field_index(dsn, "layer1", "field1")
ogr_layer_field_names(dsn, "layer1")

# delete a field
if (ogr_layer_test_cap(dsn, "layer1")$DeleteField) {
  ogr_field_delete(dsn, "layer1", "field2")
}
ogr_layer_field_names(dsn, "layer1")

# define a feature class (layer definition)
defn &lt;- ogr_def_layer("Point", srs = epsg_to_wkt(4326))
# add the attribute fields
defn$fld1_name &lt;- ogr_def_field("OFTInteger64",
                                is_nullable = FALSE,
                                is_unique = TRUE)
defn$fld2_name &lt;- ogr_def_field("OFTString",
                                fld_width = 25,
                                is_nullable = FALSE,
                                default_value = "'a default string'")
defn$third_field &lt;- ogr_def_field("OFTReal",
                                  default_value = "0.0")

ogr_layer_create(dsn, "layer2", layer_defn = defn)
ogr_ds_layer_names(dsn)
ogr_layer_field_names(dsn, "layer2")

# add a field using SQL instead
sql &lt;- "ALTER TABLE layer2 ADD field4 float"
ogr_execute_sql(dsn, sql)
ogr_layer_field_names(dsn, "layer2")

# rename a field
if (ogr_layer_test_cap(dsn, "layer1")$AlterFieldDefn) {
  ogr_field_rename(dsn, "layer2", "field4", "renamed_field")
}
ogr_layer_field_names(dsn, "layer2")

# GDAL &gt;= 3.7
if (as.integer(gdal_version()[2]) &gt;= 3070000)
  ogrinfo(dsn, "layer2")

deleteDataset(dsn)

# edit data using SQL
src &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")
perims_shp &lt;- file.path(tempdir(), "mtbs_perims.shp")
ogr2ogr(src, perims_shp, src_layers = "mtbs_perims")
ogr_ds_format(perims_shp)
ogr_ds_layer_names(perims_shp)
ogr_layer_field_names(perims_shp, "mtbs_perims")

if (ogr_layer_test_cap(perims_shp, "mtbs_perims")$CreateField) {
  sql &lt;- "ALTER TABLE mtbs_perims ADD burn_bnd_ha float"
  ogr_execute_sql(perims_shp, sql)
  # with GDAL &gt;= 3.7, equivalent to:
  # ogrinfo(perims_shp, cl_arg = c("-sql", sql), read_only = FALSE)
}

sql &lt;- "UPDATE mtbs_perims SET burn_bnd_ha = (burn_bnd_ac / 2.471)"
ogr_execute_sql(perims_shp, sql, dialect = "SQLite")
ogr_layer_field_names(perims_shp, "mtbs_perims")

# if GDAL &gt;= 3.7:
#   ogrinfo(perims_shp, "mtbs_perims")
# or, for output incl. the feature data (omit the default "-so" arg):
#   ogrinfo(perims_shp, "mtbs_perims", cl_arg = "-nomd")

deleteDataset(perims_shp)
</code></pre>

<hr>
<h2 id='ogr2ogr'>Convert vector data between different formats</h2><span id='topic+ogr2ogr'></span>

<h3>Description</h3>

<p><code>ogr2ogr()</code> is a wrapper of the <code>ogr2ogr</code> command-line
utility (see <a href="https://gdal.org/programs/ogr2ogr.html">https://gdal.org/programs/ogr2ogr.html</a>).
This function can be used to convert simple features data between file
formats. It can also perform various operations during the process, such
as spatial or attribute selection, reducing the set of attributes, setting
the output coordinate system or even reprojecting the features during
translation.
Refer to the GDAL documentation at the URL above for a description of
command-line arguments that can be passed in <code>cl_arg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ogr2ogr(
  src_dsn,
  dst_dsn,
  src_layers = NULL,
  cl_arg = NULL,
  open_options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ogr2ogr_+3A_src_dsn">src_dsn</code></td>
<td>
<p>Character string. Data source name of the source vector
dataset.</p>
</td></tr>
<tr><td><code id="ogr2ogr_+3A_dst_dsn">dst_dsn</code></td>
<td>
<p>Character string. Data source name of the destination vector
dataset.</p>
</td></tr>
<tr><td><code id="ogr2ogr_+3A_src_layers">src_layers</code></td>
<td>
<p>Optional character vector of layer names in the source
dataset. Defaults to all layers.</p>
</td></tr>
<tr><td><code id="ogr2ogr_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments for
the GDAL <code>ogr2ogr</code> command-line utility (see URL above).</p>
</td></tr>
<tr><td><code id="ogr2ogr_+3A_open_options">open_options</code></td>
<td>
<p>Optional character vector of dataset open options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p>For progress reporting, see command-line argument <code>-progress</code>: Display
progress on terminal. Only works if input layers have the &quot;fast feature
count&quot; capability.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ogrinfo">ogrinfo()</a></code>, the <a href="#topic+ogr_manage">ogr_manage</a> utilities
</p>
<p><code><a href="#topic+translate">translate()</a></code> for raster data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>src &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")

# Convert GeoPackage to Shapefile
shp_file &lt;- file.path(tempdir(), "ynp_fires.shp")
ogr2ogr(src, shp_file, src_layers = "mtbs_perims")

# Reproject to WGS84
ynp_wgs84 &lt;- file.path(tempdir(), "ynp_fires_wgs84.gpkg")
args &lt;- c("-t_srs", "EPSG:4326")
ogr2ogr(src, ynp_wgs84, cl_arg = args)

# Clip to a bounding box (xmin, ymin, xmax, ymax in the source SRS)
# This will select features whose geometry intersects the bounding box.
# The geometries themselves will not be clipped unless "-clipsrc" is
# specified.
# The source SRS can be overridden with "-spat_srs" "&lt;srs_def&gt;"
ynp_clip &lt;- file.path(tempdir(), "ynp_fires_aoi_clip.gpkg")
bb &lt;- c(469685.97, 11442.45, 544069.63, 85508.15)
args &lt;- c("-spat", bb)
ogr2ogr(src, ynp_clip, cl_arg = args)

# Filter features by a -where clause
ynp_filtered &lt;- file.path(tempdir(), "ynp_fires_2000_2022.gpkg")
sql &lt;- "ig_year &gt;= 2000 ORDER BY ig_year"
args &lt;- c("-where", sql)
ogr2ogr(src, ynp_filtered, src_layers = "mtbs_perims", cl_arg = args)

deleteDataset(shp_file)
deleteDataset(ynp_wgs84)
deleteDataset(ynp_clip)
deleteDataset(ynp_filtered)
</code></pre>

<hr>
<h2 id='ogrinfo'>Retrieve information about a vector data source</h2><span id='topic+ogrinfo'></span>

<h3>Description</h3>

<p><code>ogrinfo()</code> is a wrapper of the <code>ogrinfo</code> command-line
utility (see <a href="https://gdal.org/programs/ogrinfo.html">https://gdal.org/programs/ogrinfo.html</a>).
This function lists information about an OGR-supported data source.
It is also possible to edit data with SQL statements.
Refer to the GDAL documentation at the URL above for a description of
command-line arguments that can be passed in <code>cl_arg</code>.
Requires GDAL &gt;= 3.7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ogrinfo(
  dsn,
  layers = NULL,
  cl_arg = as.character(c("-so", "-nomd")),
  open_options = NULL,
  read_only = TRUE,
  cout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ogrinfo_+3A_dsn">dsn</code></td>
<td>
<p>Character string. Data source name (e.g., filename, database
connection string, etc.)</p>
</td></tr>
<tr><td><code id="ogrinfo_+3A_layers">layers</code></td>
<td>
<p>Optional character vector of layer names in the source
dataset.</p>
</td></tr>
<tr><td><code id="ogrinfo_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments for
the <code>ogrinfo</code> command-line utility in GDAL (see URL above for
reference). The default is <code>c("-so", "-nomd")</code> (see Note).</p>
</td></tr>
<tr><td><code id="ogrinfo_+3A_open_options">open_options</code></td>
<td>
<p>Optional character vector of dataset open options.</p>
</td></tr>
<tr><td><code id="ogrinfo_+3A_read_only">read_only</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to open the data source read-only
(the default), or <code>FALSE</code> to open with write access.</p>
</td></tr>
<tr><td><code id="ogrinfo_+3A_cout">cout</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to write info to the standard C output
stream (the default). <code>FALSE</code> to suppress console output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a character string containing information about the
vector dataset, or empty string (<code>""</code>) in case of error.
</p>


<h3>Note</h3>

<p>The command-line argument <code>-so</code> provides a summary only, i.e., does not
include details about every single feature of a layer.
<code>-nomd</code> suppresses metadata printing. Some datasets may contain a lot of
metadata strings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ogr2ogr">ogr2ogr()</a></code>, the <a href="#topic+ogr_manage">ogr_manage</a> utilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>src &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")

# Requires GDAL &gt;= 3.7
if (as.integer(gdal_version()[2]) &gt;= 3070000) {
  # Get the names of the layers in a GeoPackage file.
  ogrinfo(src)

  # Summary of a layer
  ogrinfo(src, "mtbs_perims")

  # JSON format
  args &lt;- c("-json", "-nomd")
  json &lt;- ogrinfo(src, "mtbs_perims", args, cout = FALSE)
  #info &lt;- jsonlite::fromJSON(json)

  # Query an attribute to restrict the output of the features in a layer
  args &lt;- c("-ro", "-nomd", "-where", "ig_year = 2020")
  ogrinfo(src, "mtbs_perims", args)

  # Copy to a temporary in-memory file that is writeable
  src_mem &lt;- paste0("/vsimem/", basename(src))
  vsi_copy_file(src, src_mem)
  print(src_mem)

  # Add a column to a layer
  args &lt;- c("-sql", "ALTER TABLE mtbs_perims ADD burn_bnd_ha float")
  ogrinfo(src_mem, cl_arg = args, read_only = FALSE)

  # Update values of the column with SQL and specify a dialect
  sql &lt;- "UPDATE mtbs_perims SET burn_bnd_ha = (burn_bnd_ac / 2.471)"
  args &lt;- c("-dialect", "sqlite", "-sql", sql)
  ogrinfo(src_mem, cl_arg = args, read_only = FALSE)

  vsi_unlink(src_mem)
}
</code></pre>

<hr>
<h2 id='plot_raster'>Display raster data</h2><span id='topic+plot_raster'></span>

<h3>Description</h3>

<p><code>plot_raster()</code> displays raster data using base <code>graphics</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_raster(
  data,
  xsize = NULL,
  ysize = NULL,
  nbands = 1,
  max_pixels = 2.5e+07,
  col_tbl = NULL,
  maxColorValue = 1,
  normalize = TRUE,
  minmax_def = NULL,
  minmax_pct_cut = NULL,
  col_map_fn = NULL,
  xlim = NULL,
  ylim = NULL,
  interpolate = TRUE,
  asp = 1,
  axes = TRUE,
  main = "",
  xlab = "x",
  ylab = "y",
  xaxs = "i",
  yaxs = "i",
  legend = FALSE,
  digits = 2,
  na_col = rgb(0, 0, 0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_raster_+3A_data">data</code></td>
<td>
<p>Either a <code>GDALRaster</code> object from which data will be read, or
a numeric vector of pixel values arranged in left to right, top to
bottom order, or a list of band vectors. If input is vector or list,
the information in attribute <code>gis</code> will be used if present (see <code><a href="#topic+read_ds">read_ds()</a></code>),
potentially ignoring values below for <code>xsize</code>, <code>ysize</code>, <code>nbands</code>.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_xsize">xsize</code></td>
<td>
<p>The number of pixels along the x dimension in <code>data</code>. If <code>data</code>
is a <code>GDALRaster</code> object, specifies the size at which the raster will be
read (used for argument <code>out_xsize</code> in <code>GDALRaster$read()</code>). By default,
the entire raster will be read at full resolution.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_ysize">ysize</code></td>
<td>
<p>The number of pixels along the y dimension in <code>data</code>. If <code>data</code>
is a <code>GDALRaster</code> object, specifies the size at which the raster will be
read (used for argument <code>out_ysize</code> in <code>GDALRaster$read()</code>). By default,
the entire raster will be read at full resolution.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_nbands">nbands</code></td>
<td>
<p>The number of bands in <code>data</code>. Must be either 1 (grayscale) or
3 (RGB). For RGB, <code>data</code> are interleaved by band.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_max_pixels">max_pixels</code></td>
<td>
<p>The maximum number of pixels that the function will
attempt to display (per band). An error is raised if <code>(xsize * ysize)</code>
exceeds this value. Setting to <code>NULL</code> turns off this check.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_col_tbl">col_tbl</code></td>
<td>
<p>A color table as a matrix or data frame with four or five
columns. Column 1 contains the numeric pixel values. Columns 2:4 contain
the intensities of the red, green and blue primaries (<code>0:1</code> by default,
or use integer <code>0:255</code> by setting <code>maxColorValue = 255</code>).
An optional column 5 may contain alpha transparency values, <code>0</code> for fully
transparent to <code>1</code> (or <code>maxColorValue</code>) for opaque (the default if column 5
is missing). If <code>data</code> is a <code>GDALRaster</code> object, a built-in color table will
be used automatically if one exists in the dataset.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>A number giving the maximum of the color values range
in <code>col_tbl</code> (see above). The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_normalize">normalize</code></td>
<td>
<p>Logical. <code>TRUE</code> to rescale pixel values so that their
range is <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, normalized to the full range of the pixel data by default
(<code>min(data)</code>, <code>max(data)</code>, per band). Ignored if <code>col_tbl</code> is used.
Set <code>normalize</code> to <code>FALSE</code> if a color map function is used that
operates on raw pixel values (see <code>col_map_fn</code> below).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_minmax_def">minmax_def</code></td>
<td>
<p>Normalize to user-defined min/max values (in terms of
the pixel data, per band). For single-band grayscale, a numeric vector of
length two containing min, max. For 3-band RGB, a numeric vector of length
six containing b1_min, b2_min, b3_min, b1_max, b2_max, b3_max.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_minmax_pct_cut">minmax_pct_cut</code></td>
<td>
<p>Normalize to a truncated range of the pixel data using
percentile cutoffs (removes outliers). A numeric vector of length two giving
the percentiles to use (e.g., <code>c(2, 98)</code>). Applied per band. Ignored if
<code>minmax_def</code> is used.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_col_map_fn">col_map_fn</code></td>
<td>
<p>An optional color map function (default is
<code>grDevices::gray</code> for single-band data or <code>grDevices::rgb</code> for 3-band).
Ignored if <code>col_tbl</code> is used. Set <code>normalize</code> to <code>FALSE</code> if using a color
map function that operates on raw pixel values.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length two giving the x coordinate range.
If <code>data</code> is a <code>GDALRaster</code> object, the default is the raster xmin, xmax in
georeferenced coordinates, otherwise the default uses pixel/line
coordinates (<code>c(0, xsize)</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length two giving the y coordinate range.
If <code>data</code> is a <code>GDALRaster</code> object, the default is the raster ymin, ymax in
georeferenced coordinates, otherwise the default uses pixel/line
coordinates (<code>c(ysize, 0)</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_interpolate">interpolate</code></td>
<td>
<p>Logical indicating whether to apply linear interpolation
to the image when drawing (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_asp">asp</code></td>
<td>
<p>Numeric. The aspect ratio y/x (see <code>?plot.window</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_axes">axes</code></td>
<td>
<p>Logical. <code>TRUE</code> to draw axes (the default).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_main">main</code></td>
<td>
<p>The main title (on top).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_xlab">xlab</code></td>
<td>
<p>Title for the x axis (see <code>?title</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_ylab">ylab</code></td>
<td>
<p>Title for the y axis (see <code>?title</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_xaxs">xaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the x axis
(see <code>?par</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the y axis
(see <code>?par</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether to include a legend on the plot.
Currently, legends are only supported for continuous data. A color table
will be used if one is specified or the raster has a built-in color table,
otherwise the value for <code>col_map_fn</code> will be used.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_digits">digits</code></td>
<td>
<p>The number of digits to display after the decimal point in
the legend labels when raster data are floating point.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_na_col">na_col</code></td>
<td>
<p>Color to use for <code>NA</code> as a 7- or 9-character hexadecimal code.
The default is transparent (<code>"#00000000"</code>, the return value of
<code>rgb(0,0,0,0)</code>).</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>plot.default()</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>plot_raster()</code> uses the function <code>graphics::rasterImage()</code> for plotting
which is not supported on some devices (see <code>?rasterImage</code>).
</p>
<p>If <code>data</code> is an object of class <code>GDALRaster</code>, then <code>plot_raster()</code> will
attempt to read the entire raster into memory by default (unless the number
of pixels per band would exceed <code>max_pixels</code>).
A reduced resolution overview can be read by setting <code>xsize</code>, <code>ysize</code>
smaller than the raster size on disk.
(If <code>data</code> is instead specified as a vector of pixel values, a reduced
resolution overview would be read by setting <code>out_xsize</code> and <code>out_ysize</code>
smaller than the raster region defined by <code>xsize</code>, <code>ysize</code> in a call to
<code>GDALRaster$read()</code>).
The GDAL_RASTERIO_RESAMPLING configuration option can be
defined to override the default resampling (NEAREST) to one of BILINEAR,
CUBIC, CUBICSPLINE, LANCZOS, AVERAGE or MODE, for example:
</p>
<pre>
set_config_option("GDAL_RASTERIO_RESAMPLING", "BILINEAR")
</pre>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$read()</a></code>, <code><a href="#topic+read_ds">read_ds()</a></code>, <code><a href="#topic+set_config_option">set_config_option()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Elevation
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file)

# grayscale
plot_raster(ds, legend=TRUE, main="Storm Lake elevation (m)")

# color ramp from user-defined palette
elev_pal &lt;- c("#00A60E","#63C600","#E6E600","#E9BD3B",
              "#ECB176","#EFC2B3","#F2F2F2")
ramp &lt;- scales::colour_ramp(elev_pal, alpha=FALSE)
plot_raster(ds, col_map_fn=ramp, legend=TRUE,
            main="Storm Lake elevation (m)")

ds$close()

## Landsat band combination
b4_file &lt;- system.file("extdata/sr_b4_20200829.tif", package="gdalraster")
b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
b6_file &lt;- system.file("extdata/sr_b6_20200829.tif", package="gdalraster")
band_files &lt;- c(b6_file, b5_file, b4_file)

r &lt;- vector("integer")
for (f in band_files) {
  ds &lt;- new(GDALRaster, f)
  dm &lt;- ds$dim()
  r &lt;- c(r, read_ds(ds))
  ds$close()
}

plot_raster(r, xsize=dm[1], ysize=dm[2], nbands=3,
            main="Landsat 6-5-4 (vegetative analysis)")

## LANDFIRE Existing Vegetation Cover (EVC) with color map
evc_file &lt;- system.file("extdata/storml_evc.tif", package="gdalraster")

# colors from the CSV attribute table distributed by LANDFIRE
evc_csv &lt;- system.file("extdata/LF20_EVC_220.csv", package="gdalraster")
vat &lt;- read.csv(evc_csv)
head(vat)
vat &lt;- vat[,c(1,6:8)]

ds &lt;- new(GDALRaster, evc_file)
plot_raster(ds, col_tbl=vat, interpolate=FALSE,
            main="Storm Lake LANDFIRE EVC")

ds$close()
</code></pre>

<hr>
<h2 id='polygonize'>Create a polygon feature layer from raster data</h2><span id='topic+polygonize'></span>

<h3>Description</h3>

<p><code>polygonize()</code> creates vector polygons for all connected regions of pixels
in a source raster sharing a common pixel value. Each polygon is created
with an attribute indicating the pixel value of that polygon. A raster mask
may also be provided to determine which pixels are eligible for processing.
The function will create the output vector layer if it does not already
exist, otherwise it will try to append to an existing one.
This function is a wrapper of <code>GDALPolygonize</code> in the GDAL Algorithms API.
It provides essentially the same functionality as the <code>gdal_polygonize.py</code>
command-line program (<a href="https://gdal.org/programs/gdal_polygonize.html">https://gdal.org/programs/gdal_polygonize.html</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygonize(
  raster_file,
  out_dsn,
  out_layer,
  fld_name = "DN",
  out_fmt = NULL,
  connectedness = 4,
  src_band = 1,
  mask_file = NULL,
  nomask = FALSE,
  overwrite = FALSE,
  dsco = NULL,
  lco = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygonize_+3A_raster_file">raster_file</code></td>
<td>
<p>Filename of the source raster.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_out_dsn">out_dsn</code></td>
<td>
<p>The destination vector filename to which the polygons will be
written (or database connection string).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_out_layer">out_layer</code></td>
<td>
<p>Name of the layer for writing the polygon features. For
single-layer file formats such as <code>"ESRI Shapefile"</code>, the layer name is the
same as the filename without the path or extension (e.g., <code>out_dsn = "path_to_file/polygon_output.shp"</code>, the layer name is <code>"polygon_output"</code>).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_fld_name">fld_name</code></td>
<td>
<p>Name of an integer attribute field in <code>out_layer</code> to which
the pixel values will be written. Will be created if necessary when using an
existing layer.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_out_fmt">out_fmt</code></td>
<td>
<p>GDAL short name of the output vector format. If unspecified,
the function will attempt to guess the format from the filename/connection
string.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_connectedness">connectedness</code></td>
<td>
<p>Integer scalar. Must be either <code>4</code> or <code>8</code>. For the
default 4-connectedness, pixels with the same value are considered connected
only if they touch along one of the four sides, while 8-connectedness
also includes pixels that touch at one of the corners.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_src_band">src_band</code></td>
<td>
<p>The band on <code>raster_file</code> to build the polygons from
(default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_mask_file">mask_file</code></td>
<td>
<p>Use the first band of the specified raster as a
validity mask (zero is invalid, non-zero is valid). If not specified, the
default validity mask for the input band (such as nodata, or alpha masks)
will be used (unless <code>nomask</code> is set to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_nomask">nomask</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, do not use the default validity
mask for the input band (such as nodata, or alpha masks).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, overwrite <code>out_layer</code> if it
already exists. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="polygonize_+3A_dsco">dsco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>out_dsn</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_lco">lco</code></td>
<td>
<p>Optional character vector of format-specific creation options
for <code>out_layer</code> (<code>"NAME=VALUE"</code> pairs).</p>
</td></tr>
<tr><td><code id="polygonize_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polygon features will be created on the output layer, with polygon
geometries representing the polygons. The polygon geometries will be in the
georeferenced coordinate system of the raster (based on the geotransform of
the source dataset). It is acceptable for the output layer to already have
features. If the output layer does not already exist, it will be created
with coordinate system matching the source raster.
</p>
<p>The algorithm attempts to minimize memory use so that very large rasters can
be processed. However, if the raster has many polygons or very large/complex
polygons, the memory use for holding polygon enumerations and active polygon
geometries may grow to be quite large.
</p>
<p>The algorithm will generally produce very dense polygon geometries, with
edges that follow exactly on pixel boundaries for all non-interior pixels.
For non-thematic raster data (such as satellite images) the result will
essentially be one small polygon per pixel, and memory and output layer
sizes will be substantial. The algorithm is primarily intended for
relatively simple thematic rasters, masks, and classification results.
</p>


<h3>Note</h3>

<p>The source pixel band values are read into a signed 64-bit integer buffer
(<code>Int64</code>) by <code>GDALPolygonize</code>, so floating point or complex bands will be
implicitly truncated before processing.
</p>
<p>When 8-connectedness is used, many of the resulting polygons will likely be
invalid due to ring self-intersection (in the strict OGC definition of
polygon validity). They may be suitable as-is for certain purposes such as
calculating geometry attributes (area, perimeter). Package <strong>sf</strong> has
<code>st_make_valid()</code>, PostGIS has <code>ST_MakeValid()</code>, and QGIS has vector
processing utility &quot;Fix geometries&quot; (single polygons can become MultiPolygon
in the case of self-intersections).
</p>
<p>If writing to a SQLite database format as either <code>GPKG</code> (GeoPackage
vector) or <code>SQLite</code> (Spatialite vector), setting the
<code>SQLITE_USE_OGR_VFS</code> and <code>OGR_SQLITE_JOURNAL</code> configuration options may
increase performance substantially. If writing to <code>PostgreSQL</code>
(PostGIS vector), setting <code>PG_USE_COPY=YES</code> is faster:
</p>
<div class="sourceCode"><pre># SQLite: GPKG (.gpkg) and Spatialite (.sqlite)
# enable extra buffering/caching by the GDAL/OGR I/O layer
set_config_option("SQLITE_USE_OGR_VFS", "YES")
# set the journal mode for the SQLite database to MEMORY
set_config_option("OGR_SQLITE_JOURNAL", "MEMORY")

# PostgreSQL / PostGIS
# use COPY for inserting data rather than INSERT
set_config_option("PG_USE_COPY", "YES")
</pre></div>


<h3>See Also</h3>

<p><code><a href="#topic+rasterize">rasterize()</a></code>
</p>
<p><code>vignette("gdal-config-quick-ref")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
dsn &lt;- file.path(tempdir(), "storm_lake.gpkg")
layer &lt;- "lf_evt"
fld &lt;- "evt_value"
set_config_option("SQLITE_USE_OGR_VFS", "YES")
set_config_option("OGR_SQLITE_JOURNAL", "MEMORY")
polygonize(evt_file, dsn, layer, fld)
set_config_option("SQLITE_USE_OGR_VFS", "")
set_config_option("OGR_SQLITE_JOURNAL", "")
deleteDataset(dsn)
</code></pre>

<hr>
<h2 id='pop_error_handler'>Pop error handler off stack</h2><span id='topic+pop_error_handler'></span>

<h3>Description</h3>

<p><code>pop_error_handler()</code> is a wrapper for <code>CPLPopErrorHandler()</code> in the GDAL
Common Portability Library.
Discards the current error handler on the error handler stack, and restores
the one in use before the last <code>push_error_handler()</code> call. This method has
no effect if there are no error handlers on the current thread's error
handler stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_error_handler()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+push_error_handler">push_error_handler()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>push_error_handler("quiet")
# ...
pop_error_handler()
</code></pre>

<hr>
<h2 id='proj_networking'>Check, enable or disable PROJ networking capabilities</h2><span id='topic+proj_networking'></span>

<h3>Description</h3>

<p><code>proj_networking()</code> returns the status of PROJ networking capabilities,
optionally enabling or disabling first. Requires GDAL 3.4 or later and
PROJ 7 or later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_networking(enabled = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_networking_+3A_enabled">enabled</code></td>
<td>
<p>Optional logical scalar. Set to <code>TRUE</code> to enable networking
capabilities or <code>FALSE</code> to disable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> if PROJ networking capabilities are enabled (as
indicated by the return value of <code>OSRGetPROJEnableNetwork()</code> in the GDAL
Spatial Reference System C API). Logical <code>NA</code> is returned if GDAL &lt; 3.4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj_version">proj_version()</a></code>, <code><a href="#topic+proj_search_paths">proj_search_paths()</a></code>
</p>
<p><a href="https://github.com/OSGeo/PROJ-data">PROJ-data on GitHub</a>,
<a href="https://cdn.proj.org/">PROJ Content Delivery Network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proj_networking()
</code></pre>

<hr>
<h2 id='proj_search_paths'>Get or set search path(s) for PROJ resource files</h2><span id='topic+proj_search_paths'></span>

<h3>Description</h3>

<p><code>proj_search_paths()</code> returns the search path(s) for PROJ resource files,
optionally setting them first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_search_paths(paths = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_search_paths_+3A_paths">paths</code></td>
<td>
<p>Optional character vector containing one or more directory
paths to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the currently used search path(s) for
PROJ resource files. An empty string (<code>""</code>) is returned if no search paths
are returned by the function <code>OSRGetPROJSearchPaths()</code> in the GDAL Spatial
Reference System C API.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj_version">proj_version()</a></code>, <code><a href="#topic+proj_networking">proj_networking()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proj_search_paths()
</code></pre>

<hr>
<h2 id='proj_version'>Get PROJ version</h2><span id='topic+proj_version'></span>

<h3>Description</h3>

<p><code>proj_version()</code> returns version information for the PROJ library in use by
GDAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_version()
</code></pre>


<h3>Value</h3>

<p>A list of length four containing:
</p>

<ul>
<li> <p><code>name</code> - a string formatted as &quot;major.minor.patch&quot;
</p>
</li>
<li> <p><code>major</code> - major version as integer
</p>
</li>
<li> <p><code>minor</code> - minor version as integer
</p>
</li>
<li> <p><code>patch</code> - patch version as integer
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gdal_version">gdal_version()</a></code>, <code><a href="#topic+geos_version">geos_version()</a></code>, <code><a href="#topic+proj_search_paths">proj_search_paths()</a></code>,
<code><a href="#topic+proj_networking">proj_networking()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>proj_version()
</code></pre>

<hr>
<h2 id='push_error_handler'>Push a new GDAL CPLError handler</h2><span id='topic+push_error_handler'></span>

<h3>Description</h3>

<p><code>push_error_handler()</code> is a wrapper for
<code>CPLPushErrorHandler()</code> in the GDAL Common Portability
Library.
This pushes a new error handler on the thread-local error handler stack.
This handler will be used until removed with <code>pop_error_handler()</code>.
A typical use is to temporarily set <code>CPLQuietErrorHandler()</code> which doesn't
make any attempt to report passed error or warning messages, but will
process debug messages via <code>CPLDefaultErrorHandler</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>push_error_handler(handler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="push_error_handler_+3A_handler">handler</code></td>
<td>
<p>Character name of the error handler to push.
One of <code>quiet</code>, <code>logging</code> or <code>default</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Note</h3>

<p>Setting <code>handler = "logging"</code> will use <code>CPLLoggingErrorHandler()</code>, error
handler that logs into the file defined by the <code>CPL_LOG</code> configuration
option, or <code>stderr</code> otherwise.
</p>
<p>This only affects error reporting from GDAL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop_error_handler">pop_error_handler()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>push_error_handler("quiet")
# ...
pop_error_handler()
</code></pre>

<hr>
<h2 id='rasterFromRaster'>Create a raster from an existing raster as template</h2><span id='topic+rasterFromRaster'></span>

<h3>Description</h3>

<p><code>rasterFromRaster()</code> creates a new raster with spatial reference,
extent and resolution taken from a template raster, without copying data.
Optionally changes the format, number of bands, data type and nodata value,
sets driver-specific dataset creation options, and initializes to a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterFromRaster(
  srcfile,
  dstfile,
  fmt = NULL,
  nbands = NULL,
  dtName = NULL,
  options = NULL,
  init = NULL,
  dstnodata = init
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterFromRaster_+3A_srcfile">srcfile</code></td>
<td>
<p>Source raster filename.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_dstfile">dstfile</code></td>
<td>
<p>Output raster filename.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_fmt">fmt</code></td>
<td>
<p>Output raster format name (e.g., &quot;GTiff&quot; or &quot;HFA&quot;). Will attempt
to guess from the output filename if <code>fmt</code> is not specified.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_nbands">nbands</code></td>
<td>
<p>Number of output bands.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_dtname">dtName</code></td>
<td>
<p>Output raster data type name. Commonly used types include
<code>"Byte"</code>, <code>"Int16"</code>, <code>"UInt16"</code>, <code>"Int32"</code> and <code>"Float32"</code>.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_options">options</code></td>
<td>
<p>Optional list of format-specific creation options in a
vector of &quot;NAME=VALUE&quot; pairs
(e.g., <code>options = c("COMPRESS=LZW")</code> to set LZW compression
during creation of a GTiff file).</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_init">init</code></td>
<td>
<p>Numeric value to initialize all pixels in the output raster.</p>
</td></tr>
<tr><td><code id="rasterFromRaster_+3A_dstnodata">dstnodata</code></td>
<td>
<p>Numeric nodata value for the output raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the destination filename invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+bandCopyWholeRaster">bandCopyWholeRaster()</a></code>, <code><a href="#topic+translate">translate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># band 2 in a FARSITE landscape file has slope degrees
# convert slope degrees to slope percent in a new raster
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds_lcp &lt;- new(GDALRaster, lcp_file)
ds_lcp$getMetadata(band=2, domain="")

slpp_file &lt;- file.path(tempdir(), "storml_slpp.tif")
opt = c("COMPRESS=LZW")
rasterFromRaster(srcfile = lcp_file,
                 dstfile = slpp_file,
                 nbands = 1,
                 dtName = "Int16",
                 options = opt,
                 init = -32767)
ds_slp &lt;- new(GDALRaster, slpp_file, read_only=FALSE)

# slpp_file is initialized to -32767 and nodata value set
ds_slp$getNoDataValue(band=1)

# extent and cell size are the same as lcp_file
ds_lcp$bbox()
ds_lcp$res()
ds_slp$bbox()
ds_slp$res()

# convert slope degrees in lcp_file band 2 to slope percent in slpp_file
# bring through LCP nodata -9999 to the output nodata value
ncols &lt;- ds_slp$getRasterXSize()
nrows &lt;- ds_slp$getRasterYSize()
for (row in 0:(nrows-1)) {
    rowdata &lt;- ds_lcp$read(band=2,
                           xoff=0, yoff=row,
                           xsize=ncols, ysize=1,
                           out_xsize=ncols, out_ysize=1)
    rowslpp &lt;- tan(rowdata*pi/180) * 100
    rowslpp[rowdata==-9999] &lt;- -32767
    dim(rowslpp) &lt;- c(1, ncols)
    ds_slp$write(band=1, xoff=0, yoff=row, xsize=ncols, ysize=1, rowslpp)
}

# min, max, mean, sd
ds_slp$getStatistics(band=1, approx_ok=FALSE, force=TRUE)

ds_slp$close()
ds_lcp$close()
deleteDataset(slpp_file)
</code></pre>

<hr>
<h2 id='rasterize'>Burn vector geometries into a raster</h2><span id='topic+rasterize'></span>

<h3>Description</h3>

<p><code>rasterize()</code> burns vector geometries (points, lines, or polygons) into
the band(s) of a raster dataset. Vectors are read from any GDAL
OGR-supported vector format.
This function is a wrapper for the <code>gdal_rasterize</code> command-line
utility (<a href="https://gdal.org/programs/gdal_rasterize.html">https://gdal.org/programs/gdal_rasterize.html</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterize(
  src_dsn,
  dstfile,
  band = NULL,
  layer = NULL,
  where = NULL,
  sql = NULL,
  burn_value = NULL,
  burn_attr = NULL,
  invert = NULL,
  te = NULL,
  tr = NULL,
  tap = NULL,
  ts = NULL,
  dtName = NULL,
  dstnodata = NULL,
  init = NULL,
  fmt = NULL,
  co = NULL,
  add_options = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_+3A_src_dsn">src_dsn</code></td>
<td>
<p>Data source name for the input vector layer (filename or
connection string).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_dstfile">dstfile</code></td>
<td>
<p>Filename of the output raster. Must support update mode
access. This file will be created (or overwritten if it already exists -
see Note).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_band">band</code></td>
<td>
<p>Numeric vector. The band(s) to burn values into (for existing
<code>dstfile</code>). The default is to burn into band 1. Not used when creating a
new raster.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_layer">layer</code></td>
<td>
<p>Character vector of layer names(s) from <code>src_dsn</code>  that will be
used for input features. At least one layer name or a <code>sql</code> option must be
specified.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_where">where</code></td>
<td>
<p>An optional SQL WHERE style query string to select features to
burn in from the input <code>layer</code>(s).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_sql">sql</code></td>
<td>
<p>An SQL statement to be evaluated against <code>src_dsn</code> to produce a
virtual layer of features to be burned in (alternative to <code>layer</code>).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_burn_value">burn_value</code></td>
<td>
<p>A fixed numeric value to burn into a band for all
features. A numeric vector can be supplied, one burn value per band being
written to.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_burn_attr">burn_attr</code></td>
<td>
<p>Character string. Name of an attribute field on the
features to be used for a burn-in value. The value will be burned into all
output bands.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_invert">invert</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to invert rasterization. Burn the fixed
burn value, or the burn value associated with the first feature, into all
parts of the raster not inside the provided polygon.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_te">te</code></td>
<td>
<p>Numeric vector of length four. Sets the output raster extent. The
values must be expressed in georeferenced units. If not specified, the
extent of the output raster will be the extent of the vector layer.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_tr">tr</code></td>
<td>
<p>Numeric vector of length two. Sets the target pixel resolution.
The values must be expressed in georeferenced units. Both must be positive.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_tap">tap</code></td>
<td>
<p>Logical scalar. (target aligned pixels) Align the coordinates of
the extent of the output raster to the values of <code>tr</code>, such that the
aligned extent includes the minimum extent. Alignment means that
xmin / resx, ymin / resy, xmax / resx and ymax / resy are integer values.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_ts">ts</code></td>
<td>
<p>Numeric vector of length two. Sets the output raster size in
pixels (xsize, ysize). Note that <code>ts</code> cannot be used with <code>tr</code>.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_dtname">dtName</code></td>
<td>
<p>Character name of output raster data type, e.g., <code>Byte</code>,
<code>Int16</code>, <code>UInt16</code>, <code>Int32</code>, <code>UInt32</code>, <code>Float32</code>, <code>Float64</code>.
Defaults to <code>Float64</code>.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_dstnodata">dstnodata</code></td>
<td>
<p>Numeric scalar. Assign a nodata value to output bands.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_init">init</code></td>
<td>
<p>Numeric vector. Pre-initialize the output raster band(s) with
these value(s). However, it is not marked as the nodata value in the output
file. If only one value is given, the same value is used in all the bands.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_fmt">fmt</code></td>
<td>
<p>Output raster format short name (e.g., <code>"GTiff"</code>). Will attempt
to guess from the output filename if <code>fmt</code> is not specified.</p>
</td></tr>
<tr><td><code id="rasterize_+3A_co">co</code></td>
<td>
<p>Optional list of format-specific creation options for the output
raster in a vector of &quot;NAME=VALUE&quot; pairs
(e.g., <code>options = c("TILED=YES","COMPRESS=LZW")</code> to set LZW compression
during creation of a tiled GTiff file).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_add_options">add_options</code></td>
<td>
<p>An optional character vector of additional command-line
options to <code>gdal_rasterize</code> (see the <code>gdal_rasterize</code> documentation at the
URL above for all available options).</p>
</td></tr>
<tr><td><code id="rasterize_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p>The function creates a new target raster when any of the <code>fmt</code>, <code>dstnodata</code>,
<code>init</code>, <code>co</code>, <code>te</code>, <code>tr</code>, <code>tap</code>, <code>ts</code>, or <code>dtName</code> arguments are used. The
resolution or size must be specified using the <code>tr</code> or <code>ts</code> argument for all
new rasters. The target raster will be overwritten if it already exists and
any of these creation-related options are used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polygonize">polygonize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MTBS fire perimeters for Yellowstone National Park 1984-2022
dsn &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")
sql &lt;- "SELECT * FROM mtbs_perims ORDER BY mtbs_perims.ig_year"
out_file &lt;- file.path(tempdir(), "ynp_fires_1984_2022.tif")

rasterize(src_dsn = dsn,
          dstfile = out_file,
          sql = sql,
          burn_attr = "ig_year",
          tr = c(90,90),
          tap = TRUE,
          dtName = "Int16",
          dstnodata = -9999,
          init = -9999,
          co = c("TILED=YES","COMPRESS=LZW"))

ds &lt;- new(GDALRaster, out_file)
pal &lt;- scales::viridis_pal(end = 0.8, direction = -1)(6)
ramp &lt;- scales::colour_ramp(pal)
plot_raster(ds, legend = TRUE, col_map_fn = ramp, na_col = "#d9d9d9",
            main="YNP Fires 1984-2022 - Most Recent Burn Year")

ds$close()
deleteDataset(out_file)
</code></pre>

<hr>
<h2 id='rasterToVRT'>Create a GDAL virtual raster derived from one source dataset</h2><span id='topic+rasterToVRT'></span>

<h3>Description</h3>

<p><code>rasterToVRT()</code> creates a virtual raster dataset (VRT format) derived from
one source dataset with options for virtual subsetting, virtually resampling
the source data at a different pixel resolution, or applying a virtual
kernel filter. (See <code><a href="#topic+buildVRT">buildVRT()</a></code> for virtual mosaicing.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterToVRT(
  srcfile,
  relativeToVRT = FALSE,
  vrtfile = tempfile("tmprast", fileext = ".vrt"),
  resolution = NULL,
  subwindow = NULL,
  src_align = TRUE,
  resampling = "nearest",
  krnl = NULL,
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterToVRT_+3A_srcfile">srcfile</code></td>
<td>
<p>Source raster filename.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_relativetovrt">relativeToVRT</code></td>
<td>
<p>Logical. Indicates whether the source filename should
be interpreted as relative to the .vrt file (<code>TRUE</code>) or not relative
to the .vrt file (<code>FALSE</code>, the default). If <code>TRUE</code>, the .vrt
file is assumed to be in the same directory as <code>srcfile</code> and
<code>basename(srcfile)</code> is used in the .vrt file. Use <code>TRUE</code> if the .vrt file
will always be stored in the same directory with <code>srcfile</code>.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_vrtfile">vrtfile</code></td>
<td>
<p>Output VRT filename.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_resolution">resolution</code></td>
<td>
<p>A numeric vector of length two (xres, yres). The pixel
size must be expressed in georeferenced units. Both must be positive values.
The source pixel size is used if <code>resolution</code> is not specified.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_subwindow">subwindow</code></td>
<td>
<p>A numeric vector of length four (xmin, ymin, xmax, ymax).
Selects <code>subwindow</code> of the source raster with corners given in
georeferenced coordinates (in the source CRS).
If not given, the upper left corner of the VRT will be the
same as source, and the VRT extent will be the same or larger than source
depending on <code>resolution</code>.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_src_align">src_align</code></td>
<td>
<p>Logical.
</p>

<ul>
<li> <p><code>TRUE</code>: the upper left corner of the VRT extent will be set to the
upper left corner of the source pixel that contains <code>subwindow</code> xmin, ymax.
The VRT will be pixel-aligned with source if the VRT <code>resolution</code> is the
same as the source pixel size, otherwise VRT extent will be the minimum
rectangle that contains <code>subwindow</code> for the given pixel size.
Often, <code>src_align=TRUE</code> when selecting a raster minimum bounding box
for a vector polygon.
</p>
</li>
<li> <p><code>FALSE</code>: the VRT upper left corner will be exactly <code>subwindow</code>
xmin, ymax, and the VRT extent will be the minimum rectangle that contains
<code>subwindow</code> for the given pixel size. If <code>subwindow</code> is not given, the
source raster extent is used in which case <code>src_align=FALSE</code> has no effect.
Use <code>src_align=FALSE</code> to pixel-align two rasters of different sizes, i.e.,
when the intent is target alignment.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_resampling">resampling</code></td>
<td>
<p>The resampling method to use if xsize, ysize of the VRT is
different than the size of the underlying source rectangle (in number of
pixels). The values allowed are nearest, bilinear, cubic, cubicspline,
lanczos, average and mode (as character).</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_krnl">krnl</code></td>
<td>
<p>A filtering kernel specified as pixel coefficients.
<code>krnl</code> is a array with dimensions (size, size), where
size must be an odd number. <code>krnl</code> can also be given as a vector with
length size x size. For example, a 3x3 average filter is given by:
</p>
<pre>
krnl &lt;- c(
0.11111, 0.11111, 0.11111,
0.11111, 0.11111, 0.11111,
0.11111, 0.11111, 0.11111)
</pre>
<p>A kernel cannot be applied to sub-sampled or over-sampled data.</p>
</td></tr>
<tr><td><code id="rasterToVRT_+3A_normalized">normalized</code></td>
<td>
<p>Logical. Indicates whether the kernel is normalized.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rasterToVRT()</code> can be used to virtually clip and pixel-align
various raster layers with each other or in relation to vector
polygon boundaries. It also supports VRT kernel filtering.
</p>
<p>A VRT dataset is saved as a plain-text file with extension .vrt. This file
contains a description of the dataset in an XML format. The description
includes the source raster filename which can be a full path
(<code>relativeToVRT = FALSE</code>) or relative path (<code>relativeToVRT = TRUE</code>).
For relative path, <code>rasterToVRT()</code> assumes that the .vrt file will be in
the same directory as the source file and uses <code>basename(srcfile)</code>. The
elements of the XML schema describe how the source data will be read, along
with algorithms potentially applied and so forth. Documentation of the XML
format for .vrt is at:
<a href="https://gdal.org/drivers/raster/vrt.html">https://gdal.org/drivers/raster/vrt.html</a>.
</p>
<p>Since .vrt is a small plain-text file it is fast to write and requires
little storage space. Read performance is not degraded for certain simple
operations (e.g., virtual clip without resampling). Reading will be
slower for virtual resampling to a different pixel resolution or virtual
kernel filtering since the operations are performed on-the-fly (but .vrt
does not require the up front writing of a resampled or kernel-filtered
raster to a regular format). VRT is sometimes useful as an intermediate
raster in a series of processing steps, e.g., as a <code>tempfile</code> (the
default).
</p>
<p>GDAL VRT format has several capabilities and uses beyond those
covered by <code>rasterToVRT()</code>. See the URL above for a full discussion.
</p>


<h3>Value</h3>

<p>Returns the VRT filename invisibly.
</p>


<h3>Note</h3>

<p>Pixel alignment is specified in terms of the source raster pixels (i.e.,
<code>srcfile</code> of the virtual raster). The use case in mind is virtually
clipping a raster to the bounding box of a vector polygon and keeping
pixels aligned with <code>srcfile</code> (<code>src_align = TRUE</code>). <code>src_align</code> would be
set to <code>FALSE</code> if the intent is &quot;target alignment&quot;. For example, if
<code>subwindow</code> is the bounding box of another raster with a different layout,
then also setting <code>resolution</code> to the pixel resolution of the target raster
and <code>src_align = FALSE</code> will result in a virtual raster pixel-aligned with
the target (i.e., pixels in the virtual raster are no longer aligned with
its <code>srcfile</code>). Resampling defaults to <code>nearest</code> if not specified.
Examples for both cases of <code>src_align</code> are given below.
</p>
<p><code>rasterToVRT()</code> assumes <code>srcfile</code> is a north-up raster.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+bbox_from_wkt">bbox_from_wkt()</a></code>, <code><a href="#topic+buildVRT">buildVRT()</a></code>
</p>
<p><code><a href="#topic+warp">warp()</a></code> can write VRT for virtual reprojection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## resample

evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
ds &lt;- new(GDALRaster, evt_file)
ds$res()
ds$bbox()
ds$close()

# table of the unique pixel values and their counts
tbl &lt;- buildRAT(evt_file)
print(tbl)
sum(tbl$COUNT)

# resample at 90-m resolution
# EVT is thematic vegetation type so use a majority value
vrt_file &lt;- rasterToVRT(evt_file,
                        resolution=c(90,90),
                        resampling="mode")

# .vrt is a small xml file pointing to the source raster
file.size(vrt_file)

tbl90m &lt;- buildRAT(vrt_file)
print(tbl90m)
sum(tbl90m$COUNT)

ds &lt;- new(GDALRaster, vrt_file)
ds$res()
ds$bbox()
ds$close()
vsi_unlink(vrt_file)


## clip

evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")
ds_evt &lt;- new(GDALRaster, evt_file)
ds_evt$bbox()

# WKT string for a boundary within the EVT extent
bnd = "POLYGON ((324467.3 5104814.2, 323909.4 5104365.4, 323794.2
5103455.8, 324970.7 5102885.8, 326420.0 5103595.3, 326389.6 5104747.5,
325298.1 5104929.4, 325298.1 5104929.4, 324467.3 5104814.2))"

# src_align = TRUE
vrt_file &lt;- rasterToVRT(evt_file,
                        subwindow = bbox_from_wkt(bnd),
                        src_align=TRUE)
ds_vrt &lt;- new(GDALRaster, vrt_file)

# VRT is a virtual clip, pixel-aligned with the EVT raster
bbox_from_wkt(bnd)
ds_vrt$bbox()
ds_vrt$res()

ds_vrt$close()
vsi_unlink(vrt_file)

# src_align = FALSE
vrt_file &lt;- rasterToVRT(evt_file,
                        subwindow = bbox_from_wkt(bnd),
                        src_align=FALSE)
ds_vrt_noalign &lt;- new(GDALRaster, vrt_file)

# VRT upper left corner (xmin, ymax) is exactly bnd xmin, ymax
ds_vrt_noalign$bbox()
ds_vrt_noalign$res()

ds_vrt_noalign$close()
vsi_unlink(vrt_file)
ds_evt$close()


## subset and pixel align two rasters

# FARSITE landscape file for the Storm Lake area
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds_lcp &lt;- new(GDALRaster, lcp_file)

# Landsat band 5 file covering the Storm Lake area
b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
ds_b5 &lt;- new(GDALRaster, b5_file)

ds_lcp$bbox()  # 323476.1 5101872.0  327766.1 5105082.0
ds_lcp$res()   # 30 30

ds_b5$bbox()   # 323400.9 5101815.8  327870.9 5105175.8
ds_b5$res()    # 30 30

# src_align = FALSE because we need target alignment in this case:
vrt_file &lt;- rasterToVRT(b5_file,
                        resolution = ds_lcp$res(),
                        subwindow = ds_lcp$bbox(),
                        src_align = FALSE)
ds_b5vrt &lt;- new(GDALRaster, vrt_file)

ds_b5vrt$bbox() # 323476.1 5101872.0  327766.1 5105082.0
ds_b5vrt$res()  # 30 30

# read the the Landsat file pixel-aligned with the LCP file
# summarize band 5 reflectance where FBFM = 165
# LCP band 4 contains FBFM (a classification of fuel beds):
ds_lcp$getMetadata(band=4, domain="")

# verify Landsat nodata (0):
ds_b5vrt$getNoDataValue(band=1)
# will be read as NA and omitted from stats
rs &lt;- new(RunningStats, na_rm=TRUE)

ncols &lt;- ds_lcp$getRasterXSize()
nrows &lt;- ds_lcp$getRasterYSize()
for (row in 0:(nrows-1)) {
    row_fbfm &lt;- ds_lcp$read(band=4, xoff=0, yoff=row,
                            xsize=ncols, ysize=1,
                            out_xsize=ncols, out_ysize=1)
    row_b5 &lt;- ds_b5vrt$read(band=1, xoff=0, yoff=row,
                            xsize=ncols, ysize=1,
                            out_xsize=ncols, out_ysize=1)
	   rs$update(row_b5[row_fbfm == 165])
}
rs$get_count()
rs$get_mean()
rs$get_min()
rs$get_max()
rs$get_sum()
rs$get_var()
rs$get_sd()

ds_b5vrt$close()
vsi_unlink(vrt_file)
ds_lcp$close()
ds_b5$close()
</code></pre>

<hr>
<h2 id='read_ds'>Convenience wrapper for <code>GDALRaster$read()</code></h2><span id='topic+read_ds'></span>

<h3>Description</h3>

<p><code>read_ds()</code> will read from a raster dataset that is already open in a
<code>GDALRaster</code> object. By default, it attempts to read the full raster
extent from all bands at full resolution. <code>read_ds()</code> is sometimes more
convenient than <code>GDALRaster$read()</code>, e.g., to read specific multiple bands
for display with <code><a href="#topic+plot_raster">plot_raster()</a></code>, or simply for the argument defaults to
read an entire raster into memory (see Note).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ds(
  ds,
  bands = NULL,
  xoff = 0,
  yoff = 0,
  xsize = ds$getRasterXSize(),
  ysize = ds$getRasterYSize(),
  out_xsize = xsize,
  out_ysize = ysize,
  as_list = FALSE,
  as_raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ds_+3A_ds">ds</code></td>
<td>
<p>An object of class <code>GDALRaster</code> in open state.</p>
</td></tr>
<tr><td><code id="read_ds_+3A_bands">bands</code></td>
<td>
<p>Integer vector of band numbers to read. By default all bands
will be read.</p>
</td></tr>
<tr><td><code id="read_ds_+3A_xoff">xoff</code></td>
<td>
<p>Integer. The pixel (column) offset to the top left corner of the
raster region to be read (zero to start from the left side).</p>
</td></tr>
<tr><td><code id="read_ds_+3A_yoff">yoff</code></td>
<td>
<p>Integer. The line (row) offset to the top left corner of the
raster region to be read (zero to start from the top).</p>
</td></tr>
<tr><td><code id="read_ds_+3A_xsize">xsize</code></td>
<td>
<p>Integer. The width in pixels of the region to be read.</p>
</td></tr>
<tr><td><code id="read_ds_+3A_ysize">ysize</code></td>
<td>
<p>Integer. The height in pixels of the region to be read.</p>
</td></tr>
<tr><td><code id="read_ds_+3A_out_xsize">out_xsize</code></td>
<td>
<p>Integer. The width in pixels of the output buffer into
which the desired region will be read (e.g., to read a reduced resolution
overview).</p>
</td></tr>
<tr><td><code id="read_ds_+3A_out_ysize">out_ysize</code></td>
<td>
<p>Integer. The height in pixels of the output buffer into
which the desired region will be read (e.g., to read a reduced resolution
overview).</p>
</td></tr>
<tr><td><code id="read_ds_+3A_as_list">as_list</code></td>
<td>
<p>Logical. If <code>TRUE</code>, return output as a list of band vectors.
If <code>FALSE</code> (the default), output is a vector of pixel data interleaved by
band.</p>
</td></tr>
<tr><td><code id="read_ds_+3A_as_raw">as_raw</code></td>
<td>
<p>Logical. If <code>TRUE</code> and the underlying data type is Byte,
return output as R's raw vector type. This maps to the setting
<code style="white-space: pre;">&#8288;$readByteAsRaw&#8288;</code> on the <code>GDALRaster</code> object, which is used to temporarily
update that field in this function. To control this behaviour in a
persistent way on a data set see <code>$readByteAsRaw</code> in
<code><a href="#topic+GDALRaster">GDALRaster-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> will be returned in place of the nodata value if the raster dataset has
a nodata value defined for the band. Data are read as R <code>integer</code> type when
possible for the raster data type (Byte, Int8, Int16, UInt16, Int32),
otherwise as type <code>double</code> (UInt32, Float32, Float64).
</p>
<p>The output object has attribute <code>gis</code>, a list containing:
</p>
<pre>
  $type = "raster"
  $bbox = c(xmin, ymin, xmax, ymax)
  $dim = c(xsize, ysize, nbands)
  $srs = &lt;projection as WKT2 string&gt;
</pre>
<p>The WKT version used for the projection string can be overridden by setting
the <code>OSR_WKT_FORMAT</code> configuration option. See <code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code> for a list of
supported values.
</p>


<h3>Value</h3>

<p>If <code>as_list = FALSE</code> (the default), a <code>numeric</code> or <code>complex</code> vector
containing the values that were read. It is organized in left to right, top
to bottom pixel order, interleaved by band.
If <code>as_list = TRUE</code>, a list with number of elements equal to the number of
bands read. Each element contains a <code>numeric</code> or <code>complex</code> vector
containing the pixel data read for the band.
</p>


<h3>Note</h3>

<p>There is small overhead in calling <code>read_ds()</code> compared with
calling <code>GDALRaster$read()</code> directly. This would only matter if calling
the function repeatedly to read a raster in chunks. For the case of reading
a large raster in many chunks, it will be optimal performance-wise to call
<code>GDALRaster$read()</code> directly.
</p>
<p>By default, this function will attempt to read the full raster into memory.
It generally should not be called on large raster datasets using the default
argument values. The memory size in bytes of the returned vector will be
approximately (xsize * ysize * number of bands * 4) for data read as
<code>integer</code>, and (xsize * ysize * number of bands * 8) for data read as
<code>double</code> (plus small object overhead for the vector).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster$read()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read three bands from a multi-band dataset
lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")
ds &lt;- new(GDALRaster, lcp_file)

# as a vector of pixel data interleaved by band
r &lt;- read_ds(ds, bands=c(6,5,4))
typeof(r)
length(r)
object.size(r)

# as a list of band vectors
r &lt;- read_ds(ds, bands=c(6,5,4), as_list=TRUE)
typeof(r)
length(r)
object.size(r)

# gis attribute list
attr(r, "gis")

ds$close()
</code></pre>

<hr>
<h2 id='renameDataset'>Rename a dataset</h2><span id='topic+renameDataset'></span>

<h3>Description</h3>

<p><code>renameDataset()</code> renames a dataset in a format-specific way (e.g.,
rename associated files as appropriate). This could include moving the
dataset to a new directory or even a new filesystem.
The dataset should not be open in any existing <code>GDALRaster</code> objects
when <code>renameDataset()</code> is called. Wrapper for <code>GDALRenameDataset()</code> in the
GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameDataset(new_filename, old_filename, format = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameDataset_+3A_new_filename">new_filename</code></td>
<td>
<p>New name for the dataset.</p>
</td></tr>
<tr><td><code id="renameDataset_+3A_old_filename">old_filename</code></td>
<td>
<p>Old name for the dataset (should not be open in a
<code>GDALRaster</code> object).</p>
</td></tr>
<tr><td><code id="renameDataset_+3A_format">format</code></td>
<td>
<p>Raster format short name (e.g., &quot;GTiff&quot;). If set to empty
string <code>""</code> (the default), will attempt to guess the raster format from
<code>old_filename</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> if no error or <code>FALSE</code> on failure.
</p>


<h3>Note</h3>

<p>If <code>format</code> is set to an empty string <code>""</code> (the default) then the function
will try to identify the driver from <code>old_filename</code>. This is done
internally in GDAL by invoking the <code>Identify</code> method of each registered
<code>GDALDriver</code> in turn. The first driver that successful identifies the file
name will be returned. An error is raised if a format cannot be determined
from the passed file name.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+create">create()</a></code>, <code><a href="#topic+createCopy">createCopy()</a></code>,
<code><a href="#topic+deleteDataset">deleteDataset()</a></code>, <code><a href="#topic+copyDatasetFiles">copyDatasetFiles()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b5_file &lt;- system.file("extdata/sr_b5_20200829.tif", package="gdalraster")
b5_tmp &lt;- file.path(tempdir(), "b5_tmp.tif")
file.copy(b5_file,  b5_tmp)

ds &lt;- new(GDALRaster, b5_tmp)
ds$buildOverviews("BILINEAR", levels = c(2, 4, 8), bands = c(1))
ds$getFileList()
ds$close()
b5_tmp2 &lt;- file.path(tempdir(), "b5_tmp_renamed.tif")
renameDataset(b5_tmp2, b5_tmp)
ds &lt;- new(GDALRaster, b5_tmp2)
ds$getFileList()
ds$close()

deleteDataset(b5_tmp2)
</code></pre>

<hr>
<h2 id='RunningStats-class'>Class to calculate mean and variance in one pass</h2><span id='topic+RunningStats-class'></span><span id='topic+Rcpp_RunningStats'></span><span id='topic+Rcpp_RunningStats-class'></span><span id='topic+RunningStats'></span>

<h3>Description</h3>

<p><code>RunningStats</code> computes summary statistics on a data stream efficiently.
Mean and variance are calculated with Welford's online algorithm
(<a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>).
The min, max, sum and count are also tracked. The input data values are not
stored in memory, so this class can be used to compute statistics for very
large data streams.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunningStats-class_+3A_na_rm">na_rm</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to remove <code>NA</code> from the input data or
<code>FALSE</code> to retain <code>NA</code> (defaults to <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RunningStats</code>. A <code>RunningStats</code> object
maintains the current minimum, maximum, mean, variance, sum and count of
values that have been read from the stream. It can be updated repeatedly
with new values (i.e., chunks of data read from the input stream), but its
memory footprint is negligible. Class methods for updating with new values
and retrieving current values of statistics are described in Details.
<code>RunningStats</code> is a C++ class exposed directly to R (via
<code>RCPP_EXPOSED_CLASS</code>). Methods of the class are accessed in R using the <code>$</code>
operator.
</p>


<h3>Usage</h3>

<pre>
## Constructor
rs &lt;- new(RunningStats, na_rm)

## Methods (see Details)
rs$update(newvalues)
rs$get_count()
rs$get_mean()
rs$get_min()
rs$get_max()
rs$get_sum()
rs$get_var()
rs$get_sd()
rs$reset()
</pre>


<h3>Details</h3>

<p><code>new(RunningStats, na_rm)</code>
Constructor. Returns an object of class <code>RunningStats</code>.
</p>
<p><code>$update(newvalues)</code>
Updates the <code>RunningStats</code> object with a numeric vector of <code>newvalues</code>
(i.e., a chunk of values from the data stream). No return value, called
for side effects.
</p>
<p><code>$get_count()</code>
Returns the count of values received from the data stream.
</p>
<p><code>$get_mean()</code>
Returns the mean of values received from the data stream.
</p>
<p><code>$get_min()</code>
Returns the minimum value received from the data stream.
</p>
<p><code>$get_max()</code>
Returns the maximum value received from the data stream.
</p>
<p><code>$get_sum()</code>
Returns the sum of values received from the data stream.
</p>
<p><code>$get_var()</code>
Returns the variance of values from the data stream
(denominator n - 1).
</p>
<p><code>$get_sd()</code>
Returns the standard deviation of values from the data stream
(denominator n - 1).
</p>
<p><code>$reset()</code>
Clears the <code>RunningStats</code> object to its initialized state (count = 0).
No return value, called for side effects.
</p>


<h3>Note</h3>

<p>The intended use is computing summary statistics for specific subsets or
zones of a raster that could be defined in various ways and are generally
not contiguous. The algorithm as implemented here incurs the cost of
floating point division for each new value updated (i.e., per pixel), but is
reasonably efficient for the use case. Note that GDAL internally uses an
optimized version of Welford's algorithm to compute raster statistics as
described in detail by Rouault, 2016
(<a href="https://github.com/OSGeo/gdal/blob/master/gcore/statistics.txt">https://github.com/OSGeo/gdal/blob/master/gcore/statistics.txt</a>).
The class method <code>GDALRaster$getStatistics()</code> is a GDAL API wrapper that
computes statistics for a whole raster band.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

rs &lt;- new(RunningStats, na_rm=TRUE)
chunk &lt;- runif(1000)
rs$update(chunk)
object.size(rs)

rs$get_count()
length(chunk)

rs$get_mean()
mean(chunk)

rs$get_min()
min(chunk)

rs$get_max()
max(chunk)

rs$get_var()
var(chunk)

rs$get_sd()
sd(chunk)


## 10^9 values read in 10,000 chunks
## should take under 1 minute on most PC hardware
for (i in 1:1e4) {
  chunk &lt;- runif(1e5)
  rs$update(chunk)
}
rs$get_count()
rs$get_mean()
rs$get_var()

object.size(rs)

</code></pre>

<hr>
<h2 id='set_config_option'>Set GDAL configuration option</h2><span id='topic+set_config_option'></span>

<h3>Description</h3>

<p><code>set_config_option()</code> sets a GDAL runtime configuration option.
Configuration options are essentially global variables the user can set.
They are used to alter the default behavior of certain raster format
drivers, and in some cases the GDAL core. For a full description and
listing of available options see
<a href="https://gdal.org/user/configoptions.html">https://gdal.org/user/configoptions.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_config_option(key, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_config_option_+3A_key">key</code></td>
<td>
<p>Character name of a configuration option.</p>
</td></tr>
<tr><td><code id="set_config_option_+3A_value">value</code></td>
<td>
<p>Character value to set for the option.
<code>value = ""</code> (empty string) will unset a value previously set by
<code>set_config_option()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_config_option">get_config_option()</a></code>
</p>
<p><code>vignette("gdal-config-quick-ref")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_config_option("GDAL_CACHEMAX", "10%")
get_config_option("GDAL_CACHEMAX")
## unset:
set_config_option("GDAL_CACHEMAX", "")
</code></pre>

<hr>
<h2 id='sieveFilter'>Remove small raster polygons</h2><span id='topic+sieveFilter'></span>

<h3>Description</h3>

<p><code>sieveFilter()</code> is a wrapper for <code>GDALSieveFilter()</code> in the GDAL Algorithms
API. It removes raster polygons smaller than a provided threshold size
(in pixels) and replaces them with the pixel value of the largest neighbour
polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sieveFilter(
  src_filename,
  src_band,
  dst_filename,
  dst_band,
  size_threshold,
  connectedness,
  mask_filename = "",
  mask_band = 0L,
  options = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sieveFilter_+3A_src_filename">src_filename</code></td>
<td>
<p>Filename of the source raster to be processed.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_src_band">src_band</code></td>
<td>
<p>Band number in the source raster to be processed.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Filename of the output raster. It may be the same as
<code>src_filename</code> to update the source file in place.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_dst_band">dst_band</code></td>
<td>
<p>Band number in <code>dst_filename</code> to write output. It may be
the same as <code>src_band</code> to update the source raster in place.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_size_threshold">size_threshold</code></td>
<td>
<p>Integer. Raster polygons with sizes (in pixels)
smaller than this value will be merged into their largest neighbour.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_connectedness">connectedness</code></td>
<td>
<p>Integer. Either <code>4</code> indicating that diagonal pixels
are not considered directly adjacent for polygon membership purposes, or
<code>8</code> indicating they are.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_mask_filename">mask_filename</code></td>
<td>
<p>Optional filename of raster to use as a mask.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_mask_band">mask_band</code></td>
<td>
<p>Band number in <code>mask_filename</code> to use as a mask. All
pixels in the mask band with a value other than zero will be considered
suitable for inclusion in polygons.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_options">options</code></td>
<td>
<p>Algorithm options as a character vector of name=value pairs.
None currently supported.</p>
</td></tr>
<tr><td><code id="sieveFilter_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polygons are determined as regions of the raster where the pixels all have
the same value, and that are contiguous (connected).
Pixels determined to be &quot;nodata&quot; per the mask band will not be
treated as part of a polygon regardless of their pixel values. Nodata areas
will never be changed nor affect polygon sizes. Polygons smaller than the
threshold with no neighbours that are as large as the threshold will not be
altered. Polygons surrounded by nodata areas will therefore not be altered.
</p>
<p>The algorithm makes three passes over the input file to enumerate the
polygons and collect limited information about them. Memory use is
proportional to the number of polygons (roughly 24 bytes per polygon), but
is not directly related to the size of the raster. So very large raster
files can be processed effectively if there aren't too many polygons. But
extremely noisy rasters with many one pixel polygons will end up being
expensive (in memory) to process.
</p>
<p>The input dataset is read as integer data which means that floating point
values are rounded to integers.
</p>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## remove single-pixel polygons from the vegetation type layer (EVT)
evt_file &lt;- system.file("extdata/storml_evt.tif", package="gdalraster")

# create a blank raster to hold the output
evt_mmu_file &lt;- file.path(tempdir(), "storml_evt_mmu2.tif")
rasterFromRaster(srcfile = evt_file,
                 dstfile = evt_mmu_file,
                 init = 32767)

# create a mask to exclude water pixels from the algorithm
# recode water (7292) to 0
expr &lt;- "ifelse(EVT == 7292, 0, EVT)"
mask_file &lt;- calc(expr = expr,
                  rasterfiles = evt_file,
                  var.names = "EVT")

# create a version of EVT with two-pixel minimum mapping unit
sieveFilter(src_filename = evt_file,
            src_band = 1,
            dst_filename = evt_mmu_file,
            dst_band = 1,
            size_threshold = 2,
            connectedness = 8,
            mask_filename = mask_file,
            mask_band = 1)

deleteDataset(mask_file)
deleteDataset(evt_mmu_file)
</code></pre>

<hr>
<h2 id='srs_is_geographic'>Check if WKT definition is a geographic coordinate system</h2><span id='topic+srs_is_geographic'></span>

<h3>Description</h3>

<p><code>srs_is_geographic()</code> will attempt to import the given WKT string as a
spatial reference system, and returns <code>TRUE</code>  if the root is a
GEOGCS node. This is a wrapper for <code>OSRIsGeographic()</code> in the GDAL Spatial
Reference System C API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs_is_geographic(srs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs_is_geographic_+3A_srs">srs</code></td>
<td>
<p>Character OGC WKT string for a spatial reference system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if <code>srs</code> is geographic, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srs_is_projected">srs_is_projected()</a></code>, <code><a href="#topic+srs_is_same">srs_is_same()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>srs_is_geographic(epsg_to_wkt(5070))
srs_is_geographic(srs_to_wkt("WGS84"))
</code></pre>

<hr>
<h2 id='srs_is_projected'>Check if WKT definition is a projected coordinate system</h2><span id='topic+srs_is_projected'></span>

<h3>Description</h3>

<p><code>srs_is_projected()</code> will attempt to import the given WKT string as a
spatial reference system (SRS), and returns <code>TRUE</code> if the SRS contains a
PROJCS node indicating a it is a projected coordinate system. This is a
wrapper for <code>OSRIsProjected()</code> in the GDAL Spatial Reference System C API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs_is_projected(srs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs_is_projected_+3A_srs">srs</code></td>
<td>
<p>Character OGC WKT string for a spatial reference system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if <code>srs</code> is projected, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srs_is_geographic">srs_is_geographic()</a></code>, <code><a href="#topic+srs_is_same">srs_is_same()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>srs_is_projected(epsg_to_wkt(5070))
srs_is_projected(srs_to_wkt("WGS84"))
</code></pre>

<hr>
<h2 id='srs_is_same'>Do these two spatial references describe the same system?</h2><span id='topic+srs_is_same'></span>

<h3>Description</h3>

<p><code>srs_is_same()</code> returns <code>TRUE</code> if these two spatial references describe
the same system. This is a wrapper for <code>OSRIsSame()</code> in the GDAL Spatial
Reference System C API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs_is_same(
  srs1,
  srs2,
  criterion = "",
  ignore_axis_mapping = FALSE,
  ignore_coord_epoch = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs_is_same_+3A_srs1">srs1</code></td>
<td>
<p>Character string. OGC WKT for a spatial reference system.</p>
</td></tr>
<tr><td><code id="srs_is_same_+3A_srs2">srs2</code></td>
<td>
<p>Character string. OGC WKT for a spatial reference system.</p>
</td></tr>
<tr><td><code id="srs_is_same_+3A_criterion">criterion</code></td>
<td>
<p>Character string. One of <code>STRICT</code>, <code>EQUIVALENT</code>,
<code>EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS</code>.
Defaults to <code>EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS</code>.</p>
</td></tr>
<tr><td><code id="srs_is_same_+3A_ignore_axis_mapping">ignore_axis_mapping</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, sets
<code>IGNORE_DATA_AXIS_TO_SRS_AXIS_MAPPING=YES</code> in the call to <code>OSRIsSameEx()</code>
in the GDAL Spatial Reference System API. Defaults to <code>NO</code>.</p>
</td></tr>
<tr><td><code id="srs_is_same_+3A_ignore_coord_epoch">ignore_coord_epoch</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, sets
<code>IGNORE_COORDINATE_EPOCH=YES</code> in the call to <code>OSRIsSameEx()</code>
in the GDAL Spatial Reference System API. Defaults to <code>NO</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. <code>TRUE</code> if these two spatial references describe the same
system, otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srs_is_geographic">srs_is_geographic()</a></code>, <code><a href="#topic+srs_is_projected">srs_is_projected()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
ds &lt;- new(GDALRaster, elev_file, TRUE)
srs_is_same(ds$getProjectionRef(), epsg_to_wkt(26912))
srs_is_same(ds$getProjectionRef(), epsg_to_wkt(5070))
ds$close()
</code></pre>

<hr>
<h2 id='srs_to_wkt'>Convert various spatial reference formats to Well Known Text</h2><span id='topic+srs_to_wkt'></span>

<h3>Description</h3>

<p><code>srs_to_wkt()</code> converts a spatial reference system (SRS) definition
in various text formats to WKT. The function will examine the input SRS,
try to deduce the format, and then export it to WKT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs_to_wkt(srs, pretty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs_to_wkt_+3A_srs">srs</code></td>
<td>
<p>Character string containing an SRS definition in various
formats (see Details).</p>
</td></tr>
<tr><td><code id="srs_to_wkt_+3A_pretty">pretty</code></td>
<td>
<p>Logical. <code>TRUE</code> to return a nicely formatted WKT string
for display to a person. <code>FALSE</code> for a regular WKT string (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code>OSRSetFromUserInput()</code> in the GDAL Spatial
Reference System C API with output to WKT.
The input SRS may take the following forms:
</p>

<ul>
<li><p> WKT - to convert WKT versions (see below)
</p>
</li>
<li><p> EPSG:n - EPSG code n
</p>
</li>
<li><p> AUTO:proj_id,unit_id,lon0,lat0 - WMS auto projections
</p>
</li>
<li><p> urn:ogc:def:crs:EPSG::n - OGC URNs
</p>
</li>
<li><p> PROJ.4 definitions
</p>
</li>
<li><p> filename - file to read for WKT, XML or PROJ.4 definition
</p>
</li>
<li><p> well known name such as NAD27, NAD83, WGS84 or WGS72
</p>
</li>
<li><p> IGNF:xxxx, ESRI:xxxx - definitions from the PROJ database
</p>
</li>
<li><p> PROJJSON (PROJ &gt;= 6.2)
</p>
</li></ul>

<p>This function is intended to be flexible, but by its nature it is
imprecise as it must guess information about the format intended.
<code><a href="#topic+epsg_to_wkt">epsg_to_wkt()</a></code> could be used instead for EPSG codes.
</p>
<p>As of GDAL 3.0, the default format for WKT export is OGC WKT 1.
The WKT version can be overridden by using the OSR_WKT_FORMAT
configuration option (see <code><a href="#topic+set_config_option">set_config_option()</a></code>).
Valid values are one of: SFSQL, WKT1_SIMPLE, WKT1, WKT1_GDAL,
WKT1_ESRI, WKT2_2015, WKT2_2018, WKT2, DEFAULT.
If SFSQL, a WKT1 string without AXIS, TOWGS84, AUTHORITY or
EXTENSION node is returned. If WKT1_SIMPLE, a WKT1 string without
AXIS, AUTHORITY or EXTENSION node is returned. WKT1 is an alias of
WKT1_GDAL. WKT2 will default to the latest revision implemented
(currently WKT2_2018). WKT2_2019 can be used as an alias of
WKT2_2018 since GDAL 3.2
</p>


<h3>Value</h3>

<p>Character string containing OGC WKT.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epsg_to_wkt">epsg_to_wkt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>srs_to_wkt("NAD83")
writeLines(srs_to_wkt("NAD83", pretty=TRUE))
set_config_option("OSR_WKT_FORMAT", "WKT2")
writeLines(srs_to_wkt("NAD83", pretty=TRUE))
set_config_option("OSR_WKT_FORMAT", "")
</code></pre>

<hr>
<h2 id='transform_xy'>Transform geospatial x/y coordinates</h2><span id='topic+transform_xy'></span>

<h3>Description</h3>

<p><code>transform_xy()</code> transforms geospatial x/y coordinates to a new projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_xy(pts, srs_from, srs_to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_xy_+3A_pts">pts</code></td>
<td>
<p>A two-column data frame or numeric matrix containing geospatial
x/y coordinates.</p>
</td></tr>
<tr><td><code id="transform_xy_+3A_srs_from">srs_from</code></td>
<td>
<p>Character string in OGC WKT format specifying the
spatial reference system for <code>pts</code>.</p>
</td></tr>
<tr><td><code id="transform_xy_+3A_srs_to">srs_to</code></td>
<td>
<p>Character string in OGC WKT format specifying the output
spatial reference system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric array of geospatial x/y coordinates in the projection
specified by <code>srs_to</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epsg_to_wkt">epsg_to_wkt()</a></code>, <code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>, <code><a href="#topic+inv_project">inv_project()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt_file &lt;- system.file("extdata/storml_pts.csv", package="gdalraster")
pts &lt;- read.csv(pt_file)
print(pts)
## id, x, y in NAD83 / UTM zone 12N
## transform to NAD83 / CONUS Albers
transform_xy(pts = pts[,-1],
             srs_from = epsg_to_wkt(26912),
             srs_to = epsg_to_wkt(5070))
</code></pre>

<hr>
<h2 id='translate'>Convert raster data between different formats</h2><span id='topic+translate'></span>

<h3>Description</h3>

<p><code>translate()</code> is a wrapper of the <code>gdal_translate</code> command-line
utility (see <a href="https://gdal.org/programs/gdal_translate.html">https://gdal.org/programs/gdal_translate.html</a>).
The function can be used to convert raster data between different
formats, potentially performing some operations like subsetting,
resampling, and rescaling pixels in the process. Refer to the GDAL
documentation at the URL above for a list of command-line arguments that
can be passed in <code>cl_arg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(src_filename, dst_filename, cl_arg = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_src_filename">src_filename</code></td>
<td>
<p>Character string. Filename of the source raster.</p>
</td></tr>
<tr><td><code id="translate_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Character string. Filename of the output raster.</p>
</td></tr>
<tr><td><code id="translate_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments for
<code>gdal_translate</code> (see URL above).</p>
</td></tr>
<tr><td><code id="translate_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+rasterFromRaster">rasterFromRaster()</a></code>, <code><a href="#topic+warp">warp()</a></code>
</p>
<p><code><a href="#topic+ogr2ogr">ogr2ogr()</a></code> for vector data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert the elevation raster to Erdas Imagine format and resample to 90m
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")

# command-line arguments for gdal_translate
args &lt;- c("-tr", "90", "90", "-r", "average")
args &lt;- c(args, "-of", "HFA", "-co", "COMPRESSED=YES")

img_file &lt;- file.path(tempdir(), "storml_elev_90m.img")
translate(elev_file, img_file, args)

ds &lt;- new(GDALRaster, img_file)
ds$getDriverLongName()
ds$bbox()
ds$res()
ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
ds$close()

deleteDataset(img_file)
</code></pre>

<hr>
<h2 id='vsi_clear_path_options'>Clear path specific configuration options</h2><span id='topic+vsi_clear_path_options'></span>

<h3>Description</h3>

<p><code>vsi_clear_path_options()</code> clears path specific options previously set
with <code>vsi_set_path_option()</code>.
Wrapper for <code>VSIClearPathSpecificOptions()</code> in the GDAL Common Portability
Library. Requires GDAL &gt;= 3.6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_clear_path_options(path_prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_clear_path_options_+3A_path_prefix">path_prefix</code></td>
<td>
<p>Character string. If set to <code>""</code> (empty string), all
path specific options are cleared. If set to a path prefix, only those
options set with <code>vsi_set_path_option(path_prefix, ...)</code> will be cleared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effect.
</p>


<h3>Note</h3>

<p>No particular care is taken to remove options from RAM in a secure way.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_set_path_option">vsi_set_path_option()</a></code>
</p>

<hr>
<h2 id='vsi_constants'>Constants for VSIFile$seek()</h2><span id='topic+vsi_constants'></span><span id='topic+SEEK_SET'></span><span id='topic+SEEK_CUR'></span><span id='topic+SEEK_END'></span>

<h3>Description</h3>

<p>These are package global constants for convenience in calling
<code>VSIFile$seek()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEEK_SET

SEEK_CUR

SEEK_END
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='vsi_copy_file'>Copy a source file to a target filename</h2><span id='topic+vsi_copy_file'></span>

<h3>Description</h3>

<p><code>vsi_copy_file()</code> is a wrapper for <code>VSICopyFile()</code> in the GDAL Common
Portability Library. The GDAL VSI functions allow virtualization of disk
I/O so that non file data sources can be made to appear as files.
See <a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>.
Requires GDAL &gt;= 3.7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_copy_file(src_file, target_file, show_progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_copy_file_+3A_src_file">src_file</code></td>
<td>
<p>Character string. Filename of the source file.</p>
</td></tr>
<tr><td><code id="vsi_copy_file_+3A_target_file">target_file</code></td>
<td>
<p>Character string. Filename of the target file.</p>
</td></tr>
<tr><td><code id="vsi_copy_file_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will be
displayed (the size of <code>src_file</code> will be retrieved in GDAL with
<code>VSIStatL()</code>). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following copies are made fully on the target server, without local
download from source and upload to target:
</p>

<ul>
<li><p> /vsis3/ -&gt; /vsis3/
</p>
</li>
<li><p> /vsigs/ -&gt; /vsigs/
</p>
</li>
<li><p> /vsiaz/ -&gt; /vsiaz/
</p>
</li>
<li><p> /vsiadls/ -&gt; /vsiadls/
</p>
</li>
<li><p> any of the above or /vsicurl/ -&gt; /vsiaz/ (starting with GDAL 3.8)
</p>
</li></ul>



<h3>Value</h3>

<p><code>0</code> on success or <code>-1</code> on an error.
</p>


<h3>Note</h3>

<p>If <code>target_file</code> has the form /vsizip/foo.zip/bar, the default options
described for the function <code>addFilesInZip()</code> will be in effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copyDatasetFiles">copyDatasetFiles()</a></code>, <code><a href="#topic+vsi_stat">vsi_stat()</a></code>, <code><a href="#topic+vsi_sync">vsi_sync()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
tmp_file &lt;- "/vsimem/elev_temp.tif"

# Requires GDAL &gt;= 3.7
if (as.integer(gdal_version()[2]) &gt;= 3070000) {
  result &lt;- vsi_copy_file(elev_file, tmp_file)
  print(result)
  print(vsi_stat(tmp_file, "size"))

  vsi_unlink(tmp_file)
}
</code></pre>

<hr>
<h2 id='vsi_curl_clear_cache'>Clean cache associated with /vsicurl/ and related file systems</h2><span id='topic+vsi_curl_clear_cache'></span>

<h3>Description</h3>

<p><code>vsi_curl_clear_cache()</code> cleans the local cache associated with /vsicurl/
(and related file systems). This function is a wrapper for
<code>VSICurlClearCache()</code> and <code>VSICurlPartialClearCache()</code> in the GDAL Common
Portability Library. See Details for the GDAL documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_curl_clear_cache(partial = FALSE, file_prefix = "", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_curl_clear_cache_+3A_partial">partial</code></td>
<td>
<p>Logical scalar. Whether to clear the cache only for a given
filename (see Details).</p>
</td></tr>
<tr><td><code id="vsi_curl_clear_cache_+3A_file_prefix">file_prefix</code></td>
<td>
<p>Character string. Filename prefix to use if
<code>partial = TRUE</code>.</p>
</td></tr>
<tr><td><code id="vsi_curl_clear_cache_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> (the default) to wrap the API call in
a quiet error handler, or <code>FALSE</code> to print any potential error messages to
the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>/vsicurl/ (and related file systems like /vsis3/, /vsigs/, /vsiaz/,
/vsioss/, /vsiswift/) cache a number of metadata and data for faster
execution in read-only scenarios. But when the content on the server-side
may change during the same process, those mechanisms can prevent opening
new files, or give an outdated version of them.
If <code>partial = TRUE</code>, cleans the local cache associated for a given filename
(and its subfiles and subdirectories if it is a directory).
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vsi_curl_clear_cache()
</code></pre>

<hr>
<h2 id='vsi_get_disk_free_space'>Return free disk space available on the filesystem</h2><span id='topic+vsi_get_disk_free_space'></span>

<h3>Description</h3>

<p><code>vsi_get_disk_free_space()</code> returns the free disk space available on the
filesystem. Wrapper for <code>VSIGetDiskFreeSpace()</code> in the GDAL Common
Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_get_disk_free_space(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_get_disk_free_space_+3A_path">path</code></td>
<td>
<p>Character string. A directory of the filesystem to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scalar. The free space in bytes (as <code>bit64::integer64</code>
type), or <code>-1</code> in case of error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- file.path("/vsimem", "tmpdir")
vsi_mkdir(tmp_dir)
vsi_get_disk_free_space(tmp_dir)
vsi_rmdir(tmp_dir)
</code></pre>

<hr>
<h2 id='vsi_get_file_metadata'>Get metadata on files</h2><span id='topic+vsi_get_file_metadata'></span>

<h3>Description</h3>

<p><code>vsi_get_file_metadata()</code> returns metadata for file system objects.
Implemented for network-like filesystems. Starting with GDAL 3.7,
implemented for /vsizip/ with SOZip metadata.
Wrapper of <code>VSIGetFileMetadata()</code> in the GDAL Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_get_file_metadata(filename, domain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_get_file_metadata_+3A_filename">filename</code></td>
<td>
<p>Character string. The path of the file system object to be
queried.</p>
</td></tr>
<tr><td><code id="vsi_get_file_metadata_+3A_domain">domain</code></td>
<td>
<p>Character string. Metadata domain to query. Depends on the
file system, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metadata available depends on the file system. The following are
supported as of GDAL 3.9:
</p>

<ul>
<li><p> HEADERS: to get HTTP headers for network-like filesystems (/vsicurl/,
/vsis3/, /vsgis/, etc).
</p>
</li>
<li><p> TAGS: for /vsis3/, to get S3 Object tagging information. For /vsiaz/,
to get blob tags.
</p>
</li>
<li><p> STATUS: specific to /vsiadls/: returns all system-defined properties
for a path (seems in practice to be a subset of HEADERS).
</p>
</li>
<li><p> ACL: specific to /vsiadls/ and /vsigs/: returns the access control list
for a path. For /vsigs/, a single <code>XML=xml_content</code> string is returned.
</p>
</li>
<li><p> METADATA: specific to /vsiaz/: blob metadata (this will be a subset of
what <code>domain=HEADERS</code> returns).
</p>
</li>
<li><p> ZIP: specific to /vsizip/: to obtain ZIP specific metadata, in
particular if a file is SOZIP-enabled (<code>SOZIP_VALID=YES</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>A named list of values, or <code>NULL</code> in case of error or empty list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_stat">vsi_stat()</a></code>, <code><a href="#topic+addFilesInZip">addFilesInZip()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an SOZip-enabled file and validate
# Requires GDAL &gt;= 3.7
f &lt;- system.file("extdata/ynp_fires_1984_2022.gpkg", package="gdalraster")

if (as.integer(gdal_version()[2]) &gt;= 3070000) {
  zip_file &lt;- tempfile(fileext=".zip")
  addFilesInZip(zip_file, f, full_paths=FALSE, sozip_enabled="YES")
  zip_vsi &lt;- file.path("/vsizip", zip_file)
  print("Files in zip archive:")
  print(vsi_read_dir(zip_vsi))
  print("SOZip metadata:")
  print(vsi_get_file_metadata(zip_vsi, domain="ZIP"))

  vsi_unlink(zip_file)
}
</code></pre>

<hr>
<h2 id='vsi_get_fs_options'>Return the list of options associated with a virtual file system handler</h2><span id='topic+vsi_get_fs_options'></span>

<h3>Description</h3>

<p><code>vsi_get_fs_options()</code> returns the list of options associated with a virtual
file system handler. Those options may be set as configuration options with
<code>set_config_option()</code>.
Wrapper for <code>VSIGetFileSystemOptions()</code> in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_get_fs_options(filename, as_list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_get_fs_options_+3A_filename">filename</code></td>
<td>
<p>Filename, or prefix of a virtual file system handler.</p>
</td></tr>
<tr><td><code id="vsi_get_fs_options_+3A_as_list">as_list</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default), the XML string
returned by GDAL will be coerced to list. <code>FALSE</code> to return the configuration
options as a serialized XML string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An XML string, or empty string (<code>""</code>) if no options are declared.
If <code>as_list = TRUE</code> (the default), the XML string will be coerced to list
with <code>xml2::as_list()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_config_option">set_config_option()</a></code>, <code><a href="#topic+vsi_get_fs_prefixes">vsi_get_fs_prefixes()</a></code>
</p>
<p><a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vsi_get_fs_options("/vsimem/")

vsi_get_fs_options("/vsizip/")

vsi_get_fs_options("/vsizip/", as_list = FALSE)
</code></pre>

<hr>
<h2 id='vsi_get_fs_prefixes'>Return the list of virtual file system handlers currently registered</h2><span id='topic+vsi_get_fs_prefixes'></span>

<h3>Description</h3>

<p><code>vsi_get_fs_prefixes()</code> returns the list of prefixes for virtual file
system handlers currently registered (e.g., <code>"/vsimem/"</code>, <code>"/vsicurl/"</code>,
etc). Wrapper for <code>VSIGetFileSystemsPrefixes()</code> in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_get_fs_prefixes()
</code></pre>


<h3>Value</h3>

<p>Character vector containing prefixes of the virtual file system
handlers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_get_fs_options">vsi_get_fs_options()</a></code>
</p>
<p><a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vsi_get_fs_prefixes()
</code></pre>

<hr>
<h2 id='vsi_mkdir'>Create a directory</h2><span id='topic+vsi_mkdir'></span>

<h3>Description</h3>

<p><code>vsi_mkdir()</code> creates a new directory with the indicated mode.
For POSIX-style systems, the mode is modified by the file creation mask
(umask). However, some file systems and platforms may not use umask, or
they may ignore the mode completely. So a reasonable cross-platform
default mode value is <code>0755</code>.
With <code>recursive = TRUE</code>, creates a directory and all its ancestors.
This function is a wrapper for <code>VSIMkdir()</code> and <code>VSIMkdirRecursive()</code> in
the GDAL Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_mkdir(path, mode = "0755", recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_mkdir_+3A_path">path</code></td>
<td>
<p>Character string. The path to the directory to create.</p>
</td></tr>
<tr><td><code id="vsi_mkdir_+3A_mode">mode</code></td>
<td>
<p>Character string. The permissions mode in octal with prefix
<code>0</code>, e.g., <code>"0755"</code> (the default).</p>
</td></tr>
<tr><td><code id="vsi_mkdir_+3A_recursive">recursive</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to create the directory and its
ancestors. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0</code> on success or <code>-1</code> on an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_read_dir">vsi_read_dir()</a></code>, <code><a href="#topic+vsi_rmdir">vsi_rmdir()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_dir &lt;- file.path(tempdir(), "newdir")
vsi_mkdir(new_dir)
vsi_stat(new_dir, "type")
vsi_rmdir(new_dir)
</code></pre>

<hr>
<h2 id='vsi_read_dir'>Read names in a directory</h2><span id='topic+vsi_read_dir'></span>

<h3>Description</h3>

<p><code>vsi_read_dir()</code> abstracts access to directory contents. It returns a
character vector containing the names of files and directories in this
directory. This function is a wrapper for <code>VSIReadDirEx()</code> in the GDAL
Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_read_dir(path, max_files = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_read_dir_+3A_path">path</code></td>
<td>
<p>Character string. The relative or absolute path of a
directory to read.</p>
</td></tr>
<tr><td><code id="vsi_read_dir_+3A_max_files">max_files</code></td>
<td>
<p>Integer scalar. The maximum number of files after which to
stop, or 0 for no limit (see Note).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the names of files and directories
in the directory given by <code>path</code>. An empty string (<code>""</code>) is returned if
<code>path</code> does not exist.
</p>


<h3>Note</h3>

<p>If <code>max_files</code> is set to a positive number, directory listing will stop
after that limit has been reached. Note that to indicate truncation, at
least one element more than the <code>max_files</code> limit will be returned. If the
length of the returned character vector is lesser or equal to <code>max_files</code>,
then no truncation occurred.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_mkdir">vsi_mkdir()</a></code>, <code><a href="#topic+vsi_rmdir">vsi_rmdir()</a></code>, <code><a href="#topic+vsi_stat">vsi_stat()</a></code>, <code><a href="#topic+vsi_sync">vsi_sync()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regular file system for illustration
data_dir &lt;- system.file("extdata", package="gdalraster")
vsi_read_dir(data_dir)
</code></pre>

<hr>
<h2 id='vsi_rename'>Rename a file</h2><span id='topic+vsi_rename'></span>

<h3>Description</h3>

<p><code>vsi_rename()</code> renames a file object in the file system. The GDAL
documentation states it should be possible to rename a file onto a new
filesystem, but it is safest if this function is only used to rename files
that remain in the same directory.
This function goes through the GDAL <code>VSIFileHandler</code> virtualization and may
work on unusual filesystems such as in memory.
It is a wrapper for <code>VSIRename()</code> in the GDAL Common Portability Library.
Analog of the POSIX <code>rename()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_rename(oldpath, newpath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_rename_+3A_oldpath">oldpath</code></td>
<td>
<p>Character string. The name of the file to be renamed.</p>
</td></tr>
<tr><td><code id="vsi_rename_+3A_newpath">newpath</code></td>
<td>
<p>Character string. The name the file should be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0</code> on success or <code>-1</code> on an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renameDataset">renameDataset()</a></code>, <code><a href="#topic+vsi_copy_file">vsi_copy_file()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regular file system for illustration
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
tmp_file &lt;- tempfile(fileext = ".tif")
file.copy(elev_file, tmp_file)
new_file &lt;- file.path(dirname(tmp_file), "storml_elev_copy.tif")
vsi_rename(tmp_file, new_file)
vsi_stat(new_file)
vsi_unlink(new_file)
</code></pre>

<hr>
<h2 id='vsi_rmdir'>Delete a directory</h2><span id='topic+vsi_rmdir'></span>

<h3>Description</h3>

<p><code>vsi_rmdir()</code> deletes a directory object from the file system. On some
systems the directory must be empty before it can be deleted.
With <code>recursive = TRUE</code>, deletes a directory object and its content from
the file system.
This function goes through the GDAL <code>VSIFileHandler</code> virtualization and may
work on unusual filesystems such as in memory.
It is a wrapper for <code>VSIRmdir()</code> and <code>VSIRmdirRecursive()</code> in the GDAL
Common Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_rmdir(path, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_rmdir_+3A_path">path</code></td>
<td>
<p>Character string. The path to the directory to be deleted.</p>
</td></tr>
<tr><td><code id="vsi_rmdir_+3A_recursive">recursive</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> to delete the directory and its
content. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0</code> on success or <code>-1</code> on an error.
</p>


<h3>Note</h3>

<p>/vsis3/ has an efficient implementation for deleting recursively. Starting
with GDAL 3.4, /vsigs/ has an efficient implementation for deleting
recursively, provided that OAuth2 authentication is used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deleteDataset">deleteDataset()</a></code>, <code><a href="#topic+vsi_mkdir">vsi_mkdir()</a></code>, <code><a href="#topic+vsi_read_dir">vsi_read_dir()</a></code>, <code><a href="#topic+vsi_unlink">vsi_unlink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_dir &lt;- file.path(tempdir(), "newdir")
vsi_mkdir(new_dir)
vsi_rmdir(new_dir)
</code></pre>

<hr>
<h2 id='vsi_set_path_option'>Set a path specific option for a given path prefix</h2><span id='topic+vsi_set_path_option'></span>

<h3>Description</h3>

<p><code>vsi_set_path_option()</code> sets a path specific option for a given path
prefix. Such an option is typically, but not limited to, setting
credentials for a virtual file system.
Wrapper for <code>VSISetPathSpecificOption()</code> in the GDAL Common Portability
Library. Requires GDAL &gt;= 3.6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_set_path_option(path_prefix, key, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_set_path_option_+3A_path_prefix">path_prefix</code></td>
<td>
<p>Character string. A path prefix of a virtual file system
handler. Typically of the form <code style="white-space: pre;">&#8288;/vsiXXX/bucket&#8288;</code>.</p>
</td></tr>
<tr><td><code id="vsi_set_path_option_+3A_key">key</code></td>
<td>
<p>Character string. Option key.</p>
</td></tr>
<tr><td><code id="vsi_set_path_option_+3A_value">value</code></td>
<td>
<p>Character string. Option value. Passing <code>value = ""</code> (empty
string) will unset a value previously set by <code>vsi_set_path_option()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Options may also be set with <code>set_config_option()</code>, but
<code>vsi_set_path_option()</code> allows specifying them with a granularity at the
level of a file path. This makes it easier if using the same virtual file
system but with different credentials (e.g., different credentials for
buckets &quot;/vsis3/foo&quot; and &quot;/vsis3/bar&quot;). This is supported for the following
virtual file systems: /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiwebhdfs,
/vsiswift.
</p>


<h3>Value</h3>

<p>No return value, called for side effect.
</p>


<h3>Note</h3>

<p>Setting options for a path starting with /vsiXXX/ will also apply for
/vsiXXX_streaming/ requests.
</p>
<p>No particular care is taken to store options in RAM in a secure way.
So they might accidentally hit persistent storage if swapping occurs,
or someone with access to the memory allocated by the process may be
able to read them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_config_option">set_config_option()</a></code>, <code><a href="#topic+vsi_clear_path_options">vsi_clear_path_options()</a></code>
</p>

<hr>
<h2 id='vsi_stat'>Get filesystem object info</h2><span id='topic+vsi_stat'></span>

<h3>Description</h3>

<p><code>vsi_stat()</code> fetches status information about a filesystem object (file,
directory, etc).
This function goes through the GDAL <code>VSIFileHandler</code> virtualization and may
work on unusual filesystems such as in memory.
It is a wrapper for <code>VSIStatExL()</code> in the GDAL Common Portability Library.
Analog of the POSIX <code>stat()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_stat(filename, info = "exists")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_stat_+3A_filename">filename</code></td>
<td>
<p>Character string. The path of the filesystem object to be
queried.</p>
</td></tr>
<tr><td><code id="vsi_stat_+3A_info">info</code></td>
<td>
<p>Character string. The type of information to fetch, one of
<code>"exists"</code> (the default), <code>"type"</code> or <code>"size"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>info = "exists"</code>, returns logical <code>TRUE</code> if the file system
object exists, otherwise <code>FALSE</code>. If <code>info = "type"</code>, returns a character
string with one of <code>"file"</code> (regular file), <code>"dir"</code> (directory),
<code>"symlink"</code> (symbolic link), or empty string (<code>""</code>). If <code>info = "size"</code>,
returns the file size in bytes (as <code>bit64::integer64</code> type), or <code>-1</code> if an
error occurs.
</p>


<h3>Note</h3>

<p>For portability, <code>vsi_stat()</code> supports a subset of <code>stat()</code>-type
information for filesystem objects. This function is primarily intended
for use with GDAL virtual file systems (e.g., URLs, cloud storage systems,
ZIP/GZip/7z/RAR archives, in-memory files).
The base R function <code>utils::file_test()</code> could be used instead for file
tests on regular local filesystems.
</p>


<h3>See Also</h3>

<p>GDAL Virtual File Systems:<br />
<a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_dir &lt;- system.file("extdata", package="gdalraster")
vsi_stat(data_dir)
vsi_stat(data_dir, "type")
# stat() on a directory doesn't return the sum of the file sizes in it,
# but rather how much space is used by the directory entry
vsi_stat(data_dir, "size")

elev_file &lt;- file.path(data_dir, "storml_elev.tif")
vsi_stat(elev_file)
vsi_stat(elev_file, "type")
vsi_stat(elev_file, "size")

nonexistent &lt;- file.path(data_dir, "nonexistent.tif")
vsi_stat(nonexistent)
vsi_stat(nonexistent, "type")
vsi_stat(nonexistent, "size")

# /vsicurl/ file system handler
base_url &lt;- "https://raw.githubusercontent.com/usdaforestservice/"
f &lt;- "gdalraster/main/sample-data/landsat_c2ard_sr_mt_hood_jul2022_utm.tif"
url_file &lt;- paste0("/vsicurl/", base_url, f)

vsi_stat(url_file)
vsi_stat(url_file, "type")
vsi_stat(url_file, "size")
</code></pre>

<hr>
<h2 id='vsi_supports_rnd_write'>Return whether the filesystem supports random write</h2><span id='topic+vsi_supports_rnd_write'></span>

<h3>Description</h3>

<p><code>vsi_supports_rnd_write()</code> returns whether the filesystem supports
random write.
Wrapper for <code>VSISupportsRandomWrite()</code> in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_supports_rnd_write(filename, allow_local_tmpfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_supports_rnd_write_+3A_filename">filename</code></td>
<td>
<p>Character string. The path of the filesystem object to be
tested.</p>
</td></tr>
<tr><td><code id="vsi_supports_rnd_write_+3A_allow_local_tmpfile">allow_local_tmpfile</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> if the filesystem is
allowed to use a local temporary file before uploading to the target
location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar. <code>TRUE</code> if random write is supported.
</p>


<h3>Note</h3>

<p>The location GDAL uses for temporary files can be forced via the
<code>CPL_TMPDIR</code> configuration option.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_supports_seq_write">vsi_supports_seq_write()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires GDAL &gt;= 3.6
if (as.integer(gdal_version()[2]) &gt;= 3060000)
  vsi_supports_rnd_write("/vsimem/test-mem-file.gpkg", TRUE)
</code></pre>

<hr>
<h2 id='vsi_supports_seq_write'>Return whether the filesystem supports sequential write</h2><span id='topic+vsi_supports_seq_write'></span>

<h3>Description</h3>

<p><code>vsi_supports_seq_write()</code> returns whether the filesystem supports
sequential write.
Wrapper for <code>VSISupportsSequentialWrite()</code> in the GDAL API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_supports_seq_write(filename, allow_local_tmpfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_supports_seq_write_+3A_filename">filename</code></td>
<td>
<p>Character string. The path of the filesystem object to be
tested.</p>
</td></tr>
<tr><td><code id="vsi_supports_seq_write_+3A_allow_local_tmpfile">allow_local_tmpfile</code></td>
<td>
<p>Logical scalar. <code>TRUE</code> if the filesystem is
allowed to use a local temporary file before uploading to the target
location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar. <code>TRUE</code> if sequential write is supported.
</p>


<h3>Note</h3>

<p>The location GDAL uses for temporary files can be forced via the
<code>CPL_TMPDIR</code> configuration option.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vsi_supports_rnd_write">vsi_supports_rnd_write()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires GDAL &gt;= 3.6
if (as.integer(gdal_version()[2]) &gt;= 3060000)
  vsi_supports_seq_write("/vsimem/test-mem-file.gpkg", TRUE)
</code></pre>

<hr>
<h2 id='vsi_sync'>Synchronize a source file/directory with a target file/directory</h2><span id='topic+vsi_sync'></span>

<h3>Description</h3>

<p><code>vsi_sync()</code> is a wrapper for <code>VSISync()</code> in the GDAL Common Portability
Library. The GDAL documentation is given in Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_sync(src, target, show_progress = FALSE, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_sync_+3A_src">src</code></td>
<td>
<p>Character string. Source file or directory.</p>
</td></tr>
<tr><td><code id="vsi_sync_+3A_target">target</code></td>
<td>
<p>Character string. Target file or directory.</p>
</td></tr>
<tr><td><code id="vsi_sync_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsi_sync_+3A_options">options</code></td>
<td>
<p>Character vector of <code>NAME=VALUE</code> pairs (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>VSISync()</code> is an analog of the Linux <code>rsync</code> utility. In the current
implementation, <code>rsync</code> would be more efficient for local file copying,
but <code>VSISync()</code> main interest is when the source or target is a remote
file system like /vsis3/ or /vsigs/, in which case it can take into account
the timestamps of the files (or optionally the ETag/MD5Sum) to avoid
unneeded copy operations.
This is only implemented efficiently for:
</p>

<ul>
<li><p> local filesystem &lt;&ndash;&gt; remote filesystem
</p>
</li>
<li><p> remote filesystem &lt;&ndash;&gt; remote filesystem (starting with GDAL 3.1)<br />
Where the source and target remote filesystems are the same and one of
/vsis3/, /vsigs/ or /vsiaz/. Or when the target is /vsiaz/ and the source
is /vsis3/, /vsigs/, /vsiadls/ or /vsicurl/ (starting with GDAL 3.8)
</p>
</li></ul>

<p>Similarly to <code>rsync</code> behavior, if the source filename ends with a slash, it
means that the content of the directory must be copied, but not the
directory name. For example, assuming &quot;/home/even/foo&quot; contains a file
&quot;bar&quot;, <code>VSISync("/home/even/foo/", "/mnt/media", ...)</code> will create a
&quot;/mnt/media/bar&quot; file.
Whereas <code>VSISync("/home/even/foo", "/mnt/media", ...)</code> will create a
&quot;/mnt/media/foo&quot; directory which contains a bar file.
</p>
<p>The <code>options</code> argument accepts a character vector of name=value pairs.
Currently accepted options are:<br />
</p>

<ul>
<li> <p><code>RECURSIVE=NO</code> (the default is <code>YES</code>)
</p>
</li>
<li> <p><code>SYNC_STRATEGY=TIMESTAMP/ETAG/OVERWRITE</code>. Determines which criterion is
used to determine if a target file must be replaced when it already exists
and has the same file size as the source. Only applies for a source or
target being a network filesystem.
The default is <code>TIMESTAMP</code> (similarly to how 'aws s3 sync' works), that is
to say that for an upload operation, a remote file is replaced if it has a
different size or if it is older than the source. For a download operation,
a local file is replaced if it has a different size or if it is newer than
the remote file.
The <code>ETAG</code> strategy assumes that the ETag metadata of the remote file is
the MD5Sum of the file content, which is only true in the case of /vsis3/
for files not using KMS server side encryption and uploaded in a single PUT
operation (so smaller than 50 MB given the default used by GDAL). Only to
be used for /vsis3/, /vsigs/ or other filesystems using a MD5Sum as ETAG.
The <code>OVERWRITE</code> strategy (GDAL &gt;= 3.2) will always overwrite the target
file with the source one.<br />
</p>
</li>
<li> <p><code>NUM_THREADS=integer</code>. Number of threads to use for parallel file
copying. Only use for when /vsis3/, /vsigs/, /vsiaz/ or /vsiadls/ is
in source or target. The default is 10 since GDAL 3.3.<br />
</p>
</li>
<li> <p><code>CHUNK_SIZE=integer</code>. Maximum size of chunk (in bytes) to use to split
large objects when downloading them from /vsis3/, /vsigs/, /vsiaz/
or /vsiadls/ to local file system, or for upload to /vsis3/, /vsiaz/ or
/vsiadls/ from local file system. Only used if <code>NUM_THREADS &gt; 1</code>.
For upload to /vsis3/, this chunk size must be set at least to 5 MB. The
default is 8 MB since GDAL 3.3.<br />
</p>
</li>
<li> <p><code>x-amz-KEY=value</code>. (GDAL &gt;= 3.5) MIME header to pass during creation of a
/vsis3/ object.<br />
</p>
</li>
<li> <p><code>x-goog-KEY=value</code>. (GDAL &gt;= 3.5) MIME header to pass during creation of a
/vsigs/ object.<br />
</p>
</li>
<li> <p><code>x-ms-KEY=value</code>. (GDAL &gt;= 3.5) MIME header to pass during creation of a
/vsiaz/ or /vsiadls/ object.
</p>
</li></ul>



<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> on success or <code>FALSE</code> on an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copyDatasetFiles">copyDatasetFiles()</a></code>, <code><a href="#topic+vsi_copy_file">vsi_copy_file()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sample-data is a directory in the git repository for gdalraster that is
# not included in the R package:
# https://github.com/USDAForestService/gdalraster/tree/main/sample-data
# A copy of sample-data in an AWS S3 bucket, and a partial copy in an
# Azure Blob container, were used to generate the example below.

src &lt;- "/vsis3/gdalraster-sample-data/"
# s3://gdalraster-sample-data is not public, set credentials
set_config_option("AWS_ACCESS_KEY_ID", "xxxxxxxxxxxxxx")
set_config_option("AWS_SECRET_ACCESS_KEY", "xxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
vsi_read_dir(src)
#&gt; [1] "README.md"
#&gt; [2] "bl_mrbl_ng_jul2004_rgb_720x360.tif"
#&gt; [3] "blue_marble_ng_neo_metadata.xml"
#&gt; [4] "landsat_c2ard_sr_mt_hood_jul2022_utm.json"
#&gt; [5] "landsat_c2ard_sr_mt_hood_jul2022_utm.tif"
#&gt; [6] "lf_elev_220_metadata.html"
#&gt; [7] "lf_elev_220_mt_hood_utm.tif"
#&gt; [8] "lf_fbfm40_220_metadata.html"
#&gt; [9] "lf_fbfm40_220_mt_hood_utm.tif"

dst &lt;- "/vsiaz/sampledata"
set_config_option("AZURE_STORAGE_CONNECTION_STRING",
                  "&lt;connection_string_for_gdalraster_account&gt;")
vsi_read_dir(dst)
#&gt; [1] "lf_elev_220_metadata.html"   "lf_elev_220_mt_hood_utm.tif"

# GDAL VSISync() supports direct copy for /vsis3/ -&gt; /vsiaz/ (GDAL &gt;= 3.8)
result &lt;- vsi_sync(src, dst, show_progress = TRUE)
#&gt; 0...10...20...30...40...50...60...70...80...90...100 - done.
print(result)
#&gt; [1] TRUE
vsi_read_dir(dst)
#&gt; [1] "README.md"
#&gt; [2] "bl_mrbl_ng_jul2004_rgb_720x360.tif"
#&gt; [3] "blue_marble_ng_neo_metadata.xml"
#&gt; [4] "landsat_c2ard_sr_mt_hood_jul2022_utm.json"
#&gt; [5] "landsat_c2ard_sr_mt_hood_jul2022_utm.tif"
#&gt; [6] "lf_elev_220_metadata.html"
#&gt; [7] "lf_elev_220_mt_hood_utm.tif"
#&gt; [8] "lf_fbfm40_220_metadata.html"
#&gt; [9] "lf_fbfm40_220_mt_hood_utm.tif"

## End(Not run)
</code></pre>

<hr>
<h2 id='vsi_unlink'>Delete a file</h2><span id='topic+vsi_unlink'></span>

<h3>Description</h3>

<p><code>vsi_unlink()</code> deletes a file object from the file system.
This function goes through the GDAL <code>VSIFileHandler</code> virtualization and may
work on unusual filesystems such as in memory.
It is a wrapper for <code>VSIUnlink()</code> in the GDAL Common Portability Library.
Analog of the POSIX <code>unlink()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_unlink(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_unlink_+3A_filename">filename</code></td>
<td>
<p>Character string. The path of the file to be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>0</code> on success or <code>-1</code> on an error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deleteDataset">deleteDataset()</a></code>, <code><a href="#topic+vsi_rmdir">vsi_rmdir()</a></code>, <code><a href="#topic+vsi_unlink_batch">vsi_unlink_batch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regular file system for illustration
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
tmp_file &lt;- file.path(tempdir(), "tmp.tif")
file.copy(elev_file,  tmp_file)
vsi_stat(tmp_file)
vsi_unlink(tmp_file)
vsi_stat(tmp_file)
</code></pre>

<hr>
<h2 id='vsi_unlink_batch'>Delete several files in a batch</h2><span id='topic+vsi_unlink_batch'></span>

<h3>Description</h3>

<p><code>vsi_unlink_batch()</code> deletes a list of files passed in a character vector.
All files should belong to the same file system handler.
This is implemented efficiently for /vsis3/ and /vsigs/ (provided for
/vsigs/ that OAuth2 authentication is used).
This function is a wrapper for <code>VSIUnlinkBatch()</code> in the GDAL Common
Portability Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsi_unlink_batch(filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsi_unlink_batch_+3A_filenames">filenames</code></td>
<td>
<p>Character vector. The list of files to delete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector of <code>length(filenames)</code> with values depending
on the success of deletion of the corresponding file.
<code>NULL</code> might be returned in case of a more general error (for example,
files belonging to different file system handlers).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deleteDataset">deleteDataset()</a></code>, <code><a href="#topic+vsi_rmdir">vsi_rmdir()</a></code>, <code><a href="#topic+vsi_unlink">vsi_unlink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># regular file system for illustration
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")
tcc_file &lt;- system.file("extdata/storml_tcc.tif", package="gdalraster")

tmp_elev &lt;- file.path(tempdir(), "tmp_elev.tif")
file.copy(elev_file,  tmp_elev)
tmp_tcc &lt;- file.path(tempdir(), "tmp_tcc.tif")
file.copy(tcc_file,  tmp_tcc)
vsi_unlink_batch(c(tmp_elev, tmp_tcc))
</code></pre>

<hr>
<h2 id='VSIFile-class'>Class wrapping the GDAL VSIVirtualHandle API for binary file I/O</h2><span id='topic+VSIFile-class'></span><span id='topic+Rcpp_VSIFile'></span><span id='topic+Rcpp_VSIFile-class'></span><span id='topic+VSIFile'></span>

<h3>Description</h3>

<p><code>VSIFile</code> provides bindings to the GDAL VSIVirtualHandle API. Encapsulates a
<code>VSIVirtualHandle</code>
(<a href="https://gdal.org/api/cpl_cpp.html#_CPPv416VSIVirtualHandle">https://gdal.org/api/cpl_cpp.html#_CPPv416VSIVirtualHandle</a>).
This API abstracts binary file I/O across &quot;regular&quot; file systems, URLs,
cloud storage services, Zip/GZip/7z/RAR, and in-memory files.
It provides analogs of several Standard C file I/O functions, allowing
virtualization of disk I/O so that non-file data sources can be made to
appear as files.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="VSIFile-class_+3A_filename">filename</code></td>
<td>
<p>Character string containing the filename to open. It may be
a file in a regular local filesystem, or a filename with a GDAL /vsiPREFIX/
(see <a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>).</p>
</td></tr>
<tr><td><code id="VSIFile-class_+3A_access">access</code></td>
<td>
<p>Character string containing the access requested (i.e., <code>"r"</code>,
<code>"r+"</code>, <code>"w"</code>, <code style="white-space: pre;">&#8288;"w+&#8288;</code>). Defaults to <code>"r"</code>. Binary access is always implied
and the &quot;b&quot; does not need to be included in <code>access</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Access</strong> </td><td style="text-align: left;"> <strong>Explanation</strong>             </td><td style="text-align: left;"> <strong>If file exists</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"r"</code>      </td><td style="text-align: left;"> open file for reading       </td><td style="text-align: left;"> read from start</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"r+"</code>     </td><td style="text-align: left;"> open file for read/write    </td><td style="text-align: left;"> read from start</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"w"</code>      </td><td style="text-align: left;"> create file for writing     </td><td style="text-align: left;"> destroy contents</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"w+"</code>     </td><td style="text-align: left;"> create file for read/write  </td><td style="text-align: left;"> destroy contents
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="VSIFile-class_+3A_options">options</code></td>
<td>
<p>Optional character vector of <code>NAME=VALUE</code> pairs specifying
filesystem-dependent options (GDAL &gt;= 3.3, see Details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>VSIFile</code> which contains a pointer to a
<code>VSIVirtualHandle</code>, and methods that operate on the file as described in
Details. <code>VSIFile</code> is a C++ class exposed directly to R (via
<code>RCPP_EXPOSED_CLASS</code>). Methods of the class are accessed using the
<code>$</code> operator.
</p>


<h3>Usage</h3>

<pre>
## Constructors
vf &lt;- new(VSIFile, filename)
# specifying access:
vf &lt;- new(VSIFile, filename, access)
# specifying access and options (both required):
vf &lt;- new(VSIFile, filename, access, options)

## Methods (see Details)
vf$seek(offset, origin)
vf$tell()
vf$rewind()
vf$read(nbytes)
vf$write(object)
vf$eof()
vf$truncate(new_size)
vf$flush()
vf$ingest(max_size)

vf$close()
vf$open()
vf$get_filename()
vf$get_access()
vf$set_access(access)
</pre>


<h3>Details</h3>

<p><code>new(VSIFile, filename)</code>
Constructor. Returns an object of class <code>VSIFile</code>, or an error is raised
if a file handle cannot be obtained.
</p>
<p><code>new(VSIFile, filename, access)</code>
Alternate constructor for passing <code>access</code> as a character string
(e.g., <code>"r"</code>, <code>"r+"</code>, <code>"w"</code>, <code>"w+"</code>).
Returns an object of class <code>VSIFile</code> with an open file handle, or an error
is raised if a file handle cannot be obtained.
</p>
<p><code>new(VSIFile, filename, access, options)</code>
Alternate constructor for passing <code>access</code> as a character string, and
<code>options</code> as a character vector of &quot;NAME=VALUE&quot; pairs (both arguments
required, GDAL &gt;= 3.3 required for <code>options</code> support).
Returns an object of class <code>VSIFile</code> with an open file handle, or an error
is raised if a file handle cannot be obtained.
</p>
<p>The <code>options</code> argument is highly file system dependent. Supported options
as of GDAL 3.9 include:
</p>

<ul>
<li><p> MIME headers such as Content-Type and Content-Encoding are supported for
the /vsis3/, /vsigs/, /vsiaz/, /vsiadls/ file systems.
</p>
</li>
<li><p> DISABLE_READDIR_ON_OPEN=YES/NO (GDAL &gt;= 3.6) for /vsicurl/ and other
network-based file systems. By default, directory file listing is done,
unless YES is specified.
</p>
</li>
<li><p> WRITE_THROUGH=YES (GDAL &gt;= 3.8) for Windows regular files to set the
FILE_FLAG_WRITE_THROUGH flag to the <code>CreateFile()</code> function. In that mode,
the data are written to the system cache but are flushed to disk without
delay.
</p>
</li></ul>

<p><code>$seek(offset, origin)</code>
Seek to a requested <code>offset</code> in the file.
<code>offset</code> is given as a positive numeric scalar, optionally as
<code>bit64::integer64</code> type.
<code>origin</code> is given as a character string, one of <code>SEEK_SET</code>, <code>SEEK_CUR</code> or
<code>SEEK_END</code>. Package global constants are defined for convenience, so these
can be passed unquoted. Note that <code>offset</code> is an unsigned type, so <code>SEEK_CUR</code>
can only be used for positive seek. If negative seek is needed, use:
</p>
<div class="sourceCode"><pre>vf$seek(vf$tell() + negative_offset, SEEK_SET)
</pre></div>
<p>Returns <code>0</code> on success or <code>-1</code> on failure.
</p>
<p><code>$tell()</code>
Returns the current file read/write offset in bytes from the beginning of
the file. The return value is a numeric scalar carrying the <code>integer64</code>
class attribute.
</p>
<p><code>$rewind()</code>
Rewind the file pointer to the beginning of the file. This is equivalent to
<code>vf$seek(0, SEEK_SET)</code>. No return value, called for that side effect.
</p>
<p><code>$read(nbytes)</code>
Read <code>nbytes</code> bytes from the file at the current offset. Returns a vector
of R <code>raw</code> type, or <code>NULL</code> if the operation fails.
</p>
<p><code>$write(object)</code>
Write bytes to the file at the current offset. <code>object</code> is a <code>raw</code> vector.
Returns the number of bytes successfully written, as numeric scalar
carrying the <code>integer64</code> class attribute.
See also base R <code>charToRaw()</code> / <code>rawToChar()</code>, convert to or from raw
vectors, and <code>readBin()</code> / <code>writeBin()</code> which read binary data from or write
binary data to a raw vector.
</p>
<p><code>$eof()</code>
Test for end of file. Returns <code>TRUE</code> if an end-of-file condition occurred
during the previous read operation. The end-of-file flag is cleared by a
successful call to <code style="white-space: pre;">&#8288;$seek()&#8288;</code>.
</p>
<p><code>$truncate(new_size)</code>
Truncate/expand the file to the specified <code>new_size</code>, given as a positive
numeric scalar, optionally as <code>bit64::integer64</code> type.
Returns <code>0</code> on success.
</p>
<p><code>$flush()</code>
Flush pending writes to disk. For files in write or update mode and on
file system types where it is applicable, all pending output on the file is
flushed to the physical disk.
On Windows regular files, this method does nothing, unless the
<code>VSI_FLUSH=YES</code> configuration option is set (and only when the file has not
been opened with the <code>WRITE_THROUGH</code> option).
Returns <code>0</code> on success or <code>-1</code> on error.
</p>
<p><code>$ingest(max_size)</code>
Ingest a file into memory. Read the whole content of the file into a <code>raw</code>
vector.
<code>max_size</code> is the maximum size of file allowed, given as a numeric scalar,
optionally as <code>bit64::integer64</code> type. If no limit, set to a negative value.
Returns a <code>raw</code> vector, or <code>NULL</code> if the operation fails.
</p>
<p><code>$close()</code>
Closes the file. The file should always be closed when I/O has been
completed. Returns <code>0</code> on success or <code>-1</code> on error.
</p>
<p><code>$open()</code>
This method can be used to re-open the file after it has been closed, using
the same <code>filename</code>, and same <code>options</code> if any are set. The file will be
opened using <code>access</code> as currently set. The <code style="white-space: pre;">&#8288;$set_access()&#8288;</code> method can be
called to change the requested access while the file is closed.
No return value. An error is raised if a file handle cannot be obtained.
</p>
<p><code>$get_filename()</code>
Returns a character string containing the <code>filename</code> associated with this
<code>VSIFile</code> object (the <code>filename</code> originally used to create the object).
</p>
<p><code>$get_access()</code>
Returns a character string containing the <code>access</code> as currently set on this
<code>VSIFile</code> object.
</p>
<p><code>$set_access(access)</code>
Sets the requested read/write access on this <code>VSIFile</code> object, given as a
character string (i.e., <code>"r"</code>, <code>"r+"</code>, <code>"w"</code>, <code>"w+"</code>). The access can be
changed only while the <code>VSIFile</code> object is closed, and will apply when it is
re-opened with a call to <code style="white-space: pre;">&#8288;$open()&#8288;</code>.
Returns <code>0</code> on success or <code>-1</code> on error.
</p>


<h3>Note</h3>

<p>File offsets are given as R <code>numeric</code> (i.e., <code>double</code> type), optionally
carrying the <code>bit64::integer64</code> class attribute. They are returned as
<code>numeric</code> with the <code>integer64</code> class attribute attached. The <code>integer64</code>
type is signed, so the maximum file offset supported by this interface
is <code>9223372036854775807</code> (the value of <code>bit64::lim.integer64()[2]</code>).
</p>
<p>Some virtual file systems allow only sequential write, so no seeks or read
operations are then allowed (e.g., AWS S3 files with /vsis3/).
Starting with GDAL 3.2, a configuration option can be set with:
</p>
<div class="sourceCode"><pre>set_config_option("CPL_VSIL_USE_TEMP_FILE_FOR_RANDOM_WRITE", "YES")
</pre></div>
<p>in which case random-write access is possible (involves the creation of a
temporary local file, whose location is controlled by the <code>CPL_TMPDIR</code>
configuration option). In this case, setting <code>access</code> to <code>"w+"</code> may be
needed for writing with seek and read operations (if creating a new file,
otherwise, <code>"r+"</code> to open an existing file), while <code>"w"</code> access would
allow sequential write only.
</p>


<h3>See Also</h3>

<p>GDAL Virtual File Systems (compressed, network hosted, etc...):<br />
/vsimem, /vsizip, /vsitar, /vsicurl, ...<br />
<a href="https://gdal.org/user/virtual_file_systems.html">https://gdal.org/user/virtual_file_systems.html</a>
</p>
<p><code><a href="#topic+vsi_copy_file">vsi_copy_file()</a></code>, <code><a href="#topic+vsi_read_dir">vsi_read_dir()</a></code>, <code><a href="#topic+vsi_stat">vsi_stat()</a></code>, <code><a href="#topic+vsi_unlink">vsi_unlink()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The examples make use of the FARSITE LCP format specification at:
# https://gdal.org/drivers/raster/lcp.html
# An LCP file is a raw format with a 7,316-byte header. The format
# specification gives byte offets and data types for fields in the header.

lcp_file &lt;- system.file("extdata/storm_lake.lcp", package="gdalraster")

# identify a FARSITE v.4 LCP file
# function to check if the first three fields have valid data
# input is the first twelve raw bytes in the file
is_lcp &lt;- function(bytes) {
  values &lt;- readBin(bytes, "integer", n = 3)
  if ((values[1] == 20 || values[1] == 21) &amp;&amp;
      (values[2] == 20 || values[2] == 21) &amp;&amp;
      (values[3] &gt;= -90 &amp;&amp; values[3] &lt;= 90)) {

    return(TRUE)
  } else {
    return(FALSE)
  }
}

vf &lt;- new(VSIFile, lcp_file)
vf$read(12) |&gt; is_lcp()

vf$tell()

# read the whole file into memory
bytes &lt;- vf$ingest(-1)
vf$close()

# write to a VSI in-memory file
mem_file &lt;- "/vsimem/storml_copy.lcp"
vf &lt;- new(VSIFile, mem_file, "w")
vf$write(bytes)

vf$tell()
vf$rewind()
vf$tell()

vf$seek(0, SEEK_END)
(vf$tell() == vsi_stat(lcp_file, "size"))  # TRUE

vf$rewind()
vf$read(12) |&gt; is_lcp()

# read/write an integer field
# write invalid data for the Latitude field and then set back
# save the original first
vf$seek(8, SEEK_SET)
lat_orig &lt;- vf$read(4)
readBin(lat_orig, "integer")  # 46
# latitude -99 out of range
vf$seek(8, SEEK_SET)
writeBin(-99L, raw()) |&gt; vf$write()
vf$rewind()
vf$read(12) |&gt; is_lcp()  # FALSE
vf$seek(8, SEEK_SET)
vf$read(4) |&gt; readBin("integer")  # -99
# set back to original
vf$seek(8, SEEK_SET)
vf$write(lat_orig)
vf$rewind()
vf$read(12) |&gt; is_lcp()  # TRUE

# read a vector of doubles - xmax, xmin, ymax, ymin
# 327766.1, 323476.1, 5105082.0, 5101872.0
vf$seek(4172, SEEK_SET)
vf$read(32) |&gt; readBin("double", n = 4)

# read a short int, the canopy cover units
vf$seek(4232, SEEK_SET)
vf$read(2) |&gt; readBin("integer", size = 2)  # 1 = "percent"

# read the Description field
vf$seek(6804, SEEK_SET)
bytes &lt;- vf$read(512)
rawToChar(bytes)

# edit the Description
desc &lt;- paste(rawToChar(bytes),
              "Storm Lake AOI,",
              "Beaverhead-Deerlodge National Forest, Montana.")

vf$seek(6804, SEEK_SET)
charToRaw(desc) |&gt; vf$write()
vf$close()

# verify the file as a raster dataset
ds &lt;- new(GDALRaster, mem_file)
ds$info()

# retrieve Description from the metadata
# band = 0 for dataset-level metadata, domain = "" for default domain
ds$getMetadata(band = 0, domain = "")
ds$getMetadataItem(band = 0, mdi_name = "DESCRIPTION", domain = "")

ds$close()
vsi_unlink(mem_file)
</code></pre>

<hr>
<h2 id='warp'>Raster reprojection and mosaicing</h2><span id='topic+warp'></span>

<h3>Description</h3>

<p><code>warp()</code> is a wrapper of the <code>gdalwarp</code> command-line utility for
raster mosaicing, reprojection and warping
(see <a href="https://gdal.org/programs/gdalwarp.html">https://gdal.org/programs/gdalwarp.html</a>).
The function can reproject to any supported spatial reference system (SRS).
It can also be used to crop, resample, and optionally write output to a
different raster format. See Details for a list of commonly used
processing options that can be passed as arguments to <code>warp()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp(src_files, dst_filename, t_srs, cl_arg = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp_+3A_src_files">src_files</code></td>
<td>
<p>Character vector of source file(s) to be reprojected.</p>
</td></tr>
<tr><td><code id="warp_+3A_dst_filename">dst_filename</code></td>
<td>
<p>Character string. Filename of the output raster.</p>
</td></tr>
<tr><td><code id="warp_+3A_t_srs">t_srs</code></td>
<td>
<p>Character string. Target spatial reference system. Usually an
EPSG code (&quot;EPSG:#####&quot;) or a well known text (WKT) SRS definition.
If empty string <code>""</code>, the spatial reference of <code>src_files[1]</code> will be
used (see Note).</p>
</td></tr>
<tr><td><code id="warp_+3A_cl_arg">cl_arg</code></td>
<td>
<p>Optional character vector of command-line arguments to
<code>gdalwarp</code> in addition to <code>-t_srs</code> (see Details).</p>
</td></tr>
<tr><td><code id="warp_+3A_quiet">quiet</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, a progress bar will not be
displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several processing options can be performed in one call to <code>warp()</code> by
passing the necessary command-line arguments. The following list describes
several commonly used arguments. Note that <code>gdalwarp</code> supports a large
number of arguments that enable a variety of different processing options.
Users are encouraged to review the original source documentation provided
by the GDAL project at the URL above for the full list.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;-te &lt;xmin&gt; &lt;ymin&gt; &lt;xmax&gt; &lt;ymax&gt;&#8288;</code><br />
Georeferenced extents of output file to be created (in target SRS by
default).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-te_srs &lt;srs_def&gt;&#8288;</code><br />
SRS in which to interpret the coordinates given with <code>-te</code>
(if different than <code>t_srs</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-tr &lt;xres&gt; &lt;yres&gt;&#8288;</code><br />
Output pixel resolution (in target georeferenced units).
</p>
</li>
<li> <p><code>-tap</code><br />
(target aligned pixels) align the coordinates of the extent of the output
file to the values of the <code>-tr</code>, such that the aligned extent includes
the minimum extent. Alignment means that xmin / resx, ymin / resy,
xmax / resx and ymax / resy are integer values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-ovr &lt;level&gt;|AUTO|AUTO-&lt;n&gt;|NONE&#8288;</code><br />
Specify which overview level of source files must be used. The default
choice, <code>AUTO</code>, will select the overview level whose resolution is the
closest to the target resolution. Specify an integer value (0-based,
i.e., 0=1st overview level) to select a particular level. Specify
<code>AUTO-n</code> where <code>n</code> is an integer greater or equal to <code>1</code>, to select an
overview level below the <code>AUTO</code> one. Or specify <code>NONE</code> to force the base
resolution to be used (can be useful if overviews have been generated
with a low quality resampling method, and the warping is done using a
higher quality resampling method).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-wo &lt;NAME&gt;=&lt;VALUE&gt;&#8288;</code><br />
Set a warp option as described in the GDAL documentation for
<a href="https://gdal.org/api/gdalwarp_cpp.html#_CPPv415GDALWarpOptions"><code>GDALWarpOptions</code></a>
Multiple <code>-wo</code> may be given. See also <code>-multi</code> below.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-ot &lt;type&gt;&#8288;</code><br />
Force the output raster bands to have a specific data type supported by
the format, which may be one of the following: <code>Byte</code>, <code>Int8</code>, <code>UInt16</code>,
<code>Int16</code>, <code>UInt32</code>, <code>Int32</code>, <code>UInt64</code>, <code>Int64</code>, <code>Float32</code>, <code>Float64</code>,
<code>CInt16</code>, <code>CInt32</code>, <code>CFloat32</code> or <code>CFloat64</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-r &lt;resampling_method&gt;&#8288;</code><br />
Resampling method to use. Available methods are: <code>near</code> (nearest
neighbour, the default), <code>bilinear</code>, <code>cubic</code>, <code>cubicspline</code>, <code>lanczos</code>,
<code>average</code>, <code>rms</code> (root mean square, GDAL &gt;= 3.3), <code>mode</code>, <code>max</code>, <code>min</code>,
<code>med</code>, <code>q1</code> (first quartile), <code>q3</code> (third quartile), <code>sum</code> (GDAL &gt;= 3.1).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-srcnodata "&lt;value&gt;[ &lt;value&gt;]..."&#8288;</code><br />
Set nodata masking values for input bands (different values can be
supplied for each band). If more than one value is supplied all values
should be quoted to keep them together as a single operating system
argument. Masked values will not be used in interpolation. Use a value of
<code>None</code> to ignore intrinsic nodata settings on the source dataset.
If <code>-srcnodata</code> is not explicitly set, but the source dataset has nodata
values, they will be taken into account by default.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-dstnodata "&lt;value&gt;[ &lt;value&gt;]..."&#8288;</code><br />
Set nodata values for output bands (different values can be supplied for
each band). If more than one value is supplied all values should be
quoted to keep them together as a single operating system argument. New
files will be initialized to this value and if possible the nodata value
will be recorded in the output file. Use a value of <code>"None"</code> to ensure
that nodata is not defined. If this argument is not used then nodata
values will be copied from the source dataset.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-wm &lt;memory_in_mb&gt;&#8288;</code><br />
Set the amount of memory that the warp API is allowed to use for caching.
The value is interpreted as being in megabytes if the value is &lt;10000.
For values &gt;=10000, this is interpreted as bytes. The warper will
total up the memory required to hold the input and output image arrays
and any auxiliary masking arrays and if they are larger than the
&quot;warp memory&quot; allowed it will subdivide the chunk into smaller chunks and
try again. If the <code>-wm</code> value is very small there is some extra overhead
in doing many small chunks so setting it larger is better but it is a
matter of diminishing returns.
</p>
</li>
<li> <p><code>-multi</code><br />
Use multithreaded warping implementation. Two threads will be used to
process chunks of image and perform input/output operation
simultaneously. Note that computation is not multithreaded itself. To do
that, you can use the <code style="white-space: pre;">&#8288;-wo NUM_THREADS=val/ALL_CPUS&#8288;</code> option, which can be
combined with <code>-multi</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-of &lt;format&gt;&#8288;</code>
Set the output raster format. Will be guessed from the extension if not
specified. Use the short format name (e.g., <code>"GTiff"</code>).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;-co &lt;NAME&gt;=&lt;VALUE&gt;&#8288;</code><br />
Set one or more format specific creation options for the output dataset.
For example, the GeoTIFF driver supports creation options to control
compression, and whether the file should be tiled.
<code><a href="#topic+getCreationOptions">getCreationOptions()</a></code> can be used to look up available creation options,
but the GDAL <a href="https://gdal.org/drivers/raster/index.html">Raster drivers</a>
documentation is the definitive reference for format specific options.
Multiple <code>-co</code> may be given, e.g.,
</p>
<pre> c("-co", "COMPRESS=LZW", "-co", "BIGTIFF=YES") </pre>
</li>
<li> <p><code>-overwrite</code><br />
Overwrite the target dataset if it already exists. Overwriting means
deleting and recreating the file from scratch. Note that if this option
is not specified and the output file already exists, it will be updated
in place.
</p>
</li></ul>

<p>The documentation for <a href="https://gdal.org/programs/gdalwarp.html"><code>gdalwarp</code></a>
describes additional command-line options related to spatial reference
systems, source nodata values, alpha bands, polygon cutlines as mask
including blending, and more.
</p>
<p>Mosaicing into an existing output file is supported if the output file
already exists. The spatial extent of the existing file will not be
modified to accommodate new data, so you may have to remove it in that
case, or use the <code>-overwrite</code> option.
</p>
<p>Command-line options are passed to <code>warp()</code> as a character vector. The
elements of the vector are the individual options followed by their
individual values, e.g.,
</p>
<pre>
cl_arg = c("-tr", "30", "30", "-r", "bilinear"))
</pre>
<p>to set the target pixel resolution to 30 x 30 in target georeferenced
units and use bilinear resampling.
</p>


<h3>Value</h3>

<p>Logical indicating success (invisible <code>TRUE</code>).
An error is raised if the operation fails.
</p>


<h3>Note</h3>

<p><code>warp()</code> can be used to reproject and also perform other processing such
as crop, resample, and mosaic.
This processing is generally done with a single function call by passing
arguments for the target (output) pixel resolution, extent, resampling
method, nodata value, format, and so forth.
If <code>warp()</code> is called with <code>t_srs</code> set to <code>""</code> (empty string),
the target spatial reference will be set to that of <code>src_files[1]</code>,
so that the processing options given in <code>cl_arg</code> will be performed without
reprojecting (in the case of one input raster or multiple inputs that
all use the same spatial reference system, otherwise would reproject
inputs to the SRS of <code>src_files[1]</code> when they are different).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GDALRaster">GDALRaster-class</a></code>, <code><a href="#topic+srs_to_wkt">srs_to_wkt()</a></code>, <code><a href="#topic+translate">translate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># reproject the elevation raster to NAD83 / CONUS Albers (EPSG:5070)
elev_file &lt;- system.file("extdata/storml_elev.tif", package="gdalraster")

# command-line arguments for gdalwarp
# resample to 90-m resolution and keep pixels aligned:
args &lt;- c("-tr", "90", "90", "-r", "cubic", "-tap")
# write to Erdas Imagine format (HFA) with compression:
args &lt;- c(args, "-of", "HFA", "-co", "COMPRESSED=YES")

alb83_file &lt;- file.path(tempdir(), "storml_elev_alb83.img")
warp(elev_file, alb83_file, t_srs="EPSG:5070", cl_arg = args)

ds &lt;- new(GDALRaster, alb83_file)
ds$getDriverLongName()
ds$getProjectionRef()
ds$res()
ds$getStatistics(band=1, approx_ok=FALSE, force=TRUE)
ds$close()

deleteDataset(alb83_file)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
