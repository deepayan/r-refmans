<!DOCTYPE html><html><head><title>Help for package RHRV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RHRV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddEpisodes'><p> Adds new episodes manually</p></a></li>
<li><a href='#AnalyzeHRbyEpisodes'><p> Analyzes Heart Rate using episodes information</p></a></li>
<li><a href='#AnalyzePowerBandsByEpisodes'><p>Analyze power band by episodes</p></a></li>
<li><a href='#AvgIntegralCorrelation'><p> Calculates the average of the Integral Correlations</p></a></li>
<li><a href='#BuildNIHR'><p> Builds the instantaneous heart rate signal from a beat position array</p></a></li>
<li><a href='#BuildTakens'><p>Build the Takens' vectors</p></a></li>
<li><a href='#BuildTakensVector'><p> Calculates Takens expanded vectors</p></a></li>
<li><a href='#CalculateApEn'><p> Calculates Approximate Entropy</p></a></li>
<li><a href='#CalculateCorrDim'><p>Correlation sum, correlation dimension and generalized correlation dimension</p>
(order q &gt;1)</a></li>
<li><a href='#CalculateDFA'><p>Detrended Fluctuation Analysis</p></a></li>
<li><a href='#CalculateEmbeddingDim'><p>Estimate the proper embedding dimension for the RR time series</p></a></li>
<li><a href='#CalculateEnergyInPSDBands'><p>CalculateSPDBandsEnergy</p></a></li>
<li><a href='#CalculateFracDim'><p> Calculates Fractal Dimension</p></a></li>
<li><a href='#CalculateInfDim'><p>Information dimension of the RR time series</p></a></li>
<li><a href='#CalculateMaxLyapunov'><p>Maximum lyapunov exponent</p></a></li>
<li><a href='#CalculatePowerBand'><p> Calculates power per band</p></a></li>
<li><a href='#CalculatePSD'><p>Spectral Density Estimation</p></a></li>
<li><a href='#CalculateRfromCorrelation'><p> Calculates ra and rb from Correlation</p></a></li>
<li><a href='#CalculateSampleEntropy'><p>Sample Entropy (also known as Kolgomorov-Sinai Entropy)</p></a></li>
<li><a href='#CalculateSpectrogram'><p> Calculates the spectrogram of a signal</p></a></li>
<li><a href='#CalculateTimeLag'><p>Estimate an appropiate time lag for the Takens' vectors</p></a></li>
<li><a href='#CreateFreqAnalysis'><p> Creates data analysis structure for frequency analysis calculations</p></a></li>
<li><a href='#CreateHRVData'><p> Creates data structure for all the calculations</p></a></li>
<li><a href='#CreateNonLinearAnalysis'><p> Creates data analysis structure for non linear analysis calculations</p></a></li>
<li><a href='#CreateTimeAnalysis'><p> Creates data analysis structure for time analysis calculations</p></a></li>
<li><a href='#EditNIHR'><p> Manually edition of non-interpolated instantaneous heart rate</p></a></li>
<li><a href='#EstimatePSDSlope'><p>Estimate the slope of the Power Spectral Density (PSD).</p></a></li>
<li><a href='#ExtractTimeSegment'><p>Time windows of HR record</p></a></li>
<li><a href='#FilterNIHR'><p> Artefact filter based in an adaptive threshold</p></a></li>
<li><a href='#GenerateEpisodes'><p> Creates new episodes from old ones</p></a></li>
<li><a href='#getNormSpectralUnits'><p>Normalized Spectral Units</p></a></li>
<li><a href='#HRVData'><p>HRVData</p></a></li>
<li><a href='#HRVProcessedData'><p>HRVProcessedData</p></a></li>
<li><a href='#IntegralCorrelation'><p> Calculates the Integral Correlation</p></a></li>
<li><a href='#InterpolateNIHR'><p> Linear or Spline interpolator for build the sample heart rate signal</p></a></li>
<li><a href='#ListEpisodes'><p> Episodes listing</p></a></li>
<li><a href='#LoadApneaWFDB'><p> Loads apnea episodes for WFDB record</p></a></li>
<li><a href='#LoadBeat'><p> Builds an array of beats positions from different type of files</p></a></li>
<li><a href='#LoadBeatAmbit'><p> Imports data from a record in Suunto Ambit XML format</p></a></li>
<li><a href='#LoadBeatAscii'><p> Builds an array of beats positions from an ascii file</p></a></li>
<li><a href='#LoadBeatEDFPlus'><p> Imports data from a record in EDF+ format</p></a></li>
<li><a href='#LoadBeatPolar'><p> Imports data from a record in Polar format</p></a></li>
<li><a href='#LoadBeatRR'><p> Builds an array of beats positions from an ascii file</p></a></li>
<li><a href='#LoadBeatSuunto'><p> Imports data from a record in Suunto format</p></a></li>
<li><a href='#LoadBeatVector'><p>Loads beats positions from an R vector</p></a></li>
<li><a href='#LoadBeatWFDB'><p> Imports data from a record in WFDB format</p></a></li>
<li><a href='#LoadEpisodesAscii'><p> Loads episodes file</p></a></li>
<li><a href='#LoadHeaderWFDB'><p> Imports header information from a record in wfdb format</p></a></li>
<li><a href='#ModifyEpisodes'><p> Modifies values of episodes</p></a></li>
<li><a href='#NonlinearityTests'><p>Nonlinearity tests</p></a></li>
<li><a href='#NonLinearNoiseReduction'><p>Nonlinear noise reduction</p></a></li>
<li><a href='#OverplotEpisodes'><p>OverplotEpisodes</p></a></li>
<li><a href='#PlotHR'><p>Simple plot of interpolated heart rate</p></a></li>
<li><a href='#PlotNIHR'><p>Simple plot of non-interpolated heart rate</p></a></li>
<li><a href='#PlotPowerBand'><p>Plots power determined by CalculatePowerBand function</p></a></li>
<li><a href='#PlotPSD'><p>Plot Spectral Density Estimation</p></a></li>
<li><a href='#PlotSinglePowerBand'><p>PlotSinglePowerBand</p></a></li>
<li><a href='#PlotSpectrogram'><p>Calculates and Plots spectrogram</p></a></li>
<li><a href='#PoincarePlot'><p>Poincare Plot</p></a></li>
<li><a href='#ReadFromFile'><p> Reads data structure from file</p></a></li>
<li><a href='#RecurrencePlot'><p>Recurrence Plot</p></a></li>
<li><a href='#RemoveEpisodes'><p> Remove episodes by indexes or tags</p></a></li>
<li><a href='#RHRV-package'>
<p>RHRV: An R-based software package for the heart rate variability analysis of ECG recordings</p></a></li>
<li><a href='#RQA'><p>Recurrence Quantification Analysis (RQA)</p></a></li>
<li><a href='#SetVerbose'><p> Sets verbose mode on or off</p></a></li>
<li><a href='#SplitHRbyEpisodes'><p> Splits Heart Rate Data using Episodes information</p></a></li>
<li><a href='#SplitPowerBandByEpisodes'><p> Splits Power Per Band using Episodes information</p></a></li>
<li><a href='#SurrogateTest'><p>Surrogate data testing</p></a></li>
<li><a href='#Window'><p>Time windows of RR intervals</p></a></li>
<li><a href='#WriteToFile'><p> Writes data structure to a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Heart Rate Variability Analysis of ECG Data</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leandro Rodriguez-Linares &lt;leandro@uvigo.es&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://rhrv.r-forge.r-project.org/">http://rhrv.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Allows users to import data files containing heartbeat	positions in the most broadly used formats, to remove outliers or points with unacceptable physiological values present in the time series, to plot HRV data, and to perform time domain, frequency domain and nonlinear HRV analysis. See Garcia et al. (2017) &lt;<a href="https://doi.org/10.1007%2F978-3-319-65355-6">doi:10.1007/978-3-319-65355-6</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Code for the wavelet transform is based on Brandon
Whitcher's work. See file COPYRIGHT for details</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), waveslim(&ge; 1.6.4), nonlinearTseries (&ge; 0.2.3),
lomb (&ge; 1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk, tkrplot, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-31 15:57:08 UTC; leandro</td>
</tr>
<tr>
<td>Author:</td>
<td>Leandro Rodriguez-Linares [aut, cre],
  Xose Vila [aut],
  Maria Jose Lado [aut],
  Arturo Mendez [aut],
  Abraham Otero [aut],
  Constantino Antonio Garcia [aut],
  Matti Lassila [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-31 20:05:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddEpisodes'> Adds new episodes manually</h2><span id='topic+AddEpisodes'></span>

<h3>Description</h3>

<p>Adds information of episodes manually, or annotated physiological events, and stores it into the data structure containing the beat positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddEpisodes(HRVData, InitTimes, Tags, Durations, Values, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="AddEpisodes_+3A_inittimes">InitTimes</code></td>
<td>
<p> Vector containing init times in seconds </p>
</td></tr>
<tr><td><code id="AddEpisodes_+3A_tags">Tags</code></td>
<td>
<p> Vector containing types of episodes </p>
</td></tr>
<tr><td><code id="AddEpisodes_+3A_durations">Durations</code></td>
<td>
<p> Vector containing durations in seconds </p>
</td></tr>
<tr><td><code id="AddEpisodes_+3A_values">Values</code></td>
<td>
<p> Vector containing numerical values for episodes </p>
</td></tr>
<tr><td><code id="AddEpisodes_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and new episodes information
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='AnalyzeHRbyEpisodes'> Analyzes Heart Rate using episodes information </h2><span id='topic+AnalyzeHRbyEpisodes'></span>

<h3>Description</h3>

<p>Analyzes Heart Rate allowing to evaluate the application of a desired function inside and outside episodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnalyzeHRbyEpisodes(HRVData, Tag="", func, ..., verbose=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnalyzeHRbyEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="AnalyzeHRbyEpisodes_+3A_tag">Tag</code></td>
<td>
<p> Type of episode </p>
</td></tr>
<tr><td><code id="AnalyzeHRbyEpisodes_+3A_func">func</code></td>
<td>
<p> Function to be applied to Heart Rate Data inside and outside episodes </p>
</td></tr>
<tr><td><code id="AnalyzeHRbyEpisodes_+3A_...">...</code></td>
<td>
<p>optional arguments to func</p>
</td></tr>
<tr><td><code id="AnalyzeHRbyEpisodes_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two objects, that is, the values of the application of the selected function inside and outside episodes
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SplitHRbyEpisodes">SplitHRbyEpisodes</a></code> for splitting in two parts Heart Rate Data using an specific episode type
</p>

<hr>
<h2 id='AnalyzePowerBandsByEpisodes'>Analyze power band by episodes</h2><span id='topic+AnalyzePowerBandsByEpisodes'></span>

<h3>Description</h3>

<p>Analyzes the ULF, VLF, LF and HF bands from a given indexFreqAnalysis allowing
to evaluate the application of a desired function inside and outside each episode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnalyzePowerBandsByEpisodes(HRVData,
  indexFreqAnalysis = length(HRVData$FreqAnalysis), Tag = "",
  verbose = NULL, func, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it.</p>
</td></tr>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>Integer value denoting which frequency analysis is going to be analyzed using func. Default: 1</p>
</td></tr>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_tag">Tag</code></td>
<td>
<p>Type of episode</p>
</td></tr>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated argument maintained for compatibility, use SetVerbose() instead</p>
</td></tr>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_func">func</code></td>
<td>
<p>Function to be applied to each power band inside and outside episodes</p>
</td></tr>
<tr><td><code id="AnalyzePowerBandsByEpisodes_+3A_...">...</code></td>
<td>
<p>Optional arguments for func.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two objects, that is, the values of the application of the selected function
inside (&quot;resultIn&quot;) and outside (&quot;resultOut&quot;) episodes in the given indexFreqAnalysis. Each of these 
list has another set of lists: the  &quot;ULF&quot;, &quot;VLF&quot;, &quot;LF&quot; and &quot;HF&quot; lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hrv.data = CreateHRVData()
hrv.data = SetVerbose(hrv.data, TRUE)
hrv.data = LoadBeat(hrv.data, fileType = "WFDB", "a03", RecordPath ="beatsFolder/", 
                    annotator = "qrs")
                    hrv.data = LoadApneaWFDB(hrv.data, RecordName="a03",Tag="Apnea",
                                             RecordPath="beatsFolder/")
hrv.data = BuildNIHR(hrv.data)
hrv.data = InterpolateNIHR (hrv.data, freqhr = 4)
hrv.data = CreateFreqAnalysis(hrv.data)
hrv.data = CalculatePowerBand( hrv.data , indexFreqAnalysis= 1,
                               type = "wavelet", wavelet = "la8",
                                bandtolerance = 0.01, relative = FALSE)
results = AnalyzePowerBandsByEpisodes(hrv.data,indexFreqAnalysis=1,
                                       Tag="Apnea",func=mean)
## End(Not run)
</code></pre>

<hr>
<h2 id='AvgIntegralCorrelation'> Calculates the average of the Integral Correlations </h2><span id='topic+AvgIntegralCorrelation'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function. 
The Integral correlation is calculated for every vector of the m-dimensional space, and then the average of all these values is calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AvgIntegralCorrelation(HRVData, Data, m, tau, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AvgIntegralCorrelation_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="AvgIntegralCorrelation_+3A_data">Data</code></td>
<td>
<p> Portion of HRVData to be analyzed </p>
</td></tr>
<tr><td><code id="AvgIntegralCorrelation_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="AvgIntegralCorrelation_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
<tr><td><code id="AvgIntegralCorrelation_+3A_r">r</code></td>
<td>
<p> Distance for calculating correlation </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the average of IntegralCorrelations
</p>


<h3>Note</h3>

<p>This function is used in the <code><a href="#topic+CalculateApEn">CalculateApEn</a></code> function, which is
<b>deprecated</b>. We suggest the use of the <code><a href="#topic+CalculateSampleEntropy">CalculateSampleEntropy</a></code>
function instead of <code><a href="#topic+CalculateApEn">CalculateApEn</a></code>.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+IntegralCorrelation">IntegralCorrelation</a></code>  </p>

<hr>
<h2 id='BuildNIHR'> Builds the instantaneous heart rate signal from a beat position array </h2><span id='topic+BuildNIHR'></span>

<h3>Description</h3>

<p>The instantaneous heart rate can be defined as the inverse of the time separation between two consecutive heart beats. Once the beats have been identified, and since the only valid values contributing to the heart rate signal are the corresponding to normal beats preceded by other normal beats, a further operation should be performed for the calculation of the instantaneous heart rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildNIHR(HRVData, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildNIHR_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="BuildNIHR_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and now associated heart rate instantaneous values also
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='BuildTakens'>Build the Takens' vectors</h2><span id='topic+BuildTakens'></span>

<h3>Description</h3>

<p>This function builds the Takens' vectors of the Non Interpolated RR intervals.
The set  of Takens' vectors is the result of embedding the time series in
a m-dimensional  space. That is, the <code class="reqn">n^{th}</code> Takens' vector is defined as 
</p>
<p style="text-align: center;"><code class="reqn">T[n]=\{niRR[n], niRR[n+ timeLag],..., niRR[n+m*timeLag]\}.</code>
</p>

<p>Taken's theorem states that we can then reconstruct an equivalent dynamical 
system to the original one (the 
dynamical system that generated the observed time series) by using the Takens' vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildTakens(HRVData, embeddingDim, timeLag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildTakens_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="BuildTakens_+3A_embeddingdim">embeddingDim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed the RR series.</p>
</td></tr>
<tr><td><code id="BuildTakens_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Takens' vectors (one per row).
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+buildTakens">buildTakens</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>

<hr>
<h2 id='BuildTakensVector'> Calculates Takens expanded vectors </h2><span id='topic+BuildTakensVector'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function. 
In order to calculate de Fractal Dimension and Approximate Entropy (or others properties of the data) a representation of the data in a space m-dimensional is needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildTakensVector(HRVData, Data, m, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildTakensVector_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="BuildTakensVector_+3A_data">Data</code></td>
<td>
<p> Portion of HRVData to be analyzed </p>
</td></tr>
<tr><td><code id="BuildTakensVector_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="BuildTakensVector_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the Expanded Data with N-(m-1)*tau rows (N is the length of the Data to be analyzed) and m columns
</p>


<h3>Note</h3>

<p>This function is  <b>deprecated</b>. Please use <code><a href="#topic+BuildTakens">BuildTakens</a></code> instead.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='CalculateApEn'> Calculates Approximate Entropy </h2><span id='topic+CalculateApEn'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function.
Calculates Approximate Entropy as indicated by Pincus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateApEn(HRVData,
              indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
              m = 2, tau = 1, 
              r = 0.2, N = 1000, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateApEn_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information
related to it </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p> Reference to the data structure that will
contain the non linear analysis </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_r">r</code></td>
<td>
<p> Distance for calculating correlation </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_n">N</code></td>
<td>
<p> Number of points of the portion of signal to be analyzed </p>
</td></tr>
<tr><td><code id="CalculateApEn_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use
SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and now 
associated heart rate instantaneous values also, including the value of the
Approximate Entropy
</p>


<h3>Note</h3>

<p>This function is <b>deprecated</b>. We suggest the use of the 
<code><a href="#topic+CalculateSampleEntropy">CalculateSampleEntropy</a></code> function instead, which is faster.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
S. M. Pincus, &quot;Approximate entropy as a measure of system complexity,&quot;
Mathematics 88, 2297-2301 (1991)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BuildTakensVector">BuildTakensVector</a></code> for expand data <br />
<code><a href="#topic+IntegralCorrelation">IntegralCorrelation</a></code> for correlation calculations <br />
<code><a href="#topic+AvgIntegralCorrelation">AvgIntegralCorrelation</a></code> for averaging correlation calculations<br />
</p>

<hr>
<h2 id='CalculateCorrDim'>Correlation sum, correlation dimension and generalized correlation dimension 
(order q &gt;1)</h2><span id='topic+CalculateCorrDim'></span><span id='topic+EstimateCorrDim'></span><span id='topic+PlotCorrDim'></span>

<h3>Description</h3>

<p>Functions for estimating the correlation sum and the correlation dimension of 
the RR time series using phase-space reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateCorrDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  minEmbeddingDim = NULL, maxEmbeddingDim = NULL, timeLag = NULL,
  minRadius, maxRadius, pointsRadius = 20, theilerWindow = 100,
  corrOrder = 2, doPlot = TRUE)

EstimateCorrDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, useEmbeddings = NULL, doPlot = TRUE)

PlotCorrDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateCorrDim_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_minembeddingdim">minEmbeddingDim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we shall embed the time series</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_maxembeddingdim">maxEmbeddingDim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we shall embed the time series. Thus,
we shall estimate the correlation dimension between <em>minEmbeddingDim</em> and <em>maxEmbeddingDim</em>.</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors.</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_minradius">minRadius</code></td>
<td>
<p>Minimum distance used to compute the correlation sum C(r)</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_maxradius">maxRadius</code></td>
<td>
<p>Maximum distance used to compute the correlation sum C(r)</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_pointsradius">pointsRadius</code></td>
<td>
<p>The number of different radius where we shall estimate
C(r). Thus,  we will estimate C(r) in pointsRadius between minRadius and maxRadius</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_theilerwindow">theilerWindow</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' vectors must be separated by more than
theilerWindow time steps in order to be considered neighbours. By using a Theiler window, we exclude temporally correlated 
vectors from our estimations.</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_corrorder">corrOrder</code></td>
<td>
<p>Order of the generalized correlation Dimension q. It must be greater than 1 (corrOrder&gt;1). Default, corrOrder=2</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default), a plot of the correlation sum is shown</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Vector with 2 components denoting the range where the function will perform linear regression</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_useembeddings">useEmbeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions should the algorithm use to compute
the correlation dimension</p>
</td></tr>
<tr><td><code id="CalculateCorrDim_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation dimension is the most common measure of the fractal dimensionality
of a geometrical object embedded in a phase space. In order to estimate the correlation
dimension, the correlation sum is defined over the points from the phase space:
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \{(number\;of\;points\;(x_i,x_j)\;verifying\;that\;distance\;(x_i,x_j)&lt;r\})/N^2</code>
</p>

<p>However, this estimator is biased when the pairs in the sum are not statistically independent. For example,
Taken's vectors that are close in time, are usually close in the phase space due to the non-zero autocorrelation
of the original time series. This is solved by using the so-called Theiler window: two Takens' vectors must be
separated by, at least, the time steps specified with this window in order to be considered neighbours. By using a Theiler window,
we exclude temporally correlated vectors from our estimations. 
</p>
<p>The correlation dimension is estimated using the slope obtained by performing a linear regression of 
<code class="reqn">\log10(C(r))\;Vs.\;\log10(r)</code>. Since this dimension is supposed to be an invariant of the system, it should not
depend on the dimension of the Taken's vectors used to estimate it. Thus, the user should plot <code class="reqn">\log10(C(r))\;Vs.\;\log10(r)</code> for several embedding
dimensions when looking for the correlation 
dimension and, if for some range <code class="reqn">\log10(C(r))</code> shows a similar linear behaviour in different embedding dimensions (i.e. parallel
slopes), these slopes are an estimate of the
correlation dimension. The <em>estimate</em> routine allows the user to get always an estimate of the correlation dimension,
but the user must check that there is a linear region in the correlation sum over different dimensions. 
If such a region does not exist, the estimation should be discarded.
</p>
<p>Note that the correlation sum  C(r) may be interpreted as:
<code class="reqn">C(r) = &lt;p(r)&gt;,</code>
that is: the mean probability of finding a neighbour in a ball of radius r surrounding
a point in the phase space. Thus, it is possible to define a generalization of the correlation dimension by writing:
</p>
<p style="text-align: center;"><code class="reqn">C_q(r) = &lt;p(r)^{(q-1)}&gt;</code>
</p>

<p>Note that the correlation sum </p>
<p style="text-align: center;"><code class="reqn">C(r) = C_2(r)</code>
</p>

<p>It is possible to determine generalized dimensions Dq using the slope obtained by performing a linear regression of 
<code class="reqn">log10(Cq(r))\;Vs.\;(q-1)log10(r)</code>. The case q=1 leads to the information dimension, that is treated separately
in this package. The considerations discussed for the correlation dimension estimate
are also valid for these generalized dimensions.
</p>


<h3>Value</h3>

<p>The <em>CalculateCorrDim</em> returns the <em>HRVData</em> structure containing a <em>corrDim</em> object storing the results
of the correlation sum (see <code><a href="nonlinearTseries.html#topic+corrDim">corrDim</a></code>) of the RR time series.
</p>
<p>The <em>EstimateCorrDim</em> function estimates the correlation dimension of the 
RR time series by averaging the slopes of the embedding dimensions specified in
the <em>useEmbeddings</em> parameter. The slopes are determined by performing a linear regression
over the radius' range specified in <em>regressionRange</em>.If <em>doPlot</em> is TRUE,
a graphic of the regression over the data is shown. The 
results are returned into the <em>HRVData</em> structure, under the <em>NonLinearAnalysis</em> list.
</p>
<p><em>PlotCorrDim</em> shows two graphics of the correlation integral:
a log-log plot of the correlation sum Vs the radius and the local slopes of 
<code class="reqn">log10(C(r))\;Vs\;log10(C(r)).</code>
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+timeLag">timeLag</a></code> function from the 
nonlinearTseries package.
</p>
<p>In order to run <em>EstimateCorrDim</em>, it
is necessary to have performed the correlation sum before with <em>ComputeCorrDim</em>.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+corrDim">corrDim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # ...
 hrv.data = CreateNonLinearAnalysis(hrv.data)
 hrv.data = CalculateCorrDim(hrv.data,indexNonLinearAnalysis=1, 
             minEmbeddingDim=2, maxEmbeddingDim=8,timeLag=1,minRadius=1,
             maxRadius=15, pointsRadius=20,theilerWindow=10,
             corrOrder=2,doPlot=FALSE)
 PlotCorrDim(hrv.data,indexNonLinearAnalysis=1)
 hrv.data = EstimateCorrDim(hrv.data,indexNonLinearAnalysis=1,
             useEmbeddings=6:8,regressionRange=c(1,10))

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateDFA'>Detrended Fluctuation Analysis</h2><span id='topic+CalculateDFA'></span><span id='topic+EstimateDFA'></span><span id='topic+PlotDFA'></span>

<h3>Description</h3>

<p>Performs Detrended Fluctuation Analysis (DFA) on the RR time series, a widely used
technique for detecting long range correlations in time series. These functions
are able to estimate several scaling exponents from the time series being analyzed. 
These scaling exponents  characterize short or long-term fluctuations, depending of
the range used for regression (see  details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateDFA(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  windowSizeRange = c(10, 300), npoints = 25, doPlot = TRUE)

EstimateDFA(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, doPlot = TRUE)

PlotDFA(HRVData, indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateDFA_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_windowsizerange">windowSizeRange</code></td>
<td>
<p>Range of values for the windows size that will be used
to estimate the fluctuation function. Default: c(10,300).</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_npoints">npoints</code></td>
<td>
<p>The number of different window sizes that will be used to estimate 
the Fluctuation function in each zone.</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_doplot">doPlot</code></td>
<td>
<p>logical value. If TRUE (default value), a plot of the Fluctuation function is shown.</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Vector with 2 components denoting the range where the function will perform linear regression</p>
</td></tr>
<tr><td><code id="CalculateDFA_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Detrended Fluctuation Analysis (DFA) has become a widely used
technique for detecting long range correlations in time series. The DFA procedure
may be summarized as follows:
</p>

<ol>
<li><p> Integrate the time series to be analyzed. The time series resulting from the
integration will be referred to as the profile.
</p>
</li>
<li><p> Divide the profile into N non-overlapping segments.
</p>
</li>
<li><p>  Calculate the local trend for each of the segments using least-square regression.
Compute the total error for each of the segments.
</p>
</li>
<li><p> Compute the average of the total error over all segments and take its root square. By repeating 
the previous steps for several segment sizes (let's denote it by t), we obtain the
so-called Fluctuation function <code class="reqn">F(t)</code>.
</p>
</li>
<li><p>  If the data presents long-range power law correlations:  <code class="reqn">F(t) \sim t^\alpha</code> and
we may estimate using regression.
</p>
</li>
<li><p>  Usually, when plotting <code class="reqn">\log(F(t))\;Vs\;log(t)</code> we may distinguish two linear regions.
By regression them separately, we obtain two scaling exponents, <em><code class="reqn">\alpha_1</code></em>  
(characterizing short-term fluctuations) and <em><code class="reqn">\alpha_2</code></em> (characterizing long-term fluctuations). 
</p>
</li></ol>

<p>Steps 1-4 are performed using the <em>CalculateDFA</em> function. In order to obtain a estimate 
of some scaling exponent, the user must use the  <em>EstimateDFA</em> function specifying
the regression range (window sizes used to detrend the series).  <em><code class="reqn">\alpha_1</code></em>   is usually
obtained by performing the regression in the <code class="reqn">3&lt;t&lt;17</code> range wheras that  <em><code class="reqn">\alpha_2</code></em>
is obtained in the <code class="reqn">15&lt;t&lt;65</code> range (However the F(t) function must be linear in these ranges for obtaining
reliable results).
</p>


<h3>Value</h3>

<p>The <em>CalculateDFA</em> returns a HRVData structure containing the computations  
of the Fluctuation function of the RR time series under the <em>NonLinearAnalysis</em> list.
</p>
<p>The <em>EstimateDFA</em> function estimates an scaling exponent of the 
RR time series by performing a linear regression
over the time steps' range specified in <em>regressionRange</em>. If <em>doPlot</em> is TRUE,
a graphic of the regression over the data is shown. In order to run <em>EstimateDFA</em>, it
is necessary to have performed the Fluctuation function computations before with <em>ComputeDFA</em>. The 
results are returned into the <em>HRVData</em> structure, under the <em>NonLinearAnalysis</em> list. Since
it is possible to estimate several scaling exponents, depending on the regression range used, the
scaling exponents are also stored into a list.
</p>
<p><em>PlotDFA</em> shows a graphic of the Fluctuation functions vs window's
sizes.
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+dfa">dfa</a></code> function from the 
nonlinearTseries package.
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+dfa">dfa</a></code>
</p>

<hr>
<h2 id='CalculateEmbeddingDim'>Estimate the proper embedding dimension for the RR time series</h2><span id='topic+CalculateEmbeddingDim'></span>

<h3>Description</h3>

<p>This function determines the minimum embedding dimension from a scalar time 
series using the algorithm proposed by L. Cao (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateEmbeddingDim(HRVData, numberPoints = 5000, timeLag = 1,
  maxEmbeddingDim = 15, threshold = 0.95, maxRelativeChange = 0.05,
  doPlot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateEmbeddingDim_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_numberpoints">numberPoints</code></td>
<td>
<p>Number of points from the time series that will be used to estimate
the embedding dimension. By default, 5000 points are used.</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_timelag">timeLag</code></td>
<td>
<p>Time lag used to build the Takens' vectors needed to estimate the
embedding dimension (see <a href="nonlinearTseries.html#topic+buildTakens">buildTakens</a>). Default: 1.</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_maxembeddingdim">maxEmbeddingDim</code></td>
<td>
<p>Maximum possible embedding dimension for the time series. Default: 15.</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_threshold">threshold</code></td>
<td>
<p>Numerical value between 0 and 1. The embedding dimension is
estimated using the E1(d) function. E1(d) stops changing when d is greater 
than or equal to embedding dimension, staying close to 1. This value 
establishes a threshold for considering that E1(d) is close to 1.
Default: 0.95</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_maxrelativechange">maxRelativeChange</code></td>
<td>
<p>Maximum relative change in E1(d) with respect to
E1(d-1) in order to consider that the E1 function has been stabilized and it
will stop changing. Default: 0.05.</p>
</td></tr>
<tr><td><code id="CalculateEmbeddingDim_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of E1(d) and E2(d) is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cao's algorithm uses 2 functions in order to estimate the embedding dimension
from a time series: the E1(d) and the E2(d) functions, where d denotes the dimension.
</p>
<p>E1(d) stops changing when d is greater than or equal to the embedding dimension, staying close to 1.
On the other hand, E2(d) is used to distinguish deterministic signals from stochastic signals. For 
deterministic signals, there exists some d such that E2(d)!=1. For stochastic signals,
E2(d) is approximately 1 for all the values.
</p>


<h3>Note</h3>

<p>The current implementation of this function is fully written in R, based on the 
<code><a href="nonlinearTseries.html#topic+estimateEmbeddingDim">estimateEmbeddingDim</a></code> function from the 
nonlinearTseries package. Thus it requires 
heavy computations and may be quite slow. The <em>numberPoints</em> parameter can be used
for controlling the computational burden.
</p>
<p>Future versions of the package will solve this issue.
</p>


<h3>References</h3>

<p>Cao, L. Practical method for determining the minimum embedding dimension of a scalar time series. Physica D: Nonlinear Phenomena,
110,1, pp. 43-50 (1997).
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+estimateEmbeddingDim">estimateEmbeddingDim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
HRVData = HRVProcessedData
HRVData = SetVerbose(HRVData,T)
timeLag = CalculateTimeLag(HRVData,technique = "ami")
embeddingDim = CalculateEmbeddingDim(HRVData,
                                     timeLag = timeLag,
                                     maxEmbeddingDim = 15)

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateEnergyInPSDBands'>CalculateSPDBandsEnergy</h2><span id='topic+CalculateEnergyInPSDBands'></span>

<h3>Description</h3>

<p>Calculates the Energy in the bands of the Power Spectral Density
(PSD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateEnergyInPSDBands(HRVData,
  indexFreqAnalysis = length(HRVData$FreqAnalysis), ULFmin = 0,
  ULFmax = 0.03, VLFmin = 0.03, VLFmax = 0.05, LFmin = 0.05,
  LFmax = 0.15, HFmin = 0.15, HFmax = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>An integer referencing the data structure that contains 
the PSD analysis.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_ulfmin">ULFmin</code></td>
<td>
<p>Lower limit ULF band used for distinguish the ULF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_ulfmax">ULFmax</code></td>
<td>
<p>Upper limit ULF band used for distinguish the ULF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_vlfmin">VLFmin</code></td>
<td>
<p>Lower limit VLF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_vlfmax">VLFmax</code></td>
<td>
<p>Upper limit VLF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_lfmin">LFmin</code></td>
<td>
<p>Lower limit LF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_lfmax">LFmax</code></td>
<td>
<p>Upper limit LF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_hfmin">HFmin</code></td>
<td>
<p>Lower limit HF band.</p>
</td></tr>
<tr><td><code id="CalculateEnergyInPSDBands_+3A_hfmax">HFmax</code></td>
<td>
<p>Upper limit HF band.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the energy of the ULF, VLF, LF and HF bands in the
PSD.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PlotPSD">PlotPSD</a></code>, <code><a href="#topic+CalculatePSD">CalculatePSD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVData)
HRVData=BuildNIHR(HRVData)
HRVData=FilterNIHR(HRVData)
# Frequency analysis requires interpolated data (except Lomb)
HRVData=InterpolateNIHR(HRVData)
HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,1,"pgram",doPlot = F)
# get Energy in the default ULF, VLF and LF frequency bands.
# We modify the limits for the HF band
CalculateEnergyInPSDBands(HRVData, 1, HFmin = 0.15, HFmax = 0.3) 

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateFracDim'> Calculates Fractal Dimension </h2><span id='topic+CalculateFracDim'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function.
Calculates Fractal Dimension as indicated by Pincus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateFracDim(HRVData, indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
    m = 10, tau = 3, Cra = 0.005, Crb = 0.75, N = 1000, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateFracDim_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p> Reference to the data structure that will contain the non linear analysis </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_cra">Cra</code></td>
<td>
<p> Minimum value of correlation for calculating Fractal Dimension </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_crb">Crb</code></td>
<td>
<p> Maximum value of correlation for calculating Fractal Dimension </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_n">N</code></td>
<td>
<p> Number of points of the portion of signal to be analyzed </p>
</td></tr>
<tr><td><code id="CalculateFracDim_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and now associated heart rate instantaneous values also, including the value of the Fractal Dimension
</p>


<h3>Note</h3>

<p>This function is <b>deprecated</b>. We suggest the use of the 
<code><a href="#topic+CalculateCorrDim">CalculateCorrDim</a></code> function instead, which is faster.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
S. M. Pincus, &quot;Approximate entropy as a measure of system complexity,&quot; Mathematics 88, 2297-2301 (1991)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateRfromCorrelation">CalculateRfromCorrelation</a></code> for finding r distance at which the correlation has a certain value
</p>

<hr>
<h2 id='CalculateInfDim'>Information dimension of the RR time series</h2><span id='topic+CalculateInfDim'></span><span id='topic+EstimateInfDim'></span><span id='topic+PlotInfDim'></span>

<h3>Description</h3>

<p>Information dimension of the RR time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateInfDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  minEmbeddingDim = NULL, maxEmbeddingDim = NULL, timeLag = NULL,
  minFixedMass = 1e-04, maxFixedMass = 0.005, numberFixedMassPoints = 50,
  radius = 1, increasingRadiusFactor = 1.05, numberPoints = 500,
  theilerWindow = 100, doPlot = TRUE)

EstimateInfDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, useEmbeddings = NULL, doPlot = TRUE)

PlotInfDim(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateInfDim_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_minembeddingdim">minEmbeddingDim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we shall embed the time series.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_maxembeddingdim">maxEmbeddingDim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we shall embed the time series.
Thus, we shall estimate the correlation dimension between <em>minEmbeddingDim</em> and <em>maxEmbeddingDim</em>.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_minfixedmass">minFixedMass</code></td>
<td>
<p>Minimum percentage of the total points that the algorithm shall use for the estimation.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_maxfixedmass">maxFixedMass</code></td>
<td>
<p>Maximum percentage of the total points that the algorithm shall use for the estimation.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_numberfixedmasspoints">numberFixedMassPoints</code></td>
<td>
<p>The number of different <em>fixed mass</em> fractions between <em>minFixedMass</em>
and <em>maxFixedMass</em> that the algorithm will use for estimation.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_radius">radius</code></td>
<td>
<p>Initial radius for searching neighbour points in the phase space. Ideally, it should be small
enough so that the fixed mass contained in this radius is slightly greater than the <em>minFixedMass</em>. However,
whereas the radius is not too large (so that the performance decreases) the choice is not critical.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_increasingradiusfactor">increasingRadiusFactor</code></td>
<td>
<p>Numeric value. If no enough neighbours are found within <em>radius</em>, the radius
is increased by a factor <em>increasingRadiusFactor</em> until succesful. Default: 1.05.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_numberpoints">numberPoints</code></td>
<td>
<p>Number of reference points that the routine will try to use, saving computation time.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_theilerwindow">theilerWindow</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' vectors must be separated by more than
theilerWindow time steps in order to be considered neighbours. By using a Theiler window, we exclude temporally correlated 
vectors from our estimations.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default), a plot of the correlation sum with q=1 is shown</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Vector with 2 components denoting the range where the function will perform linear regression</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_useembeddings">useEmbeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions should the algorithm
use to compute the information dimension.</p>
</td></tr>
<tr><td><code id="CalculateInfDim_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information dimension is a particular case of the generalized correlation dimension
when setting the order q = 1. It is possible to demonstrate that the information dimension
<code class="reqn">D_1</code> may be defined as:
<code class="reqn">D_1=lim_{r \rightarrow 0} &lt;\log p(r)&gt;/\log(r)</code>.
Here, <code class="reqn">p(r)</code> is the probability of finding a neighbour in a neighbourhood of size <code class="reqn">r</code> and 
&lt;&gt; is the mean value. Thus, the information dimension specifies how the average
Shannon information scales with the radius <code class="reqn">r</code>.
</p>
<p>In order to estimate <code class="reqn">D_1</code>, the algorithm looks for the scaling behaviour of the average
radius that contains a given portion (a &quot;fixed-mass&quot;) of the total points in the phase space. By performing
a linear regression of <code class="reqn">\log(p)\;Vs.\;\log(&lt;r&gt;)</code> (being <code class="reqn">p</code> the fixed-mass of the total points), an estimate
of <code class="reqn">D_1</code> is obtained. The user should run
the method for different embedding dimensions for checking if <code class="reqn">D_1</code> saturates.
</p>
<p>The calculations for the information dimension are heavier than
those needed for the correlation dimension.
</p>


<h3>Value</h3>

<p>The <em>CalculateCorrDim</em> returns the <em>HRVData</em> structure containing a <em>infDim</em> object storing the results
of the correlation sum (see <code><a href="nonlinearTseries.html#topic+infDim">infDim</a></code>) of the RR time series.
</p>
<p>The <em>EstimateInfDim</em> function estimates the information dimension of the 
RR time series by averaging the slopes of the correlation sums with q=1.
The slopes are determined by performing a linear regression
over the radius' range specified in <em>regressionRange</em>.If <em>doPlot</em> is TRUE,
a graphic of the regression over the data is shown. The 
results are returned into the <em>HRVData</em> structure, under the <em>NonLinearAnalysis</em> list.
</p>
<p><em>PlotInfDim</em> shows a graphics of the correlation sum with q=1.
</p>


<h3>Note</h3>

<p>In order to run <em>EstimateInfDim</em>, it
is necessary to have performed the correlation sum before with <em>ComputeInfDim</em>.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateCorrDim">CalculateCorrDim</a></code>.
</p>

<hr>
<h2 id='CalculateMaxLyapunov'>Maximum lyapunov exponent</h2><span id='topic+CalculateMaxLyapunov'></span><span id='topic+EstimateMaxLyapunov'></span><span id='topic+PlotMaxLyapunov'></span>

<h3>Description</h3>

<p>Functions for estimating the maximal Lyapunov exponent of  the RR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateMaxLyapunov(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  minEmbeddingDim = NULL, maxEmbeddingDim = NULL, timeLag = NULL,
  radius = 2, theilerWindow = 100, minNeighs = 5, minRefPoints = 500,
  numberTimeSteps = 20, doPlot = TRUE)

EstimateMaxLyapunov(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, useEmbeddings = NULL, doPlot = TRUE)

PlotMaxLyapunov(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateMaxLyapunov_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_minembeddingdim">minEmbeddingDim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we shall embed the time series</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_maxembeddingdim">maxEmbeddingDim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we shall embed the time series. Thus,
we shall estimate the correlation dimension between <em>minEmbeddingDim</em> and <em>maxEmbeddingDim</em>.</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors. Default: timeLag = 1</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_radius">radius</code></td>
<td>
<p>Maximum distance in which will look for nearby trajectories. Default: radius = 2</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_theilerwindow">theilerWindow</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' vectors must be separated by more than
<em>theilerWindow</em> time steps in order to be considered neighbours. By using a Theiler window, temporally correlated 
vectors are excluded from the estimations.  Default: theilerWindow = 100</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_minneighs">minNeighs</code></td>
<td>
<p>Minimum number of neighbours that a Takens' vector must have to be considered
a reference point. Default: minNeighs = 5</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_minrefpoints">minRefPoints</code></td>
<td>
<p>Number of reference points that the routine will try to use. The routine stops when it finds 
<em>minRefPoints</em> reference points, saving computation time. Default: minRefPoints = 500</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_numbertimesteps">numberTimeSteps</code></td>
<td>
<p>Integer denoting the number of time steps in which the algorithm will
compute the divergence.</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of <code class="reqn">S(t)</code> Vs  <code class="reqn">t</code> is shown.</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Vector with 2 components denoting the range where the function will perform linear regression</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_useembeddings">useEmbeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions should the algorithm use to compute
the maximal Lyapunov exponent.</p>
</td></tr>
<tr><td><code id="CalculateMaxLyapunov_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a well-known fact that close trajectories diverge exponentially fast in a chaotic system. The 
averaged exponent that determines the divergence rate is called the Lyapunov exponent (usually denoted with <code class="reqn">\lambda</code>). 
If <code class="reqn">\delta(0)</code> is the distance between two Takens' vectors in the embedding.dim-dimensional space, we expect that the distance
after a time <code class="reqn">t</code> between the two trajectories arising from this two vectors fulfills:
</p>
<p style="text-align: center;"><code class="reqn">\delta (n) \sim \delta (0)\cdot exp(\lambda \cdot t)</code>
</p>

<p>The lyapunov exponent is estimated using the slope obtained by performing a linear regression of 
<code class="reqn">S(t)=\lambda \cdot t \sim log(\delta (t)/\delta (0))</code> 
on  <code class="reqn">t</code>. <code class="reqn">S(t)</code> will be estimated by averaging the divergence of several reference points.
</p>
<p>The user should plot <code class="reqn">S(t) Vs t</code> when looking for the maximal lyapunov exponent and, if for some temporal range
<code class="reqn">S(t)</code> shows a linear behaviour, its slope is an estimate of the maximal Lyapunov exponent per unit of time. The estimate
routine allows the user to get always an estimate of the maximal Lyapunov exponent, but the user must check that there is a linear region in the  
<code class="reqn">S(t) Vs t</code>. If such a region does not exist, the estimation should be discarded.  The user should also
run the method for different embedding dimensions for checking if <code class="reqn">D_1</code> saturates.
</p>


<h3>Value</h3>

<p>The <em>CalculateMaxLyapunov</em> returns a HRVData structure containing the divergence computations of the 
RR time series under the <em>NonLinearAnalysis</em> list.
</p>
<p>The <em>EstimateMaxLyapunov</em> function estimates the maximum Lyapunov exponent of the 
RR time series  by performing a linear regression
over the time steps' range specified in <em>regressionRange</em>.If <em>doPlot</em> is TRUE,
a graphic of the regression over the data is shown. The 
results are returned into the <em>HRVData</em> structure, under the <em>NonLinearAnalysis</em> list.
</p>
<p><em>PlotMaxLyapunov</em> shows a graphic of the divergence Vs time
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+maxLyapunov">maxLyapunov</a></code> function from the 
nonlinearTseries package.
</p>
<p>In order to run <em>EstimateMaxLyapunov</em>, it
is necessary to have performed the divergence computations before with <em>ComputeMaxLyapunov</em>.
</p>


<h3>References</h3>

<p>Eckmann, Jean-Pierre and Kamphorst, S Oliffson and Ruelle, David and Ciliberto, S and others. Liapunov exponents from time series.
Physical Review A, 34-6, 4971&ndash;4979, (1986).
</p>
<p>Rosenstein, Michael T and Collins, James J and De Luca, Carlo J.A practical method for calculating largest Lyapunov exponents from small data sets.
Physica D: Nonlinear Phenomena, 65-1, 117&ndash;134, (1993).
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+maxLyapunov">maxLyapunov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ...
hrv.data = CreateNonLinearAnalysis(hrv.data)
hrv.data = CalculateMaxLyapunov(hrv.data,indexNonLinearAnalysis=1,
                                 minEmbeddingDim=5,
                                 maxEmbeddingDim = 5,
                                 timeLag=1,radius=10,
                                 theilerWindow=100, doPlot=FALSE)
PlotMaxLyapunov(hrv.data,indexNonLinearAnalysis=1)
hrv.data = EstimateMaxLyapunov(hrv.data,indexNonLinearAnalysis=1, 
                               regressionRange=c(1,10))

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculatePowerBand'> Calculates power per band </h2><span id='topic+CalculatePowerBand'></span>

<h3>Description</h3>

<p>Calculates  power of the heart rate signal at ULF, VLF, LF and HF bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculatePowerBand(HRVData,
                   indexFreqAnalysis = length(HRVData$FreqAnalysis),
                   size, shift, sizesp = NULL, scale = "linear",
                   ULFmin = 0, ULFmax = 0.03,
                   VLFmin = 0.03, VLFmax = 0.05,
                   LFmin = 0.05, LFmax = 0.15,
                   HFmin = 0.15, HFmax = 0.4,
                   type = c("fourier", "wavelet"), wavelet = "d4",
                   bandtolerance = 0.01, relative = FALSE,
                   verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculatePowerBand_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information 
related to it </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p> Reference to the data structure that will contain
the variability analysis </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_size">size</code></td>
<td>
<p> Size of window for calculations (seconds) </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_shift">shift</code></td>
<td>
<p> Displacement of window for calculations (seconds) </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_sizesp">sizesp</code></td>
<td>
<p> Points for calculation (zero padding). If the user does not 
specify it, the function estimates a propper value.</p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_ulfmin">ULFmin</code></td>
<td>
<p> Lower limit ULF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_ulfmax">ULFmax</code></td>
<td>
<p> Upper limit ULF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_vlfmin">VLFmin</code></td>
<td>
<p> Lower limit VLF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_vlfmax">VLFmax</code></td>
<td>
<p> Upper limit VLF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_lfmin">LFmin</code></td>
<td>
<p> Lower limit LF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_lfmax">LFmax</code></td>
<td>
<p> Upper limit LF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_hfmin">HFmin</code></td>
<td>
<p> Lower limit HF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_hfmax">HFmax</code></td>
<td>
<p> Upper limit HF band </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_scale">scale</code></td>
<td>
<p> Deprecated argument </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility,
use SetVerbose() instead </p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_type">type</code></td>
<td>
<p> Type of analysis used to calculate the spectrogram. 
Possible options are &quot;fourier&quot; or &quot;wavelet&quot;</p>
</td></tr> 
<tr><td><code id="CalculatePowerBand_+3A_wavelet">wavelet</code></td>
<td>
<p> Mother wavelet used to calculate the spectrogram when
a wavelet-based analysis is performed. The available wavelets are: 
&quot;haar&quot; wavelet; least asymmetric Daubechies wavelets of width 8 (&quot;la8&quot;),
16 (&quot;la16&quot;) and 20 (&quot;la20&quot;) samples; extremal phase Daubechies of width 4
(&quot;d4&quot;), 6 (&quot;d6&quot;), 8 (&quot;d8&quot;) and 16 (&quot;d16&quot;) samples; best localized wavelets
of width 14 (&quot;bl14&quot;) and 20 (&quot; bl20&quot;) samples; Fejer-Korovkin wavelets of 
width 4 (&quot;fk4&quot;), 6 (&quot;fk6&quot;), 8 (&quot;fk8&quot;), 14(&quot;fk14&quot;) and 22 (&quot;fk22&quot;) samples; 
minimum bandwidth wavelets of width 4 (&quot;mb4&quot;), 8 (&quot;mb8&quot;), 16 (&quot;mb16&quot;) and 24 
(&quot;mb24&quot;); and the biorthogonal wavelet &quot;bs3.1&quot;</p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_bandtolerance">bandtolerance</code></td>
<td>
<p> Maximum error allowed when a wavelet-based analysis is 
performed. It can be specified as a absolute or a relative error depending on
the &quot;relative&quot; parameter value</p>
</td></tr>
<tr><td><code id="CalculatePowerBand_+3A_relative">relative</code></td>
<td>
<p> Logic value specifying which kind of bandtolerance shall be
used (relative or absolute). The relative tolerance takes into account the 
width of each of the intervals of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, 
associated heart rate instantaneous values, filtered heart rate signal
equally spaced, and the analysis structure including spectral power at 
different bands of the heart rate signal
</p>


<h3>Note</h3>

<p>An example including all the necessary steps to obtain the power<br /> 
bands of a wfdb register is giving below:<br />
</p>
<p>##Reading a wfdb register and storing into a data structure:<br />
md = CreateHRVData(Verbose = TRUE)<br />
md = LoadBeatWFDB(md, RecordName = &quot;register_name&quot;,<br /> 
RecordPath = &quot;register_path&quot;)<br />
</p>
<p>##Calculating heart rate signal:<br />
md = BuildNIHR(md)<br />
</p>
<p>##Filtering heart rate signal:<br />
md = FilterNIHR(md)<br />
</p>
<p>##Interpolating heart rate signal:<br />
md = InterpolateNIHR(md)<br />
</p>
<p>##Calculating spectrogram and power per band using fourier <br />
analysis:<br />
md = CreateFreqAnalysis(md)<br />
md = CalculatePowerBand(md, indexFreqAnalysis = 1, size = 120, <br />
shift = 10, sizesp = 1024)<br />
</p>
<p>##Calculating spectrogram and power per band using wavelet analysis:<br />
md = CreateFreqAnalysis(md)<br />
md = CalculatePowerBand(md, indexFreqAnalysis = 2, type=&quot;wavelet&quot;,<br /> 
wavelet=&quot;la8&quot;,bandtolerance=0.0025)<br />
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, 
and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral 
analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='CalculatePSD'>Spectral Density Estimation</h2><span id='topic+CalculatePSD'></span>

<h3>Description</h3>

<p>Estimate the Power Spectral Density (PSD) of the RR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculatePSD(HRVData, indexFreqAnalysis = length(HRVData$FreqAnalysis),
  method = c("pgram", "ar", "lomb"), doPlot = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculatePSD_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="CalculatePSD_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>An integer referencing the data structure that will contain 
the frequency analysis.</p>
</td></tr>
<tr><td><code id="CalculatePSD_+3A_method">method</code></td>
<td>
<p>String specifying the method used to estimate the spectral 
density. Allowed methods are &quot;pgram&quot; (the default), &quot;ar&quot; and &quot;lomb&quot;.</p>
</td></tr>
<tr><td><code id="CalculatePSD_+3A_doplot">doPlot</code></td>
<td>
<p>Plot the periodogram?</p>
</td></tr>
<tr><td><code id="CalculatePSD_+3A_...">...</code></td>
<td>
<p>Further arguments to specific PSD estimation methods or 
<code><a href="#topic+PlotPSD">PlotPSD</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;pgram&quot; and &quot;ar&quot; methods use the <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>
and <code><a href="stats.html#topic+spec.ar">spec.ar</a></code> functions. Thus, the same arguments used
in  <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code> or <code><a href="stats.html#topic+spec.ar">spec.ar</a></code> 
can be used when method is &quot;pgram&quot; or &quot;ar&quot;, respectively.
The &quot;lomb&quot;  is based in the <code><a href="lomb.html#topic+lsp">lsp</a></code> and thus it accepts the
same parameters as this function.
</p>


<h3>Value</h3>

<p>The <em>CalculatePSD</em> returns the <em>HRVData</em> structure 
containing a <em>periodogram</em> field storing and PSD estimation 
of the RR time series. When the &quot;pgram&quot; and &quot;ar&quot; methods are used the
<em>periodogram</em> field is an object of class &quot;spec&quot;. If &quot;lomb&quot; is used,
the <em>periodogram</em> field is just a list. In any case the 
<em>periodogram</em> field will contain:
</p>

<ul>
<li><p>freq: vector of frequencies at which the spectral density is estimated.
</p>
</li>
<li><p>spec: spectral density estimation 
</p>
</li>
<li><p>series: name of the series
</p>
</li>
<li><p>method: method used to calculate the spectrum
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="#topic+PlotPSD">PlotPSD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVData)
HRVData=BuildNIHR(HRVData)
HRVData=FilterNIHR(HRVData)
# Frequency analysis requires interpolated data (except Lomb)
HRVData=InterpolateNIHR(HRVData)
# Create a different freqAnalysis for each method
HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,1,"pgram",doPlot = F)

HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,2,"pgram",spans=9, doPlot = F)

HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,3,"ar",doPlot = F)

HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,4,"lomb",doPlot = F)
# Plot the results
layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE))
PlotPSD(HRVData,1)
PlotPSD(HRVData,2)
PlotPSD(HRVData,3)
PlotPSD(HRVData,4)

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateRfromCorrelation'> Calculates ra and rb from Correlation </h2><span id='topic+CalculateRfromCorrelation'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function. 
Calculates ra and rb distances that verify that their correlation values are Cra and Crb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateRfromCorrelation(HRVData, Data, m, tau, Cra, Crb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateRfromCorrelation_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="CalculateRfromCorrelation_+3A_data">Data</code></td>
<td>
<p> Portion of HRVData to be analyzed </p>
</td></tr>
<tr><td><code id="CalculateRfromCorrelation_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateRfromCorrelation_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
<tr><td><code id="CalculateRfromCorrelation_+3A_cra">Cra</code></td>
<td>
<p> Minimum value of correlation for calculating Fractal Dimension </p>
</td></tr>
<tr><td><code id="CalculateRfromCorrelation_+3A_crb">Crb</code></td>
<td>
<p> Maximum value of correlation for calculating Fractal Dimension </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2 by 2 matrix containing ra and rb distance in the first row and their exact correlation values in the second row
</p>


<h3>Note</h3>

<p>This function is used in the <code><a href="#topic+CalculateFracDim">CalculateFracDim</a></code> function, which is
<b>deprecated</b>. We suggest the use of the <code><a href="#topic+CalculateCorrDim">CalculateCorrDim</a></code> function 
instead of <code><a href="#topic+CalculateFracDim">CalculateFracDim</a></code>.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
S. M. Pincus, &quot;Approximate entropy as a measure of system complexity,&quot; Mathematics 88, 2297-2301 (1991)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateFracDim">CalculateFracDim</a></code> 
</p>

<hr>
<h2 id='CalculateSampleEntropy'>Sample Entropy (also known as Kolgomorov-Sinai Entropy)</h2><span id='topic+CalculateSampleEntropy'></span><span id='topic+EstimateSampleEntropy'></span><span id='topic+PlotSampleEntropy'></span>

<h3>Description</h3>

<p>These functions measure the complexity of the RR time series. Large values of 
the Sample Entropy indicate high complexity whereas that smaller values characterize
more regular signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateSampleEntropy(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), doPlot = TRUE)

EstimateSampleEntropy(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, useEmbeddings = NULL, doPlot = TRUE)

PlotSampleEntropy(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateSampleEntropy_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="CalculateSampleEntropy_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="CalculateSampleEntropy_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default), a plot of the correlation sum is shown</p>
</td></tr>
<tr><td><code id="CalculateSampleEntropy_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Vector with 2 components denoting the range where the function will perform linear regression</p>
</td></tr>
<tr><td><code id="CalculateSampleEntropy_+3A_useembeddings">useEmbeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions should the algorithm use to compute
the sample entropy.</p>
</td></tr>
<tr><td><code id="CalculateSampleEntropy_+3A_...">...</code></td>
<td>
<p>Additional plot parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample entropy is computed using:
</p>
<p style="text-align: center;"><code class="reqn">h_q(m,r) = log(C_q(m,r)/C_{q}(m+1,r))</code>
</p>

<p>where <em>m</em> is the embedding dimension and <em>r</em> is the radius of the neighbourhood. When 
computing the correlation dimensions we use the linear regions from the correlation
sums in order to do the estimates. Similarly, the sample entropy <code class="reqn">h_q(m,r)</code> 
should not change for both various <em>m</em> and <em>r</em>.
</p>


<h3>Value</h3>

<p>The <em>CalculateSampleEntropy</em> returns a HRVData structure containing the sample entropy computations of the 
RR time series under the <em>NonLinearAnalysis</em> list.
</p>
<p>The <em>EstimateSampleEntropy</em> function estimates the sample entropy of the 
RR time series  by performing a linear regression
over the radius' range specified in <em>regressionRange</em>. If <em>doPlot</em> is TRUE,
a graphic of the regression over the data is shown. In order to run <em>EstimateSampleEntropy</em>, it
is necessary to have performed the sample entropy computations before with <em>ComputeSampleEntropy</em>. The 
results are returned into the <em>HRVData</em> structure, under the <em>NonLinearAnalysis</em> list.
</p>
<p><em>PlotSampleEntropy</em> shows a graphic of the sample entropy computations.
</p>


<h3>Note</h3>

<p>In order to run this functions, it is necessary to have used the <em>CalculateCorrDim</em> function.
</p>
<p>This function is based on the <code><a href="nonlinearTseries.html#topic+sampleEntropy">sampleEntropy</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+sampleEntropy">sampleEntropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ...
hrv.data = CreateNonLinearAnalysis(hrv.data)
hrv.data = CalculateCorrDim(hrv.data,indexNonLinearAnalysis=1,minEmbeddingDim=2,
                            maxEmbeddingDim=8,timeLag=1,minRadius=1,maxRadius=15,
                            pointsRadius=20,theilerWindow=10,corrOrder=2,doPlot=FALSE)
hrv.data = CalculateSampleEntropy(hrv.data,indexNonLinearAnalysis=1,doPlot=FALSE)
PlotSampleEntropy(hrv.data,indexNonLinearAnalysis=1)
hrv.data = EstimateSampleEntropy(hrv.data,indexNonLinearAnalysis=1,regressionRange=c(6,10))

## End(Not run)
</code></pre>

<hr>
<h2 id='CalculateSpectrogram'> Calculates the spectrogram of a signal </h2><span id='topic+CalculateSpectrogram'></span>

<h3>Description</h3>

<p>Calculates the spectrogram of the heart rate signal after filtering and 
interpolation in a window of a certain size 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateSpectrogram(HRVData, size, shift, sizesp = 1024, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateSpectrogram_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information
related to it </p>
</td></tr>
<tr><td><code id="CalculateSpectrogram_+3A_size">size</code></td>
<td>
<p> Size of window for calculating spectrogram (seconds) </p>
</td></tr>
<tr><td><code id="CalculateSpectrogram_+3A_shift">shift</code></td>
<td>
<p> Displacement of window for calculating spectrogram (seconds) </p>
</td></tr>
<tr><td><code id="CalculateSpectrogram_+3A_sizesp">sizesp</code></td>
<td>
<p> Points for calculating spectrogram (zero padding) </p>
</td></tr>
<tr><td><code id="CalculateSpectrogram_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use
SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the spectrogram of the heart rate signal
</p>


<h3>Note</h3>

<p>An example including all the necessary steps to obtain the spectrogram<br />
of a wfdb register is giving below:<br />
</p>
<p>##Reading a wfdb register and storing into a data structure:<br />
md = CreateHRVData(Verbose = TRUE)<br />
md = LoadBeatWFDB(md, RecordName = &quot;register_name&quot;, <br />
RecordPath = &quot;register_path&quot;, verbose = TRUE)<br />
</p>
<p>##Calculating heart rate signal:<br />
md = BuildNIHR(md)<br />
</p>
<p>##Filtering heart rate signal:<br />
md = FilterNIHR(md)<br />
</p>
<p>##Interpolating heart rate signal:<br />
md = InterpolateNIHR(md)<br />
</p>
<p>##Calculating spectrogram:<br />
CalculateSpectrogram(md, size = 120, shift = 10, sizesp = 1024)<br />
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='CalculateTimeLag'>Estimate an appropiate time lag for the Takens' vectors</h2><span id='topic+CalculateTimeLag'></span>

<h3>Description</h3>

<p>Given a time series (timeSeries), an embedding dimension (m) and a 
time lag (timeLag), the <code class="reqn">n^{th}</code> 
Takens' vector is defined as 
</p>
<p style="text-align: center;"><code class="reqn">T[n]={timeSeries[n], timeSeries[n+ timeLag],...timeSeries[n+m*timeLag]}.</code>
</p>

<p>This function estimates an appropiate time lag by using the autocorrelation or the
average mutual information (AMI) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateTimeLag(HRVData, technique = c("acf", "ami"),
  method = c("first.e.decay", "first.zero", "first.minimum", "first.value"),
  value = 1/exp(1), lagMax = NULL, doPlot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateTimeLag_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_technique">technique</code></td>
<td>
<p>The technique that we shall use to estimate the time lag. 
Allowed values are <em>&quot;acf&quot;</em> and <em>&quot;ami&quot;</em>.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_method">method</code></td>
<td>
<p>The method that we shall use to select the time lag (see the Details section). Available methods
are <em>&quot;first.zero&quot;</em>, <em>&quot;first.e.decay&quot;</em>, <em>&quot;first.minimum&quot;</em> and <em>&quot;first.value&quot;</em>.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_value">value</code></td>
<td>
<p>Numeric value indicating the value that the autocorrelation/AMI function must cross in order to
select the time lag. It is used only with the &quot;first.value&quot; method.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_lagmax">lagMax</code></td>
<td>
<p>Maximum lag at which to calculate the acf/AMI.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the autocorrelation/AMI function is shown.</p>
</td></tr>
<tr><td><code id="CalculateTimeLag_+3A_...">...</code></td>
<td>
<p>Additional parameters for the <em>acf</em> or the 
<em>mutualInformation</em> functions (see <code><a href="nonlinearTseries.html#topic+mutualInformation">mutualInformation</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A basic criteria for estimating a proper time lag is based on the following reasoning:
if the time lag used to build the Takens' vectors is too small, the coordinates will
be too highly temporally correlated and the embedding will tend to cluster around 
the diagonal in the phase space. If the time lag is chosen too large, the resulting 
coordinates may be almost uncorrelated and the resulting embedding will be very complicated. 
Thus, the autocorrelation function can be used for  estimating an appropiate time lag of
a time series. However, it must be noted that the autocorrelation is a linear statistic,
and thus it does not take into account nonlinear dynamical correlations. To take into
account nonlinear correlations the average mutual information (AMI) can be used. 
Independently of the technique used to compute the correlation, the time lag can
be selected in a variety of ways: 
</p>

<ul>
<li><p> Select the time lag where the autocorrelation/AMI function decays to 0 
(<em>first.zero</em> method). This
method is not appropriate for the AMI function, since it only takes positive values.
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function decays to 
1/e of its value at zero (<em>first.e.decay</em> method).
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function reaches 
its first minimum (<em>first.minimum</em> method).
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function decays to
the value specified by the user (<em>first.value</em> method and 
<em>value</em> parameter).
</p>
</li></ul>



<h3>Value</h3>

<p>The estimated time lag.
</p>


<h3>Note</h3>

<p>If the autocorrelation/AMI function does not cross the specifiged value, an error is thrown. This may be solved
by increasing the lag.max or selecting a higher value to which the autocorrelation/AMI function may decay.
</p>
<p>This function is based on the <code><a href="nonlinearTseries.html#topic+timeLag">timeLag</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+timeLag">timeLag</a></code>,<code><a href="nonlinearTseries.html#topic+mutualInformation">mutualInformation</a></code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
HRVData = HRVProcessedData
HRVData = SetVerbose(HRVData,T)
timeLag = CalculateTimeLag(HRVData,technique = "ami")
embeddingDim = CalculateEmbeddingDim(HRVData,
                                     timeLag = timeLag,
                                     maxEmbeddingDim = 15)

## End(Not run)
</code></pre>

<hr>
<h2 id='CreateFreqAnalysis'> Creates data analysis structure for frequency analysis calculations </h2><span id='topic+CreateFreqAnalysis'></span>

<h3>Description</h3>

<p>Creates data analysis structure that stores the information extracted from a variability analysis of heart rate signal and joins it to HRVData as a member of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateFreqAnalysis(HRVData, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateFreqAnalysis_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="CreateFreqAnalysis_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, associated heart rate instantaneous values, filtered heart rate signal equally spaced, and a new analysis structure as a member of a list
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CreateHRVData">CreateHRVData</a></code>  </p>

<hr>
<h2 id='CreateHRVData'> Creates data structure for all the calculations </h2><span id='topic+CreateHRVData'></span>

<h3>Description</h3>

<p>Creates data structure that stores the beats register and all the information obtained from it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateHRVData(Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateHRVData_+3A_verbose">Verbose</code></td>
<td>
<p> Boolean argument that allows to specify if the function returns additional information </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that will contain beat positions register, associated heart rate instantaneous values, filtered heart rate signal equally spaced, and one or more analysis structures
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CreateFreqAnalysis">CreateFreqAnalysis</a></code>, <code><a href="#topic+CreateTimeAnalysis">CreateTimeAnalysis</a></code>, <code><a href="#topic+CreateNonLinearAnalysis">CreateNonLinearAnalysis</a></code>  </p>

<hr>
<h2 id='CreateNonLinearAnalysis'> Creates data analysis structure for non linear analysis calculations </h2><span id='topic+CreateNonLinearAnalysis'></span>

<h3>Description</h3>

<p>Creates data analysis structure that stores the information extracted from a non linear analysis of ECG signal and joins it to HRVData as a member of a list</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateNonLinearAnalysis(HRVData, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateNonLinearAnalysis_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="CreateNonLinearAnalysis_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, associated heart rate instantaneous values, filtered heart rate signal equally spaced, and a new analysis structure as a member of a list
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CreateHRVData">CreateHRVData</a></code>  </p>

<hr>
<h2 id='CreateTimeAnalysis'> Creates data analysis structure for time analysis calculations </h2><span id='topic+CreateTimeAnalysis'></span>

<h3>Description</h3>

<p>Creates data analysis structure that stores the information extracted from a time analysis of ECG signal and joins it to HRVData as a member of a list</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateTimeAnalysis(HRVData, size=300, numofbins=NULL, interval=7.8125, verbose=NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateTimeAnalysis_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="CreateTimeAnalysis_+3A_size">size</code></td>
<td>
<p> Size of window (seconds) </p>
</td></tr>
<tr><td><code id="CreateTimeAnalysis_+3A_numofbins">numofbins</code></td>
<td>
<p> Number of bins in histogram. If it is not specified, the interval parameter is used (default)</p>
</td></tr>
<tr><td><code id="CreateTimeAnalysis_+3A_interval">interval</code></td>
<td>
<p> Width of bins in histogram (milliseconds)</p>
</td></tr>
<tr><td><code id="CreateTimeAnalysis_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, associated heart rate instantaneous values, filtered heart rate signal equally spaced, and a new analysis structure as a member of a list
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CreateHRVData">CreateHRVData</a></code>  </p>

<hr>
<h2 id='EditNIHR'> Manually edition of non-interpolated instantaneous heart rate </h2><span id='topic+EditNIHR'></span>

<h3>Description</h3>

<p>Plots non-interpolated instantaneous heart rate for manual removing of outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EditNIHR(HRVData, scale = 1, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EditNIHR_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="EditNIHR_+3A_scale">scale</code></td>
<td>
<p> Allows scaling for small screens </p>
</td></tr>
<tr><td><code id="EditNIHR_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Data, the structure that contains beat positions register, and manually edited associated heart rate instantaneous values
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='EstimatePSDSlope'>Estimate the slope of the Power Spectral Density (PSD).</h2><span id='topic+EstimatePSDSlope'></span>

<h3>Description</h3>

<p>Estimate the slope of the Power Spectral Density (PSD)  of the 
RR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimatePSDSlope(HRVData, indexFreqAnalysis = length(HRVData$FreqAnalysis),
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  regressionRange = NULL, doPlot = T, main = "PSD power law",
  xlab = "Frequency (Hz)", ylab = "Spectrum", pch = NULL, log = "xy",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstimatePSDSlope_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>An integer referencing the periodogram that will be
used for estimating the spectral index.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>An integer referencing the structure that will
store the resulting estimations.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_regressionrange">regressionRange</code></td>
<td>
<p>Range of frequencies in which the regression will be
performed. Default is c(1e-4, 1e-2) Hz.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_doplot">doPlot</code></td>
<td>
<p>Plot the periodogram and the least-squares fit?</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_xlab">xlab</code></td>
<td>
<p>Title for the x axis.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_ylab">ylab</code></td>
<td>
<p>Title for the y axis.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_pch">pch</code></td>
<td>
<p>Symbol for the plotting points.</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_log">log</code></td>
<td>
<p>A character string which contains &quot;x&quot; if the x axis is to be 
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if 
both axes are to be logarithmic (default).</p>
</td></tr>
<tr><td><code id="EstimatePSDSlope_+3A_...">...</code></td>
<td>
<p>Other arguments for the plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power spectrum of most physiological signals fulfils
<code class="reqn">S(f)=Cf^{-\beta}</code> (1/f spectrum). This function estimates
the <code class="reqn">\beta</code> exponent, which is usually referred to as the spectral
index.
</p>


<h3>Value</h3>

<p>The <em>EstimatePSDSlope</em> returns the <em>HRVData</em> structure 
containing a <em>PSDSlope</em> field storing the spectral index and the 
proper Hurst exponent.
</p>


<h3>Note</h3>

<p>It should be noted that the PSD must be estimated prior to the
use of this function. We do not recommend the use of the AR spectrum when
estimating the spectral index.
</p>


<h3>References</h3>

<p>Voss, Andreas, et al. &quot;Methods derived from nonlinear dynamics 
for analysing heart rate variability.&quot; Philosophical Transactions of the 
Royal Society A: Mathematical, Physical and Engineering Sciences 367.1887 
(2009): 277-296.
</p>
<p>Eke, A., Herman, P., Kocsis, L., &amp; Kozak, L. R. (2002). Fractal 
characterization of complexity in temporal physiological signals. 
Physiological measurement, 23(1), R1.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>,<code><a href="lomb.html#topic+lsp">lsp</a></code>,
<code><a href="#topic+CalculatePSD">CalculatePSD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
# use other name for convenience
HRVData=HRVProcessedData
# Estimate the periodogram
HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,1,"pgram",doPlot = T,log="xy")
HRVData=CreateNonLinearAnalysis(HRVData)
HRVData=SetVerbose(HRVData,T)
HRVData=EstimatePSDSlope(HRVData,1,1,
                        regressionRange=c(5e-4,1e-2))

## End(Not run)
</code></pre>

<hr>
<h2 id='ExtractTimeSegment'>Time windows of HR record</h2><span id='topic+ExtractTimeSegment'></span>

<h3>Description</h3>

<p>Extracts a temporal subset between the times starttime and endtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractTimeSegment(HRVData, starttime, endtime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractTimeSegment_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it. This function calls <em>Window</em> to perform the extraction.</p>
</td></tr>
<tr><td><code id="ExtractTimeSegment_+3A_starttime">starttime</code></td>
<td>
<p>The start time of the period of interest.</p>
</td></tr>
<tr><td><code id="ExtractTimeSegment_+3A_endtime">endtime</code></td>
<td>
<p>The end time of the period of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <em>HRVData</em> contains episodes, beats or RR time series,
these will be also extracted into the new HRV structure. On the other hand,
all the analysis stored in the original structure will be lost.
</p>


<h3>Value</h3>

<p>A new <em>HRVData</em> structure containing the temporal data  
within the specified range.
</p>


<h3>Author(s)</h3>

<p>Leandro Rodriguez-Linares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
# Rename for convenience
HRVData &lt;- HRVProcessedData
PlotNIHR(HRVData)
newHRVData &lt;- ExtractTimeSegment(HRVData,2000,4000)
PlotNIHR(newHRVData)

## End(Not run)
</code></pre>

<hr>
<h2 id='FilterNIHR'> Artefact filter based in an adaptive threshold </h2><span id='topic+FilterNIHR'></span>

<h3>Description</h3>

<p>An algorithm that uses adaptive thresholds for rejecting those beats different from the given threshold more than a certain value. The rule for beat acceptation or rejection is to compare with previous, following and with the updated mean. We apply also a comparison with acceptable physiological values (default values 25 and 200 bpm). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterNIHR(HRVData, long=50, last=13, minbpm=25, maxbpm=200, mini=NULL, 
		maxi=NULL, fixed=NULL, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterNIHR_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="FilterNIHR_+3A_long">long</code></td>
<td>
<p> Number of beats to calculate the updated mean </p>
</td></tr>
<tr><td><code id="FilterNIHR_+3A_last">last</code></td>
<td>
<p> Initial threshold </p>
</td></tr>  
<tr><td><code id="FilterNIHR_+3A_minbpm">minbpm</code></td>
<td>
<p> Minimum physiologically acceptable value for HR </p>
</td></tr>  
<tr><td><code id="FilterNIHR_+3A_maxbpm">maxbpm</code></td>
<td>
<p> Maximum physiologically acceptable value for HR </p>
</td></tr>  
<tr><td><code id="FilterNIHR_+3A_mini">mini</code></td>
<td>
<p> Deprecated argument maintained for compatibility </p>
</td></tr>
<tr><td><code id="FilterNIHR_+3A_maxi">maxi</code></td>
<td>
<p> Deprecated argument maintained for compatibility </p>
</td></tr>
<tr><td><code id="FilterNIHR_+3A_fixed">fixed</code></td>
<td>
<p> Deprecated argument maintained for compatibility </p>
</td></tr>
<tr><td><code id="FilterNIHR_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, associated heart rate instantaneous values also, and now filtered heart rate signal
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>X. Vila, F. Palacios, J. Presedo, M. Fernandez-Delgado, P. Felix, S. Barro, &quot;Time-Frequency analysis of heart-rate variability,&quot; IEEE Eng. Med. Biol. Magazine 16, 119-125 (1997)
L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='GenerateEpisodes'> Creates new episodes from old ones </h2><span id='topic+GenerateEpisodes'></span>

<h3>Description</h3>

<p>Creates new episodes, or annotated physiological events, from existing ones and stores them into the data structure containing the beat positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateEpisodes(HRVData, NewBegFrom, NewEndFrom, DispBeg, DispEnd, 
		OldTag = "", NewTag = "", verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_newbegfrom">NewBegFrom</code></td>
<td>
<p> Source of new beginning of episodes (&quot;Beg&quot; for indicating the beginning as the beginning of the old episode, &quot;End&quot; for end)</p>
</td></tr> 
<tr><td><code id="GenerateEpisodes_+3A_newendfrom">NewEndFrom</code></td>
<td>
<p> Source of new end of episodes (&quot;Beg&quot; for indicating the end as the beginning of the old episode, &quot;End&quot; for end)</p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_dispbeg">DispBeg</code></td>
<td>
<p> Absolute displacement from the beginning for new episodes in seconds </p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_dispend">DispEnd</code></td>
<td>
<p> Absolute displacement from the end for new episodes in seconds </p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_oldtag">OldTag</code></td>
<td>
<p> Tag of old episodes </p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_newtag">NewTag</code></td>
<td>
<p> Tag for new episodes (if empty, copies OldTag) </p>
</td></tr>
<tr><td><code id="GenerateEpisodes_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and new episodes information
</p>


<h3>Note</h3>

<p>##Example of arguments for creating episodes displaced one <br />
minute before old ones:<br />
##NewBegFrom = &quot;Beg&quot;, NewEndFrom = &quot;End&quot;, DispBeg = -60, <br />
DispEnd = -60<br />
##Example of arguments for creating episodes just after previous<br />
ones of 1 minute length:<br />
##NewBegFrom = &quot;End&quot;, NewEndFrom = &quot;End&quot;, DispBeg = 0, <br />
DispEnd = 60<br />
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='getNormSpectralUnits'>Normalized Spectral Units</h2><span id='topic+getNormSpectralUnits'></span>

<h3>Description</h3>

<p>Calculates the spectrogram bands in normalized units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNormSpectralUnits(HRVData,
  indexFreqAnalysis = length(HRVData$FreqAnalysis), VLFnormalization = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNormSpectralUnits_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="getNormSpectralUnits_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>Reference to the data structure that contains the spectrogram analysis</p>
</td></tr>
<tr><td><code id="getNormSpectralUnits_+3A_vlfnormalization">VLFnormalization</code></td>
<td>
<p>Logical value. If TRUE (default), the function
normalizes LF and HF power series by its sum. If FALSE, the function computes
VLF, LF and HF power series  by its sum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour of this function computes the normalized power
time series in the LF and HF bands following the Task Force recommendations:
</p>
<p style="text-align: center;"><code class="reqn">normalized\_LF = LF\_power / (total\_power - VLF\_power - ULF\_power)</code>
</p>

<p style="text-align: center;"><code class="reqn">normalized\_HF = HF\_power / (total\_power - VLF\_power -ULF\_power)</code>
</p>

<p>If <em>VLFnormalization</em> is set to FALSE, the functions computes:
</p>
<p style="text-align: center;"><code class="reqn">normalized\_VLF = VLF\_power / (total\_power - ULF\_power)</code>
</p>

<p style="text-align: center;"><code class="reqn">normalized\_LF = LF\_power / (total\_power - ULF\_power)</code>
</p>

<p style="text-align: center;"><code class="reqn">normalized\_HF = HF\_power / (total\_power - ULF\_power)</code>
</p>

<p>The resulting time series are returned in a list. Note that before using this
function, the spectrogram should be computed with the <em>CalculatePowerBand</em>
function.
</p>


<h3>Value</h3>

<p>The <em>getNormSpectralUnits</em> returns a list storing the resulting
normalized power-band series. Note that this list is not stored in the 
<em>HRVData</em> structure.
</p>


<h3>References</h3>

<p>Camm, A. J., et al. &quot;Heart rate variability: standards of measurement, physiological interpretation and clinical use.
Task Force of the European Society of Cardiology and the North American Society of
Pacing and Electrophysiology.&quot; Circulation 93.5 (1996): 1043-1065.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load some data...
data(HRVProcessedData)
hd = HRVProcessedData
# Perform some spectral analysis and normalize the results
hd = CreateFreqAnalysis(hd)
hd = CalculatePowerBand(hd,indexFreqAnalysis = 1,shift=30,size=60)
normUnits = getNormSpectralUnits(hd)
# plot the normalized time series
par(mfrow=c(2,1))
plot(normUnits$Time, normUnits$LF, xlab="Time", ylab="normalized LF",
     main="normalized LF",type="l")
plot(normUnits$Time, normUnits$HF, xlab="Time", ylab="normalized HF",
     main="normalized HF",type="l")
par(mfrow=c(1,1))


## End(Not run)
</code></pre>

<hr>
<h2 id='HRVData'>HRVData</h2><span id='topic+HRVData'></span>

<h3>Description</h3>

<p>HRVData structure containing the occurrence times of the hearbeats of patient suffering from 
paraplegia and hypertension. The subject from whom the HR was obtained is a patient suffering
from paraplegia and hypertension (systolic blood pressure above 200 mmHg). During
the recording, he is supplied with prostaglandin E1 (a vasodilator that is rarely
employed) and systolic blood pressure fell to 100 mmHg for over an hour. Then, the
blood pressure was slowly recovering until 150 mmHg, more or less
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HRVData)</code></pre>


<h3>Format</h3>

<p>A HRVData structure containing the occurrence times of the heartbeats</p>


<h3>See Also</h3>

<p><a href="#topic+HRVProcessedData">HRVProcessedData</a></p>

<hr>
<h2 id='HRVProcessedData'>HRVProcessedData</h2><span id='topic+HRVProcessedData'></span>

<h3>Description</h3>

<p>HRV data containing the heart rhythm of patient suffering from 
paraplegia and hypertension. The subject from whom the HR was obtained is a patient suffering
from paraplegia and hypertension (systolic blood pressure above 200 mmHg). During
the recording, he is supplied with prostaglandin E1 (a vasodilator that is rarely
employed) and systolic blood pressure fell to 100 mmHg for over an hour. Then, the
blood pressure was slowly recovering until 150 mmHg, more or less</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HRVProcessedData)</code></pre>


<h3>Format</h3>

<p>A HRVData structure containing the interpolated and filtered HR series</p>


<h3>See Also</h3>

<p><a href="#topic+HRVData">HRVData</a></p>

<hr>
<h2 id='IntegralCorrelation'> Calculates the Integral Correlation </h2><span id='topic+IntegralCorrelation'></span>

<h3>Description</h3>

<p>WARNING: <b>deprecated</b> function.
The Integral correlation is calculated for every vector of the m-dimensional space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegralCorrelation(HRVData, Data, m, tau, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegralCorrelation_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="IntegralCorrelation_+3A_data">Data</code></td>
<td>
<p> Portion of HRVData to be analyzed </p>
</td></tr>
<tr><td><code id="IntegralCorrelation_+3A_m">m</code></td>
<td>
<p> Value of the dimension of the expansion of data </p>
</td></tr>
<tr><td><code id="IntegralCorrelation_+3A_tau">tau</code></td>
<td>
<p> Delay of the expansion of data </p>
</td></tr>
<tr><td><code id="IntegralCorrelation_+3A_r">r</code></td>
<td>
<p> Distance for calculating correlation </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the average of IntegralCorrelations
</p>


<h3>Note</h3>

<p>This function is used in the <code><a href="#topic+CalculateApEn">CalculateApEn</a></code> function, which is
<b>deprecated</b>. We suggest the use of the <code><a href="#topic+CalculateSampleEntropy">CalculateSampleEntropy</a></code>
function instead of <code><a href="#topic+CalculateApEn">CalculateApEn</a></code>.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+BuildTakensVector">BuildTakensVector</a></code>  </p>

<hr>
<h2 id='InterpolateNIHR'> Linear or Spline interpolator for build the sample heart rate signal </h2><span id='topic+InterpolateNIHR'></span>

<h3>Description</h3>

<p>An algorithm to obtain a heart rate signal with equally spaced values at a certain sampling frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InterpolateNIHR(HRVData, freqhr = 4, method = c("linear", "spline"), verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InterpolateNIHR_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="InterpolateNIHR_+3A_freqhr">freqhr</code></td>
<td>
<p> Sampling frequency </p>
</td></tr>
<tr><td><code id="InterpolateNIHR_+3A_method">method</code></td>
<td>
<p> &quot;linear&quot; interpolation or &quot;spline&quot; monotone interpolation </p>
</td></tr>
<tr><td><code id="InterpolateNIHR_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register, associated heart rate instantaneous values also, and filtered heart rate signal equally spaced
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='ListEpisodes'> Episodes listing </h2><span id='topic+ListEpisodes'></span>

<h3>Description</h3>

<p>Lists episodes included in a RHRV record
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ListEpisodes(HRVData, TimeHMS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ListEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="ListEpisodes_+3A_timehms">TimeHMS</code></td>
<td>
<p> Boolean argument to print times in H:M:S format </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadApneaWFDB'> Loads apnea episodes for WFDB record </h2><span id='topic+LoadApneaWFDB'></span>

<h3>Description</h3>

<p>Loads the information of apnea episodes and stores it into the data structure containing the beat positions and other related information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadApneaWFDB(HRVData, RecordName, RecordPath = ".", Tag = "APNEA", 
		verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadApneaWFDB_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadApneaWFDB_+3A_recordname">RecordName</code></td>
<td>
<p> The WFDB file to be used </p>
</td></tr>
<tr><td><code id="LoadApneaWFDB_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the WFDB file </p>
</td></tr>
<tr><td><code id="LoadApneaWFDB_+3A_tag">Tag</code></td>
<td>
<p> to include APNEA episodes </p>
</td></tr>
<tr><td><code id="LoadApneaWFDB_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and other related information and apnea episodes information
</p>


<h3>Note</h3>

<p>An example including all the steps to download a record from Physionet and load its content and the Apnea annotations is included below:<br /><br />
dirorig &lt;-  &quot;http://www.physionet.org/physiobank/database/apnea-ecg/&quot;<br />
files &lt;- c(&quot;a01.hea&quot;, &quot;a01.apn&quot;, &quot;a01.qrs&quot;)<br />
filesorig &lt;- paste(dirorig, files, sep = &quot;&quot;)<br />
for (i in 1:length(files))<br />
download.file(filesorig[i], files[i])<br />
hrv.data &lt;- CreateHRVData()<br />
hrv.data &lt;- LoadBeatWFDB(hrv.data, &quot;a01&quot;)<br />
hrv.data &lt;- LoadApneaWFDB(hrv.data, &quot;a01&quot;)<br />
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadBeat'> Builds an array of beats positions from different type of files </h2><span id='topic+LoadBeat'></span>

<h3>Description</h3>

<p>Reads the specific file with data of beat positions and stores the values in a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeat(fileType, HRVData, Recordname, RecordPath = ".", 
		annotator = "qrs", scale = 1, datetime = "1/1/1900 0:0:0", 
		annotationType = "QRS", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeat_+3A_filetype">fileType</code></td>
<td>
<p> The format of the file to be used: WFDB, Ascii, RR, Polar, Suunto, EDFPlus, Ambit </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_recordname">Recordname</code></td>
<td>
<p> The file to be used </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_annotator">annotator</code></td>
<td>
<p> The extension of the file, only if we are working with a WFDB file </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_scale">scale</code></td>
<td>
<p> 1 if beat positions in seconds or 0.001 if beat positions in milliseconds, only if we are working with a RR or an Ascii file </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_datetime">datetime</code></td>
<td>
<p> Date and time (DD/MM/YYYY HH:MM:SS), only if we are working with a RR or an Ascii file </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_annotationtype">annotationType</code></td>
<td>
<p> The type of annotation wished, only if we are working with an EDF+ file </p>
</td></tr>
<tr><td><code id="LoadBeat_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='LoadBeatAmbit'> Imports data from a record in Suunto Ambit XML format </h2><span id='topic+LoadBeatAmbit'></span>

<h3>Description</h3>

<p>Reads a Suunto Ambit XML file with data of beat positions and stores the values in a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatAmbit(HRVData, RecordName, RecordPath = ".", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatAmbit_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatAmbit_+3A_recordname">RecordName</code></td>
<td>
<p> The Suunto Ambit XML file to be read </p>
</td></tr>
<tr><td><code id="LoadBeatAmbit_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatAmbit_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>Matti Lassila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, X. Vila, A. Mendez, M. Lado, D. Olivieri, &quot;RHRV: An R-based software package for heart rate variability analysis of ECG recordings,&quot; 3rd Iberian Conference in Systems and Information Technologies (CISTI 2008), Proceedings I, 565-573, ISBN: 978-84-612-4476-8 (2008)
</p>

<hr>
<h2 id='LoadBeatAscii'> Builds an array of beats positions from an ascii file </h2><span id='topic+LoadBeatAscii'></span>

<h3>Description</h3>

<p>Reads an ascii file with data of beat positions and stores the values in a data structure. A segment of a file can be loaded making use of the &quot;starttime&quot; and &quot;endtime&quot; arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LoadBeatAscii(HRVData, RecordName, RecordPath=".", scale = 1, starttime=NULL,
      endtime=NULL, datetime = "1/1/1900 0:0:0", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatAscii_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_recordname">RecordName</code></td>
<td>
<p>Ascii file containing the beats to be loaded </p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_scale">scale</code></td>
<td>
<p> 1 if beat positions in seconds or 0.001 if beat positions in milliseconds </p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_starttime">starttime</code></td>
<td>
<p>Beginning of the segment of file to load</p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_endtime">endtime</code></td>
<td>
<p>End of the segment of file to load</p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_datetime">datetime</code></td>
<td>
<p> Date and time (DD/MM/YYYY HH:MM:SS) </p>
</td></tr>
<tr><td><code id="LoadBeatAscii_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Loads beats positions into the structure that contains RHRV information. The
file containing the heartbeats positions must be a single column file with
no headers. Each line should denote the occurrence time of each heartbeat. An
example of a valid file could be the following:<br />
<em>0</em><br />
<em>0.3280001</em><br />
<em>0.7159996</em><br />
<em>1.124</em><br />
<em>1.5</em><br />
<em>1.88</em><br />
(...)
</p>


<h3>Author(s)</h3>

<p>A. Mendez, L. Rodriguez, A. Otero, C.A. Garcia, X. Vila, M. Lado
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='LoadBeatEDFPlus'> Imports data from a record in EDF+ format </h2><span id='topic+LoadBeatEDFPlus'></span>

<h3>Description</h3>

<p>Basically, this algorithm reads the annotation file for the ECG register, and stores the information obtained in a data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatEDFPlus(HRVData, RecordName, RecordPath = ".", 
		annotationType ="QRS", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatEDFPlus_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatEDFPlus_+3A_recordname">RecordName</code></td>
<td>
<p> The EDF+ file to be used </p>
</td></tr>
<tr><td><code id="LoadBeatEDFPlus_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatEDFPlus_+3A_annotationtype">annotationType</code></td>
<td>
<p> The type of annotation wished </p>
</td></tr>
<tr><td><code id="LoadBeatEDFPlus_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='LoadBeatPolar'> Imports data from a record in Polar format </h2><span id='topic+LoadBeatPolar'></span>

<h3>Description</h3>

<p>Reads a Polar file with data of beat positions and stores the values in a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatPolar(HRVData, RecordName, RecordPath=".", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatPolar_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatPolar_+3A_recordname">RecordName</code></td>
<td>
<p> The Polar file to be used </p>
</td></tr>
<tr><td><code id="LoadBeatPolar_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatPolar_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadBeatRR'> Builds an array of beats positions from an ascii file </h2><span id='topic+LoadBeatRR'></span>

<h3>Description</h3>

<p>Reads an ascii file containing RR values, i.e. distances between two successive beats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LoadBeatRR(HRVData, RecordName, RecordPath=".", scale = 1, 
		  datetime = "1/1/1900 0:0:0", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatRR_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatRR_+3A_recordname">RecordName</code></td>
<td>
<p> The Ascii file to be used </p>
</td></tr>
<tr><td><code id="LoadBeatRR_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatRR_+3A_scale">scale</code></td>
<td>
<p> 1 if beat positions in seconds or 0.001 if beat positions in milliseconds </p>
</td></tr>
<tr><td><code id="LoadBeatRR_+3A_datetime">datetime</code></td>
<td>
<p> Date and time (DD/MM/YYYY HH:MM:SS) </p>
</td></tr>
<tr><td><code id="LoadBeatRR_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='LoadBeatSuunto'> Imports data from a record in Suunto format </h2><span id='topic+LoadBeatSuunto'></span>

<h3>Description</h3>

<p>Reads a Suunto file with data of beat positions and stores the values in a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatSuunto(HRVData, RecordName, RecordPath = ".", verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatSuunto_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatSuunto_+3A_recordname">RecordName</code></td>
<td>
<p> The Suunto file to be read </p>
</td></tr>
<tr><td><code id="LoadBeatSuunto_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatSuunto_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadBeatVector'>Loads beats positions from an R vector</h2><span id='topic+LoadBeatVector'></span>

<h3>Description</h3>

<p>Stores the beat positions from an R vector under the
<em>HRVData</em> data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatVector(HRVData, beatPositions, scale = 1,
  datetime = "1/1/1900 0:0:0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatVector_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats recording and information 
related to it</p>
</td></tr>
<tr><td><code id="LoadBeatVector_+3A_beatpositions">beatPositions</code></td>
<td>
<p>Numeric vector with the heartbeats occurrence's times since
the beginning of the recording. See <em>scale</em> parameter to specify the 
units</p>
</td></tr>
<tr><td><code id="LoadBeatVector_+3A_scale">scale</code></td>
<td>
<p>Numeric value identifying the temporal units in which
the beat positions are specified: 1 if beat positions is specified in seconds, 
0.001 if beat positions in milliseconds, etc.</p>
</td></tr>
<tr><td><code id="LoadBeatVector_+3A_datetime">datetime</code></td>
<td>
<p>Date and time (DD/MM/YYYY HH:MM:SS) of the beginning of the
recording</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>HRVData</em> structure containing the heartbeat positions
from the <em>beatPositions</em> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hd = CreateHRVData()
hd = LoadBeatVector(hd, 
     c(0.000, 0.328, 0.715, 0.124, 1.50,1.880, 2.268, 2.656))
hd = BuildNIHR(hd)
# ... continue analyzing the recording

## End(Not run)
</code></pre>

<hr>
<h2 id='LoadBeatWFDB'> Imports data from a record in WFDB format </h2><span id='topic+LoadBeatWFDB'></span>

<h3>Description</h3>

<p>Basically, this algorithm reads the annotation file for the ECG register, and stores the information obtained in a data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadBeatWFDB(HRVData, RecordName, RecordPath = ".", annotator = "qrs", 
		verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadBeatWFDB_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadBeatWFDB_+3A_recordname">RecordName</code></td>
<td>
<p> The WFDB file to be used </p>
</td></tr>
<tr><td><code id="LoadBeatWFDB_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadBeatWFDB_+3A_annotator">annotator</code></td>
<td>
<p> The extension of the file </p>
</td></tr>
<tr><td><code id="LoadBeatWFDB_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register
</p>


<h3>Author(s)</h3>

<p>I. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadEpisodesAscii'> Loads episodes file </h2><span id='topic+LoadEpisodesAscii'></span>

<h3>Description</h3>

<p>Loads the information of episodes, or annotated physiological events, and stores it into the data structure containing the beat positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadEpisodesAscii(HRVData, FileName, RecordPath=".", Tag="", InitTime="0:0:0",
verbose=NULL,header = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadEpisodesAscii_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadEpisodesAscii_+3A_filename">FileName</code></td>
<td>
<p> The episodes file to be used </p>
</td></tr>
<tr><td><code id="LoadEpisodesAscii_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the file </p>
</td></tr>
<tr><td><code id="LoadEpisodesAscii_+3A_tag">Tag</code></td>
<td>
<p> Type of episode </p>
</td></tr>  
<tr><td><code id="LoadEpisodesAscii_+3A_inittime">InitTime</code></td>
<td>
<p> Time (HH:MM:SS) </p>
</td></tr>
<tr><td><code id="LoadEpisodesAscii_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
<tr><td><code id="LoadEpisodesAscii_+3A_header">header</code></td>
<td>
<p>Logical value. If TRUE, then the first line of the file is skipped. Default: TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and episodes information
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='LoadHeaderWFDB'> Imports header information from a record in wfdb format </h2><span id='topic+LoadHeaderWFDB'></span>

<h3>Description</h3>

<p>Reads the header file for the ECG register, and stores the information obtained in a data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoadHeaderWFDB(HRVData, RecordName, RecordPath = ".", verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LoadHeaderWFDB_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="LoadHeaderWFDB_+3A_recordname">RecordName</code></td>
<td>
<p> The ECG file to be used </p>
</td></tr>
<tr><td><code id="LoadHeaderWFDB_+3A_recordpath">RecordPath</code></td>
<td>
<p> The path of the ECG file </p>
</td></tr>
<tr><td><code id="LoadHeaderWFDB_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Data, the structure that contains beat positions register and data extracted from header file
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='ModifyEpisodes'> Modifies values of episodes</h2><span id='topic+ModifyEpisodes'></span>

<h3>Description</h3>

<p>This function allow users to modify the parameters that define episodes: Tags, InitTimes, Durations and Values.
</p>
<p>Episodes can be selected by Tags or Indexes (or both) and more than one episodes' characteristics can be modified within the same call.
</p>
<p>When modifying more than one episode, vectors of new parameters are recycled.
</p>
<p>After the modification has been made, duplicate episodes are removed and they are reordered by increasing InitTimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModifyEpisodes(HRVData, Tags=NULL, Indexes=NULL, NewInitTimes=NULL,
NewTags=NULL, NewDurations=NULL ,NewValues=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ModifyEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_tags">Tags</code></td>
<td>
<p> Vector containing types of episodes to remove </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_indexes">Indexes</code></td>
<td>
<p> Vector containing indexes of episodes to remove (see ListEpisodes()) </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_newinittimes">NewInitTimes</code></td>
<td>
<p> Vector containing new init times in seconds </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_newtags">NewTags</code></td>
<td>
<p> Vector containing new tags for episodes </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_newdurations">NewDurations</code></td>
<td>
<p> Vector containing new durations in seconds </p>
</td></tr>
<tr><td><code id="ModifyEpisodes_+3A_newvalues">NewValues</code></td>
<td>
<p> Vector containing new numerical values for episodes </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that contains beat positions register and new episodes information
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='NonlinearityTests'>Nonlinearity tests</h2><span id='topic+NonlinearityTests'></span>

<h3>Description</h3>

<p>Nonlinearity tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonlinearityTests(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonlinearityTests_+3A_hrvdata">HRVData</code></td>
<td>
<p>Structure containing the RR time series.</p>
</td></tr>
<tr><td><code id="NonlinearityTests_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs a set of nonlinearity tests on the RR time series 
implemented in other R packages including:
</p>

<ul>
<li><p> Teraesvirta's neural metwork test for nonlinearity (<code><a href="tseries.html#topic+terasvirta.test">terasvirta.test</a></code>).
</p>
</li>
<li><p> White neural metwork test for nonlinearity (<code><a href="tseries.html#topic+white.test">white.test</a></code>).
</p>
</li>
<li><p> Keenan's one-degree test for nonlinearity (<code><a href="TSA.html#topic+Keenan.test">Keenan.test</a></code>).
</p>
</li>
<li><p> Perform the McLeod-Li test for conditional heteroscedascity (ARCH). (<code><a href="TSA.html#topic+McLeod.Li.test">McLeod.Li.test</a></code>).
</p>
</li>
<li><p> Perform the Tsay's test for quadratic nonlinearity in a time series. (<code><a href="TSA.html#topic+Tsay.test">Tsay.test</a></code>).
</p>
</li>
<li><p> Perform the Likelihood ratio test for threshold nonlinearity. (<code><a href="TSA.html#topic+tlrt">tlrt</a></code>).
</p>
</li></ul>



<h3>Value</h3>

<p>A <em>HRVData</em> structure containing a <em>NonlinearityTests</em> field storing the results of each of the tests. 
The <em>NonlinearityTests</em> list is stored under the <em>NonLinearAnalysis</em> structure.
</p>

<hr>
<h2 id='NonLinearNoiseReduction'>Nonlinear noise reduction</h2><span id='topic+NonLinearNoiseReduction'></span>

<h3>Description</h3>

<p>Function for denoising the RR time series using nonlinear analysis techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonLinearNoiseReduction(HRVData, embeddingDim = NULL, radius = NULL,
  ECGsamplingFreq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NonLinearNoiseReduction_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information
related to it</p>
</td></tr>
<tr><td><code id="NonLinearNoiseReduction_+3A_embeddingdim">embeddingDim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed 
the RR time series.</p>
</td></tr>
<tr><td><code id="NonLinearNoiseReduction_+3A_radius">radius</code></td>
<td>
<p>The radius used to looking for neighbours in the phase space 
(see details). If the radius is not specified, a radius depending on the 
resolution of the RR time series is used. The resolution depends
on the <em>ECGsamplingFreq</em> parameter. When selecting
the radius it must be taken into account that the RR series is specified in
milliseconds.</p>
</td></tr>
<tr><td><code id="NonLinearNoiseReduction_+3A_ecgsamplingfreq">ECGsamplingFreq</code></td>
<td>
<p>The sampling frequency of the ECG from which the RR
time series was derived. Although it is not necessary, if it is provided it
may improve the noise reduction. If the <em>ECGsamplingFreq</em> is 
not supplied, the sampling frequency is derived from the RR data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the RR time series and denoises it. The denoising
is achieved by averaging each Takens' vector in an m-dimensional space
with his neighbours (time lag=1). Each neighbourhood is specified with balls
of a given radius
(max norm is used).
</p>


<h3>Value</h3>

<p>A HRVData structure containing the denoised RR time series.
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+nonLinearNoiseReduction">nonLinearNoiseReduction</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis (Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+nonLinearNoiseReduction">nonLinearNoiseReduction</a></code>
</p>

<hr>
<h2 id='OverplotEpisodes'>OverplotEpisodes</h2><span id='topic+OverplotEpisodes'></span>

<h3>Description</h3>

<p>Add episodic information to the current plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverplotEpisodes(HRVData, Tags = NULL, Indexes = NULL,
  epColorPalette = NULL, eplim, lty = 2, markEpisodes = T, ymark,
  showEpLegend = T, epLegendCoords = NULL, Tag = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OverplotEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as apnoea or oxygen 
desaturation, are included in the plot. <em>Tags</em>=&quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes of episodes (see <code><a href="#topic+ListEpisodes">ListEpisodes</a></code>)
to specify which episodes are included in the plot. 
<em>Indexes</em>=&quot;all&quot; plots all episodes present in the data.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_epcolorpalette">epColorPalette</code></td>
<td>
<p>Vector specifying the color of each of the episodes that
will be plotted. The length of epColorPalette should be equal or greater than
the number of different episodes to be plotted.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_eplim">eplim</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for the 
vertical lines limiting each episode.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_lty">lty</code></td>
<td>
<p>The line type for the vertical lines limiting each episode.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_markepisodes">markEpisodes</code></td>
<td>
<p>Boolean specyfing if a horizontal mark should be included
for each of the episodes.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_ymark">ymark</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for
the horizontal marks. Only used if markEpisodes = TRUE.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_showeplegend">showEpLegend</code></td>
<td>
<p>Boolean argument. If TRUE, a legend of the episodes is 
included.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_eplegendcoords">epLegendCoords</code></td>
<td>
<p>Two-component vector specifiying the coordinates where
the legend should be placed. By defaul, the legend is placed on top of 
the plot.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument maintained for
compatibility, use Tags instead.</p>
</td></tr>
<tr><td><code id="OverplotEpisodes_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for the vertical lines limiting each
episode. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Read file "a03" from the physionet apnea-ecg database
library(RHRV)
HRVData &lt;- CreateHRVData()
HRVData &lt;- LoadBeatWFDB(HRVData,RecordName="test_files/WFDB/a03")
HRVData &lt;- LoadApneaWFDB(HRVData,RecordName="test_files/WFDB/a03")
# Add other type of episode for a more complete example (this episode does
# not have any physiological meaning)
HRVData &lt;- AddEpisodes(HRVData,InitTimes=c(4500),Durations=c(1000), 
                       Tags="Other", Values = 1)
HRVData &lt;- BuildNIHR(HRVData)
HRVData &lt;- FilterNIHR(HRVData)
HRVData &lt;- InterpolateNIHR(HRVData)


PlotHR(HRVData)
OverplotEpisodes(HRVData,ymark=c(150,151),eplim=c(20,150))

# Change some default parameters
PlotHR(HRVData)
OverplotEpisodes(HRVData,ymark=c(150,151),eplim=c(20,150),
                 epLegendCoords=c(25000,150), lty=5, 
                 epColorPalette=c("blue","green"))
                 
# Use episodic information with the spectrogram... In order to obtain a proper
# representation of the episodes we need to avoid the use of the spectrogram
# legend
sp &lt;- PlotSpectrogram(HRVData, size=600, shift=60, freqRange=c(0,0.05),
                      showLegend=F);
OverplotEpisodes(HRVData, markEpisodes=T, ymark=c(0.04,0.0401),
                 eplim=c(0,0.04), Tags="APNEA",
                 epColorPalette = c("white"), lwd=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotHR'>Simple plot of interpolated heart rate</h2><span id='topic+PlotHR'></span>

<h3>Description</h3>

<p>Plots in a simple way the interpolated instantaneous heart
rate signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotHR(HRVData, Tags = NULL, Indexes = NULL,
  main = "Interpolated instantaneous heart rate", xlab = "time (sec.)",
  ylab = "HR (beats/min.)", type = "l", ylim = NULL, Tag = NULL,
  verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotHR_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as apnoea or oxygen 
desaturation, are included in the plot. <em>Tags</em>=&quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes of episodes (see <code><a href="#topic+ListEpisodes">ListEpisodes</a></code>)
to specify which episodes are included in the plot. 
<em>Indexes</em>=&quot;all&quot; plots all episodes present in the data.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument maintained for
compatibility, use <em>Tags</em> instead.</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated argument maintained for compatibility, 
use SetVerbose() instead</p>
</td></tr>
<tr><td><code id="PlotHR_+3A_...">...</code></td>
<td>
<p>Other graphical parameters. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PlotHR
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila, C.A. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri,
X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate
variability spectral analysis&quot;, Computer Methods and Programs in
Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='PlotNIHR'>Simple plot of non-interpolated heart rate</h2><span id='topic+PlotNIHR'></span>

<h3>Description</h3>

<p>Plots in a simple way the non-interpolated instantaneous heart
rate signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotNIHR(HRVData, Tags = NULL, Indexes = NULL,
  main = "Non-interpolated instantaneous heart rate", xlab = "time (sec.)",
  ylab = "HR (beats/min.)", type = "l", ylim = NULL, Tag = NULL,
  verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotNIHR_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information
related to it</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as apnoea or oxygen 
desaturation, are included in the plot. <em>Tags</em>=&quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes to specify which episodes (see ListEpisodes),
are included in the plot. Indexes=&quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument maintained for
compatibility, use <em>Tags</em> instead.</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated argument maintained for compatibility, 
use SetVerbose() instead</p>
</td></tr>
<tr><td><code id="PlotNIHR_+3A_...">...</code></td>
<td>
<p>Other graphical parameters. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PlotNIHR
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila, C.A. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri,
X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate
variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 
103(1):39-50, july 2011.
</p>

<hr>
<h2 id='PlotPowerBand'>Plots power determined by CalculatePowerBand function</h2><span id='topic+PlotPowerBand'></span>

<h3>Description</h3>

<p>Plots the power of the heart rate signal at different bands 
of physiological interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPowerBand(HRVData, indexFreqAnalysis = length(HRVData$FreqAnalysis),
  normalized = FALSE, hr = FALSE, ymax = NULL, ymaxratio = NULL,
  ymaxnorm = 1, Tags = NULL, Indexes = NULL, Tag = NULL,
  verbose = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPowerBand_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and 
information related to it</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>Numeric parameter used to reference a particular
frequency analysis</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_normalized">normalized</code></td>
<td>
<p>Plots normalized powers if TRUE</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_hr">hr</code></td>
<td>
<p>Plots heart rate signal if TRUE</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value for y axis (unnormalized plots)</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_ymaxratio">ymaxratio</code></td>
<td>
<p>Maximum value for y axis in LF/HF band (normalized and 
unnormalized plots)</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_ymaxnorm">ymaxnorm</code></td>
<td>
<p>Maximum value for y axis (normalized plots)</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as apnoea or oxygen 
desaturation, are included in the plot. Tags = &quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes to specify which episodes (see ListEpisodes),
are included in the plot. Indexes = &quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument, use Tags instead</p>
</td></tr>
<tr><td><code id="PlotPowerBand_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated argument maintained for compatibility, use 
setVerbose() instead</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PlotPowerBand
</p>


<h3>Note</h3>

<p>See <code><a href="#topic+PlotSinglePowerBand">PlotSinglePowerBand</a></code> for  a more flexible 
function for plotting power bands.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri,
X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate 
variability spectral analysis&quot;, Computer Methods and Programs in 
Biomedicine 103(1):39-50, july 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculatePowerBand">CalculatePowerBand</a></code> for power calculation
and <code><a href="#topic+PlotSinglePowerBand">PlotSinglePowerBand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Reading a wfdb register and storing into a data structure:
md = CreateHRVData(Verbose = TRUE)
md = LoadBeatWFDB(md, RecordName = "register_name", 
                  RecordPath = "register_path")

# Calculating heart rate signal:md = BuildNIHR(md)

# Filtering heart rate signal:
md = FilterNIHR(md)
# Interpolating heart rate signal:
md = InterpolateNIHR(md)
# Calculating spectrogram and power per band:
md = CreateFreqAnalysis(md)
md = CalculatePowerBand(md, indexFreqAnalysis = 1, size = 120, 
                        shift = 10, sizesp = 1024)
# Plotting Power per Band
PlotPowerBand(md, hr = TRUE, ymax = 700000, ymaxratio = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotPSD'>Plot Spectral Density Estimation</h2><span id='topic+PlotPSD'></span>

<h3>Description</h3>

<p>Plot the PSD estimate of the RR time series distinguishing
the different frequency bands with different colurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPSD(HRVData, indexFreqAnalysis = length(HRVData$FreqAnalysis),
  ULFmin = 0, ULFmax = 0.03, VLFmin = 0.03, VLFmax = 0.05,
  LFmin = 0.05, LFmax = 0.15, HFmin = 0.15, HFmax = 0.4, log = "y",
  type = "l", xlab = "Frequency (Hz) ", ylab = "Spectrum", main = NULL,
  xlim = c(min(ULFmin, ULFmax, VLFmin, VLFmax, LFmin, LFmax, HFmin, HFmax),
  max(ULFmin, ULFmax, VLFmin, VLFmax, LFmin, LFmax, HFmin, HFmax)),
  ylim = NULL, addLegend = TRUE, addSigLevel = TRUE,
  usePalette = c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotPSD_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>An integer referencing the data structure that contains 
the PSD analysis.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_ulfmin">ULFmin</code></td>
<td>
<p>Lower limit ULF band used for distinguish the ULF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_ulfmax">ULFmax</code></td>
<td>
<p>Upper limit ULF band used for distinguish the ULF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_vlfmin">VLFmin</code></td>
<td>
<p>Lower limit VLF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_vlfmax">VLFmax</code></td>
<td>
<p>Upper limit VLF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_lfmin">LFmin</code></td>
<td>
<p>Lower limit LF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_lfmax">LFmax</code></td>
<td>
<p>Upper limit LF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_hfmin">HFmin</code></td>
<td>
<p>Lower limit HF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_hfmax">HFmax</code></td>
<td>
<p>Upper limit HF band.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_log">log</code></td>
<td>
<p>a character string which contains &quot;x&quot; if the x axis is to be
logarithmic,  &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if 
both axes are to be logarithmic. Default: &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_main">main</code></td>
<td>
<p>a main title for the plot. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_addlegend">addLegend</code></td>
<td>
<p>add a simple legend? Default: True.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_addsiglevel">addSigLevel</code></td>
<td>
<p>Logical value (only used with the lomb method). If true an
horizontal line limiting the significance level is included ( Powers &gt;
sig.level can be considered significant peaks). See <code><a href="lomb.html#topic+lsp">lsp</a></code>.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_usepalette">usePalette</code></td>
<td>
<p>A new palette of colors for plotting the frequency bands.</p>
</td></tr>
<tr><td><code id="PlotPSD_+3A_...">...</code></td>
<td>
<p>graphical parameters. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="lomb.html#topic+lsp">lsp</a></code>, <code><a href="#topic+CalculatePSD">CalculatePSD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVData)
HRVData=BuildNIHR(HRVData)
HRVData=FilterNIHR(HRVData)
# Frequency analysis requires interpolated data (except Lomb)
HRVData=InterpolateNIHR(HRVData)
# Create a different freqAnalysis for each method
HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,1,"pgram",doPlot = F)

HRVData=CalculatePSD(HRVData,2,"pgram",spans=9,doPlot = F)

HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,3,"ar",doPlot = F)

HRVData=CreateFreqAnalysis(HRVData)
HRVData=CalculatePSD(HRVData,4,"lomb",doPlot = F)
# Plot the results
layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE))
PlotPSD(HRVData,1)
PlotPSD(HRVData,2)
PlotPSD(HRVData,3)
PlotPSD(HRVData,4)

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotSinglePowerBand'>PlotSinglePowerBand</h2><span id='topic+PlotSinglePowerBand'></span>

<h3>Description</h3>

<p>Plots a concrete power band computed by the CalculatePowerBand 
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSinglePowerBand(HRVData, indexFreqAnalysis = length(HRVData$FreqAnalysis),
  band = c("LF", "HF", "ULF", "VLF", "LF/HF"), normalized = FALSE,
  main = paste(band, "Power Band"), xlab = "Time",
  ylab = paste("Power in", band), type = "l", Tags = NULL,
  Indexes = NULL, eplim = NULL, epColorPalette = NULL,
  markEpisodes = TRUE, ymark = NULL, showEpLegend = TRUE,
  epLegendCoords = NULL, Tag = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSinglePowerBand_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and 
information related to it</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p>Numeric parameter used to reference a particular
frequency analysis</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_band">band</code></td>
<td>
<p>The frequency band to be plotted. Allowd bands are &quot;ULF&quot;, &quot;VLF&quot;, &quot;LF&quot; 
(default), &quot;HF&quot; and &quot;LF/HF&quot;)</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_normalized">normalized</code></td>
<td>
<p>Plots normalized powers if TRUE</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y axis</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as
apnoea or oxygen desaturation, are included in the plot.
<em>Tags</em>=&quot;all&quot; plots all episodes present in the data.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes of episodes (see <code><a href="#topic+ListEpisodes">ListEpisodes</a></code>)
to specify which episodes are included in the plot. 
<em>Indexes</em>=&quot;all&quot; plots all episodes present in the data.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_eplim">eplim</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for the
vertical lines limiting each episode.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_epcolorpalette">epColorPalette</code></td>
<td>
<p>Vector specifying the color of each of the episodes that 
will be plotted. The length of colorPalette should be equal or greater than 
the number of different episodes to be plotted.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_markepisodes">markEpisodes</code></td>
<td>
<p>Boolean specyfing if a horizontal mark should be included 
for each of the episodes.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_ymark">ymark</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for the
horizontal marks. Only used if markEpisodes = TRUE.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_showeplegend">showEpLegend</code></td>
<td>
<p>Boolean argument. If TRUE, a legend of the episodes is 
included.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_eplegendcoords">epLegendCoords</code></td>
<td>
<p>Two-component vector specifiying the coordinates where
the legend should be placed. By defaul, the legend is placed on top of the
plot.</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument maintained for
compatibility, use Tags instead</p>
</td></tr>
<tr><td><code id="PlotSinglePowerBand_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for plotting the power band. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CalculatePowerBand">CalculatePowerBand</a></code> for power calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Read file "a03" from the physionet apnea-ecg database
library(RHRV)
HRVData &lt;- CreateHRVData()
HRVData &lt;- LoadBeatWFDB(HRVData,RecordName="test_files/WFDB/a03")
HRVData &lt;- LoadApneaWFDB(HRVData,RecordName="test_files/WFDB/a03")
# Calculating heart rate signal:
HRVData &lt;- BuildNIHR(HRVData)
 
# Filtering heart rate signal:
HRVData &lt;- FilterNIHR(HRVData)

# Interpolating heart rate signal:
HRVData = InterpolateNIHR(HRVData)

HRVData = CreateFreqAnalysis(HRVData)
HRVData = CalculatePowerBand(HRVData, indexFreqAnalysis = 1,
          size = 300, shift = 60, sizesp = 1024)
          
layout(matrix(1:4, nrow = 2))
PlotSinglePowerBand(HRVData, 1, "VLF", Tags = "APNEA", epColorPalette = "red",
                    epLegendCoords = c(2000,7500))
PlotSinglePowerBand(HRVData, 1, "LF", Tags = "APNEA", epColorPalette = "red",
                    eplim = c(0,6000),
                    markEpisodes = F, showEpLegend = FALSE)
PlotSinglePowerBand(HRVData, 1, "HF", Tags = "APNEA", epColorPalette = "red",
                    epLegendCoords = c(2000,1700))
PlotSinglePowerBand(HRVData, 1, "LF/HF", Tags = "APNEA", epColorPalette = "red",
                    eplim = c(0,20),
                    markEpisodes = F, showEpLegend = FALSE)
# Reset layout
par(mfrow = c(1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='PlotSpectrogram'>Calculates and Plots spectrogram</h2><span id='topic+PlotSpectrogram'></span>

<h3>Description</h3>

<p>Plots spectrogram of the heart rate signal as calculated by
CalculateSpectrogram() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSpectrogram(HRVData, size, shift, sizesp = NULL, freqRange = NULL,
  scale = "linear", verbose = NULL, showLegend = TRUE, Tags = NULL,
  Indexes = NULL, eplim = NULL, epColorPalette = NULL,
  markEpisodes = TRUE, ymark = NULL, showEpLegend = TRUE,
  epLegendCoords = NULL, main = "Spectrogram of the HR  series",
  xlab = "Time (sec.)", ylab = "Frequency (Hz.)", ylim = freqRange,
  Tag = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSpectrogram_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information
related to it</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_size">size</code></td>
<td>
<p>Size of window for calculating spectrogram (seconds)</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_shift">shift</code></td>
<td>
<p>Displacement of window for calculating spectrogram (seconds)</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_sizesp">sizesp</code></td>
<td>
<p>Points for calculation (zero padding). If the user does not 
specify it, the function estimates a propper value.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_freqrange">freqRange</code></td>
<td>
<p>Vector with two components specifying the frequency range 
that the program should plot. If the user does not specify it, the function 
uses the whole frequency range. It is possible to specify the frequency range
using the ylim parameter.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_scale">scale</code></td>
<td>
<p>Scale used to plot spectrogram, linear or logarithmic</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_verbose">verbose</code></td>
<td>
<p>Deprecated argument maintained for compatibility, 
use SetVerbose() instead</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_showlegend">showLegend</code></td>
<td>
<p>Logical argument. If true, a legend of the color map is 
shown (default is TRUE)</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_tags">Tags</code></td>
<td>
<p>List of tags to specify which episodes, as apnoea or oxygen 
desaturation, are included in the plot. <em>Tags</em>=&quot;all&quot; plots all episodes present
in the data.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_indexes">Indexes</code></td>
<td>
<p>List of indexes of episodes (see ListEpisodes())
to specify which episodes are included in the plot.
<em>Indexes</em>=&quot;all&quot; plots all episodes present in the data.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_eplim">eplim</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for the
vertical lines limiting each episode.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_epcolorpalette">epColorPalette</code></td>
<td>
<p>Vector specifying the color of each of the episodes that 
will be plotted. The length of colorPalette should be equal or greater than 
the number of different episodes to be plotted.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_markepisodes">markEpisodes</code></td>
<td>
<p>Boolean specyfing if a horizontal mark should be included 
for each of the episodes.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_ymark">ymark</code></td>
<td>
<p>Two-component vector specifying the y-range (min,max) for the
horizontal marks. Only used if markEpisodes = TRUE.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_showeplegend">showEpLegend</code></td>
<td>
<p>Boolean argument. If TRUE, a legend of the episodes is 
included.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_eplegendcoords">epLegendCoords</code></td>
<td>
<p>Two-component vector specifiying the coordinates where
the legend should be placed. By defaul, the legend is placed on top of the
plot.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y axis</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vectors of length 2, giving the x and y coordinates 
range. If freqRange is specified, ylim is overwriten by it because of backward
compatibility.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_tag">Tag</code></td>
<td>
<p>Deprecated argument maintained for
compatibility, use Tags instead.</p>
</td></tr>
<tr><td><code id="PlotSpectrogram_+3A_...">...</code></td>
<td>
<p>Other graphical parameters. See 
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PlotSpectrogram
</p>


<h3>Note</h3>

<p>PlotSpectrogram with <em>showLegend = TRUE</em> uses the layout function 
and so is restricted to a full page display. Select <em>showLegend = FALSE</em>
in order to use the layout function.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila. C.A. Garcia
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, 
I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral 
analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, 
doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculateSpectrogram">CalculateSpectrogram</a></code> for spectrogram calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Read file "a03" from the physionet apnea-ecg database
library(RHRV)
HRVData &lt;- CreateHRVData()
HRVData &lt;- LoadBeatWFDB(HRVData,RecordName="test_files/WFDB/a03")
HRVData &lt;- LoadApneaWFDB(HRVData,RecordName="test_files/WFDB/a03")
# Add other type of episode for a more complete example (this episode does
# not have any physiological meaning)
HRVData &lt;- AddEpisodes(HRVData,InitTimes=c(4500),Durations=c(1000), 
                       Tags="Other", Values = 1)         
# Calculating heart rate signal:
HRVData &lt;- BuildNIHR(HRVData)
 
# Filtering heart rate signal:
HRVData &lt;- FilterNIHR(HRVData)

# Interpolating heart rate signal:
HRVData = InterpolateNIHR(HRVData)
 
# Calculating and Plotting Spectrogram
spctr &lt;- PlotSpectrogram(HRVData, size = 120, shift = 10, sizesp = 1024,
         freqRange=c(0,0.14), color.palette = topo.colors)
         
spctr &lt;- PlotSpectrogram(HRVData,size=120, shift=60, Tags="all", 
                         ylim=c(0,0.1),
                         showLegend=T, 
                         eplim = c(0,0.06),
                         epColorPalette=c("skyblue","white"), 
                         showEpLegend = T,
                         epLegendCoords = c(15000,0.08), 
                         ymark=c(0.001,0.002))

## End(Not run)
</code></pre>

<hr>
<h2 id='PoincarePlot'>Poincare Plot</h2><span id='topic+PoincarePlot'></span>

<h3>Description</h3>

<p>The Poincare plot is a graphical representation of the dependance
between successive RR intervals obtained by plotting the <code class="reqn">RR_{j+\tau}</code>
as a function of <code class="reqn">RR_j</code>. This dependance is often quantified by fitting an
ellipse to the plot. In this way, two parameters are obtained:  
<code class="reqn">SD_1</code>  and <code class="reqn">SD_2</code>.
<code class="reqn">SD_1</code> characterizes short-term variability
whereas that <code class="reqn">SD_2</code> characterizes long-term variability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoincarePlot(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis), timeLag = 1,
  confidenceEstimation = FALSE, confidence = 0.95, doPlot = FALSE,
  main = "Poincare plot", xlab = "RR[n]", ylab = paste0("RR[n+", timeLag,
  "]"), pch = 1, cex = 0.3, type = "p", xlim = NULL, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoincarePlot_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
dependance relation:  <code class="reqn">RR_{j+timeLag}</code> as a function of <code class="reqn">RR_j</code>.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_confidenceestimation">confidenceEstimation</code></td>
<td>
<p>Logical value. If TRUE, the covariance matrix is
used for fitting the ellipse and computing the <code class="reqn">SD_1</code> and
<code class="reqn">SD_2</code> parameters (see details). Default: FALSE.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_confidence">confidence</code></td>
<td>
<p>The confidence used for plotting the confidence ellipse.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE (default), the PoincarePlot is shown.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_main">main</code></td>
<td>
<p>An overall title for the Poincare plot.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_pch">pch</code></td>
<td>
<p>Plotting character (symbol to use).</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_cex">cex</code></td>
<td>
<p>Character (or symbol) expansion.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_xlim">xlim</code></td>
<td>
<p>x coordinates range. If not specified, a proper x range is selected.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_ylim">ylim</code></td>
<td>
<p>y coordinates range. If not specified, a proper y range is selected.</p>
</td></tr>
<tr><td><code id="PoincarePlot_+3A_...">...</code></td>
<td>
<p>Additional parameters for the Poincare plot figure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the HRV literature, when <em>timeLag = 1</em>, the <code class="reqn">SD_1</code> and <code class="reqn">SD_2</code>
parameters are computed using time domain measures. This is the default approach in this
function if <em>timeLag=1</em>. This function also allows the user to fit a ellipse
by computing the covariance matrix of 
(<code class="reqn">RR_{j}</code>,<code class="reqn">RR_{j+\tau}</code>)
(by setting <em>confidenceEstimation = TRUE</em>). In most cases, both approaches
yield similar results.
</p>


<h3>Value</h3>

<p>A <em>HRVData</em> structure containing a <em>PoincarePlot</em> field storing
the <code class="reqn">SD_1</code> and <code class="reqn">SD_2</code> parameters. The <em>PoincarePlot</em> field is
stored under the <em>NonLinearAnalysis</em> list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(HRVProcessedData)
 # rename for convenience
 hd = HRVProcessedData
 hd = CreateNonLinearAnalysis(hd)
 hd = PoincarePlot(hd, doPlot = T)

## End(Not run)
</code></pre>

<hr>
<h2 id='ReadFromFile'> Reads data structure from file </h2><span id='topic+ReadFromFile'></span>

<h3>Description</h3>

<p>Reads the data structure containing beat positions and all derived calculations from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadFromFile(name, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadFromFile_+3A_name">name</code></td>
<td>
<p> The name of the file to be used (without the .hrv extension)</p>
</td></tr>
<tr><td><code id="ReadFromFile_+3A_verbose">verbose</code></td>
<td>
<p>Logical value that sets the verbose mode on or off</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the HRVData structure previously stored in the given file.
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='RecurrencePlot'>Recurrence Plot</h2><span id='topic+RecurrencePlot'></span>

<h3>Description</h3>

<p>Plot the recurrence matrix of the RR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RecurrencePlot(HRVData, numberPoints = 1000, embeddingDim = NULL,
  timeLag = NULL, radius = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RecurrencePlot_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="RecurrencePlot_+3A_numberpoints">numberPoints</code></td>
<td>
<p>Number of points from the RR time series to be used in the RQA computation. Default: 1000 heartbeats.</p>
</td></tr>
<tr><td><code id="RecurrencePlot_+3A_embeddingdim">embeddingDim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed the RR time series.</p>
</td></tr>
<tr><td><code id="RecurrencePlot_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors.</p>
</td></tr>
<tr><td><code id="RecurrencePlot_+3A_radius">radius</code></td>
<td>
<p>Maximum distance between two phase-space points to be considered a recurrence.</p>
</td></tr>
<tr><td><code id="RecurrencePlot_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: This function is computationally very expensive. Use with caution.
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+recurrencePlot">recurrencePlot</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>Zbilut, J. P. and C. L. Webber. Recurrence quantification analysis. Wiley Encyclopedia of Biomedical Engineering  (2006).
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+recurrencePlot">recurrencePlot</a></code>, <code><a href="#topic+RQA">RQA</a></code>
</p>

<hr>
<h2 id='RemoveEpisodes'> Remove episodes by indexes or tags</h2><span id='topic+RemoveEpisodes'></span>

<h3>Description</h3>

<p>Removes episodes from the data. Episodes can be specified using indexes or tags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveEpisodes(HRVData, Tags = NULL, Indexes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RemoveEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="RemoveEpisodes_+3A_tags">Tags</code></td>
<td>
<p> Vector containing types of episodes to remove </p>
</td></tr>
<tr><td><code id="RemoveEpisodes_+3A_indexes">Indexes</code></td>
<td>
<p> Vector containing indexes of episodes to remove (see ListEpisodes()) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, without the removed episodes
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='RHRV-package'>
RHRV: An R-based software package for the heart rate variability analysis of ECG recordings
</h2><span id='topic+RHRV-package'></span><span id='topic+RHRV'></span>

<h3>Description</h3>

<p>RHRV offers functions for performing power spectral analysis of heart rate data. We will use this package for the study of several diseases, such as obstructive sleep apnoea or chronic obstructive pulmonary disease.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RHRV</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-02-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This is a package for developing heart rate variability studies of ECG records. Data are read from an ascii file containing a column with beat positions in seconds. A function is included in order to build this file from an ECG record in WFDB format (visit the site http://www.physionet.org for more information).
</p>


<h3>Note</h3>

<p>An example including all the necessary steps to obtain and to <br /> 
analyze by episodes the power bands of a wfdb register is <br />
giving below:<br />
</p>
<p>##Reading a wfdb register and storing into a data structure:<br />
md = CreateHRVData(Verbose = TRUE)<br />
md = LoadBeatWFDB(md, RecordName = &quot;register_name&quot;, <br />
RecordPath = &quot;register_path&quot;)<br />
</p>
<p>##Loading information of episodes of apnea:<br />
md = LoadApneaWFDB(md, RecordName = &quot;register_name&quot;, <br />
RecordPath = &quot;register_path&quot;, Tag = &quot;APN&quot;)<br />
</p>
<p>##Generating new episodes before and after previous episodes of <br />
apnea:<br />
md = GenerateEpisodes(md, NewBegFrom = &quot;Beg&quot;, NewEndFrom = &quot;Beg&quot;, <br />
DispBeg = -600, DispEnd = -120, OldTag = &quot;APN&quot;, <br />
NewTag = &quot;PREV_APN&quot;)<br />
md = GenerateEpisodes(md, NewBegFrom = &quot;End&quot;, NewEndFrom = &quot;End&quot;, <br />
DispBeg = 120, DispEnd = 600, OldTag = &quot;APN&quot;, <br />
NewTag = &quot;POST_APN&quot;)<br />
</p>
<p>##Calculating heart rate signal:<br />
md = BuildNIHR(md)<br />
</p>
<p>##Filtering heart rate signal:<br />
md = FilterNIHR(md)<br />
</p>
<p>##Interpolating heart rate signal:<br />
md = InterpolateNIHR(md)<br />
</p>
<p>##Calculating spectrogram and power per band:<br />
md = CreateFreqAnalysis(md)<br />
md = CalculatePowerBand(md, indexFreqAnalysis = 1, size = 120, <br />
shift = 10, sizesp = 1024)<br />
</p>
<p>##Plotting power per band, including episodes information:<br />
PlotPowerBand(md, indexFreqAnalysis = 1, hr = TRUE, ymax = 2400000, <br />
ymaxratio = 3, Tag = &quot;all&quot;)<br />
</p>
<p>##Splitting power per band using episodes before and after <br />
episodes of apnea:<br />
PrevAPN = SplitPowerBandByEpisodes(md, indexFreqAnalysis = 1, <br />
Tag = &quot;PREV_APN&quot;)<br />
PostAPN = SplitPowerBandByEpisodes(md, indexFreqAnalysis = 1, <br />
Tag = &quot;POST_APN&quot;)<br />
</p>
<p>##Performing Student's t-test:<br />
result = t.test(PrevAPN$InEpisodes$ULF, PostAPN$InEpisodes$ULF)<br />
print(result)<br />
</p>


<h3>Author(s)</h3>

<p>A. Mendez, L. Rodriguez, A. Otero, C.A. Garcia, X. Vila, M. Lado
</p>
<p>Maintainer: Leandro Rodriguez-Linares &lt;leandro@uvigo.es&gt;
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, L., A.J. Mendez, M.J. Lado, D.N. Olivieri, X.A. Vila, and I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103(1):39-50, july 2011.
</p>

<hr>
<h2 id='RQA'>Recurrence Quantification Analysis (RQA)</h2><span id='topic+RQA'></span>

<h3>Description</h3>

<p>The Recurrence Quantification Analysis (RQA) is an advanced technique for the nonlinear
analysis that allows to quantify the number and duration of the recurrences in the 
phase space. This function computes the RQA of the RR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RQA(HRVData, indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  numberPoints = NULL, embeddingDim = NULL, timeLag = NULL, radius = 1,
  lmin = 2, vmin = 2, distanceToBorder = 2, doPlot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RQA_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information related to it</p>
</td></tr>
<tr><td><code id="RQA_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="RQA_+3A_numberpoints">numberPoints</code></td>
<td>
<p>Number of points from the RR time series to be used in the RQA computation. If the number of
points is not specified, the whole RR time series is used.</p>
</td></tr>
<tr><td><code id="RQA_+3A_embeddingdim">embeddingDim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed the RR time series.</p>
</td></tr>
<tr><td><code id="RQA_+3A_timelag">timeLag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use to construct the 
Takens' vectors.</p>
</td></tr>
<tr><td><code id="RQA_+3A_radius">radius</code></td>
<td>
<p>Maximum distance between two phase-space points to be considered a recurrence.</p>
</td></tr>
<tr><td><code id="RQA_+3A_lmin">lmin</code></td>
<td>
<p>Minimal length of a diagonal line to be considered in the RQA. Default <em>lmin</em> = 2.</p>
</td></tr>
<tr><td><code id="RQA_+3A_vmin">vmin</code></td>
<td>
<p>Minimal length of a vertical line to be considered in the RQA. Default <em>vmin</em> = 2.</p>
</td></tr>
<tr><td><code id="RQA_+3A_distancetoborder">distanceToBorder</code></td>
<td>
<p>In order to avoid border effects, the <em>distanceToBorder</em> points near the 
border of the recurrence matrix are ignored when computing the RQA parameters. Default, <em>distanceToBorder</em> = 2.</p>
</td></tr>
<tr><td><code id="RQA_+3A_doplot">doPlot</code></td>
<td>
<p>Logical. If TRUE, the recurrence plot is shown. However, plotting the recurrence matrix is computationally 
expensive. Use with caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HRVData structure that stores an <em>rqa</em> field under the NonLinearAnalysis list.
The <em>rqa</em> field consist of a list with the most important RQA parameters:
</p>

<ul>
<li> <p><em>REC</em>: Recurrence. Percentage of recurrence points in a Recurrence Plot.
</p>
</li>
<li> <p><em>DET</em>: Determinism. Percentage of recurrence points that form diagonal lines.
</p>
</li>
<li> <p><em>LAM</em>: Percentage of recurrent points that form vertical lines.
</p>
</li>
<li> <p><em>RATIO</em>: Ratio between <em>DET</em> and <em>RR</em>.
</p>
</li>
<li> <p><em>Lmax</em>: Length of the longest diagonal line.
</p>
</li>
<li> <p><em>Lmean</em>: Mean length of the diagonal lines. The main diagonal is not taken into account.
</p>
</li>
<li> <p><em>DIV</em>: Inverse of <em>Lmax</em>.
</p>
</li>
<li> <p><em>Vmax</em>: Longest vertical line.
</p>
</li>
<li> <p><em>Vmean</em>: Average length of the vertical lines. This parameter is also referred to as the Trapping time.
</p>
</li>
<li> <p><em>ENTR</em>: Shannon entropy of the diagonal line lengths distribution
</p>
</li>
<li> <p><em>TREND</em>: Trend of the number of recurrent points depending on the distance to the main diagonal
</p>
</li>
<li> <p><em>diagonalHistogram</em>: Histogram of the length of the diagonals.
</p>
</li>
<li> <p><em>recurrenceRate</em>: Number of recurrent points depending on the distance to the main diagonal.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is based on the <code><a href="nonlinearTseries.html#topic+rqa">rqa</a></code> function from the 
nonlinearTseries package.
</p>


<h3>References</h3>

<p>Zbilut, J. P. and C. L. Webber. Recurrence quantification analysis. Wiley Encyclopedia of Biomedical Engineering  (2006).
</p>


<h3>See Also</h3>

<p><code><a href="nonlinearTseries.html#topic+rqa">rqa</a></code>, <code><a href="#topic+RecurrencePlot">RecurrencePlot</a></code>
</p>

<hr>
<h2 id='SetVerbose'> Sets verbose mode on or off </h2><span id='topic+SetVerbose'></span>

<h3>Description</h3>

<p>Sets verbose mode on or off, verbose is a boolean component of the data structure HRVData that allows to specify if all the functions return additional information </p>


<h3>Usage</h3>

<pre><code class='language-R'>SetVerbose(HRVData, Verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetVerbose_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="SetVerbose_+3A_verbose">Verbose</code></td>
<td>
<p> Boolean argument that allows to specify if the function returns additional information </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns HRVData, the structure that will contain beat positions register, associated heart rate instantaneous values, filtered heart rate signal equally spaced, and one or more analysis structures
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

<hr>
<h2 id='SplitHRbyEpisodes'> Splits Heart Rate Data using Episodes information </h2><span id='topic+SplitHRbyEpisodes'></span>

<h3>Description</h3>

<p>Splits Heart Rate Data in two parts using an specific episode type: data inside episodes and data outside episodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitHRbyEpisodes(HRVData, Tag = "", verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitHRbyEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="SplitHRbyEpisodes_+3A_tag">Tag</code></td>
<td>
<p> Type of episode </p>
</td></tr>
<tr><td><code id="SplitHRbyEpisodes_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two vectors that is, the values of Heart Rate Data inside and outside episodes
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AnalyzeHRbyEpisodes">AnalyzeHRbyEpisodes</a></code> for processing Heart Rate Data using an specific episode type
</p>

<hr>
<h2 id='SplitPowerBandByEpisodes'> Splits Power Per Band using Episodes information </h2><span id='topic+SplitPowerBandByEpisodes'></span>

<h3>Description</h3>

<p>Splits Power per Band in two lists using an specific episode type: data inside
episodes and data outside episodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitPowerBandByEpisodes(HRVData, indexFreqAnalysis  =
length(HRVData$FreqAnalysis), Tag = "", 
		verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitPowerBandByEpisodes_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information 
related to it </p>
</td></tr>
<tr><td><code id="SplitPowerBandByEpisodes_+3A_indexfreqanalysis">indexFreqAnalysis</code></td>
<td>
<p> Reference to the data structure that will contain 
the variability analysis </p>
</td></tr>
<tr><td><code id="SplitPowerBandByEpisodes_+3A_tag">Tag</code></td>
<td>
<p> Type of episode </p>
</td></tr>
<tr><td><code id="SplitPowerBandByEpisodes_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use 
SetVerbose() instead </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two lists: InEpisodes and OutEpisodes, both lists include 
ULF, VLF, LF and HF bands
</p>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open sourcetool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalculatePowerBand">CalculatePowerBand</a></code> for power calculation
</p>

<hr>
<h2 id='SurrogateTest'>Surrogate data testing</h2><span id='topic+SurrogateTest'></span>

<h3>Description</h3>

<p>Surrogate data testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurrogateTest(HRVData,
  indexNonLinearAnalysis = length(HRVData$NonLinearAnalysis),
  significance = 0.05, oneSided = FALSE, alternative = c("smaller",
  "larger"), K = 1, useFunction, xlab = "Values of the statistic",
  ylab = "", main = "Surrogate data testing on the RR intervals",
  doPlot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurrogateTest_+3A_hrvdata">HRVData</code></td>
<td>
<p>Structure containing the RR time series.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_indexnonlinearanalysis">indexNonLinearAnalysis</code></td>
<td>
<p>Reference to the data structure that will contain the nonlinear analysis</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_significance">significance</code></td>
<td>
<p>Significance of the test.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_onesided">oneSided</code></td>
<td>
<p>Logical value. If <em>TRUE</em>, the routine runs a one-side
test. If <em>FALSE</em>, a two-side test is applied (default).</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_alternative">alternative</code></td>
<td>
<p>Specifies the concrete type of one-side test that should be 
performed: If the the user wants to test if the statistic from the original
data is smaller (<em>alternative=&quot;smaller&quot;</em>) or larger 
(<em>alternative=&quot;larger&quot;</em>) than the expected value under the
null hypothesis.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_k">K</code></td>
<td>
<p>Integer controlling the number of surrogates to be generated (see
details).</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_usefunction">useFunction</code></td>
<td>
<p>The function that computes the discriminating statistic that shall be used for testing.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_doplot">doPlot</code></td>
<td>
<p>Logical value. If TRUE, a graphical representation of the statistic value for
both surrogates and original data is shown.</p>
</td></tr>
<tr><td><code id="SurrogateTest_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <em>useFunction</em> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests the null hypothesis (H0) stating that the series 
is a gaussian linear process. The test is performed by generating several 
surrogate data according to H0 and comparing the values of a discriminating
statistic between both original data and the surrogate data. If the value of 
the statistic is significantly different for the original series than for the
surrogate set, the null hypothesis is rejected and nonlinearity assumed.  
</p>
<p>To test with a significance level of <code class="reqn">\alpha</code> if the statistic
from the original data is smaller than the expected  value under the null
hypothesis (a one-side test),  <code class="reqn">K/\alpha - 1</code> surrogates
are generated. The null hypothesis is then rejected if the statistic from
the data has one of the K smallest values. For a two-sided test, 
<code class="reqn">2K/\alpha - 1</code> surrogates are generated. The null 
hypothesis is rejected if the statistic from the data gives one of the K smallest
or largest values.
</p>
<p>The  surrogate data is generated by using a phase randomization procedure.
</p>


<h3>Value</h3>

<p>A <em>HRVData</em> structure containing a <em>SurrogateTest</em> field storing the 
statistics computed for the set (<em>surrogates.statistics</em> field) and the RR time series 
(<em>data.statistic field</em>). The <em>SurrogateTest</em> list is stored under the <em>NonLinearAnalysis</em> structure.
</p>


<h3>References</h3>

<p>SCHREIBER, Thomas; SCHMITZ, Andreas. Surrogate time series. Physica D: 
Nonlinear Phenomena, 2000, vol. 142, no 3, p. 346-382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
# rename for convenience
HRVData = HRVProcessedData
# Select a small window that looks stationary
HRVData = Window(HRVData,start = 0, end=800)
HRVData = CreateNonLinearAnalysis(HRVData)
HRVData = SetVerbose(HRVData,TRUE)
HRVData = SurrogateTest(HRVData, indexNonLinearAnalysis = 1,
                        significance = 0.05, oneSided = FALSE,
                        K = 5, useFunction = timeAsymmetry2)


## End(Not run)
</code></pre>

<hr>
<h2 id='Window'>Time windows of RR intervals</h2><span id='topic+Window'></span>

<h3>Description</h3>

<p>Extracts a temporal subset between the times start and end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Window(HRVData, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window_+3A_hrvdata">HRVData</code></td>
<td>
<p>Data structure that stores the beats register and information 
related to it.</p>
</td></tr>
<tr><td><code id="Window_+3A_start">start</code></td>
<td>
<p>The start time of the period of interest.</p>
</td></tr>
<tr><td><code id="Window_+3A_end">end</code></td>
<td>
<p>The end time of the period of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <em>HRVData</em> episodes, beats or RR time series,
these will be also extracted into the new HRV structure. On the other hand,
all the analysis stored in the original structure will be lost.
</p>


<h3>Value</h3>

<p>A new <em>HRVData</em> structure containing the subset of RR intervals
within the specified range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(HRVProcessedData)
# Rename for convenience
HRVData &lt;- HRVProcessedData
PlotNIHR(HRVData)
newHRVData &lt;- Window(HRVData,2000,4000)
PlotNIHR(newHRVData)

## End(Not run)
</code></pre>

<hr>
<h2 id='WriteToFile'> Writes data structure to a file </h2><span id='topic+WriteToFile'></span>

<h3>Description</h3>

<p>Writes the data structure containing beat positions and all derived calculations to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteToFile(HRVData, name, overwrite = TRUE, verbose=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteToFile_+3A_hrvdata">HRVData</code></td>
<td>
<p> Data structure that stores the beats register and information related to it </p>
</td></tr>
<tr><td><code id="WriteToFile_+3A_name">name</code></td>
<td>
<p> The name of the file to be used </p>
</td></tr>
<tr><td><code id="WriteToFile_+3A_overwrite">overwrite</code></td>
<td>
<p> Boolean argument for indicating what to do if the file already exists </p>
</td></tr>
<tr><td><code id="WriteToFile_+3A_verbose">verbose</code></td>
<td>
<p> Deprecated argument maintained for compatibility, use SetVerbose() instead </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>M. Lado, A. Mendez, D. Olivieri, L. Rodriguez, X. Vila
</p>


<h3>References</h3>

<p>L. Rodriguez-Linares, A. Mendez, M. Lado, D. Olivieri, X. Vila, I. Gomez-Conde, &quot;An open source tool for heart rate variability spectral analysis&quot;, Computer Methods and Programs in Biomedicine 103, 39-50, doi:10.1016/j.cmpb.2010.05.012 (2011)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
