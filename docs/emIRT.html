<!DOCTYPE html><html><head><title>Help for package emIRT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {emIRT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AsahiTodai'>
<p>Asahi-Todai Elite Survey</p></a></li>
<li><a href='#binIRT'><p> Two-parameter Binary IRT estimation via EM</p></a></li>
<li><a href='#boot_emIRT'><p> Parametric bootstrap of EM Standard Errirs</p></a></li>
<li><a href='#convertRC'><p> Convert Roll Call Matrix Format</p></a></li>
<li><a href='#dwnom'>
<p>Poole-Rosenthal DW-NOMINATE data and scores, 80-110 U.S. Senate</p></a></li>
<li><a href='#dynIRT'><p> Dynamic IRT estimation via Variational Inference</p></a></li>
<li><a href='#getStarts'><p> Generate Starts for <code>binIRT</code></p></a></li>
<li><a href='#hierIRT'><p> Hierarchichal IRT estimation via Variational Inference</p></a></li>
<li><a href='#makePriors'><p> Generate Priors for <code>binIRT</code></p></a></li>
<li><a href='#manifesto'>
<p>German Manifesto Data</p></a></li>
<li><a href='#mq_data'>
<p>Martin-Quinn Judicial Ideology Scores</p></a></li>
<li><a href='#networkIRT'><p> Network IRT estimation via EM</p></a></li>
<li><a href='#ordIRT'><p> Two-parameter Ordinal IRT estimation via EM</p></a></li>
<li><a href='#poisIRT'><p> Poisson IRT estimation via EM</p></a></li>
<li><a href='#ustweet'>
<p>U.S. Twitter Following Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>EM Algorithms for Estimating Item Response Theory Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.14</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Kosuke Imai &lt;imai@harvard.edu&gt;, James Lo &lt;jameslo989@gmail.com&gt;, Jonathan Olmsted &lt;jpolmsted@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kosuke Imai &lt;imai@harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various Expectation-Maximization (EM) algorithms are implemented for item 
	response theory (IRT) models. The package includes IRT models for binary and ordinal
	responses, along with dynamic and hierarchical IRT models with binary responses. The
	latter two models are fitted using variational EM.  The package also includes 
	variational network and text scaling models.  The algorithms are described in Imai, Lo, 
	and Olmsted (2016) &lt;<a href="https://doi.org/10.1017%2FS000305541600037X">doi:10.1017/S000305541600037X</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), pscl (&ge; 1.0.0), Rcpp (&ge; 0.10.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MCMCpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-05 08:47:18 UTC; kosukeimai</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-06 15:22:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='AsahiTodai'>
Asahi-Todai Elite Survey
</h2><span id='topic+AsahiTodai'></span>

<h3>Description</h3>

<p>The Asahi-Todai Elite survey was conducted by the University of Tokyo in collaboration with
a major national newspaper, the Asahi Shimbun, covering all candidates (both incumbents and
challengers) for the eight Japanese Upper and Lower House elections that occurred between 2003
and 2013. In six out of eight waves, the survey was also administered to a nationally representative
sample of voters with the sample size ranging from approximately 1,100 to about 2,000. The novel
feature of the data is that there are a set of common policy questions, which can be used to scale
both politicians and voters over time on the same dimension.
</p>
<p>All together, the data set contains a total of N = 19,443 respondents, including 7,734 politicians
and 11,709 voters. There are J = 98 unique questions in the survey, most of which consisted of
questions asking for responses on a 5-point Likert scale. However, these scales were collapsed
into a 3-point Likert scale for estimation with <code>ordIRT()</code>.  In the data set, we include
estimates obtained via MCMC using both the 3 and 5-point scale data. See Hirano et al. 2011 for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AsahiTodai)</code></pre>


<h3>Format</h3>

<p>list, containing the following variables:
</p>

<dl>
<dt>dat.all</dt><dd><p> Survey data, formatted for input to <code>ordIRT()</code>.</p>
</dd>
<dt>start.values</dt><dd><p> Start values, formatted for input to <code>ordIRT()</code>. </p>
</dd>
<dt>priors</dt><dd><p> Priors, formatted for input to <code>ordIRT()</code>.</p>
</dd>
<dt>ideal3</dt><dd><p> Ideal point estimates with data via MCMC, using collapsed 3-category data.</p>
</dd>
<dt>ideal5</dt><dd><p> Ideal point estimates with data via MCMC, using original 5-category data.</p>
</dd>
<dt>obs.attri</dt><dd><p> Attribute data of the respondents.</p>
</dd>
</dl>



<h3>References</h3>

<p>Shigeo Hirano, Kosuke Imai, Yuki Shiraito and Masaaki Taniguchi. 2011. &ldquo;Policy Positions in
Mixed Member Electoral Systems:Evidence from Japan.&rdquo; Working Paper.
</p>
<p>Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656. 
</p>


<h3>See Also</h3>

<p>'<a href="#topic+ordIRT">ordIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
### Real data example: Asahi-Todai survey (not run)
## Collapses 5-category ordinal survey items into 3 categories for estimation
data(AsahiTodai)
out.varinf &lt;- ordIRT(.rc = AsahiTodai$dat.all, .starts = AsahiTodai$start.values,
					.priors = AsahiTodai$priors, .D = 1,
					.control = {list(verbose = TRUE,
                     thresh = 1e-6, maxit = 500)})

## Compare against MCMC estimates using 3 and 5 categories
cor(ideal3, out.varinf$means$x)
cor(ideal5, out.varinf$means$x)  

## End(Not run)

</code></pre>

<hr>
<h2 id='binIRT'> Two-parameter Binary IRT estimation via EM </h2><span id='topic+binIRT'></span>

<h3>Description</h3>

<p><code>binaryIRT</code> estimates a binary IRT model with two response categories. Estimation
is conducted using the EM algorithm described in the reference paper below. The algorithm will
produce point estimates that are comparable to those of <code><a href="pscl.html#topic+ideal">ideal</a></code>,
but will do so much more rapidly and also scale better with larger data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  binIRT(.rc, .starts = NULL, .priors = NULL, .D = 1L, .control = NULL,
  .anchor_subject = NULL, .anchor_outcomes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binIRT_+3A_.rc">.rc</code></td>
<td>
<p>  a list object, in which .rc$votes is a matrix of numeric values containing the data
to be scaled.  Respondents are assumed to be on rows, and items assumed to be on columns, so the
matrix is assumed to be of dimension (N x J).  For each item, &lsquo;1&rsquo;, and &lsquo;-1&rsquo; represent different
responses (i.e. yes or no votes) with &lsquo;0&rsquo; as a missing data record.</p>
</td></tr>
<tr><td><code id="binIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters.
The list should contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of starting values for the item difficulty parameter <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x D) matrix of starting values for the item discrimination parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (N x D) matrix of starting values for the respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="binIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters.
The list should contain the following matrices:
</p>

<dl>
<dt><code>x$mu</code></dt><dd><p>  A (D x D) prior means matrix for respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>x$sigma</code></dt><dd><p>  A (D x D) prior covariance matrix for respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>beta$mu</code></dt><dd><p>  A (D+1 x 1) prior means matrix for <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>beta$sigma</code></dt><dd><p>  A (D+1 x D+1) prior covariance matrix for <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="binIRT_+3A_.d">.D</code></td>
<td>
<p> integer, indicates number of dimensions to estimate. Only a
1 dimension is currently supported. If a higher dimensional model is
requested, <code>binIRT</code> exits with an error.</p>
</td></tr>
<tr><td><code id="binIRT_+3A_.control">.control</code></td>
<td>
<p>list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core, but more can be
supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.  Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all
parameters have a correlation greater than (1 - threshold) across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run. Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations. Set at 50 by default.</p>
</dd>
<dt><code>asEM</code></dt><dd><p>  boolean. Sets EM or variational EM algorithm. Set is TRUE.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="binIRT_+3A_.anchor_subject">.anchor_subject</code></td>
<td>
<p> integer, the index of the subect to be used in
anchoring the orientation/polarity of the underlying latent
dimensions. Defaults to <code>NULL</code> and no anchoring is done.
</p>
</td></tr>
<tr><td><code id="binIRT_+3A_.anchor_outcomes">.anchor_outcomes</code></td>
<td>
<p> logical, should an outcomes-based metric be
used to anchor the orientation of the underlying space. The
outcomes-based anchoring uses a model-free/non-parametric
approximation to quantify each item's difficulty and each subject's
ability. The post-processing then rotates the model-dependent results
to match the model-free polarity. Defaults to <code>FALSE</code> and no
anchoring is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>binIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x 1) matrix of point estimates for the respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>   A (J x D+1 ) matrix of point estimates for the item parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for parameters corresponding
to the inputs for the priors.  Note that these variances are those recovered via variational approximation,
and in most cases they are known to be far too small and generally unusable.  Better estimates of variances
can be obtained manually via the parametric bootstrap.  The list should contain the following matrices:
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x 1) matrix of variances for the respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x D+1 ) matrix of variances for the item parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:</p>
</td></tr>
</table>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0 if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh argument in input to .control list.</p>
</dd>
</dl>

<table>
<tr><td><code>n</code></td>
<td>
<p> Number of respondents in estimation, should correspond to number of rows in roll call matrix.</p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p> Number of items in estimation, should correspond to number of columns in roll call matrix.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p> Number of dimensions in estimation.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> Function call used to generate output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>James Lo <a href="mailto:lojames@usc.edu">lojames@usc.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
Working Paper. American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+convertRC">convertRC</a>', '<a href="#topic+makePriors">makePriors</a>', '<a href="#topic+getStarts">getStarts</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data from 109th US Senate
data(s109)

## Convert data and make starts/priors for estimation
rc &lt;- convertRC(s109)
p &lt;- makePriors(rc$n, rc$m, 1)
s &lt;- getStarts(rc$n, rc$m, 1)

## Conduct estimates
lout &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                }
                )

## Look at first 10 ideal point estimates
lout$means$x[1:10]


lout2 &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                },
                .anchor_subject = 2
                )
                                        # Rotates so that Sen. Sessions (R AL)
                                        # has more of the estimated trait

lout3 &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                },
                .anchor_subject = 10
                )
                                        # Rotates so that Sen. Boxer (D CA)
                                        # has more of the estimated trait

cor(lout2$means$x[, 1],
    lout3$means$x[, 1]
    )
                                        # = -1 --&gt; same numbers, flipped
                                        # orientation

</code></pre>

<hr>
<h2 id='boot_emIRT'> Parametric bootstrap of EM Standard Errirs </h2><span id='topic+boot_emIRT'></span>

<h3>Description</h3>

 
<p><code>boot_emIRT</code> take an emIRT() object (from binary, ordinal, dynamic, or hierarchical models) and implements
a parametric bootstrap of the standard errors for the ideal points.  It assumes you have already run the model
successfully on one of those functions, and takes the output from that estimate, along with the original arguments,
as the arguments for the bootstrap function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  boot_emIRT(emIRT.out, .data, .starts, .priors, .control, Ntrials=50, verbose=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_emIRT_+3A_emirt.out">emIRT.out</code></td>
<td>
<p>  an emIRT() object, which is output from a call to binIRT(), dynIRT(), ordIRT(), or hierIRT()</p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_.data">.data</code></td>
<td>
<p> the data used to produce the emIRT object. </p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_.starts">.starts</code></td>
<td>
<p> the starts used to produce the emIRT object.  </p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_.priors">.priors</code></td>
<td>
<p> the priors used to produce the emIRT object. </p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_.control">.control</code></td>
<td>
<p> the control arguments used to produce the emIRT object. </p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_ntrials">Ntrials</code></td>
<td>
<p> Number of bootstrap trials to run. </p>
</td></tr>
<tr><td><code id="boot_emIRT_+3A_verbose">verbose</code></td>
<td>
<p> Number of trials before progress notification triggers. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>emIRT</code>.  The output takes the original emIRT.out object and appends the following:
</p>
<table>
<tr><td><code>bse</code></td>
<td>
<p> list, containing only the matrix:
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x 1) matrix of bootstrapped standard errors</p>
</dd>
</dl>
                 
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:kimai@princeton.edu">kimai@princeton.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+binIRT">binIRT</a>', '<a href="#topic+ordIRT">ordIRT</a>', '<a href="#topic+hierIRT">hierIRT</a>', '<a href="#topic+dynIRT">dynIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

### Binary IRT example
example(binIRT)
boot.bin &lt;- boot_emIRT(lout, .data = rc, .starts = s, .priors = p,
  .control = list(threads = 1, verbose = FALSE, thresh = 1e-06), Ntrials=10, verbose=2)
boot.bin$bse$x

### Dynamic IRT example
example(dynIRT)
boot.dyn &lt;- boot_emIRT(lout, .data = mq_data$data.mq, .starts = mq_data$cur.mq,
  .priors = mq_data$priors.mq, .control = list(threads = 1, verbose = FALSE,
  thresh = 1e-06), Ntrials=10, verbose=2)
boot.dyn$bse$x

### Ordinal IRT example
example(ordIRT)
boot.ord &lt;- boot_emIRT(lout, .data=newrc, .starts=cur, .priors=priors,
  .control = list(threads = 1, verbose = TRUE, thresh = 1e-6, maxit=300,
  checkfreq=50), Ntrials=5, verbose=1)
boot.ord$bse$x

### Hierarhical IRT example
example(hierIRT, run.dontrun=TRUE)
boot.hier &lt;- boot_emIRT((lout, .data=dwnom$data.in, .starts=dwnom$cur, .priors=dwnom$priors,
	.control=list(threads = 8, verbose = TRUE, thresh = 1e-4, maxit=200, checkfreq=1),
	Ntrials=5, verbose=1)
boot.hier$bse$x_implied


## End(Not run)

</code></pre>

<hr>
<h2 id='convertRC'> Convert Roll Call Matrix Format </h2><span id='topic+convertRC'></span>

<h3>Description</h3>

 
<p><code>convertRC</code> takes a <code><a href="pscl.html#topic+rollcall">rollcall</a></code> object and converts it
into a format suitable for estimation with '<a href="#topic+binIRT">binIRT</a>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  convertRC(.rc, type = "binIRT") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertRC_+3A_.rc">.rc</code></td>
<td>
<p>  a <code><a href="pscl.html#topic+rollcall">rollcall</a></code> object containing votes to be scaled using '<a href="#topic+binIRT">binIRT</a>'.</p>
</td></tr>
<tr><td><code id="convertRC_+3A_type">type</code></td>
<td>
<p> string, only &ldquo;binIRT&rdquo; is supported for now, and argument is ignored. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>rollcall</code>, with votes recoded such that yea=1, nay=-1, missing data = 0.
</p>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:kimai@princeton.edu">kimai@princeton.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
Working Paper. Available at <a href="http://imai.princeton.edu/research/fastideal.html">http://imai.princeton.edu/research/fastideal.html</a>.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+binIRT">binIRT</a>', '<a href="#topic+makePriors">makePriors</a>', '<a href="#topic+getStarts">getStarts</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data from 109th US Senate
data(s109)

## Convert data and make starts/priors for estimation
rc &lt;- convertRC(s109)
p &lt;- makePriors(rc$n, rc$m, 1)
s &lt;- getStarts(rc$n, rc$m, 1)

## Conduct estimates
lout &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                }
                )

## Look at first 10 ideal point estimates
lout$means$x[1:10]

</code></pre>

<hr>
<h2 id='dwnom'>
Poole-Rosenthal DW-NOMINATE data and scores, 80-110 U.S. Senate
</h2><span id='topic+dwnom'></span>

<h3>Description</h3>

<p>This data set contains materials related to the Poole-Rosenthal DW-NOMINATE measure of senator
ideology.  The software (and other materials) is available at <a href="https://voteview.com/">https://voteview.com/</a>,
which includes a simpler example of an application to the 80-110 U.S. Senate.  The data set here is
derived from the data and estimates from that example, but are formatted to be run in <code>hierIRT()</code>.
In particular, start values for estimation are identical to those provided by the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dwnom)</code></pre>


<h3>Format</h3>

<p>list, containing the following elements:
</p>

<dl>
<dt>data.in</dt><dd><p> Legislator voting data, formatted for input to <code>hierIRT()</code>.</p>
</dd>
<dt>cur</dt><dd><p> Start values, formatted for input to <code>hierIRT()</code>. </p>
</dd>
<dt>priors</dt><dd><p> Priors, formatted for input to <code>hierIRT()</code>.</p>
</dd>
<dt>legis</dt><dd><p> data frame, containing contextual information about the legislators estimated.</p>
</dd>
<dt>nomres</dt><dd><p> data frame, containing estimates from DW-NOMINATE on the same data. These
are read from the file SL80110C21.DAT. </p>
</dd>
</dl>



<h3>References</h3>

<p>DW-NOMINATE is described in Keith T. Poole and Howard Rosenthal. 1997. Congress: A Political Economic History
of Roll Call Voting. Oxford University Press.  See also <a href="https://voteview.com/">https://voteview.com/</a>.
</p>
<p>Variational model is described in Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation
of Ideal Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+hierIRT">hierIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Real data example of US Senate 80-110 (not run)
### Based on voteview.com example of DW-NOMINATE 
### We estimate a hierarchical model without noise and a linear time covariate
### This model corresponds very closely to the DW-NOMINATE model

## Not run: 
data(dwnom)

## This takes about 10 minutes to run on 8 threads
## You may need to reduce threads depending on what your machine can support
lout &lt;- hierIRT(.data = dwnom$data.in,
                    .starts = dwnom$cur,
                    .priors = dwnom$priors,
                    .control = {list(
                    threads = 8,
                    verbose = TRUE,
                    thresh = 1e-4,
				    maxit=200,
				    checkfreq=1
                        )})

## Bind ideal point estimates back to legislator data
final &lt;- cbind(dwnom$legis, idealpt.hier=lout$means$x_implied)

## These are estimates from DW-NOMINATE as given on the Voteview example
## From file "SL80110C21.DAT"
nomres &lt;- dwnom$nomres

## Merge the DW-NOMINATE estimates to model results by legislator ID
## Check correlation between hierIRT() and DW-NOMINATE scores
res &lt;- merge(final, nomres, by=c("senate","id"),all.x=TRUE,all.y=FALSE)
cor(res$idealpt.hier, res$dwnom1d)


## End(Not run)
</code></pre>

<hr>
<h2 id='dynIRT'> Dynamic IRT estimation via Variational Inference </h2><span id='topic+dynIRT'></span>

<h3>Description</h3>

 
<p><code>ordIRT</code> estimates an dynamic IRT model with two response categories per item, over several
sessions. Ideal points over time follow a random walk prior, and the model originates from the
work of Martin and Quinn (2002). Estimation is conducted using the variational EM algorithm described
in the reference paper below. The algorithm will produce point estimates that are comparable to those
of <code><a href="MCMCpack.html#topic+MCMCdynamicIRT1d">MCMCdynamicIRT1d</a></code>, but will do so much more rapidly and also scale better
with larger data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dynIRT(.data, .starts = NULL, .priors = NULL, .control = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynIRT_+3A_.data">.data</code></td>
<td>
<p> a list with the following items.
</p>

<dl>
<dt><code>rc</code></dt><dd><p>  A (N x J) matrix of observed votes. &lsquo;1&rsquo; and &lsquo;-1&rsquo; are the yea and nay codes, while &lsquo;0&rsquo; is
a missing data code.</p>
</dd>
<dt><code>startlegis</code></dt><dd><p>  An (N x 1) matrix indicating the first session that each legislator serves. Justices
are assumed to serve in all terms between (and including) &lsquo;startlegis&rsquo; to &lsquo;endlegis&rsquo;.  Terms start at term 0,
and end at term T - 1.</p>
</dd>
<dt><code>endlegis</code></dt><dd><p>  An (N x 1) matrix indicating the last session that each legislator serves. Justices
are assumed to serve in all terms between (and including) &lsquo;startlegis&rsquo; to &lsquo;endlegis&rsquo;.  Terms start at term 0,
and end at term T - 1.</p>
</dd>
<dt><code>bill.session</code></dt><dd><p>  A (J x 1) matrix of integers indicating the session each bill occurred in. Session count
begins at 0, so the maximum value of bill.session is T - 1.</p>
</dd>
<dt><code>T</code></dt><dd><p>  integer, indicating total number of consecutive terms in the data. Count starts from 1, so the
maximum values of startlegis/endlegis/bill.session is T - 1, since they start from term 0.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="dynIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters. The
list should contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of starting values for the item difficulty parameter <code class="reqn">\alpha_j</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of starting values for the item discrimination parameter <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (N x T) matrix of starting values for the respondent ideal points <code class="reqn">x_{it}</code>, with rows indicating the
legislator and columns indicating the session.  Although not strictly necessary, it is generally good practice here to
set the start values for legislators who are not serving in a particular session to 0, as that is what the point estimate for
them will return.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="dynIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters. The
list should contain the following matrices:
</p>

<dl>
<dt><code>x.mu0</code></dt><dd><p>  A (N x 1) prior means matrix for respondent ideal points <code class="reqn">c_{i0}</code>. These are generally
set to be somewhat informative to resolve the standard rotational invariance problem in ideal point models.</p>
</dd>
<dt><code>x.sigma0</code></dt><dd><p>  A (N x 1) prior variance matrix for respondent ideal points <code class="reqn">C_{i0}</code>.</p>
</dd>
<dt><code>beta.mu</code></dt><dd><p>  A (2 x 1) prior means matrix for all bill parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>beta.sigma</code></dt><dd><p>  A (2 x 2) prior covariance matrix for all bill parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>omega2</code></dt><dd><p>  A (N x 1) matrix with the evolutionary variance for each legislator <code class="reqn">\omega^2_{ix}</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="dynIRT_+3A_.control">.control</code></td>
<td>
<p>  list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core, but more can be
supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.  Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all parameters correlate at 1 - thresh across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run. Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations. Set at 50 by default.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dynIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x T) matrix of point estimates for the respondent ideal points <code class="reqn">x_{it}</code>, with rows
indicating respondent and columns indicating session of the estimated ideal point. Estimates will equal
exactly 0 for legislator/period combinations in which the legislator did not serve.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of point estimates for the item difficulty parameter <code class="reqn">\alpha_j</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of point estimates for the item discrimination parameter <code class="reqn">\beta_j</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for parameters corresponding
to the inputs for the priors.  Note that these variances are those recovered via variational approximation,
and in most cases they are known to be far too small and generally unusable.  Better estimates of variances
can be obtained manually via the parametric bootstrap.  The list should contain the following matrices:
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x T) matrix of variance estimates for the respondent ideal points <code class="reqn">x_{it}</code>, with rows
indicating respondent and columns indicating session of the estimated ideal point. Estimates will equal
exactly 0 for legislator/period combinations in which the legislator did not serve.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of variance estimates for the item difficulty parameter <code class="reqn">\alpha_j</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of variance estimates for the item discrimination parameter <code class="reqn">\beta_j</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:</p>
</td></tr>
</table>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0 if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh argument in input to .control list.</p>
</dd>
</dl>
                 
<table>
<tr><td><code>N</code></td>
<td>
<p> Number of respondents in estimation, should correspond to number of rows in roll call matrix.</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p> Number of items in estimation, should correspond to number of columns in roll call matrix.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p> Number of time periods fed into the estimation, identical to argument input from .data list.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> Function call used to generate output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>James Lo <a href="mailto:lojames@usc.edu">lojames@usc.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Original model and the example is based off of Andrew Martin and Kevin Quinn, &ldquo;Dynamic Ideal
Point Estimation via Markov Chain Monte Carlo for the U.S. Supreme Court, 1953-1999.&rdquo; Political
Analysis 10(2) 134-153.
</p>
<p>Variational model is described in Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation
of Ideal Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+mq_data">mq_data</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Replication of Martin-Quinn Judicial Ideology Scores
### Based on July 23, 2014 (2014 Release 01) release of the Supreme Court Database
### Start values and priors based on replication code provided by Kevin Quinn

data(mq_data)

## Estimate dynamic variational model using dynIRT()
lout &lt;- dynIRT(.data = mq_data$data.mq,
                    .starts = mq_data$cur.mq,
                    .priors = mq_data$priors.mq,
                    .control = {list(
                    threads = 1,
                    verbose = TRUE,
                    thresh = 1e-6,
		    maxit=500
                    )})

## Extract estimate from variational model
## Delete point estimates of 0, which are justices missing from that session
vi.out &lt;- c(t(lout$means$x))
vi.out[vi.out==0] &lt;- NA
vi.out &lt;- na.omit(vi.out)

## Compare correlation against MCMC-estimated result
## Correlates at r=0.93 overall, and 0.96 when excluding Douglas
cor(vi.out, mq_data$mq_mcmc)	
cor(vi.out[mq_data$justiceName != "Douglas"],
 mq_data$mq_mcmc[mq_data$justiceName != "Douglas"])	


</code></pre>

<hr>
<h2 id='getStarts'> Generate Starts for <code>binIRT</code> </h2><span id='topic+getStarts'></span>

<h3>Description</h3>

 
<p><code>getStarts</code> generates starting values for <code>binIRT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getStarts(.N, .J, .D, .type = "zeros")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStarts_+3A_.n">.N</code></td>
<td>
<p> integer, number of subjects/legislators to generate starts for.</p>
</td></tr>
<tr><td><code id="getStarts_+3A_.j">.J</code></td>
<td>
<p> integer, number of items/bills to generate starts for.</p>
</td></tr>
<tr><td><code id="getStarts_+3A_.d">.D</code></td>
<td>
<p> integer, number of dimensions.</p>
</td></tr>
<tr><td><code id="getStarts_+3A_.type">.type</code></td>
<td>
<p> &ldquo;zeros&rdquo; and &ldquo;random&rdquo; are the only valid types, will generate starts accordingly.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>alpha</code></td>
<td>
<p>  A (J x 1) matrix of starting values for the item difficulty parameter <code class="reqn">alpha</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>  A (J x D) matrix of starting values for the item discrimination parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>  An (N x D) matrix of starting values for the respondent ideal points <code class="reqn">x_i</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:kimai@princeton.edu">kimai@princeton.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
Working Paper. Available at <a href="http://imai.princeton.edu/research/fastideal.html">http://imai.princeton.edu/research/fastideal.html</a>.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+binIRT">binIRT</a>', '<a href="#topic+makePriors">makePriors</a>', '<a href="#topic+convertRC">convertRC</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data from 109th US Senate
data(s109)

## Convert data and make starts/priors for estimation
rc &lt;- convertRC(s109)
p &lt;- makePriors(rc$n, rc$m, 1)
s &lt;- getStarts(rc$n, rc$m, 1)

## Conduct estimates
lout &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                }
                )

## Look at first 10 ideal point estimates
lout$means$x[1:10]

</code></pre>

<hr>
<h2 id='hierIRT'> Hierarchichal IRT estimation via Variational Inference </h2><span id='topic+hierIRT'></span>

<h3>Description</h3>

 
<p><code>hierIRT</code> estimates an hierarchical IRT model with two response categories, allowing the use of covariates
to help determine ideal point estimates. Estimation is conducted using the variational EM algorithm described
in the reference paper below. A special case of this model occurs when time/session is used as the covariate &mdash;
this allows legislator ideal points to vary over time with a parametric time trend.  Notably, the popular
DW-NOMINATE model (Poole and Rosenthal, 1997) is one such example, in which legislator ideal points shift
by a constant amount each period, and the error term in the hierarchical model is set to 0.  In contrast to
other functions in this package, this model does not assume a &lsquo;rectangular&rsquo; roll call matrix, and all data
are stored in vector form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  hierIRT(.data, .starts = NULL, .priors = NULL, .control = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierIRT_+3A_.data">.data</code></td>
<td>
<p> a list with the following items:
</p>

<dl>
<dt><code>y</code></dt><dd><p>  A (L x 1) matrix of observed votes. &lsquo;1&rsquo; and &lsquo;-1&rsquo; are the yea and nay codes.</p>
</dd>
<dt><code>i</code></dt><dd><p>  A (L x 1) integer matrix of indexes of the ideal point i[l] linked to each observed
vote l = 0 <code class="reqn">\ldots</code> L.  Indexes begin at 0 and reach a maximum value of I - 1.</p>
</dd>
<dt><code>j</code></dt><dd><p>  A (L x 1) integer matrix of indexes of the bill/item j[l] linked to each observed
vote l = 0 <code class="reqn">\ldots</code> L.  Indexes begin at 0 and reach a maximum value of J - 1.</p>
</dd>
<dt><code>g</code></dt><dd><p>  A (I x 1) integer matrix of indexes of the group membership g[i[l]] linked to each
ideal point i = 0 <code class="reqn">\ldots</code> I.  Indexes begin at 0 and reach a maximum value of G - 1.</p>
</dd>
<dt><code>z</code></dt><dd><p>  A (I x D) numeric matrix of observed covariates.  Rows correspond to ideal points
i = 0 <code class="reqn">\ldots</code> I.  The columns correspond to the D different covariates.  Typically, the first
column will be an intercept and fixed to 1, while other columns represent ideal point-specific covariates
such as session.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="hierIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters. The list should
contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of starting values for the item difficulty parameter <code class="reqn">\alpha_j</code>. </p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of starting values for the item discrimination parameter <code class="reqn">\beta_j</code>. </p>
</dd>
<dt><code>gamma</code></dt><dd><p>  An (I x D) matrix of starting values for the group level coefficients <code class="reqn">\gamma_{m}</code>. </p>
</dd>
<dt><code>eta</code></dt><dd><p>  An (I x 1) matrix of starting values for the ideal point error term <code class="reqn">\eta_n</code>.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>  An (G x 1) matrix of starting values for the group level variance parameter <code class="reqn">\sigma^2_m</code>. </p>
</dd>    
</dl>

</td></tr>
<tr><td><code id="hierIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters. The list should
contain the following matrices:
</p>

<dl>
<dt><code>gamma.mu</code></dt><dd><p>  A (D x 1) prior means matrix for all group level coefficients <code class="reqn">\gamma_{m}</code>.</p>
</dd>
<dt><code>gamma.sigma</code></dt><dd><p>  A (D x D) prior covariance matrix for all group level coefficients <code class="reqn">\gamma_{m}</code>.</p>
</dd>
<dt><code>beta.mu</code></dt><dd><p>  A (2 x 1) prior means matrix for all bill parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>beta.sigma</code></dt><dd><p>  A (2 x 2) prior covariance matrix for all bill parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>sigma.v</code></dt><dd><p>  A (1 x 1) matrix containing the group level variance prior parameter <code class="reqn">\nu_{\sigma}</code>.</p>
</dd>
<dt><code>sigma.s</code></dt><dd><p>  A (1 x 1) matrix containing the group level variance prior parameter <code class="reqn">s^2_{\sigma}</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="hierIRT_+3A_.control">.control</code></td>
<td>
<p>  list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core, but more can be
supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.  Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all parameters correlate at 1 - thresh across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run. Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations. Set at 50 by default.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>hierIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of point estimates for the item difficulty parameter <code class="reqn">\alpha_j</code>. </p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of point estimates for the item discrimination parameter <code class="reqn">\beta_j</code>. </p>
</dd>
<dt><code>gamma</code></dt><dd><p>  An (I x D) matrix of point estimates for the group level coefficients <code class="reqn">\gamma_{m}</code>. </p>
</dd>
<dt><code>eta</code></dt><dd><p>  An (I x 1) matrix of point estimates for the ideal point error term <code class="reqn">\eta_n</code>.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>  An (G x 1) matrix of point estimates for the group level variance parameter <code class="reqn">\sigma^2_m</code>. </p>
</dd>    
<dt><code>x_implied</code></dt><dd><p>  An (I x 1) matrix of the implied ideal point <code class="reqn">x_i</code>, calculated as a function of
gamma, z, and eta using the point estimates for those parameters. </p>
</dd>    
</dl>
                 
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for several parameters of interest for diagnostic
purposes. Note that these variances are those recovered via variational approximation, and in most cases they are
known to be far too small and generally unusable. The list should contain the following matrices:
</p>

<dl>
<dt><code>eta</code></dt><dd><p>  A (I x 1) matrix of variance estimates for the ideal point noise parameter <code class="reqn">\eta_n</code>.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>  A (G x D x D) cube of covariance estimates for the gamma parameters for each group.
Each of the G items is a matrix with a single covariance matrix for the m-th group's D gamma parameters.</p>
</dd>
<dt><code>beta2</code></dt><dd><p>  A (J x 2 x 2) cube of covariance estimates for the item parameters <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.
Each of the J items is a matrix with a single covariance matrix for the j-th item.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:</p>
</td></tr>
</table>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0 if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh argument in input to .control list.</p>
</dd>
</dl>
                 
<table>
<tr><td><code>N</code></td>
<td>
<p> A list of counts of various items:</p>
</td></tr>
</table>

<dl>
<dt><code>D</code></dt><dd><p>  integer, number of dimensions (i.e. number of covariates, including intercept).</p>
</dd>
<dt><code>G</code></dt><dd><p>  integer, number of groups.</p>
</dd>
<dt><code>I</code></dt><dd><p>  integer, number of ideal points.</p>
</dd>
<dt><code>J</code></dt><dd><p>  integer, number of items/bill parameters.</p>
</dd>
<dt><code>L</code></dt><dd><p>  integer, number of observed votes.</p>
</dd>    
</dl>
                 
<table>
<tr><td><code>call</code></td>
<td>
<p> Function call used to generate output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>James Lo <a href="mailto:lojames@usc.edu">lojames@usc.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Variational model is described in Kosuke Imai, James Lo, and Jonathan Olmsted &ldquo;Fast Estimation
of Ideal Points with Massive Data.&rdquo; American Political Science Review, Volume 110, Issue 4, November 2016, pp. 631-656. &lt;DOI:10.1017/S000305541600037X&gt;.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+dwnom">dwnom</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Real data example of US Senate 80-110 (not run)
### Based on voteview.com example of DW-NOMINATE (\url{https://voteview.com/})
### We estimate a hierarchical model without noise and a linear time covariate
### This model corresponds very closely to the DW-NOMINATE model

## Not run: 
data(dwnom)

## This takes about 10 minutes to run on 8 threads
## You may need to reduce threads depending on what your machine can support
lout &lt;- hierIRT(.data = dwnom$data.in,
                    .starts = dwnom$cur,
                    .priors = dwnom$priors,
                    .control = {list(
                    threads = 8,
                    verbose = TRUE,
                    thresh = 1e-4,
				    maxit=200,
				    checkfreq=1
                        )})

## Bind ideal point estimates back to legislator data
final &lt;- cbind(dwnom$legis, idealpt.hier=lout$means$x_implied)

## These are estimates from DW-NOMINATE as given on the Voteview example
## From file "SL80110C21.DAT"
nomres &lt;- dwnom$nomres

## Merge the DW-NOMINATE estimates to model results by legislator ID
## Check correlation between hierIRT() and DW-NOMINATE scores
res &lt;- merge(final, nomres, by=c("senate","id"),all.x=TRUE,all.y=FALSE)
cor(res$idealpt.hier, res$dwnom1d)


## End(Not run)
</code></pre>

<hr>
<h2 id='makePriors'> Generate Priors for <code>binIRT</code> </h2><span id='topic+makePriors'></span>

<h3>Description</h3>

 
<p><code>makePriors</code> generates diffuse priors for <code>binIRT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  makePriors(.N = 20, .J = 100, .D = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePriors_+3A_.n">.N</code></td>
<td>
<p> integer, number of subjects/legislators to generate priors for.</p>
</td></tr>
<tr><td><code id="makePriors_+3A_.j">.J</code></td>
<td>
<p> integer, number of items/bills to generate priors for.</p>
</td></tr>
<tr><td><code id="makePriors_+3A_.d">.D</code></td>
<td>
<p> integer, number of dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>x$mu</code></dt><dd><p>  A (D x D) prior means matrix for respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>x$sigma</code></dt><dd><p>  A (D x D) prior covariance matrix for respondent ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>beta$mu</code></dt><dd><p>  A ( D+1 x 1) prior means matrix for <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>beta$sigma</code></dt><dd><p>  A ( D+1 x D+1 ) prior covariance matrix for <code class="reqn">\alpha_j</code> and <code class="reqn">\beta_j</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted. (2016).  &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
Working Paper. American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+binIRT">binIRT</a>', '<a href="#topic+getStarts">getStarts</a>', '<a href="#topic+convertRC">convertRC</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data from 109th US Senate
data(s109)

## Convert data and make starts/priors for estimation
rc &lt;- convertRC(s109)
p &lt;- makePriors(rc$n, rc$m, 1)
s &lt;- getStarts(rc$n, rc$m, 1)

## Conduct estimates
lout &lt;- binIRT(.rc = rc,
                .starts = s,
                .priors = p,
                .control = {
                    list(threads = 1,
                         verbose = FALSE,
                         thresh = 1e-6
                         )
                }
                )

## Look at first 10 ideal point estimates
lout$means$x[1:10]

</code></pre>

<hr>
<h2 id='manifesto'>
German Manifesto Data
</h2><span id='topic+manifesto'></span>

<h3>Description</h3>

<p>A word frequency matrix containing word frequencies from 25 German party manifestos between 1990-2005.
Obtained from Slapin and Proksch AJPS paper, also used in Lo, Slapin and Proksch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(manifesto)
</code></pre>


<h3>Format</h3>

<p>list, containing the following elements:
</p>

<dl>
<dt>data.manif</dt><dd><p> Term-document matrix, formatted for input to <code>ordIRT()</code>.</p>
</dd>
<dt>starts.manif</dt><dd><p> Start values, formatted for input to <code>ordIRT()</code>. </p>
</dd>
<dt>priors.manif</dt><dd><p> Priors, formatted for input to <code>ordIRT()</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jonathan Slapin and Sven-Oliver Proksch. 2009. &ldquo;A Scaling Model for Estimating Time-Series Party
Positions from Texts.&rdquo; American Journal of Political Science 52(3), 705-722
</p>
<p>James Lo, Jonathan Slapin, and Sven-Oliver Proksch. 2016. &ldquo;Ideological Clarify in Multiparty
Competition: A New Measure and Test Using Election Manifestos.&rdquo; British Journal of Political
Science, 1-20
</p>
<p>Kosuke Imai, James Lo, and Jonathan Olmsted. (2016). &ldquo;Fast Estimation of Ideal
Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+poisIRT">poisIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Load German Manifesto data
data(manifesto)

## Estimate variational Wordfish model
lout &lt;- poisIRT(.rc = manifesto$data.manif,
		    i = 0:(ncol(manifesto$data.manif)-1),
		    NI=ncol(manifesto$data.manif),
                    .starts = manifesto$starts.manif,
                    .priors = manifesto$priors.manif,
                    .control = {list(
                        threads = 1,
                        verbose = TRUE,
                        thresh = 1e-6,
						maxit=1000
                        )})

## Positional Estimates for Parties
lout$means$x  

## End(Not run)

</code></pre>

<hr>
<h2 id='mq_data'>
Martin-Quinn Judicial Ideology Scores
</h2><span id='topic+mq_data'></span>

<h3>Description</h3>

<p>This data set contains materials related to the Martin-Quinn measures of judicial ideology,
estimated for every justice serving from October 1937 to October 2013.  The materials are
based on the July 23, 2014 (2014 Release 01) release of the Supreme Court Database, which
contain the votes of each Supreme Court justice on each case heard in the court.  The
data is set up for input to <code>dynIRT()</code>, and also includes point estimates of the same
model obtained using standard MCMC techniques.  Start values and priors input to this model
are identical to those used in the MCMC estimates, and were provided by Kevin Quinn. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mq_data)</code></pre>


<h3>Format</h3>

<p>list, containing the following elements:
</p>

<dl>
<dt>data.mq</dt><dd><p> Justice voting data, formatted for input to <code>dynIRT()</code>.</p>
</dd>
<dt>cur.mq</dt><dd><p> Start values, formatted for input to <code>dynIRT()</code>. </p>
</dd>
<dt>priors.mq</dt><dd><p> Priors, formatted for input to <code>dynIRT()</code>.</p>
</dd>
<dt>mq_mcmc</dt><dd><p> Ideal point estimates with data via MCMC.</p>
</dd>
<dt>justiceName</dt><dd><p> A vector of names identifying the justice that goes with each estimated ideal point.</p>
</dd>
</dl>



<h3>References</h3>

<p>Original model and the example is based off of Andrew Martin and Kevin Quinn, &ldquo;Dynamic Ideal
Point Estimation via Markov Chain Monte Carlo for the U.S. Supreme Court, 1953-1999.&rdquo; Political
Analysis 10(2) 134-153.
</p>
<p>Variational model is described in Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation
of Ideal Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+dynIRT">dynIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Replication of Martin-Quinn Judicial Ideology Scores
### Based on July 23, 2014 (2014 Release 01) release of the Supreme Court Database
### Start values and priors based on replication code provided by Kevin Quinn

data(mq_data)

## Estimate dynamic variational model using dynIRT()
lout &lt;- dynIRT(.data = mq_data$data.mq,
                    .starts = mq_data$cur.mq,
                    .priors = mq_data$priors.mq,
                    .control = {list(
                    threads = 1,
                    verbose = TRUE,
                    thresh = 1e-6,
		    maxit=500
                    )})

## Extract estimate from variational model
## Delete point estimates of 0, which are justices missing from that session
vi.out &lt;- c(t(lout$means$x))
vi.out[vi.out==0] &lt;- NA
vi.out &lt;- na.omit(vi.out)

## Compare correlation against MCMC-estimated result
## Correlates at r=0.93 overall, and 0.96 when excluding Douglas
cor(vi.out, mq_data$mq_mcmc)	
cor(vi.out[mq_data$justiceName != "Douglas"],
 mq_data$mq_mcmc[mq_data$justiceName != "Douglas"])	

</code></pre>

<hr>
<h2 id='networkIRT'> Network IRT estimation via EM </h2><span id='topic+networkIRT'></span>

<h3>Description</h3>

 
<p><code>networkIRT</code> estimates an IRT model with network in cells. Estimation
is conducted using the EM algorithm described in the reference paper below. The algorithm
generalizes a model by Slapin and Proksch (2009) that is commonly applied to manifesto
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   networkIRT(.y, .starts = NULL, .priors = NULL, .control = NULL,
    .anchor_subject = NULL, .anchor_item = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="networkIRT_+3A_.y">.y</code></td>
<td>
<p>  matrix, with 1 indicating a valid link and 0 otherwise.  Followers (usually voters) are on
rows, elites are on columns.  No NA values are permitted.</p>
</td></tr>
<tr><td><code id="networkIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters. 
The list should contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of starting values for politician propensity to be followed <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (N x 1) matrix of starting values for follower propensity to follow others <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>w</code></dt><dd><p>  An (J x 1) matrix of starting values for politician ideal points <code class="reqn">z</code>.</p>
</dd>
<dt><code>theta</code></dt><dd><p>  An (N x 1) matrix of starting values for the follower ideal points <code class="reqn">x</code>.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>  An (1 x 1) matrix, should generally be fixed to be 1.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="networkIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters.
The list should contain the following matrices (1x1) matrices:
</p>

<dl>
<dt><code>alpha$mu</code></dt><dd><p>  prior mean for <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>alpha$sigma</code></dt><dd><p>  prior variance for <code class="reqn">\alpha</code></p>
</dd>
<dt><code>beta$mu</code></dt><dd><p> prior mean for <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>beta$sigma</code></dt><dd><p> prior variance for <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>w$mu</code></dt><dd><p> prior mean for z.</p>
</dd>
<dt><code>w$sigma</code></dt><dd><p> prior variance for z</p>
</dd>
<dt><code>theta$mu</code></dt><dd><p> prior mean for x.</p>
</dd>
<dt><code>theta$sigma</code></dt><dd><p> prior variance for x.</p>
</dd>
<dt><code>gamma$mu</code></dt><dd><p>  Should be fixed to equal 1.</p>
</dd>
<dt><code>gamma$sigma</code></dt><dd><p>  Should be fixed to equal 1.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="networkIRT_+3A_.control">.control</code></td>
<td>
<p>list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core,
but more can be supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.
Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all parameters correlate at 1 - thresh across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run.
Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations.
Set at 50 by default.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="networkIRT_+3A_.anchor_subject">.anchor_subject</code></td>
<td>
<p>integer, specifying subject to use as identification anchor.</p>
</td></tr>
<tr><td><code id="networkIRT_+3A_.anchor_item">.anchor_item</code></td>
<td>
<p>integer, specifying item to use as identification anchor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>networkIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of point estimates for politician propensity to be followed <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (N x 1) matrix of point estimates for follower propensity to follow others <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>w</code></dt><dd><p>  An (J x 1) matrix of point estimates for politician ideal points <code class="reqn">z</code>.</p>
</dd>
<dt><code>theta</code></dt><dd><p>  An (N x 1) matrix of point estimates for the follower ideal points <code class="reqn">x</code>.</p>
</dd>                
</dl>

</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for parameters corresponding
to the inputs for the priors.  Note that these variances are those recovered via variational approximation,
and in most cases they are known to be far too small and generally unusable.  Better estimates of variances
can be obtained manually via the parametric bootstrap.  The list should contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of variance estimates for politician propensity to be followed <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (N x 1) matrix of variance estimates for follower propensity to follow others <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>w</code></dt><dd><p>  An (J x 1) matrix of variance estimates for politician ideal points <code class="reqn">z</code>.</p>
</dd>
<dt><code>theta</code></dt><dd><p>  An (N x 1) matrix of variance estimates for the follower ideal points <code class="reqn">x</code>.</p>
</dd>                
</dl>
                 
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:</p>
</td></tr>
</table>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0
if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh
argument in input to .control list.</p>
</dd>
</dl>
                 
<table>
<tr><td><code>N</code></td>
<td>
<p> Number of followers in estimation, should correspond to number of rows in data matrix .y</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p> Number of politicians in estimation, should correspond to number of columns in data matrix .y</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> Function call used to generate output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@Harvard.edu">imai@Harvard.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation of Ideal
Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+ustweet">ustweet</a>'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(ustweet)

## A ridiculously short run to pass CRAN
## For a real test, set maxit to a more reasonable number to reach convergence
lout &lt;- networkIRT(.y = ustweet$data,
                   .starts = ustweet$starts,
                   .priors = ustweet$priors,
                   .control = {list(verbose = TRUE,
                                    maxit = 3,
                                    convtype = 2,
                                    thresh = 1e-6,
                                    threads = 1
                                    )
                           },
                   .anchor_item = 43
                   )


## End(Not run)

</code></pre>

<hr>
<h2 id='ordIRT'> Two-parameter Ordinal IRT estimation via EM </h2><span id='topic+ordIRT'></span>

<h3>Description</h3>

 
<p><code>ordIRT</code> estimates an ordinal IRT model with three ordered response categories. Estimation
is conducted using the EM algorithm described in the reference paper below. The algorithm will
produce point estimates that are comparable to those of <code><a href="MCMCpack.html#topic+MCMCordfactanal">MCMCordfactanal</a></code>,
but will do so much more rapidly and also scale better with larger data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ordIRT(.rc, .starts = NULL, .priors = NULL, .D = 1L, .control = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordIRT_+3A_.rc">.rc</code></td>
<td>
<p>  matrix of numeric values containing the data to be scaled.  Respondents are
assumed to be on rows, and items assumed to be on columns, so the matrix is assumed to be
of dimension (N x J).  For each item, only 3 ordered category responses are accepted, and the
only allowable responses are &lsquo;1&rsquo;, &lsquo;2&rsquo;, and &lsquo;3&rsquo;, with &lsquo;0&rsquo; as a missing data record. If data
of more than 3 categories are to be rescaled, they should be collapsed into 3 categories and
recoded accordingly before proceeding.</p>
</td></tr>
<tr><td><code id="ordIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters. Note that
the parameters here correspond to the re-parameterized version of the model (i.e. alpha is <code class="reqn">alpha^*</code>,
not the original <code class="reqn">alpha_{1j}</code>  The list should contain the following matrices:
</p>

<dl>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of starting values for the reparameterized item discrimination parameter <code class="reqn">\beta^*</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (N x 1) matrix of starting values for the respondent ideal points <code class="reqn">x_t</code>.</p>
</dd>
<dt><code>tau</code></dt><dd><p>  A (J x 1) matrix of starting values for the bill cutpoint <code class="reqn">\tau_j</code>.</p>
</dd>
<dt><code>DD</code></dt><dd><p>  A (J x 1) matrix of starting values for the squared bill cutpoint difference <code class="reqn">\tau_j^2</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="ordIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters. Note that
the parameters here correspond to the re-parameterized version of the model (i.e. alpha is <code class="reqn">\alpha^*</code>,
not the original <code class="reqn">\alpha_{1j}</code>  The list should contain the following matrices:
</p>

<dl>
<dt><code>x$mu</code></dt><dd><p>  A (1 x 1) prior means matrix for respondent ideal points <code class="reqn">x_t</code>.</p>
</dd>
<dt><code>x$sigma</code></dt><dd><p>  A (1 x 1) prior covariance matrix for respondent ideal points <code class="reqn">x_t</code>.</p>
</dd>
<dt><code>beta$mu</code></dt><dd><p>  A (2 x 1) prior means matrix for <code class="reqn">\tau_j</code> and <code class="reqn">\beta^*</code>.</p>
</dd>
<dt><code>beta$sigma</code></dt><dd><p>  A (2 x 2) prior covariance matrix for <code class="reqn">\tau_j</code> and <code class="reqn">\beta^*</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="ordIRT_+3A_.d">.D</code></td>
<td>
<p> integer, indicates number of dimensions. Only one dimension is implemented and this argument is ignored.</p>
</td></tr>
<tr><td><code id="ordIRT_+3A_.control">.control</code></td>
<td>
<p>list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core, but more can be
supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.  Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all parameters correlate at 1 - thresh across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run. Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations. Set at 50 by default.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ordIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x 1) matrix of point estimates for the respondent ideal points <code class="reqn">x_t</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of point estimates for the reparameterized item discrimination parameter <code class="reqn">\beta^*</code>.</p>
</dd>
<dt><code>tau</code></dt><dd><p>  A (J x 1) matrix of point estimates for the bill cutpoint <code class="reqn">\alpha^*</code>.</p>
</dd>
<dt><code>Delta_sq</code></dt><dd><p>  A (J x 1) matrix of point estimates for the squared bill cutpoint difference <code class="reqn">\tau_j^2</code>.</p>
</dd>
<dt><code>Delta</code></dt><dd><p>  A (J x 1) matrix of point estimates for the bill cutpoint difference <code class="reqn">\tau_j</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for parameters corresponding
to the inputs for the priors.  Note that these variances are those recovered via variational approximation,
and in most cases they are known to be far too small and generally unusable.  Better estimates of variances
can be obtained manually via the parametric bootstrap.  The list should contain the following matrices:
</p>

<dl>
<dt><code>x</code></dt><dd><p>  A (N x 1) matrix of variances for the respondent ideal points <code class="reqn">x_t</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of variances for the reparameterized item discrimination parameter <code class="reqn">\beta^*</code>.</p>
</dd>
<dt><code>tau</code></dt><dd><p>  A (J x 1) matrix of variances for the bill cutpoint <code class="reqn">\tau_j</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:</p>
</td></tr>
</table>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0 if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh argument in input to .control list.</p>
</dd>
</dl>
                 
<table>
<tr><td><code>n</code></td>
<td>
<p> Number of respondents in estimation, should correspond to number of rows in roll call matrix.</p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p> Number of items in estimation, should correspond to number of columns in roll call matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> Function call used to generate output.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@Harvard.edu">imai@Harvard.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation of Ideal
Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+AsahiTodai">AsahiTodai</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
### Real data example: Asahi-Todai survey (not run)
## Collapses 5-category ordinal survey items into 3 categories for estimation
data(AsahiTodai)
out.varinf &lt;- ordIRT(.rc = AsahiTodai$dat.all, .starts = AsahiTodai$start.values,
					.priors = AsahiTodai$priors, .D = 1,
					.control = {list(verbose = TRUE,
                     thresh = 1e-6, maxit = 500)})

## Compare against MCMC estimates using 3 and 5 categories
cor(ideal3, out.varinf$means$x)
cor(ideal5, out.varinf$means$x)  

## End(Not run)


### Monte Carlo simulation of ordIRT() model vs. known parameters
## Set number of legislators and items
set.seed(2)
NN &lt;- 500
JJ &lt;- 100

## Simulate true parameters from original model
x.true &lt;- runif(NN, -2, 2)
beta.true &lt;- runif(JJ, -1, 1)
tau1 &lt;- runif(JJ, -1.5, -0.5)
tau2 &lt;- runif(JJ, 0.5, 1.5)
ystar &lt;- x.true %o% beta.true + rnorm(NN *JJ)

## These parameters are not needed, but correspond to reparameterized model
#d.true &lt;- tau2 - tau1
#dd.true &lt;- d.true^2
#tau_star &lt;- -tau1/d.true
#beta_star &lt;- beta.true/d.true

## Generate roll call matrix using simulated parameters
newrc &lt;- matrix(0, NN, JJ)
for(j in 1:JJ) newrc[,j] &lt;- cut(ystar[,j], c(-100, tau1[j], tau2[j],100), labels=FALSE)

## Generate starts and priors
cur &lt;- vector(mode = "list")
cur$DD &lt;- matrix(rep(0.5,JJ), ncol=1)
cur$tau &lt;- matrix(rep(-0.5,JJ), ncol=1)
cur$beta &lt;- matrix(runif(JJ,-1,1), ncol=1) 
cur$x &lt;- matrix(runif(NN,-1,1), ncol=1) 
priors &lt;- vector(mode = "list")
priors$x &lt;- list(mu = matrix(0,1,1), sigma = matrix(1,1,1) )
priors$beta &lt;- list(mu = matrix(0,2,1), sigma = matrix(diag(25,2),2,2))

## Call ordIRT() with inputs
time &lt;- system.time({
    lout &lt;- ordIRT(.rc = newrc,
                    .starts = cur,
                    .priors = priors,
                    .control = {list(
                        threads = 1,
                        verbose = TRUE,
                        thresh = 1e-6,
			maxit=300,
			checkfreq=50
                        )})
})

## Examine runtime and correlation of recovered ideal points vs. truth
time
cor(x.true,lout$means$x)

</code></pre>

<hr>
<h2 id='poisIRT'> Poisson IRT estimation via EM </h2><span id='topic+poisIRT'></span>

<h3>Description</h3>

 
<p><code>poisIRT</code> estimates an IRT model with count (usually word counts) in cells. Estimation
is conducted using the EM algorithm described in the reference paper below. The algorithm
generalizes a model by Slapin and Proksch (2009) that is commonly applied to manifesto
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    poisIRT(.rc, i = 0:(nrow(.rc)-1), NI = nrow(.rc), .starts = NULL, .priors = NULL,
    .control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisIRT_+3A_.rc">.rc</code></td>
<td>
<p>  matrix, usually with unique words along the J rows and different documents across K columns.
Each cell will contain a count of words.  There should be no NA values, so documents missing a particular
word should list 0 in the cell.</p>
</td></tr>
<tr><td><code id="poisIRT_+3A_i">i</code></td>
<td>
<p>  vector of length K, indicating for each of the K documents which actor it belongs to. Assignment
of actors begins at actor 0.  If set to 0:(K-1), and NI=K below, then each document
is assigned its own ideal point, and we get the Slapin and Proksch Wordfish model.</p>
</td></tr>
<tr><td><code id="poisIRT_+3A_ni">NI</code></td>
<td>
<p>  integer, number of unique actors.  Must be less than or equal to K.  If NI=K, then each document
is assigned its own ideal point, and we get the Slapin and Proksch Wordfish model.</p>
</td></tr>
<tr><td><code id="poisIRT_+3A_.starts">.starts</code></td>
<td>
<p> a list containing several matrices of starting values for the parameters. 
The list should contain the following matrices:
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of starting values for the word frequency parameter <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>psi</code></dt><dd><p>  A (K x 1) matrix of starting values for the document verbosity parameter <code class="reqn">psi</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of starting values for the word discrimination parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (NI x 1) matrix of starting values for the actor ideal points <code class="reqn">x_i</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="poisIRT_+3A_.priors">.priors</code></td>
<td>
<p>  list, containing several matrices of starting values for the parameters.
The list should contain the following matrices:
</p>

<dl>
<dt><code>x$mu</code></dt><dd><p>  numeric, prior mean for actor ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>x$sigma2</code></dt><dd><p>   numeric, prior variance for actor ideal points <code class="reqn">x_i</code>.</p>
</dd>
<dt><code>beta$mu</code></dt><dd><p>  numeric, prior mean for <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>beta$sigma2</code></dt><dd><p>  numeric, prior variance for <code class="reqn">\beta_j</code>.</p>
</dd>
<dt><code>alpha$mu</code></dt><dd><p>  numeric, prior mean for <code class="reqn">\alpha_j</code>.</p>
</dd>
<dt><code>alpha$sigma2</code></dt><dd><p>  numeric, prior variance for <code class="reqn">\alpha_j</code></p>
</dd>
<dt><code>psi$mu</code></dt><dd><p>  numeric, prior mean for <code class="reqn">\psi_k</code>.</p>
</dd>
<dt><code>psi$sigma2</code></dt><dd><p>  numeric, prior variance for <code class="reqn">\psi_k</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="poisIRT_+3A_.control">.control</code></td>
<td>
<p>list, specifying some control functions for estimation.  Options include the following:
</p>

<dl>
<dt><code>threads</code></dt><dd><p>  integer, indicating number of cores to use. Default is to use a single core, but more can be
supported if more speed is desired.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>  boolean, indicating whether output during estimation should be verbose or not.  Set FALSE by default.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>  numeric. Algorithm will run until all parameters correlate at 1 - thresh across
consecutive iterations. Set at 1e-6 by default.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>  integer. Sets the maximum number of iterations the algorithm can run. Set at 500 by default.</p>
</dd>
<dt><code>checkfreq</code></dt><dd><p>  integer. Sets frequency of verbose output by number of iterations. Set at 50 by default.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>poisIRT</code>.
</p>
<table>
<tr><td><code>means</code></td>
<td>
<p> list, containing several matrices of point estimates for the parameters corresponding
to the inputs for the priors.  The list should contain the following matrices.
</p>

<dl>
<dt><code>alpha</code></dt><dd><p>  A (J x 1) matrix of point estimates for the word frequency parameter <code class="reqn">alpha</code>.</p>
</dd>
<dt><code>psi</code></dt><dd><p>  A (K x 1) matrix of point estimates for the document verbosity parameter <code class="reqn">psi</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of point estimates for the word discrimination parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (NI x 1) matrix of point estimates for the actor ideal points <code class="reqn">x_i</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p> list, containing several matrices of variance estimates for parameters corresponding
to the inputs for the priors.  Note that these variances are those recovered via variational approximation,
and in most cases they are known to be far too small and generally unusable.  Better estimates of variances
can be obtained manually via the parametric bootstrap.  The list should contain the following matrices:
</p>

<dl>
<dt><code>beta</code></dt><dd><p>  A (J x 1) matrix of variational variance estimates for the word discrimination parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>  An (NI x 1) matrix of variational variance estimates for the actor ideal points <code class="reqn">x_i</code>.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> A list of fit results, with elements listed as follows:
</p>

<dl>
<dt><code>iters</code></dt><dd><p>  integer, number of iterations run.</p>
</dd>
<dt><code>conv</code></dt><dd><p>  integer, convergence flag. Will return 1 if threshold reached, and 0 if maximum number of iterations reached.</p>
</dd>
<dt><code>threads</code></dt><dd><p>  integer, number of threads used to estimated model.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>  numeric, tolerance threshold for convergence.  Identical to thresh argument in input to .control list.</p>
</dd>
</dl>
                 
</td></tr>
<tr><td><code>N</code></td>
<td>
<p> A list of sizes, with elements listed as follow:
</p>

<dl>
<dt>K</dt><dd><p> Number of unique words in term-document matrix.</p>
</dd>
<dt>J</dt><dd><p> Number of documents in term-document matrix.</p>
</dd>
<dt>I</dt><dd><p> Number of actors in model, always less than or equal to J.</p>
</dd>
<dt>call</dt><dd><p> Function call used to generate output.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>i_of_k</code></td>
<td>
<p> A copy of input for argument &lsquo;i&rsquo;, which allows the J documents to be linked to I actors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a>
</p>
<p>James Lo <a href="mailto:jameslo@princeton.edu">jameslo@princeton.edu</a>
</p>
<p>Jonathan Olmsted <a href="mailto:jpolmsted@gmail.com">jpolmsted@gmail.com</a>
</p>


<h3>References</h3>

<p>Kosuke Imai, James Lo, and Jonathan Olmsted (2016). &ldquo;Fast Estimation of Ideal
Points with Massive Data.&rdquo; American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+manifesto">manifesto</a>'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Load German Manifesto data
data(manifesto)

## Estimate variational Wordfish model
lout &lt;- poisIRT(.rc = manifesto$data.manif,
		    i = 0:(ncol(manifesto$data.manif)-1),
		    NI=ncol(manifesto$data.manif),
                    .starts = manifesto$starts.manif,
                    .priors = manifesto$priors.manif,
                    .control = {list(
                        threads = 1,
                        verbose = TRUE,
                        thresh = 1e-6,
						maxit=1000
                        )})

## Positional Estimates for Parties
lout$means$x  

## End(Not run)

</code></pre>

<hr>
<h2 id='ustweet'>
U.S. Twitter Following Data
</h2><span id='topic+ustweet'></span>

<h3>Description</h3>

<p>Data from U.S. Twitter follower data, obtained from Barbera's (2015) replication archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ustweet)</code></pre>


<h3>Format</h3>

<p>list, containing the following elements:
</p>

<dl>
<dt>data</dt><dd><p> Term-document matrix, formatted for input to <code>networkIRT()</code>.</p>
</dd>
<dt>starts</dt><dd><p> Start values, formatted for input to <code>networkIRT()</code>. </p>
</dd>
<dt>priors</dt><dd><p> Priors, formatted for input to <code>networkIRT()</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Pablo Barbera. 2015. &ldquo;Birds of the Same Feather Tweet Together: Bayesian Ideal Point Estimation
Using Twitter Data.&rdquo; Political Analysis 23(1), 76-91
</p>
<p>Kosuke Imai, James Lo, and Jonathan Olmsted. (2016). &ldquo;Fast Estimation of Ideal Points with Massive Data.&rdquo;
American Political Science Review, Vol. 110, No. 4 (December), pp. 631-656.
</p>


<h3>See Also</h3>

<p>'<a href="#topic+networkIRT">networkIRT</a>'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(ustweet)

## A ridiculously short run to pass CRAN
## For a real test, set maxit to a more reasonable number to reach convergence
lout &lt;- networkIRT(.y = ustweet$data,
                   .starts = ustweet$starts,
                   .priors = ustweet$priors,
                   .control = {list(verbose = TRUE,
                                    maxit = 3,
                                    convtype = 2,
                                    thresh = 1e-6,
                                    threads = 1
                                    )
                           },
                   .anchor_item = 43
                   )


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
