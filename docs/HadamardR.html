<!DOCTYPE html><html><head><title>Help for package HadamardR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HadamardR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HadamardR-package'><p>Hadamard Matrices</p></a></li>
<li><a href='#antidiagnol'><p>antidiagnol</p></a></li>
<li><a href='#base_to_T'><p>Base_to_T</p></a></li>
<li><a href='#baseseq'><p>baseseq</p></a></li>
<li><a href='#cdn_baumert'><p>cdn_baumert</p></a></li>
<li><a href='#cdn_cooper'><p>cdn_cooper</p></a></li>
<li><a href='#cdn_ehlich'><p>cdn_ehlich</p></a></li>
<li><a href='#cdn_goethals_base'><p>cdn_goethals_base</p></a></li>
<li><a href='#cdn_goethals_T'><p>cdn_goethals_T</p></a></li>
<li><a href='#cdn_goethals_Turyn'><p>cdn_goethals_Turyn</p></a></li>
<li><a href='#cdn_kronecker_matrix'><p>cdn_kronecker_matrix</p></a></li>
<li><a href='#cdn_miyamoto'><p>cdn_miyamoto</p></a></li>
<li><a href='#cdn_PaleyI'><p>cdn_PaleyI</p>
Checks Hadamard Matrix can be constructed using Paley I method.</a></li>
<li><a href='#cdn_PaleyII'><p>cdn_PaleyII</p>
Checks Hadamard Matrix can be constructed using Paley II method.</a></li>
<li><a href='#cdn_PaleyIIprimepower'><p>cdn_PaleyIIprimepower</p>
checks Hadamard Matrix can be constructed using Paley II  method.</a></li>
<li><a href='#cdn_PaleyIprimepower'><p>cdn_PaleyIprimepower</p>
checks Hadamard Matrix can be constructed using Paley I method.</a></li>
<li><a href='#cdn_sds'><p>cdn_sds</p></a></li>
<li><a href='#cdn_williamson'><p>cdn_williamson</p></a></li>
<li><a href='#check_hadamard'><p>check_hadamard</p></a></li>
<li><a href='#circulant_mat'><p>circulant_mat</p></a></li>
<li><a href='#get_cooper'><p>get_cooper</p></a></li>
<li><a href='#Get_method'><p>Get_method</p></a></li>
<li><a href='#GFADD'><p>GFADD</p></a></li>
<li><a href='#GFCheck'><p>GFCheck</p></a></li>
<li><a href='#GFELEM'><p>GFELEM</p></a></li>
<li><a href='#GFM'><p>GFM</p>
GFM Generate Multiplication table of GF(p^r), where p is a prime power.</a></li>
<li><a href='#GFMult'><p>GFMult</p>
GFMult Generate Multiplication table of GF(p^r), where p is a prime power.</a></li>
<li><a href='#GFPrimeAdd'><p>GFPrimeAdd</p></a></li>
<li><a href='#GFPrimeMult'><p>GFPrimeMult</p>
GFPrimeMult creates Multiplication Table for GF(p), where p is a prime number</a></li>
<li><a href='#goethals_seidel_array'><p>goethals_seidel_array</p></a></li>
<li><a href='#had_baumert'><p>had_baumert</p></a></li>
<li><a href='#had_cooper'><p>had_cooper</p></a></li>
<li><a href='#had_ehlich'><p>had_ehlich</p></a></li>
<li><a href='#had_goethals_base'><p>had_goethals_base</p></a></li>
<li><a href='#had_goethals_T'><p>had_goethals_T</p>
had_goethals_Turyn performs the Hadamard Matrix from Goethals-Seidel method
by using T sequences.</a></li>
<li><a href='#had_goethals_Turyn'><p>had_goethals_Turyn</p></a></li>
<li><a href='#had_kronecker'><p>had_kronecker</p></a></li>
<li><a href='#Had_method'><p>Had_method</p></a></li>
<li><a href='#had_miyamoto'><p>had_miyamoto</p></a></li>
<li><a href='#had_SDS'><p>had_SDS</p></a></li>
<li><a href='#had_williamson'><p>had_williamson</p></a></li>
<li><a href='#Hadamard_Matrix'><p>Hadamard_Matrix</p></a></li>
<li><a href='#Hadamard_matrix_method'><p>Hadamard_Matrix_method</p></a></li>
<li><a href='#Initial_row_SDS'><p>Initial_row_SDS</p>
Initial_row_SDS is an internal function.Not Exported.</a></li>
<li><a href='#is_divisible'><p>is_divisible</p></a></li>
<li><a href='#is.prime'><p>is.prime</p></a></li>
<li><a href='#is.primepower'><p>is.primepower</p></a></li>
<li><a href='#Jmat'><p>Jmat</p></a></li>
<li><a href='#kro_method'><p>kro_method</p></a></li>
<li><a href='#kronecker_matrix'><p>kronecker_matrix</p></a></li>
<li><a href='#method1_paleyII'><p>method1_paleyII</p></a></li>
<li><a href='#method2_paleyII'><p>method2_paleyII</p></a></li>
<li><a href='#miyamotoC'><p>miyamotoC</p></a></li>
<li><a href='#nextElem'><p>nextElem</p></a></li>
<li><a href='#Normcol'><p>Normcol</p>
Normcol performs the Normalisation of column the given matrix.</a></li>
<li><a href='#Normrow'><p>Normrow</p>
Normcol performs the Normalisation of row the given matrix.</a></li>
<li><a href='#PaleyI'><p>PaleyI</p></a></li>
<li><a href='#PaleyII'><p>PaleyII</p></a></li>
<li><a href='#PaleyIIPrimePower'><p>PaleyIIPrimePower</p></a></li>
<li><a href='#PaleyIPrimePower'><p>PaleyIPrimePower</p></a></li>
<li><a href='#ply1'><p>ply1</p></a></li>
<li><a href='#ply2'><p>ply2</p></a></li>
<li><a href='#pow'><p>pow</p></a></li>
<li><a href='#qhad2'><p>qhad2</p></a></li>
<li><a href='#QPrimePower'><p>QPrimePower</p>
QPrimePower creats the Quadratic residues of the prime number.</a></li>
<li><a href='#quadprime'><p>quadprime</p></a></li>
<li><a href='#seq_williamson'><p>seq_williamson</p></a></li>
<li><a href='#T_seq'><p>T_seq</p>
T_seq performs the selection of the T sequences from dataset.internal function not exported.</a></li>
<li><a href='#Turyn_seq'><p>Turyn_seq</p>
Turyn_seq performs the selection of the Turyn sequences from dataset.
It is internal function not exported.</a></li>
<li><a href='#Turyn_to_T'><p>Turyn_to_T</p>
internal function. converts Turyn sequences to Base Sequences.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hadamard Matrix Generation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Appavoo Dhandapani &lt;dhandapani.appavoo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates Hadamard matrices using different construction methods. For those who want to generate Hadamard matrix, a generic function, Hadamard_matrix() is provided. For those who want to generate Hadamard matrix using a particular method, separate functions are available. See Horadam (2007, ISBN:9780691119212) Hadamard Matrices and their applications, Princeton University Press for more information on Hadamard Matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>numbers, openxlsx</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-06 16:23:21 UTC; Dhandapani</td>
</tr>
<tr>
<td>Author:</td>
<td>Appavoo Dhandapani
    <a href="https://orcid.org/0000-0001-7436-2723"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Revan Siddesha [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-07 15:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HadamardR-package'>Hadamard Matrices</h2><span id='topic+HadamardR-package'></span>

<h3>Description</h3>

<p>A square matrix H of order n with entries +1 or -1 is called Hadamard Matrix, if HH'=nI, where I is Identity matrix. Necessary condition for Hadamard matrix of order n exists when n = 1,2 or 0(mod 4).
</p>


<h3>Details</h3>

<p>Using HadamardR, Hadamard Matrices of various orders can be generated. Out of 1250 possible Hadamard Matrices of order &lt; 5000 (ignoring trivial orders 1 and 2), the construction methods are not known for 45 orders; 1158 orders are possible using Hadamard_Matrix() function. 47 Hadamard matrices not available in this package are as follows:
1336, 1432, 1940, 2212, 2264, 2292, 2316, 2488, 2740, 2776, 2864, 2872,
3140, 3352, 3476, 3544, 3620, 3684, 3704, 3708, 3820, 3832, 3880, 3892,
3896, 3928, 3972, 3980, 4044, 4120, 4152, 4184, 4268, 4296, 4304, 4344,
4396, 4404, 4432, 4528, 4572, 580, 4632, 4740, 4792, 4812, 4976
</p>

<hr>
<h2 id='antidiagnol'>antidiagnol</h2><span id='topic+antidiagnol'></span>

<h3>Description</h3>

<p>antidiagnol performs the creation of Back diagnol matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antidiagnol(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antidiagnol_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An anti-diagonal matrix is a square matrix where all the entries are
zero except those on the diagonal going from the lower left corner to the upper right
corner entries are equal to 1.
</p>
<p>In the first row, the last column will be 1 and all other entries are 0.
</p>
<p>In second row, last but one column is 1 and others are 0 and so on.
</p>


<h3>Value</h3>

<p>Antidiagnol matrix of order n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>antidiagnol(4)
#0    0    0    1
#0    0    1    0
#0    1    0    0
#1    0    0    0
</code></pre>

<hr>
<h2 id='base_to_T'>Base_to_T</h2><span id='topic+base_to_T'></span>

<h3>Description</h3>

<p>internal function and it is not exported. It converts base sequences to T-Sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_to_T(dat, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_to_T_+3A_dat">dat</code></td>
<td>
<p>is the frame containing basesequences to be exported</p>
</td></tr>
<tr><td><code id="base_to_T_+3A_x">x</code></td>
<td>
<p>integer (order of the base sequence)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dat - Internal dataset containing 4 sequences in long form with lentgh n+p,n+p,n,n. Using the 4 basequences,
the function creates 4 sequences of length 2n+p,2n+p,2n+p,2n+p.
T-Sequnces are usually used in creating matrices of Goethel Seidal array.
</p>


<h3>Value</h3>

<p>4 T-sequences of length of 2x+p.
</p>


<h3>Source</h3>

<p>The Base sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>

<hr>
<h2 id='baseseq'>baseseq</h2><span id='topic+baseseq'></span>

<h3>Description</h3>

<p>Extracts the selection of Basesequences from internal dataset. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseseq(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseseq_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create Basesequence of given order from the internal dataset Basesequence
Base sequences are available in the internal table for order= 1:35
</p>


<h3>Value</h3>

<p>Required Basesequences of order of x
</p>


<h3>Source</h3>

<p>The Base sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>

<hr>
<h2 id='cdn_baumert'>cdn_baumert</h2><span id='topic+cdn_baumert'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using Baumert-Hall arrays of order 12.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_baumert(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_baumert_+3A_order">order</code></td>
<td>
<p>integer, order of Hadamard matrix to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baumert-Hall array is a generalization of Williamson Array.
In case, Williamson matrices are available for order/12, the method
return 6 otherwise it returns NULL.
</p>
<p>The availabile Williamson sequences in the internal data sets is
seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>


<h3>Value</h3>

<p>6 or NULL
</p>


<h3>References</h3>

<p>Hedayat, A. and Wallis, W. D.(1978).  Hadamard Matrices and Their Applications. Ann. Stat. 6: 1184-1238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_baumert">had_baumert</a></code> for Baumert-Hall's construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_baumert(36)
#6
cdn_baumert(72)
#NULL
</code></pre>

<hr>
<h2 id='cdn_cooper'>cdn_cooper</h2><span id='topic+cdn_cooper'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using Williamson arrays and T- sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_cooper(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_cooper_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cooper-Wallis is a construction of Hadamard matrices which combines
Williamson matrices and T-sequences.
</p>
<p>The availabile Williamson sequences in the internal data sets is
seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>
<p>The availabile T- sequences in the internal data sets is seq(1,73,2) and
83, 101, 107.
</p>


<h3>Value</h3>

<p>11 or NULL
</p>


<h3>References</h3>

<p>Cooper, J., and Wallis, W., D. (1972). A construction for Hadamard arrays. Bull. Austral. Math. 7, 269-278.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_cooper">had_cooper</a></code> for Cooper-Wallis construction method.
<code><a href="#topic+get_cooper">get_cooper</a></code> for finding order of Williamson and T-Sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_cooper(20)
#11
cdn_cooper(16)
#NULL
</code></pre>

<hr>
<h2 id='cdn_ehlich'>cdn_ehlich</h2><span id='topic+cdn_ehlich'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using Ehlich's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_ehlich(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_ehlich_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ehlich (1965)'s construction method requires order of the Hadamard
matrix must be a of the form (n-1)^2. Conditions are (i)Order=(n-1)^2;
(ii) n is a prime or prime power and 3(mod 4). (iii) (n-2) must be a
prime or prime power. In case, if all the three conditions are satisfied,
function will return 4 or NULL.
</p>


<h3>Value</h3>

<p>4 or NULL
</p>


<h3>References</h3>

<p>Ehlich, H. (1965). Neue Hadamard-matrizen. Arch. Math., 16, 34-36.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_ehlich">had_ehlich</a></code> for Ehlich's construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_ehlich(36)
#Condition 1:(n-1)^2 = 36 = 6^2
#Condition 2: n=7 (prime)and n=3(mod 4)
#Condition 3: n-2=5 (prime)
#Return
#4
cdn_ehlich(64)
#Condition 1:(n-1)^2 = 64 = 8^2
#Condition 2: n=9 (prime power) but n=1(mod 4).
#Condition 2 fails
#Return
#NULL
</code></pre>

<hr>
<h2 id='cdn_goethals_base'>cdn_goethals_base</h2><span id='topic+cdn_goethals_base'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using available base sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_goethals_base(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_goethals_base_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix of given order can be constructed using base sequences.
If base sequences of length n+1,n+1,n,n are available, T-sequences of length 2n+1,2n+1,2n+1,2n+1 can be constructed.
From T-sequence of length 2n+1, Hadamard matrix of order 4(2n+1) can be constructed.
Returns the value 7, if it is possible otherwise NULL is returned.
</p>
<p>Base sequences are available in the internal dataset is  1:35
</p>


<h3>Value</h3>

<p>7 or NULL
</p>


<h3>Source</h3>

<p>The Base sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_base">had_goethals_base</a></code> for Goethals-Seidel construction method.
</p>
<p><code><a href="#topic+baseseq">baseseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_goethals_base(20)
#7
cdn_goethals_base(24)
#NULL

</code></pre>

<hr>
<h2 id='cdn_goethals_T'>cdn_goethals_T</h2><span id='topic+cdn_goethals_T'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using available T-sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_goethals_T(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_goethals_T_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix of given order can be constructed using T sequences.
If T sequences of length n,n,n,n are available, Hadamard matrix of order 4n can be constructed.
Returns the value 13, if it is possible otherwise NULL is returned.
</p>
<p>T-sequences are available for length of seq(1,73,2) and for 83, 101 and 107 in the internal table.
</p>


<h3>Value</h3>

<p>13 or NULL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_T">had_goethals_T</a></code> for Goethals-Seidel construction method using T-sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_goethals_T(28)
#T-seqeunce of length 7 exists.
#13
cdn_goethals_T(24)
#T-sequence of length 6 does not exist.
#NULL
</code></pre>

<hr>
<h2 id='cdn_goethals_Turyn'>cdn_goethals_Turyn</h2><span id='topic+cdn_goethals_Turyn'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using available Turyn Type sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_goethals_Turyn(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_goethals_Turyn_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix of given order can be constructed using Turyn sequences.
If Turyn sequences of (order+4)/12 is available then Hadamard matrix of order exists.
Returns the value 8, if it is possible otherwise NULL is returned.
</p>
<p>Turyn type-sequences are available for 28,30,34,36 in the internal table.
</p>


<h3>Value</h3>

<p>8 or NULL
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_Turyn">had_goethals_Turyn</a></code> for Goethals-Seidel construction method using Turyn sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_goethals_Turyn(356)
#8
cdn_goethals_Turyn(40)
#NULL
</code></pre>

<hr>
<h2 id='cdn_kronecker_matrix'>cdn_kronecker_matrix</h2><span id='topic+cdn_kronecker_matrix'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed by multiplying 2 existing Hadamard matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_kronecker_matrix(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_kronecker_matrix_+3A_r">r</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix  can be constructed as multiple of 2 Hadamard matrix.
Returns the value 12, if it is possible otherwise NULL is returned.
</p>


<h3>Value</h3>

<p>12 or NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_kronecker_matrix(8)
#12
cdn_kronecker_matrix(12)
#NULL

</code></pre>

<hr>
<h2 id='cdn_miyamoto'>cdn_miyamoto</h2><span id='topic+cdn_miyamoto'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using Ehlich's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_miyamoto(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_miyamoto_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Miyamoto construction, if q= n/4 and q is a prime or prime power
and q=1 (mod 4),then there exists an Hadamard Matrix of order n.
</p>


<h3>Value</h3>

<p>9 or NULL
</p>


<h3>References</h3>

<p>Miyamoto, M. (1991). A Construction of Hadamard matrices. J. Math. Phy., 12, 311-320.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_miyamoto">had_miyamoto</a></code> for Miyamoto's construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_miyamoto(20)
#q=5, is a prime number and q=1(mod 4).
#9
cdn_miyamoto(16)
#NULL
</code></pre>

<hr>
<h2 id='cdn_PaleyI'>cdn_PaleyI
Checks Hadamard Matrix can be constructed using Paley I method.</h2><span id='topic+cdn_PaleyI'></span>

<h3>Description</h3>

<p>cdn_PaleyI
Checks Hadamard Matrix can be constructed using Paley I method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_PaleyI(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_PaleyI_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Paley I method,  if q=order-1 and q is prime number and q=3 (mod 4) then the function retuns 2 otherwise NULL.
</p>


<h3>Value</h3>

<p>2 or NULL
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PaleyI">PaleyI</a></code> for Paley I construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_PaleyI(8)
#2
cdn_PaleyI(16)
#NULL
</code></pre>

<hr>
<h2 id='cdn_PaleyII'>cdn_PaleyII
Checks Hadamard Matrix can be constructed using Paley II method.</h2><span id='topic+cdn_PaleyII'></span>

<h3>Description</h3>

<p>cdn_PaleyII
Checks Hadamard Matrix can be constructed using Paley II method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_PaleyII(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_PaleyII_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Paley II method,  If q=order/2-1 or q=order/4-1 and q is prime number and
q=1 (mod 4) then this function retuns 3 otherwise NULL.
</p>


<h3>Value</h3>

<p>3 or NULL
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PaleyII">PaleyII</a></code> for Paley II construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_PaleyII(24)
#3
cdn_PaleyII(16)
#NULL
</code></pre>

<hr>
<h2 id='cdn_PaleyIIprimepower'>cdn_PaleyIIprimepower
checks Hadamard Matrix can be constructed using Paley II  method.</h2><span id='topic+cdn_PaleyIIprimepower'></span>

<h3>Description</h3>

<p>cdn_PaleyIIprimepower
checks Hadamard Matrix can be constructed using Paley II  method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_PaleyIIprimepower(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_PaleyIIprimepower_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Paley II method,  q=order/2-1 and q is prime power and q=1 (mod 4) then
it retuns 15 otherwise NULL.
</p>


<h3>Value</h3>

<p>15 or NULL
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PaleyIIPrimePower">PaleyIIPrimePower</a></code> for Paley construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_PaleyIIprimepower(340)
#15
cdn_PaleyIIprimepower(64)
#NULL
</code></pre>

<hr>
<h2 id='cdn_PaleyIprimepower'>cdn_PaleyIprimepower
checks Hadamard Matrix can be constructed using Paley I method.</h2><span id='topic+cdn_PaleyIprimepower'></span>

<h3>Description</h3>

<p>cdn_PaleyIprimepower
checks Hadamard Matrix can be constructed using Paley I method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_PaleyIprimepower(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_PaleyIprimepower_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Paley I method,  If q=order-1 and q is prime power and q=3 (mod 4) then
it retuns 14 otherwise NULL.
</p>


<h3>Value</h3>

<p>14 or NULL
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PaleyIPrimePower">PaleyIPrimePower</a></code> for Paley I construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_PaleyI(28)
#14
cdn_PaleyI(16)
#NULL
</code></pre>

<hr>
<h2 id='cdn_sds'>cdn_sds</h2><span id='topic+cdn_sds'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using available Suplementary Difference Sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_sds(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_sds_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix of given order can be constructed using Suplementary Diffrence sets.
If SDS is available it Returns the value 10 otherwise NULL.
</p>
<p>SDS are available for 103,127,151,163,181,191,239,251,463,631 in the internal table.
</p>


<h3>Value</h3>

<p>10 or NULL
</p>


<h3>Source</h3>

<p>SDS sets are availble from Djokovic (1992a,b,c,d and 1994a,1994b).
</p>


<h3>References</h3>

<p>Djokovic, D. Z. (1992a). Skew Hadamard matrices of order 4x37 and 4x39. J. Combin. Theory, A 61, 319-321.
</p>
<p>Djokovic, D. Z. (1992b). Construction of some new Hadamard matrices. Bull. Austral. math. Soc., 45, 327-332.
</p>
<p>Djokovic, D. Z. (1992c). Ten new Hadamard matrices of skew type. Publ.Electrotechnickog Fak., Ser. Mathematika, Univ. of Belgrade, 3, 47-59.
</p>
<p>Djokovic, D. Z. (1992d). Ten Hadamard matrices of order 1852 of Goethals-Seidel type. Europ. J. Combinatorics, 13, 245-248.
</p>
<p>Djokovic, D. Z. (1994a). Two Hadamard matrices of order 956 of Goethals-Seidel type. Combinatorica, 14(3), 375-377.
</p>
<p>Djokovic, D. Z. (1994b). Five new Hadamard matrices of order skew type. Austral. J. Combinatorics, 10, 259-264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_SDS">had_SDS</a></code> for SDS construction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_sds(412)
#10
cdn_sds(428)
#NULL


</code></pre>

<hr>
<h2 id='cdn_williamson'>cdn_williamson</h2><span id='topic+cdn_williamson'></span>

<h3>Description</h3>

<p>Checks Hadamard Matrix can be constructed using available Williamson sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdn_williamson(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdn_williamson_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks whether the Hadamard matrix of given order can be constructed using williamson sequences.
If Williamson sequences of length n,n,n,n are available, Hadamard matrix of order 4n can be constructed.
Returns the value 5, if it is possible otherwise NULL is returned.
</p>
<p>Williamson sequences are available for length of seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>


<h3>Value</h3>

<p>5 or NULL
</p>


<h3>Source</h3>

<p>The Williamson sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a> and London (2013).
</p>


<h3>References</h3>

<p>Williamson, J. (1944). Hadamard determinant theorem and the sum of four squares. Duke. Math. J., 11, 65-81.
</p>
<p>Williamson, J. (1947). Note on Hadamard's determnant theorem. Bull. Amer. Math. Soc., 53, 608-613.
</p>
<p>London, S. 2013. Constructing New Turyn Type Sequences, T-Sequences and Hadamard Matrices. PhD Thesis, University of Illinois at Chicago, Chicago.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_williamson">had_williamson</a></code> for Williamson construction method using Williamson sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdn_williamson(20)
#5
cdn_goethals_T(24)
#NULL

</code></pre>

<hr>
<h2 id='check_hadamard'>check_hadamard</h2><span id='topic+check_hadamard'></span>

<h3>Description</h3>

<p>check_hadamard tests whether the input matrix  is an Hadamard matrix or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_hadamard(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_hadamard_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to check whether a given matrix is an Hadamard Matrix or not.
To ensure that generated matrix is indeed an Hadamard matrix, this function can be used. In case,
if the given matrix is an Hadamard matrix, a text message, Given matrix is an Hadamard Matrix of order is printed on the console.
</p>
<p>This function checks (i)Input is a matrix; (ii)a square matrix; (iii)Order of the matrix is an Hadamard number;
(iv) All elements are either +1 or -1; (v) HH'=nI, where n is the order of the input matrix H and H' is transpose of H.
</p>


<h3>Value</h3>

<p>returns a text message
</p>


<h3>References</h3>

<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application.Ann. Stat., 6, 1184-1238.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
h&lt;-matrix(c(1,1,1,-1),nrow=2,ncol=2)
check_hadamard(h)
# Given matrix is an Hadamard Matrix of order 2
#Example 2:
h&lt;-matrix(c(1,-1,1,-1),nrow=2,ncol=2)
check_hadamard(h)
#Not an Hadamard matrix
#Example 3:
h&lt;-Hadamard_Matrix(36)
check_hadamard(h)
#"Given matrix is an Hadamard Matrix of order 36"
</code></pre>

<hr>
<h2 id='circulant_mat'>circulant_mat</h2><span id='topic+circulant_mat'></span>

<h3>Description</h3>

<p>A matrix is said to be circulant if (i+1, j+1)th entry is equal to the
(i, j)th entry. Thus, for such matrices, the initial row determines the complex matrix. Whenever i+1,j+1 exceeds the order,
modulus operation is carried out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant_mat(x = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant_mat_+3A_x">x</code></td>
<td>
<p>a vector to be used as intial row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>circulant_mat performs construction of circulant matrices.
</p>


<h3>Value</h3>

<p>circulant matrix of order length of input vector.
</p>


<h3>References</h3>

<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application.Ann. Stat., 6, 1184-1238.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circulant_mat(c(1,1,-1,0))
#      [,1] [,2] [,3] [,4]
#[1,]    1    1   -1    0
#[2,]    0    1    1   -1
#[3,]   -1    0    1    1
#[4,]    1   -1    0    1
circulant_mat(c(5,9,-7,-2))
#      [,1] [,2] [,3] [,4]
#[1,]    5    9   -7   -2
#[2,]   -2    5    9   -7
#[3,]   -7   -2    5    9
#[4,]    9   -7   -2    5
</code></pre>

<hr>
<h2 id='get_cooper'>get_cooper</h2><span id='topic+get_cooper'></span>

<h3>Description</h3>

<p>This function provides the Williamson Matrix order and T-Sequence length required to construct Hadamard matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cooper(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cooper_+3A_x">x</code></td>
<td>
<p>integer
Hadamard Matrix Order to Check</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If m is the order of T-Sequence and n is the order of Williamson sequence and both exists.
Cooper and Wallis (1972) showed a construction method for Hadamard matrix of order 4mn exists. This function returns
m and n if they exists otherwise NULL value is returned.
</p>


<h3>Value</h3>

<p>m Tsequence order
</p>
<p>n Williamson  order
</p>


<h3>References</h3>

<p>Cooper, J., and Wallis, J. 1972. A construction for Hadamard arrays. Bull. Austral. Math. Soc., 07: 269-277.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_cooper(340)
#$m
#[1] 5
#$n
#[1] 17
get_cooper(256)
#NULL
</code></pre>

<hr>
<h2 id='Get_method'>Get_method</h2><span id='topic+Get_method'></span>

<h3>Description</h3>

<p>Get_method helps finding the given order of the matrix is constructed by which method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Get_method(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_method_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Method name of the given order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Get_method(92) # Williamson method
Get_method(24)
# Paley I
</code></pre>

<hr>
<h2 id='GFADD'>GFADD</h2><span id='topic+GFADD'></span>

<h3>Description</h3>

<p>Addition table of GF(P^r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFADD(GFElem, p, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFADD_+3A_gfelem">GFElem</code></td>
<td>
<p>integer (Can be obtained by calling GFELEM function)</p>
</td></tr>
<tr><td><code id="GFADD_+3A_p">p</code></td>
<td>
<p>integer (a prime number)</p>
</td></tr>
<tr><td><code id="GFADD_+3A_r">r</code></td>
<td>
<p>integer (a positive integer)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns addition table of Galois field of order p^r. To use this function, Minimum function, elements of GF are required.
Minimum functions are available in internal dataset. Elements can be generated using GFELEM function.
</p>


<h3>Value</h3>

<p>A matrix of size p^r x p^r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p&lt;-3
r&lt;-2
cardin&lt;-p^2
mf&lt;-subset(HadamardR:::minimumfunction,HadamardR:::minimumfunction$s==cardin)
MF&lt;-mf$coeff
GFElem&lt;-GFELEM(p,r,MF)
GFADD(GFElem,p,r)
#Addition Table of GF(9)

</code></pre>

<hr>
<h2 id='GFCheck'>GFCheck</h2><span id='topic+GFCheck'></span>

<h3>Description</h3>

<p>This is an internal function to return the position of argument add in elements of GF(cardin)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFCheck(GFElem, r, cardin, add)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFCheck_+3A_gfelem">GFElem</code></td>
<td>
<p>integer array</p>
</td></tr>
<tr><td><code id="GFCheck_+3A_r">r</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="GFCheck_+3A_cardin">cardin</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="GFCheck_+3A_add">add</code></td>
<td>
<p>integer array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not exported. Used for checking the result of addition or multiplication of GFElements.
</p>


<h3>Value</h3>

<p>i integer
The position of the element checked in GFElem
</p>

<hr>
<h2 id='GFELEM'>GFELEM</h2><span id='topic+GFELEM'></span>

<h3>Description</h3>

<p>Elements of Galois Field, GF(P^r)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFELEM(p, r, MF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFELEM_+3A_p">p</code></td>
<td>
<p>integer (a prime number)</p>
</td></tr>
<tr><td><code id="GFELEM_+3A_r">r</code></td>
<td>
<p>integer (a positive integer)</p>
</td></tr>
<tr><td><code id="GFELEM_+3A_mf">MF</code></td>
<td>
<p>Integer Array containing Minimum function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns Elements of Galois field of order p^r. To use this function, Minimum function is required.
Minimum functions are available in internal dataset. To use the Minimum function from the internal, use HadamardR:::
</p>


<h3>Value</h3>

<p>A vector of size p^r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(HadamardR)
p&lt;-3
r&lt;-2
cardin=9
mf&lt;-subset(HadamardR:::minimumfunction,HadamardR:::minimumfunction$s==cardin)
MF&lt;-mf$coeff
GFElem&lt;-GFELEM(p,r,MF)
GFElem
</code></pre>

<hr>
<h2 id='GFM'>GFM
GFM Generate Multiplication table of GF(p^r), where p is a prime power.</h2><span id='topic+GFM'></span>

<h3>Description</h3>

<p>GFM
GFM Generate Multiplication table of GF(p^r), where p is a prime power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFM(cardin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFM_+3A_cardin">cardin</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns Multiplication table of Galois field of order p^r. To use this function, Minimum function, elements of GF are required.
Minimum functions are available in internal dataset. Elements can be generated using GFELEM function.
</p>


<h3>Value</h3>

<p>Multiplication table of GF(p^r)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GFM(9)
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    1    1    1    1    1    1    1    1    1
##  [2,]    1    3    4    5    6    7    8    9    2
##  [3,]    1    4    5    6    7    8    9    2    3
##  [4,]    1    5    6    7    8    9    2    3    4
##  [5,]    1    6    7    8    9    2    3    4    5
##  [6,]    1    7    8    9    2    3    4    5    6
##  [7,]    1    8    9    2    3    4    5    6    7
##  [8,]    1    9    2    3    4    5    6    7    8
##  [9,]    1    2    3    4    5    6    7    8    9
</code></pre>

<hr>
<h2 id='GFMult'>GFMult
GFMult Generate Multiplication table of GF(p^r), where p is a prime power.</h2><span id='topic+GFMult'></span>

<h3>Description</h3>

<p>GFMult
GFMult Generate Multiplication table of GF(p^r), where p is a prime power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFMult(cardin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFMult_+3A_cardin">cardin</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns Multiplication table of Galois field of order p^r. To use this function, Minimum function, elements of GF are required.
Minimum functions are available in internal dataset. Elements can be generated using GFELEM function.
</p>


<h3>Value</h3>

<p>Multiplication table of GF(p^r)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GFMult(9)
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    1    1    1    1    1    1    1    1    1
##  [2,]    1    3    4    5    6    7    8    9    2
##  [3,]    1    4    5    6    7    8    9    2    3
##  [4,]    1    5    6    7    8    9    2    3    4
##  [5,]    1    6    7    8    9    2    3    4    5
##  [6,]    1    7    8    9    2    3    4    5    6
##  [7,]    1    8    9    2    3    4    5    6    7
##  [8,]    1    9    2    3    4    5    6    7    8
##  [9,]    1    2    3    4    5    6    7    8    9
</code></pre>

<hr>
<h2 id='GFPrimeAdd'>GFPrimeAdd</h2><span id='topic+GFPrimeAdd'></span>

<h3>Description</h3>

<p>GFPrimeAdd creates the addition Table for GF(p), where p is a prime number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFPrimeAdd(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFPrimeAdd_+3A_p">p</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the elements of GF(p) are 0,1,..,p-1 then the (i,j)th element of matrix
returned is addition of (i-1)th and (j-1)th elements. The additions are
subjected to modulo p.
</p>


<h3>Value</h3>

<p>Addition Table of GF(p) in the form of matrix of order p x p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GFPrimeAdd(5)
     #[,1] [,2] [,3] [,4] [,5]
#[1,]    0    1    2    3    4
#[2,]    1    2    3    4    0
#[3,]    2    3    4    0    1
#[4,]    3    4    0    1    2
#[5,]    4    0    1    2    3




</code></pre>

<hr>
<h2 id='GFPrimeMult'>GFPrimeMult
GFPrimeMult creates Multiplication Table for GF(p), where p is a prime number</h2><span id='topic+GFPrimeMult'></span>

<h3>Description</h3>

<p>GFPrimeMult
GFPrimeMult creates Multiplication Table for GF(p), where p is a prime number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFPrimeMult(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFPrimeMult_+3A_p">p</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the elements of GF(p) are 0,1,..,p-1 then the (i,j)th element of matrix
returned is multiplication of (i-1)th and (j-1)th elements. The multiplications
are subjected to modulo p.
</p>


<h3>Value</h3>

<p>Multiplication Table of GF(p) in the form of matrix of order p x p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GFPrimeMult(5)
     #[,1] [,2] [,3] [,4] [,5]
#[1,]    0    0    0    0    0
#[2,]    0    1    2    3    4
#[3,]    0    2    4    1    3
#[4,]    0    3    1    4    2
#[5,]    0    4    3    2    1
</code></pre>

<hr>
<h2 id='goethals_seidel_array'>goethals_seidel_array</h2><span id='topic+goethals_seidel_array'></span>

<h3>Description</h3>

<p>goethals_seidel_array  performs the construction of Hadamard
matrix by Goethals-Seidel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goethals_seidel_array(A = NA, B = NA, C = NA, D = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goethals_seidel_array_+3A_a">A</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="goethals_seidel_array_+3A_b">B</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="goethals_seidel_array_+3A_c">C</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="goethals_seidel_array_+3A_d">D</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function requrires the four matrices, all the four matrix are Circulant matrices
same order.R is an antidiagonal matrix of the same order With which it should satisfy
the AA'+ BB'+ CC'+ DD'=4nI, where I is the identity matrix of order n.
This function returns matrix of order 4n where n is the order of the given matrices.
</p>


<h3>Value</h3>

<p>goethals_seidel matrix of order 4n
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero
diagnol. Canad. J. Math., 19, 259-264.
</p>

<hr>
<h2 id='had_baumert'>had_baumert</h2><span id='topic+had_baumert'></span>

<h3>Description</h3>

<p>had_baumert performs the constrution of Hadamard matrix by Baumert-Hall method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_baumert(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_baumert_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baumert-Hall arrays extension of the williamson array. For construction of matrix
it requires the Williamson sequences.For different order of the matrix it requries
different williamson sequences.If williamson sequences are not available it Returns NULL.
</p>
<p>Williamson sequences are available for length of seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order n
</p>


<h3>Source</h3>

<p>The Williamson sequences are available in London (2013) and
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Baumert, L. D., and Hall, M. Jr. (1965). A new construction method for Hadamard matrices.
Bull. Amer. Math. Soc., 71, 169-170
</p>
<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application. Ann. Stat., 6, 1184-1238.
</p>
<p>London, S. 2013. Constructing New Turyn Type Sequences, T-Sequences and Hadamard Matrices. PhD Thesis, University of Illinois at Chicago, Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
had_baumert(372)

#Big matrix.
had_baumert(24)
#NULL
</code></pre>

<hr>
<h2 id='had_cooper'>had_cooper</h2><span id='topic+had_cooper'></span>

<h3>Description</h3>

<p>had_cooper performs the construction of Hadamard matrix
by Cooper-Wallis method.In which combines the williamson matrices and T-sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_cooper(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_cooper_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix=876)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hadamard matrix of order n
</p>


<h3>Source</h3>

<p>The williamson sequences and Turyn sequences were obtained from
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Cooper, J. and Wallis, W. D. (1972). A construction for Hadamard arrays. Bull. Austral. Math. 7, 269-278.
</p>

<hr>
<h2 id='had_ehlich'>had_ehlich</h2><span id='topic+had_ehlich'></span>

<h3>Description</h3>

<p>had_ehlich performs the construction of Hadamard matrix by Ehlich method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_ehlich(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_ehlich_+3A_x">x</code></td>
<td>
<p>Integer (order of the Hadamard matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ehlich (1965)'s construction method requires order of the Hadamard matrix must
be a of the form (n-1)^2. Conditions are (i)Order=(n-1)^2; (ii) n is a prime
or prime power and 3(mod 4); (iii) (n-2) must be a prime or prime power. In
case, if all the three conditions are satisfied,then function will return Hadamard
matrix of order x otherwise NULL.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order x
</p>


<h3>References</h3>

<p>Ehlich, H. (1965). Neue Hadamard-matrizen. Arch. Math., 16, 34-36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_ehlich(36)
had_ehlich(20)
#NULL
</code></pre>

<hr>
<h2 id='had_goethals_base'>had_goethals_base</h2><span id='topic+had_goethals_base'></span>

<h3>Description</h3>

<p>had_goethals_base performs the construction of Hadamard Matrix from Goethals-Seidel method.
by using the Base sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_goethals_base(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_goethals_base_+3A_x">x</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct the Hadamard matrix of given order using base sequences.
If base sequences of length n+1,n+1,n,n are available, base sequences are converted into T-sequences of length 2n+1,2n+1,2n+1,2n+1 can be constructed.
From T-sequence of length 2n+1, Hadamard matrix of order 4(2n+1) can be constructed.
For a given order the base sequences is not available it returns NULL.
</p>
<p>The Base sequences are stored in internal dataset. The available
Base sequences of length is 1,2,3,4,.....,35
</p>


<h3>Value</h3>

<p>Hadamard matrix of order x
</p>


<h3>Source</h3>

<p>The Base sequences were obtained from
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_goethals_base(12)
#       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
# [1,]    1    1    1    1    1   -1    1   -1   -1    -1     1    -1
# [2,]    1    1    1    1   -1    1   -1   -1    1     1    -1    -1
# [3,]    1    1    1   -1    1    1   -1    1   -1    -1    -1     1
# [4,]   -1   -1    1    1    1    1    1   -1   -1     1    -1     1
# [5,]   -1    1   -1    1    1    1   -1   -1    1    -1     1     1
# [6,]    1   -1   -1    1    1    1   -1    1   -1     1     1    -1
# [7,]   -1    1    1   -1    1    1    1    1    1     1     1    -1
# [8,]    1    1   -1    1    1   -1    1    1    1     1    -1     1
# [9,]    1   -1    1    1   -1    1    1    1    1    -1     1     1
#[10,]    1   -1    1   -1    1   -1   -1   -1    1     1     1     1
#[11,]   -1    1    1    1   -1   -1   -1    1   -1     1     1     1
#[12,]    1    1   -1   -1   -1    1    1   -1   -1     1     1     1
had_goethals_base(16)
#NULL
</code></pre>

<hr>
<h2 id='had_goethals_T'>had_goethals_T
had_goethals_Turyn performs the Hadamard Matrix from Goethals-Seidel method
by using T sequences.</h2><span id='topic+had_goethals_T'></span>

<h3>Description</h3>

<p>had_goethals_T
had_goethals_Turyn performs the Hadamard Matrix from Goethals-Seidel method
by using T sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_goethals_T(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_goethals_T_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct Hadamard matrix of given order using T sequences.
If T sequences of length n,n,n,n are available, Hadamard matrix of order 4n can be constructed.
Returns the Hadamard matrix of given order. If for given order the T sequences are not available
returns NULL.
</p>
<p>The T sequences are stored in internal dataset. The available
T sequences of length is seq(1,73,2) and 83, 101 and 107
</p>


<h3>Value</h3>

<p>Hadamard matrix of order x
</p>


<h3>Source</h3>

<p>The T sequences are available at London (2013)  and
The Base sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>
<p>London, S. 2013. Constructing New Turyn Type Sequences, T-Sequences and Hadamard Matrices. PhD Thesis, University of Illinois at Chicago, Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_goethals_T(4)
#      [,1] [,2] [,3] [,4]
# [1,]    1   -1   -1   -1
# [2,]    1    1   -1    1
# [3,]    1    1    1   -1
# [4,]    1   -1    1    1
had_goethals_T(8)
#NULL
</code></pre>

<hr>
<h2 id='had_goethals_Turyn'>had_goethals_Turyn</h2><span id='topic+had_goethals_Turyn'></span>

<h3>Description</h3>

<p>had_goethals_Turyn performs the Hadamard Matrix from Goethals-Seidel method
by using Turyn sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_goethals_Turyn(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_goethals_Turyn_+3A_r">r</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct Hadamard matrix of given order using Turyn sequences.
If Turyn sequences of length 2n-1, 2n-1, n, n is available then Turyn sequences are
converted in T sequences of length 2n+p, 2n+p, 2n+p, 2n+p and p=n-1, these T sequences are used for
construction of  Hadamard matrix.
If the given order of the the Turyn sequences are not available it returns NULL.
</p>
<p>Turyn type-sequences are available for 28,30,34,36 in the internal dataset.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order r
</p>


<h3>Source</h3>

<p>The Base sequences were obtained from
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Big matrices
had_goethals_Turyn(356)
had_goethals_Turyn(404)

</code></pre>

<hr>
<h2 id='had_kronecker'>had_kronecker</h2><span id='topic+had_kronecker'></span>

<h3>Description</h3>

<p>had_kronecker performs the construction of an Hadamard matrix by kronecker product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_kronecker(n, exponent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_kronecker_+3A_n">n</code></td>
<td>
<p>an integer (Expected to be Hadamard Number)</p>
</td></tr>
<tr><td><code id="had_kronecker_+3A_exponent">exponent</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only applicable when n is the power of 2 and multiple of 4.
</p>
<p>If n&lt;-2, returns Hadamard matrix of order 2; if n is not Hadamard number, return NULL.
</p>
<p>By default exponent=FALSE; when exponent is unknown it is computed.
</p>
<p>If exponent is given use the same
</p>


<h3>Value</h3>

<p>Hadamard Matrix of order n, if n is power of 2, otherwise NULL.
</p>


<h3>References</h3>

<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application.Ann. Stat., 6, 1184-1238.
</p>
<p>Sylvester, J.J. (1968). Problem 2511. Math. Questions and solutions, 10, 74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_kronecker(4)
#      [,1] [,2] [,3] [,4]
#[1,]    1    1    1    1
#[2,]    1   -1    1   -1
#[3,]    1    1   -1   -1
#[4,]    1   -1   -1    1
had_kronecker(8,3)
#     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#[1,]    1    1    1    1    1    1    1    1
#[2,]    1   -1    1   -1    1   -1    1   -1
#[3,]    1    1   -1   -1    1    1   -1   -1
#[4,]    1   -1   -1    1    1   -1   -1    1
#[5,]    1    1    1    1   -1   -1   -1   -1
#[6,]    1   -1    1   -1   -1    1   -1    1
#[7,]    1    1   -1   -1   -1   -1    1    1
#[8,]    1   -1   -1    1   -1    1    1   -1
had_kronecker(9)
 # NULL
</code></pre>

<hr>
<h2 id='Had_method'>Had_method</h2><span id='topic+Had_method'></span>

<h3>Description</h3>

<p>Had_method  performs the give order of the matrix is constructed by which method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Had_method(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Had_method_+3A_order">order</code></td>
<td>
<p>integer (order of the Hadamard matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the method number retuns, if it
</p>
<p>1      kronecker method (power of 2 only)
</p>
<p>2      PaleyI
</p>
<p>3      PaleyII
</p>
<p>4      Ehlich method
</p>
<p>5      Williamson method
</p>
<p>6      Baumert-Hall method
</p>
<p>7      Goethals-Seidel by using Base sequences
</p>
<p>8      Goethals-Seidel by using Turyn sequences
</p>
<p>9      Miyamoto method
</p>
<p>10     Suplimentary Difference Sets
</p>
<p>11     Cooper-Wallis method
</p>
<p>12     Kronecker product method
</p>
<p>13     Goethals-Seidel by using T sequences
</p>
<p>14     Paley I Prime Power
</p>
<p>15     Paley II Prime Power
</p>


<h3>Value</h3>

<p>Method number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Had_method(92)   # "5"
Had_method(324)  # "4"
</code></pre>

<hr>
<h2 id='had_miyamoto'>had_miyamoto</h2><span id='topic+had_miyamoto'></span>

<h3>Description</h3>

<p>had_miyamoto function perform the construction of the Hadamard matrix by using the
Miyamoto method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_miyamoto(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_miyamoto_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the q=n/4, and q be a prime power and q=1 (mod 4). If there is a exists of
Hadamard matrix of order q-1, then there exists an Hadamard matrix of order 4q.
If given order is not satisfied it returns NULL.
</p>


<h3>Value</h3>

<p>Hadamard matrix of n
</p>


<h3>References</h3>

<p>Miyamoto, M. (1991). A Construction of Hadamard matrices. J. Math. Phy., 12, 311-320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_miyamoto(20)
had_miyamoto(24) #NULL

</code></pre>

<hr>
<h2 id='had_SDS'>had_SDS</h2><span id='topic+had_SDS'></span>

<h3>Description</h3>

<p>had_SDS performs the construction of Hadamard matrix from SDS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_SDS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_SDS_+3A_x">x</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct the Hadamard matrix of given order can be constructed using Suplementary Diffrence sets.
For given order the SDS set is not available it retuns NULL
If SDS is available it Returns Hadamard matrix of given order.
</p>
<p>SDS are available for 103,127,151,163,181,191,239,251,463,631 in the internal table.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order x
</p>


<h3>References</h3>

<p>Djokovic, D. Z. (1992a). Skew Hadamard matrices of order 4x37 and 4x39. J. Combin. Theory, A 61, 319-321.
</p>
<p>Djokovic, D. Z. (1992b). Construction of some new Hadamard matrices. Bull. Austral. math. Soc., 45, 327-332.
</p>
<p>Djokovic, D. Z. (1992c). Ten new Hadamard matrices of skew type. Publ.Electrotechnickog Fak., Ser. Mathematika, Univ. of Belgrade, 3, 47-59.
</p>
<p>Djokovic, D. Z. (1992d). Ten Hadamard matrices of order 1852 of Goethals-Seidel type. Europ. J. Combinatorics, 13, 245-248.
</p>
<p>Djokovic, D. Z. (1994a). Two Hadamard matrices of order 956 of Goethals-Seidel type. Combinatorica, 14(3), 375-377.
</p>
<p>Djokovic, D. Z. (1994b). Five new Hadamard matrices of order skew type. Austral. J. Combinatorics, 10, 259-264.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
had_SDS(412)


had_SDS(508)

</code></pre>

<hr>
<h2 id='had_williamson'>had_williamson</h2><span id='topic+had_williamson'></span>

<h3>Description</h3>

<p>had_williamson performs the construction Hadamard matrix from Williamson method by using the
williamson sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>had_williamson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="had_williamson_+3A_x">x</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct Hadamard matrix of given order using williamson sequences.
If Williamson sequences of length n,n,n,n are available, Hadamard matrix of order 4n can be constructed.
If for given order of Matrix Williamson sequences are not available it retuns NULL.
</p>
<p>The  Williamson sequences are stored in internal dataset,
available for length of seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>


<h3>Value</h3>

<p>Hadamard matrix
</p>


<h3>Source</h3>

<p>The williamson sequences are available in London(2013) and
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
</p>


<h3>References</h3>

<p>Williamson, J. (1944). Hadamard determinant theorem and the sum of four squares. Duke. Math. J., 11, 65-81.
</p>
<p>Williamson, J. (1947). Note on Hadamard's determnant theorem. Bull. Amer. Math. Soc., 53, 608-613.
</p>
<p>London, S. 2013. Constructing New Turyn Type Sequences, T-Sequences and Hadamard Matrices. PhD Thesis, University of Illinois at Chicago, Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>had_williamson(4)
#      [,1] [,2] [,3] [,4]
#[1,]    1    1    1    1
#[2,]   -1    1   -1    1
#[3,]   -1    1    1   -1
#[4,]   -1   -1    1    1
had_williamson(8)
# NULL
</code></pre>

<hr>
<h2 id='Hadamard_Matrix'>Hadamard_Matrix</h2><span id='topic+Hadamard_Matrix'></span>

<h3>Description</h3>

<p>Hadamard_Matrix is generic function for construction of Hadamard matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hadamard_Matrix(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hadamard_Matrix_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function Hadamard_matrix was created which does not require known of
construction methods. Hadamard_matrix() takes an integer as input and returns
Hadamard matrix if it is available. In case, it is not possible to construct,
NULL value is returned.
</p>


<h3>Value</h3>

<p>Hadamard Matrix of given Order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Hadamard_Matrix(1)
#1
Hadamard_Matrix(2)
#      [,1] [,2]
# [1,]    1    1
# [2,]    1   -1
Hadamard_Matrix(8)
      # [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
# [1,]    1    1    1    1    1    1    1    1
# [2,]    1   -1    1   -1    1   -1    1   -1
# [3,]    1    1   -1   -1    1    1   -1   -1
# [4,]    1   -1   -1    1    1   -1   -1    1
# [5,]    1    1    1    1   -1   -1   -1   -1
# [6,]    1   -1    1   -1   -1    1   -1    1
# [7,]    1    1   -1   -1   -1   -1    1    1
# [8,]    1   -1   -1    1   -1    1    1   -1
Hadamard_Matrix(10)
#"Order is not a Hadamard number"
Hadamard_Matrix(668)
#"Not possible to construct or order is not a multiple of 4"
</code></pre>

<hr>
<h2 id='Hadamard_matrix_method'>Hadamard_Matrix_method</h2><span id='topic+Hadamard_matrix_method'></span>

<h3>Description</h3>

<p>Hadamard_Matrix_method it is also generic function but it provides some additional options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hadamard_matrix_method(order, type = -1, method = "", file = "", filetype = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hadamard_matrix_method_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="Hadamard_matrix_method_+3A_type">type</code></td>
<td>
<p>-1 or 0</p>
</td></tr>
<tr><td><code id="Hadamard_matrix_method_+3A_method">method</code></td>
<td>
<p>method=c(&quot;Kronecker&quot;, &quot;PaleyI&quot;,&quot;PaleyII&quot;,&quot;Ehlich&quot;,&quot;Williamson&quot;,&quot;Baumert&quot;,&quot;Goethals-Seidel_Base&quot;,
&quot;Goethals-Seidel_Turyn&quot;,&quot;Miyamoto&quot;,&quot;Cooper-Wallis&quot;,&quot;Kronecker_Product_Method&quot;,&quot;PaleyIPrimepower&quot;,&quot;PaleyIIPrimePower&quot;)</p>
</td></tr>
<tr><td><code id="Hadamard_matrix_method_+3A_file">file</code></td>
<td>
<p>Name of the file</p>
</td></tr>
<tr><td><code id="Hadamard_matrix_method_+3A_filetype">filetype</code></td>
<td>
<p>xlsx or csv</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the method is not specified or incorrectly specified,
Hadamard matrix will be constructed using Had_method function.
If the method is specified, Hadamard matrix will be constructed using that method.
</p>
<p>By default, the elements will be +1 or -1. Incase, -1 should be replaced by 0,
use type=0.
</p>
<p>TO save the generated matrix into a text file (csv) or MS-Excel,
filename may be specified (with extension). In case Excel file required,
use filetype = xlsx, otherwise csv file will be generated.
</p>
<p>If just give the input as number it returns Hadamard matrix in console.
</p>


<h3>Value</h3>

<p>Hadamard Matrix of given Order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Hadamard_matrix_method(4)
#      [,1] [,2] [,3] [,4]
#[1,]    1    1    1    1
#[2,]    1   -1    1   -1
#[3,]    1    1   -1   -1
#[4,]    1   -1   -1    1
Hadamard_matrix_method(8,method = "PaleyI")
#       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
# [1,]    1    1    1    1    1    1    1    1
# [2,]   -1    1   -1   -1    1   -1    1    1
# [3,]   -1    1    1   -1   -1    1   -1    1
# [4,]   -1    1    1    1   -1   -1    1   -1
# [5,]   -1   -1    1    1    1   -1   -1    1
# [6,]   -1    1   -1    1    1    1   -1   -1
# [7,]   -1   -1    1   -1    1    1    1   -1
# [8,]   -1   -1   -1    1   -1    1    1    1

Hadamard_matrix_method(12,method = "Williamson",
 file =  file.path(tempdir(), "Hadamard12.csv"))
#output saved in file


Hadamard_matrix_method(36,method = "Baumert",
file = file.path(tempdir(),"Hadamard36.xlsx"))
#output saved in file


Hadamard_matrix_method(20,method = "Miyamoto",
file = file.path(tempdir(),"Hadamard20.csv"),filetype = "csv")
#output saved in file


Hadamard_matrix_method(8,method =
"Kronecker",file = file.path(tempdir(),"Hadamard8.xlsx"), filetype = "xlsx")
#output saved in file

</code></pre>

<hr>
<h2 id='Initial_row_SDS'>Initial_row_SDS
Initial_row_SDS is an internal function.Not Exported.</h2><span id='topic+Initial_row_SDS'></span>

<h3>Description</h3>

<p>Initial_row_SDS
Initial_row_SDS is an internal function.Not Exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Initial_row_SDS(i, j, v, n, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initial_row_SDS_+3A_i">i</code></td>
<td>
<p>is the numeric vectors</p>
</td></tr>
<tr><td><code id="Initial_row_SDS_+3A_j">j</code></td>
<td>
<p>is the numeric vectors</p>
</td></tr>
<tr><td><code id="Initial_row_SDS_+3A_v">v</code></td>
<td>
<p>is the numeric vectors</p>
</td></tr>
<tr><td><code id="Initial_row_SDS_+3A_n">n</code></td>
<td>
<p>is the numeric vectors</p>
</td></tr>
<tr><td><code id="Initial_row_SDS_+3A_r">r</code></td>
<td>
<p>is the numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All inputs are numeric vectors of same length.
This function used in the COnstruction of Hadamard matrix by Supplementary Differences Sets
It converts the SDS sets into binary forms (+1 or -1).
</p>


<h3>Value</h3>

<p>Intial rows of Matrix.
</p>


<h3>References</h3>

<p>Djokovic, D. Z. (1992a). Skew Hadamard matrices of order 4x37 and 4x39. J. Combin. Theory, A 61, 319-321.
</p>
<p>Djokovic, D. Z. (1992b). Construction of some new Hadamard matrices. Bull. Austral. math. Soc., 45, 327-332.
</p>
<p>Djokovic, D. Z. (1992c). Ten new Hadamard matrices of skew type. Publ.Electrotechnickog Fak., Ser. Mathematika, Univ. of Belgrade, 3, 47-59.
</p>
<p>Djokovic, D. Z. (1992d). Ten Hadamard matrices of order 1852 of Goethals-Seidel type. Europ. J. Combinatorics, 13, 245-248.
</p>
<p>Djokovic, D. Z. (1994a). Two Hadamard matrices of order 956 of Goethals-Seidel type. Combinatorica, 14(3), 375-377.
</p>
<p>Djokovic, D. Z. (1994b). Five new Hadamard matrices of order skew type. Austral. J. Combinatorics, 10, 259-264.
</p>

<hr>
<h2 id='is_divisible'>is_divisible</h2><span id='topic+is_divisible'></span>

<h3>Description</h3>

<p>is_divisible is internal function. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_divisible(num, divisor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_divisible_+3A_num">num</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="is_divisible_+3A_divisor">divisor</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>it returns num/divisor value.
</p>


<h3>Value</h3>

<p>num/divisor
</p>

<hr>
<h2 id='is.prime'>is.prime</h2><span id='topic+is.prime'></span>

<h3>Description</h3>

<p>is.prime check the given number is prime or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.prime(num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.prime_+3A_num">num</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the given number is divisible any number other than 1 and itself it return NULL.
otherwise TRUE.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.prime(3)
#TRUE
is.prime(21)
#FALSE
</code></pre>

<hr>
<h2 id='is.primepower'>is.primepower</h2><span id='topic+is.primepower'></span>

<h3>Description</h3>

<p>Checks whether given number is a prime power or not. Note that for a prime number, it would return NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.primepower(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.primepower_+3A_p">p</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a and b where p=a^b, otherwise NULL. Uses primeFactors() function of numbers package.
</p>


<h3>Value</h3>

<p>a and b where p=a^b and a is a prime number. Otherwise NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.primepower(2048)
#2 11
is.primepower(7)
#NULL
is.primepower(100)
#NULL
</code></pre>

<hr>
<h2 id='Jmat'>Jmat</h2><span id='topic+Jmat'></span>

<h3>Description</h3>

<p>Jmat peforms the generation of unit matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jmat(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jmat_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An J matrix is a square matrix where all the entries are one.
</p>


<h3>Value</h3>

<p>square matrix of order n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Jmat(4)
#      [,1] [,2] [,3] [,4]
#[1,]    1    1    1    1
#[2,]    1    1    1    1
#[3,]    1    1    1    1
#[4,]    1    1    1    1
</code></pre>

<hr>
<h2 id='kro_method'>kro_method</h2><span id='topic+kro_method'></span>

<h3>Description</h3>

<p>kro_method internal function. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kro_method(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kro_method_+3A_r">r</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>r/2 or NULL.
</p>


<h3>References</h3>

<p>Sylvester, J.J. (1967). Thoughts on orthogonal matrices, simultaneous sign-succession
and Tessellated pavements in two or more colours, with applications to Newton's rule,
ornamental Tie-work, and the theory of numbers. Phil. Mag.,34, 461-475.
</p>
<p>Sylvester, J.J. (1968). Problem 2511. Math. Questions and solutions, 10, 74.
</p>
<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application.Ann. Stat., 6, 1184-1238.
</p>

<hr>
<h2 id='kronecker_matrix'>kronecker_matrix</h2><span id='topic+kronecker_matrix'></span>

<h3>Description</h3>

<p>kronecker_matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronecker_matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronecker_matrix_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function construct Hadamard matrix by multiple of 2 Hadamard matrix.
It Returns the Hadamard Matrix, if it is not possible NULL is returned.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order &quot;n&quot;
</p>


<h3>References</h3>

<p>Sylvester, J.J. (1967). Thoughts on orthogonal matrices, simultaneous sign-succession
and Tessellated pavements in two or more colours, with applications to Newton's rule,
ornamental Tie-work, and the theory of numbers. Phil. Mag.,34, 461-475.
</p>
<p>Sylvester, J.J. (1968). Problem 2511. Math. Questions and solutions, 10, 74.
</p>
<p>Hedayat, A. and Wallis, W.D. (1978). Hadamard Matrices and Their Application.Ann. Stat., 6, 1184-1238.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kronecker_matrix(8)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#[1,]    1    1    1    1    1    1    1    1
#[2,]    1   -1    1   -1    1   -1    1   -1
#[3,]    1    1   -1   -1    1    1   -1   -1
#[4,]    1   -1   -1    1    1   -1   -1    1
#[5,]    1    1    1    1   -1   -1   -1   -1
#[6,]    1   -1    1   -1   -1    1   -1    1
#[7,]    1    1   -1   -1   -1   -1    1    1
#[8,]    1   -1   -1    1   -1    1    1   -1
kronecker_matrix(12)
#NULL
</code></pre>

<hr>
<h2 id='method1_paleyII'>method1_paleyII</h2><span id='topic+method1_paleyII'></span>

<h3>Description</h3>

<p>method1_paleyII is internal function not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method1_paleyII(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method1_paleyII_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function checks q&lt;- (n/2)-1, q is prime number and q = 1(mod 4). if it satisfy it returns q;
otherwise returns NULL.
</p>


<h3>Value</h3>

<p>0 or (n/2)-1
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>

<hr>
<h2 id='method2_paleyII'>method2_paleyII</h2><span id='topic+method2_paleyII'></span>

<h3>Description</h3>

<p>method2_paleyII is internal function not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method2_paleyII(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method2_paleyII_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function checks q&lt;- (n/4)-1, q is prime number and q = 1(mod 4). if it satisfy it returns q;
otherwise returns NULL.
</p>


<h3>Value</h3>

<p>0 or (n/4)-1
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>

<hr>
<h2 id='miyamotoC'>miyamotoC</h2><span id='topic+miyamotoC'></span>

<h3>Description</h3>

<p>miyamotoC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miyamotoC(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miyamotoC_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>q matrix
</p>


<h3>References</h3>

<p>Miyamoto, M. (1991). A Construction of Hadamard matrices. J. Math. Phy., 12, 311-320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>miyamotoC(20)
#      [,1] [,2] [,3] [,4] [,5]
#[1,]    0    1    1   -1   -1
#[2,]    1    0   -1   -1    1
#[3,]    1   -1    0    1   -1
#[4,]   -1   -1    1    0    1
#[5,]   -1    1   -1    1    0
</code></pre>

<hr>
<h2 id='nextElem'>nextElem</h2><span id='topic+nextElem'></span>

<h3>Description</h3>

<p>nextElem Generate next element of GF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextElem(p1, MF, p, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextElem_+3A_p1">p1</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="nextElem_+3A_mf">MF</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="nextElem_+3A_p">p</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="nextElem_+3A_r">r</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of order r, the coefficients of elements.
</p>

<hr>
<h2 id='Normcol'>Normcol
Normcol performs the Normalisation of column the given matrix.</h2><span id='topic+Normcol'></span>

<h3>Description</h3>

<p>Normcol
Normcol performs the Normalisation of column the given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normcol(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normcol_+3A_m">m</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the given matrix of the first column of the all the -1 elements converting +1
without alter the property of the matrix.
</p>


<h3>Value</h3>

<p>Normalised matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyI(8)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#[1,]    1    1    1    1    1    1    1    1
#[2,]   -1    1   -1   -1    1   -1    1    1
#[3,]   -1    1    1   -1   -1    1   -1    1
#[4,]   -1    1    1    1   -1   -1    1   -1
#[5,]   -1   -1    1    1    1   -1   -1    1
#[6,]   -1    1   -1    1    1    1   -1   -1
#[7,]   -1   -1    1   -1    1    1    1   -1
#[8,]   -1   -1   -1    1   -1    1    1    1
Normcol(PaleyI(8))
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#[1,]    1    1    1    1    1    1    1    1
#[2,]    1   -1    1    1   -1    1   -1   -1
#[3,]    1   -1   -1    1    1   -1    1   -1
#[4,]    1   -1   -1   -1    1    1   -1    1
#[5,]    1    1   -1   -1   -1    1    1   -1
#[6,]    1   -1    1   -1   -1   -1    1    1
#[7,]    1    1   -1    1   -1   -1   -1    1
#[8,]    1    1    1   -1    1   -1   -1   -1

</code></pre>

<hr>
<h2 id='Normrow'>Normrow
Normcol performs the Normalisation of row the given matrix.</h2><span id='topic+Normrow'></span>

<h3>Description</h3>

<p>Normrow
Normcol performs the Normalisation of row the given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normrow(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normrow_+3A_m">m</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the given matrix of the first row of the all the -1 elements converting +1
without alter the property of the matrix.
</p>


<h3>Value</h3>

<p>Normalised matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyII(12)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
# [1,]    1    1    1    1    1    1    1   -1   -1    -1    -1    -1
# [2,]    1    1    1   -1   -1    1   -1    1   -1     1     1    -1
# [3,]    1    1    1    1   -1   -1   -1   -1    1    -1     1     1
# [4,]    1   -1    1    1    1   -1   -1    1   -1     1    -1     1
# [5,]    1   -1   -1    1    1    1   -1    1    1    -1     1    -1
# [6,]    1    1   -1   -1    1    1   -1   -1    1     1    -1     1
# [7,]    1   -1   -1   -1   -1   -1   -1   -1   -1    -1    -1    -1
# [8,]   -1    1   -1    1    1   -1   -1   -1   -1     1     1    -1
# [9,]   -1   -1    1   -1    1    1   -1   -1   -1    -1     1     1
#[10,]   -1    1   -1    1   -1    1   -1    1   -1    -1    -1     1
#[11,]   -1    1    1   -1    1   -1   -1    1    1    -1    -1    -1
#[12,]   -1   -1    1    1   -1    1   -1   -1    1     1    -1    -1
Normrow(PaleyII(12))
#       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
# [1,]    1    1    1    1    1    1    1    1    1     1     1     1
# [2,]    1    1    1   -1   -1    1   -1   -1    1    -1    -1     1
# [3,]    1    1    1    1   -1   -1   -1    1   -1     1    -1    -1
# [4,]    1   -1    1    1    1   -1   -1   -1    1    -1     1    -1
# [5,]    1   -1   -1    1    1    1   -1   -1   -1     1    -1     1
# [6,]    1    1   -1   -1    1    1   -1    1   -1    -1     1    -1
# [7,]    1   -1   -1   -1   -1   -1   -1    1    1     1     1     1
# [8,]   -1    1   -1    1    1   -1   -1    1    1    -1    -1     1
# [9,]   -1   -1    1   -1    1    1   -1    1    1     1    -1    -1
#[10,]   -1    1   -1    1   -1    1   -1   -1    1     1     1    -1
#[11,]   -1    1    1   -1    1   -1   -1   -1   -1     1     1     1
#[12,]   -1   -1    1    1   -1    1   -1    1   -1    -1     1     1
</code></pre>

<hr>
<h2 id='PaleyI'>PaleyI</h2><span id='topic+PaleyI'></span>

<h3>Description</h3>

<p>This function performs constructing the Hadamard matrix by Paley method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PaleyI(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PaleyI_+3A_n">n</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>let q = n-1 ,  and q = 3 (mod 4), q is the prime number, then obtained the Hadamard
matrix of order q+1.if input satisfies these condition it retuns Hadamard Matrix; otherwise
returns NULL.
</p>


<h3>Value</h3>

<p>hadamard matrix of n
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyI(8)
#' PaleyI(8)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
#[1,]    1    1    1    1    1    1    1    1
#[2,]   -1    1   -1   -1    1   -1    1    1
#[3,]   -1    1    1   -1   -1    1   -1    1
#[4,]   -1    1    1    1   -1   -1    1   -1
#[5,]   -1   -1    1    1    1   -1   -1    1
#[6,]   -1    1   -1    1    1    1   -1   -1
#[7,]   -1   -1    1   -1    1    1    1   -1
#[8,]   -1   -1   -1    1   -1    1    1    1
PaleyI(16)
#NULL
</code></pre>

<hr>
<h2 id='PaleyII'>PaleyII</h2><span id='topic+PaleyII'></span>

<h3>Description</h3>

<p>This function create the Hadamard matrix by Paley method 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PaleyII(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PaleyII_+3A_n">n</code></td>
<td>
<p>integer(order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>q=n/2-1, If there is an Hadamard matrix of order h&gt;1, and q = 1 (mod 4) is a prime number,
then there exists an Hadamard matrix of order nh.
</p>


<h3>Value</h3>

<p>Hadamard matrix of order n
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyII(12)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
# [1,]    1    1    1    1    1    1    1   -1   -1    -1    -1    -1
# [2,]    1    1    1   -1   -1    1   -1    1   -1     1     1    -1
# [3,]    1    1    1    1   -1   -1   -1   -1    1    -1     1     1
# [4,]    1   -1    1    1    1   -1   -1    1   -1     1    -1     1
# [5,]    1   -1   -1    1    1    1   -1    1    1    -1     1    -1
# [6,]    1    1   -1   -1    1    1   -1   -1    1     1    -1     1
# [7,]    1   -1   -1   -1   -1   -1   -1   -1   -1    -1    -1    -1
# [8,]   -1    1   -1    1    1   -1   -1   -1   -1     1     1    -1
# [9,]   -1   -1    1   -1    1    1   -1   -1   -1    -1     1     1
#[10,]   -1    1   -1    1   -1    1   -1    1   -1    -1    -1     1
#[11,]   -1    1    1   -1    1   -1   -1    1    1    -1    -1    -1
#[12,]   -1   -1    1    1   -1    1   -1   -1    1     1    -1    -1
PaleyII(8)
#NULL
</code></pre>

<hr>
<h2 id='PaleyIIPrimePower'>PaleyIIPrimePower</h2><span id='topic+PaleyIIPrimePower'></span>

<h3>Description</h3>

<p>PaleyIIPrimePower
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PaleyIIPrimePower(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PaleyIIPrimePower_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>q=n/2-1, If there is an Hadamard matrix of order h&gt;1, and q = 1 (mod 4) is a prime power,
then there exists an Hadamard matrix of order nh.
</p>


<h3>Value</h3>

<p>Hadamard matrix of the given order.
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyIIPrimePower(20)
PaleyIIPrimePower(24)
</code></pre>

<hr>
<h2 id='PaleyIPrimePower'>PaleyIPrimePower</h2><span id='topic+PaleyIPrimePower'></span>

<h3>Description</h3>

<p>PaleyIPrimePower
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PaleyIPrimePower(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PaleyIPrimePower_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>let q = n-1 ,  and q = 3 (mod 4), q is the prime power, then obtained the Hadamard
matrix of order q+1.if input satisfies these condition it retuns Hadamard Matrix; otherwise
returns NULL.
</p>


<h3>Value</h3>

<p>Hadamard matrix
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaleyIPrimePower(28)
PaleyIPrimePower(28)
#NULL
</code></pre>

<hr>
<h2 id='ply1'>ply1</h2><span id='topic+ply1'></span>

<h3>Description</h3>

<p>ply1 -internal function; not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ply1(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ply1_+3A_q">q</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hadamard matrix of order 2(q+1)
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>

<hr>
<h2 id='ply2'>ply2</h2><span id='topic+ply2'></span>

<h3>Description</h3>

<p>ply2 is internal function and not exported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ply2(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ply2_+3A_q">q</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hadamard matrix of order 4(q+1)
</p>


<h3>References</h3>

<p>Paley, R.E.A.C. (1933). On Orthogonal matrices. J. Combin. Theory, A 57(1), 86-108.
</p>

<hr>
<h2 id='pow'>pow</h2><span id='topic+pow'></span>

<h3>Description</h3>

<p>pow functions finds the exponent of 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the given number is the power of 2 or not
If the given number is power of 2 it returns the exponent value; otherwise NULL is returned.
</p>


<h3>Value</h3>

<p>power of 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow(4)
# 2
pow(5)
#NULL
pow(6)
#NULL
</code></pre>

<hr>
<h2 id='qhad2'>qhad2</h2><span id='topic+qhad2'></span>

<h3>Description</h3>

<p>qhad2 creats the Quadratic residues of the prime number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhad2(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qhad2_+3A_p">p</code></td>
<td>
<p>is the integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given input is prime number it retuns the matrix of order p.
if the input is not prime number it returns NULL.
</p>


<h3>Value</h3>

<p>matrix of order p
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qhad2(7)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
#[1,]    0   -1   -1    1   -1    1    1
#[2,]    1    0   -1   -1    1   -1    1
#[3,]    1    1    0   -1   -1    1   -1
#[4,]   -1    1    1    0   -1   -1    1
#[5,]    1   -1    1    1    0   -1   -1
#[6,]   -1    1   -1    1    1    0   -1
#[7,]   -1   -1    1   -1    1    1    0
</code></pre>

<hr>
<h2 id='QPrimePower'>QPrimePower
QPrimePower creats the Quadratic residues of the prime number.</h2><span id='topic+QPrimePower'></span>

<h3>Description</h3>

<p>QPrimePower
QPrimePower creats the Quadratic residues of the prime number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QPrimePower(cardin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QPrimePower_+3A_cardin">cardin</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given input is prime power it retuns the matrix of order cardin.
if the input is not prime number then it returns NULL.
</p>


<h3>Value</h3>

<p>matrix of cardin x cardin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>QPrimePower(9)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
#[1,]    0    1   -1    1   -1    1   -1    1   -1
#[2,]    1    0    1   -1    1    1   -1   -1   -1
#[3,]   -1    1    0   -1    1   -1   -1    1    1
#[4,]    1   -1   -1    0    1   -1    1    1   -1
#[5,]   -1    1    1    1    0   -1    1   -1   -1
#[6,]    1    1   -1   -1   -1    0    1   -1    1
#[7,]   -1   -1   -1    1    1    1    0   -1    1
#[8,]    1   -1    1    1   -1   -1   -1    0    1
#[9,]   -1   -1    1   -1   -1    1    1    1    0
QPrimePower(36)
#NULL
</code></pre>

<hr>
<h2 id='quadprime'>quadprime</h2><span id='topic+quadprime'></span>

<h3>Description</h3>

<p>quadprime is a internal function not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadprime(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadprime_+3A_p">p</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function obtain Quadratic residues of GF. It returns squares of odd elements of GF
</p>


<h3>Value</h3>

<p>squres
</p>

<hr>
<h2 id='seq_williamson'>seq_williamson</h2><span id='topic+seq_williamson'></span>

<h3>Description</h3>

<p>seq_williamson performs the selection of Williamson sequences from dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_williamson(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_williamson_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create williamson sequences of given order from the internal dataset williamson_sequences
</p>
<p>Williamson sequences are available for length of seq(1,63, 2) except 15, 35, 47, 53, 59 in the internal table.
</p>


<h3>Value</h3>

<p>Required Williamson sequences of order
</p>


<h3>Source</h3>

<p>The Base sequences are obtained The Base sequences were obtained from
<a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>
and London (2013).
</p>


<h3>References</h3>

<p>Williamson, J. (1944). Hadamard determinant theorem and the sum of four squares. Duke. Math. J., 11, 65-81.
</p>
<p>Williamson, J. (1947). Note on Hadamard's determnant theorem. Bull. Amer. Math. Soc., 53, 608-613.
</p>
<p>London, S. 2013. Constructing New Turyn Type Sequences, T-Sequences and Hadamard Matrices. PhD Thesis, University of Illinois at Chicago, Chicago.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_williamson">had_williamson</a></code> for Williamson construction method using Williamson sequences.
</p>

<hr>
<h2 id='T_seq'>T_seq
T_seq performs the selection of the T sequences from dataset.internal function not exported.</h2><span id='topic+T_seq'></span>

<h3>Description</h3>

<p>T_seq
T_seq performs the selection of the T sequences from dataset.internal function not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_seq(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T_seq_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create T sequences of given order from the internal dataset T_sequences
</p>
<p>T-sequences are available for length of seq(1,73,2) and 83, 101 and 107 in the internal table.
</p>


<h3>Value</h3>

<p>Required Turyn sequences of order of x
</p>


<h3>Source</h3>

<p>The Turyn sequences were obtained from <a href="http://www.math.ntua.gr/~ckoukouv/">Christos Koukouvinos</a>.
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_T">had_goethals_T</a></code> for Goethals-Seidel construction method using T-sequences.
</p>

<hr>
<h2 id='Turyn_seq'>Turyn_seq
Turyn_seq performs the selection of the Turyn sequences from dataset.
It is internal function not exported.</h2><span id='topic+Turyn_seq'></span>

<h3>Description</h3>

<p>Turyn_seq
Turyn_seq performs the selection of the Turyn sequences from dataset.
It is internal function not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Turyn_seq(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Turyn_seq_+3A_order">order</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create Turyn sequences of given order from the internal dataset T_sequences
</p>
<p>Turyn type-sequences are available for 28,30,34,36 in the internal table.
</p>


<h3>Value</h3>

<p>Required Turyn sequences of order of x
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_Turyn">had_goethals_Turyn</a></code> for Goethals-Seidel construction method using Turyn sequences.
</p>
<p>#'
</p>

<hr>
<h2 id='Turyn_to_T'>Turyn_to_T
internal function. converts Turyn sequences to Base Sequences.</h2><span id='topic+Turyn_to_T'></span>

<h3>Description</h3>

<p>Turyn_to_T
internal function. converts Turyn sequences to Base Sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Turyn_to_T(dat1, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Turyn_to_T_+3A_dat1">dat1</code></td>
<td>
<p>is the Turyn sequences subset exported from Tseq</p>
</td></tr>
<tr><td><code id="Turyn_to_T_+3A_order">order</code></td>
<td>
<p>integer (order of the matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dat - Internal dataset containing 4 sequences in long form with lentgh 2n-1, 2n-1, n, n. Using the 4 Turyn sequences,
the function creates 4 sequences of length n+p, n+p, n, n.
Base Sequnces are usually used in creating matrices of Goethel Seidal array.
</p>
<p>Turyn type-sequences are available for 28,30,34,36 in the internal table.
</p>


<h3>Value</h3>

<p>Basesequences of length of order
</p>


<h3>References</h3>

<p>Goethals, J. M. and Seidel, J. J. (1967). Orthogonal matrices with zero diagnol. Canad. J. Math., 19, 259-264.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+had_goethals_Turyn">had_goethals_Turyn</a></code> for Goethals-Seidel construction method using Turyn sequences.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
