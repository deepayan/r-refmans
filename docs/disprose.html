<!DOCTYPE html><html><head><title>Help for package disprose</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {disprose}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_adapters'><p>Add adapters to probes</p></a></li>
<li><a href='#ann.data'><p>Chlamydia pneumoniae genome annotation.</p></a></li>
<li><a href='#annotate_probes'><p>Annotate probes</p></a></li>
<li><a href='#blast_local'><p>Local BLAST</p></a></li>
<li><a href='#blast.fill'><p>Local BLAST results with added content.</p></a></li>
<li><a href='#blast.raw'><p>Local BLAST results.</p></a></li>
<li><a href='#count_PhCh'><p>Calculate physical and chemical properties</p></a></li>
<li><a href='#cut_probes'><p>Cut probes</p></a></li>
<li><a href='#cut_string'><p>Cut string into segments</p></a></li>
<li><a href='#delete_duplicates_DF'><p>Delete rows with duplicated values</p></a></li>
<li><a href='#fill_blast_result'><p>Complement BLAST result</p></a></li>
<li><a href='#get_GA_files'><p>Read GISAID sequence file</p></a></li>
<li><a href='#get_GIs'><p>Get GenInfo Identifier numbers</p></a></li>
<li><a href='#get_seq_for_DB'><p>Get nucleotide sequences from NCBI</p></a></li>
<li><a href='#get_seq_info'><p>Get NCBI sequence record</p></a></li>
<li><a href='#make_blast_DB'><p>Builds local database for BLAST</p></a></li>
<li><a href='#make_ids'><p>Create unique identification values</p></a></li>
<li><a href='#meta.all'><p>Metadata of all available Chlamydia pneumoniae's sequences.</p></a></li>
<li><a href='#meta.target'><p>Metadata of target Chlamydia pneumoniae's sequences.</p></a></li>
<li><a href='#normalize_DF'><p>Normalize variable</p></a></li>
<li><a href='#rate_DF'><p>Rate variables</p></a></li>
<li><a href='#read_and_unite_files'><p>Read and unite files</p></a></li>
<li><a href='#read_from_table_file'><p>Read table file</p></a></li>
<li><a href='#store_in_DB'><p>Store data in SQLite database</p></a></li>
<li><a href='#summarize_blast_result'><p>Summarize BLAST result</p></a></li>
<li><a href='#trim_DF'><p>Trim data frame</p></a></li>
<li><a href='#unite_NCBI_ac.nums'><p>Assigns master record's id to all project records</p></a></li>
<li><a href='#unite_two_DF'><p>Combine two data frames</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discriminating Probes Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elena Filatova &lt;filatova@nniiem.ru&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools for molecular probes selection and design of a microarray, e.g. the assessment of physical and chemical properties, blast performance, selection according to sensitivity and selectivity. Methods used in package are described in: Lorenz R., Stephan H.B., Höner zu Siederdissen C. et al. (2011) &lt;<a href="https://doi.org/10.1186%2F1748-7188-6-26">doi:10.1186/1748-7188-6-26</a>&gt;; Camacho C., Coulouris G., Avagyan V. et al. (2009) &lt;<a href="https://doi.org/10.1186%2F1471-2105-10-421">doi:10.1186/1471-2105-10-421</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-us</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BBmisc, biomartr, curl, DBI, dplyr, rentrez, reutils,
RSQLite, stats, stringr, seqinr, TmCalculator, utils, XML</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-07 01:30:16 UTC; elfil</td>
</tr>
<tr>
<td>Author:</td>
<td>Elena Filatova <a href="https://orcid.org/0000-0002-6683-7191"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Oleg Utkin <a href="https://orcid.org/0000-0002-7571-525X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Blokhina Scientific Research Institute of Epidemiology and Microbiology
    of Nizhny Novgorod, Russia [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-18 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_adapters'>Add adapters to probes</h2><span id='topic+add_adapters'></span>

<h3>Description</h3>

<p>Add set of adapters to oligonucleotide probes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_adapters(
  probe.id.var,
  probe.var,
  ad.len,
  ad.nucl = "t",
  end = c(3, 5),
  mc.cores = 1,
  digits = 4,
  return = "dataframe",
  data,
  data.probe.id.var,
  count.mfe = FALSE,
  RNAfold.path,
  temperature = 40,
  trim.mfe = FALSE,
  MFEmin = 0,
  MFE.files.dir = NULL,
  delete.MFE.files = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_adapters_+3A_probe.id.var">probe.id.var</code></td>
<td>
<p>vector of probes' identification numbers</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_probe.var">probe.var</code></td>
<td>
<p>character; character; vector of nucleotide probes</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_ad.len">ad.len</code></td>
<td>
<p>integer; vector of adapter length</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_ad.nucl">ad.nucl</code></td>
<td>
<p>character; vector of adapter nucleotides</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_end">end</code></td>
<td>
<p>integer; probe's end for adapter attachment. Possible values are 3 and 5.</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to round the result (MFE)</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_return">return</code></td>
<td>
<p>character; returned object; possible values are: <code>"vector"</code> (vector of nucleotide probes with added adapters),
<code>"dataframe"</code> (data frame with probes, adapters and their characteristics),
<code>"add"</code> (user's data frame with added data of probes, adapters and their characteristics)</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_data">data</code>, <code id="add_adapters_+3A_data.probe.id.var">data.probe.id.var</code></td>
<td>
<p>user's data frame and it's variable with probes identification numbers (used if <code>return = "add"</code>)</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_count.mfe">count.mfe</code></td>
<td>
<p>logical; count minimum folding energy for probes with adapters</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_rnafold.path">RNAfold.path</code>, <code id="add_adapters_+3A_temperature">temperature</code>, <code id="add_adapters_+3A_trim.mfe">trim.mfe</code>, <code id="add_adapters_+3A_mfemin">MFEmin</code>, <code id="add_adapters_+3A_mfe.files.dir">MFE.files.dir</code>, <code id="add_adapters_+3A_delete.mfe.files">delete.MFE.files</code></td>
<td>
<p>used if <code>count.mfe = TRUE</code>;
see <a href="#topic+count_MFE">count_MFE</a>[disprose] for details</p>
</td></tr>
<tr><td><code id="add_adapters_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ad.len</code> parameter indicates number of <code>ad.nucl</code> repeats.
For example, with <code>ad.len =5</code> for <code>ad.nucl = "t"</code> adapter will be <code>"ttttt"</code> and for
<code>ad.nucl = "ac"</code> adapter will be <code>"acacacacac"</code>.
</p>
<p><code>ad.len</code>, <code>ad.nucl</code> and <code>end</code> might be vectors of any length.
All possible variants of adapters will be added to probes and tested.
</p>
<p>For MFE counting ViennaRNA Package (UNIX or Windows) must be installed. see <a href="#topic+count_MFE">count_MFE</a>[disprose] for details
</p>


<h3>Value</h3>

<p>Vector of nucleotide probes with added adapters, or data frame with probes, adapters and their characteristics,
or user's data frame with added data of probes, adapters and their characteristics.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probes &lt;- data.frame (ids = 1:3,  probes = c ("acacacacacaca", "aaaaagggggtttttccccc",
                                             "atgcgctagctcagc"))
ad.data &lt;- add_adapters(probe.var = probes$probes, probe.id.var = probes$ids,
                       ad.len = c(5, 8), ad.nucl = c("t", "dt"), end = c(3, 5),
                       count.mfe = FALSE, mc.cores = 1, digits = 4,
                       return = "dataframe", data = probes, data.probe.id.var = probes$ids)

</code></pre>

<hr>
<h2 id='ann.data'>Chlamydia pneumoniae genome annotation.</h2><span id='topic+ann.data'></span>

<h3>Description</h3>

<p>A dataset containing Chlamydia pneumoniae TW-183 (complete sequence, NC_005043.1.) genome annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ann.data
</code></pre>


<h3>Format</h3>

<p>A data frame with 2218 rows and 9 variables:
</p>

<dl>
<dt>seqid</dt><dd><p>sequence identification number</p>
</dd>
<dt>source</dt><dd><p>source database name</p>
</dd>
<dt>type</dt><dd><p>type of annotated region</p>
</dd>
<dt>start</dt><dd><p>region's start position</p>
</dd>
<dt>end</dt><dd><p>region's end position</p>
</dd>
<dt>score</dt><dd><p>score</p>
</dd>
<dt>strand</dt><dd><p>strand</p>
</dd>
<dt>phase</dt><dd><p>phase</p>
</dd>
<dt>attribute</dt><dd><p>region description</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/">https://www.ncbi.nlm.nih.gov/</a>
</p>

<hr>
<h2 id='annotate_probes'>Annotate probes</h2><span id='topic+annotate_probes'></span>

<h3>Description</h3>

<p>Get genome annotation for oligonucleotide sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_probes(
  source = "data.frame",
  ann.data = NULL,
  gff.path = NULL,
  org.name,
  db = "refseq",
  refs = TRUE,
  probe.id.var,
  probe.start.var,
  probe.stop.var,
  file.annot = NULL,
  save.format = "txt",
  sep = ";",
  return = "add.resume",
  priority = c("CDS", "gene", "region"),
  data,
  data.probe.id.var,
  delete.downloads = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_probes_+3A_source">source</code></td>
<td>
<p>character; genome annotation source. Possible values are:
<code>"data.frame"</code> (from data frame), <code>"giff"</code> (from GIFF file),
<code>"load"</code> (download from NCBI with <a href="biomartr.html#topic+getGFF">getGFF</a> function)</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_ann.data">ann.data</code></td>
<td>
<p>genome annotation data frame</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_gff.path">gff.path</code></td>
<td>
<p>character; .gff file name and path</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_org.name">org.name</code></td>
<td>
<p>character; the scientific name of the organism of interest</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_db">db</code></td>
<td>
<p>character; database from which the genome shall be retrieved; possible values are <code>"refseq", "genbank", "ensembl"</code></p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_refs">refs</code></td>
<td>
<p>logical; download genome if it isn't marked in the database as either a reference or a representative genome</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_probe.id.var">probe.id.var</code></td>
<td>
<p>vector of probes' identification numbers</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_probe.start.var">probe.start.var</code>, <code id="annotate_probes_+3A_probe.stop.var">probe.stop.var</code></td>
<td>
<p>integer; vector of probes' start and end coordinates</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_file.annot">file.annot</code></td>
<td>
<p>character; resulting annotation file name and path</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_save.format">save.format</code></td>
<td>
<p>character; format of resulting annotation file; possible values are <code>"txt", "csv"</code></p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_sep">sep</code></td>
<td>
<p>character;  field separator string</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_return">return</code></td>
<td>
<p>character; returned object; possible values are: <code>"annotation"</code> (annotation data frame),
<code>"resume"</code> (annotation attributes only), <code>"add.resume"</code> (user's data frame with added annotation attributes)</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_priority">priority</code></td>
<td>
<p>character; vector of sequence ontology types that should be returned in resume in the first place</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_data">data</code>, <code id="annotate_probes_+3A_data.probe.id.var">data.probe.id.var</code></td>
<td>
<p>users data frame and probes' identification variable in it (used if <code>return = "add.resume"</code>)</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_delete.downloads">delete.downloads</code></td>
<td>
<p>logical; delete files that were downloaded from NCBI</p>
</td></tr>
<tr><td><code id="annotate_probes_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>boimartr</code> genome annotation retrieval instruments. See <a href="biomartr.html#topic+getGFF">getGFF</a> for details.
If retrieval is not available, GFF file may be used.
</p>
<p>This function creates annotation &quot;.txt&quot; or &quot;.csv&quot; file. By default file is created in working directory.
Optionally function returns annotation resume, i.e. annotation attribute for specified sequence ontology (SO).
Priorities of SOs are set by user in <code>priopity</code> parameter.
For example, if <code>priopity = c("CDS", "gene", "region")</code>, the function returns resume for &quot;CDS&quot; SO, if there are none - for
&quot;gene&quot; CO etc.
If there are several attributes meet <code>priority</code>, the first annotation attribute is returned.
If none of <code>priority</code> COs found, the first annotation attribute is returned.
</p>
<p>Number of found annotations are indicated in returned data (<code>"ann.n" column</code>).
</p>


<h3>Value</h3>

<p>Annotation data frame, or annotation attributes, or user's data frame with added annotation attributes. Also annotation file is created.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path&lt;-tempdir()
dir.create(path) # create temporal directory
data(ann.data) # load genome annotation data frame
annotation&lt;-annotate_probes(source = "data.frame", ann.data = ann.data,
                probe.id.var = 1:5,
                probe.start.var = c (1, 100, 200, 300, 400),
                probe.stop.var = c (99, 199, 299, 399, 499),
                file.annot = paste0(path, "/annotation.txt"), save.format = "txt",
                return = "resume")
file.remove(paste0(path, "/annotation.txt")) # delete files
unlink(path, recursive = TRUE)

</code></pre>

<hr>
<h2 id='blast_local'>Local BLAST</h2><span id='topic+blast_local'></span>

<h3>Description</h3>

<p>Perform nucleotide BLAST with local database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast_local(
  probe.var,
  probe.id.var = NULL,
  fasta.way = NULL,
  blastn.way = NULL,
  db.way = NULL,
  out.way = NULL,
  mc.cores = 1,
  add.query.info = FALSE,
  temp.db = NULL,
  delete.files = FALSE,
  eval = 1000,
  ws = 7,
  reward = 1,
  penalty = -3,
  gapopen = 5,
  gapextend = 2,
  maxtargetseqs = 500,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blast_local_+3A_probe.var">probe.var</code></td>
<td>
<p>character; query - vector of nucleotide sequences</p>
</td></tr>
<tr><td><code id="blast_local_+3A_probe.id.var">probe.id.var</code></td>
<td>
<p>vector of identification numbers for query sequences</p>
</td></tr>
<tr><td><code id="blast_local_+3A_fasta.way">fasta.way</code></td>
<td>
<p>character; name and path to FASTA file</p>
</td></tr>
<tr><td><code id="blast_local_+3A_blastn.way">blastn.way</code></td>
<td>
<p>character; name and path to blastn executable file</p>
</td></tr>
<tr><td><code id="blast_local_+3A_db.way">db.way</code></td>
<td>
<p>character; name and path to local BLAST database</p>
</td></tr>
<tr><td><code id="blast_local_+3A_out.way">out.way</code></td>
<td>
<p>character; name and path to blastn output file</p>
</td></tr>
<tr><td><code id="blast_local_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="blast_local_+3A_add.query.info">add.query.info</code></td>
<td>
<p>logical; add query nucleotide sequence and its length to result</p>
</td></tr>
<tr><td><code id="blast_local_+3A_temp.db">temp.db</code></td>
<td>
<p>character; temporal SQLite database name and path</p>
</td></tr>
<tr><td><code id="blast_local_+3A_delete.files">delete.files</code></td>
<td>
<p>logical; delete created FASTA and output files</p>
</td></tr>
<tr><td><code id="blast_local_+3A_eval">eval</code></td>
<td>
<p>integer; expect value for saving hits</p>
</td></tr>
<tr><td><code id="blast_local_+3A_ws">ws</code></td>
<td>
<p>integer; length of initial exact match</p>
</td></tr>
<tr><td><code id="blast_local_+3A_reward">reward</code></td>
<td>
<p>integer; reward for a nucleotide match</p>
</td></tr>
<tr><td><code id="blast_local_+3A_penalty">penalty</code></td>
<td>
<p>integer; penalty for a nucleotide mismatch</p>
</td></tr>
<tr><td><code id="blast_local_+3A_gapopen">gapopen</code></td>
<td>
<p>integer; cost to open a gap</p>
</td></tr>
<tr><td><code id="blast_local_+3A_gapextend">gapextend</code></td>
<td>
<p>integer; cost to extend a gap</p>
</td></tr>
<tr><td><code id="blast_local_+3A_maxtargetseqs">maxtargetseqs</code></td>
<td>
<p>integer; number of aligned sequences to keep</p>
</td></tr>
<tr><td><code id="blast_local_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function BLAST+ executables (blastn) must be installed and local nucleotide database must be created.
</p>
<p>While working, the function creates blastn input FASTA file and output file. If files exist already, they will be overwritten.
Those files could be deleted by <code>delete.files = TRUE</code> parameter.
</p>
<p>If no <code>probe.id.var</code> is provided, query sequences are numbered in order, starting with 1.
</p>
<p>Query cover is query coverage per HSP (as a percentage)
</p>
<p>If <code>add.query.info = TRUE</code> function saves data in temporal SQLite database.
Function will stop if same database already exists, so deleting temporal database
(by setting <code>delete.files = TRUE</code>) is highly recommended.
</p>
<p>&quot;no lines available in input&quot; error is returned when there are no BLAST results matching the specified parameters. Adjust BLAST parameters.
</p>


<h3>Value</h3>

<p>Data frame with BLAST alignments: query sequence id, start and end of alignment in query, subject GI, accession, title and taxon id,
start and end of alignment in subject, length of alignment, number of mismatches and gaps, number of identical matches,
raw score, bit score, expect value and query cover.
If <code>add.result.info = TRUE</code>, query sequence and its length are also added to data frame.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Camacho C., Coulouris G., Avagyan V. et al. (2009). BLAST+: architecture and applications. BMC Bioinformatics 10, 421.
<a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-421">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-421</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This function is using BLAST applications. BLAST+ should be installed.
# Local nucleotide database should be created
# Local database of target sequences of Chlamydia pneumoniae was created
# in temporal directory previously (see make_blast_DB () function)
path &lt;- tempdir()
dir.create (path)
#set probes for local BLAST
probes &lt;- c ("catctctatttcggtagcagctcc", "aaagtcatagaaaagcctgtagtcgc",
            "ccttcttctcgaactctgaagtacact", "aaaaaaaaaaaaaaaaa", "acacacacacacaac")
blast.raw &lt;- blast_local(probe.var = probes, probe.id.var = NULL,
                        fasta.way = paste0 (path, "/blast.fasta"),
                        blastn.way = "D:/Blast/blast-2.11.0+/bin/blastn.exe",
                        db.way = paste0 (path, "/DB"),
                        out.way = paste0 (path, "/blast.out"),
                        mc.cores=1, add.query.info = TRUE, temp.db = paste0 (path, "/temp.db"),
                        delete.files = TRUE, eval = 1, maxtargetseqs = 200)

## End(Not run)

</code></pre>

<hr>
<h2 id='blast.fill'>Local BLAST results with added content.</h2><span id='topic+blast.fill'></span>

<h3>Description</h3>

<p>Result of BLAST of 5 probes against local database of target nucleotide sequences
of Chlamydia pneumoniae. Local BLAST was performed with blast_local () function.
Subjects' Genbank Identifiers are added with fill_blast_result () function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast.fill
</code></pre>


<h3>Format</h3>

<p>A data frame with 72 rows and 19 variables:
</p>

<dl>
<dt>probe</dt><dd><p>probe sequence</p>
</dd>
<dt>probe.length</dt><dd><p>probe sequence's length</p>
</dd>
<dt>Qid</dt><dd><p>query identification number</p>
</dd>
<dt>Qstart</dt><dd><p>query start position</p>
</dd>
<dt>Qend</dt><dd><p>query end position</p>
</dd>
<dt>Rgi</dt><dd><p>subject GenInfo Identifier number</p>
</dd>
<dt>Racc</dt><dd><p>subject NCBI accession number</p>
</dd>
<dt>Rtitle</dt><dd><p>subject title</p>
</dd>
<dt>Rtaxid</dt><dd><p>subject taxon identificator</p>
</dd>
<dt>Rstart</dt><dd><p>subject start position</p>
</dd>
<dt>Rend</dt><dd><p>subject end position</p>
</dd>
<dt>alig.length</dt><dd><p>length of alignment</p>
</dd>
<dt>mismatch</dt><dd><p>amount of mismatches</p>
</dd>
<dt>gaps</dt><dd><p>amount of gaps</p>
</dd>
<dt>ident.number</dt><dd><p>amount of identical positions</p>
</dd>
<dt>score</dt><dd><p>alignment score</p>
</dd>
<dt>bitscore</dt><dd><p>alignment bitscore</p>
</dd>
<dt>Evalue</dt><dd><p>alignment e-value</p>
</dd>
<dt>Qcover</dt><dd><p>query coverage, %</p>
</dd>
</dl>


<hr>
<h2 id='blast.raw'>Local BLAST results.</h2><span id='topic+blast.raw'></span>

<h3>Description</h3>

<p>Result of BLAST of 5 probes against local database of target nucleotide sequences
of Chlamydia pneumoniae. Local BLAST was performed with blast_local () function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blast.raw
</code></pre>


<h3>Format</h3>

<p>A data frame with 72 rows and 19 variables:
</p>

<dl>
<dt>probe</dt><dd><p>probe sequence</p>
</dd>
<dt>probe.length</dt><dd><p>probe sequence's length</p>
</dd>
<dt>Qid</dt><dd><p>query identification number</p>
</dd>
<dt>Qstart</dt><dd><p>query start position</p>
</dd>
<dt>Qend</dt><dd><p>query end position</p>
</dd>
<dt>Rgi</dt><dd><p>subject GenInfo Identifier number</p>
</dd>
<dt>Racc</dt><dd><p>subject NCBI accession number</p>
</dd>
<dt>Rtitle</dt><dd><p>subject title</p>
</dd>
<dt>Rtaxid</dt><dd><p>subject taxon identificator</p>
</dd>
<dt>Rstart</dt><dd><p>subject start position</p>
</dd>
<dt>Rend</dt><dd><p>subject end position</p>
</dd>
<dt>alig.length</dt><dd><p>length of alignment</p>
</dd>
<dt>mismatch</dt><dd><p>amount of mismatches</p>
</dd>
<dt>gaps</dt><dd><p>amount of gaps</p>
</dd>
<dt>ident.number</dt><dd><p>amount of identical positions</p>
</dd>
<dt>score</dt><dd><p>alignment score</p>
</dd>
<dt>bitscore</dt><dd><p>alignment bitscore</p>
</dd>
<dt>Evalue</dt><dd><p>alignment e-value</p>
</dd>
<dt>Qcover</dt><dd><p>query coverage, %</p>
</dd>
</dl>


<hr>
<h2 id='count_PhCh'>Calculate physical and chemical properties</h2><span id='topic+count_PhCh'></span><span id='topic+count_GC'></span><span id='topic+count_REP'></span><span id='topic+count_MFE'></span><span id='topic+count_TM'></span>

<h3>Description</h3>

<p>Calculates GC-content, detects several nucleotides in a row, calculates minimum folding energy and melting temperature for oligonucleotide probes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_PhCh(
  probe.var,
  trim = FALSE,
  data,
  digits = 4,
  mc.cores = 1,
  MFE.files.dir = NULL,
  delete.MFE.files = FALSE,
  GCmin = 40,
  GCmax = 60,
  nucl.pattern = c("a", "t", "g", "c"),
  n.crit = 5,
  RNAfold.path,
  temperature = 40,
  MFEmin = -3,
  TD.params = NULL,
  TMmin = 55,
  TMmax = 60,
  verbose = TRUE,
  Na = 50,
  K = 0,
  Tris = 0,
  Mg = 0,
  dNTPs = 0
)

count_GC(
  probe.var,
  trim.gc = FALSE,
  GCmin = 40,
  GCmax = 60,
  mc.cores = 1,
  add.to.data = FALSE,
  data,
  digits = 4
)

count_REP(
  probe.var,
  trim.rep = FALSE,
  nucl.pattern = c("a", "t", "g", "c"),
  n.crit = 5,
  mc.cores = 1,
  add.to.data = FALSE,
  data
)

count_MFE(
  probe.var,
  RNAfold.path,
  temperature = 40,
  trim.mfe = FALSE,
  MFEmin = -3,
  add.to.data = FALSE,
  data,
  MFE.files.dir = NULL,
  delete.MFE.files = FALSE,
  mc.cores = 1,
  digits = 4,
  verbose = TRUE
)

count_TM(
  probe.var,
  TD.params = NULL,
  trim.tm = FALSE,
  TMmin = 55,
  TMmax = 60,
  add.to.data = FALSE,
  data,
  digits = 4,
  mc.cores = 1,
  verbose = TRUE,
  Na = 50,
  K = 0,
  Tris = 0,
  Mg = 0,
  dNTPs = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_PhCh_+3A_probe.var">probe.var</code></td>
<td>
<p>character; vector of nucleotide probes</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_trim">trim</code>, <code id="count_PhCh_+3A_trim.gc">trim.gc</code>, <code id="count_PhCh_+3A_trim.rep">trim.rep</code>, <code id="count_PhCh_+3A_trim.mfe">trim.mfe</code>, <code id="count_PhCh_+3A_trim.tm">trim.tm</code></td>
<td>
<p>logical; whether to select results that meet the criterion</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to round the result</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_mfe.files.dir">MFE.files.dir</code></td>
<td>
<p>character; directory for RNAfold input and output files</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_delete.mfe.files">delete.MFE.files</code></td>
<td>
<p>logical; delete RNAfold input and output files</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_gcmin">GCmin</code>, <code id="count_PhCh_+3A_gcmax">GCmax</code></td>
<td>
<p>numeric; minimum and maximum value of GC-content (percent, used if <code>trim = TRUE</code>)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_nucl.pattern">nucl.pattern</code></td>
<td>
<p>character; vector of nucleotide pattern</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_n.crit">n.crit</code></td>
<td>
<p>integer; minimal amount of nucleotide pattern's repeats in a row to detect</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_rnafold.path">RNAfold.path</code></td>
<td>
<p>character; name and path to RNAfold executable file</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_temperature">temperature</code></td>
<td>
<p>numeric; folding design temperature</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_mfemin">MFEmin</code></td>
<td>
<p>numeric; maximum value of folding energy (used if <code>trim = TRUE</code>)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_td.params">TD.params</code></td>
<td>
<p>character; vector of length 4, contains designation for four tables with thermodynamic values
(nn_table - thermodynamic NN values, tmm_table - thermodynamic values for terminal mismatches,
imm_table -  thermodynamic values for internal mismatches, de_table - thermodynamic values for dangling ends).
See <a href="TmCalculator.html#topic+Tm_NN">Tm_NN</a> for details.</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_tmmin">TMmin</code>, <code id="count_PhCh_+3A_tmmax">TMmax</code></td>
<td>
<p>numeric; minimum and maximum value of melting temperature (used if <code>trim = TRUE</code>)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_na">Na</code></td>
<td>
<p>numeric; millimolar concentration of Na, default is 50 (used for <code>count_TM</code> function)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_k">K</code></td>
<td>
<p>numeric; millimolar concentration of K, default is 0 (used for <code>count_TM</code> function)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_tris">Tris</code></td>
<td>
<p>numeric; millimolar concentration of Tris, default is 0 (used for <code>count_TM</code> function)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_mg">Mg</code></td>
<td>
<p>numeric; millimolar concentration of Mg, default is 0 (used for <code>count_TM</code> function)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_dntps">dNTPs</code></td>
<td>
<p>numeric; millimolar concentration of dNTPs, default is 0 (used for <code>count_TM</code> function)</p>
</td></tr>
<tr><td><code id="count_PhCh_+3A_add.to.data">add.to.data</code>, <code id="count_PhCh_+3A_data">data</code></td>
<td>
<p>logical; add result vector to specified data frame (used unconditionally if <code>trim = TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GC-content trimming selects results that are between <code>GCmin</code> and <code>GCmax</code> (inclusive).
Nucleotides' amount trimming deletes probes that contain <code>n.crit</code> or more of same nucleotides (pattern) in a row.
Minimum folding energy trimming selects results that are equal or more than <code>MFEmin</code>.
Melting temperature trimming selects results that are between <code>TMmin</code> and <code>TMmax</code> (inclusive).
</p>
<p>This function is using ViennaRNA service to count minimum folding energy. ViennaRNA Package (UNIX or Windows) must be installed.
While counting MFE, working directory is set to <code>MFE.files.dir</code> and input and output files
for ViennaRNA (&quot;seq_in&quot; and &quot;seq_out&quot;) are created in the working directory.Afterwards the working directory is changed back to user's setting.
If no <code>MFE.files.dir</code> exists it is created and is not deleted even if <code>delete.MFE.files = TRUE</code>.
</p>
<p>Melting temperature is counted with <a href="TmCalculator.html#topic+Tm_NN">Tm_NN</a> function. Indication of thermodynamic values must be provided.
By default they are: nn_table = &quot;DNA_NN4&quot;, tmm_table = &quot;DNA_TMM1&quot;, imm_table = &quot;DNA_IMM1&quot;, de_table = &quot;DNA_DE1&quot;.
</p>


<h3>Value</h3>

<p>If <code>trim = FALSE</code>, <code>count_PhCh</code> function returns data frame with GC-count (<code>GC.percent</code>),
nucleotide repeats (<code>repeats</code>, TRUE/FALSE), minimum folding energy (<code>MFE</code>) and melting temperature (<code>TM</code>) columns.
If <code>trim = TRUE</code>, <code>count_PhCh</code> function returns provided data frame with attached four columns
and rows selected according to values <code>GCmin, GCmax, n.crit, MFEmin, TMmin, TMmax</code>.
</p>
<p>If <code>trim.gc= FALSE</code>, <code>count_GC</code> function returns <code>GC.percent</code> vector or data with attached <code>GC.percent</code> column (when <code>add.to.data = TRUE</code>).
If <code>trim.gc = TRUE</code>, <code>count_GC</code> function returns provided data frame with attached <code>GC.percent</code> column and rows selected according to <code>GCmin, GCmax</code> values.
</p>
<p>If <code>trim.rep = FALSE</code>, <code>count_REP</code> function returns <code>repeats</code> vector (logical; TRUE/FALSE - there are/there are no nucleotide repeats) or data with attached <code>repeats</code> column (when <code>add.to.data = TRUE</code>).
If <code>trim.rep = TRUE</code>, <code>count_REP</code> function returns provided data frame with attached <code>repeats</code> column and rows selected according to <code>n.crit</code> value.
</p>
<p>If <code>trim.mfe = FALSE</code>, <code>count_MFE</code> function returns <code>MFE</code> vector or data with attached <code>MFE</code> column (when <code>add.to.data = TRUE</code>).
If <code>trim.mfe = TRUE</code>, <code>count_MFE</code> function returns provided data frame with attached <code>MFE</code> column and rows selected according to <code>MFEmin</code> value.
</p>
<p>If <code>trim.tm = FALSE</code>, <code>count_TM</code> function returns <code>TM</code> vector or data with attached <code>TM</code> column (when <code>add.to.data = TRUE</code>).
If <code>trim.tm = TRUE</code>, <code>count_TM</code> function returns provided data frame with attached <code>TM</code> column and rows selected according to <code>TMmin, TMmax</code> values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>count_PhCh</code>: Calculates GC.percent, detects several nucleotides in a row, calculates minimum folding energy and melting temperature
</p>
</li>
<li> <p><code>count_GC</code>: Calculates GC-content (percent)
</p>
</li>
<li> <p><code>count_REP</code>: Detects several nucleotides in a row
</p>
</li>
<li> <p><code>count_MFE</code>: Calculates minimum folding energy
</p>
</li>
<li> <p><code>count_TM</code>: Calculates melting temperature
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Lorenz R., Stephan H.B., Höner zu Siederdissen C. et al. (2011). ViennaRNA Package 2.0. Algorithms for Molecular Biology, 6, 1.
<a href="https://almob.biomedcentral.com/articles/10.1186/1748-7188-6-26">https://almob.biomedcentral.com/articles/10.1186/1748-7188-6-26</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probes &lt;- data.frame (ids = 1:3,  probes = c ("acacacacacaca", "aaaaagggggtttttccccc",
                                             "atgcgctagctcagc"))
probes &lt;- count_GC (probe.var = probes$probes, trim.gc = FALSE, GCmin = 40, GCmax = 60,
                   add.to.data = TRUE, data = probes)

probes &lt;- count_REP (probe.var = probes$probes, trim.rep = FALSE, n.crit = 5,
                    add.to.data = TRUE, data = probes)
## Not run: 
# This function is using ViennaRNA service. ViennaRNA Package must be installed.
MFE.files.dir &lt;- tempdir()
probes &lt;- count_MFE (probe.var = probes$probes, RNAfold.path = "D:/Vienna/RNAfold.exe",
                    temperature = 40, trim.mfe = FALSE, MFEmin = 0,
                    MFE.files.dir = MFE.files.dir, delete.MFE.files = TRUE,
                    add.to.data = TRUE, data = probes, mc.cores = 1)
unlink (MFE.files.dir, recursive = TRUE)

## End(Not run)
probes &lt;- count_TM (probe.var = probes$probes, TD.params = NULL, trim.tm = FALSE,
                   TMmin = 55, TMmax = 60, add.to.data = TRUE, data = probes,
                   digits = 4, mc.cores = 1)
# All in one command
## Not run: 
# This function is using ViennaRNA service. ViennaRNA Package must be installed.
MFE.files.dir &lt;- tempdir()
probes2 &lt;- count_PhCh (probe.var = probes$probes, trim = FALSE,
                      nucl.pattern = c ("a", "t", "g", "c"), n.crit = 5,
                      MFE.files.dir = MFE.files.dir, delete.MFE.files = TRUE,
                      RNAfold.path = "D:/Vienna/RNAfold.exe", temperature = 40,
                      TD.params = NULL, digits = 3, mc.cores = 1,
                      data = probes)
unlink (MFE.files.dir, recursive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cut_probes'>Cut probes</h2><span id='topic+cut_probes'></span>

<h3>Description</h3>

<p>Generate probes from nucleotide reference sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_probes(
  ref.seq.from.file = FALSE,
  ref.seq.id,
  ref.seq.db,
  fasta.file = NULL,
  delete.fasta = FALSE,
  start = 1,
  stop = NULL,
  start.correction = FALSE,
  size = 24:32,
  delete.incomplete = FALSE,
  delete.identical = FALSE,
  give.probes.id = FALSE,
  mc.cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_probes_+3A_ref.seq.from.file">ref.seq.from.file</code></td>
<td>
<p>logical; read reference sequences from file (<code>TRUE</code>) or download them from NCBI data base (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_ref.seq.id">ref.seq.id</code></td>
<td>
<p>identification number of reference nucleotide sequences. Only used when <code>ref.seq.from.file = FALSE</code>.
GenBank accession numbers, GenInfo identifiers (GI) or Entrez unique identifiers (UID) may be used.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_ref.seq.db">ref.seq.db</code></td>
<td>
<p>character; NCBI database for search. See <a href="rentrez.html#topic+entrez_dbs">entrez_dbs</a> for possible values.
Only used when <code>ref.seq.from.file = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_fasta.file">fasta.file</code></td>
<td>
<p>character; FASTA file name and path, only used when <code>ref.seq.from.file = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_delete.fasta">delete.fasta</code></td>
<td>
<p>logical; delete FASTA file.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_start">start</code>, <code id="cut_probes_+3A_stop">stop</code></td>
<td>
<p>integer; number of first and last nucleotide of the reference sequence's segment that should be cut into probes.
All sequence is used by default.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_start.correction">start.correction</code></td>
<td>
<p>logical; count probes' start and stop nucleotides relatively to the specified segment (<code>FALSE</code>)
or to the whole sequence (<code>TRUE</code>). Only used if <code>start&gt;1</code>.</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_size">size</code></td>
<td>
<p>integer; vector of probe size</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_delete.incomplete">delete.incomplete</code></td>
<td>
<p>logical; remove probes that contain undeciphered nucleotides</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_delete.identical">delete.identical</code></td>
<td>
<p>logical; remove identical (duplicated) probes</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_give.probes.id">give.probes.id</code></td>
<td>
<p>logical; add probes' identification numbers</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="cut_probes_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes nucleotide sequences and cut them on segments (probes) of given size.
Sequences might be downloaded from given FASTA file or from NCBI data bases.
In the latter case, FASTA file is created.
If desired, FASTA file can be deleted after.
</p>
<p>Not all sequence must be cut on probes, you may define needed segment by <code>start</code> and <code>stop</code> parameters.
Note that in this case probes' start and stop nucleotides would be counted relatively to the specified segment (<code>start.correction = FALSE</code>)
or to the whole sequence (<code>start.correction = TRUE</code>).
</p>
<p>Undeciphered nucleotides are the one that are indicated by &quot;rywsmkhbvdn&quot; symbols.
</p>
<p>Probes' identification numbers are created by adding numeric indexes to reference sequence's identification number.
</p>
<p>See <a href="#topic+cut_string">cut_string</a>, <a href="#topic+delete_duplicates_DF">delete_duplicates_DF</a> and <a href="#topic+make_ids">make_ids</a> for details.
</p>


<h3>Value</h3>

<p>Data frame with probe id (optionally), sequence id, probe size, start and stop nucleotide, sequence.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- tempdir()
dir.create (path)
# download and save as FASTA "Chlamydia pneumoniae B21 contig00001,
# whole genome shotgun sequence" (GI = 737435910)
if (!requireNamespace("rentrez", quietly = TRUE)) {
stop("Package \"rentrez\" needed for this function to work. Please install it.", call. = FALSE)}
reference.string &lt;- rentrez::entrez_fetch(db = "nucleotide", id = 737435910,
                                         rettype="fasta")
write( x= reference.string, file = paste0 (path, "/fasta"))
probes &lt;- cut_probes (ref.seq.from.file = TRUE, fasta.file = paste0(path, "/fasta"),
                     delete.fasta = TRUE, start = 1000, stop = 1500,
                     start.correction = FALSE, size = c(400, 500),
                     delete.incomplete = FALSE,
                     delete.identical = FALSE, give.probes.id = TRUE, mc.cores = 1)
unlink (path, recursive = TRUE)

</code></pre>

<hr>
<h2 id='cut_string'>Cut string into segments</h2><span id='topic+cut_string'></span>

<h3>Description</h3>

<p>Cuts character string into segments of given size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_string(string, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_string_+3A_string">string</code></td>
<td>
<p>character string; vector of length 1</p>
</td></tr>
<tr><td><code id="cut_string_+3A_size">size</code></td>
<td>
<p>integral; vector of length of segments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with one string only.
Segments are cut from start to end of a string.
<code>size</code> might be a vector of any length, all possible variants will be cut.
</p>


<h3>Value</h3>

<p>Data frame with segment size, start and end point, segment string.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cut_string (string = "aaatttttttccgc", size = 12:14)

</code></pre>

<hr>
<h2 id='delete_duplicates_DF'>Delete rows with duplicated values</h2><span id='topic+delete_duplicates_DF'></span>

<h3>Description</h3>

<p>Delete data frame rows if they contain duplicated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_duplicates_DF(
  data,
  duplicated.var,
  exact = FALSE,
  stay = "first",
  choose.var,
  choose.stay.val,
  pattern,
  mc.cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_duplicates_DF_+3A_data">data</code></td>
<td>
<p>data frame;</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_duplicated.var">duplicated.var</code></td>
<td>
<p>variable that contains duplicated values</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_exact">exact</code></td>
<td>
<p>logical; values are to be matched as is</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_stay">stay</code></td>
<td>
<p>character; which row with duplicated values will stay; possible values are <code>"first"</code> (first of rows),
<code>"choose"</code> (depending of the value of other variable) and <code>"none"</code> (rows with values that contain pattern will be removed)</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_choose.var">choose.var</code>, <code id="delete_duplicates_DF_+3A_choose.stay.val">choose.stay.val</code></td>
<td>
<p>vector of additional variable to choose the preferred row and it's preferred value
(used if <code>stay = "choose"</code>)</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_pattern">pattern</code></td>
<td>
<p>deleted pattern (used if <code>stay = "none"</code>)</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="delete_duplicates_DF_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks if there are repeated values in the data frame (in the <code>duplicated.var</code>).
If repeated values are found, the first row with duplicated value stays, others are deleted (if <code>stay = "first"</code>).
If <code>stay = "choose"</code> the first row with duplicated values and <code>choose.var = choose.stay.val</code> will stay.
If there are no rows with <code>choose.var = choose.stay.val</code>, the first row will stay.
</p>
<p>If <code>stay = "none"</code> all rows with values that contain pattern will be removed.
</p>


<h3>Value</h3>

<p>Data frame without rows that contain duplicates in <code>duplicated.var</code>
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame (N = c(1:5, 11:15), name = c(rep( "A",4), "AA", rep( "B",3), "BB", "C"),
                choose = c(rep(c("yes", "no"), 3), "yes", "yes", "no", "no"))
delete_duplicates_DF (data = data, duplicated.var = data$N, exact = TRUE, stay = "first")
delete_duplicates_DF (data = data, duplicated.var = data$N, exact = FALSE, stay = "first")
delete_duplicates_DF (data = data, duplicated.var = data$name, exact = TRUE, stay = "first")
delete_duplicates_DF (data = data, duplicated.var = data$name, exact = TRUE,
                    stay = "choose", choose.var = data$choose, choose.stay.val = "yes")
delete_duplicates_DF (data = data, duplicated.var = data$name, exact = FALSE, stay = "first")
delete_duplicates_DF (data = data, duplicated.var = data$name, exact = FALSE,
                    stay = "choose", choose.var = data$choose, choose.stay.val = "yes")
delete_duplicates_DF (data =data, duplicated.var = data$name, stay = "none",
                    pattern = c("A", "B"), exact = TRUE)
delete_duplicates_DF (data =data, duplicated.var = data$name, stay = "none",
                    pattern = c("A", "B"), exact = FALSE)

</code></pre>

<hr>
<h2 id='fill_blast_result'>Complement BLAST result</h2><span id='topic+fill_blast_result'></span><span id='topic+fill_blast_results'></span><span id='topic+delete_AcNum_version'></span>

<h3>Description</h3>

<p>Provides subjects' GenInfo Identifiers if BLAST alignment result does not contain one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_blast_results(
  blast.result,
  AcNum.column.name = "Racc",
  GI.column.name = "Rgi",
  delete.version = FALSE,
  version.sep = ".",
  add.gi = "DB",
  add.gi.df,
  temp.db = NULL,
  delete.temp = FALSE,
  add.gi.db = NULL,
  add.gi.table = NULL,
  add.gi.ac.column.name = "AC",
  add.gi.gi.column.name = "GI",
  mc.cores = 1,
  verbose = TRUE
)

delete_AcNum_version(ac.num.var, version.sep = ".", mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_blast_result_+3A_blast.result">blast.result</code></td>
<td>
<p>data frame; BLAST alignment result</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_acnum.column.name">AcNum.column.name</code>, <code id="fill_blast_result_+3A_gi.column.name">GI.column.name</code></td>
<td>
<p>character; name of column with subject
accession numbers and GenInfo Identifier numbers from BLAST result data frame</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_delete.version">delete.version</code></td>
<td>
<p>logical; remove version suffix from subject accession number</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_version.sep">version.sep</code></td>
<td>
<p>character; accession number and version suffix separator (a dot for NCBI accession numbers)</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_add.gi">add.gi</code></td>
<td>
<p>character; table with linked accession and GI numbers is taken from
SQLite database (<code>"DB"</code>) or data frame (<code>"DF"</code>)</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_add.gi.df">add.gi.df</code></td>
<td>
<p>data frame with table (used if <code>add.gi = "DF"</code>)</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_temp.db">temp.db</code></td>
<td>
<p>character; temporal SQLite database name and path</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_delete.temp">delete.temp</code></td>
<td>
<p>logical; delete created temporal SQLite database</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_add.gi.db">add.gi.db</code>, <code id="fill_blast_result_+3A_add.gi.table">add.gi.table</code>, <code id="fill_blast_result_+3A_add.gi.ac.column.name">add.gi.ac.column.name</code>, <code id="fill_blast_result_+3A_add.gi.gi.column.name">add.gi.gi.column.name</code></td>
<td>
<p>SQLite database name and path,
table name and name of columns with accession and GI numbers (used if <code>add.gi = "DB"</code>)</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="fill_blast_result_+3A_ac.num.var">ac.num.var</code></td>
<td>
<p>vector of accession numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BLAST alignment, performed with local database, may not contain subject GI information. Also subject accession may contain version suffix.
This can make it difficult to analyze the results further. This function adds subject GI and removes subject accession version suffix.
</p>
<p>To add GI GenInfo Identifiers table with them linked to accession numbers must be provided as data frame or SQLite database table.
<code>add.gi.df</code> must be a data frame with column one - accession numbers, column two - GenInfo Identifier numbers.
If <code>add.gi = "DF"</code> temporal SQLite database is created.
</p>
<p>SQLite database table with accession and GI numbers should not contain duplicated rows.
It is also highly recommended to index accession numbers' variable in database.
</p>
<p><code>delete.version</code> executes in the first step, so if you use this option accession numbers
in <code>add.gi</code> table must not contain version suffix.
</p>
<p><code>AcNum.column.name</code>, <code>GI.column.name</code>, <code>add.gi.ac.column.name</code> and <code>dd.gi.gi.column.name</code>
must be column names exactly as in data frame.
</p>


<h3>Value</h3>

<p><code>blast.result</code> data frame with added GI and deleted accession version suffix.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fill_blast_results</code>: Provides subjects' Genbank Identifiers if BALST alignment result does not contain one
</p>
</li>
<li> <p><code>delete_AcNum_version</code>: Remove accession version suffix
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- tempdir()
dir.create (path)
# load raw blast results
data (blast.raw)
#load meta.target with result (targets' sequences) GI and Acc.nums
data (meta.target)
blast.fill &lt;- fill_blast_results(blast.result = blast.raw, delete.version = TRUE,
                                 add.gi = "DF", add.gi.df = meta.target[, c("GB_AcNum", "gi")],
                                 temp.db = paste0 (path, "/temp.db"), delete.temp = TRUE)

</code></pre>

<hr>
<h2 id='get_GA_files'>Read GISAID sequence file</h2><span id='topic+get_GA_files'></span>

<h3>Description</h3>

<p>Get metadata and nucleotide sequence from GISAID files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_GA_files(
  dir.path,
  return = "both",
  seq.return = "data.frame",
  fasta.file = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_GA_files_+3A_dir.path">dir.path</code></td>
<td>
<p>character; directory name and path</p>
</td></tr>
<tr><td><code id="get_GA_files_+3A_return">return</code></td>
<td>
<p>character; type of returned object; possible values are:
<code>"info"</code> (sequence metadata), <code>"seq"</code> (nucleotide sequences), <code>"both"</code> (both of them).</p>
</td></tr>
<tr><td><code id="get_GA_files_+3A_seq.return">seq.return</code></td>
<td>
<p>character; sequence returned object;  possible values are &quot;vector&quot;, &quot;data.frame&quot; and &quot;fasta&quot;</p>
</td></tr>
<tr><td><code id="get_GA_files_+3A_fasta.file">fasta.file</code></td>
<td>
<p>character; FASTA file name and path, only used if <code>return = "fasta"</code></p>
</td></tr>
<tr><td><code id="get_GA_files_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with downloaded from GISAID &quot;Input for the Augur pipeline&quot; archives
(with &quot;metadata.tsv&quot; and &quot;sequences.fasta&quot; files).
Archives must be unzipped before usage.
All extracted from GISAID archive files must be in one directory.
</p>
<p>If <code>return = "seq"</code>, serial numbers are used as sequence identification numbers.
</p>
<p>Metadata is transformed into data frame of the same format as <a href="#topic+get_seq_info">get_seq_info</a> function does.
Sequences are transformed into data type of the same format as <a href="#topic+get_seq_for_DB">get_seq_for_DB</a> function does.
</p>


<h3>Value</h3>

<p>List of length two, where first is metadata and second is nucleotide sequence.
If <code>return = "info"</code> or <code>return = "seq"</code> only first or second element is returned.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First download some sequences' archives from GISAID (https://www.gisaid.org/)
# unzip them and put into "gisaidfiles" directory

res &lt;- get_GA_files (dir.path = "gisaidfiles", return = "info")
res &lt;- get_GA_files (dir.path = "gisaidfiles", return = "seq", seq.return = "data.frame")
res &lt;- get_GA_files (dir.path = "gisaidfiles", return ="both", seq.return = "fasta")

## End(Not run)

</code></pre>

<hr>
<h2 id='get_GIs'>Get GenInfo Identifier numbers</h2><span id='topic+get_GIs'></span><span id='topic+get_GIs_fix'></span>

<h3>Description</h3>

<p>Retrieves NCBI sequence identifiers (GIs) for given organism name or taxon identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_GIs(
  org.name,
  db,
  n.start = 1,
  n.stop = NULL,
  step = 99999,
  return.vector = TRUE,
  check.result = FALSE,
  term = NULL,
  temp.dir = NULL,
  delete.temp = FALSE,
  verbose = TRUE
)

get_GIs_fix(
  gis.list,
  org.name,
  db,
  n.start = 1,
  n.stop = NULL,
  step = 99999,
  term = NULL,
  temp.dir = NULL,
  delete.temp = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_GIs_+3A_org.name">org.name</code></td>
<td>
<p>character; scientific name or taxon identifier (written as &quot;txid0000&quot;) of the organism/taxon.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_db">db</code></td>
<td>
<p>character; NCBI database for search. See <a href="rentrez.html#topic+entrez_dbs">entrez_dbs</a>() for possible values.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_n.start">n.start</code></td>
<td>
<p>integer; download starting value. Default is 1.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_n.stop">n.stop</code></td>
<td>
<p>integer; download finishing value. Default is NULL, which provides retrieval of all available GIs.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_step">step</code></td>
<td>
<p>integer; download increment value.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_return.vector">return.vector</code></td>
<td>
<p>logical; whether to return GI numbers as character vector (another variant is list of vectors).</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_check.result">check.result</code></td>
<td>
<p>logical; check if download was done correctly.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_term">term</code></td>
<td>
<p>character; search query.</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_temp.dir">temp.dir</code></td>
<td>
<p>character; name and path of directory for downloaded temporary files (only for &quot;Windows&quot; OS)</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_delete.temp">delete.temp</code></td>
<td>
<p>logical; delete downloaded files (only for &quot;Windows&quot; OS, does not delete directory).</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="get_GIs_+3A_gis.list">gis.list</code></td>
<td>
<p>list of previously downloaded GIs vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends the query to NCBI database and returns sequence identifiers according to the query. By default the
query is organism, so the function returns GI numbers for all sequences that are associated with the requested organism.
For example, if <code>org.name = "Homo sapiens"</code> the function will download GI numbers for all sequences that answer the query
&quot;Homo sapiens[Organism]&quot;. For any other query use parameter <code>term</code>.
</p>
<p>The function downloads GI numbers by piecemeal, by several pieces in one block. The size of the block is defined by parameter
<code>step</code>. It is useful if by any reason the download was interrupted, so later it is possible to reload only
the missing blocks without the need to reload the entire amount of data. By default, all available GI numbers are downloaded,
but you may also choose start and finish notes by specifying the parameters <code>n.start</code> and <code>n.stop</code>. The numeration starts with 1, not 0.
At the end the resulting list of blocks (list of character vectors) is unlisted into one character vector. You may prevent this by setting
<code>return.vector = FALSE</code>. Also, regardless of <code>return.vector</code> settings, the list of blocks is returned if the download was somehow compromised.
</p>
<p>If download was corrupted you may use <code>get_GIs_fix()</code> function to reload the missing block. The corrupted list of blocks
should be set in <code>gis.list</code> parameter. You may also check and reload data when <code>get_GIs()</code> function is running
by specifying <code>check.result = TRUE</code>.
</p>
<p>The function checks for user's OS type. For Windows temporal files are created while downloading,
so <code>temp.dir</code> and <code>delete.temp</code> parameters should be set. This helps to solve the
&quot;routines:SSL23_GET_SERVER_HELLO:tlsv1 alert protocol version&quot; problem by using <code>curl</code> instead of <code>RCurl</code>.
However it slows down the function.If there is no <code>temp.dir</code> directory, it will be
created and will not be removed (only temporal files will be deleted if <code>delete.temp = TRUE</code>).
</p>
<p>In progress the functions turn off and on scientific notation.
</p>


<h3>Value</h3>

<p><code>get_GIs()</code> returns character vector of GI numbers. If <code>return.vector = FALSE</code> or there are missing data,
list of character vectors is returned.
</p>
<p><code>get_GIs_fix()</code> returns list of character vectors.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_GIs</code>: Retrieves NCBI sequence identifiers (GIs) for given organism name or taxon identifier.
</p>
</li>
<li> <p><code>get_GIs_fix</code>: Checks the downloads and tries to retrieve the compromised data.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gi.list&lt;-get_GIs(org.name="txid9606", db="nucleotide",
                n.start=1, n.stop=3, step=1,
                return.vector = FALSE, check.result=TRUE,
                temp.dir = tempdir(),  delete.temp=TRUE)

</code></pre>

<hr>
<h2 id='get_seq_for_DB'>Get nucleotide sequences from NCBI</h2><span id='topic+get_seq_for_DB'></span><span id='topic+get_seq_for_DB_fix'></span>

<h3>Description</h3>

<p>Retrieves nucleotide sequences from NCBI for given identification numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seq_for_DB(
  ids,
  db,
  check.result = FALSE,
  return = "data.frame",
  fasta.file = NULL,
  exclude.from.download = FALSE,
  exclude.var,
  exclude.pattern,
  exclude.fixed = TRUE,
  verbose = TRUE
)

get_seq_for_DB_fix(res.data, db, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_seq_for_DB_+3A_ids">ids</code></td>
<td>
<p>vector of NCBI sequences' identification numbers: GenBank accession numbers, GenInfo identifiers (GI) or Entrez unique identifiers (UID)</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_db">db</code></td>
<td>
<p>character; NCBI database for search. See <a href="rentrez.html#topic+entrez_dbs">entrez_dbs</a>() for possible values</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_check.result">check.result</code></td>
<td>
<p>logical; check if download was done correctly</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_return">return</code></td>
<td>
<p>character; sequence returned object; possible values are &quot;vector&quot;, &quot;data.frame&quot; and &quot;fasta&quot;</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_fasta.file">fasta.file</code></td>
<td>
<p>character; FASTA file name and path, only used if <code>return = "fasta"</code></p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_exclude.from.download">exclude.from.download</code></td>
<td>
<p>logical; ignore some sequences while downloading</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_exclude.var">exclude.var</code></td>
<td>
<p>vector that is used to define which sequences should be ignored, only used if <code>exclude.from.download = TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_exclude.pattern">exclude.pattern</code></td>
<td>
<p>value that matches to <code>exclude.var</code> and marks unwanted sequences, only used if <code>exclude.from.download = TRUE</code></p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_exclude.fixed">exclude.fixed</code></td>
<td>
<p>logical; match <code>exclude.pattern</code> as is, only used if <code>exclude.from.download = TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="get_seq_for_DB_+3A_res.data">res.data</code></td>
<td>
<p>data.frame; data frame of nucleotide ids and previously downloaded sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Master records (for example, in WGS-project) do not contain any nucleotide.
They might be excluded from download with <code>exclude.from.download</code> parameters.
However this has no affect and such ids do not have to be excluded when loading.
</p>
<p>If writing FASTA to existing FASTA file, sequences are appended.
</p>


<h3>Value</h3>

<p>If <code>return = "vector"</code> function returns vector of nucleotide sequences,
<code>return = "data.frame"</code> - data frame with nucleotide ids and nucleotide sequences,
<code>return = "fasta"</code> - writes FASTA file, no data returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_seq_for_DB</code>: Retrieves NCBI nucleotide sequences for given identification numbers.
</p>
</li>
<li> <p><code>get_seq_for_DB_fix</code>: Checks the downloads and tries to retrieve the compromised data.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ids&lt;-c(2134240466, 2134240465, 2134240464)
fasta.file&lt;-tempfile()
get_seq_for_DB (ids = ids, db = "nucleotide", check.result = TRUE,
                return = "fasta", fasta.file = fasta.file, exclude.from.download=FALSE)
file.remove(fasta.file)

</code></pre>

<hr>
<h2 id='get_seq_info'>Get NCBI sequence record</h2><span id='topic+get_seq_info'></span><span id='topic+get_seq_info_fix'></span><span id='topic+info_listtodata'></span>

<h3>Description</h3>

<p>Retrieves information about sequences from NCBI records for given organism name or taxon identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seq_info(
  org.name,
  db,
  n.start = 1,
  n.stop = NULL,
  step = 500,
  return.dataframe = FALSE,
  check.result = FALSE,
  term = NULL,
  verbose = TRUE
)

get_seq_info_fix(
  info.list,
  web.history = NULL,
  org.name = NULL,
  db,
  n.start = 1,
  n.stop = NULL,
  step = 500,
  term = NULL,
  verbose = TRUE
)

info_listtodata(info.list, unlist = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_seq_info_+3A_org.name">org.name</code></td>
<td>
<p>character; scientific name or taxon identifier (written as &quot;txid0000&quot;) of the organism/taxon.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_db">db</code></td>
<td>
<p>character; NCBI database for search. See <a href="rentrez.html#topic+entrez_dbs">entrez_dbs</a>() for possible values.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_n.start">n.start</code></td>
<td>
<p>integer; download starting value. Default is 1.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_n.stop">n.stop</code></td>
<td>
<p>integer; download finishing value. Default is NULL, which provides retrieval of all available GIs.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_step">step</code></td>
<td>
<p>integer; download increment value. Maximum is 500.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_return.dataframe">return.dataframe</code></td>
<td>
<p>integer; whether to return information as structured data frame (another variant is list of lists).</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_check.result">check.result</code></td>
<td>
<p>logical; check if download was done correctly.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_term">term</code></td>
<td>
<p>character; search query.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_info.list">info.list</code></td>
<td>
<p>list of previously downloaded records.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_web.history">web.history</code></td>
<td>
<p>previously saved web_history object for use in calls to the NCBI. New web.history is created if none is provided.</p>
</td></tr>
<tr><td><code id="get_seq_info_+3A_unlist">unlist</code></td>
<td>
<p>logical; unlist result before transforming (only recommended if <code>step &gt; 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sends the query to NCBI database and returns sequence records according to the query. By default the
query is organism, so the function returns data of all sequences that are associated with the requested organism.
For example, if <code>org.name = "Homo sapiens"</code> the function will download data for all records that answer the query
&quot;Homo sapiens[Organism]&quot;. For any other query use parameter <code>term</code>.
</p>
<p>The function downloads records by piecemeal, by several pieces in one block. The size of the block is defined by parameter
<code>step</code>. It is useful if by any reason the download was interrupted, so later it is possible to reload only
the missing blocks without the need to reload the entire amount of data. By default, all available records are downloaded,
but you may also choose start and finish points by specifying the parameters <code>n.start</code> and <code>n.stop</code>. The numeration starts with 1, not 0.
At the end the resulting list of blocks (list of lists if <code>step &gt; 1</code>) is unlisted into one data frame that contains information about record GI, UID,
caption, source database, organism, strain etc. You may prevent this by setting <code>return.dataframe = FALSE</code>.
Also, regardless of <code>return.dataframe</code> settings, the list of blocks is returned if the download was somehow compromised.
Optionally, you can turn the resulting list into data frame later using the function <code>info_listtodata()</code>.
Note that in this case, if parameter <code>info.list</code> was inherited from <code>get_seq_info()</code> function,
the result must be unlisted first (use <code>unlist = TRUE</code>).
</p>
<p>If download was corrupted you may use <code>get_seq_info()</code> function to reload the missing block. The corrupted list of blocks
should be set in <code>info.list</code> parameter. You may also check and reload data when <code>get_seq_infos()</code> function is running
by specifying <code>check.result = TRUE</code>.
</p>
<p>In progress the functions turn off and on scientific notation.
</p>


<h3>Value</h3>

<p><code>get_seq_info()</code> returns data frame that contains most of sequence information from NCBI records.
If <code>return.dataframer = FALSE</code> or there are missing data, list of lists is returned. List contains full information
from NCBI records.
</p>
<p><code>get_seq_info_fix()</code> returns list of lists.
</p>
<p><code>info_listtodata()</code> returns data frame.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_seq_info</code>: Retrieves NCBI sequence records for given organism name or taxon identifier.
</p>
</li>
<li> <p><code>get_seq_info_fix</code>: Checks the downloads and tries to retrieve the compromised data.
</p>
</li>
<li> <p><code>info_listtodata</code>: Transforms downloaded list into data frame.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>info.dataframe &lt;- get_seq_info (org.name = "txid9606", db = "nucleotide", n.start = 1,
                               n.stop = 10, step = 5, return.dataframe = TRUE,
                               check.result = TRUE)

</code></pre>

<hr>
<h2 id='make_blast_DB'>Builds local database for BLAST</h2><span id='topic+make_blast_DB'></span>

<h3>Description</h3>

<p>Builds a BLAST database with local sequences using FASTA file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_blast_DB(
  makeblastdb.way,
  fasta.way,
  db.way,
  db.type = "nucl",
  db.title,
  delete.fasta = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_blast_DB_+3A_makeblastdb.way">makeblastdb.way</code></td>
<td>
<p>character; name and path to makeblastdb executable file</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_fasta.way">fasta.way</code></td>
<td>
<p>character; name and path to FASTA file</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_db.way">db.way</code></td>
<td>
<p>character; name and path to local BLAST database</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_db.type">db.type</code></td>
<td>
<p>character; type of BLAST database</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_db.title">db.title</code></td>
<td>
<p>character; BLAST data base title</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_delete.fasta">delete.fasta</code></td>
<td>
<p>logical; delete FASTA file</p>
</td></tr>
<tr><td><code id="make_blast_DB_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is using BLAST applications. BLAST+ (UNIX or Windows) should be installed.
</p>


<h3>Value</h3>

<p>The function creates local BLAST data base. No additional data is returned.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Camacho C., Coulouris G., Avagyan V. et al. (2009). BLAST+: architecture and applications. BMC Bioinformatics 10, 421.
<a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-421">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-10-421</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This function is using BLAST applications. BLAST+ should be installed.
# FASTA file with sequences for local data base should be downloaded first (see get_seq_for_DB ())
path &lt;- tempdir()
dir.create (path)
# load metadata for target sequences of Chlamydia pneumoniae
(meta.target)
# load sequences, it will take about 3 minutes
get_seq_for_DB (ids = meta.target$gi, db = "nucleotide", check.result = TRUE,
              return="fasta", fasta.file = paste0 (path, "/seq.fasta"), verbose = TRUE)
# create local data base, it will take 0.235217 seconds
make_blast_DB (makeblastdb.way = "D:/Blast/blast-2.11.0+/bin/makeblastdb.exe",
              fasta.way = paste0 (path, "/seq.fasta"), db.title = "Cl_pneumoniae",
              db.way = paste0 (path, "/DB"), db.type = "nucl", delete.fasta = FALSE)
# delete FASTA file (also can set delete.fasta = TRUE)
file.remove (paste0 (path, "/seq.fasta"))

## End(Not run)

</code></pre>

<hr>
<h2 id='make_ids'>Create unique identification values</h2><span id='topic+make_ids'></span>

<h3>Description</h3>

<p>Creates unique identification values by adding numbers to identical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ids(var, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ids_+3A_var">var</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="make_ids_+3A_sep">sep</code></td>
<td>
<p>character; string to separate the terms</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes vector with same values and adds numbers to create unique values.
</p>


<h3>Value</h3>

<p>Character vector of <code>var</code> with attached numbers.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var&lt;-c("one", "two", "three", "one", "two", "three", "one")
make_ids(var)

</code></pre>

<hr>
<h2 id='meta.all'>Metadata of all available Chlamydia pneumoniae's sequences.</h2><span id='topic+meta.all'></span>

<h3>Description</h3>

<p>A dataset containing metadata of all Chlamydia pneumoniae's nucleotide sequences
that were downloaded from NCBI Nucleotide database (November, 2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.all
</code></pre>


<h3>Format</h3>

<p>A data frame with 9062 rows and 21 variables:
</p>

<dl>
<dt>uid</dt><dd><p>sequence identification number</p>
</dd>
<dt>gi</dt><dd><p>sequence identification number</p>
</dd>
<dt>GB_AcNum</dt><dd><p>sequence identification number</p>
</dd>
<dt>createdate</dt><dd><p>date of note's creation</p>
</dd>
<dt>updatedate</dt><dd><p>date of last note's update</p>
</dd>
<dt>source_db</dt><dd><p>database</p>
</dd>
<dt>organism</dt><dd><p>organism name</p>
</dd>
<dt>title</dt><dd><p>sequence title</p>
</dd>
<dt>strain</dt><dd><p>strain</p>
</dd>
<dt>taxid</dt><dd><p>taxon identificator</p>
</dd>
<dt>length</dt><dd><p>sequence length</p>
</dd>
<dt>biomol</dt><dd><p>biomolecule</p>
</dd>
<dt>moltype</dt><dd><p>molecular type</p>
</dd>
<dt>genome</dt><dd><p>genome type</p>
</dd>
<dt>complete</dt><dd><p>sequence completness</p>
</dd>
<dt>geneticcode</dt><dd><p>type of genetic and codon codes</p>
</dd>
<dt>strand</dt><dd><p>strand</p>
</dd>
<dt>host</dt><dd><p>host</p>
</dd>
<dt>country</dt><dd><p>country</p>
</dd>
<dt>isolation_source</dt><dd><p>isolation material</p>
</dd>
<dt>collection_date</dt><dd><p>collection date</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/">https://www.ncbi.nlm.nih.gov/</a>
</p>

<hr>
<h2 id='meta.target'>Metadata of target Chlamydia pneumoniae's sequences.</h2><span id='topic+meta.target'></span>

<h3>Description</h3>

<p>A dataset containing target nucleotide sequences of Chlamydia pneumoniae
that were downloaded from NCBI Nucleotide database (November, 2021).
Target sequences are chosen from all available sequences as targets for discriminating probes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.target
</code></pre>


<h3>Format</h3>

<p>A data frame with 183 rows and 21 variables:
</p>

<dl>
<dt>uid</dt><dd><p>sequence identification number</p>
</dd>
<dt>gi</dt><dd><p>sequence identification number</p>
</dd>
<dt>GB_AcNum</dt><dd><p>sequence identification number</p>
</dd>
<dt>createdate</dt><dd><p>date of note's creation</p>
</dd>
<dt>updatedate</dt><dd><p>date of last note's update</p>
</dd>
<dt>source_db</dt><dd><p>database</p>
</dd>
<dt>organism</dt><dd><p>organism name</p>
</dd>
<dt>title</dt><dd><p>sequence title</p>
</dd>
<dt>strain</dt><dd><p>strain</p>
</dd>
<dt>taxid</dt><dd><p>taxon identificator</p>
</dd>
<dt>length</dt><dd><p>sequence length</p>
</dd>
<dt>biomol</dt><dd><p>biomolecule</p>
</dd>
<dt>moltype</dt><dd><p>molecular type</p>
</dd>
<dt>genome</dt><dd><p>genome type</p>
</dd>
<dt>complete</dt><dd><p>sequence completness</p>
</dd>
<dt>geneticcode</dt><dd><p>type of genetic and codon codes</p>
</dd>
<dt>strand</dt><dd><p>strand</p>
</dd>
<dt>host</dt><dd><p>host</p>
</dd>
<dt>country</dt><dd><p>country</p>
</dd>
<dt>isolation_source</dt><dd><p>isolation material</p>
</dd>
<dt>collection_date</dt><dd><p>collection date</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/">https://www.ncbi.nlm.nih.gov/</a>
</p>

<hr>
<h2 id='normalize_DF'>Normalize variable</h2><span id='topic+normalize_DF'></span>

<h3>Description</h3>

<p>Normalize variable in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_DF(
  data,
  var.name,
  method = "mean",
  norm.number,
  return = "add.end",
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_DF_+3A_data">data</code></td>
<td>
<p>data frame with numeric variable that should be normalized</p>
</td></tr>
<tr><td><code id="normalize_DF_+3A_var.name">var.name</code></td>
<td>
<p>character; data frame column name with numeric variable that should be normalized</p>
</td></tr>
<tr><td><code id="normalize_DF_+3A_method">method</code></td>
<td>
<p>character; normalization method; possible values are: <code>"mean"</code> (normalize to mean),
<code>"median"</code> (normalize to median), <code>"number"</code> (normalize to given number)</p>
</td></tr>
<tr><td><code id="normalize_DF_+3A_norm.number">norm.number</code></td>
<td>
<p>numeric; a value to normalize to (if <code>method = "number"</code>)</p>
</td></tr>
<tr><td><code id="normalize_DF_+3A_return">return</code></td>
<td>
<p>character; return object; possible values are: <code>"vector"</code> (return a vector of normalized values),
<code>"replace"</code> (replace <code>var.name</code> values with normalized values in data frame),
<code>"add.near"</code> (add normalized values next to <code>var.name</code> values in data frame),
<code>"add.end"</code> (add normalized values as the latter column in data frame)</p>
</td></tr>
<tr><td><code id="normalize_DF_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to round the normalized value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales variable to a range of (0-1), where 1 get values that are the most close to mean, median or given number.
See <a href="BBmisc.html#topic+normalize">normalize</a> for details.
</p>
<p><code>var.name</code> must be exact column name as in data frame.
</p>


<h3>Value</h3>

<p>Vector or data frame with normalized values.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame (N = 1:5, temperature = c(37.5, 36.6, 41.2, 38.8, 36.7),
                name = c("Bob", "Kate", "Steve", "Sonya", "Mary"))
normalize_DF (data = data, var.name = "temperature", method = "mean", return = "vector")
normalize_DF (data = data, var.name = "temperature", method = "mean", return = "replace")
normalize_DF (data = data, var.name = "temperature", method = "mean", return = "add.near")
normalize_DF (data = data, var.name = "temperature", method = "number",
            norm.number = 36.6, return = "add.end")

</code></pre>

<hr>
<h2 id='rate_DF'>Rate variables</h2><span id='topic+rate_DF'></span>

<h3>Description</h3>

<p>Count data frame's row rate according to several variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_DF(
  data,
  rate.var,
  weights,
  return = "add",
  as.percent = FALSE,
  percent.var,
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate_DF_+3A_data">data</code></td>
<td>
<p>data frame with rated variables</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_rate.var">rate.var</code></td>
<td>
<p>character; vector of data frame column names with numeric variables of range (0-1) that should be used for rating</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_weights">weights</code></td>
<td>
<p>numeric; vector of variables' weights (their sum must be 1)</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_return">return</code></td>
<td>
<p>character; return object; possible values are: <code>"vector"</code> (return a vector of rate values),
<code>"add"</code> (add rated values as the latter column in data frame)</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_as.percent">as.percent</code></td>
<td>
<p>logical; if some rated variables are percentages</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_percent.var">percent.var</code></td>
<td>
<p>character;  vector of data frame column names with rated variables that are percentages</p>
</td></tr>
<tr><td><code id="rate_DF_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to round the rate value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function counts rate as <code>rate = var1*weight1 + var2*weight2 + var3*weight3 +...</code> etc.
All variables must be in range (0-1) and sum of weights must be 1. If you use percentages as rating variable, use <code>as.percent = TRUE</code>.
Those variables would be divided by 100 before rating and then would be multiplicated by 100 after rating.
</p>
<p><code>rate.var</code> and  <code>percent.var</code> must be exact column names as in data frame.
</p>


<h3>Value</h3>

<p>Vector or data frame with rate values.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame (N = 1:5, percent = c(12, 15, 18, 20, 94), number = c(0.1, 0.5, 0.6, 0.8 ,0.9))
rate_DF (data = data, rate.var = c("percent", "number"), weights = c(0.4, 0.6), return = "add",
                             as.percent = TRUE, percent.var = "percent")

</code></pre>

<hr>
<h2 id='read_and_unite_files'>Read and unite files</h2><span id='topic+read_and_unite_files'></span>

<h3>Description</h3>

<p>Read a bunch of table files and unite them in one data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_and_unite_files(
  path,
  pattern,
  sep = ";",
  header = TRUE,
  add.file.id = FALSE,
  file.id = NULL,
  unique = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_and_unite_files_+3A_path">path</code></td>
<td>
<p>character; directory path</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_pattern">pattern</code></td>
<td>
<p>character; file names pattern</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_sep">sep</code></td>
<td>
<p>character; the field separator character</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_header">header</code></td>
<td>
<p>logical; files contain the names of the variables as its first line</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_add.file.id">add.file.id</code></td>
<td>
<p>logical; add file identification columns</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_file.id">file.id</code></td>
<td>
<p>data frame with file identification values</p>
</td></tr>
<tr><td><code id="read_and_unite_files_+3A_unique">unique</code></td>
<td>
<p>logical; delete repeated rows</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All files must be tables of same type. All files must be in one directory.
</p>
<p>File identification columns might be added. There might be any number of such columns.
They are added at the beginning of result data frame.
File identification values are set as <code>file.id</code> data frame,
where each column contains possible identification values and column names are names of identificator.
If no <code>file.id</code> provided file names are set by default.
</p>


<h3>Value</h3>

<p>data frame with united files' content.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- tempdir()
dir.create(path)
t1&lt;-paste0(path, "/table1")
t2&lt;-paste0(path, "/table2")
table1 &lt;- data.frame (Num = 1:10, Letter = rep("A", 10))
write.table (table1, t1, sep = ";")
table2 &lt;- data.frame (Num = 1:10, Letter = rep("B", 10))
write.table (table2, t2, sep = ";")
read_and_unite_files (path = path, pattern = "table", header = TRUE, sep = ";",
                      add.file.id = TRUE)
read_and_unite_files (path = path, pattern = "table", header = TRUE, sep = ";",
                      add.file.id = TRUE,
                      file.id = data.frame (id1 = c(1,2), id2 = c("one", "two")))
file.remove (t1); file.remove (t2)

</code></pre>

<hr>
<h2 id='read_from_table_file'>Read table file</h2><span id='topic+read_from_table_file'></span>

<h3>Description</h3>

<p>Read table file and selects the required rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_from_table_file(
  file,
  choose.columns = FALSE,
  column.names,
  select = FALSE,
  select.column.name,
  select.val,
  unique = FALSE,
  sep = ";",
  header = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_from_table_file_+3A_file">file</code></td>
<td>
<p>character; file name and path</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_choose.columns">choose.columns</code></td>
<td>
<p>logical; return chosen columns only</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_column.names">column.names</code></td>
<td>
<p>character; vector of name of columns that are chosen to be returned</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_select">select</code></td>
<td>
<p>logical; return only rows that contain selected values in one column</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_select.column.name">select.column.name</code></td>
<td>
<p>character; name of column that contains selected values</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_select.val">select.val</code></td>
<td>
<p>vector of values that define rows that should be returned</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_unique">unique</code></td>
<td>
<p>logical; delete duplicated rows</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_sep">sep</code></td>
<td>
<p>character; the field separator character</p>
</td></tr>
<tr><td><code id="read_from_table_file_+3A_header">header</code></td>
<td>
<p>logical; files contain the names of the variables as its first line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads table files and returns data frame with selected
rows (only rows with specified values) and columns.
Also duplicated rows may be deleted.
</p>
<p><code>column.names</code> and  <code>select.column.name</code> must be exact column names as in data frame.
</p>


<h3>Value</h3>

<p>Data frame with file content, optionally trimmed.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame (N = 1:10, letter = c(rep ("A", 5), rep ("B", 4), "C"),
                   num = c(1, rep(1:4, 2), 5))
t1&lt;-tempfile()
write.table (mydata, t1, sep = ";")
read_from_table_file (file = t1)
read_from_table_file (file = t1, select = TRUE, select.column.name = "letter",
                     select.val = c("A", "C"))
read_from_table_file (file = t1, select = TRUE, select.column.name = "letter",
                     select.val = c("A", "C"), unique=TRUE, choose.columns = TRUE,
                     column.names = c("letter", "num"))
read_from_table_file (file = t1, select = TRUE, select.column.name = "letter",
                     select.val = c("A", "C"), unique = TRUE, choose.columns = TRUE,
                     column.names = c("N", "num"))
read_from_table_file (file = t1, select = TRUE, select.column.name = "letter",
                     select.val = c("A", "C"), unique = TRUE, choose.columns = TRUE,
                     column.names = c("letter", "N"))
file.remove (t1)

</code></pre>

<hr>
<h2 id='store_in_DB'>Store data in SQLite database</h2><span id='topic+store_in_DB'></span><span id='topic+list_DB'></span><span id='topic+write_to_DB'></span><span id='topic+index_DB'></span><span id='topic+read_from_DB'></span><span id='topic+delete_from_DB'></span>

<h3>Description</h3>

<p>Write, read and delete tables from SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_DB(database)

write_to_DB(
  database,
  data,
  table,
  overwrite = FALSE,
  append = FALSE,
  verbose = TRUE
)

index_DB(database, table, index.unique, index.column.name, verbose = TRUE)

read_from_DB(
  database,
  table,
  choose.columns = FALSE,
  column.names,
  select = FALSE,
  select.column.name,
  select.val,
  unique = FALSE
)

delete_from_DB(database, table, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="store_in_DB_+3A_database">database</code></td>
<td>
<p>character; SQLite database name and path.</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_data">data</code></td>
<td>
<p>data frame that should be stored as database table.</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_table">table</code></td>
<td>
<p>character; table name.</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_overwrite">overwrite</code></td>
<td>
<p>logical; use <code>overwrite = TRUE</code> if you want to overwrite a table that already exists in database</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_append">append</code></td>
<td>
<p>logical; append rows to table</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_index.unique">index.unique</code></td>
<td>
<p>logical; vector of indicators to create unique or not unique indexes</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_index.column.name">index.column.name</code></td>
<td>
<p>vector of indexed columns' names</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_choose.columns">choose.columns</code></td>
<td>
<p>logical; return chosen columns only</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_column.names">column.names</code></td>
<td>
<p>character; vector of name of columns that are chosen to be returned</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_select">select</code></td>
<td>
<p>logical; return only rows that contain selected values in one column</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_select.column.name">select.column.name</code></td>
<td>
<p>character; name of column that contains selected values</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_select.val">select.val</code></td>
<td>
<p>vector of values that define rows that should be returned</p>
</td></tr>
<tr><td><code id="store_in_DB_+3A_unique">unique</code></td>
<td>
<p>logical; delete duplicated rows</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions help to store big data frames in SQLite database which makes it faster to save and read the data.
</p>
<p>This function creates SQLlite connection to database, fulfills the task and then disconnects.
If no database has been created yet, creates one.
</p>
<p>Do not use <code>overwrite = TRUE</code> if table does not exists.
Do not use <code>append = TRUE</code> and <code>overwrite = TRUE</code> at the same time, no append is possible while overwriting.
</p>
<p>If multiple indexes are created in one table, they are unrelated.
</p>
<p>Do not use dots in data frame character variables, use underscore.
</p>
<p>Parameters <code>choose.columns=FALSE, column.names, select, select.column.name, select.val, unique</code> are only used with
linkread_from_DB function. Those parameters define rows and columns that will be returned.
</p>


<h3>Value</h3>

<p><code>list_DB</code> returns character vector of names of database tables.
</p>
<p><code>read_from_DB</code> returns a data frame with the content of SQLite table.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>list_DB</code>: Lists all tables from SQLite database
</p>
</li>
<li> <p><code>write_to_DB</code>: Writes data frame into SQLite database table
</p>
</li>
<li> <p><code>index_DB</code>: Creates SQLite indexes in database table
</p>
</li>
<li> <p><code>read_from_DB</code>: Reads table from SQLite database and writes it into data frame.
</p>
</li>
<li> <p><code>delete_from_DB</code>: Deletes table from SQLite database.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- as.data.frame (matrix(1:10, 2, 5))
database &lt;- tempfile()
write_to_DB (database, data = mydata, table = "table1", overwrite = FALSE)
list_DB (database)
mydata2 &lt;- as.data.frame (matrix(11:20, 2, 5))
write_to_DB (database, data = mydata2, table = "table1", overwrite = TRUE)
mydata3 &lt;- read_from_DB (database, table = "table1")
delete_from_DB (database, table = "table1")
file.remove (database)

# example with reading table with restricted columns and rows.
mydata &lt;- data.frame(ids = c(1:6), titles = c("A", "B", "C", "D", "E", "E"),
                    other = rep("other", 6))
database &lt;- tempfile()
write_to_DB (database, data = mydata, table = "table1", overwrite = FALSE)
read_from_DB(database, "table1", choose.columns = TRUE, column.names = c("ids", "titles", "other"),
            select = TRUE, select.column.name = "ids",  select.val = 3:6, unique = TRUE)
read_from_DB(database, "table1", choose.columns = TRUE, column.names = c("titles", "other"),
            select = TRUE, select.column.name = "ids",  select.val = 3:6, unique = TRUE)
file.remove (database)

</code></pre>

<hr>
<h2 id='summarize_blast_result'>Summarize BLAST result</h2><span id='topic+summarize_blast_result'></span>

<h3>Description</h3>

<p>Summarize aligned, not aligned and undesirably aligned sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_blast_result(
  sum.aligned = "sp",
  blast.probe.id.var,
  blast.res.id.var,
  blast.res.title.var,
  reference.id.var,
  reference.title.var,
  titles = FALSE,
  add.blast.info = FALSE,
  data.blast.info,
  check.blast.for.source = FALSE,
  source = NULL,
  switch.ids = FALSE,
  switch.table,
  mc.cores = 1,
  digits = 2,
  sep = ";",
  temp.db = NULL,
  delete.temp.db = TRUE,
  return = "summary",
  write.alignment = "DB",
  alignment.db = NULL,
  alignment.table.sp.aligned = NULL,
  alignment.table.sp.not.aligned = NULL,
  alignment.table.nonsp = NULL,
  change.colnames.dots = TRUE,
  file.sp.aligned = NULL,
  file.sp.not.aligned = NULL,
  file.nonsp = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_blast_result_+3A_sum.aligned">sum.aligned</code></td>
<td>
<p>character; summarize specific or not specific alignments; possible values are
<code>"sp"</code> (aligned and not aligned specific subjects) and <code>"nonsp"</code> (aligned non specific subjects)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_blast.probe.id.var">blast.probe.id.var</code></td>
<td>
<p>vector of query identification numbers from BLAST result data</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_blast.res.id.var">blast.res.id.var</code>, <code id="summarize_blast_result_+3A_blast.res.title.var">blast.res.title.var</code></td>
<td>
<p>vector of subject identification numbers and titles from BLAST result data</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_reference.id.var">reference.id.var</code>, <code id="summarize_blast_result_+3A_reference.title.var">reference.title.var</code></td>
<td>
<p>vector of identification numbers and titles of
specific sequences that should be or might be aligned</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_titles">titles</code></td>
<td>
<p>logical; include titles in alignment reports</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_add.blast.info">add.blast.info</code></td>
<td>
<p>logical; add other BLAST results</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_data.blast.info">data.blast.info</code></td>
<td>
<p>data frame; additional BLAST result from BLAST result data</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_check.blast.for.source">check.blast.for.source</code></td>
<td>
<p>logical; delete queries that are not aligned with one obligatory sequence</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_source">source</code></td>
<td>
<p>identification number of obligatory sequence for alignment</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_switch.ids">switch.ids</code></td>
<td>
<p>logical; use different identification numbers for BLAST result's subjects</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_switch.table">switch.table</code></td>
<td>
<p>data frame; table of old and new identification numbers (and new titles) linked by row</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer; number of processors for parallel computation (not supported on Windows)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to round the result</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_sep">sep</code></td>
<td>
<p>character; the field separator character</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_temp.db">temp.db</code></td>
<td>
<p>character; temporal SQLite database name and path</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_delete.temp.db">delete.temp.db</code></td>
<td>
<p>logical; delete temporal SQLite database afterwards</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_return">return</code></td>
<td>
<p>character; returned object; possible values are <code>"list"</code> (list of data frames with alignment
summary and report for each probe) and <code>"summary"</code> (data frame with summary for all probes is returned
and alignment reports are written into files or SQLite database tables)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_write.alignment">write.alignment</code></td>
<td>
<p>character; write alignment reports into files (<code>"file"</code>) or SQLite database tables (<code>"DB"</code>;
used if (<code>return = "summary"</code>))</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_alignment.db">alignment.db</code>, <code id="summarize_blast_result_+3A_alignment.table.sp.aligned">alignment.table.sp.aligned</code>, <code id="summarize_blast_result_+3A_alignment.table.sp.not.aligned">alignment.table.sp.not.aligned</code>, <code id="summarize_blast_result_+3A_alignment.table.nonsp">alignment.table.nonsp</code></td>
<td>
<p>character;
SQLite database name and path, tables names (used if <code>write.alignment = "DB"</code>)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_change.colnames.dots">change.colnames.dots</code></td>
<td>
<p>logical; change dots to underscore in data frame column names
(used if <code>write.alignment = "DB"</code>)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_file.sp.aligned">file.sp.aligned</code>, <code id="summarize_blast_result_+3A_file.sp.not.aligned">file.sp.not.aligned</code>, <code id="summarize_blast_result_+3A_file.nonsp">file.nonsp</code></td>
<td>
<p>character; file names and path (used if <code>write.alignment = "file"</code>)</p>
</td></tr>
<tr><td><code id="summarize_blast_result_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with data frame created by <a href="#topic+blast_local">blast_local</a> function.
It takes BLAST results, divides aligned subjects on specific (that should be aligned)
and non specific (that should not be aligned) according to <code>reference</code>) values.
Function summarizes amount of aligned and not aligned specific subjects and amount of aligned non specific subjects.
</p>
<p>When <code>sum.aligned = "sp"</code> aligned and not aligned specific subjects are summarized and
<code>reference.id.var</code> and <code>reference.title.var</code> should contain sequences that it is necessary to align with.
When <code>sum.aligned = "nonsp"</code> aligned non specific subjects are summarized and
<code>reference.id.var</code> should contain sequences that may be aligned (that are not considered as non specific),
no titles needed.
</p>
<p>When <code>return = "summary"</code>, function returns summary (amount of aligned and not aligned subjects) and writes
sorted alignments (alignment report) in file (<code>write.alignment = "file"</code>) or SQLite database (<code>write.alignment = "DB"</code>).
Usually only subjects' ids and (optionally) titles are returned, but you may add as many BLAST results as you like
with <code>add.blast.info</code> and <code>data.blast.info</code> parameters.
If you add some BLAST results, all alignments will present in alignment report,
if not -  duplicated subjects will be deleted.
</p>
<p>By default result tables in database (if <code>write.alignment = "DB"</code>) are
&quot;sp_aligned&quot;, &quot;sp_not_aligned&quot; and &quot;nonsp&quot;,
Results are written by appending, so if files or tables already exist, data will be added into them.
</p>
<p>If subjects identification numbers in BLAST result data differ from those in <code>reference.id.var</code>
you may use <code>switch.ids = TRUE</code> to change BLAST ids into new according to <code>switch.table</code>.
<code>switch.table</code> must be a data frame with column one - old ids, column two - new ids and (optionally)
column three - new titles. Do not use dots in column names.
</p>
<p>When <code>check.blast.for.source = TRUE</code> probes that are non blasted for one special subject
(usually the sequence that was cut for probes) are deleted.
No <code>check.blast.for.source</code> is performed if <code>sum.aligned = "nonsp"</code>.
Check for source is performed after the possible <code>id.switch</code>, so <code>source</code> should be identification number of
same type as <code>reference</code>.
</p>
<p>Probe identification number must be character variable.
</p>
<p>If alignment report is written into database, probe identification variable is indexed in all tables.
Also it is highly recommended to set <code>change.colnames.dots = TRUE</code> to change possible dots to underscore
within result data frame's column names and avoid further mistakes.
</p>
<p>While working function saves data in temporal SQLite database.
Function will stop if same database already exists, so deleting temporal database is highly recommended.
</p>


<h3>Value</h3>

<p>List of data frames with alignment summary and report for each probe or
data frame with summary for all probes (alignment reports are written into files or SQLite database tables).
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- tempdir()
dir.create (path)
# load blast results with subject accession numbers
data(blast.fill)
#load metadata of all Chlamydia pneumoniae sequences - they are subjects that
# do not count as nonspecific and may be aligned
data(meta.all)
# load metadata with target Chlamydia pneumoniae sequences - they are specific subjects
# that must be aligned
# make new accession numbers to count all WGS sequences as one (see unite_NCBI_ac.nums ())
meta.target.new.ids &lt;- unite_NCBI_ac.nums (data = meta.target,
                                          ac.num.var = meta.target$GB_AcNum,
                                          title.var = meta.target$title,
                                          db.var = meta.target$source_db,
                                          type = "shotgun", order = TRUE,
                                          new.titles = TRUE)
# summarize blast results, count aligned specific subjects with "switch ids" option
# (WGS sequences are counted as one). Add query cover information.
blast.sum.sp &lt;- summarize_blast_result (sum.aligned = "sp",
                                       blast.probe.id.var = blast.fill$Qid,
                                       blast.res.id.var = blast.fill$Racc,
                                       blast.res.title.var = blast.fill$Rtitle,
                                       reference.id.var = meta.target.new.ids$new.id,
                                       reference.title.var = meta.target.new.ids$new.title,
                                       titles = TRUE,
                                       add.blast.info = TRUE,
                                       data.blast.info = data.frame(Qcover = blast.fill$Qcover),
                                       switch.ids = TRUE, switch.table = meta.target.new.ids,
                                       temp.db = paste0 (path, "/temp.db"), delete.temp.db = TRUE,
                                       return = "summary", write.alignment = "DB",
                                       alignment.db = paste0 (path, "/alig.db"))
# summarize nonspecific alignments (that are not in meta.all dataframe)
blast.sum.nonsp &lt;- summarize_blast_result (sum.aligned = "nonsp",
                                          blast.probe.id.var = blast.fill$Qid,
                                          blast.res.id.var = blast.fill$Racc,
                                          blast.res.title.var = blast.fill$Rtitle,
                                          reference.id.var = meta.all$GB_AcNum,
                                          reference.title.var = meta.all$title,
                                          titles = TRUE, switch.ids = FALSE,
                                          add.blast.info = TRUE,
                                          data.blast.info = data.frame(Qcover = blast.fill$Qcover),
                                          temp.db = paste0 (path, "/temp.db"),
                                          delete.temp.db = TRUE,
                                          return = "summary", write.alignment = "DB",
                                          alignment.db = paste0 (path, "/alig.db"))
# all specific targets are aligned
sp.aligned &lt;- read_from_DB(database = paste0 (path, "/alig.db"), table = "sp_aligned")
# no targets that are not aligned
sp.not.aligned &lt;- read_from_DB(database = paste0 (path, "/alig.db"), table = "sp_not_aligned")
# No nonspecific alignments
nonsp &lt;- read_from_DB(database = paste0 (path, "/alig.db"), table = "nonsp")
file.remove (paste0 (path, "/alig.db"))

</code></pre>

<hr>
<h2 id='trim_DF'>Trim data frame</h2><span id='topic+trim_DF'></span>

<h3>Description</h3>

<p>If the numeric value of the data frame variable does not meet the specified conditions, the function deletes the entire row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_DF(data, trim.var.name, trim.action, trim.thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_DF_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="trim_DF_+3A_trim.var.name">trim.var.name</code></td>
<td>
<p>character; vector of data frame column names with numeric variables that should be tested for conditions</p>
</td></tr>
<tr><td><code id="trim_DF_+3A_trim.action">trim.action</code></td>
<td>
<p>character; vector of test conditions; possible values are:
<code>"more", "eqmore"</code> (more or equal), <code>"less", "eqless"</code> (less or equal).</p>
</td></tr>
<tr><td><code id="trim_DF_+3A_trim.thresh">trim.thresh</code></td>
<td>
<p>numeric; vector of condition threshold values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the vector of data frame variables and for each of them test if they satisfy the specified conditions.
Not satisfying values are deleted with the entire data frame row. You may set as many conditions for as many variables as you like.
</p>
<p><code>trim.values</code> must be exact column names as in data frame.
</p>


<h3>Value</h3>

<p>data frame without rows with values that do not satisfy the specified conditions.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame ("a" = 1:10, "b" = 101:110)
trim_DF (data, trim.var.name = c("a", "b"), trim.action = c("less", "eqmore"),
       trim.thresh = c(6, 104))

</code></pre>

<hr>
<h2 id='unite_NCBI_ac.nums'>Assigns master record's id to all project records</h2><span id='topic+unite_NCBI_ac.nums'></span>

<h3>Description</h3>

<p>The function assigns the project master record's NCBI access number to all records that belong to the project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite_NCBI_ac.nums(
  data,
  ac.num.var,
  title.var,
  db.var,
  type = "shotgun",
  order = TRUE,
  new.titles = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_NCBI_ac.nums_+3A_data">data</code></td>
<td>
<p>data frame; contains information about sequence records.</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_ac.num.var">ac.num.var</code></td>
<td>
<p>character; data frame variable that contains sequence accession numbers.</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_title.var">title.var</code></td>
<td>
<p>character; data frame variable that contains sequence titles.</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_db.var">db.var</code></td>
<td>
<p>character; data frame variable that contains source data base names.</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_type">type</code></td>
<td>
<p>character; type of the project which records should be united with one accession number.
At the moment <code>"shotgun"</code> is the only possible value which corresponds to the whole genome shotgun sequencing project with shotgun technology.</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_order">order</code></td>
<td>
<p>logical; rearrange a data frame in alphabetical order of accession numbers (highly recommended).</p>
</td></tr>
<tr><td><code id="unite_NCBI_ac.nums_+3A_new.titles">new.titles</code></td>
<td>
<p>logical; add new titles according to new access numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks through all records in a data frame.
If the record belongs to the project (for example, WGS-project), the function assigns the project master record's NCBI access number to this record.
If the record is not related to any project, it retains its own accession number.
</p>
<p>It is highly recommended to arrange the data in alphabetical order of accession numbers,
since the first record among similar ones is determined as master record.
</p>


<h3>Value</h3>

<p>If <code>new.titles = FALSE</code> data frame with old and new access numbers is returned.
</p>
<p>If <code>new.titles = TRUE</code> data frame with old and new access numbers and new titles is returned.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with sequences from WGS-project of Chlamydia pneumoniae genome
data (meta.target) #load metadata of target sequences with GenBank identificators
meta.target.new.ids &lt;- unite_NCBI_ac.nums (data = meta.target,
                                          ac.num.var = meta.target$GB_AcNum,
                                          title.var = meta.target$title,
                                          db.var = meta.target$source_db,
                                          type = "shotgun", order = TRUE,
                                          new.titles = TRUE)

</code></pre>

<hr>
<h2 id='unite_two_DF'>Combine two data frames</h2><span id='topic+unite_two_DF'></span>

<h3>Description</h3>

<p>Combine two data frames according to shared variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite_two_DF(
  data1,
  data1.shared.var,
  data1.shared.column.num = 1,
  data2,
  data2.shared.var,
  data2.shared.column.num = 1,
  delete.not.shared = FALSE,
  not.shared = "all",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_two_DF_+3A_data1">data1</code>, <code id="unite_two_DF_+3A_data2">data2</code></td>
<td>
<p>data frames</p>
</td></tr>
<tr><td><code id="unite_two_DF_+3A_data1.shared.var">data1.shared.var</code>, <code id="unite_two_DF_+3A_data2.shared.var">data2.shared.var</code></td>
<td>
<p>same variables in data frames</p>
</td></tr>
<tr><td><code id="unite_two_DF_+3A_data1.shared.column.num">data1.shared.column.num</code>, <code id="unite_two_DF_+3A_data2.shared.column.num">data2.shared.column.num</code></td>
<td>
<p>integer; column numbers of same variables in data frames</p>
</td></tr>
<tr><td><code id="unite_two_DF_+3A_delete.not.shared">delete.not.shared</code></td>
<td>
<p>logical; delete rows that present in one data frame but do not present in other data frame</p>
</td></tr>
<tr><td><code id="unite_two_DF_+3A_not.shared">not.shared</code></td>
<td>
<p>character; which rows to delete; possible values are
<code>"data1"</code> (delete rows that present in <code>data1</code> but do not present in <code>data2</code>),
<code>"data2"</code> (delete rows that present in <code>data2</code> but do not present in <code>data1</code>),
<code>"all"</code> (both variants)</p>
</td></tr>
<tr><td><code id="unite_two_DF_+3A_verbose">verbose</code></td>
<td>
<p>logical; show messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines columns of two data frames according to <code>shared.var</code> which acts like rows' identification number.
If <code>shared.var</code> value from one data frame do not present in other data frame, NAs are produced.
Those absent rows are deleted when <code>delete.not.shared = TRUE</code>.
</p>
<p><code>data1.shared.var</code> and data2.shared.var must contain unique values within its own data frame.
</p>
<p>Order of rows in resulting data frame is according to <code>data1</code>.
<code>data2.shared.var</code> is removed from resulting data frame.
</p>


<h3>Value</h3>

<p>Combined data frame.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#same values in shared variables
data1 &lt;- data.frame (N = 1:5, letter = rep("A", 5))
data2 &lt;- data.frame (N = 1:5, letter = rep("B", 5), cs = rep("cs",5))
unite_two_DF (data1 = data1, data1.shared.var = data1$N, data2 = data2, data2.shared.var = data2$N,
            delete.not.shared = TRUE, not.shared = "all")
#different values in shared variables
data1 &lt;- data.frame (N = 1:5, letter = rep("A", 5))
data2 &lt;- data.frame (N = 3:8, letter = rep("B", 6), cs = rep("cs",6))
unite_two_DF (data1 = data1, data1.shared.var = data1$N, data2 = data2, data2.shared.var = data2$N)
unite_two_DF (data1 = data1, data1.shared.var = data1$N, data2 = data2, data2.shared.var = data2$N,
            delete.not.shared = TRUE, not.shared = "data1")
unite_two_DF (data1 = data1, data1.shared.var = data1$N, data2 = data2, data2.shared.var = data2$N,
            delete.not.shared = TRUE, not.shared = "data2")
unite_two_DF (data1 = data1, data1.shared.var = data1$N, data2 = data2, data2.shared.var = data2$N,
            delete.not.shared = TRUE, not.shared = "all")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
