<!DOCTYPE html><html lang="en"><head><title>Help for package metadeconfoundR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metadeconfoundR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BuildHeatmap'><p>BuildHeatmap</p></a></li>
<li><a href='#ImportLongPrior'><p>ImportLongPrior</p></a></li>
<li><a href='#MetaDeconfound'><p>MetaDeconfound</p></a></li>
<li><a href='#metaMatMetformin'><p>Documentation for the metaMatMetformin RData in /data</p></a></li>
<li><a href='#reduced_feature'><p>Documentation for the reduced_feature RData in /data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariate-Sensitive Analysis of Cross-Sectional High-Dimensional
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Till Birkner &lt;metadeconf@till-birkner.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Using non-parametric tests, naive associations between omics 
    features and metadata in cross-sectional data-sets are detected. In a second 
    step, confounding effects between metadata associated to the same omics 
    feature are detected and labeled using nested post-hoc model comparison
    tests, as first described in 
    Forslund, Chakaroun, Zimmermann-Kogadeeva, et al. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41586-021-04177-9">doi:10.1038/s41586-021-04177-9</a>&gt;. 
    The generated output can be graphically summarized using the built-in plotting function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TillBirkner/metadeconfoundR">https://github.com/TillBirkner/metadeconfoundR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TillBirkner/metadeconfoundR/issues">https://github.com/TillBirkner/metadeconfoundR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>lmtest, foreach, parallel, doParallel, stats, futile.logger,
lme4, ggplot2, reshape2, methods, rlang</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), detectseparation</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pander, knitr, gridExtra, kableExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-24 19:41:48 UTC; tbirkne</td>
</tr>
<tr>
<td>Author:</td>
<td>Till Birkner <a href="https://orcid.org/0000-0003-2656-2821"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sofia Kirke Forslund-Startceva
    <a href="https://orcid.org/0000-0003-4285-6993"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-25 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BuildHeatmap'>BuildHeatmap</h2><span id='topic+BuildHeatmap'></span>

<h3>Description</h3>

<p>BuildHeatmap summarizes <a href="#topic+MetaDeconfound">MetaDeconfound</a> output in a heatmap or cuneiform plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildHeatmap(
  metaDeconfOutput,
  q_cutoff = 0.1,
  d_cutoff = 0.01,
  cuneiform = FALSE,
  coloring = 0,
  showConfounded = TRUE,
  intermedData = FALSE,
  featureNames = NULL,
  metaVariableNames = NULL,
  d_range = "fit",
  d_col = c("blue", "white", "red"),
  keepMeta = NULL,
  keepFeature = NULL,
  trusted = c("OK_sd", "OK_nc", "OK_d", "AD"),
  tileBordCol = "black",
  reOrder = "both"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BuildHeatmap_+3A_metadeconfoutput">metaDeconfOutput</code></td>
<td>
<p>output of a metadeconfound run</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_q_cutoff">q_cutoff</code></td>
<td>
<p>optional FDR-value cutoff used to remove
low-significance entries from data</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_d_cutoff">d_cutoff</code></td>
<td>
<p>optional effect size cutoff used to remove
low effect size entries from data</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_cuneiform">cuneiform</code></td>
<td>
<p>optional logical parameter,
plot cuneiform instead of heatmap when cuneiform = TRUE</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_coloring">coloring</code></td>
<td>
<p>optional, can be 0,1,2;
0: color all tiles according to effectsize ;
1: don't color not significant tiles
2: like 1 but also don't color confounded signal tiles</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_showconfounded">showConfounded</code></td>
<td>
<p>optional logical parameter;
set to FALSE to remove significance markers from confounded signals</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_intermeddata">intermedData</code></td>
<td>
<p>only return intermediate data for plotting, default = FALSE</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_featurenames">featureNames</code></td>
<td>
<p>optional two-column-dataframe containing corresponding
&quot;human-readable&quot; names to the &quot;machine-readable&quot; feature names used as
row.names in metaDeconfOutput. These human readable
names will be displayed in the final plot. First column: machine-readable,
second column: human-readable.</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_metavariablenames">metaVariableNames</code></td>
<td>
<p>optional two-column-dataframe containing
corresponding  &quot;human-readable&quot; names to the &quot;machine-readable&quot; metadata
names used as column names in metaDeconfOutput. These human readable
names will be displayed in the final plot. First column: machine-readable,
second column: human-readable.</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_d_range">d_range</code></td>
<td>
<p>range of effect sizes shown; &quot;full&quot;: (default) range from
-1 to +1;
&quot;fit&quot;: range reduced according to maximum and minimum effect size
present in resulting plot</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_d_col">d_col</code></td>
<td>
<p>set color range for effect size as c(minimum, middle, maximum),
default c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_keepmeta">keepMeta</code></td>
<td>
<p>character vector of metavariable names
(corresponding to names in metaDeconfOutput), that should be shown in
resulting plot, even when they have no associations
passing d_cutoff and q_cutoff</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_keepfeature">keepFeature</code></td>
<td>
<p>character vector of metavariable names
(corresponding to names in metaDeconfOutput), that should be shown in
resulting plot, even when they have no associations
passing d_cutoff and q_cutoff</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_trusted">trusted</code></td>
<td>
<p>character vector of confounding status labels to be treated
as trustworthy, not-confounded signal. default = c(&quot;OK_sd&quot;, &quot;OK_nc&quot;, &quot;OK_d&quot;, &quot;AD&quot;)</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_tilebordcol">tileBordCol</code></td>
<td>
<p>tile border color of  heatmap tiles, default: &quot;black&quot;</p>
</td></tr>
<tr><td><code id="BuildHeatmap_+3A_reorder">reOrder</code></td>
<td>
<p>reorder features and/or metadata? possible options: c(&quot;both&quot;, &quot;feat&quot;, &quot;meta&quot;, &quot;none&quot;), default: &quot;both&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for more details and explanations please see the package vignette.
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reduced_feature)
data(metaMatMetformin)

example_output &lt;- MetaDeconfound(featureMat = reduced_feature,
                                  metaMat = metaMatMetformin,
                                  logLevel = "ERROR")

plotObject &lt;- BuildHeatmap(example_output)

alternativePlot &lt;- BuildHeatmap(example_output, coloring = 2, showConfounded = FALSE)


</code></pre>

<hr>
<h2 id='ImportLongPrior'>ImportLongPrior</h2><span id='topic+ImportLongPrior'></span>

<h3>Description</h3>

<p>ImportLongPrior imports prior knowledge of associations between individual
features and metadata in form of a long-format dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImportLongPrior(longPrior, featureMat, metaMat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImportLongPrior_+3A_longprior">longPrior</code></td>
<td>
<p>long-format dataframe as generated by
Metadeconfound(returnLong = TRUE). Must contain at least one column
containing feature names and one column containing associated metadata names,
called &quot;feature&quot; and &quot;metaVariable&quot;, respectively. Only associations between
features and metadata present in featureMat and metaMat will be returned.
Additionally, &quot;Qs&quot; and &quot;status&quot; (as produced by
<a href="#topic+MetaDeconfound">MetaDeconfound</a>)columns can be supplied and will
be parsed as well.
If only &quot;feature&quot; and &quot;metaVariable&quot; columns are supplied, all listed
associations are assumed to be significant.
If &quot;status&quot; is supplied, only non-&quot;NS&quot; labeled associations will be kept.</p>
</td></tr>
<tr><td><code id="ImportLongPrior_+3A_featuremat">featureMat</code></td>
<td>
<p>omics features to be analyzed by <a href="#topic+MetaDeconfound">MetaDeconfound</a></p>
</td></tr>
<tr><td><code id="ImportLongPrior_+3A_metamat">metaMat</code></td>
<td>
<p>metadata to be analyzed by <a href="#topic+MetaDeconfound">MetaDeconfound</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to facilitate incorporation of prior
knowledge about associations between measured omics features and available
metadata both from earlier metadeconfoundR runs by supplying the long-format
Metadeconfound(returnLong = TRUE) output directly or by supplying a simple
list of known associations from other studies.
</p>


<h3>Value</h3>

<p>wide-format dataframe that can be used as minQValues parameter in
<a href="#topic+MetaDeconfound">MetaDeconfound</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reduced_feature)
data(metaMatMetformin)


# note that this example is only to demonstrate the process of integrating
 # prior knowledge into a MetaDeconfound() analysis. Using the output of a
 # MetaDeconfound() run as minQValues input for a second run with the exact
 # same features and metadata will not lead to any new insights since the set
 # of QValues calculated by MetaDeconfound() and the set supplied using the
 # minQValues parameter are identical in this case.

example_output &lt;- MetaDeconfound(featureMat = reduced_feature,
                                  metaMat = metaMatMetformin,
                                  returnLong = TRUE,
                                  logLevel = "ERROR")

minQValues &lt;- ImportLongPrior(longPrior = example_output,
                                featureMat = reduced_feature,
                                metaMat = metaMatMetformin)

example_output2 &lt;- MetaDeconfound(featureMat = reduced_feature,
                                  metaMat = metaMatMetformin,
                                  minQValues = minQValues,
                                  logLevel = "ERROR")

</code></pre>

<hr>
<h2 id='MetaDeconfound'>MetaDeconfound</h2><span id='topic+MetaDeconfound'></span>

<h3>Description</h3>

<p>MetaDeconfound checks all feature &lt;-&gt; covariate combinations for
counfounding effects of covariates on feature &lt;-&gt; effect correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaDeconfound(
  featureMat,
  metaMat,
  nnodes = 1,
  adjustMethod = "fdr",
  robustCutoff = 5,
  QCutoff = 0.1,
  DCutoff = 0,
  PHS_cutoff = 0.05,
  logfile = NULL,
  logLevel = "INFO",
  startStop = NA,
  QValues = NA,
  DValues = NA,
  minQValues = NULL,
  deconfT = NULL,
  deconfF = NULL,
  doConfs = 0,
  doRanks = NA,
  randomVar = NA,
  fixedVar = NA,
  robustCutoffRho = NULL,
  typeCategorical = NULL,
  typeContinuous = NULL,
  logistic = FALSE,
  rawCounts = FALSE,
  returnLong = FALSE,
  collectMods = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MetaDeconfound_+3A_featuremat">featureMat</code></td>
<td>
<p>a data frame with row(sample ID)
and column(feature such as metabolite or microbial OTU )
names, listing features for all samples</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_metamat">metaMat</code></td>
<td>
<p>a data frame with row(sample ID) and
column(meta data such as age,BMI and all possible confounders)
names listing metadata for all samples. first column should be case status
with case=1 and control=0. All binary variables need to be in 0/1 syntax!</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_nnodes">nnodes</code></td>
<td>
<p>number of nodes/cores to be used for parallel processing</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_adjustmethod">adjustMethod</code></td>
<td>
<p>multiple testing p-value correction using one of the
methods of <a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_robustcutoff">robustCutoff</code></td>
<td>
<p>minimal number of sample size for each covariate
in order to have sufficient power for association testing</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_qcutoff">QCutoff</code></td>
<td>
<p>significance cutoff for q-value, DEFAULT = 0.1</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_dcutoff">DCutoff</code></td>
<td>
<p>effect size cutoff
(either cliff's delta or spearman correlation test estimate), DEFAULT = 0</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_phs_cutoff">PHS_cutoff</code></td>
<td>
<p>PostHoc Significance cutoff</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_logfile">logfile</code></td>
<td>
<p>name of optional logging file.</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_loglevel">logLevel</code></td>
<td>
<p>logging verbosity, possible levels:
TRACE, DEBUG, INFO, WARN, ERROR, FATAL, DEFAULT = INFO</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_startstop">startStop</code></td>
<td>
<p>vector of optional strings controlling which
parts of the pipeline should be executed.
(&quot;naiveStop&quot;: only naive associations will be computed, no confounder analysis is done)</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_qvalues">QValues</code></td>
<td>
<p>optional data.frame containing pre-computed multiple-testing corrected p-values for naive associations</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_dvalues">DValues</code></td>
<td>
<p>optional data.frame containing pre-computed effect sizes for naive associations</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_minqvalues">minQValues</code></td>
<td>
<p>pessimistic qvalues, can be generated by
<a href="#topic+ImportLongPrior">ImportLongPrior</a>.
This dataframe of QValues is used to incorporate prior knowledge of
potential associations between individual features and metadata by supplying
QValues &lt; QCutoff for these associations. All significant associations thus
reported will be treated as potentially confounding influences.</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_deconft">deconfT</code></td>
<td>
<p>vector of metavariable names *always* to be included as potential confounder</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_deconff">deconfF</code></td>
<td>
<p>vector of metavariable names *never* to be included as potential confounder</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_doconfs">doConfs</code></td>
<td>
<p>optional parameter for additional computation of confidence
interval of linear models in the deconfounding step
(0 = no , 1 = logging, 2 = strict)</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_doranks">doRanks</code></td>
<td>
<p>optional vector of metavariable names, that should be rank
transformed when building linear models in the doconfounding step</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_randomvar">randomVar</code></td>
<td>
<p>optional vector of metavariable names to be treated as
random effect variables. These variables will not be tested for naive
associations and will not be included as potential confounders,
but will be added as random effects &quot;+ (1|variable)&quot; into any models being built.
Any associations reducible to the supplied random effect(s) will be labeled
as &quot;NS&quot;. Note: Ps, Qs, Ds are computed independently and thereby not changed
through inclusion of random effects.</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_fixedvar">fixedVar</code></td>
<td>
<p>optional vector of metavariable names to be treated as
fixed effect variables. These variabels will not be tested for naive
associations and will not be included as potential confounders,
but will be added as fixed effects &quot;+ variable&quot; into any models being built.
Any associations reducible to the supplied fixed effect(s) will be labeled
as &quot;NS&quot;. Note: Ps, Qs, Ds are computed independently and thereby not changed
through inclusion of fixed effects.</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_robustcutoffrho">robustCutoffRho</code></td>
<td>
<p>optional robustness cutoff for continuous variables</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_typecategorical">typeCategorical</code></td>
<td>
<p>optional character vector of metavariable names to
always be treated as categorical</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_typecontinuous">typeContinuous</code></td>
<td>
<p>optional character vector of metavariable names to
always be treated as continuous</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_logistic">logistic</code></td>
<td>
<p>optional logical parameter; DEFAULT = FALSE;
Set TRUE to treat supplied features as binary instead of continuous</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_rawcounts">rawCounts</code></td>
<td>
<p>optional logical parameter; DEFAULT = FALSE;
Set TRUE to treat supplied features as not normalized/rarefied counts;
metadeconfoundR will compute total read count per sample and include this
information in the modelling steps. WARNING: naive associations computed in
first part of metadeconfoundR are reliant on normalized/rarefied data.
Please split your analysis up into 2 parts as shown in the documentation
when using this mode..</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_returnlong">returnLong</code></td>
<td>
<p>DEFAULT = FALSE; Set TRUE to get output in one long
format data.frame instead of list of four wide format data.frames</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_collectmods">collectMods</code></td>
<td>
<p>DEFAULT = FALSE; Set TRUE to collect all model objects
generated by Metadeconfound and return them in a nested list alongside the
standard Ps/Qs/Ds/status output.</p>
</td></tr>
<tr><td><code id="MetaDeconfound_+3A_...">...</code></td>
<td>
<p>for additional arguments used internally (development/debugging)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for more details and explanations please see the vignette.
</p>


<h3>Value</h3>

<p>list with elements (or data.frame with columns, when returnLong = TRUE) Ds = effectsize,
Ps = uncorrected p-value for naive association,
Qs = multiple testing corrected p-value/fdr,
and status = confounding status for all
feature &lt;=&gt; covariate combinations with following categories:
(NS = not significant, OK_sd = strictly deconfounded, OK_nc = no covariates,
OK_d = doubtful, AD = ambiguously deconfounded, C: followed by comma
separated covariate names = confounded by listed covariates)<br />
</p>
<p>Can be plotted using <a href="#topic+BuildHeatmap">BuildHeatmap</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reduced_feature)
data(metaMatMetformin)

example_output &lt;- MetaDeconfound(featureMat = reduced_feature,
                                  metaMat = metaMatMetformin,
                                  logLevel = "ERROR")


</code></pre>

<hr>
<h2 id='metaMatMetformin'>Documentation for the metaMatMetformin RData in /data</h2><span id='topic+metaMatMetformin'></span>

<h3>Description</h3>

<p>set of features from the metformin dataset
(Forslund et al. (2015), DOI: https://doi.org/10.1038/nature15766 ),
containing status for 5 different properties for 753 samples
</p>

<hr>
<h2 id='reduced_feature'>Documentation for the reduced_feature RData in /data</h2><span id='topic+reduced_feature'></span>

<h3>Description</h3>

<p>reduced set of features from the metformin dataset
(Forslund et al. (2015), DOI: https://doi.org/10.1038/nature15766 ),
containing feature measurements for 753 samples
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
