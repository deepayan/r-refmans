<!DOCTYPE html><html><head><title>Help for package STMr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {STMr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+2B.STMr_scheme'><p>Method for adding set and rep schemes</p></a></li>
<li><a href='#adj_perc_1RM'><p>Family of functions to adjust %1RM</p></a></li>
<li><a href='#adj_reps'><p>Family of functions to adjust number of repetition</p></a></li>
<li><a href='#create_example'><p>Create Example</p></a></li>
<li><a href='#estimate_functions'><p>Estimate relationship between reps and %1RM (or weight)</p></a></li>
<li><a href='#estimate_functions_mixed'><p>Estimate relationship between reps and weight using the non-linear mixed-effects regression</p></a></li>
<li><a href='#estimate_functions_quantile'><p>Estimate relationship between reps and weight using the non-linear quantile regression</p></a></li>
<li><a href='#estimate_rolling_1RM'><p>Estimate the rolling profile and 1RM</p></a></li>
<li><a href='#generate_progression_table'><p>Family of functions to create progression tables</p></a></li>
<li><a href='#get_perc_1RM'><p>Get %1RM</p></a></li>
<li><a href='#get_reps'><p>Get Reps</p></a></li>
<li><a href='#max_perc_1RM'><p>Family of functions to estimate max %1RM</p></a></li>
<li><a href='#max_reps'><p>Family of functions to estimate max number of repetition (nRM)</p></a></li>
<li><a href='#plot_progression_table'><p>Plotting of the Progression Table</p></a></li>
<li><a href='#plot_scheme'><p>Plotting of the Set and Reps Scheme</p></a></li>
<li><a href='#plot_vertical'><p>Plotting of the Vertical Planning</p></a></li>
<li><a href='#plot.STMr_release'><p>Plotting of the Release</p></a></li>
<li><a href='#plot.STMr_scheme'><p>Plotting of the Set and Reps Scheme</p></a></li>
<li><a href='#release'><p>Create a Release period</p></a></li>
<li><a href='#RTF_testing'><p>Reps to failure testing of 12 athletes</p></a></li>
<li><a href='#set_and_reps_schemes'><p>Set and Rep Schemes</p></a></li>
<li><a href='#strength_training_log'><p>Strength Training Log</p></a></li>
<li><a href='#vertical_planning_functions'><p>Vertical Planning Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Strength Training Manual R-Language Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Strength training prescription using percent-based approach requires
    numerous computations and assumptions. 'STMr' package allow users to estimate 
    individual reps-max relationships, implement various progression tables, and
    create numerous set and rep schemes. The 'STMr' package is originally created as
    a tool to help writing Jovanović M. (2020) Strength Training Manual
    &lt;ISBN:979-8604459898&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mladenjovanovic.github.io/STMr/">https://mladenjovanovic.github.io/STMr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mladenjovanovic/STMr/issues">https://github.com/mladenjovanovic/STMr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggfittext, ggplot2, magrittr, minpack.lm, nlme,
quantreg, stats, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 10:13:24 UTC; mladenjovanovic</td>
</tr>
<tr>
<td>Author:</td>
<td>Mladen Jovanović [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mladen Jovanović &lt;coach.mladen.jovanovic@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='+2B.STMr_scheme'>Method for adding set and rep schemes</h2><span id='topic++2B.STMr_scheme'></span>

<h3>Description</h3>

<p>Method for adding set and rep schemes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STMr_scheme'
lhs + rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.STMr_scheme_+3A_lhs">lhs</code></td>
<td>
<p><code>STMr_scheme</code> object</p>
</td></tr>
<tr><td><code id="+2B2B.STMr_scheme_+3A_rhs">rhs</code></td>
<td>
<p><code>STMr_scheme</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>STMr_scheme</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme1 &lt;- scheme_wave()
warmup_scheme &lt;- scheme_perc_1RM()
plot(warmup_scheme + scheme1)
</code></pre>

<hr>
<h2 id='adj_perc_1RM'>Family of functions to adjust %1RM</h2><span id='topic+adj_perc_1RM'></span><span id='topic+adj_perc_1RM_RIR'></span><span id='topic+adj_perc_1RM_DI'></span><span id='topic+adj_perc_1RM_rel_int'></span><span id='topic+adj_perc_1RM_perc_MR'></span>

<h3>Description</h3>

<p>Family of functions to adjust %1RM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_perc_1RM_RIR(
  reps,
  adjustment = 0,
  mfactor = 1,
  max_perc_1RM_func = max_perc_1RM_epley,
  ...
)

adj_perc_1RM_DI(
  reps,
  adjustment = 0,
  mfactor = 1,
  max_perc_1RM_func = max_perc_1RM_epley,
  ...
)

adj_perc_1RM_rel_int(
  reps,
  adjustment = 1,
  mfactor = 1,
  max_perc_1RM_func = max_perc_1RM_epley,
  ...
)

adj_perc_1RM_perc_MR(
  reps,
  adjustment = 1,
  mfactor = 1,
  max_perc_1RM_func = max_perc_1RM_epley,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_perc_1RM_+3A_reps">reps</code></td>
<td>
<p>Numeric vector. Number of repetition to be performed</p>
</td></tr>
<tr><td><code id="adj_perc_1RM_+3A_adjustment">adjustment</code></td>
<td>
<p>Numeric vector. Adjustment to be implemented</p>
</td></tr>
<tr><td><code id="adj_perc_1RM_+3A_mfactor">mfactor</code></td>
<td>
<p>Numeric vector. Default is 1 (i.e., no adjustment).
Use <code>mfactor = 2</code> to generate ballistic adjustment and tables</p>
</td></tr>
<tr><td><code id="adj_perc_1RM_+3A_max_perc_1rm_func">max_perc_1RM_func</code></td>
<td>
<p>Max  %1RM function to be used. Default is <code><a href="#topic+max_perc_1RM_epley">max_perc_1RM_epley</a></code></p>
</td></tr>
<tr><td><code id="adj_perc_1RM_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>max_perc_1RM_func</code>. Usually the parameter value.
For example <code>klin = 36</code> when using <code><a href="#topic+max_perc_1RM_linear">max_perc_1RM_linear</a></code> as
<code>max_perc_1RM_func</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. Predicted perc 1RM
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>adj_perc_1RM_RIR()</code>: Adjust max  %1RM using the Reps In Reserve (RIR) approach
</p>
</li>
<li> <p><code>adj_perc_1RM_DI()</code>: Adjust max %1RM using the Deducted Intensity (DI) approach.
This approach simple deducts <code>adjustment</code> from estimated %1RM
</p>
</li>
<li> <p><code>adj_perc_1RM_rel_int()</code>: Adjust max perc 1RM using the Relative Intensity (RelInt) approach.
This approach simple multiplies estimated perc 1RM with <code>adjustment</code>
</p>
</li>
<li> <p><code>adj_perc_1RM_perc_MR()</code>: Adjust max perc 1RM using the %Max Reps (%MR) approach.
This approach simple divides target reps with <code>adjustment</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------
# Adjustment using Reps In Reserve (RIR)
adj_perc_1RM_RIR(5)

# Use ballistic adjustment (this implies doing half the reps)
adj_perc_1RM_RIR(5, mfactor = 2)

# Use 2 reps in reserve
adj_perc_1RM_RIR(5, adjustment = 2)

# Use Linear model
adj_perc_1RM_RIR(5, max_perc_1RM_func = max_perc_1RM_linear, adjustment = 2)

# Use Modifed Epley's equation with a custom parameter values
adj_perc_1RM_RIR(
  5,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  adjustment = 2,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using Deducted Intensity (DI)
adj_perc_1RM_DI(5)

# Use ballistic adjustment (this implies doing half the reps)
adj_perc_1RM_DI(5, mfactor = 2)

# Use 10 perc deducted intensity
adj_perc_1RM_DI(5, adjustment = -0.1)

# Use Linear model
adj_perc_1RM_DI(5, max_perc_1RM_func = max_perc_1RM_linear, adjustment = -0.1)

# Use Modifed Epley's equation with a custom parameter values
adj_perc_1RM_DI(
  5,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  adjustment = -0.1,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using Relative Intensity (RelInt)
adj_perc_1RM_rel_int(5)

# Use ballistic adjustment (this implies doing half the reps)
adj_perc_1RM_rel_int(5, mfactor = 2)

# Use 90 perc  relative intensity
adj_perc_1RM_rel_int(5, adjustment = 0.9)

# Use Linear model
adj_perc_1RM_rel_int(5, max_perc_1RM_func = max_perc_1RM_linear, adjustment = 0.9)

# Use Modifed Epley's equation with a custom parameter values
adj_perc_1RM_rel_int(
  5,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  adjustment = 0.9,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using % max reps (%MR)
adj_perc_1RM_perc_MR(5)

# Use ballistic adjustment (this implies doing half the reps)
adj_perc_1RM_perc_MR(5, mfactor = 2)

# Use 70 perc max reps
adj_perc_1RM_perc_MR(5, adjustment = 0.7)

# Use Linear model
adj_perc_1RM_perc_MR(5, max_perc_1RM_func = max_perc_1RM_linear, adjustment = 0.7)

# Use Modifed Epley's equation with a custom parameter values
adj_perc_1RM_perc_MR(
  5,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  adjustment = 0.7,
  kmod = 0.06
)
</code></pre>

<hr>
<h2 id='adj_reps'>Family of functions to adjust number of repetition</h2><span id='topic+adj_reps'></span><span id='topic+adj_reps_RIR'></span><span id='topic+adj_reps_DI'></span><span id='topic+adj_reps_rel_int'></span><span id='topic+adj_reps_perc_MR'></span>

<h3>Description</h3>

<p>These functions are reverse version of the <code><a href="#topic+adj_perc_1RM">adj_perc_1RM</a></code>
family of functions. Use these when you want to estimate number of
repetitions to be used when using the known %1RM and level of
adjustment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_reps_RIR(
  perc_1RM,
  adjustment = 0,
  mfactor = 1,
  max_reps_func = max_reps_epley,
  ...
)

adj_reps_DI(
  perc_1RM,
  adjustment = 1,
  mfactor = 1,
  max_reps_func = max_reps_epley,
  ...
)

adj_reps_rel_int(
  perc_1RM,
  adjustment = 1,
  mfactor = 1,
  max_reps_func = max_reps_epley,
  ...
)

adj_reps_perc_MR(
  perc_1RM,
  adjustment = 1,
  mfactor = 1,
  max_reps_func = max_reps_epley,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_reps_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>Numeric vector. %1RM used (use 0.5 for 50%, 0.9 for 90%)</p>
</td></tr>
<tr><td><code id="adj_reps_+3A_adjustment">adjustment</code></td>
<td>
<p>Numeric vector. Adjustment to be implemented</p>
</td></tr>
<tr><td><code id="adj_reps_+3A_mfactor">mfactor</code></td>
<td>
<p>Numeric vector. Default is 1 (i.e., no adjustment).
Use <code>mfactor = 2</code> to generate ballistic adjustment and tables</p>
</td></tr>
<tr><td><code id="adj_reps_+3A_max_reps_func">max_reps_func</code></td>
<td>
<p>Max reps function to be used. Default is <code><a href="#topic+max_reps_epley">max_reps_epley</a></code></p>
</td></tr>
<tr><td><code id="adj_reps_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>max_reps_func</code>. Usually the parameter value.
For example <code>klin = 36</code> when using <code><a href="#topic+max_reps_linear">max_reps_linear</a></code> as
<code>max_reps_func</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. Predicted number of repetitions to be performed
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>adj_reps_RIR()</code>: Adjust number of repetitions using the Reps In Reserve (RIR) approach
</p>
</li>
<li> <p><code>adj_reps_DI()</code>: Adjust number of repetitions using the Deducted Intensity (DI) approach
</p>
</li>
<li> <p><code>adj_reps_rel_int()</code>: Adjust number of repetitions using the Relative Intensity (RelInt) approach
</p>
</li>
<li> <p><code>adj_reps_perc_MR()</code>: Adjust number of repetitions using the % max reps (%MR) approach
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------
# Adjustment using Reps In Reserve (RIR)
adj_reps_RIR(0.75)

# Use ballistic adjustment (this implies doing half the reps)
adj_reps_RIR(0.75, mfactor = 2)

# Use 2 reps in reserve
adj_reps_RIR(0.75, adjustment = 2)

# Use Linear model
adj_reps_RIR(0.75, max_reps_func = max_reps_linear, adjustment = 2)

# Use Modifed Epley's equation with a custom parameter values
adj_reps_RIR(
  0.75,
  max_reps_func = max_reps_modified_epley,
  adjustment = 2,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using Deducted Intensity (DI)
adj_reps_DI(0.75)

# Use ballistic adjustment (this implies doing half the reps)
adj_reps_DI(0.75, mfactor = 2)

# Use 10% deducted intensity
adj_reps_DI(0.75, adjustment = -0.1)

# Use Linear model
adj_reps_DI(0.75, max_reps_func = max_reps_linear, adjustment = -0.1)

# Use Modifed Epley's equation with a custom parameter values
adj_reps_DI(
  0.75,
  max_reps_func = max_reps_modified_epley,
  adjustment = -0.1,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using Relative Intensity (RelInt)
adj_reps_rel_int(0.75)

# Use ballistic adjustment (this implies doing half the reps)
adj_reps_rel_int(0.75, mfactor = 2)

# Use 85% relative intensity
adj_reps_rel_int(0.75, adjustment = 0.85)

# Use Linear model
adj_reps_rel_int(0.75, max_reps_func = max_reps_linear, adjustment = 0.85)

# Use Modifed Epley's equation with a custom parameter values
adj_reps_rel_int(
  0.75,
  max_reps_func = max_reps_modified_epley,
  adjustment = 0.85,
  kmod = 0.06
)
# ------------------------------------------
# Adjustment using % max reps (%MR)
adj_reps_perc_MR(0.75)

# Use ballistic adjustment (this implies doing half the reps)
adj_reps_perc_MR(0.75, mfactor = 2)

# Use 85% of max reps
adj_reps_perc_MR(0.75, adjustment = 0.85)

# Use Linear model
adj_reps_perc_MR(0.75, max_reps_func = max_reps_linear, adjustment = 0.85)

# Use Modifed Epley's equation with a custom parameter values
adj_reps_perc_MR(
  0.75,
  max_reps_func = max_reps_modified_epley,
  adjustment = 0.85,
  kmod = 0.06
)
</code></pre>

<hr>
<h2 id='create_example'>Create Example</h2><span id='topic+create_example'></span>

<h3>Description</h3>

<p>This function create simple example using <code>progression_table</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_example(
  progression_table,
  reps = c(3, 5, 10),
  volume = c("intensive", "normal", "extensive"),
  type = c("grinding", "ballistic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_example_+3A_progression_table">progression_table</code></td>
<td>
<p>Progression table function</p>
</td></tr>
<tr><td><code id="create_example_+3A_reps">reps</code></td>
<td>
<p>Numeric vector. Default is <code>c(3, 5, 10)</code></p>
</td></tr>
<tr><td><code id="create_example_+3A_volume">volume</code></td>
<td>
<p>Character vector. Default is <code>c("intensive", "normal", "extensive")</code></p>
</td></tr>
<tr><td><code id="create_example_+3A_type">type</code></td>
<td>
<p>Character vector. Type of max rep table. Options are grinding (Default) and ballistic</p>
</td></tr>
<tr><td><code id="create_example_+3A_...">...</code></td>
<td>
<p>Extra arguments forwarded to <code>progression_table</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following structure
</p>

<dl>
<dt>type</dt><dd><p>Type of the set and rep scheme</p>
</dd>
<dt>reps</dt><dd><p>Number of reps performed</p>
</dd>
<dt>volume</dt><dd><p>Volume type of the set and rep scheme</p>
</dd>
<dt>Step 1</dt><dd><p>First progression step %1RM</p>
</dd>
<dt>Step 2</dt><dd><p>Second progression step %1RM</p>
</dd>
<dt>Step 3</dt><dd><p>Third progression step %1RM</p>
</dd>
<dt>Step 4</dt><dd><p>Fourth progression step %1RM</p>
</dd>
<dt>Step 2-1 Diff</dt><dd><p>Difference in %1RM between second and first progression step</p>
</dd>
<dt>Step 3-2 Diff</dt><dd><p>Difference in %1RM between third and second progression step</p>
</dd>
<dt>Step 4-3 Diff</dt><dd><p>Difference in %1RM between fourth and third progression step</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>create_example(progression_RIR)

# Create example using specific reps-max table and k value
create_example(
  progression_RIR,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  kmod = 0.0388
)
</code></pre>

<hr>
<h2 id='estimate_functions'>Estimate relationship between reps and %1RM (or weight)</h2><span id='topic+estimate_functions'></span><span id='topic+estimate_k_generic'></span><span id='topic+estimate_k_generic_1RM'></span><span id='topic+estimate_k'></span><span id='topic+estimate_k_1RM'></span><span id='topic+estimate_kmod'></span><span id='topic+estimate_kmod_1RM'></span><span id='topic+estimate_klin'></span><span id='topic+estimate_klin_1RM'></span><span id='topic+get_predicted_1RM_from_k_model'></span>

<h3>Description</h3>

<p>By default, target variable is the reps performed, while the predictors is the <code>perc_1RM</code> or
<code>weight</code>. To reverse this, use the <code>reverse = TRUE</code> argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_k_generic(
  perc_1RM,
  reps,
  eRIR = 0,
  k = 0.0333,
  reverse = FALSE,
  weighted = "none",
  ...
)

estimate_k_generic_1RM(
  weight,
  reps,
  eRIR = 0,
  k = 0.0333,
  reverse = FALSE,
  weighted = "none",
  ...
)

estimate_k(perc_1RM, reps, eRIR = 0, reverse = FALSE, weighted = "none", ...)

estimate_k_1RM(weight, reps, eRIR = 0, reverse = FALSE, weighted = "none", ...)

estimate_kmod(
  perc_1RM,
  reps,
  eRIR = 0,
  reverse = FALSE,
  weighted = "none",
  ...
)

estimate_kmod_1RM(
  weight,
  reps,
  eRIR = 0,
  reverse = FALSE,
  weighted = "none",
  ...
)

estimate_klin(
  perc_1RM,
  reps,
  eRIR = 0,
  reverse = FALSE,
  weighted = "none",
  ...
)

estimate_klin_1RM(
  weight,
  reps,
  eRIR = 0,
  reverse = FALSE,
  weighted = "none",
  ...
)

get_predicted_1RM_from_k_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_functions_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>%1RM</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_reps">reps</code></td>
<td>
<p>Number of repetitions done</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_erir">eRIR</code></td>
<td>
<p>Subjective estimation of reps-in-reserve (eRIR)</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_k">k</code></td>
<td>
<p>Value for the generic Epley's equation, which is by default equal to 0.0333</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_reverse">reverse</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should reps be used as predictor instead as a target?</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_weighted">weighted</code></td>
<td>
<p>What weighting should be used for the non-linear regression? Default is &quot;none&quot;. Other options include:
&quot;reps&quot; (for 1/reps weighting), &quot;load&quot; (for using weight or %1RM), &quot;eRIR&quot; (for 1/(eRIR+1) weighting),
&quot;reps x load&quot;, &quot;reps x eRIR&quot;, &quot;load x eRIR&quot;, and &quot;reps x load x eRIR&quot;</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> function</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_weight">weight</code></td>
<td>
<p>Weight used</p>
</td></tr>
<tr><td><code id="estimate_functions_+3A_model">model</code></td>
<td>
<p>Object returned from the  <code><a href="#topic+estimate_k_1RM">estimate_k_1RM</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimate_k_generic()</code>: Provides the model with generic <code>k</code> parameter
</p>
</li>
<li> <p><code>estimate_k_generic_1RM()</code>: Provides the model with generic <code>k</code> parameter, as well as
estimated <code>1RM</code>. This is a novel estimation function that uses the absolute weights.
</p>
</li>
<li> <p><code>estimate_k()</code>: Estimate the parameter <code>k</code> in the Epley's equation
</p>
</li>
<li> <p><code>estimate_k_1RM()</code>: Estimate the parameter <code>k</code> in the Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights.
</p>
</li>
<li> <p><code>estimate_kmod()</code>: Estimate the parameter <code>kmod</code> in the modified Epley's equation
</p>
</li>
<li> <p><code>estimate_kmod_1RM()</code>: Estimate the parameter <code>kmod</code> in the modified Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_klin()</code>: Estimate the parameter <code>klin</code> using the Linear/Brzycki model
</p>
</li>
<li> <p><code>estimate_klin_1RM()</code>: Estimate the parameter <code>klin</code> in the Linear/Brzycki equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>get_predicted_1RM_from_k_model()</code>: Estimate the 1RM from <code><a href="#topic+estimate_k_1RM">estimate_k_1RM</a></code> function
</p>
<p>The problem with Epley's estimation model (implemented in <code><a href="#topic+estimate_k_1RM">estimate_k_1RM</a></code> function)
is that it predicts the 1RM when nRM = 0. Thus, the estimated parameter in the model produced
by the <code><a href="#topic+estimate_k_1RM">estimate_k_1RM</a></code> function is not 1RM, but 0RM. This function calculates the
weight at nRM = 1 for both the normal and reverse model. See Examples for code
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------
# Generic Epley's model
m1 &lt;- estimate_k_generic(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Generic Epley's model that also estimates 1RM
m1 &lt;- estimate_k_generic_1RM(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Epley's model
m1 &lt;- estimate_k(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Epley's model that also estimates 1RM
m1 &lt;- estimate_k_1RM(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Modified Epley's model
m1 &lt;- estimate_kmod(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Modified Epley's model that also estimates 1RM
m1 &lt;- estimate_kmod_1RM(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model
m1 &lt;- estimate_klin(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model thal also estimates 1RM
m1 &lt;- estimate_klin_1RM(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Estimating 1RM from Epley's model
m1 &lt;- estimate_k_1RM(150 * c(0.9, 0.8, 0.7), c(3, 6, 12))
m2 &lt;- estimate_k_1RM(150 * c(0.9, 0.8, 0.7), c(3, 6, 12), reverse = TRUE)

# Estimated 0RM values from both model
c(coef(m1)[[1]], coef(m2)[[1]])

# But these are not 1RMs!!!
# Using the "reverse" model, where nRM is the predictor (in this case m2)
# makes it easier to predict 1RM
predict(m2, newdata = data.frame(nRM = 1))

# But for the normal model it involve reversing the formula
# To spare you from the math pain, use this
get_predicted_1RM_from_k_model(m1)

# It also works for the "reverse" model
get_predicted_1RM_from_k_model(m2)
</code></pre>

<hr>
<h2 id='estimate_functions_mixed'>Estimate relationship between reps and weight using the non-linear mixed-effects regression</h2><span id='topic+estimate_functions_mixed'></span><span id='topic+estimate_k_mixed'></span><span id='topic+estimate_k_generic_1RM_mixed'></span><span id='topic+estimate_k_1RM_mixed'></span><span id='topic+estimate_kmod_mixed'></span><span id='topic+estimate_kmod_1RM_mixed'></span><span id='topic+estimate_klin_mixed'></span><span id='topic+estimate_klin_1RM_mixed'></span>

<h3>Description</h3>

<p>These functions provide estimated 1RM and parameter values using the mixed-effect regression. By default,
target variable is the reps performed, while the predictor is the <code>perc_1RM</code> or
<code>weight</code>. To reverse this, use the <code>reverse = TRUE</code> argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_k_mixed(athlete, perc_1RM, reps, eRIR = 0, reverse = FALSE, ...)

estimate_k_generic_1RM_mixed(
  athlete,
  weight,
  reps,
  eRIR = 0,
  k = 0.0333,
  reverse = FALSE,
  random = zeroRM ~ 1,
  ...
)

estimate_k_1RM_mixed(
  athlete,
  weight,
  reps,
  eRIR = 0,
  reverse = FALSE,
  random = k + zeroRM ~ 1,
  ...
)

estimate_kmod_mixed(athlete, perc_1RM, reps, eRIR = 0, reverse = FALSE, ...)

estimate_kmod_1RM_mixed(
  athlete,
  weight,
  reps,
  eRIR = 0,
  reverse = FALSE,
  random = kmod + oneRM ~ 1,
  ...
)

estimate_klin_mixed(athlete, perc_1RM, reps, eRIR = 0, reverse = FALSE, ...)

estimate_klin_1RM_mixed(
  athlete,
  weight,
  reps,
  eRIR = 0,
  reverse = FALSE,
  random = klin + oneRM ~ 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_functions_mixed_+3A_athlete">athlete</code></td>
<td>
<p>Athlete identifier</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>%1RM</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_reps">reps</code></td>
<td>
<p>Number of repetitions done</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_erir">eRIR</code></td>
<td>
<p>Subjective estimation of reps-in-reserve (eRIR)</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_reverse">reverse</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should reps be used as predictor instead as a target?</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="nlme.html#topic+nlme">nlme</a></code> function</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_weight">weight</code></td>
<td>
<p>Weight used</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_k">k</code></td>
<td>
<p>Value for the generic Epley's equation, which is by default equal to 0.0333</p>
</td></tr>
<tr><td><code id="estimate_functions_mixed_+3A_random">random</code></td>
<td>
<p>Random parameter forwarded to <code><a href="nlme.html#topic+nlme">nlme</a></code> function. Default is <code>k + zeroRM ~ 1</code> for,
<code><a href="#topic+estimate_k_mixed">estimate_k_mixed</a></code> function, or <code>k + oneRM ~ 1</code> for <code><a href="#topic+estimate_kmod_mixed">estimate_kmod_mixed</a></code> and
<code><a href="#topic+estimate_klin_mixed">estimate_klin_mixed</a></code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="nlme.html#topic+nlme">nlme</a></code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimate_k_mixed()</code>: Estimate the parameter <code>k</code> in the Epley's equation
</p>
</li>
<li> <p><code>estimate_k_generic_1RM_mixed()</code>: Provides the model with generic <code>k</code> parameter, as well as
estimated <code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_k_1RM_mixed()</code>: Estimate the parameter <code>k</code> in the Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_kmod_mixed()</code>: Estimate the parameter <code>kmod</code> in the Modified Epley's equation
</p>
</li>
<li> <p><code>estimate_kmod_1RM_mixed()</code>: Estimate the parameter <code>kmod</code> in the Modified Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_klin_mixed()</code>: Estimate the parameter <code>klin</code> in the Linear/Brzycki's equation
</p>
</li>
<li> <p><code>estimate_klin_1RM_mixed()</code>: Estimate the parameter <code>klin</code> in the Linear/Brzycki equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------
# Epley's model
m1 &lt;- estimate_k_mixed(
  athlete = RTF_testing$Athlete,
  perc_1RM = RTF_testing$`Real %1RM`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Generic Epley's model that also estimates 1RM
m1 &lt;- estimate_k_generic_1RM_mixed(
  athlete = RTF_testing$Athlete,
  weight = RTF_testing$`Real Weight`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Epley's model that also estimates 1RM
m1 &lt;- estimate_k_1RM_mixed(
  athlete = RTF_testing$Athlete,
  weight = RTF_testing$`Real Weight`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Modifed Epley's model
m1 &lt;- estimate_kmod_mixed(
  athlete = RTF_testing$Athlete,
  perc_1RM = RTF_testing$`Real %1RM`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Modified Epley's model that also estimates 1RM
m1 &lt;- estimate_kmod_1RM_mixed(
  athlete = RTF_testing$Athlete,
  weight = RTF_testing$`Real Weight`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model
m1 &lt;- estimate_klin_mixed(
  athlete = RTF_testing$Athlete,
  perc_1RM = RTF_testing$`Real %1RM`,
  reps = RTF_testing$nRM
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model that also estimates 1RM
m1 &lt;- estimate_klin_1RM_mixed(
  athlete = RTF_testing$Athlete,
  weight = RTF_testing$`Real Weight`,
  reps = RTF_testing$nRM
)

coef(m1)
</code></pre>

<hr>
<h2 id='estimate_functions_quantile'>Estimate relationship between reps and weight using the non-linear quantile regression</h2><span id='topic+estimate_functions_quantile'></span><span id='topic+estimate_k_quantile'></span><span id='topic+estimate_k_generic_1RM_quantile'></span><span id='topic+estimate_k_1RM_quantile'></span><span id='topic+estimate_kmod_quantile'></span><span id='topic+estimate_kmod_1RM_quantile'></span><span id='topic+estimate_klin_quantile'></span><span id='topic+estimate_klin_1RM_quantile'></span>

<h3>Description</h3>

<p>These functions provide estimate 1RM and parameter values using the quantile regression. By default,
target variable is the reps performed, while the predictors is the <code>perc_1RM</code> or
<code>weight</code>. To reverse this, use the <code>reverse = TRUE</code> argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_k_quantile(
  perc_1RM,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_k_generic_1RM_quantile(
  weight,
  reps,
  eRIR = 0,
  k = 0.0333,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_k_1RM_quantile(
  weight,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_kmod_quantile(
  perc_1RM,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_kmod_1RM_quantile(
  weight,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_klin_quantile(
  perc_1RM,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)

estimate_klin_1RM_quantile(
  weight,
  reps,
  eRIR = 0,
  tau = 0.5,
  reverse = FALSE,
  control = quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_functions_quantile_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>%1RM</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_reps">reps</code></td>
<td>
<p>Number of repetitions done</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_erir">eRIR</code></td>
<td>
<p>Subjective estimation of reps-in-reserve (eRIR)</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_tau">tau</code></td>
<td>
<p>Vector of quantiles to be estimated. Default is 0.5</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_reverse">reverse</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Should reps be used as predictor instead as a target?</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_control">control</code></td>
<td>
<p>Control object for the <code><a href="quantreg.html#topic+nlrq">nlrq</a></code> function. Default is:
<code>quantreg::nlrq.control(maxiter = 10^4, InitialStepSize = 0)</code></p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="quantreg.html#topic+nlrq">nlrq</a></code> function</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_weight">weight</code></td>
<td>
<p>Weight used</p>
</td></tr>
<tr><td><code id="estimate_functions_quantile_+3A_k">k</code></td>
<td>
<p>Value for the generic Epley's equation, which is by default equal to 0.0333</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="quantreg.html#topic+nlrq">nlrq</a></code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>estimate_k_quantile()</code>: Estimate the parameter <code>k</code> in the Epley's equation
</p>
</li>
<li> <p><code>estimate_k_generic_1RM_quantile()</code>: Provides the model with generic <code>k</code> parameter, as well as
estimated <code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_k_1RM_quantile()</code>: Estimate the parameter <code>k</code> in the Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_kmod_quantile()</code>: Estimate the parameter <code>kmod</code> in the modified Epley's equation
</p>
</li>
<li> <p><code>estimate_kmod_1RM_quantile()</code>: Estimate the parameter <code>kmod</code> in the modified Epley's equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li>
<li> <p><code>estimate_klin_quantile()</code>: Estimate the parameter <code>klin</code> in the Linear/Brzycki equation
</p>
</li>
<li> <p><code>estimate_klin_1RM_quantile()</code>: Estimate the parameter <code>klin</code> in the Linear/Brzycki equation, as well as
<code>1RM</code>. This is a novel estimation function that uses the absolute weights
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ---------------------------------------------------------
# Epley's model
m1 &lt;- estimate_k_quantile(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Epley's model that also estimates 1RM
m1 &lt;- estimate_k_generic_1RM_quantile(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Epley's model that also estimates 1RM
m1 &lt;- estimate_k_1RM_quantile(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Modified Epley's model
m1 &lt;- estimate_kmod_quantile(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Modified Epley's model that also estimates 1RM
m1 &lt;- estimate_kmod_1RM_quantile(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model
m1 &lt;- estimate_klin_quantile(
  perc_1RM = c(0.7, 0.8, 0.9),
  reps = c(10, 5, 3)
)

coef(m1)
# ---------------------------------------------------------
# Linear/Brzycki model thal also estimates 1RM
m1 &lt;- estimate_klin_1RM_quantile(
  weight = c(70, 110, 140),
  reps = c(10, 5, 3)
)

coef(m1)
</code></pre>

<hr>
<h2 id='estimate_rolling_1RM'>Estimate the rolling profile and 1RM</h2><span id='topic+estimate_rolling_1RM'></span>

<h3>Description</h3>

<p>Estimate the rolling profile and 1RM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_rolling_1RM(
  weight,
  reps,
  eRIR = 0,
  day_index,
  window = 14,
  estimate_function = estimate_k_1RM,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_rolling_1RM_+3A_weight">weight</code></td>
<td>
<p>Weight used</p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_reps">reps</code></td>
<td>
<p>Number of repetitions done</p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_erir">eRIR</code></td>
<td>
<p>Subjective estimation of reps-in-reserve (eRIR)</p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_day_index">day_index</code></td>
<td>
<p>Day index used to estimate rolling window</p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_window">window</code></td>
<td>
<p>Width of the rolling window. Default is 14</p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_estimate_function">estimate_function</code></td>
<td>
<p>Estimation function to be used. Default is
<code><a href="#topic+estimate_k_1RM">estimate_k_1RM</a></code></p>
</td></tr>
<tr><td><code id="estimate_rolling_1RM_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>estimate_function</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with day index and coefficients returned by the <code>estimate_function</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimate_rolling_1RM(
  weight = strength_training_log$weight,
  reps = strength_training_log$reps,
  eRIR = strength_training_log$eRIR,
  day_index = strength_training_log$day,
  window = 10,
  estimate_function = estimate_k_1RM_quantile,
  tau = 0.9
)
</code></pre>

<hr>
<h2 id='generate_progression_table'>Family of functions to create progression tables</h2><span id='topic+generate_progression_table'></span><span id='topic+progression_DI'></span><span id='topic+progression_RIR'></span><span id='topic+progression_RIR_increment'></span><span id='topic+progression_perc_MR'></span><span id='topic+progression_perc_MR_variable'></span><span id='topic+progression_perc_drop'></span><span id='topic+progression_rel_int'></span><span id='topic+progression_table'></span>

<h3>Description</h3>

<p>Family of functions to create progression tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_progression_table(
  progression_table,
  type = c("grinding", "ballistic"),
  volume = c("intensive", "normal", "extensive"),
  reps = 1:12,
  step = seq(-3, 0, 1),
  ...
)

progression_DI(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  step_increment = -0.025,
  volume_increment = step_increment,
  ...
)

progression_RIR(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  step_increment = 1,
  volume_increment = step_increment,
  ...
)

progression_RIR_increment(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  ...
)

progression_perc_MR(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  step_increment = -0.1,
  volume_increment = -0.2,
  ...
)

progression_perc_MR_variable(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  ...
)

progression_perc_drop(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  ...
)

progression_rel_int(
  reps,
  step = 0,
  volume = "normal",
  adjustment = 0,
  type = "grinding",
  mfactor = NULL,
  step_increment = -0.05,
  volume_increment = -0.075,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_progression_table_+3A_progression_table">progression_table</code></td>
<td>
<p>Progression table function to use</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_type">type</code></td>
<td>
<p>Character vector. Type of max rep table. Options are grinding (Default) and ballistic.</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_volume">volume</code></td>
<td>
<p>Character vector: 'intensive', 'normal' (Default), or 'extensive'</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_reps">reps</code></td>
<td>
<p>Numeric vector. Number of repetition to be performed</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_step">step</code></td>
<td>
<p>Numeric vector. Progression step. Default is 0. Use negative numbers (i.e., -1, -2)</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_...">...</code></td>
<td>
<p>Extra arguments forwarded to <code><a href="#topic+adj_perc_1RM">adj_perc_1RM</a></code> family of functions
Use this to supply different parameter value (i.e., <code>k = 0.035</code>), or model
function (i.e., <code>max_perc_1RM_func = max_perc_1RM_linear)</code></p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_adjustment">adjustment</code></td>
<td>
<p>Numeric vector. Additional post adjustment applied to sets. Default is none
(value depends on the method).</p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_mfactor">mfactor</code></td>
<td>
<p>Numeric vector. Factor to adjust max rep table. Used instead of <code>type</code> parameter,
unless <code>NULL</code></p>
</td></tr>
<tr><td><code id="generate_progression_table_+3A_step_increment">step_increment</code>, <code id="generate_progression_table_+3A_volume_increment">volume_increment</code></td>
<td>
<p>Numeric vector. Used to adjust specific progression methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements: <code>adjustment</code> and <code>perc_1RM</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_progression_table()</code>: Generates progression tables
</p>
</li>
<li> <p><code>progression_DI()</code>: Deducted Intensity progression table. This simplest progression
table simply deducts intensity to progress. Adjust this deducted by using the
<code>deduction</code> parameter (default is equal to -0.025)
</p>
</li>
<li> <p><code>progression_RIR()</code>: Constant RIR Increment progression table. This variant have constant RIR
increment across reps from phases to phases and RIR difference between extensive, normal, and
intensive schemes. Use <code>step_increment</code> and  <code>volume_increment</code> parameters to
utilize needed increments
</p>
</li>
<li> <p><code>progression_RIR_increment()</code>: RIR Increment progression table (see Strength Training Manual)
</p>
</li>
<li> <p><code>progression_perc_MR()</code>: Constant %MR Step progression table. This variant have constant %MR
increment across reps from phases to phases and %MR difference between extensive, normal, and
intensive schemes. Use <code>step_increment</code> and  <code>volume_increment</code> parameters to
utilize needed increments
</p>
</li>
<li> <p><code>progression_perc_MR_variable()</code>: Variable %MR Step progression table
</p>
</li>
<li> <p><code>progression_perc_drop()</code>: Perc Drop progression table (see Strength Training Manual)
</p>
</li>
<li> <p><code>progression_rel_int()</code>: Relative Intensity progression table. Use <code>step_increment</code>
and  <code>volume_increment</code> parameters to utilize needed increments
</p>
</li></ul>


<h3>References</h3>

<div class="sourceCode"><pre>Jovanović M. 2020. Strength Training Manual: The Agile Periodization Approach.
Independently published.
</pre></div>
<div class="sourceCode"><pre>Jovanović M. 2020. Strength Training Manual: The Agile Periodization Approach.
Independently published.
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>generate_progression_table(progression_RIR)

generate_progression_table(
  progression_RIR,
  type = "grinding",
  volume = "normal",
  step_increment = 2
)

# Create progression table using specific reps-max table and k value
generate_progression_table(
  progression_RIR,
  max_perc_1RM_func = max_perc_1RM_modified_epley,
  kmod = 0.0388
)
# ------------------------------------------
# Progression Deducted Intensity
progression_DI(10, step = seq(-3, 0, 1))
progression_DI(10, step = seq(-3, 0, 1), volume = "extensive")
progression_DI(5, step = seq(-3, 0, 1), type = "ballistic", step_increment = -0.05)
progression_DI(
  5,
  step = seq(-3, 0, 1),
  type = "ballistic",
  step_increment = -0.05,
  volume_increment = -0.1
)

# Generate progression table
generate_progression_table(progression_DI, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_DI,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)

# ------------------------------------------
# Progression RIR Constant
progression_RIR(10, step = seq(-3, 0, 1))
progression_RIR(10, step = seq(-3, 0, 1), volume = "extensive")
progression_RIR(5, step = seq(-3, 0, 1), type = "ballistic", step_increment = 2)
progression_RIR(
  5,
  step = seq(-3, 0, 1),
  type = "ballistic",
  step_increment = 3
)

# Generate progression table
generate_progression_table(progression_RIR, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_RIR,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)

# Plot progression table
plot_progression_table(progression_RIR)
plot_progression_table(progression_RIR, "adjustment")
# ------------------------------------------
# Progression RIR Increment
progression_RIR_increment(10, step = seq(-3, 0, 1))
progression_RIR_increment(10, step = seq(-3, 0, 1), volume = "extensive")
progression_RIR_increment(5, step = seq(-3, 0, 1), type = "ballistic")

# Generate progression table
generate_progression_table(progression_RIR_increment, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_RIR_increment,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)
# ------------------------------------------
# Progression %MR Step Const
progression_perc_MR(10, step = seq(-3, 0, 1))
progression_perc_MR(10, step = seq(-3, 0, 1), volume = "extensive")
progression_perc_MR(5, step = seq(-3, 0, 1), type = "ballistic", step_increment = -0.2)
progression_perc_MR(
  5,
  step = seq(-3, 0, 1),
  type = "ballistic",
  step_increment = -0.15,
  volume_increment = -0.25
)

# Generate progression table
generate_progression_table(progression_perc_MR, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_perc_MR,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)

# ------------------------------------------
# Progression %MR Step Variable
progression_perc_MR_variable(10, step = seq(-3, 0, 1))
progression_perc_MR_variable(10, step = seq(-3, 0, 1), volume = "extensive")
progression_perc_MR_variable(5, step = seq(-3, 0, 1), type = "ballistic")
# Generate progression table
generate_progression_table(progression_perc_MR_variable, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_perc_MR_variable,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)
# ------------------------------------------
# Progression Perc Drop
progression_perc_drop(10, step = seq(-3, 0, 1))
progression_perc_drop(10, step = seq(-3, 0, 1), volume = "extensive")
progression_perc_drop(5, step = seq(-3, 0, 1), type = "ballistic")

# Generate progression table
generate_progression_table(progression_perc_drop, type = "grinding", volume = "normal")

# Use different reps-max model
generate_progression_table(
  progression_perc_drop,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)
# ------------------------------------------
# Progression Relative Intensity
progression_rel_int(10, step = seq(-3, 0, 1))
progression_rel_int(10, step = seq(-3, 0, 1), volume = "extensive")
progression_rel_int(5, step = seq(-3, 0, 1), type = "ballistic")

# Generate progression table
generate_progression_table(progression_rel_int, type = "grinding", volume = "normal")
generate_progression_table(progression_rel_int, step_increment = -0.1, volume_increment = 0.15)

# Use different reps-max model
generate_progression_table(
  progression_rel_int,
  type = "grinding",
  volume = "normal",
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)
</code></pre>

<hr>
<h2 id='get_perc_1RM'>Get %1RM</h2><span id='topic+get_perc_1RM'></span>

<h3>Description</h3>

<p>Function <code>get_perc_1RM</code> represent a wrapper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_perc_1RM(reps, method = "RIR", model = "epley", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_perc_1RM_+3A_reps">reps</code></td>
<td>
<p>Numeric vector. Number of repetition to be performed</p>
</td></tr>
<tr><td><code id="get_perc_1RM_+3A_method">method</code></td>
<td>
<p>Character vector. Default is &quot;RIR&quot;. Other options are
&quot;DI&quot;, &quot;RelInt&quot;, &quot;%MR&quot;</p>
</td></tr>
<tr><td><code id="get_perc_1RM_+3A_model">model</code></td>
<td>
<p>Character vector. Default is &quot;epley&quot;. Other options are
&quot;modified epley&quot;, &quot;linear&quot;</p>
</td></tr>
<tr><td><code id="get_perc_1RM_+3A_...">...</code></td>
<td>
<p>Forwarded to selected <code>adj_perc_1RM</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. Predicted %1RM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_perc_1RM(5)

# # Use ballistic adjustment (this implies doing half the reps)
get_perc_1RM(5, mfactor = 2)

# Use perc MR adjustment method
get_perc_1RM(5, "%MR", adjustment = 0.8)

# Use linear model with use defined klin values
get_perc_1RM(5, "%MR", model = "linear", adjustment = 0.8, klin = 36)
</code></pre>

<hr>
<h2 id='get_reps'>Get Reps</h2><span id='topic+get_reps'></span>

<h3>Description</h3>

<p>Function <code>get_reps</code> represent a wrapper function. This function is the
reverse version of the <code><a href="#topic+get_perc_1RM">get_perc_1RM</a></code> function. Use it when
you want to estimate number of repetitions to be used when using the
known %1RM and level of adjustment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reps(perc_1RM, method = "RIR", model = "epley", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reps_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>Numeric vector. %1RM used (use 0.5 for 50 perc, 0.9 for 90 perc)</p>
</td></tr>
<tr><td><code id="get_reps_+3A_method">method</code></td>
<td>
<p>Character vector. Default is &quot;RIR&quot;. Other options are
&quot;DI&quot;, &quot;RelInt&quot;, &quot;%MR&quot;</p>
</td></tr>
<tr><td><code id="get_reps_+3A_model">model</code></td>
<td>
<p>Character vector. Default is &quot;epley&quot;. Other options are
&quot;modified epley&quot;, &quot;linear&quot;</p>
</td></tr>
<tr><td><code id="get_reps_+3A_...">...</code></td>
<td>
<p>Forwarded to selected <code>adj_reps</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector Predicted repetitions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_reps(0.75)

# # Use ballistic adjustment (this implies doing half the reps)
get_reps(0.75, mfactor = 2)

# Use %MR adjustment method
get_reps(0.75, "%MR", adjustment = 0.8)

# Use linear model with use defined klin values
get_reps(0.75, "%MR", model = "linear", adjustment = 0.8, klin = 36)
</code></pre>

<hr>
<h2 id='max_perc_1RM'>Family of functions to estimate max %1RM</h2><span id='topic+max_perc_1RM'></span><span id='topic+max_perc_1RM_epley'></span><span id='topic+max_perc_1RM_modified_epley'></span><span id='topic+max_perc_1RM_linear'></span>

<h3>Description</h3>

<p>Family of functions to estimate max %1RM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_perc_1RM_epley(reps, k = 0.0333)

max_perc_1RM_modified_epley(reps, kmod = 0.0353)

max_perc_1RM_linear(reps, klin = 33)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_perc_1RM_+3A_reps">reps</code></td>
<td>
<p>Numeric vector. Number of repetition to be performed</p>
</td></tr>
<tr><td><code id="max_perc_1RM_+3A_k">k</code></td>
<td>
<p>User defined <code>k</code> parameter in the Epley's equation. Default is 0.0333</p>
</td></tr>
<tr><td><code id="max_perc_1RM_+3A_kmod">kmod</code></td>
<td>
<p>User defined <code>kmod</code> parameter in the Modified Epley's equation. Default is 0.0353</p>
</td></tr>
<tr><td><code id="max_perc_1RM_+3A_klin">klin</code></td>
<td>
<p>User defined <code>klin</code> parameter in the Linear equation. Default is 33</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. Predicted %1RM
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>max_perc_1RM_epley()</code>: Estimate max %1RM using the Epley's equation
</p>
</li>
<li> <p><code>max_perc_1RM_modified_epley()</code>: Estimate max %1RM using the Modified Epley's equation
</p>
</li>
<li> <p><code>max_perc_1RM_linear()</code>: Estimate max %1RM using the Linear (or Brzycki's) equation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------
# Epley equation
max_perc_1RM_epley(1:10)
max_perc_1RM_epley(1:10, k = 0.04)
# ------------------------------------------
# Modified Epley equation
max_perc_1RM_modified_epley(1:10)
max_perc_1RM_modified_epley(1:10, kmod = 0.05)
# ------------------------------------------
# Linear/Brzycki equation
max_perc_1RM_linear(1:10)
max_perc_1RM_linear(1:10, klin = 36)
</code></pre>

<hr>
<h2 id='max_reps'>Family of functions to estimate max number of repetition (nRM)</h2><span id='topic+max_reps'></span><span id='topic+max_reps_epley'></span><span id='topic+max_reps_modified_epley'></span><span id='topic+max_reps_linear'></span>

<h3>Description</h3>

<p>Family of functions to estimate max number of repetition (nRM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_reps_epley(perc_1RM, k = 0.0333)

max_reps_modified_epley(perc_1RM, kmod = 0.0353)

max_reps_linear(perc_1RM, klin = 33)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_reps_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>Numeric vector. % 1RM used (use 0.5 for 50 %, 0.9 for 90 %)</p>
</td></tr>
<tr><td><code id="max_reps_+3A_k">k</code></td>
<td>
<p>User defined <code>k</code> parameter in the Epley's equation. Default is 0.0333</p>
</td></tr>
<tr><td><code id="max_reps_+3A_kmod">kmod</code></td>
<td>
<p>User defined <code>kmod</code> parameter in the Modified Epley's equation. Default is 0.0353</p>
</td></tr>
<tr><td><code id="max_reps_+3A_klin">klin</code></td>
<td>
<p>User defined <code>klin</code> parameter in the Linear equation. Default is 33</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. Predicted maximal number of repetitions (nRM)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>max_reps_epley()</code>: Estimate max number of repetition (nRM) using the Epley's equation
</p>
</li>
<li> <p><code>max_reps_modified_epley()</code>: Estimate max number of repetition (nRM) using the Modified Epley's equation
</p>
</li>
<li> <p><code>max_reps_linear()</code>: Estimate max number of repetition (nRM) using the Linear/Brzycki's equation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------
# Epley equation
max_reps_epley(0.85)
max_reps_epley(c(0.75, 0.85), k = 0.04)
# ------------------------------------------
# Modified Epley equation
max_reps_modified_epley(0.85)
max_reps_modified_epley(c(0.75, 0.85), kmod = 0.05)
# ------------------------------------------
# Linear/Brzycki's equation
max_reps_linear(0.85)
max_reps_linear(c(0.75, 0.85), klin = 36)
</code></pre>

<hr>
<h2 id='plot_progression_table'>Plotting of the Progression Table</h2><span id='topic+plot_progression_table'></span>

<h3>Description</h3>

<p>Function for creating <code>ggplot2</code> plot of the Progression Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_progression_table(
  progression_table,
  plot = "%1RM",
  signif_digits = 3,
  adjustment_multiplier = 1,
  font_size = 14,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_progression_table_+3A_progression_table">progression_table</code></td>
<td>
<p>Function for creating progression table</p>
</td></tr>
<tr><td><code id="plot_progression_table_+3A_plot">plot</code></td>
<td>
<p>Character string. Options include &quot;%1RM&quot; (default) and &quot;adjustment&quot;</p>
</td></tr>
<tr><td><code id="plot_progression_table_+3A_signif_digits">signif_digits</code></td>
<td>
<p>Rounding numbers for plotting. Default is 3</p>
</td></tr>
<tr><td><code id="plot_progression_table_+3A_adjustment_multiplier">adjustment_multiplier</code></td>
<td>
<p>Factor to multiply the adjustment. Useful when converting to percentage.
Default is 1</p>
</td></tr>
<tr><td><code id="plot_progression_table_+3A_font_size">font_size</code></td>
<td>
<p>Numeric. Default is 14</p>
</td></tr>
<tr><td><code id="plot_progression_table_+3A_...">...</code></td>
<td>
<p>Forwarded to the <code><a href="#topic+generate_progression_table">generate_progression_table</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_progression_table(progression_RIR_increment, "%1RM", reps = 1:5)
plot_progression_table(progression_RIR_increment, "adjustment", reps = 1:5)

# Create progression pot by using specific reps-max table and klin value
plot_progression_table(
  progression_RIR,
  reps = 1:5,
  max_perc_1RM_func = max_perc_1RM_linear,
  klin = 36
)
</code></pre>

<hr>
<h2 id='plot_scheme'>Plotting of the Set and Reps Scheme</h2><span id='topic+plot_scheme'></span>

<h3>Description</h3>

<p>Functions for creating <code>ggplot2</code> plot of the Set and Reps Scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scheme(scheme, font_size = 8, perc_str = "%")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scheme_+3A_scheme">scheme</code></td>
<td>
<p>Data Frame create by one of the package functions. See examples</p>
</td></tr>
<tr><td><code id="plot_scheme_+3A_font_size">font_size</code></td>
<td>
<p>Numeric. Default is 8</p>
</td></tr>
<tr><td><code id="plot_scheme_+3A_perc_str">perc_str</code></td>
<td>
<p>Percent string. Default is &quot;%&quot;. Use &quot;&quot; to have more space on graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme &lt;- scheme_wave(
  reps = c(10, 8, 6, 10, 8, 6),
  # Adjusting sets to use lower %1RM (RIR Inc method used, so RIR adjusted)
  adjustment = c(4, 2, 0, 6, 4, 2),
  vertical_planning = vertical_linear,
  vertical_planning_control = list(reps_change = c(0, -2, -4)),
  progression_table = progression_RIR_increment,
  progression_table_control = list(volume = "extensive")
)

plot_scheme(scheme)
</code></pre>

<hr>
<h2 id='plot_vertical'>Plotting of the Vertical Planning</h2><span id='topic+plot_vertical'></span>

<h3>Description</h3>

<p>Function for creating <code>ggplot2</code> plot of the Vertical Planning function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vertical(vertical_plan, reps = c(5, 5, 5), font_size = 14, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_vertical_+3A_vertical_plan">vertical_plan</code></td>
<td>
<p>Vertical Plan function</p>
</td></tr>
<tr><td><code id="plot_vertical_+3A_reps">reps</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="plot_vertical_+3A_font_size">font_size</code></td>
<td>
<p>Numeric. Default is 14</p>
</td></tr>
<tr><td><code id="plot_vertical_+3A_...">...</code></td>
<td>
<p>Forwarded to <code>vertical_plan</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot_vertical(vertical_block_undulating, reps = c(8, 6, 4))
</code></pre>

<hr>
<h2 id='plot.STMr_release'>Plotting of the Release</h2><span id='topic+plot.STMr_release'></span>

<h3>Description</h3>

<p>Function for creating <code>ggplot2</code> plot of the Release <code>STMr_release</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STMr_release'
plot(x, font_size = 14, load_1RM_agg_func = max, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.STMr_release_+3A_x">x</code></td>
<td>
<p><code>STMr_release</code> object</p>
</td></tr>
<tr><td><code id="plot.STMr_release_+3A_font_size">font_size</code></td>
<td>
<p>Numeric. Default is 14</p>
</td></tr>
<tr><td><code id="plot.STMr_release_+3A_load_1rm_agg_func">load_1RM_agg_func</code></td>
<td>
<p>Function to aggregate step <code>load_1RM</code> from
multiple sets. Default is <code><a href="base.html#topic+max">max</a></code></p>
</td></tr>
<tr><td><code id="plot.STMr_release_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="ggfittext.html#topic+geom_bar_text">geom_bar_text</a></code> and
<code><a href="ggfittext.html#topic+geom_fit_text">geom_fit_text</a></code> functions. Can be used to se the highest
labels size, for example, using <code>size=5</code>. See documentation for these two
packages for more info</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme1 &lt;- scheme_step(vertical_planning = vertical_constant)
scheme2 &lt;- scheme_step(vertical_planning = vertical_linear)
scheme3 &lt;- scheme_step(vertical_planning = vertical_undulating)

release_df &lt;- release(
  scheme1, scheme2, scheme3,
  additive_1RM_adjustment = 2.5
)

plot(release_df)
</code></pre>

<hr>
<h2 id='plot.STMr_scheme'>Plotting of the Set and Reps Scheme</h2><span id='topic+plot.STMr_scheme'></span>

<h3>Description</h3>

<p>Functions for creating <code>ggplot2</code> plot of the Set and Reps Scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STMr_scheme'
plot(x, type = "bar", font_size = 14, perc_str = "%", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.STMr_scheme_+3A_x">x</code></td>
<td>
<p><code>STMr_scheme</code> object. See examples</p>
</td></tr>
<tr><td><code id="plot.STMr_scheme_+3A_type">type</code></td>
<td>
<p>Type of plot. Options are &quot;bar&quot; (default), &quot;vertical&quot;, and &quot;fraction&quot;</p>
</td></tr>
<tr><td><code id="plot.STMr_scheme_+3A_font_size">font_size</code></td>
<td>
<p>Numeric. Default is 14</p>
</td></tr>
<tr><td><code id="plot.STMr_scheme_+3A_perc_str">perc_str</code></td>
<td>
<p>Percent string. Default is &quot;%&quot;. Use &quot;&quot; to have more space on graph</p>
</td></tr>
<tr><td><code id="plot.STMr_scheme_+3A_...">...</code></td>
<td>
<p>Forwarded to <code><a href="ggfittext.html#topic+geom_bar_text">geom_bar_text</a></code> and
<code><a href="ggfittext.html#topic+geom_fit_text">geom_fit_text</a></code> functions. Can be used to se the highest
labels size, for example, using <code>size=5</code>. See documentation for these two
packages for more info</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme &lt;- scheme_wave(
  reps = c(10, 8, 6, 10, 8, 6),
  # Adjusting sets to use lower %1RM (RIR Inc method used, so RIR adjusted)
  adjustment = c(4, 2, 0, 6, 4, 2),
  vertical_planning = vertical_linear,
  vertical_planning_control = list(reps_change = c(0, -2, -4)),
  progression_table = progression_RIR_increment,
  progression_table_control = list(volume = "extensive")
)

plot(scheme)
plot(scheme, type = "vertical")
plot(scheme, type = "fraction")
</code></pre>

<hr>
<h2 id='release'>Create a Release period</h2><span id='topic+release'></span>

<h3>Description</h3>

<p>Release combines multiple schemes together with <code>prescription_1RM</code>,
<code>additive_1RM_adjustment</code>, and <code>multiplicative_1RM_adjustment</code>
parameters to calculate working <code>weight</code>, <code>load_1RM</code>, and
<code>buffer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>release(
  ...,
  prescription_1RM = 100,
  additive_1RM_adjustment = 2.5,
  multiplicative_1RM_adjustment = 1,
  rounding = 2.5,
  max_perc_1RM_func = max_perc_1RM_epley
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="release_+3A_...">...</code></td>
<td>
<p><code>STMr_scheme</code> objects create by <code>scheme_</code> functions</p>
</td></tr>
<tr><td><code id="release_+3A_prescription_1rm">prescription_1RM</code></td>
<td>
<p>Initial prescription planning 1RM to calculate weight
Default is 100</p>
</td></tr>
<tr><td><code id="release_+3A_additive_1rm_adjustment">additive_1RM_adjustment</code></td>
<td>
<p>Additive 1RM adjustment across phases. Default is 2.5</p>
</td></tr>
<tr><td><code id="release_+3A_multiplicative_1rm_adjustment">multiplicative_1RM_adjustment</code></td>
<td>
<p>multiplicative 1RM adjustment across phases.
Default is 1 (i.e., no adjustment)</p>
</td></tr>
<tr><td><code id="release_+3A_rounding">rounding</code></td>
<td>
<p>Rounding for the calculated weight. Default is 2.5</p>
</td></tr>
<tr><td><code id="release_+3A_max_perc_1rm_func">max_perc_1RM_func</code></td>
<td>
<p>Max Perc 1RM function to use when calculating
<code>load_1RM</code>. Default is <code><a href="#topic+max_perc_1RM_epley">max_perc_1RM_epley</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>STMr_relase</code> data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scheme1 &lt;- scheme_step(vertical_planning = vertical_constant)
scheme2 &lt;- scheme_step(vertical_planning = vertical_linear)
scheme3 &lt;- scheme_step(vertical_planning = vertical_undulating)

release_df &lt;- release(
  scheme1, scheme2, scheme3,
  additive_1RM_adjustment = 2.5
)

plot(release_df)
</code></pre>

<hr>
<h2 id='RTF_testing'>Reps to failure testing of 12 athletes</h2><span id='topic+RTF_testing'></span>

<h3>Description</h3>

<p>A dataset containing reps to failure testing for 12 athletes
using 70, 80, and 90% of 1RM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RTF_testing
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 rows and 6 variables:
</p>

<dl>
<dt>Athlete</dt><dd><p>Name of the athlete; ID</p>
</dd>
<dt>1RM</dt><dd><p>Maximum weight the athlete can lift correctly for a single rep</p>
</dd>
<dt>Target %1RM</dt><dd><p>%1RM we want to use for testing; 70, 80, or 90%</p>
</dd>
<dt>Target Weight</dt><dd><p>Estimated weight to be lifted</p>
</dd>
<dt>Real Weight</dt><dd><p>Weight that is estimated to be lifted, but rounded to closest 2.5</p>
</dd>
<dt>Real %1RM</dt><dd><p>Recalculated %1RM after rounding the weight</p>
</dd>
<dt>nRM</dt><dd><p>Reps-to-failure (RTF), or the number of maximum repetitions (nRM) performed</p>
</dd>
</dl>


<hr>
<h2 id='set_and_reps_schemes'>Set and Rep Schemes</h2><span id='topic+set_and_reps_schemes'></span><span id='topic+scheme_generic'></span><span id='topic+scheme_wave'></span><span id='topic+scheme_plateau'></span><span id='topic+scheme_step'></span><span id='topic+scheme_step_reverse'></span><span id='topic+scheme_wave_descending'></span><span id='topic+scheme_light_heavy'></span><span id='topic+scheme_pyramid'></span><span id='topic+scheme_pyramid_reverse'></span><span id='topic+scheme_rep_acc'></span><span id='topic+scheme_ladder'></span><span id='topic+scheme_manual'></span><span id='topic+scheme_perc_1RM'></span>

<h3>Description</h3>

<p>Set and Rep Schemes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scheme_generic(
  reps,
  adjustment,
  vertical_planning,
  vertical_planning_control = list(),
  progression_table,
  progression_table_control = list()
)

scheme_wave(
  reps = c(10, 8, 6),
  adjustment = -rev((seq_along(reps) - 1) * 5)/100,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_plateau(
  reps = c(5, 5, 5),
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_step(
  reps = c(5, 5, 5),
  adjustment = -rev((seq_along(reps) - 1) * 10)/100,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "intensive")
)

scheme_step_reverse(
  reps = c(5, 5, 5),
  adjustment = -((seq_along(reps) - 1) * 10)/100,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "intensive")
)

scheme_wave_descending(
  reps = c(6, 8, 10),
  adjustment = -rev((seq_along(reps) - 1) * 5)/100,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_light_heavy(
  reps = c(10, 5, 10, 5),
  adjustment = c(-0.1, 0)[(seq_along(reps)%%2) + 1],
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_pyramid(
  reps = c(12, 10, 8, 10, 12),
  adjustment = 0,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "extensive")
)

scheme_pyramid_reverse(
  reps = c(8, 10, 12, 10, 8),
  adjustment = 0,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "extensive")
)

scheme_rep_acc(
  reps = c(10, 10, 10),
  adjustment = 0,
  vertical_planning_control = list(step = rep(0, 4)),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_ladder(
  reps = c(3, 5, 10),
  adjustment = 0,
  vertical_planning = vertical_constant,
  vertical_planning_control = list(),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_manual(
  index = NULL,
  step,
  sets = 1,
  reps,
  adjustment = 0,
  perc_1RM = NULL,
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "normal")
)

scheme_perc_1RM(reps = c(5, 5, 5), perc_1RM = c(0.4, 0.5, 0.6), n_steps = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_and_reps_schemes_+3A_reps">reps</code></td>
<td>
<p>Numeric vector indicating reps prescription</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_adjustment">adjustment</code></td>
<td>
<p>Numeric vector indicating adjustments. Forwarded to <code>progression_table</code>.</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_vertical_planning">vertical_planning</code></td>
<td>
<p>Vertical planning function. Default is <code><a href="#topic+vertical_constant">vertical_constant</a></code></p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_vertical_planning_control">vertical_planning_control</code></td>
<td>
<p>Arguments forwarded to the <code><a href="#topic+vertical_planning">vertical_planning</a></code> function</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_progression_table">progression_table</code></td>
<td>
<p>Progression table function. Default is <code><a href="#topic+progression_perc_drop">progression_perc_drop</a></code></p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_progression_table_control">progression_table_control</code></td>
<td>
<p>Arguments forwarded to the <code><a href="#topic+progression_table">progression_table</a></code> function</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_index">index</code></td>
<td>
<p>Numeric vector. If not provided, index will be
create using sequence of <code>step</code></p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_step">step</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_sets">sets</code></td>
<td>
<p>Numeric vector. Used to replicate reps and adjustments</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_perc_1rm">perc_1RM</code></td>
<td>
<p>Numeric vector of user provided 1RM percentage</p>
</td></tr>
<tr><td><code id="set_and_reps_schemes_+3A_n_steps">n_steps</code></td>
<td>
<p>How many progression steps to generate? Default is 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following columns: <code>reps</code>, <code>index</code>, <code>step</code>,
<code>adjustment</code>, and <code>perc_1RM</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>scheme_generic()</code>: Generic set and rep scheme.
<code>scheme_generic</code> is called in all other set and rep schemes - only the default parameters
differ to make easier and quicker schemes writing and groupings
</p>
</li>
<li> <p><code>scheme_wave()</code>: Wave set and rep scheme
</p>
</li>
<li> <p><code>scheme_plateau()</code>: Plateau set and rep scheme
</p>
</li>
<li> <p><code>scheme_step()</code>: Step set and rep scheme
</p>
</li>
<li> <p><code>scheme_step_reverse()</code>: Reverse Step set and rep scheme
</p>
</li>
<li> <p><code>scheme_wave_descending()</code>: Descending Wave set and rep scheme
</p>
</li>
<li> <p><code>scheme_light_heavy()</code>: Light-Heavy set and rep scheme.
Please note that the <code>adjustment</code> column in the output
will be wrong, hence set to <code>NA</code>
</p>
</li>
<li> <p><code>scheme_pyramid()</code>: Pyramid set and rep scheme
</p>
</li>
<li> <p><code>scheme_pyramid_reverse()</code>: Reverse Pyramid set and rep scheme
</p>
</li>
<li> <p><code>scheme_rep_acc()</code>: Rep Accumulation set and rep scheme
</p>
</li>
<li> <p><code>scheme_ladder()</code>: Ladder set and rep scheme.
Please note that the <code>adjustment</code> column in the output
will be wrong, hence set to <code>NA</code>
</p>
</li>
<li> <p><code>scheme_manual()</code>: Manual set and rep scheme
</p>
</li>
<li> <p><code>scheme_perc_1RM()</code>: Manual %1RM set and rep scheme
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>scheme_generic(
  reps = c(8, 6, 4, 8, 6, 4),
  # Adjusting using lower %1RM (RIR Increment method used)
  adjustment = c(4, 2, 0, 6, 4, 2),
  vertical_planning = vertical_linear,
  vertical_planning_control = list(reps_change = c(0, -2, -4)),
  progression_table = progression_RIR_increment,
  progression_table_control = list(volume = "extensive")
)

# Wave set and rep schemes
# --------------------------
scheme_wave()

scheme_wave(
  reps = c(8, 6, 4, 8, 6, 4),
  # Second wave with higher intensity
  adjustment = c(-0.25, -0.15, 0.05, -0.2, -0.1, 0),
  vertical_planning = vertical_block,
  progression_table = progression_perc_drop,
  progression_table_control = list(type = "ballistic")
)

# Adjusted second wave
# and using 3 steps progression
scheme_wave(
  reps = c(8, 6, 4, 8, 6, 4),
  # Adjusting using lower %1RM (progression_perc_drop method used)
  adjustment = c(0, 0, 0, -0.1, -0.1, -0.1),
  vertical_planning = vertical_linear,
  vertical_planning_control = list(reps_change = c(0, -2, -4)),
  progression_table = progression_perc_drop,
  progression_table_control = list(volume = "extensive")
)

# Adjusted using RIR inc
# This time we adjust first wave as well, first two sets easier
scheme &lt;- scheme_wave(
  reps = c(8, 6, 4, 8, 6, 4),
  # Adjusting using lower %1RM (RIR Increment method used)
  adjustment = c(4, 2, 0, 6, 4, 2),
  vertical_planning = vertical_linear,
  vertical_planning_control = list(reps_change = c(0, -2, -4)),
  progression_table = progression_RIR_increment,
  progression_table_control = list(volume = "extensive")
)
plot(scheme)

# Plateau set and rep schemes
# --------------------------
scheme_plateau()

scheme &lt;- scheme_plateau(
  reps = c(3, 3, 3),
  progression_table_control = list(type = "ballistic")
)
plot(scheme)

# Step set and rep schemes
# --------------------------
scheme_step()

scheme &lt;- scheme_step(
  reps = c(2, 2, 2),
  adjustment = c(-0.1, -0.05, 0),
  vertical_planning = vertical_linear_reverse,
  progression_table_control = list(type = "ballistic")
)
plot(scheme)

# Reverse Step set and rep schemes
#- -------------------------
scheme &lt;- scheme_step_reverse()
plot(scheme)

# Descending Wave set and rep schemes
# --------------------------
scheme &lt;- scheme_wave_descending()
plot(scheme)

# Light-Heavy set and rep schemes
# --------------------------
scheme &lt;- scheme_light_heavy()
plot(scheme)

# Pyramid set and rep schemes
# --------------------------
scheme &lt;- scheme_pyramid()
plot(scheme)

# Reverse Pyramid set and rep schemes
# --------------------------
scheme &lt;- scheme_pyramid_reverse()
plot(scheme)

# Rep Accumulation set and rep schemes
# --------------------------
scheme_rep_acc()

# Generate Wave scheme with rep accumulation vertical progression
# This functions doesn't allow you to use different vertical planning
# options
scheme &lt;- scheme_rep_acc(reps = c(10, 8, 6), adjustment = c(-0.1, -0.05, 0))
plot(scheme)

# Other options is to use `.vertical_rep_accumulation.post()` and
# apply it after
# The default vertical progression is `vertical_const()`
scheme &lt;- scheme_wave(reps = c(10, 8, 6), adjustment = c(-0.1, -0.05, 0))

.vertical_rep_accumulation.post(scheme)

# We can also create "undulating" rep decrements
.vertical_rep_accumulation.post(
  scheme,
  rep_decrement = c(-3, -1, -2, 0)
)

# `scheme_rep_acc` will not allow you to generate `scheme_ladder()`
# and `scheme_scheme_light_heavy()`
# You must use `.vertical_rep_accumulation.post()` to do so
scheme &lt;- scheme_ladder()
scheme &lt;- .vertical_rep_accumulation.post(scheme)
plot(scheme)

# Please note that reps &lt; 1 are removed. If you do not want this,
# use `remove_reps = FALSE` parameter
scheme &lt;- scheme_ladder()
scheme &lt;- .vertical_rep_accumulation.post(scheme, remove_reps = FALSE)
plot(scheme)

# Ladder set and rep schemes
# --------------------------
scheme &lt;- scheme_ladder()
plot(scheme)

# Manual set and rep schemes
# --------------------------
scheme_df &lt;- data.frame(
  index = 1, # Use this just as an example
  step = c(-3, -2, -1, 0),
  # Sets are just an easy way to repeat reps and adjustment
  sets = c(5, 4, 3, 2),
  reps = c(5, 4, 3, 2),
  adjustment = 0
)

# Step index is estimated to be sequences of steps
# If you want specific indexes, use it as an argument (see next example)
scheme &lt;- scheme_manual(
  step = scheme_df$step,
  sets = scheme_df$sets,
  reps = scheme_df$reps,
  adjustment = scheme_df$adjustment
)

plot(scheme)

# Here we are going to provide our own index
scheme &lt;- scheme_manual(
  index = scheme_df$index,
  step = scheme_df$step,
  sets = scheme_df$sets,
  reps = scheme_df$reps,
  adjustment = scheme_df$adjustment
)

plot(scheme)

# More complicated example
scheme_df &lt;- data.frame(
  step = c(-3, -3, -3, -3, -2, -2, -2, -1, -1, 0),
  sets = 1,
  reps = c(5, 5, 5, 5, 3, 2, 1, 2, 1, 1),
  adjustment = c(0, -0.05, -0.1, -0.15, -0.1, -0.05, 0, -0.1, 0, 0)
)

scheme_df

scheme &lt;- scheme_manual(
  step = scheme_df$step,
  sets = scheme_df$sets,
  reps = scheme_df$reps,
  adjustment = scheme_df$adjustment,

  # Select another progression table
  progression_table = progression_DI,
  # Extra parameters for the progression table
  progression_table_control = list(
    volume = "extensive",
    type = "ballistic",
    max_perc_1RM_func = max_perc_1RM_linear,
    klin = 36
  )
)

plot(scheme)

# Provide %1RM manually

scheme_df &lt;- data.frame(
  index = rep(c(1, 2, 3, 4), each = 3),
  reps = rep(c(5, 5, 5), 4),
  perc_1RM = rep(c(0.4, 0.5, 0.6), 4)
)

warmup_scheme &lt;- scheme_manual(
  index = scheme_df$index,
  reps = scheme_df$reps,
  perc_1RM = scheme_df$perc_1RM
)

plot(warmup_scheme)
# Manual %1RM set and rep schemes
# --------------------------
warmup_scheme &lt;- scheme_perc_1RM(
  reps = c(10, 8, 6),
  perc_1RM = c(0.4, 0.5, 0.6),
  n_steps = 3
)

plot(warmup_scheme)
</code></pre>

<hr>
<h2 id='strength_training_log'>Strength Training Log</h2><span id='topic+strength_training_log'></span>

<h3>Description</h3>

<p>A dataset containing strength training log for a single athlete. Strength training program
involves doing two strength training sessions, over 12 week (4 phases of 3 weeks each).
Session A involves linear wave-loading pattern starting with 2x12/10/8 reps and reaching 2x8/6/4 reps.
Session B involves constant wave-loading pattern using 2x3/2/1. This dataset contains <code>weight</code>
being used, as well as estimated reps-in-reserve (eRIR), which represent subjective rating
of the proximity to failure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strength_training_log
</code></pre>


<h3>Format</h3>

<p>A data frame with 144 rows and 8 variables:
</p>

<dl>
<dt>phase</dt><dd><p>Phase index number. Numeric from 1 to 4</p>
</dd>
<dt>week</dt><dd><p>Week index number (within phase). Numeric from 1 to 3</p>
</dd>
<dt>day</dt><dd><p>Day (total) index number. Numeric from 1 to 3</p>
</dd>
<dt>session</dt><dd><p>Name of the session. Can be &quot;Session A&quot; or &quot;Session B&quot;</p>
</dd>
<dt>set</dt><dd><p>Set index number. Numeric from 1 to 6</p>
</dd>
<dt>weight</dt><dd><p>Weight in kg being used</p>
</dd>
<dt>reps</dt><dd><p>Number of reps being done</p>
</dd>
<dt>eRIR</dt><dd><p>Estimated reps-in-reserve</p>
</dd>
</dl>


<hr>
<h2 id='vertical_planning_functions'>Vertical Planning Functions</h2><span id='topic+vertical_planning_functions'></span><span id='topic+vertical_planning'></span><span id='topic+vertical_constant'></span><span id='topic+vertical_linear'></span><span id='topic+vertical_linear_reverse'></span><span id='topic+vertical_block'></span><span id='topic+vertical_block_variant'></span><span id='topic+vertical_rep_accumulation'></span><span id='topic+vertical_set_accumulation'></span><span id='topic+vertical_set_accumulation_reverse'></span><span id='topic+vertical_undulating'></span><span id='topic+vertical_undulating_reverse'></span><span id='topic+vertical_block_undulating'></span><span id='topic+vertical_volume_intensity'></span><span id='topic+.vertical_rep_accumulation.post'></span>

<h3>Description</h3>

<p>Functions for creating vertical planning (progressions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertical_planning(reps, reps_change = NULL, step = NULL)

vertical_constant(reps, n_steps = 4)

vertical_linear(reps, reps_change = c(0, -1, -2, -3))

vertical_linear_reverse(reps, reps_change = c(0, 1, 2, 3))

vertical_block(reps, step = c(-2, -1, 0, -3))

vertical_block_variant(reps, step = c(-2, -1, -3, 0))

vertical_rep_accumulation(
  reps,
  reps_change = c(-3, -2, -1, 0),
  step = c(0, 0, 0, 0)
)

vertical_set_accumulation(
  reps,
  step = c(-2, -2, -2, -2),
  reps_change = rep(0, length(step)),
  accumulate_set = length(reps),
  set_increment = 1,
  sequence = TRUE
)

vertical_set_accumulation_reverse(
  reps,
  step = c(-3, -2, -1, 0),
  reps_change = rep(0, length(step)),
  accumulate_set = length(reps),
  set_increment = 1,
  sequence = TRUE
)

vertical_undulating(reps, reps_change = c(0, -2, -1, -3))

vertical_undulating_reverse(reps, reps_change = c(0, 2, 1, 3))

vertical_block_undulating(
  reps,
  reps_change = c(0, -2, -1, -3),
  step = c(-2, -1, -3, 0)
)

vertical_volume_intensity(reps, reps_change = c(0, 0, -3, -3))

.vertical_rep_accumulation.post(
  scheme,
  rep_decrement = c(-3, -2, -1, 0),
  remove_reps = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertical_planning_functions_+3A_reps">reps</code></td>
<td>
<p>Numeric vector indicating reps prescription</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_reps_change">reps_change</code></td>
<td>
<p>Change in <code>reps</code> across progression steps</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_step">step</code></td>
<td>
<p>Numeric vector indicating progression steps (i.e. -3, -2, -1, 0)</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_n_steps">n_steps</code></td>
<td>
<p>Number of progression steps. Default is 4</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_accumulate_set">accumulate_set</code></td>
<td>
<p>Which set (position in <code>reps</code>) to accumulate</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_set_increment">set_increment</code></td>
<td>
<p>How many sets to increase each step? Default is 1</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_sequence">sequence</code></td>
<td>
<p>Should the sequence of accumulated sets be repeated, or
individual sets?</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_scheme">scheme</code></td>
<td>
<p>Scheme generated by <code>scheme_</code> functions</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_rep_decrement">rep_decrement</code></td>
<td>
<p>Rep decrements across progression step</p>
</td></tr>
<tr><td><code id="vertical_planning_functions_+3A_remove_reps">remove_reps</code></td>
<td>
<p>Should &lt; 1 reps be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with <code>reps</code>, <code>index</code>, and <code>step</code> columns
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>vertical_planning()</code>: Generic Vertical Planning
</p>
</li>
<li> <p><code>vertical_constant()</code>: Constants Vertical Planning
</p>
</li>
<li> <p><code>vertical_linear()</code>: Linear Vertical Planning
</p>
</li>
<li> <p><code>vertical_linear_reverse()</code>: Reverse Linear Vertical Planning
</p>
</li>
<li> <p><code>vertical_block()</code>: Block Vertical Planning
</p>
</li>
<li> <p><code>vertical_block_variant()</code>: Block Variant Vertical Planning
</p>
</li>
<li> <p><code>vertical_rep_accumulation()</code>: Rep Accumulation Vertical Planning
</p>
</li>
<li> <p><code>vertical_set_accumulation()</code>: Set Accumulation Vertical Planning
</p>
</li>
<li> <p><code>vertical_set_accumulation_reverse()</code>: Set Accumulation Reverse Vertical Planning
</p>
</li>
<li> <p><code>vertical_undulating()</code>: Undulating Vertical Planning
</p>
</li>
<li> <p><code>vertical_undulating_reverse()</code>: Undulating Vertical Planning
</p>
</li>
<li> <p><code>vertical_block_undulating()</code>: Block Undulating Vertical Planning
</p>
</li>
<li> <p><code>vertical_volume_intensity()</code>: Volume-Intensity Vertical Planning
</p>
</li>
<li> <p><code>.vertical_rep_accumulation.post()</code>: Rep Accumulation Vertical Planning POST treatment
This functions is to be applied AFTER scheme is generated. Other options is to use
<code><a href="#topic+scheme_rep_acc">scheme_rep_acc</a></code> function, that is flexible enough to generate most options,
except for the <code><a href="#topic+scheme_ladder">scheme_ladder</a></code> and <code><a href="#topic+scheme_light_heavy">scheme_light_heavy</a></code>. Please note
that the <code>adjustment</code> column in the output will be wrong, hence set to <code>NA</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Generic vertical planning function
# ----------------------------------

# Constant
vertical_planning(reps = c(3, 2, 1), step = c(-3, -2, -1, 0))

# Linear
vertical_planning(reps = c(5, 5, 5, 5, 5), reps_change = c(0, -1, -2))

# Reverse Linear
vertical_planning(reps = c(5, 5, 5, 5, 5), reps_change = c(0, 1, 2))

# Block
vertical_planning(reps = c(5, 5, 5, 5, 5), step = c(-2, -1, 0, -3))

# Block variant
vertical_planning(reps = c(5, 5, 5, 5, 5), step = c(-2, -1, -3, 0))

# Undulating
vertical_planning(reps = c(12, 10, 8), reps_change = c(0, -4, -2, -6))

# Undulating + Block variant
vertical_planning(
  reps = c(12, 10, 8),
  reps_change = c(0, -4, -2, -6),
  step = c(-2, -1, -3, 0)
)

# Rep accumulation
# If used with `scheme_generic()` (or any other `scheme_`) it will provide wrong set and rep scheme.
# Use `scheme_rep_acc()` instead, or apply `.vertical_rep_accumulation.post()`
# function AFTER generating the scheme
vertical_planning(
  reps = c(10, 8, 6),
  reps_change = c(-3, -2, -1, 0),
  step = c(0, 0, 0, 0)
)


# Constant
# ----------------------------------
vertical_constant(c(5, 5, 5), 4)
vertical_constant(c(3, 2, 1), 2)

plot_vertical(vertical_constant)

# Linear
# ----------------------------------
vertical_linear(c(10, 8, 6), c(0, -2, -4))
vertical_linear(c(5, 5, 5), c(0, -1, -2, -3))

plot_vertical(vertical_linear)

# Reverse Linear
# ----------------------------------
vertical_linear_reverse(c(6, 4, 2), c(0, 1, 2))
vertical_linear_reverse(c(5, 5, 5))

plot_vertical(vertical_linear_reverse)

# Block
# ----------------------------------
vertical_block(c(6, 4, 2))

plot_vertical(vertical_block)

# Block Variant
# ----------------------------------
vertical_block_variant(c(6, 4, 2))

plot_vertical(vertical_block_variant)

# Rep Accumulation
# ----------------------------------
# If used with `scheme_generic()` (or any other `scheme_`) it will provide wrong set and rep scheme.
# Use `scheme_rep_acc()` instead, or apply `.vertical_rep_accumulation.post()`
# function AFTER generating the scheme
vertical_rep_accumulation(c(10, 8, 6))

plot_vertical(vertical_rep_accumulation)

# Set Accumulation
# ----------------------------------
# Default is accumulation of the last set
vertical_set_accumulation(c(3, 2, 1))

# We can have whole sequence being repeated
vertical_set_accumulation(c(3, 2, 1), accumulate_set = 1:3)

# Or we can have accumulation of the individual sets
vertical_set_accumulation(c(3, 2, 1), accumulate_set = 1:3, sequence = FALSE)

# We can also have two or more sequences
vertical_set_accumulation(c(10, 8, 6, 4, 2, 1), accumulate_set = c(1:2, 5:6))

# And also repeat the individual sets
vertical_set_accumulation(
  c(10, 8, 6, 4, 2, 1),
  accumulate_set = c(1:2, 5:6),
  sequence = FALSE
)
plot_vertical(vertical_set_accumulation)

# Reverse Set Accumulation
# ----------------------------------
# Default is accumulation of the last set
vertical_set_accumulation_reverse(c(3, 2, 1))

# We can have whole sequence being repeated
vertical_set_accumulation_reverse(c(3, 2, 1), accumulate_set = 1:3)

# Or we can have accumulation of the individual sets
vertical_set_accumulation_reverse(c(3, 2, 1), accumulate_set = 1:3, sequence = FALSE)

# We can also have two or more sequences
vertical_set_accumulation_reverse(c(10, 8, 6, 4, 2, 1), accumulate_set = c(1:2, 5:6))

# And also repeat the individual sets
vertical_set_accumulation_reverse(
  c(10, 8, 6, 4, 2, 1),
  accumulate_set = c(1:2, 5:6),
  sequence = FALSE
)

plot_vertical(vertical_set_accumulation_reverse)

# Undulating
# ----------------------------------
vertical_undulating(c(8, 6, 4))

# Reverse Undulating
# ----------------------------------
vertical_undulating_reverse(c(8, 6, 4))

# Block Undulating
# ----------------------------------
# This is a combination of Block Variant (undulation in the steps) and
# Undulating (undulation in reps)
vertical_block_undulating(c(8, 6, 4))

# Volume-Intensity
# ----------------------------------
vertical_volume_intensity(c(6, 6, 6))

# Rep Accumulation
# --------------------------
scheme_rep_acc()

# Generate Wave scheme with rep accumulation vertical progression
# This functions doesn't allow you to use different vertical planning
# options
scheme &lt;- scheme_rep_acc(reps = c(10, 8, 6), adjustment = c(-0.1, -0.05, 0))
plot(scheme)

# Other options is to use `.vertical_rep_accumulation.post()` and
# apply it after
# The default vertical progression is `vertical_const()`
scheme &lt;- scheme_wave(reps = c(10, 8, 6), adjustment = c(-0.1, -0.05, 0))

.vertical_rep_accumulation.post(scheme)

# We can also create "undulating" rep decrements
.vertical_rep_accumulation.post(
  scheme,
  rep_decrement = c(-3, -1, -2, 0)
)

# `scheme_rep_acc` will not allow you to generate `scheme_ladder()`
# and `scheme_scheme_light_heavy()`
# You must use `.vertical_rep_accumulation.post()` to do so
scheme &lt;- scheme_ladder()
scheme &lt;- .vertical_rep_accumulation.post(scheme)
plot(scheme)

# Please note that reps &lt; 1 are removed. If you do not want this,
# use `remove_reps = FALSE` parameter
scheme &lt;- scheme_ladder()
scheme &lt;- .vertical_rep_accumulation.post(scheme, remove_reps = FALSE)
plot(scheme)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
