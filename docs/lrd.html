<!DOCTYPE html><html lang="en"><head><title>Help for package lrd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lrd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#answer_key_free'><p>Answer Key Example Data</p></a></li>
<li><a href='#answer_key_free2'><p>Answer Key Example Data</p></a></li>
<li><a href='#arrange_data'><p>Arrange Data for Free Recall Scoring</p></a></li>
<li><a href='#crp'><p>Conditional Response Probability</p></a></li>
<li><a href='#crp_multiple'><p>Conditional Response Probability for Multiple Lists</p></a></li>
<li><a href='#cued_data'><p>Cued Recall Data</p></a></li>
<li><a href='#cued_data_groupby'><p>Cued Recall Data with Multiple Conditions</p></a></li>
<li><a href='#cued_recall_manuscript'><p>Cued Recall Data from Manuscript</p></a></li>
<li><a href='#free_data'><p>Free Recall Data</p></a></li>
<li><a href='#kappa'><p>Cohen's Kappa</p></a></li>
<li><a href='#multi_answers'><p>Answer Key Example Data for Multiple Lists</p></a></li>
<li><a href='#multi_data'><p>Free Recall Data in Wide Format with Multiple Lists</p></a></li>
<li><a href='#pfr'><p>Probability of First Recall</p></a></li>
<li><a href='#pfr_multiple'><p>Probability of First Recall for Multiple Lists</p></a></li>
<li><a href='#prop_correct_cued'><p>Proportion Correct Cued Recall</p></a></li>
<li><a href='#prop_correct_free'><p>Proportion Correct Free Recall</p></a></li>
<li><a href='#prop_correct_multiple'><p>Proportion Correct Free Recall for Multiple Lists</p></a></li>
<li><a href='#prop_correct_sentence'><p>Proportion Correct for Sentences</p></a></li>
<li><a href='#rater_data'><p>Rater Data</p></a></li>
<li><a href='#sentence_data'><p>Sentence Recall Data</p></a></li>
<li><a href='#serial_position'><p>Serial Position Calculator</p></a></li>
<li><a href='#serial_position_multiple'><p>Serial Position Calculator for Multiple Lists</p></a></li>
<li><a href='#wide_data'><p>Free Recall Data in Wide Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Package for Processing Lexical Response Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Lexical response data is a package that 
    can be used for processing cued-recall, free-recall, 
    and sentence responses from memory experiments.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, rmarkdown, reshape</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://npm27.github.io/lrd/">https://npm27.github.io/lrd/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-06 21:49:29 UTC; nickm</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Maxwell <a href="https://orcid.org/0000-0003-4517-8323"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Erin M. Buchanan <a href="https://orcid.org/0000-0002-9689-4189"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Maxwell &lt;nicholas.maxwell@usm.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-09 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='answer_key_free'>Answer Key Example Data</h2><span id='topic+answer_key_free'></span>

<h3>Description</h3>

<p>Dataset that includes the answer key for free recall data.
Pair with the wide_data dataset for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(answer_key_free)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test
</p>
<p>Answer_Key: a list of free recall answers
</p>

<hr>
<h2 id='answer_key_free2'>Answer Key Example Data</h2><span id='topic+answer_key_free2'></span>

<h3>Description</h3>

<p>Dataset that includes the answer key for free recall data.
Pair with the free_data dataset for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(answer_key_free2)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test
</p>
<p>Answer_Key: a list of free recall answers
</p>

<hr>
<h2 id='arrange_data'>Arrange Data for Free Recall Scoring</h2><span id='topic+arrange_data'></span>

<h3>Description</h3>

<p>This function takes wide format free recall data where all
responses are stored in the same cell and converts it to long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_data(data, responses, sep, id, repeated = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_data_+3A_data">data</code></td>
<td>
<p>a dataframe of the variables you would like to return.
Other variables will be included in the returned output in long format
if they represent a one to one match with the participant ID. If you
have repeated data, please use the repeated argument or run this
function several times for each trial.</p>
</td></tr>
<tr><td><code id="arrange_data_+3A_responses">responses</code></td>
<td>
<p>a column name in the dataframe that contains
the participant answers for each item in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="arrange_data_+3A_sep">sep</code></td>
<td>
<p>a character separating each response in quotes - example: &quot;,&quot;.</p>
</td></tr>
<tr><td><code id="arrange_data_+3A_id">id</code></td>
<td>
<p>a column name containing participant ID numbers from
the original dataframe</p>
</td></tr>
<tr><td><code id="arrange_data_+3A_repeated">repeated</code></td>
<td>
<p>(optional) a single column name or set of columns
that indicate repeated measures columns you would like to
keep with the data. You should include all columns that are not a one
to one match with the subject ID (i.e., participants saw multiple
trials). Please see our vignette for an example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of the participant answers including:
</p>
<table role = "presentation">
<tr><td><code>Sub.ID</code></td>
<td>
<p>The participant id number</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>The participant response</p>
</td></tr>
<tr><td><code>position</code></td>
<td>
<p>The position number of the response listed</p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>Any additional columns included</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#This dataset includes a subject number, set of answers, and
#experiment condition.

data(wide_data)

DF_long &lt;- arrange_data(
 data = wide_data,
 responses = "Response",
 sep = ",",
 id = "Sub.ID")

head(DF_long)

</code></pre>

<hr>
<h2 id='crp'>Conditional Response Probability</h2><span id='topic+crp'></span>

<h3>Description</h3>

<p>This function calculates the conditional response
probability of each lag position. Participants' lag
between subsequent named items is tallied and then
divided by the possible combination of subsequent lags
given their response pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crp(data, position, answer, id, key, scored)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crp_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_free() for best formatting.</p>
</td></tr>
<tr><td><code id="crp_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="crp_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="crp_+3A_id">id</code></td>
<td>
<p>a column name of the participant id in the original
dataframe.</p>
</td></tr>
<tr><td><code id="crp_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="crp_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a CRP visualizations,
and an example can be found in our manuscript/vignettes.
</p>
<p>Important: The code is written assuming the data provided are for
a single recall list. If repeated measures are used (i.e., there are
multiple lists completed by each participant or multiple list versions),
you should use this function several times, once on each list/answer key.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_CRP</code></td>
<td>
<p>A dataframe of the proportion correct for each
conditional lag position including any other between subjects
variables present in the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(free_data)
data(answer_key_free2)

free_data &lt;- subset(free_data,
 List_Type == "Cat_Recall_L1")

DF_long &lt;- arrange_data(data = free_data,
 responses = "Response",
 sep = " ",
 id = "Username")

scored_output &lt;- prop_correct_free( data = DF_long,
 responses = "response",
 key = answer_key_free2$Answer_Key,
 id = "Sub.ID",
 cutoff = 1,
 flag = TRUE,
 group.by = "Version")

crp_output &lt;- crp(data = scored_output$DF_Scored,
 position = "position",
 answer = "Answer",
 id = "Sub.ID",
 key = answer_key_free2$Answer_Key,
 scored = "Scored")

 head(crp_output)

</code></pre>

<hr>
<h2 id='crp_multiple'>Conditional Response Probability for Multiple Lists</h2><span id='topic+crp_multiple'></span>

<h3>Description</h3>

<p>This function calculates the conditional response
probability of each lag position. Participants' lag
between subsequent named items is tallied and then
divided by the possible combination of subsequent lags
given their response pattern. This function was designed
to handle multiple or randomized lists across participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crp_multiple(data, position, answer, id, key, key.trial, id.trial, scored)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crp_multiple_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_free() for best formatting.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_id">id</code></td>
<td>
<p>a column name of the participant id in the original
dataframe.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe. Note that
the free response &quot;key&quot; trial and this trial number should match.
The trial key will be repeated for each answer a participant gave.</p>
</td></tr>
<tr><td><code id="crp_multiple_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a CRP visualizations,
and an example can be found in our manuscript/vignettes.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_CRP</code></td>
<td>
<p>A dataframe of the proportion correct for each
conditional lag position including any other between subjects
variables present in the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("multi_data")
data("multi_answers")

DF_long &lt;- arrange_data(data = multi_data,
                       responses = "Response",
                       sep = " ",
                       id = "Sub.ID",
                       repeated = "List.Number")

library(reshape)
multi_answers$position &lt;- 1:nrow(multi_answers)
answer_long &lt;- melt(multi_answers,
                    measured = colnames(multi_answers),
                    id = "position")
colnames(answer_long) &lt;- c("position", "List.ID", "Answer")

answer_long$List.ID &lt;- gsub(pattern = "List",
                            replacement = "",
                            x = answer_long$List.ID)

DF_long$response &lt;- tolower(DF_long$response)
answer_long$Answer &lt;- tolower(answer_long$Answer)
answer_long$Answer &lt;- gsub(" ", "", answer_long$Answer)

scored_output &lt;- prop_correct_multiple(data = DF_long,
                                    responses = "response",
                                    key = answer_long$Answer,
                                    key.trial = answer_long$List.ID,
                                    id = "Sub.ID",
                                    id.trial = "List.Number",
                                    cutoff = 1,
                                    flag = TRUE)

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)


crp_output &lt;- crp_multiple(data = scored_output$DF_Scored,
                          key = answer_long$Answer,
                          position = "position",
                          scored = "Scored",
                          answer = "Answer",
                          id = "Sub.ID",
                          key.trial = answer_long$List.ID,
                          id.trial = "List.Number")

 head(crp_output)

</code></pre>

<hr>
<h2 id='cued_data'>Cued Recall Data</h2><span id='topic+cued_data'></span>

<h3>Description</h3>

<p>Dataset that includes cued recall data in long format.
Participants were given a cue, and they were required to
remember the response listed in the dataset. This dataset
is in long format, which is required for most functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cued_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a cued recall test data
</p>
<p>id: the participant id
trial: the trial id
response: the response the participant gave to the cue
key: the answer for this trial id
condition: the between subjects group the participants were in
</p>

<hr>
<h2 id='cued_data_groupby'>Cued Recall Data with Multiple Conditions</h2><span id='topic+cued_data_groupby'></span>

<h3>Description</h3>

<p>Dataset that includes cued recall data in long format.
Participants were given a cue, and they were required to
remember the response listed in the dataset. This dataset
is in long format, which is required for most functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cued_data_groupby)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a cued recall test data
</p>
<p>Subject: the participant id
Target: the answer for this trial id
Response: the response the participant gave to the cue
Condition: the between subjects group the participants
were in
Condition2: the second between subjects group the
participants were in
</p>

<hr>
<h2 id='cued_recall_manuscript'>Cued Recall Data from Manuscript</h2><span id='topic+cued_recall_manuscript'></span>

<h3>Description</h3>

<p>Dataset that includes cued recall data in long format.
Participants were given a cue, and they were required to
remember the response listed in the dataset. This dataset
is in long format, which is required for most functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cued_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a cued recall test data
</p>
<p>Sub.ID: the participant id
Trial_num: the trial id
Cue: the cue shown to participants
Target: the answer for this trial id
Answer: the participant answer for this trial
</p>

<hr>
<h2 id='free_data'>Free Recall Data</h2><span id='topic+free_data'></span>

<h3>Description</h3>

<p>Dataset that includes free recall data in long format.
Participants were given a list of words to remember, and
then asked to recall the words. This dataset
is in wide format, which should be converted with arrange
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(free_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test data
</p>
<p>Username: the participant id
List_Types: a repeated measures condition participants were in
Response: the response the participant gave to the cue
Version: the version of the list_type given
Batch: the batch of participants that were run together
</p>

<hr>
<h2 id='kappa'>Cohen's Kappa</h2><span id='topic+kappa'></span>

<h3>Description</h3>

<p>This function returns Cohen's Kappa k for two raters. Kappa indicates
the inter-rater reliability for categorical items. High scores (closer
to one) indicate agreement between raters, while low scores (closer
to zero) indicate low agreement between raters. Negative numbers indicate
they don't agree at all!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa(rater1, rater2, confidence = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa_+3A_rater1">rater1</code></td>
<td>
<p>Rater 1 scores or categorical listings</p>
</td></tr>
<tr><td><code id="kappa_+3A_rater2">rater2</code></td>
<td>
<p>Rater 2 scores or categorical listings</p>
</td></tr>
<tr><td><code id="kappa_+3A_confidence">confidence</code></td>
<td>
<p>Confidence interval proportion for the kappa interval
estimate. You must supply a value between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: All missing values will be ignored. This function calculates kappa
for 0 and 1 scoring. If you pass categorical variables, the
function will return a percent match score between these values.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p_agree</code></td>
<td>
<p>Percent agreement between raters</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Cohen's kappa for yes/no matching</p>
</td></tr>
<tr><td><code>se_kappa</code></td>
<td>
<p>Standard error for kappa wherein standard error
is the square root of: (agree \* (1-agree)) / (N \* (1 - random
agreement)^2)</p>
</td></tr>
<tr><td><code>kappa_LL</code></td>
<td>
<p>Lower limit for the confidence interval of kappa</p>
</td></tr>
<tr><td><code>kappa_UL</code></td>
<td>
<p>Upper limit for the confidence interval of kappa</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#This dataset includes two raters who wrote the word listed by
#the participant and rated if the word was correct in the recall
#experiment.

data(rater_data)

#Consider normalizing the text if raters used different styles
#Calculate percent match for categorical answers
kappa(rater_data$rater1_word, rater_data$rater2_word)

kappa(rater_data$rater1_score, rater_data$rater2_score)

</code></pre>

<hr>
<h2 id='multi_answers'>Answer Key Example Data for Multiple Lists</h2><span id='topic+multi_answers'></span>

<h3>Description</h3>

<p>Dataset that includes the answer key for free recall data.
Pair with the multi_data dataset for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multi_answers)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test
</p>
<p>List1: a list of free recall answers
List2: a second list of free recall answers
etc.
</p>

<hr>
<h2 id='multi_data'>Free Recall Data in Wide Format with Multiple Lists</h2><span id='topic+multi_data'></span>

<h3>Description</h3>

<p>Dataset that includes free recall data in long format.
Participants were given a list of words to remember, and
then asked to recall the words. This dataset
is in wide format, which should be converted with arrange
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multi_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test data
</p>
<p>Sub.ID: the participant id
List.Type: the type of list a person saw
Response: the response the participant gave to the cue
List.Number: the number of the list they completed
</p>

<hr>
<h2 id='pfr'>Probability of First Recall</h2><span id='topic+pfr'></span>

<h3>Description</h3>

<p>This function calculates the probability of first recall
for each serial position. The total number of times an
item was recalled first is divided by the total number of
first recalls (i.e., the number of participants who wrote
anything down!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfr(data, position, answer, id, key, scored, group.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pfr_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_free() for best formatting.</p>
</td></tr>
<tr><td><code id="pfr_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="pfr_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="pfr_+3A_id">id</code></td>
<td>
<p>a column name of the participant id in the original
dataframe.</p>
</td></tr>
<tr><td><code id="pfr_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="pfr_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
<tr><td><code id="pfr_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a PFR visualizations,
and an example can be found in our manuscript/vignettes.
</p>
<p>Important: The code is written assuming the data provided are for
a single recall list. If repeated measures are used (i.e., there are
multiple lists completed by each participant or multiple list versions),
you should use this function several times, once on each list/answer key.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_PFR</code></td>
<td>
<p>A dataframe of the probability of first response
for each position including group by variables if indicated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(free_data)
data(answer_key_free2)

free_data &lt;- subset(free_data,
 List_Type == "Cat_Recall_L1")

DF_long &lt;- arrange_data(data = free_data,
 responses = "Response",
 sep = " ",
 id = "Username")

scored_output &lt;- prop_correct_free(data = DF_long,
 responses = "response",
 key = answer_key_free2$Answer_Key,
 id = "Sub.ID",
 cutoff = 1,
 flag = TRUE,
 group.by = "Version")

pfr_output &lt;- pfr(data = scored_output$DF_Scored,
 position = "position",
 answer = "Answer",
 id = "Sub.ID",
 key = answer_key_free2$Answer_Key,
 scored = "Scored",
 group.by = "Version")

 head(pfr_output)

</code></pre>

<hr>
<h2 id='pfr_multiple'>Probability of First Recall for Multiple Lists</h2><span id='topic+pfr_multiple'></span>

<h3>Description</h3>

<p>This function calculates the probability of first recall
for each serial position. The total number of times an
item was recalled first is divided by the total number of
first recalls (i.e., the number of participants who wrote
anything down!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfr_multiple(
  data,
  position,
  answer,
  id,
  key,
  key.trial,
  id.trial,
  scored,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pfr_multiple_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_free() for best formatting.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_id">id</code></td>
<td>
<p>a column name of the participant id in the original
dataframe.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe. Note that
the free response &quot;key&quot; trial and this trial number should match.
The trial key will be repeated for each answer a participant gave.</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
<tr><td><code id="pfr_multiple_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a PFR visualizations,
and an example can be found in our manuscript/vignettes.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_PFR</code></td>
<td>
<p>A dataframe of the probability of first response
for each position including group by variables if indicated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("multi_data")
data("multi_answers")

DF_long &lt;- arrange_data(data = multi_data,
                       responses = "Response",
                       sep = " ",
                       id = "Sub.ID",
                       repeated = "List.Number")

library(reshape)
multi_answers$position &lt;- 1:nrow(multi_answers)
answer_long &lt;- melt(multi_answers,
                    measured = colnames(multi_answers),
                    id = "position")
colnames(answer_long) &lt;- c("position", "List.ID", "Answer")

answer_long$List.ID &lt;- gsub(pattern = "List",
                            replacement = "",
                            x = answer_long$List.ID)

DF_long$response &lt;- tolower(DF_long$response)
answer_long$Answer &lt;- tolower(answer_long$Answer)
answer_long$Answer &lt;- gsub(" ", "", answer_long$Answer)

scored_output &lt;- prop_correct_multiple(data = DF_long,
                                    responses = "response",
                                    key = answer_long$Answer,
                                    key.trial = answer_long$List.ID,
                                    id = "Sub.ID",
                                    id.trial = "List.Number",
                                    cutoff = 1,
                                    flag = TRUE)

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)

head(scored_output$DF_Group)

pfr_output &lt;- pfr_multiple(data = scored_output$DF_Scored,
                          key = answer_long$Answer,
                          position = "position",
                          scored = "Scored",
                          answer = "Answer",
                          id = "Sub.ID",
                          key.trial = answer_long$List.ID,
                          id.trial = "List.Number")

 head(pfr_output)

</code></pre>

<hr>
<h2 id='prop_correct_cued'>Proportion Correct Cued Recall</h2><span id='topic+prop_correct_cued'></span>

<h3>Description</h3>

<p>This function computes the proportion of correct responses
per participant. Proportions can either be separated by
condition or collapsed across conditions. You will need to ensure
each trial is marked with a unique id to correspond to the answer
key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_correct_cued(
  data,
  responses,
  key,
  key.trial,
  id,
  id.trial,
  cutoff = 0,
  flag = FALSE,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_correct_cued_+3A_data">data</code></td>
<td>
<p>a dataframe of the variables you would like to return.
Other variables will be included in the scored output and
in the participant output if they are a one to one match with
the participant id.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_responses">responses</code></td>
<td>
<p>a column name in the dataframe that contains
the participant answers for each item in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_id">id</code></td>
<td>
<p>a column name containing participant ID numbers from
the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value that determines the criteria for
scoring (i.e., 0 = strictest, 5 = is most lenient). The scoring
criteria uses a Levenshtein distance measure to match participant
responses to the answer key.</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_flag">flag</code></td>
<td>
<p>a logical argument if you want to flag participant scores
that are outliers using z-scores away from the mean score for group</p>
</td></tr>
<tr><td><code id="prop_correct_cued_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: other columns included in the dataframe will be found
in the final scored dataset. If these other columns are
between subjects data, they will also be included in the
participant dataset (i.e., there's a one to one match of
participant ID and column information).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Scored</code></td>
<td>
<p>The dataframe of the original response, answer,
scoring, and any other or grouping variables. This dataframe can
be used to determine if the cutoff score and scoring matched your
answer key as intended. Distance measures are not perfect! Issues
and suggestions for improvement are welcome.</p>
</td></tr>
<tr><td><code>DF_Participant</code></td>
<td>
<p>A dataframe of the proportion correct by
participant, which also includes optional z-scoring, grouping, and
other variables.</p>
</td></tr>
<tr><td><code>DF_Group</code></td>
<td>
<p>A dataframe of the summary scores by any optional
grouping variables, along with overall total proportion correct
scoring.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#This data contains cued recall test with responses and answers together.
#You can use a separate answer key, but this example will show you an
#embedded answer key. This example also shows how you can use different
#stimuli across participants (i.e., each person sees a randomly selected
#set of trials from a larger set).

data(cued_data)

scored_output &lt;- prop_correct_cued(data = cued_data,
 responses = "response",
 key = "key",
 key.trial = "trial",
 id = "id",
 id.trial = "trial",
 cutoff = 1,
 flag = TRUE,
 group.by = "condition")

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)

head(scored_output$DF_Group)

</code></pre>

<hr>
<h2 id='prop_correct_free'>Proportion Correct Free Recall</h2><span id='topic+prop_correct_free'></span>

<h3>Description</h3>

<p>This function computes the proportion of correct responses
per participant. Proportions can either be separated by
condition or collapsed across conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_correct_free(
  data,
  responses,
  key,
  id,
  cutoff = 0,
  flag = FALSE,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_correct_free_+3A_data">data</code></td>
<td>
<p>a dataframe of the variables you would like to return.
Other variables will be included in the scored output and
in the participant output if they are a one to one match with
the participant id.</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_responses">responses</code></td>
<td>
<p>a column name in the dataframe that contains
the participant answers for each item in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_id">id</code></td>
<td>
<p>a column name containing participant ID numbers from
the original dataframe</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value that determines the criteria for
scoring (i.e., 0 = strictest, 5 = is most lenient). The scoring
criteria uses a Levenshtein distance measure to match participant
responses to the answer key.</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_flag">flag</code></td>
<td>
<p>a logical argument if you want to flag participant scores
that are outliers using z-scores away from the mean score for group</p>
</td></tr>
<tr><td><code id="prop_correct_free_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: other columns included in the dataframe will be found
in the final scored dataset. If these other columns are
between subjects data, they will also be included in the
participant dataset (i.e., there's a one to one match of
participant ID and column information).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Scored</code></td>
<td>
<p>The dataframe of the original response, answer,
scoring, and any other or grouping variables. This dataframe can
be used to determine if the cutoff score and scoring matched your
answer key as intended. Distance measures are not perfect! Issues
and suggestions for improvement are welcome.</p>
</td></tr>
<tr><td><code>DF_Participant</code></td>
<td>
<p>A dataframe of the proportion correct by
participant, which also includes optional z-scoring, grouping, and
other variables.</p>
</td></tr>
<tr><td><code>DF_Group</code></td>
<td>
<p>A dataframe of the summary scores by any optional
grouping variables, along with overall total proportion correct
scoring.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wide_data)
data(answer_key_free)

DF_long &lt;- arrange_data(data = wide_data,
 responses = "Response",
 sep = ",",
 id = "Sub.ID")

scored_output &lt;- prop_correct_free(data = DF_long,
 responses = "response",
 key = answer_key_free$Answer_Key,
 id = "Sub.ID",
 cutoff = 1,
 flag = TRUE,
 group.by = "Disease.Condition")

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)

head(scored_output$DF_Group)

</code></pre>

<hr>
<h2 id='prop_correct_multiple'>Proportion Correct Free Recall for Multiple Lists</h2><span id='topic+prop_correct_multiple'></span>

<h3>Description</h3>

<p>This function computes the proportion of correct responses
per participant. Proportions can either be separated by
condition or collapsed across conditions. This function
extends prop_correct_free() to include multiple or randomized
lists for participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_correct_multiple(
  data,
  responses,
  key,
  key.trial,
  id,
  id.trial,
  cutoff = 0,
  flag = FALSE,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_correct_multiple_+3A_data">data</code></td>
<td>
<p>a dataframe of the variables you would like to return.
Other variables will be included in the scored output and
in the participant output if they are a one to one match with
the participant id.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_responses">responses</code></td>
<td>
<p>a column name in the dataframe that contains
the participant answers for each item in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_id">id</code></td>
<td>
<p>a column name containing participant ID numbers from
the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe. Note that
the free response &quot;key&quot; trial and this trial number should match.
The trial key will be repeated for each answer a participant gave.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value that determines the criteria for
scoring (i.e., 0 = strictest, 5 = is most lenient). The scoring
criteria uses a Levenshtein distance measure to match participant
responses to the answer key.</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_flag">flag</code></td>
<td>
<p>a logical argument if you want to flag participant scores
that are outliers using z-scores away from the mean score for group</p>
</td></tr>
<tr><td><code id="prop_correct_multiple_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: other columns included in the dataframe will be found
in the final scored dataset. If these other columns are
between subjects data, they will also be included in the
participant dataset (i.e., there's a one to one match of
participant ID and column information).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Scored</code></td>
<td>
<p>The dataframe of the original response, answer,
scoring, and any other or grouping variables. This dataframe can
be used to determine if the cutoff score and scoring matched your
answer key as intended. Distance measures are not perfect! Issues
and suggestions for improvement are welcome.</p>
</td></tr>
<tr><td><code>DF_Participant</code></td>
<td>
<p>A dataframe of the proportion correct by
participant, which also includes optional z-scoring, grouping, and
other variables.</p>
</td></tr>
<tr><td><code>DF_Group</code></td>
<td>
<p>A dataframe of the summary scores by any optional
grouping variables, along with overall total proportion correct
scoring.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("multi_data")
data("multi_answers")

DF_long &lt;- arrange_data(data = multi_data,
                       responses = "Response",
                       sep = " ",
                       id = "Sub.ID",
                       repeated = "List.Number")

library(reshape)
multi_answers$position &lt;- 1:nrow(multi_answers)
answer_long &lt;- melt(multi_answers,
                    measured = colnames(multi_answers),
                    id = "position")
colnames(answer_long) &lt;- c("position", "List.ID", "Answer")

answer_long$List.ID &lt;- gsub(pattern = "List",
                            replacement = "",
                            x = answer_long$List.ID)

DF_long$response &lt;- tolower(DF_long$response)
answer_long$Answer &lt;- tolower(answer_long$Answer)
answer_long$Answer &lt;- gsub(" ", "", answer_long$Answer)

scored_output &lt;- prop_correct_multiple(data = DF_long,
                                    responses = "response",
                                    key = answer_long$Answer,
                                    key.trial = answer_long$List.ID,
                                    id = "Sub.ID",
                                    id.trial = "List.Number",
                                    cutoff = 1,
                                    flag = TRUE)

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)


</code></pre>

<hr>
<h2 id='prop_correct_sentence'>Proportion Correct for Sentences</h2><span id='topic+prop_correct_sentence'></span>

<h3>Description</h3>

<p>This function computes the proportion of correct sentence responses
per participant. Proportions can either be separated by
condition or collapsed across conditions. You will need to ensure
each trial is marked with a unique id to correspond to the answer
key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_correct_sentence(
  data,
  responses,
  key,
  key.trial,
  id,
  id.trial,
  cutoff = 0,
  flag = FALSE,
  group.by = NULL,
  token.split = " "
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_correct_sentence_+3A_data">data</code></td>
<td>
<p>a dataframe of the variables you would like to return.
Other variables will be included in the scored output and
in the participant output if they are a one to one match with
the participant id.</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_responses">responses</code></td>
<td>
<p>a column name in the dataframe that contains
the participant answers for each item in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_id">id</code></td>
<td>
<p>a column name containing participant ID numbers from
the original dataframe</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_cutoff">cutoff</code></td>
<td>
<p>a numeric value that determines the criteria for
scoring (i.e., 0 = strictest, 5 = is most lenient). The scoring
criteria uses a Levenshtein distance measure to match participant
responses to the answer key.</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_flag">flag</code></td>
<td>
<p>a logical argument if you want to flag participant scores
that are outliers using z-scores away from the mean score for group</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
<tr><td><code id="prop_correct_sentence_+3A_token.split">token.split</code></td>
<td>
<p>an optional argument that can be used to delineate
how to separate tokens. The default is a space after punctuation and
additional spacing is removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: other columns included in the dataframe will be found
in the final scored dataset. If these other columns are
between subjects data, they will also be included in the
participant dataset (i.e., there's a one to one match of
participant ID and column information).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Scored</code></td>
<td>
<p>The dataframe of the original response, answer,
scoring, and any other or grouping variables. This dataframe can
be used to determine if the cutoff score and scoring matched your
answer key as intended. Distance measures are not perfect! Issues
and suggestions for improvement are welcome.</p>
</td></tr>
<tr><td><code>DF_Participant</code></td>
<td>
<p>A dataframe of the proportion correct by
participant, which also includes optional z-scoring, grouping, and
other variables.</p>
</td></tr>
<tr><td><code>DF_Group</code></td>
<td>
<p>A dataframe of the summary scores by any optional
grouping variables, along with overall total proportion correct
scoring.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#This data contains sentence recall test with responses and answers together.
#You can use a separate answer key, but this example will show you an
#embedded answer key. This example also shows how you can use different
#stimuli across participants (i.e., each person sees a randomly selected
#set of trials from a larger set).

data(sentence_data)

scored_output &lt;- prop_correct_sentence(data = sentence_data,
 responses = "Response",
 key = "Sentence",
 key.trial = "Trial.ID",
 id = "Sub.ID",
 id.trial = "Trial.ID",
 cutoff = 1,
 flag = TRUE,
 group.by = "Condition",
 token.split = " ")

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)

head(scored_output$DF_Group)

</code></pre>

<hr>
<h2 id='rater_data'>Rater Data</h2><span id='topic+rater_data'></span>

<h3>Description</h3>

<p>Dataset that contains scoring and ratings for a recall test
that was rated by two raters. Use with the kappa function
as an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rater_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of scored answers for inter-rater reliability
</p>
<p>Sub.ID: the participant id
rater1_word: the word choice for the subject the rater selected
rater1_score: the score for the participant given by the rater
rater2_word: the word choice for the subject the rater selected
rater2_score: the score for the participant given by the rater
</p>

<hr>
<h2 id='sentence_data'>Sentence Recall Data</h2><span id='topic+sentence_data'></span>

<h3>Description</h3>

<p>Dataset that includes sentence recall data in long format.
Participants were given a sentence to remember, and
then asked to recall the words. This dataset
is in long format, which is required for these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sentence_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a sentence recall test data
</p>
<p>Sub.ID: the participant id
Trial.ID: the id for the trial given to participant
Sentence: the answer to the trial that the participant
should have given
Response: the response the participant gave to that trial
Condition: the between subjects condition the participant
was in
</p>

<hr>
<h2 id='serial_position'>Serial Position Calculator</h2><span id='topic+serial_position'></span>

<h3>Description</h3>

<p>This function calculates the proportion correct of each item in the
serial position curve. Data should include the participant's answers
in long format (use arrange_data() in this package for help), the answer
key of the items in order, and a column that denotes the order a
participant listed each item. The function will then calculate
the items remembered within a window of 1 before or 1 after the
tested position. The first and last positions must be answered in the
correct place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial_position(data, position, answer, key, scored, group.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serial_position_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_free() for best formatting.</p>
</td></tr>
<tr><td><code id="serial_position_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="serial_position_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="serial_position_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="serial_position_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
<tr><td><code id="serial_position_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a serial position curve visualizations,
and an example can be found in our manuscript/vignettes.
</p>
<p>Important: The code is written assuming group.by variables are
between subjects for an individual recall list.
If repeated measures are used (i.e., there are
multiple lists completed by each participant or multiple list versions),
you should use this function several times, once on each list/answer key.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Serial</code></td>
<td>
<p>A dataframe of the proportion correct for each
tested position by any optional grouping variables included.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(free_data)
data(answer_key_free2)

free_data &lt;- subset(free_data,
 List_Type == "Cat_Recall_L1")

DF_long &lt;- arrange_data(data = free_data,
 responses = "Response",
 sep = " ",
 id = "Username")

scored_output &lt;- prop_correct_free(data = DF_long,
 responses = "response",
 key = answer_key_free2$Answer_Key,
 id = "Sub.ID",
 cutoff = 1,
 flag = TRUE,
 group.by = "Version")

serial_output &lt;- serial_position(data = scored_output$DF_Scored,
 key = answer_key_free2$Answer_Key,
 position = "position",
 scored = "Scored",
 answer = "Answer",
 group.by = "Version")

 head(serial_output)

</code></pre>

<hr>
<h2 id='serial_position_multiple'>Serial Position Calculator for Multiple Lists</h2><span id='topic+serial_position_multiple'></span>

<h3>Description</h3>

<p>This function calculates the proportion correct of each item in the
serial position curve. Data should include the participant's answers
in long format (use arrange_data() in this package for help), the answer
key of the items in order, and a column that denotes the order a
participant listed each item. The function will then calculate
the items remembered within a window of 1 before or 1 after the
tested position. The first and last positions must be answered in the
correct place. Specifically, this function is an extension of
serial_position() for free recall when there are multiple lists
or randomized lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial_position_multiple(
  data,
  position,
  answer,
  key,
  key.trial,
  id.trial,
  scored,
  group.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serial_position_multiple_+3A_data">data</code></td>
<td>
<p>a dataframe of the scored free recall that you would
like to calculate - use prop_correct_multiple() for best formatting.</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_position">position</code></td>
<td>
<p>a column name in the dataframe that contains
answered position of each response in quotes (i.e., &quot;column&quot;)</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_answer">answer</code></td>
<td>
<p>a column name of the answer given for that position
in the original dataframe.</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_key">key</code></td>
<td>
<p>a vector containing the scoring key or data column name.
This column does not have to be included in the original dataframe.
We assume your answer key is in the tested position order. You should
not include duplicates in your answer key.</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_key.trial">key.trial</code></td>
<td>
<p>a vector containing the trial numbers for each answer.
Note: If you input long data (i.e., repeating trial-answer responses),
we will take the unique combination of the responses. If a trial number
is repeated, you will receive an error. Key and key.trial can also be
a separate dataframe, depending on how your output data is formatted.</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_id.trial">id.trial</code></td>
<td>
<p>a column name containing the trial numbers
for the participant data from the original dataframe. Note that
the free response &quot;key&quot; trial and this trial number should match.
The trial key will be repeated for each answer a participant gave.</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_scored">scored</code></td>
<td>
<p>a column in the original dataframe indicating if the
participant got the answer correct (1) or incorrect (0).</p>
</td></tr>
<tr><td><code id="serial_position_multiple_+3A_group.by">group.by</code></td>
<td>
<p>an optional argument that can be used to group the
output by condition columns. These columns should be in the original
dataframe and concatenated c() if there are multiple columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This output can then be used to create a serial position curve visualizations,
and an example can be found in our manuscript/vignettes.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DF_Serial</code></td>
<td>
<p>A dataframe of the proportion correct for each
tested position by any optional grouping variables included.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("multi_data")
data("multi_answers")

DF_long &lt;- arrange_data(data = multi_data,
                       responses = "Response",
                       sep = " ",
                       id = "Sub.ID",
                       repeated = "List.Number")

library(reshape)
multi_answers$position &lt;- 1:nrow(multi_answers)
answer_long &lt;- melt(multi_answers,
                    measured = colnames(multi_answers),
                    id = "position")
colnames(answer_long) &lt;- c("position", "List.ID", "Answer")

answer_long$List.ID &lt;- gsub(pattern = "List",
                            replacement = "",
                            x = answer_long$List.ID)

DF_long$response &lt;- tolower(DF_long$response)
answer_long$Answer &lt;- tolower(answer_long$Answer)
answer_long$Answer &lt;- gsub(" ", "", answer_long$Answer)

scored_output &lt;- prop_correct_multiple(data = DF_long,
                                    responses = "response",
                                    key = answer_long$Answer,
                                    key.trial = answer_long$List.ID,
                                    id = "Sub.ID",
                                    id.trial = "List.Number",
                                    cutoff = 1,
                                    flag = TRUE)

head(scored_output$DF_Scored)

head(scored_output$DF_Participant)


serial_output &lt;- serial_position_multiple(data = scored_output$DF_Scored,
                                         position = "position",
                                         answer = "Answer",
                                         key = answer_long$Answer,
                                         key.trial = answer_long$List.ID,
                                         scored = "Scored",
                                         id.trial = "List.Number")

 head(serial_output)

</code></pre>

<hr>
<h2 id='wide_data'>Free Recall Data in Wide Format</h2><span id='topic+wide_data'></span>

<h3>Description</h3>

<p>Dataset that includes free recall data in long format.
Participants were given a list of words to remember, and
then asked to recall the words. This dataset
is in wide format, which should be converted with arrange
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wide_data)
</code></pre>


<h3>Format</h3>

<p>A data frame of answers for a free recall test data
</p>
<p>Sub.ID: the participant id
Response: the response the participant gave to the cue
Disease.Condition: healthy or sick participant condition
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
