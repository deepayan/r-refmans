<!DOCTYPE html><html lang="en"><head><title>Help for package QTLRel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QTLRel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aicVC'>
<p>AIC Model Selection</p></a></li>
<li><a href='#blup'>
<p>Best Linear Unbiased Prediction</p></a></li>
<li><a href='#cic'>
<p>Calculate Jacquard condensed identity coefficients</p></a></li>
<li><a href='#eigen.sym'>
<p>Spectral decomposition of a matrix</p></a></li>
<li><a href='#estVC'>
<p>Estimate Variance Component Parameters</p></a></li>
<li><a href='#genMatrix'>
<p>Derive genetic matrices</p></a></li>
<li><a href='#genoImpute'>
<p>Impute Genotypic Data</p></a></li>
<li><a href='#genoProb'>
<p>Probability of a Genotype.</p></a></li>
<li><a href='#genoSim'>
<p>Generate Genotypic Data</p></a></li>
<li><a href='#gls'>
<p>Generalized Least Squares Estimates</p></a></li>
<li><a href='#hapSim'>
<p>Generate Genotypic Data</p></a></li>
<li><a href='#ibs'>
<p>Estimate Jacquard condensed identity coefficients</p></a></li>
<li><a href='#kinship'>
<p>Calculate kinship coefficients</p></a></li>
<li><a href='#lodci'>
<p>Estimate LOD Support Intervals</p></a></li>
<li><a href='#mAIC'>
<p>Multiple QTL AIC</p></a></li>
<li><a href='#miscEx'>
<p>Genotype data, phenotype data, genetic map and pedigree.</p></a></li>
<li><a href='#misFct'>
<p>A collection of other functions.</p></a></li>
<li><a href='#nullSim'>
<p>Simulate null distribution</p></a></li>
<li><a href='#pedRecode'>
<p>Recode a Pedigree</p></a></li>
<li><a href='#plotit'>
<p>Plotting</p></a></li>
<li><a href='#qqPlot'>
<p>Quantile-Quantile Plots</p></a></li>
<li><a href='#qtl2rel'><p>Convert data from R/qtl to QTLRel format</p></a></li>
<li><a href='#qtlVar'>
<p>QTL Variance</p></a></li>
<li><a href='#rel2qtl'><p>Convert data from QTLRel to R/qtl format</p></a></li>
<li><a href='#rem'>
<p>Random effect matrices</p></a></li>
<li><a href='#scanOne'>
<p>Genome Scan for QTL</p></a></li>
<li><a href='#scanTwo'>
<p>Genome Scan for Epistasis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Mapping of Quantitative Traits of Genetically Related
Individuals and Calculating Identity Coefficients from
Pedigrees</td>
</tr>
<tr>
<td>Author:</td>
<td>Riyan Cheng [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Riyan Cheng &lt;riyancheng@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This software provides tools for quantitative trait mapping in populations such as advanced intercross lines where relatedness among individuals should not be ignored. It can estimate background genetic variance components, impute missing genotypes, simulate genotypes, perform a genome scan for putative quantitative trait loci (QTL), and plot mapping results. It also has functions to calculate identity coefficients from pedigrees, especially suitable for pedigrees that consist of a large number of generations, or estimate identity coefficients from genotypic data in certain circumstances.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gdata, graphics, grDevices, lattice, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>qtl</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 19:19:27 UTC; rcheng</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aicVC'>
AIC Model Selection
</h2><span id='topic+aicVC'></span>

<h3>Description</h3>

<p>Select genetic variance components via Akaike's information criterion (AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicVC(y, x, v = list(E=diag(length(y))), initpar, k = 2, init = 1, keep = 1,
   direction = c("forward", "backward"), nit = 25, msg = FALSE,
   control = list(), hessian = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aicVC_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column (representing a phenotype for instance).
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_v">v</code></td>
<td>

<p>A list of variance components of interest. Note: <code>E</code> is reserved for residual (or environmental) variance and can be missed in <code>v</code>; it is considered to be an identify matrix if it is specified.
</p>
<p><code>v</code> can be provided as a single matrix.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_initpar">initpar</code></td>
<td>

<p>Optional initial parameter values.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_k">k</code></td>
<td>

<p>Penalty on a parameter. The selection criterion is the known &quot;AIC&quot; if <code>k = 2</code> and is &quot;BIC&quot; if <code>k = log(n)</code> where &quot;n&quot; is the sample size.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_init">init</code></td>
<td>

<p>Indicates which variance components for the initial model. By default, <code>E</code> is included if it is missing in <code>v</code>.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_keep">keep</code></td>
<td>

<p>Indicator of which variance components should be forced into the final model. By default, <code>E</code> is kept in the final model if it is not specified in <code>v</code>.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_direction">direction</code></td>
<td>

<p>The mode of search. Either &quot;forward&quot; or &quot;backward&quot; with default &quot;forward&quot;.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_nit">nit</code></td>
<td>

<p>Maximum number of iterations for optimization. Ignored if there are not more than two variance components.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_msg">msg</code></td>
<td>

<p>A logical variable. True if one wants to track the process for monitoring purpose.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_control">control</code></td>
<td>

<p>A list of control parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="aicVC_+3A_hessian">hessian</code></td>
<td>

<p>Logical. Should a numerically differentiated Hessian matrix be returned?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In genome-wide association studies (GWAS), random effects are usually added to a model to account for polygenic variation. Abney et al (2000) showed that five variance components including the most interesting additive and dominance variance components are potentially induced by polygenes. The above function is intended for selecting variance components that contribute &quot;most&quot; to a quantitative trait.
</p>
<p>Function <code><a href="#topic+estVC">estVC</a></code> is called by the above function to estimate the parameters and maximum likelihood in each model. Refer to <code><a href="#topic+estVC">estVC</a></code> for more information.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>aic</code></td>
<td>
<p>AIC of the final model.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Gives parameter estimates, log-likihood, and other information.</p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>Log-likelihood of the model selected at each intermediate step.</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>Indicates which variance components were selected at each intermediate step.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+estVC">estVC</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# forward selection
# any variance component will be selected
# if AIC improve by 1e-5 or larger
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

o&lt;- aicVC(y=pheno$bwt, x=pheno$sex, k=0, v=v, msg=TRUE)
o

# forward selection
of&lt;- aicVC(y=pheno$bwt, x=pheno$sex, v=v, k=1/2,
	direction="for", msg=TRUE)
of

# backward elimination
ob&lt;- aicVC(y=pheno$bwt, x=pheno$sex, v=v, k=1/2, init=1:2,
	direction="back", msg=TRUE)
ob

## End(Not run)
</code></pre>

<hr>
<h2 id='blup'>
Best Linear Unbiased Prediction
</h2><span id='topic+blup'></span>

<h3>Description</h3>

<p>Estimate the best linear unbiased prediction (BLUP) for various effects in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blup(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blup_+3A_object">object</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fixed</code></td>
<td>
<p>BLUP for fixed effects.</p>
</td></tr>
<tr><td><code>R</code>, <code>etc.</code></td>
<td>
<p>BLUP for random effects.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+estVC">estVC</a></code> and <code><a href="#topic+aicVC">aicVC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# only consider additive genetic variance component
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii],D=gmF8$DD[ii,ii])
vc&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)
b&lt;- blup(vc)

## End(Not run)
</code></pre>

<hr>
<h2 id='cic'>
Calculate Jacquard condensed identity coefficients
</h2><span id='topic+cic'></span>

<h3>Description</h3>

<p>Calculate Jacquard condensed identity coefficients from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cic(ped, ids, inter, df=3, ask = FALSE, msg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cic_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which is a data frame (id, father/sire, mother/dam, ...). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ... If &quot;sex&quot; is included, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If a founder is inbred, its ID should be tagged by character 'i' (e.g. 1i, 2i, etc.). Note: 0 is reserved for unknown <code>father</code>, <code>mother</code> or <code>sex</code>.
</p>
</td></tr>
<tr><td><code id="cic_+3A_ids">ids</code></td>
<td>

<p>IDs of the individuals for which to calculate the Jacquard condensed identity coefficients. If missing, all individuals in the pedigree <code>ped</code> will be considered.
</p>
</td></tr>
<tr><td><code id="cic_+3A_inter">inter</code></td>
<td>

<p>Intermediate generations, if given, where coefficients are calculated bottom-up.
</p>
</td></tr>
<tr><td><code id="cic_+3A_df">df</code></td>
<td>

<p>If <code>inter</code> is missing, <code>df</code> is used to derive (optimal) <code>inter</code>. If <code>df = 0</code>, then there will no intermediate generations. If <code>df</code> is large (and free disk space is sufficient), then all generations will be used as intermediate generations.
</p>
</td></tr>
<tr><td><code id="cic_+3A_ask">ask</code></td>
<td>

<p>If true, users will be asked whether to proceed.
</p>
</td></tr>
<tr><td><code id="cic_+3A_msg">msg</code></td>
<td>

<p>If true, will print out some messages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients will be calculated for individuals with IDs specified by <code>ids</code>. All individuals will be considered if <code>ids</code> is missing. This is not recommended if the total number of individuals in the pedigree is large. Instead, it is recommended that <code>ids</code> is specified for interested individuals only
</p>
<p><code>df</code> is a tuning parameter. It should not be 0 (or smaller than 1) if the pedigree is large in depth (many generations) but the number of individuals is not small; otherwise, it can take forever to finish. It should not be <code>Inf</code> (or a large number) if the number of individuals in certain intermediate generation is very large.
</p>
<p>Any individual without parent information is regarded as diallelic with two independent alleles. Users can add to their pedigree (e.g. 50 generations of selfing) if founders are inbred.
</p>


<h3>Value</h3>

<p>A matrix G with G[,j] being the j-th Jacquard identity coefficients.
</p>


<h3>Note</h3>

<p>You may need the administrative privilege to run this function on systems such as Windows 7. It may require your operating system support &quot;long long&quot; integer type in C++. If you run this function in a windows system, make sure the working directory is under system volume C and you have the write privilege.
</p>
<p>It is better to remove the working directory if the program is interrupted by external forces (e.g. killed by users).
</p>
<p>Warning: you may need to run this program on a 64-bit machine in case of seeing such a message!
</p>


<h3>References</h3>

<p>Abney, M., M. S. McPeek, and C. Ober (2000). Estimation of variance components of quantitative traits in inbred populations. Am. J. Hum. Genet. 141, 629-650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedRecode">pedRecode</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

ids&lt;- sample(pedF8$id[300:500],20)

## Not run: 
# run 'cic' for the sampled individuals
# top-down
oo&lt;- cic(pedF8, ids=ids, df=Inf, msg=TRUE)
# bottom-up
o1&lt;- cic(pedF8, ids=ids, df=0, msg=TRUE)
# hybrid of top-down and bottom-up
o2&lt;- cic(pedF8, ids=ids, ask=TRUE, msg=TRUE)
# same results
c(sum(abs(oo-o1) &gt;1e-7),sum(abs(o2-o1) &gt;1e-7))

## End(Not run)
</code></pre>

<hr>
<h2 id='eigen.sym'>
Spectral decomposition of a matrix
</h2><span id='topic+eigen.sym'></span>

<h3>Description</h3>

<p>Computes eigenvalues and eigenvectors of real symmetric matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen.sym(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen.sym_+3A_x">x</code></td>
<td>

<p>A real symmetric matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is to use the LAPACK routine 'DSYEVR' to perform spectral decomposition.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>a vector containing the eigenvalues of <code>x</code>, sorted in decreasing order.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>a matrix whose columns contain the eigenvectors of <code>x</code>, corresponding to eigenvalues.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Warning: symmetry is not checked by the program!
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code> for more information.
</p>

<hr>
<h2 id='estVC'>
Estimate Variance Component Parameters
</h2><span id='topic+estVC'></span>

<h3>Description</h3>

<p>Estimate model parameters for covariates, genetic variance components and residual effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estVC(y, x, v = list(E=diag(length(y))), initpar, nit = 25,
   method = c("ML", "REML"), control = list(), hessian = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estVC_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column (representing a phenotype for instance).
</p>
</td></tr>
<tr><td><code id="estVC_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="estVC_+3A_v">v</code></td>
<td>

<p>A list of matrices representing variance components of interest. Note: <code>E</code> is reserved for residual (or environmental) variance and can be missed in <code>v</code>; it is considered to be an identify matrix if it is missing.
</p>
<p><code>v</code> can be provided as a single matrix, representing a variance component other than <code>E</code>.
</p>
</td></tr>
<tr><td><code id="estVC_+3A_initpar">initpar</code></td>
<td>

<p>Optional initial parameter values. When provided, <code><a href="stats.html#topic+optim">optim</a></code> will be called for optimization, which may take time but is good for checking of the result (see details for more).
</p>
</td></tr>
<tr><td><code id="estVC_+3A_nit">nit</code></td>
<td>

<p>Maximum number of iterations for optimization. Ignored if there are not more than two variance components.
</p>
</td></tr>
<tr><td><code id="estVC_+3A_method">method</code></td>
<td>

<p>Either maximum likelihood (ML) or restricted maximum likelihood (REML).
</p>
</td></tr>
<tr><td><code id="estVC_+3A_control">control</code></td>
<td>

<p>A list of control parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="estVC_+3A_hessian">hessian</code></td>
<td>

<p>Logical. Should a numerically differentiated Hessian matrix be returned?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimization function <code><a href="stats.html#topic+optim">optim</a></code> is adopted in the above function to estimate the parameters and maximum likelihood. Several optimization methods are available for the optimization algorithm in <code><a href="stats.html#topic+optim">optim</a></code>, but we recommend &quot;Nelder-Mead&quot; for the sake of stability. Alternatively, one may choose other options, e.g., &quot;BFGS&quot; to initialize and speed up the estimation procedure and then the procedure will automatically turn to &quot;Nelder-Mead&quot; for final results. If there is only one variance component (other than <code>E</code>), <code><a href="stats.html#topic+optimize">optimize</a></code> will be used for optimization unless <code>initpar</code> is provided.
</p>
<p>Normality is assumed for the random effects. Input data should be free of missing values.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>estimates of the model parameters.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>log-likelihood of the model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>associated with x used.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>variance component matrices v used.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>other information.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Hessian matrix, if requested, pertains to -log-likelihood function.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="#topic+rem">rem</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# no sex effect
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

o&lt;- estVC(y=pheno$bwt, v=v)
o

# sex as fixed effect
fo&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)
fo
2*(fo$value-o$value) # log-likelihood test statistic

# sex as random effect
SM&lt;- rem(~sex, data=pheno)
ro&lt;- estVC(y=pheno$bwt, v=c(v,list(Sex=SM$sex)))
ro
2*(ro$value-o$value) # log-likelihood test statistic

## End(Not run)
</code></pre>

<hr>
<h2 id='genMatrix'>
Derive genetic matrices
</h2><span id='topic+genMatrix'></span>

<h3>Description</h3>

<p>Derive genetic matrices from Jacquard condensed identity coefficients or genotypic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genMatrix_+3A_x">x</code></td>
<td>

<p>An object of <code><a href="#topic+cic">cic</a></code> or <code><a href="#topic+ibs">ibs</a></code>, or genotypic data in a matrix or a data frame with each row representing an individual and each column a marker locus and entry being &quot;AA&quot;, &quot;AB&quot;, &quot;BB&quot; (or 1, 2, 3) without missing genotypes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>AA</code></td>
<td>
<p>Additive genetic matrix.</p>
</td></tr>
<tr><td><code>DD</code></td>
<td>
<p>Dominance genetic matrix.</p>
</td></tr>
<tr><td><code>AD</code>, <code>HH</code>, <code>MH</code></td>
<td>
<p>Other three genetic matrices (see Abney et. al. 2000).</p>
</td></tr>
<tr><td><code>ib</code></td>
<td>
<p>Inbreeding coefficients.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abney, M., M. S. McPeek, and C. Ober (2000). Estimation of variance components of quantitative traits in inbred populations. Am. J. Hum. Genet. 141, 629-650.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cic">cic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

ids&lt;- sample(pedF8$id[300:500],20)

## Not run: 
# get condensed identity coefficients
oo&lt;- cic(pedF8, ids=ids, df=0)
ksp&lt;- kinship(pedF8, ids=ids) # kinship coefficients only
# extract genetic matrices
gm&lt;- genMatrix(oo)
sum((gm$AA-2*ksp)&gt;1e-7) # same results

## End(Not run)
</code></pre>

<hr>
<h2 id='genoImpute'>
Impute Genotypic Data
</h2><span id='topic+genoImpute'></span>

<h3>Description</h3>

<p>Impute missing genotypic data in advance intercross lines (AIL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoImpute(gdat, gmap, step, prd = NULL, gr = 2, pos = NULL,
   method = c("Haldane", "Kosambi"), na.str = "NA", msg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genoImpute_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data. Should be a matrix or a data frame, with each row representing an observation and each column a marker locus. The column names should be marker names. Genotypes can be 1, 2 and 3, or &quot;AA&quot;, &quot;AB&quot; and &quot;BB&quot;. Optional if an object <code>prd</code> from <code><a href="#topic+genoProb">genoProb</a></code> is used as an argument.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_gmap">gmap</code></td>
<td>

<p>A genetic map. Should be data frame (snp, chr, dist,...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_step">step</code></td>
<td>

<p>Optional. If specified, it is the maximum distance (in cM) between two adjacent loci for which the probabilities are calculated. The distance corresponds to the &quot;cumulative&quot; recombination rate at <code>gr</code>-th generation. If missing, only
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_prd">prd</code></td>
<td>

<p>An object from <code><a href="#topic+genoProb">genoProb</a></code> if not <code>NULL</code>. See &quot;details&quot; for more information.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_gr">gr</code></td>
<td>

<p>The generation under consideration.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_pos">pos</code></td>
<td>

<p>Data frame (chr, dist, snp, ...). If given, <code>step</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_method">method</code></td>
<td>

<p>Whether &quot;Haldane&quot; or &quot;Kosambi&quot; mapping function should be used.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_na.str">na.str</code></td>
<td>

<p>String for missing values.
</p>
</td></tr>
<tr><td><code id="genoImpute_+3A_msg">msg</code></td>
<td>

<p>A logical variable. If TRUE, certain information will be printed out during calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The missing genotypic value is randomly assigned with a probability conditional on the genotypes of the flanking SNPs (makers). 
</p>
<p>An object, <code>prd</code>, from <code><a href="#topic+genoProb">genoProb</a></code> alone can be used for the purpose of imputation. Then, the output (especially the putative loci) will be determined by <code>prd</code>. Optionally, it can be used together with <code>gdat</code> so that missing values in <code>gdat</code> will be imputed if possible, depending on whether loci in the columns of <code>gdat</code> can be identified in the third dimension of <code>prd</code>; this won't change the original genotypic data. See examples.
</p>


<h3>Value</h3>

<p>A matrix with the number of rows being the same as <code>gdat</code> and with the number of columns depending on the SNP set in both <code>gdat</code> and <code>gmap</code> and the <code>step</code> length.
</p>


<h3>Note</h3>

<p>Currently only suitable for advanced intercross lines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genoProb">genoProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

# briefly look at genotype data
sum(is.na(gdatF8))
gdatF8[1:5,1:5]

## Not run: 
# run 'genoProb'
gdtmp&lt;- gdatF8
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8, gr=8, method="Haldane", msg=TRUE)

# imputation based on 'genoProb' object
tmp&lt;- genoImpute(prd=prDat)
sum(is.na(tmp))
tmp[1:5,1:5]

# imputation based on both genotype data and 'genoProb' object
tmp&lt;- genoImpute(gdatF8, prd=prDat)
sum(is.na(tmp))
tmp[1:5,1:5]

# imputation based on genotype data
tmp&lt;- genoImpute(gdatF8, gmap=gmapF8, gr=8, na.str=NA)
sum(is.na(tmp))
tmp[1:5, 1:5]
# set "msg=TRUE" for more information
tmp&lt;- genoImpute(gdatF8, gmap=gmapF8, gr=8, na.str=NA, msg=TRUE)
sum(is.na(tmp))
tmp[1:5, 1:5]

## End(Not run)
</code></pre>

<hr>
<h2 id='genoProb'>
Probability of a Genotype.
</h2><span id='topic+genoProb'></span>

<h3>Description</h3>

<p>Calculate the probability of a genotype at a locus conditional on the genotypes of its flanking markers in advance intercross lines (AIL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoProb(gdat, gmap, step, gr = 2, pos = NULL, method=c("Haldane", "Kosambi"),
   msg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genoProb_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data. Should be a matrix or a data frame, with each row representing an observation and each column a marker locus. The column names should be marker names. Each entry should be 1, 2, 3 or 0, corresponding to &quot;AA&quot;, &quot;AB&quot;, &quot;BB&quot; or missing genotype.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_gmap">gmap</code></td>
<td>

<p>A genetic map. Should be data frame (snp, chr, dist,...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_step">step</code></td>
<td>

<p>Optional. If specified, it is the maximum &quot;cumulative&quot; genetic distance (in cM) between two adjacent loci for which the probabilities are calculated. The genetic distance corresponds to the &quot;cumulative&quot; recombination rate at <code>gr</code>-th generation.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_gr">gr</code></td>
<td>

<p>The generation under consideration.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_pos">pos</code></td>
<td>

<p>Data frame (chr, dist, snp, ...). If given, <code>step</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_method">method</code></td>
<td>

<p>Whether &quot;Haldane&quot; or &quot;Kosambi&quot; mapping function should be used.
</p>
</td></tr>
<tr><td><code id="genoProb_+3A_msg">msg</code></td>
<td>

<p>A logical variable. If TRUE, certain information will be printed out during calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;cumulative&quot; genetic distance between any two adjacent loci for which probabilities are calculated is not larger than <code>step</code>. If <code>step</code> is missing or <code>step = Inf</code>, probabilities will only be calculated at loci in both the columns of <code>gdat</code> and the rows of <code>gmap</code>. If <code>step</code> is small, a large set of putative loci will be considered, including all loci defined by the columns of <code>gdat</code> and the rows of <code>gmap</code>. 
</p>


<h3>Value</h3>

<p>Probabilities for genotypes as well as genetic map information (snp,chr,dist)
</p>
<table role = "presentation">
<tr><td><code>pr</code></td>
<td>
<p>A 3-D array with the first dimension corresponding to that of <code>gdat</code>, the second to three genotype and the third to the putative loci. The probabilities will be -1 if not imputable, which happens when the genotype data is missing at all loci on the chromosome.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently only suitable for advanced intercross lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# briefly look at genotype data
sum(is.na(gdatF8))
gdatF8[1:5,1:5]

gdtmp&lt;- gdatF8
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
# In case an individual is not imputable, then
# one needs to assign genotypes manually
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8, gr=8, method="Haldane", msg=TRUE)
prDat$pr[1:5,,1:5]

## End(Not run)
</code></pre>

<hr>
<h2 id='genoSim'>
Generate Genotypic Data
</h2><span id='topic+genoSim'></span>

<h3>Description</h3>

<p>Simulate genotypic data from a pedigree in advanced intercross lines (AIL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoSim(ped, gmap, ids, hap, method = c("Haldane", "Kosambi"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genoSim_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which is a data frame (id, sex, father/sire, mother/dam, ...). In &quot;sex&quot;, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ..., which should be in an increasing order. Note that 0 is reserved for missing values. If a father/mother is an inbred founder, its ID should be tagged by character 'i' (e.g. 1i, 2i, etc.). See <code><a href="#topic+pedRecode">pedRecode</a></code>.
</p>
</td></tr>
<tr><td><code id="genoSim_+3A_gmap">gmap</code></td>
<td>

<p>A genetic map. Should be data frame (snp, chr, dist, ...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome. If <code>gmap</code> is missing but <code>hap</code> not, all but the first two columns of <code>hap</code> are ignored. 
</p>
</td></tr>
<tr><td><code id="genoSim_+3A_ids">ids</code></td>
<td>

<p>Genotypic data are extracted only for individuals with IDs specified by <code>ids</code>. If missing, genotypic data are extracted for all individuals in the pedigree. If <code>ped</code> is an object of <code><a href="#topic+pedRecode">pedRecode</a></code>, <code>ids</code> should be referred to &quot;old&quot; IDs.
</p>
</td></tr>
<tr><td><code id="genoSim_+3A_hap">hap</code></td>
<td>

<p>Founders' haplotype data if not missing. Rows correspond to founders as specified by row names, and columns correspond to loci in the genetic map <code>gmap</code> in the exact order. For an individual, the haplotype should be (f1 m1 f2 m2 ...) where fi is the allele from father at the i-th locus and mi is the allele from mother at the i-th locus. Elements should be non-negative integers that are not larger than 16384. If <code>hap</code> is not supplied, founders are assumed to be inbred.
</p>
</td></tr>
<tr><td><code id="genoSim_+3A_method">method</code></td>
<td>

<p>Whether &quot;Haldane&quot; or &quot;Kosambi&quot; mapping function should be used. This will be ignored if the recombination rate <code>recRate</code> is a component of <code>gmap</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pedigree should be in the same format as an output of <code><a href="#topic+pedRecode">pedRecode</a></code>. Sex chromosome should be marked
by 'x' or 'X'. Founders mean those whose parents have 0 or negative IDs after the pedigree is recoded by
<code><a href="#topic+pedRecode">pedRecode</a></code>. In addition, it is assumed that there are not more than two founders; otherwise,
you may run <code><a href="#topic+hapSim">hapSim</a></code> and then extract genotypes manually.
</p>


<h3>Value</h3>

<p>A matrix, with entry value s-1 where s is the summation of the numbers representing two alleles at a locus. For instance, 1, 2, and 3 representing genotypes &quot;AA&quot;, &quot;AB&quot; and &quot;BB&quot; respectively if <code>hap</code> is not specified. Each row represent an observation, and each column corresponds to SNP in <code>gmap</code>.
</p>


<h3>Note</h3>

<p>Sex may be used as a covariate if significance on x-chromosome is assessed by gene dropping through this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedRecode">pedRecode</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# simulate genotypes for F8 individuals
ids&lt;- sapply(pedF8$id[pedF8$gen == "F8" &amp; pedF8$sire != "32089"], as.character)
gdt&lt;- genoSim(pedF8, gmapF8, ids=ids)
dim(gdt)
gdt[1:5,1:5]

## End(Not run)
</code></pre>

<hr>
<h2 id='gls'>
Generalized Least Squares Estimates
</h2><span id='topic+gls'></span>

<h3>Description</h3>

<p>Obtain estimates using generalized least squares (gls).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gls(formula, data, vc = NULL, test=c("none","F"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gls_+3A_formula">formula</code></td>
<td>

<p>An object of class &quot;formula&quot;: a symbolic description of the model to be fitted.
</p>
</td></tr>
<tr><td><code id="gls_+3A_data">data</code></td>
<td>

<p>An data frame containing the variables in the model.
</p>
</td></tr>
<tr><td><code id="gls_+3A_vc">vc</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code> or an estimated variance-covariance matrix induced by relatedness and environment if not NULL.
</p>
</td></tr>
<tr><td><code id="gls_+3A_test">test</code></td>
<td>

<p>Wheter F-test is performed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns: &quot;Estimate&quot;, &quot;Std. Error&quot;, &quot;t value&quot; and &quot;Pr(&gt;|t|)&quot;, or an ANOVA table if F-test is requested.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>.
</p>

<hr>
<h2 id='hapSim'>
Generate Genotypic Data
</h2><span id='topic+hapSim'></span>

<h3>Description</h3>

<p>Simulate gametic data from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hapSim(ped, gmap, ids, hap, method = c("Haldane", "Kosambi"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hapSim_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which is a data frame (id, sex, father/sire, mother/dam, ...). In &quot;sex&quot;, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ..., which should be in an increasing order. Note that 0 is reserved for missing values. If a father/mother is an inbred founder, its ID should be tagged by character 'i' (e.g. 1i, 2i, etc.). See <code><a href="#topic+pedRecode">pedRecode</a></code>.
</p>
</td></tr>
<tr><td><code id="hapSim_+3A_gmap">gmap</code></td>
<td>

<p>A genetic map. Should be data frame (snp, chr, dist, ...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome. If <code>gmap</code> is missing but <code>hap</code> not, all but the first two columns of <code>hap</code> are ignored.
</p>
</td></tr>
<tr><td><code id="hapSim_+3A_ids">ids</code></td>
<td>

<p>Genotypic data are extracted only for individuals with IDs specified by <code>ids</code>. If missing, genotypic data are extracted for all individuals in the pedigree. If <code>ped</code> is an object of <code><a href="#topic+pedRecode">pedRecode</a></code>, <code>ids</code> should be referred to &quot;old&quot; IDs.
</p>
</td></tr>
<tr><td><code id="hapSim_+3A_hap">hap</code></td>
<td>

<p>Founders' haplotype data if not missing. Rows correspond to founders as specified by row names, and columns correspond to loci in the genetic map <code>gmap</code> in the exact order. For an individual, the haplotype should be (f1 m1 f2 m2 ...) where fi is the allele from father at the i-th locus and mi is the allele from mother at the i-th locus. Elements should be non-negative integers that are not larger than 16384. If <code>hap</code> is not supplied, founders are assumed to be inbred.
</p>
</td></tr>
<tr><td><code id="hapSim_+3A_method">method</code></td>
<td>

<p>Whether &quot;Haldane&quot; or &quot;Kosambi&quot; mapping function should be used. This will be ignored if the recombination rate <code>recRate</code> is a component of <code>gmap</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pedigree should be in the same format as an output of <code><a href="#topic+pedRecode">pedRecode</a></code>. Founders mean those whose parents
have 0 or negative IDs after the pedigree is recoded by <code><a href="#topic+pedRecode">pedRecode</a></code>.
</p>


<h3>Value</h3>

<p>A matrix giving haplotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedRecode">pedRecode</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# prepare pedigree in desired format
pedR&lt;- pedRecode(pedF8)
pedR[1:5,] # check to find out three founders
# fake founder haplotypes
hapDat&lt;- rbind(rep(1:2,nrow(gmapF8)),rep(3:4,nrow(gmapF8)),rep(5:6,nrow(gmapF8)))
rownames(hapDat)&lt;- c("32089","1","2")
# simulate hyplotypes for F8 individuals
hd&lt;- hapSim(pedF8, gmapF8, ids=pedF8$id[pedF8$gen=="F8"], hap=hapDat)
dim(hd)
hd[1:5,1:10]

## End(Not run)
</code></pre>

<hr>
<h2 id='ibs'>
Estimate Jacquard condensed identity coefficients
</h2><span id='topic+ibs'></span>

<h3>Description</h3>

<p>Estimate Jacquard condensed identity coefficients by identity-by-state (IBS) from genotypic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ibs_+3A_x">x</code></td>
<td>

<p>Genotype data with genotypes (&quot;AA&quot;, &quot;AB&quot;, &quot;BB&quot;, or, 1, 2, 3) and without missing data, or probabilities for these genotypes (e.g., obtained by using <code><a href="#topic+genoProb">genoProb</a></code>). In case of genotype data, rows represent individuals and columns represent SNPs.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix G with G[,j] being the j-th Jacquard identity coefficients.
</p>


<h3>Note</h3>

<p>Currently only support the two-allele data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMatrix">genMatrix</a></code>
</p>

<hr>
<h2 id='kinship'>
Calculate kinship coefficients
</h2><span id='topic+kinship'></span>

<h3>Description</h3>

<p>Calculate kinship coefficients from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship(ped, ids, all = TRUE, msg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinship_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which a data frame (id, sire, dam, ...). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ... If &quot;sex&quot; is included, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If a founder is inbred, its ID should be tagged by character 'i' (e.g. 1i, 2i, etc.). Note that 0 is reserved for missing values.
</p>
</td></tr>
<tr><td><code id="kinship_+3A_ids">ids</code></td>
<td>

<p>IDs of the individuals. If given, kinship coefficients are extracted for individuals with ID <code>ids</code>; otherwise, kinship coefficients are provided for all individuals in the pedigree.
</p>
</td></tr>
<tr><td><code id="kinship_+3A_all">all</code></td>
<td>

<p>If false, sires and dams with no parents are treated as unknown.
</p>
</td></tr>
<tr><td><code id="kinship_+3A_msg">msg</code></td>
<td>

<p>If false, messages are suppressed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix giving kinship coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

ids&lt;- sample(pedF8$id,10)
## Not run: 
ksp&lt;- kinship(pedF8,ids=ids)

## End(Not run)
</code></pre>

<hr>
<h2 id='lodci'>
Estimate LOD Support Intervals
</h2><span id='topic+lodci'></span>

<h3>Description</h3>

<p>Estimate LOD support intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lodci(llk, cv = 0, lod = 1.5, drop = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lodci_+3A_llk">llk</code></td>
<td>

<p>A data frame with components (chr, dist, y, ...), where &quot;chr&quot; is the chromosome on which the scanning locus is located, &quot;dist&quot; is the genetic or physical position of the scanning locus, and &quot;y&quot; is the test statistic.
</p>
</td></tr>
<tr><td><code id="lodci_+3A_cv">cv</code></td>
<td>

<p>Threshold. Reported support intervals cover at least one scanning locus where <code>llk$y &gt; cv</code>.
</p>
</td></tr>
<tr><td><code id="lodci_+3A_lod">lod</code></td>
<td>

<p>LOD (specified by <code>lod</code>, which is 1.5 by default) support intervals to be reported when <code>llk$y</code> is converted to LOD score.
</p>
</td></tr>
<tr><td><code id="lodci_+3A_drop">drop</code></td>
<td>

<p>3 by default. See &quot;details&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of multiple peaks on a chromosome, a peak has to satisfy: a) above the threshold <code>cv</code>; b) drops, e.g., 3 LOD on both sides except chromosome ends. So if two peaks close to each other but LOD between them doesn't drop, e.g., 3 LOD, only one of them is considered.
</p>


<h3>Value</h3>

<p>A data frame with the following components:
</p>
<table role = "presentation">
<tr><td><code>chr</code></td>
<td>
<p>The chromosome</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>The lower bound</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>The upper bound</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Indicates which scanning loci</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdtmp&lt;- geno
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
# run 'genoProb'
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8,
   gr=8, method="Haldane", msg=TRUE)
# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# genome scan
llk.hk&lt;- scanOne(y=pheno$bwt, x=pheno$sex, vc=o, prdat=prDat)

# extract LOD support intervals
tmp&lt;- data.frame(y=llk.hk$LRT, chr=llk.hk$chr, dist=llk.hk$dist)
lodci(tmp, cv=10, lod=1.5, drop=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='mAIC'>
Multiple QTL AIC
</h2><span id='topic+mAIC'></span><span id='topic+mAIC.HK'></span>

<h3>Description</h3>

<p>Multiple QTL model selection by AIC criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mAIC(y, x, gdat, prdat = NULL, vc = NULL, chrIdx, xin, k = 2,
   direction = c("both","backward","forward"), ext = FALSE, msg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mAIC_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column (representing a phenotype for instance).
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data. Should be a matrix or a data frame, with each row representing an observation and each column a marker locus. The column names should be marker names. Numeric coding of genotype is treated as numeric. Ignored if <code>prdat</code> is an object from <code><a href="#topic+genoProb">genoProb</a></code>.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_vc">vc</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code>, or an estimated variance-covariance matrix induced by relatedness. The scan will assume no polygenic variation if <code>vc</code> is NULL.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_prdat">prdat</code></td>
<td>

<p>An object from <code><a href="#topic+genoProb">genoProb</a></code>.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_chridx">chrIdx</code></td>
<td>

<p>Chromsome index of markers in columns of <code>gdat</code> if given. Ignored if <code>prdat</code> is an object from <code><a href="#topic+genoProb">genoProb</a></code>.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_xin">xin</code></td>
<td>

<p>Vector indicating whether a locus is already in the model.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_k">k</code></td>
<td>

<p>Penalty on a parameter. The selection criterion is the known &quot;AIC&quot; if <code>k = 2</code> and is &quot;BIC&quot; if <code>k = log(n)</code> where &quot;n&quot; is the sample size.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_direction">direction</code></td>
<td>

<p>The mode of search: &quot;both&quot;, &quot;forward&quot; or &quot;backward&quot; with default &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_ext">ext</code></td>
<td>

<p>A logical variable. True if ones wants more exhaustive search.
</p>
</td></tr>
<tr><td><code id="mAIC_+3A_msg">msg</code></td>
<td>

<p>A logical variable. True if ones wants to track the process for monitoring purpose.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes use of &quot;Haley-Knott&quot; method (Haley and Knott 1992) if <code>prdat</code> is an object from <code><a href="#topic+genoProb">genoProb</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>model</code>: the resulting model;
</p>
<p><code>aic</code>: AIC of the model;
</p>
<p><code>snp</code>: selected SNPs.
</p>
<p><code>xin</code>: vector indicating whether a SNP is selected.
</p>


<h3>Note</h3>

<p>Currently only suitable for advanced intercross lines (or diallelic data).
</p>


<h3>References</h3>

<p>Haley, C. S., and S. A. Knott (1992). A simple regression method for mapping quantitative trait loci in line crosses using flanking markers. Heredity 69: 315-324.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+genoProb">genoProb</a></code> and <code><a href="#topic+aicVC">aicVC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdat.imp&lt;- genoImpute(geno, gmap=gmapF8,
   gr=8, na.str=NA)
# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# run 'genoProb'
gdtmp&lt;- geno
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8,
   gr=8, method="Haldane", msg=TRUE)

# genome scan
llk.hk&lt;- scanOne(y=pheno$bwt, x=pheno$sex, prdat=prDat, vc=o)
xin&lt;- llk.hk$LRT &gt; 10

# run 'mAIC' based on genome scan results
mg&lt;- mAIC(y=pheno$bwt, x=pheno$sex, prdat=prDat, vc=o, xin=xin,
   k=5, direction="back", msg=TRUE)
mg$model$value # likelihood of the final model

## End(Not run)
</code></pre>

<hr>
<h2 id='miscEx'>
Genotype data, phenotype data, genetic map and pedigree.
</h2><span id='topic+gmF8'></span><span id='topic+pedF8'></span><span id='topic+pedF8.1'></span><span id='topic+pedF8.2'></span><span id='topic+gmapF8'></span><span id='topic+gdatF8'></span><span id='topic+pdatF8'></span><span id='topic+miscEx'></span>

<h3>Description</h3>

<p>AIL F8 data include the following:
</p>
<p>&quot;gmF8&quot;: A list with elements inbreeding coefficients &quot;ib&quot;, additive genetic matrix &quot;AA&quot;, dominance genetic matrix &quot;DD&quot; and other genetic matrices.
</p>
<p>&quot;pedF8&quot;: Pedigree data.
</p>
<p>&quot;pedF8.1&quot;, &quot;pedF8.2&quot;: Alternative versions of pedigree pedF8.
</p>
<p>&quot;gmapF8: Genetic map.
</p>
<p>&quot;gdatF8&quot;: Genotype data.
</p>
<p>&quot;pdatF8&quot;: Phenotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(miscEx)
</code></pre>

<hr>
<h2 id='misFct'>
A collection of other functions.
</h2><span id='topic+fv'></span><span id='topic+genoPos'></span><span id='topic+gvar'></span><span id='topic+pkolm'></span><span id='topic+qkolm'></span>

<h3>Description</h3>

<p>A collection of other functions that are not needed by users.
</p>

<hr>
<h2 id='nullSim'>
Simulate null distribution
</h2><span id='topic+nullSim'></span>

<h3>Description</h3>

<p>Simulate the distribution of the test statistic by permutation (of genotypic data) or gene dropping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullSim(y, x, gdat, prdat, ped, gmap, hap,
	method = c("permutation","gene dropping"), vc = NULL, intc = NULL,
	numGeno = FALSE, test = c("None","F","LRT"), minorGenoFreq = 0.05,
	rmv = TRUE, gr = 2, ntimes = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullSim_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column (representing a phenotype for instance).
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data without missing values. Should be a matrix or a data frame, with each row representing a sample and each column a marker locus. Ignored in the case of gene dropping.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_prdat">prdat</code></td>
<td>

<p>An object from <code><a href="#topic+genoProb">genoProb</a></code>, or in the same form.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which is a data frame (id, sex, father/sire, mother/dam, ...). In &quot;sex&quot;, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ... Note that 0 is reserved for missing values. Ignored in the case of permutation.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_gmap">gmap</code></td>
<td>

<p>A genetic map. Should be data frame (snp, chr, dist, ...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome. Ignored in the case of permutation.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_hap">hap</code></td>
<td>

<p>Founders' haplotype data if not missing. Rows correspond to all founders, which should be in the first places in the pedigree <code>ped</code> and in the exact order, and columns correspond to loci in the genetic map <code>gmap</code> in the exact order. For a sample, the haplotype should be (f1 m1 f2 m2 ...) where fi is the allele from father at the i-th locus and mi is the allele from mother at the i-th locus. Elements should be non-negative integers that are not larger than 16384. If missing, two founders with alleles 1 and 2 are assumed.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_method">method</code></td>
<td>

<p>Permutation or gene dropping.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_vc">vc</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code>, or an estimated variance-covariance matrix induced by relatedness. The scan will assume no polygenic variation if <code>vc</code> is NULL if any locci have a genotype frequency smaller than <code>minorGenoFreq</code>.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_intc">intc</code></td>
<td>

<p>Covariates that interact with QTL.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_numgeno">numGeno</code></td>
<td>

<p>Whether to treat numeric coding of genotypes as numeric. If true, <code>minorGenoFreq</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_test">test</code></td>
<td>

<p>&quot;None&quot;, &quot;F&quot; or &quot;LRT&quot;. Note: the result will be on the scale of -log10(p-value) if the test is &quot;F&quot; or &quot;LRT&quot;; otherwise, the result will be the log-likelihood test statistic. Moerover, the result from each simulation is the maximum over all the SNPs/variants. Therefore, the user should make sure what is pertinent.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_minorgenofreq">minorGenoFreq</code></td>
<td>

<p>Specify the minimum tolerable minor genotype frequency at a scanning locus if <code>gdat</code> is used.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_rmv">rmv</code></td>
<td>

<p>A logical variable. If true, then the scanning locus will be skipped if the minor genotype frequency at the locus is smaller than <code>minorGenoFreq</code>. Otherwise, the scanning process will stop and return with NULL.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_gr">gr</code></td>
<td>

<p>The generation under consideration.
</p>
</td></tr>
<tr><td><code id="nullSim_+3A_ntimes">ntimes</code></td>
<td>

<p>Number of simulations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two methods considered here are permutation test and gene dropping test as described as follows.
</p>
<p>Permutation test: Depending on the genome-scan, one can provide either <code>gdat</code> or <code>prdat</code> respectively corresponding to single-marker analysis or interval mapping. Then only arguments in <code><a href="#topic+scanOne">scanOne</a></code> are needed in addition to <code>method</code> and <code>ntimes</code>.
</p>
<p>Gene dropping test: If <code>prdat</code> is provided, then <code>gdat</code> will be ignored. The procedure will first call <code><a href="#topic+genoSim">genoSim</a></code> to generate new genotype data and then call <code><a href="#topic+genoProb">genoProb</a></code> to generate data for Haley-Knott interval mapping. If <code>prdat</code> is not provided, then <code>gdat</code> should be provided. The procedure will generate new genotype data and scan the genome using these generated genotype data. Haldane mapping function is used to generate data.
</p>


<h3>Value</h3>

<p>A vector of length <code>ntimes</code>, the n-th element of which is maximum of the test statistics (LRT or -log10(p-value)) over the n-th genome scan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genoSim">genoSim</a></code>,  <code><a href="#topic+genoProb">genoProb</a></code> and <code><a href="#topic+scanOne">scanOne</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdatTmp&lt;- genoImpute(geno, gmap=gmapF8,
   gr=8, na.str=NA)
# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# scan marker loci &amp; permutation
ex1&lt;- nullSim(y=pheno$bwt, x=pheno$sex, gdat=gdatTmp,
	method="permutation", vc=o, ntimes=10)

# Haley-Knott method &amp; permutation
gdtmp&lt;- geno
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8,
   gr=8, method="Haldane", msg=TRUE)
ex2&lt;- nullSim(y=pheno$bwt, x=pheno$sex, prdat=prDat,
	method="permutation", vc=o, ntimes=10)

# remove samples whose father is troublesome "32089" 
#    before running gene dropping
# otherwise, "hap" data needs to be supplied

# scan marker loci &amp; gene dropping
idx&lt;- is.element(rownames(pdatF8), pedF8$id[pedF8$sire=="32089"])
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex) &amp; !idx,]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdatTmp&lt;- genoImpute(geno, gmap=gmapF8,
   gr=8, na.str=NA)
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

ex3&lt;- nullSim(y=pheno$bwt, x=pheno$sex, gdat=gdatTmp, ped=pedF8,
	gmap=gmapF8, method="gene", vc=o, ntimes=10)

# Haley-Knott method &amp; gene dropping
gdtmp&lt;- geno
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8,
   gr=8, method="Haldane", msg=TRUE)
ex4&lt;- nullSim(y=pheno$bwt, x=pheno$sex, prdat=prDat, ped=pedF8,
	gmap=gmapF8, method="gene", vc=o, gr=8, ntimes=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='pedRecode'>
Recode a Pedigree
</h2><span id='topic+pedRecode'></span>

<h3>Description</h3>

<p>Prepare a pedigree in a format that is suitable for certain functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedRecode(ped, ids, all = TRUE, msg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pedRecode_+3A_ped">ped</code></td>
<td>

<p>A pedigree, which is a data frame (id, father/sire, mother/dam, ...). If &quot;sex&quot; is a component, male should be &quot;M&quot;, &quot;Male&quot; or 1, and female should be &quot;F&quot;, &quot;Female&quot; or 2 (other than 0 and 1). If given, &quot;generation&quot; can be numeric 0, 1, 2, ... or non-numeric &quot;F0&quot;, &quot;F1&quot;, &quot;F2&quot;, ..., which should be in an increasing order. Note: 0 is reserved for unknown <code>father</code>, <code>mother</code> or <code>sex</code>. If a father/mother is an inbred founder, its ID should be tagged by character 'i' (e.g. 1i, 2i, etc.).
</p>
</td></tr>
<tr><td><code id="pedRecode_+3A_ids">ids</code></td>
<td>

<p>If given, only individuals with <code>ids</code> and their ancestors are kept in the recoded pedigree.
</p>
</td></tr>
<tr><td><code id="pedRecode_+3A_all">all</code></td>
<td>

<p>If false, fathers and mothers with no parents are treated as unknown.
</p>
</td></tr>
<tr><td><code id="pedRecode_+3A_msg">msg</code></td>
<td>

<p>If false, messages are suppressed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in <code>cic</code>, and it can be used for error checking with respect to sex and generation if sex and/or generation information is available. The actual values of generation can be anything but should correspond to the true order of generation; otherwise, <code>cic</code> may fail or we may get incorrect results. Information except <code>id</code>, <code>father</code> and <code>mother</code> is optional.
</p>


<h3>Value</h3>

<p>A recoded pedigree.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cic">cic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

pedF8[1:10,]
pedR&lt;- pedRecode(pedF8)
pedR[1:10,]
dim(pedR)
pedR&lt;- pedRecode(pedF8, ids=pedF8$id[pedF8$gener=="F8"])
dim(pedR)
</code></pre>

<hr>
<h2 id='plotit'>
Plotting
</h2><span id='topic+plot'></span><span id='topic+plotit'></span><span id='topic+plot.scanOne'></span><span id='topic+plot.scanTwo'></span>

<h3>Description</h3>

<p>Plot mapping results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scanOne'
plot(x,...)

plotit(lrt, cv, bychr = FALSE, chr.labels = TRUE, type = "p", lty = NULL,
   col = NULL, pch = NULL, cex = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotit_+3A_x">x</code></td>
<td>

<p>Object from <code><a href="#topic+scanOne">scanOne</a></code> or <code><a href="#topic+scanTwo">scanTwo</a></code>.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_lrt">lrt</code></td>
<td>

<p>A data frame with (chr, dist, y,...) or (chr, dist, y, group,...), where &quot;chr&quot; represents chromosome, &quot;dist&quot; position on the chromosome, &quot;y&quot; the test statistic.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_cv">cv</code></td>
<td>

<p>Threshold to be drawn on the plot.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_cex">cex</code></td>
<td>

<p>See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_bychr">bychr</code></td>
<td>

<p>A logical variable. If true, the plot will be displayed per chromosomes.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_chr.labels">chr.labels</code></td>
<td>

<p>A logical variable. If true, the chromosome names will be drawn.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_type">type</code>, <code id="plotit_+3A_lty">lty</code>, <code id="plotit_+3A_col">col</code>, <code id="plotit_+3A_pch">pch</code></td>
<td>

<p>See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plotit_+3A_...">...</code></td>
<td>

<p>Other options passed to R plot function. To call <code><a href="#topic+plot">plot</a></code> to plot results of <code><a href="#topic+scanOne">scanOne</a></code>, one may need to provide a genetic map <code>gmap</code> that should be data frame (snp, chr, dist, ...), where &quot;snp&quot; is the SNP (marker) name, &quot;chr&quot; is the chromosome where the &quot;snp&quot; is, and &quot;dist&quot; is the genetic distance in centi-Morgan (cM) from the left of the chromosome.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A genetic map 'gmap' may be needed to plot an object of <code><a href="#topic+scanOne">scanOne</a></code> or <code><a href="#topic+scanTwo">scanTwo</a></code>. The color option may not give what is expected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdat.imp&lt;- genoImpute(geno, gmap=gmapF8, step=Inf,
   gr=8, na.str=NA)
# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# genome scan
llk&lt;- scanOne(y=pheno$bwt, x=pheno$sex, vc=o, gdat=gdat.imp)

# plotting
plot(llk, gmap=gmapF8) # gmap is needed

# plotting in another way
idx&lt;- match(colnames(gdat.imp), gmapF8$snp)
tmp&lt;- data.frame(chr=gmapF8$chr[idx],dist=gmapF8$dist[idx],y=llk$LRT)
plotit(tmp, main="Mapping Plot", xlab="Chromosome", ylab="LRT",
   col=as.integer(tmp$ch)%%2+2,type="p")

## End(Not run)
</code></pre>

<hr>
<h2 id='qqPlot'>
Quantile-Quantile Plots
</h2><span id='topic+qqPlot'></span>

<h3>Description</h3>

<p>Quantile-Quantile Plots With the Ability to Draw Confidence Bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqPlot(y, x = "norm", ...,
   type = "p", xlim = NULL, ylim = NULL,
   xlab = if(is.numeric(x)) deparse(substitute(x)) else x,
   ylab = deparse(substitute(y)),main="Q-Q Plot",
   col = 1, lty = 2, lwd = 1, pch = 1, cex = 0.7, plot.it = TRUE,
   confidence = .95, qqline = c("observed","expected","none"),
   add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqPlot_+3A_y">y</code></td>
<td>

<p>A numeric vector of data values.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_x">x</code></td>
<td>

<p>Either a numeric vector of data values, or a character string naming a distribution function such as &quot;norm&quot;.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_...">...</code></td>
<td>

<p>Parameters passed to the distribution specified by <code>x</code> (if non-numerical).
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_type">type</code></td>
<td>

<p>1-character string giving the type of plot desired.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_xlim">xlim</code></td>
<td>

<p>The x limits.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_ylim">ylim</code></td>
<td>

<p>The y limits.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_xlab">xlab</code></td>
<td>

<p>A label for the x axis.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_ylab">ylab</code></td>
<td>

<p>A label for the y axis.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_main">main</code></td>
<td>

<p>A main title for the plot.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_col">col</code></td>
<td>

<p>Color for points and lines.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_lty">lty</code></td>
<td>

<p>Line type.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_lwd">lwd</code></td>
<td>

<p>Line width.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_pch">pch</code></td>
<td>

<p>Plotting character for points.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_cex">cex</code></td>
<td>

<p>Factor for expanding the size of plotted symbols.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_plot.it">plot.it</code></td>
<td>

<p>Whether or not to draw a plot. if plotting, points outside the confidence bands will be indicated by different a color.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level for the confidence band, or <code>FALSE</code> for no band.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_qqline">qqline</code></td>
<td>

<p>Whether or not to draw a reference line. if &quot;observed&quot;, the line passes through the first and third observed quartiles; if &quot;expected&quot;, the point (x,y) is expected to fall on the line if x and y follow the same distribution; if &quot;none&quot;, no reference line is drawn.
</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_add">add</code></td>
<td>

<p>Add to an existing plot if true.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is numeric, a two-sample test of the null hypothesis that <code>x</code> and <code>y</code> were drawn from the same continuous distribution is performed. Alternatively, <code>x</code> can be a character string naming a continuous distribution function. In such a case, a one-sample test is carried out of the null that <code>y</code> was draw from distribution <code>x</code> with parameters specified by &quot;...&quot;.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>Quantiles of <code>x</code></p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Quantiles of <code>y</code></p>
</td></tr>
<tr><td><code>lower</code>, <code>upper</code></td>
<td>
<p>Lower and upper limits if <code>confidence</code> is specified</p>
</td></tr>
</table>


<h3>References</h3>

<p>George Marsaglia, Wai Wan Tsang and Jingbo Wang (2003), Evaluating Kolmogorov's distribution. Journal of Statistical Software 8 (18): 1-4.
</p>
<p>Vijayan N. Nair (1982). Q-Q plots with confidence bands for comparing several populations.
</p>
<p>William J. Conover (1971). Practical Nonparametric Statistics. New York: John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(mfrow=c(1,2))
x&lt;- rnorm(200, mean=0.7,sd=2); y&lt;- rnorm(200, sd=2)
qqPlot(y,x,qqline="exp")
qqPlot(y=y,x="norm",sd=2)
ks.test(x,y)

## End(Not run)
</code></pre>

<hr>
<h2 id='qtl2rel'>Convert data from R/qtl to QTLRel format</h2><span id='topic+qtl2rel'></span>

<h3>Description</h3>

<p>Convert the data for a QTL mapping experiment from the R/qtl format
(see http://www.rqtl.org) to that used by QTLRel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl2rel(cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtl2rel_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross"</code>, as defined by the R/qtl package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input cross must by an intercross (class <code>"f2"</code>).
</p>
<p>Simple pedigree information is created, assuming the data are from a
standard intercross.
</p>


<h3>Value</h3>

<p>A list with four components: <code>"ped"</code> (pedigree information),
<code>"gdat"</code> (genotype data), <code>"pdat"</code> (phenotype data), and
<code>"gmap"</code> (genetic map), in the formats used by QTLRel.
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:kbroman@biostat.wisc.edu">kbroman@biostat.wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+rel2qtl">rel2qtl</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
data(listeria)
listeria &lt;- listeria[as.character(1:19),]
reldat &lt;- qtl2rel(listeria)
</code></pre>

<hr>
<h2 id='qtlVar'>
QTL Variance
</h2><span id='topic+qtlVar'></span>

<h3>Description</h3>

<p>Estimate variance in a quantitative trait induced by QTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtlVar(lrt, prdat, simulation = FALSE, nsim = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtlVar_+3A_lrt">lrt</code></td>
<td>

<p>A data frame (a, d, ...), where 'a' and 'd' are respectively additive and dominance effects.
</p>
</td></tr>
<tr><td><code id="qtlVar_+3A_prdat">prdat</code></td>
<td>

<p>A 3-D array that provides probabilities of genotypes &quot;AA&quot;, &quot;AB&quot; and &quot;BB&quot;. If <code>prDat</code> is an object of <code><a href="#topic+genoProb">genoProb</a></code>, then <code>prdat</code> can be <code>prDat$pr</code>. 
</p>
</td></tr>
<tr><td><code id="qtlVar_+3A_simulation">simulation</code></td>
<td>

<p>Whether to use simulations to estimate the variance explained by QTL.
</p>
</td></tr>
<tr><td><code id="qtlVar_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations to perform if <code>simulation</code> is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector displaying the estimated variance at each loci.
</p>


<h3>Note</h3>

<p>Correlations among observations are ignored, and this function should be used with caution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scanOne">scanOne</a></code> and <code><a href="#topic+genoProb">genoProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

gdtmp&lt;- geno
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
# rung 'genoProb'
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8,
   gr=8, method="Haldane", msg=TRUE)
# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# genome scan
pv.hk&lt;- scanOne(y=pheno$bwt, x=pheno$sex, prdat=prDat, vc=o)

# run 'qtlVar'
qef&lt;- pv.hk$par[,c("a","d")]
   qef&lt;- as.data.frame(qef)
qv&lt;- qtlVar(qef,prDat$pr)

## End(Not run)
</code></pre>

<hr>
<h2 id='rel2qtl'>Convert data from QTLRel to R/qtl format</h2><span id='topic+rel2qtl'></span>

<h3>Description</h3>

<p>Convert the data for a QTL mapping experiment from the QTLRel format
to that used by R/qtl (http://www.rqtl.org).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel2qtl(gdat, pdat, gmap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rel2qtl_+3A_gdat">gdat</code></td>
<td>
<p>Genotype data</p>
</td></tr>
<tr><td><code id="rel2qtl_+3A_pdat">pdat</code></td>
<td>
<p>Phenotype data</p>
</td></tr>
<tr><td><code id="rel2qtl_+3A_gmap">gmap</code></td>
<td>
<p>Genetic map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pedigree information is ignored, and X chromosome data is omitted.
</p>
<p>The data are treated as an intercross.
</p>


<h3>Value</h3>

<p>A cross object for the R/qtl package (http://www.rqtl.org).
</p>


<h3>Author(s)</h3>

<p>Karl W Broman, <a href="mailto:kbroman@biostat.wisc.edu">kbroman@biostat.wisc.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+qtl2rel">qtl2rel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)
f8 &lt;- rel2qtl(gdatF8, pdatF8, gmapF8)
summary(f8)
</code></pre>

<hr>
<h2 id='rem'>
Random effect matrices
</h2><span id='topic+rem'></span>

<h3>Description</h3>

<p>Construct matrices associated with random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rem(formula,data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rem_+3A_formula">formula</code></td>
<td>

<p>A formula of the form: ~ Z | G1/.../Gk + ..., corresponding to random effects Z*G_i + Z*G_{ij} + ... in a mixed effect model. If Z=1 as in most cases, then it can be ~ G1/.../Gk + ...
</p>
</td></tr>
<tr><td><code id="rem_+3A_data">data</code></td>
<td>

<p>A data frame that contains all the variables in the formula.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices that are associated with random effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make-up example
dat&lt;- data.frame(
   group=c("A","A","A","A","A","A","B","B","B","B"),
   sex=c("F","F","F","M","M","M","F","F","M","M"),
   pass=c("Y","N","N","Y","Y","Y","Y","N","N","Y"),
   z=1:10)

# random effect pass, group and sex, where sex is nested
# within group:
# y_{ijk} = x_{ij}*b + group_i + sex_{ij} + z*pass_{ij}
#           + e_{ijk}
rem(~ group/sex + z|pass,data=dat)

## End(Not run)
</code></pre>

<hr>
<h2 id='scanOne'>
Genome Scan for QTL
</h2><span id='topic+scanOne'></span>

<h3>Description</h3>

<p>Likelihood ratio tests or F tests at scanning loci over the genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanOne(y, x, gdat, prdat = NULL, vc = NULL, intc = NULL,
   numGeno = FALSE, test = c("None","F","LRT"),
   minorGenoFreq = 0, rmv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanOne_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column, representing a phenotype.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data. It should be a matrix or a data frame, with each row being a sample and each column a locus. The column names should be marker names. It is ignored if an object <code>prdat</code> from <code><a href="#topic+genoProb">genoProb</a></code> is used as an argument.
</p>
<p>If <code>gdat</code> is not numeric, there can be more than three genotypes and all scanning loci should have the same number of genotypes.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_prdat">prdat</code></td>
<td>

<p>An object from <code><a href="#topic+genoProb">genoProb</a></code>, or in the same form. It should have a class &quot;addEff&quot; if allelic effects are assumed to be additive (see example below).
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_vc">vc</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code>, or an estimated variance-covariance matrix induced by relatedness and environment.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_intc">intc</code></td>
<td>

<p>Covariates that interact with QTL.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_numgeno">numGeno</code></td>
<td>

<p>Whether to treat numeric coding of genotypes as numeric. If true, <code>minorGenoFreq</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_test">test</code></td>
<td>

<p>&quot;None&quot;, &quot;F&quot; or &quot;LRT&quot;.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_minorgenofreq">minorGenoFreq</code></td>
<td>

<p>Specify the minimum tolerable minor genotype frequency at a scanning locus if <code>gdat</code> is used.
</p>
</td></tr>
<tr><td><code id="scanOne_+3A_rmv">rmv</code></td>
<td>

<p>A logical variable. If true, then the scanning locus will be skipped if the minor genotype frequency at the locus is smaller than <code>minorGenoFreq</code>. Otherwise, the scanning process will stop and return with NULL if any loci have a genotype frequency smaller than <code>minorGenoFreq</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test at a scanning locus under the null hypothesis of no QTL effect is performed by conditioning on the polygenic genetic variance-covariance. Normality is assumed for the random effects.
</p>
<p>It is possible to extend the Haley-Knott approach to multiple-allelic cases under the assumption that allelic effects are all additive. Then, <code>prdat</code> should be provided and be of class &quot;addEff&quot;.
</p>


<h3>Value</h3>

<p>A list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>F or LRT</code></td>
<td>
<p>the F-test or likelihood ratio test (LRT) statistic at the SNP (marker) if <code>test</code> is &quot;F&quot; or otherwise</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>P-value at the snp (marker) if <code>test</code> is &quot;F&quot; or &quot;LRT&quot;</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Variation explained by the SNP (marker)</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Estimated parameters at all scanning loci, including additive effect <code>a</code> and dominance effect <code>d</code> if <code>prdat</code> is not NULL</p>
</td></tr>
</table>


<h3>References</h3>

<p>Haley, C. S., and S. A. Knott (1992). A simple regression method for mapping quantitative trait loci in line crosses using flanking markers. Heredity 69: 315-324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genoImpute">genoImpute</a></code> and  <code><a href="#topic+genoProb">genoProb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miscEx)

## Not run: 
# impute missing genotypes
pheno&lt;- pdatF8[!is.na(pdatF8$bwt) &amp; !is.na(pdatF8$sex),]
ii&lt;- match(rownames(pheno), rownames(gdatF8))
geno&lt;- gdatF8[ii,]
ii&lt;- match(rownames(pheno), rownames(gmF8$AA))
v&lt;- list(A=gmF8$AA[ii,ii], D=gmF8$DD[ii,ii])

# estimate variance components
o&lt;- estVC(y=pheno$bwt, x=pheno$sex, v=v)

# impute missing genotypes
gdtmp&lt;- genoImpute(geno, gmap=gmapF8, gr=8, na.str=NA, msg=FALSE)
# genome scan and plotting
lrt&lt;- scanOne(y=pheno$bwt, x=pheno$sex, gdat=gdtmp, vc=o)
lrt
plot(lrt,gmap=gmapF8)

# Haley-Knott method
gdtmp&lt;- geno; unique(unlist(gdtmp))
   gdtmp&lt;- replace(gdtmp,is.na(gdtmp),0)
prDat&lt;- genoProb(gdat=gdtmp, gmap=gmapF8, gr=8, method="Haldane", msg=TRUE)
pv.hk&lt;- scanOne(y=pheno$bwt, intc=pheno$sex, prdat=prDat, vc=o, test="F")
pv.hk
plot(pv.hk, gmap=gmapF8)

# assume additive allelic effects
class(prDat)&lt;- c(class(prDat), "addEff")
lrt.hk&lt;- scanOne(y=pheno$bwt, intc=pheno$sex, prdat=prDat, vc=o)
lrt.hk

## End(Not run)
</code></pre>

<hr>
<h2 id='scanTwo'>
Genome Scan for Epistasis
</h2><span id='topic+scanTwo'></span>

<h3>Description</h3>

<p>Evaluate log-likelihood ratio test statistic for epistasis (QTL by QTL interaction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanTwo(y, x, gdat, prdat = NULL, vc = NULL, numGeno = FALSE,
   minorGenoFreq = 0, rmv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scanTwo_+3A_y">y</code></td>
<td>

<p>A numeric vector or a numeric matrix of one column (representing a phenotype for instance).
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_x">x</code></td>
<td>

<p>A data frame or matrix, representing covariates if not missing.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_gdat">gdat</code></td>
<td>

<p>Genotype data. Should be a matrix or a data frame, with each row representing an observation and each column a marker locus. The column names should be marker names. Optional if an object <code>prdat</code> from <code><a href="#topic+genoProb">genoProb</a></code> is used as an argument.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_prdat">prdat</code></td>
<td>

<p>An object from <code><a href="#topic+genoProb">genoProb</a></code>.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_vc">vc</code></td>
<td>

<p>An object from <code><a href="#topic+estVC">estVC</a></code> or <code><a href="#topic+aicVC">aicVC</a></code>, or an estimated variance-covariance matrix induced by relatedness and environment.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_numgeno">numGeno</code></td>
<td>

<p>Whether to treat numeric coding of genotypes as numeric. If true, <code>minorGenoFreq</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_minorgenofreq">minorGenoFreq</code></td>
<td>

<p>Specify the minimum tolerable minor genotype frequency at a scanning locus if <code>gdat</code> is used.
</p>
</td></tr>
<tr><td><code id="scanTwo_+3A_rmv">rmv</code></td>
<td>

<p>A logical variable. If true, then the scanning locus will be skipped if the minor genotype frequency at the locus is smaller than <code>minorGenoFreq</code>. Otherwise, the scanning process will stop and return with NULL.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose entry in the upper triangle is the log-likelihood test statistic for epistatic effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scanOne">scanOne</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
