<!DOCTYPE html><html><head><title>Help for package tarchetypes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tarchetypes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#counter_init'><p>Counter constructor.</p></a></li>
<li><a href='#counter_set_names'><p>Add data to an existing counter object.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tar_age'><p>Create a target that runs when the last run gets old</p></a></li>
<li><a href='#tar_append_static_values'><p>Append statically mapped values to target output.</p></a></li>
<li><a href='#tar_change'><p>Target that responds to an arbitrary change.</p></a></li>
<li><a href='#tar_combine'><p>Static aggregation.</p></a></li>
<li><a href='#tar_combine_raw'><p>Static aggregation (raw version).</p></a></li>
<li><a href='#tar_cue_age'><p>Cue to run a target when the last output reaches a certain age</p></a></li>
<li><a href='#tar_cue_age_raw'><p>Cue to run a target when the last run reaches a certain age</p>
(raw version)</a></li>
<li><a href='#tar_cue_force'><p>Cue to force a target to run if a condition is true</p></a></li>
<li><a href='#tar_cue_skip'><p>Cue to skip a target if a condition is true</p></a></li>
<li><a href='#tar_download'><p>Target that downloads URLs.</p></a></li>
<li><a href='#tar_download_run'><p>Download multiple URLs and return the local paths.</p></a></li>
<li><a href='#tar_eval'><p>Evaluate multiple expressions created with symbol substitution.</p></a></li>
<li><a href='#tar_eval_raw'><p>Evaluate multiple expressions created with symbol substitution</p>
(raw version).</a></li>
<li><a href='#tar_file_read'><p>Track a file and read the contents.</p></a></li>
<li><a href='#tar_files'><p>Dynamic branching over output or input files.</p></a></li>
<li><a href='#tar_files_input'><p>Dynamic branching over input files or URLs</p></a></li>
<li><a href='#tar_files_input_raw'><p>Dynamic branching over input files or URLs (raw version).</p></a></li>
<li><a href='#tar_files_raw'><p>Dynamic branching over output or input files (raw version).</p></a></li>
<li><a href='#tar_force'><p>Target with a custom condition to force execution.</p></a></li>
<li><a href='#tar_force_change'><p>Convert a condition into a change.</p></a></li>
<li><a href='#tar_formats'><p>Target formats</p></a></li>
<li><a href='#tar_group_by'><p>Group a data frame target by one or more variables.</p></a></li>
<li><a href='#tar_group_by_run'><p>Generate a grouped data frame within tar_group_by()</p></a></li>
<li><a href='#tar_group_count'><p>Group the rows of a data frame into a given number groups</p></a></li>
<li><a href='#tar_group_count_index'><p>Generate the tar_group column for <code>tar_group_count()</code>.</p></a></li>
<li><a href='#tar_group_count_run'><p>Generate a grouped data frame within <code>tar_group_count()</code>.</p></a></li>
<li><a href='#tar_group_select'><p>Group a data frame target with <code>tidyselect</code> semantics.</p></a></li>
<li><a href='#tar_group_select_run'><p>Generate a grouped data frame within tar_group_select()</p></a></li>
<li><a href='#tar_group_size'><p>Group the rows of a data frame into groups</p>
of a given size.</a></li>
<li><a href='#tar_group_size_index'><p>Generate the tar_group column for <code>tar_group_size()</code>.</p></a></li>
<li><a href='#tar_group_size_run'><p>Generate a grouped data frame within tar_group_size()</p></a></li>
<li><a href='#tar_hook_before'><p>Hook to prepend code</p></a></li>
<li><a href='#tar_hook_inner'><p>Hook to wrap dependencies</p></a></li>
<li><a href='#tar_hook_outer'><p>Hook to wrap commands</p></a></li>
<li><a href='#tar_knit'><p>Target with a <code>knitr</code> document.</p></a></li>
<li><a href='#tar_knit_raw'><p>Target with a knitr document (raw version).</p></a></li>
<li><a href='#tar_knit_run'><p>Run a <code>knitr</code> report inside a <code>tar_knit()</code> target.</p></a></li>
<li><a href='#tar_knitr_deps'><p>List literate programming dependencies.</p></a></li>
<li><a href='#tar_knitr_deps_expr'><p>Expression with literate programming dependencies.</p></a></li>
<li><a href='#tar_map'><p>Static branching.</p></a></li>
<li><a href='#tar_map_rep'><p>Dynamic batched replication within static branches</p>
for data frames.</a></li>
<li><a href='#tar_map_rep_raw'><p>Dynamic batched replication within static branches</p>
for data frames (raw version).</a></li>
<li><a href='#tar_map2'><p>Batched dynamic-within-static branching for data frames.</p></a></li>
<li><a href='#tar_map2_count'><p>Dynamic-within-static branching for data frames</p>
(count batching).</a></li>
<li><a href='#tar_map2_count_raw'><p>Dynamic-within-static branching for data frames</p>
(count batching; raw version).</a></li>
<li><a href='#tar_map2_group'><p>Append the <code>tar_group</code> variable to a <code>tar_map2()</code> target.</p></a></li>
<li><a href='#tar_map2_raw'><p>Batched dynamic-within-static branching for data frames (raw version).</p></a></li>
<li><a href='#tar_map2_run'><p>Run a dynamic batch of a <code>tar_map2()</code> target.</p></a></li>
<li><a href='#tar_map2_run_rep'><p>Run a rep in a <code>tar_map2()</code>-powered function.</p></a></li>
<li><a href='#tar_map2_size'><p>Dynamic-within-static branching for data frames</p>
(size batching).</a></li>
<li><a href='#tar_map2_size_raw'><p>Dynamic-within-static branching for data frames</p>
(size batching; raw version).</a></li>
<li><a href='#tar_plan'><p>A <code>drake</code>-plan-like pipeline archetype</p></a></li>
<li><a href='#tar_quarto'><p>Target with a Quarto project.</p></a></li>
<li><a href='#tar_quarto_files'><p>Quarto file detection</p></a></li>
<li><a href='#tar_quarto_raw'><p>Target with a Quarto project (raw version).</p></a></li>
<li><a href='#tar_quarto_rep'><p>Parameterized Quarto with dynamic branching.</p></a></li>
<li><a href='#tar_quarto_rep_raw'><p>Parameterized Quarto with dynamic branching (raw version).</p></a></li>
<li><a href='#tar_quarto_rep_rep'><p>Run a rep in a <code>tar_quarto_rep()</code>.</p></a></li>
<li><a href='#tar_quarto_rep_run'><p>Render a batch of parameterized Quarto reports</p>
inside a <code>tar_quarto_rep()</code> target.</a></li>
<li><a href='#tar_quarto_rep_run_params'><p>Prepare Quarto parameters for <code>tar_quarto_rep()</code>.</p></a></li>
<li><a href='#tar_quarto_run'><p>Render a Quarto project inside a <code>tar_quarto()</code> target.</p></a></li>
<li><a href='#tar_render'><p>Target with an R Markdown document.</p></a></li>
<li><a href='#tar_render_raw'><p>Target with an R Markdown document (raw version).</p></a></li>
<li><a href='#tar_render_rep'><p>Parameterized R Markdown with dynamic branching.</p></a></li>
<li><a href='#tar_render_rep_raw'><p>Parameterized R Markdown with dynamic branching (raw version).</p></a></li>
<li><a href='#tar_render_rep_rep'><p>Run a rep in a <code>tar_render_rep()</code>.</p></a></li>
<li><a href='#tar_render_rep_run'><p>Render a batch of parameterized R Markdown reports</p>
inside a <code>tar_render_rep()</code> target.</a></li>
<li><a href='#tar_render_rep_run_params'><p>Prepare R Markdown parameters for <code>tar_render_rep()</code>.</p></a></li>
<li><a href='#tar_render_run'><p>Render an R Markdown report inside a <code>tar_render()</code> target.</p></a></li>
<li><a href='#tar_rep'><p>Batched replication with dynamic branching.</p></a></li>
<li><a href='#tar_rep_map'><p>Dynamic batched computation downstream of <code>tar_rep()</code> (deprecated).</p></a></li>
<li><a href='#tar_rep_map_raw'><p>Dynamic batched computation downstream of <code>tar_rep()</code></p>
(raw; deprecated).</a></li>
<li><a href='#tar_rep_raw'><p>Batched replication with dynamic branching</p>
(raw version).</a></li>
<li><a href='#tar_rep_run'><p>Run a batch in a <code>tar_rep()</code> archetype.</p></a></li>
<li><a href='#tar_rep_run_map_rep'><p>Run a rep in <code>tar_rep()</code>.</p></a></li>
<li><a href='#tar_rep2'><p>Dynamic batched computation downstream of <code>tar_rep()</code></p></a></li>
<li><a href='#tar_rep2_raw'><p>Dynamic batched computation downstream of <code>tar_rep()</code> (raw version).</p></a></li>
<li><a href='#tar_rep2_run'><p>Run <code>tar_rep2()</code> batches.</p></a></li>
<li><a href='#tar_rep2_run_rep'><p>Run a rep in a <code>tar_rep2()</code>-powered function.</p></a></li>
<li><a href='#tar_select_names'><p>Select target names from a target list</p></a></li>
<li><a href='#tar_select_targets'><p>Select target objects from a target list</p></a></li>
<li><a href='#tar_skip'><p>Target with a custom cancellation condition.</p></a></li>
<li><a href='#tar_sub'><p>Create multiple expressions with symbol substitution.</p></a></li>
<li><a href='#tar_sub_raw'><p>Create multiple expressions with symbol substitution (raw version).</p></a></li>
<li><a href='#tarchetypes-package'><p>targets: Archetypes for Targets</p></a></li>
<li><a href='#walk_ast'><p>Static code analysis for <code>tarchetypes</code>.</p></a></li>
<li><a href='#walk_call_knitr'><p>Code analysis for knitr reports.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Archetypes for Targets</td>
</tr>
<tr>
<td>Description:</td>
<td>Function-oriented Make-like declarative pipelines for
  Statistics and data science are supported in the 'targets' R package.
  As an extension to 'targets', the 'tarchetypes' package provides
  convenient user-side functions to make 'targets' easier to use.
  By establishing reusable archetypes for common kinds of
  targets and pipelines, these functions help express complicated
  reproducible pipelines concisely and compactly.
  The methods in this package were influenced by the 'drake' R package
  by Will Landau (2018) &lt;<a href="https://doi.org/10.21105%2Fjoss.00550">doi:10.21105/joss.00550</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/tarchetypes/">https://docs.ropensci.org/tarchetypes/</a>,
<a href="https://github.com/ropensci/tarchetypes">https://github.com/ropensci/tarchetypes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/tarchetypes/issues">https://github.com/ropensci/tarchetypes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest (&ge; 0.6.25), dplyr (&ge; 1.0.0), fs (&ge; 1.4.2), parallel,
rlang (&ge; 0.4.7), targets (&ge; 1.6.0), tibble (&ge; 3.0.1),
tidyselect (&ge; 1.1.0), utils, vctrs (&ge; 0.3.4), withr (&ge;
2.1.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>curl (&ge; 4.3), knitr (&ge; 1.28), quarto (&ge; 1.4), rmarkdown
(&ge; 2.1), testthat (&ge; 3.0.0), xml2 (&ge; 1.3.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 18:18:10 UTC; C240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Samantha Oliver <a href="https://orcid.org/0000-0001-5668-1165"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Tristan Mahr <a href="https://orcid.org/0000-0002-8890-5116"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='counter_init'>Counter constructor.</h2><span id='topic+counter_init'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counter_init(names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counter_init_+3A_names">names</code></td>
<td>
<p>Character vector of names to add to the new counter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a counter object as described at
<a href="https://books.ropensci.org/targets-design/classes.html#counter-class">https://books.ropensci.org/targets-design/classes.html#counter-class</a>.
</p>


<h3>Value</h3>

<p>A new counter object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>counter &lt;- counter_init()
counter_set_names(counter, letters)
</code></pre>

<hr>
<h2 id='counter_set_names'>Add data to an existing counter object.</h2><span id='topic+counter_set_names'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counter_set_names(counter, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counter_set_names_+3A_counter">counter</code></td>
<td>
<p>A counter object, defined for internal purposes only.</p>
</td></tr>
<tr><td><code id="counter_set_names_+3A_names">names</code></td>
<td>
<p>Character vector of names to add to the counter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>counter &lt;- counter_init()
counter_set_names(counter, letters)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+all_of'></span><span id='topic+any_of'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tar_age'>Create a target that runs when the last run gets old</h2><span id='topic+tar_age'></span>

<h3>Description</h3>

<p><code>tar_age()</code> creates a target that reruns
itself when it gets old enough.
In other words, the target reruns periodically at regular
intervals of time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_age(
  name,
  command,
  age,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_age_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_command">command</code></td>
<td>
<p>R code to run the target and return a value.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_age">age</code></td>
<td>
<p>A <code>difftime</code> object of length 1, such as
<code>as.difftime(3, units = "days")</code>. If the target's output data
files are older than <code>age</code> (according to the most recent
time stamp over all the target's output files)
then the target will rerun.
On the other hand, if at least one data file is
younger than <code>Sys.time() - age</code>, then the ordinary
invalidation rules apply, and the target may or not rerun.
If you want to force the target to run every 3 days,
for example, set <code>age = as.difftime(3, units = "days")</code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_pattern">pattern</code></td>
<td>
<p>Language to define branching for a target.
For example, in a pipeline with numeric vector targets <code>x</code> and <code>y</code>,
<code>tar_target(z, x + y, pattern = map(x, y))</code> implicitly defines
branches of <code>z</code> that each compute <code>x[1] + y[1]</code>, <code>x[2] + y[2]</code>,
and so on. See the user manual for details.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_age_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_age_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_age_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_age_+3A_cue">cue</code></td>
<td>
<p>A <code>targets::tar_cue()</code> object. (See the &quot;Cue objects&quot;
section for background.) This cue object should contain any
optional secondary invalidation rules, anything except
the <code>mode</code> argument. <code>mode</code> will be automatically determined
by the <code>age</code> argument of <code>tar_age()</code>.</p>
</td></tr>
<tr><td><code id="tar_age_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_age()</code> uses the cue from <code><a href="#topic+tar_cue_age">tar_cue_age()</a></code>, which
uses the time stamps from <code>targets::tar_meta()$time</code>.
See the help file of <code>targets::tar_timestamp()</code>
for an explanation of how this time stamp is calculated.
</p>


<h3>Value</h3>

<p>A target object. See the &quot;Target objects&quot; section for background.
</p>


<h3>Dynamic branches at regular time intervals</h3>

<p>Time stamps are not recorded for whole dynamic targets,
so <code>tar_age()</code> is not a good fit for dynamic branching.
To invalidate dynamic branches at regular intervals,
it is recommended to use <code>targets::tar_older()</code> in combination
with <code>targets::tar_invalidate()</code> right before calling <code>tar_make()</code>.
For example,
<code>tar_invalidate(any_of(tar_older(Sys.time - as.difftime(1, units = "weeks"))))</code> # nolint
invalidates all targets more than a week old. Then, the next <code>tar_make()</code>
will rerun those targets.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other cues: 
<code><a href="#topic+tar_cue_age">tar_cue_age</a>()</code>,
<code><a href="#topic+tar_cue_age_raw">tar_cue_age_raw</a>()</code>,
<code><a href="#topic+tar_cue_force">tar_cue_force</a>()</code>,
<code><a href="#topic+tar_cue_skip">tar_cue_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  list(
    tarchetypes::tar_age(
      data,
      data.frame(x = seq_len(26)),
      age = as.difftime(0.5, units = "secs")
    )
  )
})
targets::tar_make()
Sys.sleep(0.6)
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_append_static_values'>Append statically mapped values to target output.</h2><span id='topic+tar_append_static_values'></span>

<h3>Description</h3>

<p>For internal use only. Users should not invoke
this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_append_static_values(object, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_append_static_values_+3A_object">object</code></td>
<td>
<p>Return value of a target. Must be a data frame.</p>
</td></tr>
<tr><td><code id="tar_append_static_values_+3A_values">values</code></td>
<td>
<p>Tibble with the set of static values that the current target
uses.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_change'>Target that responds to an arbitrary change.</h2><span id='topic+tar_change'></span>

<h3>Description</h3>

<p>Create a target that responds to a change
in an arbitrary value. If the value changes, the target reruns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_change(
  name,
  command,
  change,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_change_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_change">change</code></td>
<td>
<p>R code for the upstream change-inducing target.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to arguments <code>command</code> and <code>change</code>.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_change_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_change_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_change_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_change_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_change_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_change_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_change()</code> creates a pair of targets, one upstream
and one downstream. The upstream target always runs and returns
an auxiliary value. This auxiliary value gets referenced in the
downstream target, which causes the downstream target to rerun
if the auxiliary value changes. The behavior is cancelled if
<code>cue</code> is <code>tar_cue(depend = FALSE)</code> or <code>tar_cue(mode = "never")</code>.
</p>
<p>Because the upstream target always runs,
<code>tar_outdated()</code> and <code>tar_visnetwork()</code> will always
show both targets as outdated. However, <code>tar_make()</code> will still
skip the downstream one if the upstream target
did not detect a change.
</p>


<h3>Value</h3>

<p>A list of two target objects, one upstream and one downstream.
The upstream one triggers the change, and the downstream one
responds to it.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other targets with custom invalidation rules: 
<code><a href="#topic+tar_download">tar_download</a>()</code>,
<code><a href="#topic+tar_force">tar_force</a>()</code>,
<code><a href="#topic+tar_skip">tar_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_change(x, command = tempfile(), change = tempfile())
  )
})
targets::tar_make()
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_combine'>Static aggregation.</h2><span id='topic+tar_combine'></span>

<h3>Description</h3>

<p>Aggregate the results of upstream targets
into a new target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_combine(
  name,
  ...,
  command = vctrs::vec_c(!!!.x),
  use_names = TRUE,
  pattern = NULL,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_combine_+3A_name">name</code></td>
<td>
<p>Symbol, name of the new target.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_...">...</code></td>
<td>
<p>One or more target objects or list of target objects.
Lists can be arbitrarily nested, as in <code>list()</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_command">command</code></td>
<td>
<p>R command to aggregate the targets. Must contain
<code>!!!.x</code> where the arguments are to be inserted,
where <code style="white-space: pre;">&#8288;!!!&#8288;</code> is the unquote splice operator from <code>rlang</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_use_names">use_names</code></td>
<td>
<p>Logical, whether to insert the names of the targets
into the command when splicing.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_pattern">pattern</code></td>
<td>
<p>Language to define branching for a target.
For example, in a pipeline with numeric vector targets <code>x</code> and <code>y</code>,
<code>tar_target(z, x + y, pattern = map(x, y))</code> implicitly defines
branches of <code>z</code> that each compute <code>x[1] + y[1]</code>, <code>x[2] + y[2]</code>,
and so on. See the user manual for details.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_combine_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new target object to combine the return values
from the upstream targets.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  target1 &lt;- targets::tar_target(x, head(mtcars))
  target2 &lt;- targets::tar_target(y, tail(mtcars))
  target3 &lt;- tarchetypes::tar_combine(
    new_target_name,
    target1,
    target2,
    command = bind_rows(!!!.x)
  )
  list(target1, target2, target3)
})
targets::tar_manifest()
})
}
</code></pre>

<hr>
<h2 id='tar_combine_raw'>Static aggregation (raw version).</h2><span id='topic+tar_combine_raw'></span>

<h3>Description</h3>

<p>Like <code><a href="#topic+tar_combine">tar_combine()</a></code> except the <code>name</code>, <code>command</code>,
and <code>pattern</code> arguments use standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_combine_raw(
  name,
  ...,
  command = expression(vctrs::vec_c(!!!.x)),
  use_names = TRUE,
  pattern = NULL,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_combine_raw_+3A_name">name</code></td>
<td>
<p>Character, name of the new target.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_...">...</code></td>
<td>
<p>One or more target objects or list of target objects.
Lists can be arbitrarily nested, as in <code>list()</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_command">command</code></td>
<td>
<p>Expression object,
R command to aggregate the targets. Must contain
<code>!!!.x</code> where the arguments are to be inserted,
where <code style="white-space: pre;">&#8288;!!!&#8288;</code> is the unquote splice operator from <code>rlang</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_use_names">use_names</code></td>
<td>
<p>Logical, whether to insert the names of the targets
into the command when splicing.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_pattern">pattern</code></td>
<td>
<p>Similar to the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code>
except the object must already be an expression instead of
informally quoted code.
<code>base::expression()</code> and <code>base::quote()</code> can produce such objects.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_combine_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new target object to combine the return values
from the upstream targets.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  target1 &lt;- targets::tar_target(x, head(mtcars))
  target2 &lt;- targets::tar_target(y, tail(mtcars))
  target3 &lt;- tarchetypes::tar_combine(new_target_name, target1, target2)
  list(target1, target2, target3)
})
targets::tar_manifest()
})
}
</code></pre>

<hr>
<h2 id='tar_cue_age'>Cue to run a target when the last output reaches a certain age</h2><span id='topic+tar_cue_age'></span>

<h3>Description</h3>

<p><code>tar_cue_age()</code> creates a cue object to
rerun a target if the most recent output data becomes old enough.
The age of the target is determined by <code>targets::tar_timestamp()</code>,
and the way the time stamp is calculated is explained
in the Details section of the help file of that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cue_age(
  name,
  age,
  command = TRUE,
  depend = TRUE,
  format = TRUE,
  repository = TRUE,
  iteration = TRUE,
  file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cue_age_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_age">age</code></td>
<td>
<p>A <code>difftime</code> object of length 1, such as
<code>as.difftime(3, units = "days")</code>. If the target's output data
files are older than <code>age</code> (according to the most recent
time stamp over all the target's output files)
then the target will rerun.
On the other hand, if at least one data file is
younger than <code>Sys.time() - age</code>, then the ordinary
invalidation rules apply, and the target may or not rerun.
If you want to force the target to run every 3 days,
for example, set <code>age = as.difftime(3, units = "days")</code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_command">command</code></td>
<td>
<p>Logical, whether to rerun the target if command changed
since last time.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_depend">depend</code></td>
<td>
<p>Logical, whether to rerun the target if the value of one
of the dependencies changed.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_+3A_file">file</code></td>
<td>
<p>Logical, whether to rerun the target if the file(s) with the
return value changed or at least one is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_cue_age()</code> uses the time stamps from <code>tar_meta()$time</code>.
If no time stamp is recorded, the cue defaults to the ordinary
invalidation rules (i.e. <code>mode = "thorough"</code> in <code>targets::tar_cue()</code>).
</p>


<h3>Value</h3>

<p>A cue object. See the &quot;Cue objects&quot; section for background.
</p>


<h3>Dynamic branches at regular time intervals</h3>

<p>Time stamps are not recorded for whole dynamic targets,
so <code>tar_age()</code> is not a good fit for dynamic branching.
To invalidate dynamic branches at regular intervals,
it is recommended to use <code>targets::tar_older()</code> in combination
with <code>targets::tar_invalidate()</code> right before calling <code>tar_make()</code>.
For example,
<code>tar_invalidate(any_of(tar_older(Sys.time - as.difftime(1, units = "weeks"))))</code> # nolint
invalidates all targets more than a week old. Then, the next <code>tar_make()</code>
will rerun those targets.
</p>


<h3>Cue objects</h3>

<p>A cue object is an object generated by <code>targets::tar_cue()</code>,
<code>tarchetypes::tar_cue_force()</code>, or similar. It is
a collection of decision rules that decide when a target
is invalidated/outdated (e.g. when <code>tar_make()</code> or similar
reruns the target). You can supply these cue objects to the
<code>tar_target()</code> function or similar. For example,
<code>tar_target(x, run_stuff(), cue = tar_cue(mode = "always"))</code>
is a target that always calls <code>run_stuff()</code> during <code>tar_make()</code>
and always shows as invalidated/outdated in <code>tar_outdated()</code>,
<code>tar_visnetwork()</code>, and similar functions.
</p>


<h3>See Also</h3>

<p>Other cues: 
<code><a href="#topic+tar_age">tar_age</a>()</code>,
<code><a href="#topic+tar_cue_age_raw">tar_cue_age_raw</a>()</code>,
<code><a href="#topic+tar_cue_force">tar_cue_force</a>()</code>,
<code><a href="#topic+tar_cue_skip">tar_cue_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  list(
    targets::tar_target(
      data,
      data.frame(x = seq_len(26)),
      cue = tarchetypes::tar_cue_age(
        name = data,
        age = as.difftime(0.5, units = "secs")
      )
    )
  )
})
targets::tar_make()
Sys.sleep(0.6)
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_cue_age_raw'>Cue to run a target when the last run reaches a certain age
(raw version)</h2><span id='topic+tar_cue_age_raw'></span>

<h3>Description</h3>

<p><code>tar_cue_age_raw()</code> acts like <code>tar_cue_age()</code>
except the <code>name</code> argument is a character string,
not a symbol. <code>tar_cue_age_raw()</code> creates a cue object to
rerun a target if the most recent output data becomes old enough.
The age of the target is determined by <code>targets::tar_timestamp()</code>,
and the way the time stamp is calculated is explained
in the Details section of the help file of that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cue_age_raw(
  name,
  age,
  command = TRUE,
  depend = TRUE,
  format = TRUE,
  repository = TRUE,
  iteration = TRUE,
  file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cue_age_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_age">age</code></td>
<td>
<p>A <code>difftime</code> object of length 1, such as
<code>as.difftime(3, units = "days")</code>. If the target's output data
files are older than <code>age</code> (according to the most recent
time stamp over all the target's output files)
then the target will rerun.
On the other hand, if at least one data file is
younger than <code>Sys.time() - age</code>, then the ordinary
invalidation rules apply, and the target may or not rerun.
If you want to force the target to run every 3 days,
for example, set <code>age = as.difftime(3, units = "days")</code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_command">command</code></td>
<td>
<p>Logical, whether to rerun the target if command changed
since last time.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_depend">depend</code></td>
<td>
<p>Logical, whether to rerun the target if the value of one
of the dependencies changed.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_age_raw_+3A_file">file</code></td>
<td>
<p>Logical, whether to rerun the target if the file(s) with the
return value changed or at least one is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_cue_age_raw()</code> uses the time stamps from <code>tar_meta()$time</code>.
If no time stamp is recorded, the cue defaults to the ordinary
invalidation rules (i.e. <code>mode = "thorough"</code> in <code>targets::tar_cue()</code>).
</p>


<h3>Value</h3>

<p>A cue object. See the &quot;Cue objects&quot; section for background.
</p>


<h3>Dynamic branches at regular time intervals</h3>

<p>Time stamps are not recorded for whole dynamic targets,
so <code>tar_age()</code> is not a good fit for dynamic branching.
To invalidate dynamic branches at regular intervals,
it is recommended to use <code>targets::tar_older()</code> in combination
with <code>targets::tar_invalidate()</code> right before calling <code>tar_make()</code>.
For example,
<code>tar_invalidate(any_of(tar_older(Sys.time - as.difftime(1, units = "weeks"))))</code> # nolint
invalidates all targets more than a week old. Then, the next <code>tar_make()</code>
will rerun those targets.
</p>


<h3>Cue objects</h3>

<p>A cue object is an object generated by <code>targets::tar_cue()</code>,
<code>tarchetypes::tar_cue_force()</code>, or similar. It is
a collection of decision rules that decide when a target
is invalidated/outdated (e.g. when <code>tar_make()</code> or similar
reruns the target). You can supply these cue objects to the
<code>tar_target()</code> function or similar. For example,
<code>tar_target(x, run_stuff(), cue = tar_cue(mode = "always"))</code>
is a target that always calls <code>run_stuff()</code> during <code>tar_make()</code>
and always shows as invalidated/outdated in <code>tar_outdated()</code>,
<code>tar_visnetwork()</code>, and similar functions.
</p>


<h3>See Also</h3>

<p>Other cues: 
<code><a href="#topic+tar_age">tar_age</a>()</code>,
<code><a href="#topic+tar_cue_age">tar_cue_age</a>()</code>,
<code><a href="#topic+tar_cue_force">tar_cue_force</a>()</code>,
<code><a href="#topic+tar_cue_skip">tar_cue_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  list(
    targets::tar_target(
      data,
      data.frame(x = seq_len(26)),
      cue = tarchetypes::tar_cue_age_raw(
        name = "data",
        age = as.difftime(0.5, units = "secs")
      )
    )
  )
})
targets::tar_make()
Sys.sleep(0.6)
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_cue_force'>Cue to force a target to run if a condition is true</h2><span id='topic+tar_cue_force'></span>

<h3>Description</h3>

<p><code>tar_cue_force()</code> creates a cue object to
force a target to run if an arbitrary condition evaluates to <code>TRUE</code>.
Supply the returned cue object to the <code>cue</code> argument of
<code>targets::tar_target()</code> or similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cue_force(
  condition,
  command = TRUE,
  depend = TRUE,
  format = TRUE,
  repository = TRUE,
  iteration = TRUE,
  file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cue_force_+3A_condition">condition</code></td>
<td>
<p>Logical vector evaluated locally when the target is
defined. If any element of <code>condition</code> is <code>TRUE</code>, the target will
definitely rerun when the pipeline runs.
Otherwise, the target may or may not rerun, depending
on the other invalidation rules. <code>condition</code> is evaluated
when this cue factory is called, so the condition cannot
depend on upstream targets, and it should be quick to calculate.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_command">command</code></td>
<td>
<p>Logical, whether to rerun the target if command changed
since last time.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_depend">depend</code></td>
<td>
<p>Logical, whether to rerun the target if the value of one
of the dependencies changed.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_force_+3A_file">file</code></td>
<td>
<p>Logical, whether to rerun the target if the file(s) with the
return value changed or at least one is missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_cue_force()</code> and <code><a href="#topic+tar_force">tar_force()</a></code> operate differently.
The former defines a cue object based on an eagerly evaluated
condition, and <code><a href="#topic+tar_force">tar_force()</a></code> puts the condition in a special
upstream target that always runs. Unlike <code>tar_cue_force()</code>,
the condition in <code><a href="#topic+tar_force">tar_force()</a></code> can depend on upstream targets,
but the drawback is that targets defined with <code><a href="#topic+tar_force">tar_force()</a></code>
will always show up as outdated in functions like <code>tar_outdated()</code>
and <code>tar_visnetwork()</code> even though <code>tar_make()</code> may still
skip the main target if the condition is not met.
</p>


<h3>Value</h3>

<p>A cue object. See the &quot;Cue objects&quot; section for background.
</p>


<h3>Cue objects</h3>

<p>A cue object is an object generated by <code>targets::tar_cue()</code>,
<code>tarchetypes::tar_cue_force()</code>, or similar. It is
a collection of decision rules that decide when a target
is invalidated/outdated (e.g. when <code>tar_make()</code> or similar
reruns the target). You can supply these cue objects to the
<code>tar_target()</code> function or similar. For example,
<code>tar_target(x, run_stuff(), cue = tar_cue(mode = "always"))</code>
is a target that always calls <code>run_stuff()</code> during <code>tar_make()</code>
and always shows as invalidated/outdated in <code>tar_outdated()</code>,
<code>tar_visnetwork()</code>, and similar functions.
</p>


<h3>See Also</h3>

<p>Other cues: 
<code><a href="#topic+tar_age">tar_age</a>()</code>,
<code><a href="#topic+tar_cue_age">tar_cue_age</a>()</code>,
<code><a href="#topic+tar_cue_age_raw">tar_cue_age_raw</a>()</code>,
<code><a href="#topic+tar_cue_skip">tar_cue_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  list(
    targets::tar_target(
      data,
      data.frame(x = seq_len(26)),
      cue = tarchetypes::tar_cue_force(1 &gt; 0)
    )
  )
})
targets::tar_make()
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_cue_skip'>Cue to skip a target if a condition is true</h2><span id='topic+tar_cue_skip'></span>

<h3>Description</h3>

<p><code>tar_cue_skip()</code> creates a cue object to
skip a target if an arbitrary condition evaluates to <code>TRUE</code>.
The target still builds if it was never built before.
Supply the returned cue object to the <code>cue</code> argument of
<code>targets::tar_target()</code> or similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cue_skip(
  condition,
  command = TRUE,
  depend = TRUE,
  format = TRUE,
  repository = TRUE,
  iteration = TRUE,
  file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cue_skip_+3A_condition">condition</code></td>
<td>
<p>Logical vector evaluated locally when the target is
defined. If any element of <code>condition</code> is <code>TRUE</code>, the pipeline
will skip the target unless the target has never been built before.
If all elements of <code>condition</code> are <code>FALSE</code>, then
the target may or may not rerun, depending
on the other invalidation rules. <code>condition</code> is evaluated
when this cue factory is called, so the condition cannot
depend on upstream targets, and it should be quick to calculate.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_command">command</code></td>
<td>
<p>Logical, whether to rerun the target if command changed
since last time.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_depend">depend</code></td>
<td>
<p>Logical, whether to rerun the target if the value of one
of the dependencies changed.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="targets.html#topic+tar_target">tar_target()</a></code> or <code><a href="targets.html#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_skip_+3A_file">file</code></td>
<td>
<p>Logical, whether to rerun the target if the file(s) with the
return value changed or at least one is missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cue object. See the &quot;Cue objects&quot; section for background.
</p>


<h3>Cue objects</h3>

<p>A cue object is an object generated by <code>targets::tar_cue()</code>,
<code>tarchetypes::tar_cue_force()</code>, or similar. It is
a collection of decision rules that decide when a target
is invalidated/outdated (e.g. when <code>tar_make()</code> or similar
reruns the target). You can supply these cue objects to the
<code>tar_target()</code> function or similar. For example,
<code>tar_target(x, run_stuff(), cue = tar_cue(mode = "always"))</code>
is a target that always calls <code>run_stuff()</code> during <code>tar_make()</code>
and always shows as invalidated/outdated in <code>tar_outdated()</code>,
<code>tar_visnetwork()</code>, and similar functions.
</p>


<h3>See Also</h3>

<p>Other cues: 
<code><a href="#topic+tar_age">tar_age</a>()</code>,
<code><a href="#topic+tar_cue_age">tar_cue_age</a>()</code>,
<code><a href="#topic+tar_cue_age_raw">tar_cue_age_raw</a>()</code>,
<code><a href="#topic+tar_cue_force">tar_cue_force</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  list(
    targets::tar_target(
      data,
      data.frame(x = seq_len(26)),
      cue = tarchetypes::tar_cue_skip(1 &gt; 0)
    )
  )
})
targets::tar_make()
targets::tar_script({
  library(tarchetypes)
  list(
    targets::tar_target(
      data,
      data.frame(x = seq_len(25)), # Change the command.
      cue = tarchetypes::tar_cue_skip(1 &gt; 0)
    )
  )
})
targets::tar_make()
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_download'>Target that downloads URLs.</h2><span id='topic+tar_download'></span>

<h3>Description</h3>

<p>Create a target that downloads file from one or more URLs
and automatically reruns when the remote data changes
(according to the ETags or last-modified time stamps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_download(
  name,
  urls,
  paths,
  method = NULL,
  quiet = TRUE,
  mode = "w",
  cacheOK = TRUE,
  extra = NULL,
  headers = NULL,
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_download_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_urls">urls</code></td>
<td>
<p>Character vector of URLs to track and download.
Must be known and declared before the pipeline runs.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_paths">paths</code></td>
<td>
<p>Character vector of local file paths to
download each of the URLs.
Must be known and declared before the pipeline runs.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_method">method</code></td>
<td>
<p>Method to be used for downloading files.  Current
download methods are <code>"internal"</code>, <code>"libcurl"</code>,
<code>"wget"</code>, <code>"curl"</code> and <code>"wininet"</code> (Windows
only), and there is a value <code>"auto"</code>: see &lsquo;Details&rsquo; and
&lsquo;Note&rsquo;.
</p>
<p>The method can also be set through the option
<code>"download.file.method"</code>: see <code><a href="base.html#topic+options">options</a>()</code>.
</p>
</td></tr>
<tr><td><code id="tar_download_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress status messages (if any), and
the progress bar.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_mode">mode</code></td>
<td>
<p>character.  The mode with which to write the file.  Useful
values are <code>"w"</code>, <code>"wb"</code> (binary), <code>"a"</code> (append) and
<code>"ab"</code>.  Not used for methods <code>"wget"</code> and <code>"curl"</code>.
See also &lsquo;Details&rsquo;, notably about using <code>"wb"</code> for Windows.
</p>
</td></tr>
<tr><td><code id="tar_download_+3A_cacheok">cacheOK</code></td>
<td>
<p>logical.  Is a server-side cached value acceptable?</p>
</td></tr>
<tr><td><code id="tar_download_+3A_extra">extra</code></td>
<td>
<p>character vector of additional command-line arguments for
the <code>"wget"</code> and <code>"curl"</code> methods.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_headers">headers</code></td>
<td>
<p>named character vector of additional HTTP headers to
use in HTTP[S] requests.  It is ignored for non-HTTP[S] URLs.  The
<code>User-Agent</code> header taken from the <code>HTTPUserAgent</code> option
(see <code><a href="base.html#topic+options">options</a></code>) is automatically used as the first header.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_download_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_download_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_download_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_download_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_download_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_download_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_download()</code> creates a pair of targets, one upstream
and one downstream. The upstream target uses <code>format = "url"</code>
(see <code>targets::tar_target()</code>) to track files at one or more URLs,
and automatically invalidate the target if the ETags
or last-modified time stamps change. The downstream target
depends on the upstream one, downloads the files,
and tracks them using <code>format = "file"</code>.
</p>


<h3>Value</h3>

<p>A list of two target objects, one upstream and one downstream.
The upstream one watches a URL for changes, and the downstream one
downloads it.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other targets with custom invalidation rules: 
<code><a href="#topic+tar_change">tar_change</a>()</code>,
<code><a href="#topic+tar_force">tar_force</a>()</code>,
<code><a href="#topic+tar_skip">tar_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_download(
      x,
      urls = c("https://httpbin.org/etag/test", "https://r-project.org"),
      paths = c("downloaded_file_1", "downloaded_file_2")
    )
  )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_download_run'>Download multiple URLs and return the local paths.</h2><span id='topic+tar_download_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_download_run(urls, paths, method, quiet, mode, cacheOK, extra, headers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_download_run_+3A_urls">urls</code></td>
<td>
<p>Character vector of URLs to track and download.
Must be known and declared before the pipeline runs.</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_paths">paths</code></td>
<td>
<p>Character vector of local file paths to
download each of the URLs.
Must be known and declared before the pipeline runs.</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_method">method</code></td>
<td>
<p>Method to be used for downloading files.  Current
download methods are <code>"internal"</code>, <code>"libcurl"</code>,
<code>"wget"</code>, <code>"curl"</code> and <code>"wininet"</code> (Windows
only), and there is a value <code>"auto"</code>: see &lsquo;Details&rsquo; and
&lsquo;Note&rsquo;.
</p>
<p>The method can also be set through the option
<code>"download.file.method"</code>: see <code><a href="base.html#topic+options">options</a>()</code>.
</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, suppress status messages (if any), and
the progress bar.</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_mode">mode</code></td>
<td>
<p>character.  The mode with which to write the file.  Useful
values are <code>"w"</code>, <code>"wb"</code> (binary), <code>"a"</code> (append) and
<code>"ab"</code>.  Not used for methods <code>"wget"</code> and <code>"curl"</code>.
See also &lsquo;Details&rsquo;, notably about using <code>"wb"</code> for Windows.
</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_cacheok">cacheOK</code></td>
<td>
<p>logical.  Is a server-side cached value acceptable?</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_extra">extra</code></td>
<td>
<p>character vector of additional command-line arguments for
the <code>"wget"</code> and <code>"curl"</code> methods.</p>
</td></tr>
<tr><td><code id="tar_download_run_+3A_headers">headers</code></td>
<td>
<p>named character vector of additional HTTP headers to
use in HTTP[S] requests.  It is ignored for non-HTTP[S] URLs.  The
<code>User-Agent</code> header taken from the <code>HTTPUserAgent</code> option
(see <code><a href="base.html#topic+options">options</a></code>) is automatically used as the first header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of file paths where the URLs
were downloaded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
  tarchetypes::tar_download_run(
    urls = "https://httpbin.org/etag/test",
    paths = tempfile(),
    method = NULL,
    quiet = TRUE,
    mode = "w",
    cacheOK = NULL,
    extra = NULL,
    headers = NULL
  )
}
</code></pre>

<hr>
<h2 id='tar_eval'>Evaluate multiple expressions created with symbol substitution.</h2><span id='topic+tar_eval'></span>

<h3>Description</h3>

<p>Loop over a grid of values, create an expression object
from each one, and then evaluate that expression.
Helps with general metaprogramming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_eval(expr, values, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_eval_+3A_expr">expr</code></td>
<td>
<p>Starting expression. Values are iteratively substituted
in place of symbols in <code>expr</code> to create each new expression,
and then each new expression is evaluated.</p>
</td></tr>
<tr><td><code id="tar_eval_+3A_values">values</code></td>
<td>
<p>List of values to substitute into <code>expr</code> to create
the expressions. All elements of <code>values</code> must have the same length.</p>
</td></tr>
<tr><td><code id="tar_eval_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the new expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of return values from the generated expression objects.
Often, these values are target objects.
See the &quot;Target objects&quot; section for background
on target objects specifically.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Metaprogramming utilities: 
<code><a href="#topic+tar_eval_raw">tar_eval_raw</a>()</code>,
<code><a href="#topic+tar_sub">tar_sub</a>()</code>,
<code><a href="#topic+tar_sub_raw">tar_sub_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tar_map() is incompatible with tar_render() because the latter
# operates on preexisting tar_target() objects. By contrast,
# tar_eval() and tar_sub() iterate over the literal code
# farther upstream.
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = list("file1.Rmd", "file2.Rmd")
)
tar_sub(list(name, file), values = values)
tar_sub(tar_render(name, file), values = values)
path &lt;- tempfile()
file.create(path)
str(tar_eval(tar_render(name, path), values = values))
# So in your _targets.R file, you can define a pipeline like as below.
# Just make sure to set a unique name for each target
# (which tar_map() does automatically).
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = c(path, path)
)
list(
  tar_eval(tar_render(name, file), values = values)
)
</code></pre>

<hr>
<h2 id='tar_eval_raw'>Evaluate multiple expressions created with symbol substitution
(raw version).</h2><span id='topic+tar_eval_raw'></span>

<h3>Description</h3>

<p>Loop over a grid of values, create an expression object
from each one, and then evaluate that expression.
Helps with general metaprogramming. Unlike <code><a href="#topic+tar_sub">tar_sub()</a></code>,
which quotes the <code>expr</code> argument, <code>tar_sub_raw()</code> assumes <code>expr</code>
is an expression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_eval_raw(expr, values, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_eval_raw_+3A_expr">expr</code></td>
<td>
<p>Expression object with the starting expression.
Values are iteratively substituted
in place of symbols in <code>expr</code> to create each new expression,
and then each expression is evaluated.</p>
</td></tr>
<tr><td><code id="tar_eval_raw_+3A_values">values</code></td>
<td>
<p>List of values to substitute into <code>expr</code> to create
the expressions. All elements of <code>values</code> must have the same length.</p>
</td></tr>
<tr><td><code id="tar_eval_raw_+3A_envir">envir</code></td>
<td>
<p>Environment in which to evaluate the new expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of return values from evaluating the expression objects.
Often, these values are target objects.
See the &quot;Target objects&quot; section for background
on target objects specifically.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Metaprogramming utilities: 
<code><a href="#topic+tar_eval">tar_eval</a>()</code>,
<code><a href="#topic+tar_sub">tar_sub</a>()</code>,
<code><a href="#topic+tar_sub_raw">tar_sub_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tar_map() is incompatible with tar_render() because the latter
# operates on preexisting tar_target() objects. By contrast,
# tar_eval_raw() and tar_sub_raw() iterate over code farther upstream.
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = c("file1.Rmd", "file2.Rmd")
)
tar_sub_raw(quote(list(name, file)), values = values)
tar_sub_raw(quote(tar_render(name, file)), values = values)
path &lt;- tempfile()
file.create(path)
str(tar_eval_raw(quote(tar_render(name, path)), values = values))
# So in your _targets.R file, you can define a pipeline like as below.
# Just make sure to set a unique name for each target
# (which tar_map() does automatically).
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = c(path, path)
)
list(
  tar_eval_raw(quote(tar_render(name, file)), values = values)
)
</code></pre>

<hr>
<h2 id='tar_file_read'>Track a file and read the contents.</h2><span id='topic+tar_file_read'></span>

<h3>Description</h3>

<p>Create a pair of targets: one to
track a file with <code>format = "file"</code>, and another
to read the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_file_read(
  name,
  command,
  read,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  format_file = c("file", "file_fast"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_file_read_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_command">command</code></td>
<td>
<p>R code that runs in the <code>format = "file"</code> target
and returns the file to be tracked.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_read">read</code></td>
<td>
<p>R code to read the file. Must include <code>!!.x</code>
where the file path goes: for example,
<code>read = readr::read_csv(file = !!.x, col_types = readr::cols())</code>.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_format_file">format_file</code></td>
<td>
<p>Storage format of the file target, either
<code>"file"</code> or <code>"file_fast"</code>.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_file_read_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_file_read_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_file_read_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_file_read_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two new target objects to track a file
and read the contents.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  tar_file_read(data, get_path(), read_csv(file = !!.x, col_types = cols()))
})
targets::tar_manifest()
})
}
</code></pre>

<hr>
<h2 id='tar_files'>Dynamic branching over output or input files.</h2><span id='topic+tar_files'></span>

<h3>Description</h3>

<p>Dynamic branching over output or input files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_files(
  name,
  command,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = c("file", "file_fast", "url", "aws_file"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_files_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_format">format</code></td>
<td>
<p>Character of length 1.
Must be <code>"file"</code>, <code>"url"</code>, or <code>"aws_file"</code>. See the <code>format</code>
argument of <code>targets::tar_target()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_files_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_files_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_files()</code> creates a pair of targets, one upstream
and one downstream. The upstream target does some work
and returns some file paths, and the downstream
target is a pattern that applies <code>format = "file"</code>,
<code>format = "file_fast"</code>, or <code>format = "url"</code>.
(URLs are input-only, they must already exist beforehand.)
This is the correct way to dynamically
iterate over file/url targets. It makes sure any downstream patterns
only rerun some of their branches if the files/urls change.
For more information, visit
<a href="https://github.com/ropensci/targets/issues/136">https://github.com/ropensci/targets/issues/136</a> and
<a href="https://github.com/ropensci/drake/issues/1302">https://github.com/ropensci/drake/issues/1302</a>.
</p>


<h3>Value</h3>

<p>A list of two targets, one upstream and one downstream.
The upstream one does some work and returns some file paths,
and the downstream target is a pattern that applies <code>format = "file"</code>,
<code>format = "file_fast"</code>, or <code>format = "url"</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Dynamic branching over files: 
<code><a href="#topic+tar_files_input">tar_files_input</a>()</code>,
<code><a href="#topic+tar_files_input_raw">tar_files_input_raw</a>()</code>,
<code><a href="#topic+tar_files_raw">tar_files_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Do not use temp files in real projects
  # or else your targets will always rerun.
  paths &lt;- unlist(replicate(2, tempfile()))
  file.create(paths)
  list(
    tarchetypes::tar_files(x, paths)
  )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_files_input'>Dynamic branching over input files or URLs</h2><span id='topic+tar_files_input'></span>

<h3>Description</h3>

<p>Dynamic branching over input files or URLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_files_input(
  name,
  files,
  batches = length(files),
  format = c("file", "file_fast", "url", "aws_file"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_files_input_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_files">files</code></td>
<td>
<p>Nonempty character vector of known existing input files
to track for changes.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_batches">batches</code></td>
<td>
<p>Positive integer of length 1, number of batches
to partition the files. The default is one file per batch
(maximum number of batches) which is simplest to handle but
could cause a lot of overhead and consume a lot of computing resources.
Consider reducing the number of batches below the number of files
for heavy workloads.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_format">format</code></td>
<td>
<p>Character, either <code>"file"</code>, <code>"file_fast"</code>, or <code>"url"</code>.
See the <code>format</code> argument of <code>targets::tar_target()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_iteration">iteration</code></td>
<td>
<p>Character, iteration method. Must be a method
supported by the <code>iteration</code> argument of <code>targets::tar_target()</code>.
The iteration method for the upstream target is always <code>"list"</code>
in order to support batching.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_input_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_files_input()</code> is like <code>tar_files()</code>
but more convenient when the files in question already
exist and are known in advance. Whereas <code>tar_files()</code>
always appears outdated (e.g. with <code>tar_outdated()</code>)
because it always needs to check which files it needs to
branch over, <code>tar_files_input()</code> will appear up to date
if the files have not changed since last <code>tar_make()</code>.
In addition, <code>tar_files_input()</code> automatically groups
input files into batches to reduce overhead and
increase the efficiency of parallel processing.
</p>
<p><code>tar_files_input()</code> creates a pair of targets, one upstream
and one downstream. The upstream target does some work
and returns some file paths, and the downstream
target is a pattern that applies <code>format = "file"</code>,
<code>format = "file_fast"</code>, or <code>format = "url"</code>.
This is the correct way to dynamically
iterate over file/url targets. It makes sure any downstream patterns
only rerun some of their branches if the files/urls change.
For more information, visit
<a href="https://github.com/ropensci/targets/issues/136">https://github.com/ropensci/targets/issues/136</a> and
<a href="https://github.com/ropensci/drake/issues/1302">https://github.com/ropensci/drake/issues/1302</a>.
</p>


<h3>Value</h3>

<p>A list of two targets, one upstream and one downstream.
The upstream one does some work and returns some file paths,
and the downstream target is a pattern that applies <code>format = "file"</code>
or <code>format = "url"</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Dynamic branching over files: 
<code><a href="#topic+tar_files">tar_files</a>()</code>,
<code><a href="#topic+tar_files_input_raw">tar_files_input_raw</a>()</code>,
<code><a href="#topic+tar_files_raw">tar_files_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Do not use temp files in real projects
  # or else your targets will always rerun.
  paths &lt;- unlist(replicate(4, tempfile()))
  file.create(paths)
  list(
    tarchetypes::tar_files_input(
      x,
      paths,
      batches = 2
    )
  )
})
targets::tar_make()
targets::tar_read(x)
targets::tar_read(x, branches = 1)
})
}
</code></pre>

<hr>
<h2 id='tar_files_input_raw'>Dynamic branching over input files or URLs (raw version).</h2><span id='topic+tar_files_input_raw'></span>

<h3>Description</h3>

<p>Dynamic branching over input files or URLs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_files_input_raw(
  name,
  files,
  batches = length(files),
  format = c("file", "file_fast", "url", "aws_file"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_files_input_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_files">files</code></td>
<td>
<p>Nonempty character vector of known existing input files
to track for changes.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_batches">batches</code></td>
<td>
<p>Positive integer of length 1, number of batches
to partition the files. The default is one file per batch
(maximum number of batches) which is simplest to handle but
could cause a lot of overhead and consume a lot of computing resources.
Consider reducing the number of batches below the number of files
for heavy workloads.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_format">format</code></td>
<td>
<p>Character, either <code>"file"</code>, <code>"file_fast"</code>, or <code>"url"</code>.
See the <code>format</code> argument of <code>targets::tar_target()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character, iteration method. Must be a method
supported by the <code>iteration</code> argument of <code>targets::tar_target()</code>.
The iteration method for the upstream target is always <code>"list"</code>
in order to support batching.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_files_input_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_files_input_raw()</code> is similar to <code><a href="#topic+tar_files_input">tar_files_input()</a></code>
except the <code>name</code> argument must be a character string.
</p>
<p><code>tar_files_input_raw()</code> creates a pair of targets, one upstream
and one downstream. The upstream target does some work
and returns some file paths, and the downstream
target is a pattern that applies <code>format = "file"</code>
or <code>format = "url"</code>.
This is the correct way to dynamically
iterate over file/url targets. It makes sure any downstream patterns
only rerun some of their branches if the files/urls change.
For more information, visit
<a href="https://github.com/ropensci/targets/issues/136">https://github.com/ropensci/targets/issues/136</a> and
<a href="https://github.com/ropensci/drake/issues/1302">https://github.com/ropensci/drake/issues/1302</a>.
</p>


<h3>Value</h3>

<p>A list of two targets, one upstream and one downstream.
The upstream one does some work and returns some file paths,
and the downstream target is a pattern that applies <code>format = "file"</code>
or <code>format = "url"</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Dynamic branching over files: 
<code><a href="#topic+tar_files">tar_files</a>()</code>,
<code><a href="#topic+tar_files_input">tar_files_input</a>()</code>,
<code><a href="#topic+tar_files_raw">tar_files_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Do not use temp files in real projects
  # or else your targets will always rerun.
  paths &lt;- unlist(replicate(4, tempfile()))
  file.create(paths)
  list(
    tarchetypes::tar_files_input_raw(
      "x",
      paths,
      batches = 2
    )
  )
})
targets::tar_make()
targets::tar_read(x)
targets::tar_read(x, branches = 1)
})
}
</code></pre>

<hr>
<h2 id='tar_files_raw'>Dynamic branching over output or input files (raw version).</h2><span id='topic+tar_files_raw'></span>

<h3>Description</h3>

<p>Dynamic branching over output or input files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_files_raw(
  name,
  command,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = c("file", "file_fast", "url", "aws_file"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_files_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_format">format</code></td>
<td>
<p>Character of length 1.
Must be <code>"file"</code>, <code>"url"</code>, or <code>"aws_file"</code>. See the <code>format</code>
argument of <code>targets::tar_target()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_files_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_files_raw()</code> is similar to <code><a href="#topic+tar_files">tar_files()</a></code>
except the <code>name</code> argument must be a character string
and <code>command</code> must be a language object.
</p>
<p><code>tar_files_raw()</code> creates a pair of targets, one upstream
and one downstream. The upstream target does some work
and returns some file paths, and the downstream
target is a pattern that applies <code>format = "file"</code>,
<code>format = "file_fast"</code>, or <code>format = "url"</code>.
(URLs are input-only, they must already exist beforehand.)
This is the correct way to dynamically
iterate over file/url targets. It makes sure any downstream patterns
only rerun some of their branches if the files/urls change.
For more information, visit
<a href="https://github.com/ropensci/targets/issues/136">https://github.com/ropensci/targets/issues/136</a> and
<a href="https://github.com/ropensci/drake/issues/1302">https://github.com/ropensci/drake/issues/1302</a>.
</p>


<h3>Value</h3>

<p>A list of two targets, one upstream and one downstream.
The upstream one does some work and returns some file paths,
and the downstream target is a pattern that applies <code>format = "file"</code>,
<code>format = "file_fast"</code>, or <code>format = "url"</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Dynamic branching over files: 
<code><a href="#topic+tar_files">tar_files</a>()</code>,
<code><a href="#topic+tar_files_input">tar_files_input</a>()</code>,
<code><a href="#topic+tar_files_input_raw">tar_files_input_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Do not use temp files in real projects
  # or else your targets will always rerun.
  paths &lt;- unlist(replicate(2, tempfile()))
  file.create(paths)
  command &lt;- as.call(list(`c`, paths))
  list(
    tarchetypes::tar_files_raw("x", command)
  )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_force'>Target with a custom condition to force execution.</h2><span id='topic+tar_force'></span>

<h3>Description</h3>

<p>Create a target that always runs if a user-defined
condition rule is met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_force(
  name,
  command,
  force,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_force_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_force">force</code></td>
<td>
<p>R code for the condition that forces a build.
If it evaluates to <code>TRUE</code>, then your work will run during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to arguments <code>command</code> and <code>force</code>.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_force_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_force_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_force_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_force_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_force_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code>
to customize the rules that decide whether the target is up to date.
Only applies to the downstream target. The upstream target always runs.</p>
</td></tr>
<tr><td><code id="tar_force_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_force()</code> creates a target that always runs
when a custom condition is met. The implementation builds
on top of <code><a href="#topic+tar_change">tar_change()</a></code>. Thus, a pair of targets is created:
an upstream auxiliary target to indicate the custom condition
and a downstream target that responds to it and does your work.
</p>
<p><code>tar_force()</code> does not actually use <code><a href="#topic+tar_cue_force">tar_cue_force()</a></code>, and the
mechanism is totally different.
Because the upstream target always runs,
<code>tar_outdated()</code> and <code>tar_visnetwork()</code> will always
show both targets as outdated. However, <code>tar_make()</code> will still
skip the downstream one if the upstream custom condition is not met.
</p>


<h3>Value</h3>

<p>A list of 2 targets objects: one to indicate whether the custom
condition is met, and another to respond to it and do your
actual work.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other targets with custom invalidation rules: 
<code><a href="#topic+tar_change">tar_change</a>()</code>,
<code><a href="#topic+tar_download">tar_download</a>()</code>,
<code><a href="#topic+tar_skip">tar_skip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_force(x, tempfile(), force = 1 &gt; 0)
  )
})
targets::tar_make()
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_force_change'>Convert a condition into a change.</h2><span id='topic+tar_force_change'></span>

<h3>Description</h3>

<p>Supports <code><a href="#topic+tar_force">tar_force()</a></code>. This is really an internal function
and not meant to be called by users directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_force_change(condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_force_change_+3A_condition">condition</code></td>
<td>
<p>Logical, whether to run the downstream target
in <code><a href="#topic+tar_force">tar_force()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hash that changes when the downstream target is supposed to run.
</p>

<hr>
<h2 id='tar_formats'>Target formats</h2><span id='topic+tar_formats'></span><span id='topic+tar_url'></span><span id='topic+tar_file'></span><span id='topic+tar_file_fast'></span><span id='topic+tar_rds'></span><span id='topic+tar_qs'></span><span id='topic+tar_keras'></span><span id='topic+tar_torch'></span><span id='topic+tar_format_feather'></span><span id='topic+tar_parquet'></span><span id='topic+tar_fst'></span><span id='topic+tar_fst_dt'></span><span id='topic+tar_fst_tbl'></span><span id='topic+tar_aws_file'></span><span id='topic+tar_aws_rds'></span><span id='topic+tar_aws_qs'></span><span id='topic+tar_aws_keras'></span><span id='topic+tar_aws_torch'></span><span id='topic+tar_format_aws_feather'></span><span id='topic+tar_aws_parquet'></span><span id='topic+tar_aws_fst'></span><span id='topic+tar_aws_fst_dt'></span><span id='topic+tar_aws_fst_tbl'></span>

<h3>Description</h3>

<p>Target archetypes for specialized storage formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_url(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_file(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_file_fast(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_rds(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_qs(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_keras(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_torch(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_format_feather(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_parquet(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_fst(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_fst_dt(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_fst_tbl(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_file(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_rds(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_qs(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_keras(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_torch(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_format_aws_feather(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_parquet(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_fst(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_fst_dt(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)

tar_aws_fst_tbl(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_formats_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_pattern">pattern</code></td>
<td>
<p>Language to define branching for a target.
For example, in a pipeline with numeric vector targets <code>x</code> and <code>y</code>,
<code>tar_target(z, x + y, pattern = map(x, y))</code> implicitly defines
branches of <code>z</code> that each compute <code>x[1] + y[1]</code>, <code>x[2] + y[2]</code>,
and so on. See the user manual for details.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_formats_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_formats_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_formats_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_formats_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_formats_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are shorthand for targets with specialized
storage formats. For example, <code>tar_qs(name, fun())</code> is equivalent to
<code>tar_target(name, fun(), format = "qs")</code>.
For details on specialized storage formats, open the help file of the
<code>targets::tar_target()</code> function and read about the <code>format</code> argument.
</p>


<h3>Value</h3>

<p>A <code>tar_target()</code> object with the eponymous storage format.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script(
  list(
    tarchetypes::tar_rds(x, 1)
  )
)
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_group_by'>Group a data frame target by one or more variables.</h2><span id='topic+tar_group_by'></span>

<h3>Description</h3>

<p>Create a target that outputs a grouped data frame
with <code>dplyr::group_by()</code> and <code>targets::tar_group()</code>. Downstream
dynamic branching targets will iterate over the groups of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_by(
  name,
  command,
  ...,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_by_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_...">...</code></td>
<td>
<p>Symbols, variables in the output data frame to group by.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_by_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_by_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_by_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_group_by_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object to generate a grouped data frame
to allows downstream dynamic targets to branch over the
groups of rows.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Grouped data frame targets: 
<code><a href="#topic+tar_group_count">tar_group_count</a>()</code>,
<code><a href="#topic+tar_group_select">tar_group_select</a>()</code>,
<code><a href="#topic+tar_group_size">tar_group_size</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  produce_data &lt;- function() {
    expand.grid(var1 = c("a", "b"), var2 = c("c", "d"), rep = c(1, 2, 3))
  }
  list(
    tarchetypes::tar_group_by(data, produce_data(), var1, var2),
    tar_target(group, data, pattern = map(data))
  )
})
targets::tar_make()
# Read the first row group:
targets::tar_read(group, branches = 1)
# Read the second row group:
targets::tar_read(group, branches = 2)
})
}
</code></pre>

<hr>
<h2 id='tar_group_by_run'>Generate a grouped data frame within tar_group_by()</h2><span id='topic+tar_group_by_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_by_run(data, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_by_run_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
<tr><td><code id="tar_group_by_run_+3A_by">by</code></td>
<td>
<p>Nonempty character vector of names of variables to group by.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_group_count'>Group the rows of a data frame into a given number groups</h2><span id='topic+tar_group_count'></span>

<h3>Description</h3>

<p>Create a target that outputs a grouped data frame
for downstream dynamic branching. Set the maximum
number of groups using <code>count</code>. The number of rows per group
varies but is approximately uniform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_count(
  name,
  command,
  count,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_count_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_count">count</code></td>
<td>
<p>Positive integer, maximum number of row groups</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_count_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_count_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_count_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_group_count_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object to generate a grouped data frame
to allows downstream dynamic targets to branch over the
groups of rows.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Grouped data frame targets: 
<code><a href="#topic+tar_group_by">tar_group_by</a>()</code>,
<code><a href="#topic+tar_group_select">tar_group_select</a>()</code>,
<code><a href="#topic+tar_group_size">tar_group_size</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  produce_data &lt;- function() {
    expand.grid(var1 = c("a", "b"), var2 = c("c", "d"), rep = c(1, 2, 3))
  }
  list(
    tarchetypes::tar_group_count(data, produce_data(), count = 2),
    tar_target(group, data, pattern = map(data))
  )
})
targets::tar_make()
# Read the first row group:
targets::tar_read(group, branches = 1)
# Read the second row group:
targets::tar_read(group, branches = 2)
})
}
</code></pre>

<hr>
<h2 id='tar_group_count_index'>Generate the tar_group column for <code>tar_group_count()</code>.</h2><span id='topic+tar_group_count_index'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_count_index(data, count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_count_index_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
<tr><td><code id="tar_group_count_index_+3A_count">count</code></td>
<td>
<p>Maximum number of groups.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_group_count_run'>Generate a grouped data frame within <code>tar_group_count()</code>.</h2><span id='topic+tar_group_count_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_count_run(data, count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_count_run_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
<tr><td><code id="tar_group_count_run_+3A_count">count</code></td>
<td>
<p>Maximum number of groups.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_group_select'>Group a data frame target with <code>tidyselect</code> semantics.</h2><span id='topic+tar_group_select'></span>

<h3>Description</h3>

<p>Create a target that outputs a grouped data frame
with <code>dplyr::group_by()</code> and <code>targets::tar_group()</code>.
Unlike <code>tar_group_by()</code>, <code>tar_group_select()</code>
expects you to select grouping variables using <code>tidyselect</code> semantics.
Downstream dynamic branching targets will iterate over the groups of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_select(
  name,
  command,
  by = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_select_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_by">by</code></td>
<td>
<p>Tidyselect semantics to specify variables to group over.
Alternatively, you can supply a character vector.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_select_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_select_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_select_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_group_select_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object to generate a grouped data frame
to allows downstream dynamic targets to branch over the
groups of rows.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Grouped data frame targets: 
<code><a href="#topic+tar_group_by">tar_group_by</a>()</code>,
<code><a href="#topic+tar_group_count">tar_group_count</a>()</code>,
<code><a href="#topic+tar_group_size">tar_group_size</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  produce_data &lt;- function() {
    expand.grid(var1 = c("a", "b"), var2 = c("c", "d"), rep = c(1, 2, 3))
  }
  list(
    tarchetypes::tar_group_select(data, produce_data(), starts_with("var")),
    tar_target(group, data, pattern = map(data))
  )
})
targets::tar_make()
# Read the first row group:
targets::tar_read(group, branches = 1)
# Read the second row group:
targets::tar_read(group, branches = 2)
})
}
</code></pre>

<hr>
<h2 id='tar_group_select_run'>Generate a grouped data frame within tar_group_select()</h2><span id='topic+tar_group_select_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_select_run(data, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_select_run_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
<tr><td><code id="tar_group_select_run_+3A_by">by</code></td>
<td>
<p>Nonempty character vector of names of variables to group by.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_group_size'>Group the rows of a data frame into groups
of a given size.</h2><span id='topic+tar_group_size'></span>

<h3>Description</h3>

<p>Create a target that outputs a grouped data frame
for downstream dynamic branching. Row groups have
the number of rows you supply to <code>size</code> (plus the remainder
in a group of its own, if applicable.) The total number of groups
varies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_size(
  name,
  command,
  size,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_size_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_size">size</code></td>
<td>
<p>Positive integer, maximum number of rows in each group.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_size_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_size_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_group_size_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_group_size_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object to generate a grouped data frame
to allows downstream dynamic targets to branch over the
groups of rows.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Grouped data frame targets: 
<code><a href="#topic+tar_group_by">tar_group_by</a>()</code>,
<code><a href="#topic+tar_group_count">tar_group_count</a>()</code>,
<code><a href="#topic+tar_group_select">tar_group_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  produce_data &lt;- function() {
    expand.grid(var1 = c("a", "b"), var2 = c("c", "d"), rep = c(1, 2, 3))
  }
  list(
    tarchetypes::tar_group_size(data, produce_data(), size = 7),
    tar_target(group, data, pattern = map(data))
  )
})
targets::tar_make()
# Read the first row group:
targets::tar_read(group, branches = 1)
# Read the second row group:
targets::tar_read(group, branches = 2)
})
}
</code></pre>

<hr>
<h2 id='tar_group_size_index'>Generate the tar_group column for <code>tar_group_size()</code>.</h2><span id='topic+tar_group_size_index'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_size_index(data, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_size_index_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
<tr><td><code id="tar_group_size_index_+3A_size">size</code></td>
<td>
<p>Maximum number of rows in each group.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_group_size_run'>Generate a grouped data frame within tar_group_size()</h2><span id='topic+tar_group_size_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group_size_run(data, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_size_run_+3A_data">data</code></td>
<td>
<p>A data frame to group.</p>
</td></tr>
</table>

<hr>
<h2 id='tar_hook_before'>Hook to prepend code</h2><span id='topic+tar_hook_before'></span>

<h3>Description</h3>

<p>Prepend R code to the commands of multiple targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_hook_before(targets, hook, names = NULL, set_deps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_hook_before_+3A_targets">targets</code></td>
<td>
<p>A list of target objects. The input target list
can be arbitrarily nested, but it must consist entirely of target
objects. In addition, the return value is a simple list
where each element is a target object.
All hook functions remove the nested structure of the input target list.</p>
</td></tr>
<tr><td><code id="tar_hook_before_+3A_hook">hook</code></td>
<td>
<p>R code to insert. When you supply code to this argument,
the code is quoted (not evaluated) so there is no need
to wrap it in <code>quote()</code>, <code>expression()</code>, or similar.</p>
</td></tr>
<tr><td><code id="tar_hook_before_+3A_names">names</code></td>
<td>
<p>Name of targets in the target list
to apply the hook. Supplied with <code>tidyselect</code> helpers like
<code><a href="#topic+starts_with">starts_with()</a></code>, as in <code>names = starts_with("your_prefix_")</code>.
Targets not included in <code>names</code> still remain in the target list,
but they are not modified because the hook does not apply to them.</p>
</td></tr>
<tr><td><code id="tar_hook_before_+3A_set_deps">set_deps</code></td>
<td>
<p>Logical of length 1, whether to refresh the dependencies
of each modified target by scanning the newly generated
target commands for dependencies. If <code>FALSE</code>, then the target will
keep the original set of dependencies it had before the hook.
<code>TRUE</code> is recommended for nearly all situations. Only use <code>FALSE</code>
if you have a specialized use case and you know what you are doing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flattened list of target objects with the hooks applied.
Even if the input target list had a nested structure,
the return value is a simple list where each element is a target object.
All hook functions remove the nested structure of the input target list.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other hooks: 
<code><a href="#topic+tar_hook_inner">tar_hook_inner</a>()</code>,
<code><a href="#topic+tar_hook_outer">tar_hook_outer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  targets &lt;- list(
    # Nested target lists work with hooks.
    list(
      targets::tar_target(x1, task1()),
      targets::tar_target(x2, task2(x1))
    ),
    targets::tar_target(x3, task3(x2)),
    targets::tar_target(y1, task4(x3))
  )
  tarchetypes::tar_hook_before(
    targets = targets,
    hook = print("Running hook."),
    names = starts_with("x")
  )
})
targets::tar_manifest(fields = command)
})
}
</code></pre>

<hr>
<h2 id='tar_hook_inner'>Hook to wrap dependencies</h2><span id='topic+tar_hook_inner'></span>

<h3>Description</h3>

<p>In the command of each target, wrap each mention of
each dependency target in an arbitrary R expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_hook_inner(targets, hook, names = NULL, names_wrap = NULL, set_deps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_hook_inner_+3A_targets">targets</code></td>
<td>
<p>A list of target objects. The input target list
can be arbitrarily nested, but it must consist entirely of target
objects. In addition, the return value is a simple list
where each element is a target object.
All hook functions remove the nested structure of the input target list.</p>
</td></tr>
<tr><td><code id="tar_hook_inner_+3A_hook">hook</code></td>
<td>
<p>R code to wrap each target's command.
The hook must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_inner()</code> knows where to insert the code to wrap
mentions of dependencies.
The hook code is quoted (not evaluated) so there is no need
to wrap it in <code>quote()</code>, <code>expression()</code>, or similar.</p>
</td></tr>
<tr><td><code id="tar_hook_inner_+3A_names">names</code></td>
<td>
<p>Name of targets in the target list
to apply the hook. Supplied with <code>tidyselect</code> helpers like
<code><a href="#topic+starts_with">starts_with()</a></code>, as in <code>names = starts_with("your_prefix_")</code>.
Targets not included in <code>names</code> still remain in the target list,
but they are not modified because the hook does not apply to them.</p>
</td></tr>
<tr><td><code id="tar_hook_inner_+3A_names_wrap">names_wrap</code></td>
<td>
<p>Names of targets to wrap with the hook
where they appear as dependencies in the commands of other targets.
Use <code>tidyselect</code> helpers like <code><a href="#topic+starts_with">starts_with()</a></code>, as in
<code>names_wrap = starts_with("your_prefix_")</code>.</p>
</td></tr>
<tr><td><code id="tar_hook_inner_+3A_set_deps">set_deps</code></td>
<td>
<p>Logical of length 1, whether to refresh the dependencies
of each modified target by scanning the newly generated
target commands for dependencies. If <code>FALSE</code>, then the target will
keep the original set of dependencies it had before the hook.
<code>TRUE</code> is recommended for nearly all situations. Only use <code>FALSE</code>
if you have a specialized use case and you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression you supply to <code>hook</code>
must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_inner()</code> knows where to insert the original command
of the target.
</p>


<h3>Value</h3>

<p>A flattened list of target objects with the hooks applied.
Even if the input target list had a nested structure,
the return value is a simple list where each element is a target object.
All hook functions remove the nested structure of the input target list.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other hooks: 
<code><a href="#topic+tar_hook_before">tar_hook_before</a>()</code>,
<code><a href="#topic+tar_hook_outer">tar_hook_outer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  targets &lt;- list(
    # Nested target lists work with hooks.
    list(
      targets::tar_target(x1, task1()),
      targets::tar_target(x2, task2(x1))
    ),
    targets::tar_target(x3, task3(x2, x1)),
    targets::tar_target(y1, task4(x3))
  )
  tarchetypes::tar_hook_inner(
    targets = targets,
    hook = fun(.x),
    names = starts_with("x")
  )
})
targets::tar_manifest(fields = command)
})
}
</code></pre>

<hr>
<h2 id='tar_hook_outer'>Hook to wrap commands</h2><span id='topic+tar_hook_outer'></span>

<h3>Description</h3>

<p>Wrap the command of each target in an arbitrary R expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_hook_outer(targets, hook, names = NULL, set_deps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_hook_outer_+3A_targets">targets</code></td>
<td>
<p>A list of target objects. The input target list
can be arbitrarily nested, but it must consist entirely of target
objects. In addition, the return value is a simple list
where each element is a target object.
All hook functions remove the nested structure of the input target list.</p>
</td></tr>
<tr><td><code id="tar_hook_outer_+3A_hook">hook</code></td>
<td>
<p>R code to wrap each target's command.
The hook must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_outer()</code> knows where to insert the original command
of the target.
The hook code is quoted (not evaluated) so there is no need
to wrap it in <code>quote()</code>, <code>expression()</code>, or similar.</p>
</td></tr>
<tr><td><code id="tar_hook_outer_+3A_names">names</code></td>
<td>
<p>Name of targets in the target list
to apply the hook. Supplied with <code>tidyselect</code> helpers like
<code><a href="#topic+starts_with">starts_with()</a></code>, as in <code>names = starts_with("your_prefix_")</code>.
Targets not included in <code>names</code> still remain in the target list,
but they are not modified because the hook does not apply to them.</p>
</td></tr>
<tr><td><code id="tar_hook_outer_+3A_set_deps">set_deps</code></td>
<td>
<p>Logical of length 1, whether to refresh the dependencies
of each modified target by scanning the newly generated
target commands for dependencies. If <code>FALSE</code>, then the target will
keep the original set of dependencies it had before the hook.
<code>TRUE</code> is recommended for nearly all situations. Only use <code>FALSE</code>
if you have a specialized use case and you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression you supply to <code>hook</code>
must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_outer()</code> knows where to insert the original command
of the target.
</p>


<h3>Value</h3>

<p>A flattened list of target objects with the hooks applied.
Even if the input target list had a nested structure,
the return value is a simple list where each element is a target object.
All hook functions remove the nested structure of the input target list.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other hooks: 
<code><a href="#topic+tar_hook_before">tar_hook_before</a>()</code>,
<code><a href="#topic+tar_hook_inner">tar_hook_inner</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  targets &lt;- list(
    # Nested target lists work with hooks.
    list(
      targets::tar_target(x1, task1()),
      targets::tar_target(x2, task2(x1))
    ),
    targets::tar_target(x3, task3(x2)),
    targets::tar_target(y1, task4(x3))
  )
  tarchetypes::tar_hook_outer(
    targets = targets,
    hook = postprocess(.x, arg = "value"),
    names = starts_with("x")
  )
})
targets::tar_manifest(fields = command)
})
}
</code></pre>

<hr>
<h2 id='tar_knit'>Target with a <code>knitr</code> document.</h2><span id='topic+tar_knit'></span>

<h3>Description</h3>

<p>Shorthand to include <code>knitr</code> document in a
<code>targets</code> pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_knit(
  name,
  path,
  output_file = NULL,
  working_directory = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_knit_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_path">path</code></td>
<td>
<p>Character string, file path to the <code>knitr</code> source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_output_file">output_file</code></td>
<td>
<p>Character string, file path to the rendered output file.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_knit_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_knit_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="tar_knit_+3A_...">...</code></td>
<td>
<p>Named arguments to <code>knitr::knit()</code>.
These arguments are evaluated when the target actually runs in
<code>tar_make()</code>, not when the target is defined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_knit()</code> is an alternative to <code>tar_target()</code> for
<code>knitr</code> reports that depend on other targets. The <code>knitr</code> source
should mention dependency targets with <code>tar_load()</code> and <code>tar_read()</code>
in the active code chunks (which also allows you to knit the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_knit()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return both the output
report files and the input source file. All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>knitr::knit()</code>.
</p>


<h3>Value</h3>

<p>A <code>tar_target()</code> object with <code>format = "file"</code>.
When this target runs, it returns a character vector
of file paths. The first file paths are the output files
(returned by <code>knitr::knit()</code>) and the <code>knitr</code>
source file is last. But unlike <code>knitr::knit()</code>,
all returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Ordinarily, you should create the report outside
  # tar_script() and avoid temporary files.
  lines &lt;- c(
    "---",
    "title: report",
    "output_format: html_document",
    "---",
    "",
    "```{r}",
    "targets::tar_read(data)",
    "```"
  )
  path &lt;- tempfile()
  writeLines(lines, path)
  list(
    targets::tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tarchetypes::tar_knit(report, path)
  )
})
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_knit_raw'>Target with a knitr document (raw version).</h2><span id='topic+tar_knit_raw'></span>

<h3>Description</h3>

<p>Shorthand to include a knitr document in a
<code>targets</code> pipeline (raw version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_knit_raw(
  name,
  path,
  output_file = NULL,
  working_directory = NULL,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  knit_arguments = quote(list())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_knit_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_path">path</code></td>
<td>
<p>Character string, file path to the <code>knitr</code> source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_output_file">output_file</code></td>
<td>
<p>Character string, file path to the rendered output file.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="tar_knit_raw_+3A_knit_arguments">knit_arguments</code></td>
<td>
<p>Optional language object with a list
of named arguments to <code>knitr::knit()</code>.
Cannot be an expression object.
(Use <code>quote()</code>, not <code>expression()</code>.)
The reason for quoting is that these arguments may depend on
upstream targets whose values are not available at
the time the target is defined, and because <code>tar_knit_raw()</code>
is the &quot;raw&quot; version of a function, we want to avoid
all non-standard evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_knit_raw()</code> is just like <code>tar_knit()</code>
except that it uses standard evaluation. The <code>name</code> argument
is a character vector, and the <code>knit_arguments</code> argument
is a language object.
</p>


<h3>Value</h3>

<p>A <code>tar_target()</code> object with <code>format = "file"</code>.
When this target runs, it returns a character vector
of file paths. The first file paths are the output files
(returned by <code>knitr::knit()</code>) and the knitr
source file is last. But unlike <code>knitr::knit()</code>,
all returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Ordinarily, you should create the report outside
  # tar_script() and avoid temporary files.
  lines &lt;- c(
    "---",
    "title: report",
    "output_format: html_document",
    "---",
    "",
    "```{r}",
    "targets::tar_read(data)",
    "```"
  )
  path &lt;- tempfile()
  writeLines(lines, path)
  list(
    targets::tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tarchetypes::tar_knit_raw("report", path)
  )
})
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_knit_run'>Run a <code>knitr</code> report inside a <code>tar_knit()</code> target.</h2><span id='topic+tar_knit_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_knit()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_knit_run(path, working_directory, args, deps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_knit_run_+3A_path">path</code></td>
<td>
<p>Character string, file path to the <code>knitr</code> source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_knit_run_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_knit_run_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>knitr::knit()</code>.</p>
</td></tr>
<tr><td><code id="tar_knit_run_+3A_deps">deps</code></td>
<td>
<p>An unnamed list of target dependencies of the <code>knitr</code>
report, automatically created by <code>tar_knit()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character with the path to the <code>knitr</code> source file
and the relative path to the output <code>knitr</code> report.
The output path depends on the input path argument,
which has no default.
</p>

<hr>
<h2 id='tar_knitr_deps'>List literate programming dependencies.</h2><span id='topic+tar_knitr_deps'></span>

<h3>Description</h3>

<p>List the target dependencies of one or more
literate programming reports (R Markdown or <code>knitr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_knitr_deps(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_knitr_deps_+3A_path">path</code></td>
<td>
<p>Character vector, path to one or more R Markdown or
<code>knitr</code> reports.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of the names of targets
that are dependencies of the <code>knitr</code> report.
</p>


<h3>See Also</h3>

<p>Other Literate programming utilities: 
<code><a href="#topic+tar_knitr_deps_expr">tar_knitr_deps_expr</a>()</code>,
<code><a href="#topic+tar_quarto_files">tar_quarto_files</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lines &lt;- c(
  "---",
  "title: report",
  "output_format: html_document",
  "---",
  "",
  "```{r}",
  "targets::tar_load(data1)",
  "targets::tar_read(data2)",
  "```"
)
report &lt;- tempfile()
writeLines(lines, report)
tar_knitr_deps(report)
</code></pre>

<hr>
<h2 id='tar_knitr_deps_expr'>Expression with literate programming dependencies.</h2><span id='topic+tar_knitr_deps_expr'></span>

<h3>Description</h3>

<p>Construct an expression whose global variable dependencies
are the target dependencies of one or more literate programming reports
(R Markdown or <code>knitr</code>). This helps third-party developers create their
own third-party target factories for literate programming targets
(similar to <code><a href="#topic+tar_knit">tar_knit()</a></code> and <code><a href="#topic+tar_render">tar_render()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_knitr_deps_expr(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_knitr_deps_expr_+3A_path">path</code></td>
<td>
<p>Character vector, path to one or more R Markdown or
<code>knitr</code> reports.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expression object to name the dependency targets
of the <code>knitr</code> report, which will be detected in the
static code analysis of <code>targets</code>.
</p>


<h3>See Also</h3>

<p>Other Literate programming utilities: 
<code><a href="#topic+tar_knitr_deps">tar_knitr_deps</a>()</code>,
<code><a href="#topic+tar_quarto_files">tar_quarto_files</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lines &lt;- c(
  "---",
  "title: report",
  "output_format: html_document",
  "---",
  "",
  "```{r}",
  "targets::tar_load(data1)",
  "targets::tar_read(data2)",
  "```"
)
report &lt;- tempfile()
writeLines(lines, report)
tar_knitr_deps_expr(report)
</code></pre>

<hr>
<h2 id='tar_map'>Static branching.</h2><span id='topic+tar_map'></span>

<h3>Description</h3>

<p>Define multiple new targets based on existing target objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map(
  values,
  ...,
  names = tidyselect::everything(),
  descriptions = tidyselect::everything(),
  unlist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map_+3A_...">...</code></td>
<td>
<p>One or more target objects or list of target objects.
Lists can be arbitrarily nested, as in <code>list()</code>.</p>
</td></tr>
<tr><td><code id="tar_map_+3A_names">names</code></td>
<td>
<p>Subset of <code>names(values)</code>
used to generate the suffixes in the names of the new targets.
The value of <code>names</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map_+3A_unlist">unlist</code></td>
<td>
<p>Logical, whether to flatten the returned list of targets.
If <code>unlist = FALSE</code>, the list is nested and sub-lists
are named and grouped by the original input targets.
If <code>unlist = TRUE</code>, the return value is a flat list of targets
named by the new target names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_map()</code> creates collections of new
targets by iterating over a list of arguments
and substituting symbols into commands and pattern statements.
</p>


<h3>Value</h3>

<p>A list of new target objects. If <code>unlist</code> is <code>FALSE</code>,
the list is nested and sub-lists are named and grouped by the original
input targets. If <code>unlist = TRUE</code>, the return value is a flat list of
targets named by the new target names.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_map(
      list(a = c(12, 34), b = c(45, 78)),
      targets::tar_target(x, a + b),
      targets::tar_target(y, x + a, pattern = map(x))
    )
  )
})
targets::tar_manifest()
})
}
</code></pre>

<hr>
<h2 id='tar_map_rep'>Dynamic batched replication within static branches
for data frames.</h2><span id='topic+tar_map_rep'></span>

<h3>Description</h3>

<p>Define targets for batched replication
within static branches for  data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map_rep(
  name,
  command,
  values = NULL,
  names = NULL,
  descriptions = tidyselect::everything(),
  columns = tidyselect::everything(),
  batches = 1,
  reps = 1,
  rep_workers = 1,
  combine = TRUE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map_rep_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_command">command</code></td>
<td>
<p>R code for a single replicate. Must return
a data frame.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_columns">columns</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>values</code>
to append to the output. Columns already in the target output
are not appended.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_reps">reps</code></td>
<td>
<p>Number of replications in each batch. The total number
of replications is <code>batches * reps</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map_rep_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Just a sketch of a Bayesian sensitivity analysis of hyperparameters:
  assess_hyperparameters &lt;- function(sigma1, sigma2) {
    # data &lt;- simulate_random_data() # user-defined function
    # run_model(data, sigma1, sigma2) # user-defined function
    # Mock output from the model:
    posterior_samples &lt;- stats::rnorm(1000, 0, sigma1 + sigma2)
    tibble::tibble(
      posterior_median = median(posterior_samples),
      posterior_quantile_0.025 = quantile(posterior_samples, 0.025),
      posterior_quantile_0.975 = quantile(posterior_samples, 0.975)
    )
  }
  hyperparameters &lt;- tibble::tibble(
    scenario = c("tight", "medium", "diffuse"),
    sigma1 = c(10, 50, 50),
    sigma2 = c(10, 5, 10)
  )
  tarchetypes::tar_map_rep(
    sensitivity_analysis,
    command = assess_hyperparameters(sigma1, sigma2),
    values = hyperparameters,
    names = tidyselect::any_of("scenario"),
    batches = 2,
    reps = 3
   )
})
targets::tar_make()
targets::tar_read(sensitivity_analysis)
})
}
</code></pre>

<hr>
<h2 id='tar_map_rep_raw'>Dynamic batched replication within static branches
for data frames (raw version).</h2><span id='topic+tar_map_rep_raw'></span>

<h3>Description</h3>

<p>Define targets for batched replication
within static branches for data frames (raw version).
</p>
<p>This function is like <code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>
except the <code>name</code> argument is a character string
and the <code>names</code> and <code>columns</code> arguments are
language objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map_rep_raw(
  name,
  command,
  values = NULL,
  names = NULL,
  descriptions = quote(tidyselect::everything()),
  columns = quote(tidyselect::everything()),
  batches = 1,
  reps = 1,
  rep_workers = 1,
  combine = TRUE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map_rep_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_command">command</code></td>
<td>
<p>Language object, R code for a single replicate. Must return
a data frame.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_columns">columns</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to append to the output.
Columns already in the target output are not appended.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_reps">reps</code></td>
<td>
<p>Number of replications in each batch. The total number
of replications is <code>batches * reps</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_format">format</code></td>
<td>
<p>Character of length 1, storage format of the output.
An efficient data frame format like <code>"feather"</code> is recommended,
but the default is <code>"rds"</code> to avoid incurring extra package
dependencies. See the help file of <code>targets::tar_target()</code>
for details on storage formats.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map_rep_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  # Just a sketch of a Bayesian sensitivity analysis of hyperparameters:
  assess_hyperparameters &lt;- function(sigma1, sigma2) {
    # data &lt;- simulate_random_data() # user-defined function
    # run_model(data, sigma1, sigma2) # user-defined function
    # Mock output from the model:
    posterior_samples &lt;- stats::rnorm(1000, 0, sigma1 + sigma2)
    tibble::tibble(
      posterior_median = median(posterior_samples),
      posterior_quantile_0.025 = quantile(posterior_samples, 0.025),
      posterior_quantile_0.975 = quantile(posterior_samples, 0.975)
    )
  }
  hyperparameters &lt;- tibble::tibble(
    scenario = c("tight", "medium", "diffuse"),
    sigma1 = c(10, 50, 50),
    sigma2 = c(10, 5, 10)
  )
  tarchetypes::tar_map_rep_raw(
    "sensitivity_analysis",
    command = quote(assess_hyperparameters(sigma1, sigma2)),
    values = hyperparameters,
    names = quote(tidyselect::any_of("scenario")),
    batches = 2,
    reps = 3
   )
})
targets::tar_make()
targets::tar_read(sensitivity_analysis)
})
}
</code></pre>

<hr>
<h2 id='tar_map2'>Batched dynamic-within-static branching for data frames.</h2><span id='topic+tar_map2'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames.
Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = tidyselect::everything(),
  group = rep(1L, nrow(as.data.frame(!!.x))),
  combine = TRUE,
  suffix1 = "1",
  suffix2 = "2",
  columns1 = tidyselect::everything(),
  columns2 = tidyselect::everything(),
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_+3A_name">name</code></td>
<td>
<p>Symbol, base name of the targets.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_command1">command1</code></td>
<td>
<p>R code to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_command2">command2</code></td>
<td>
<p>R code to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_group">group</code></td>
<td>
<p>Function on the data produced by <code>command1</code> to create the
<code>tar_group</code> column that determines the batching structure for the
<code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_columns1">columns1</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>values</code>
to append to the output of all targets.
Columns already in the target output are not appended.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_columns2">columns2</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
Columns already in the target output are not appended.
<code>columns1</code> takes precedence over <code>columns2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>
<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>

<hr>
<h2 id='tar_map2_count'>Dynamic-within-static branching for data frames
(count batching).</h2><span id='topic+tar_map2_count'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames,
where the user sets the (maximum) number of batches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_count(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = tidyselect::everything(),
  batches = 1L,
  combine = TRUE,
  suffix1 = "1",
  suffix2 = "2",
  columns1 = tidyselect::everything(),
  columns2 = tidyselect::everything(),
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_count_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_command1">command1</code></td>
<td>
<p>R code to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_command2">command2</code></td>
<td>
<p>R code to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_columns1">columns1</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>values</code>
to append to the output of all targets.
Columns already in the target output are not appended.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_columns2">columns2</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
Columns already in the target output are not appended.
<code>columns1</code> takes precedence over <code>columns2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_count_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  tarchetypes::tar_map2_count(
    x,
    command1 = tibble::tibble(
      arg1 = arg1,
      arg2 = seq_len(6)
     ),
    command2 = tibble::tibble(
      result = paste(arg1, arg2),
      random = sample.int(1e9, size = 1),
      length_input = length(arg1)
    ),
    values = tibble::tibble(arg1 = letters[seq_len(2)]),
    batches = 3
   )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_map2_count_raw'>Dynamic-within-static branching for data frames
(count batching; raw version).</h2><span id='topic+tar_map2_count_raw'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames,
where the user sets the (maximum) number of batches.
Like <code>tar_map2_count()</code> except <code>name</code> is a character string
and <code>command1</code>, <code>command2</code>, <code>names</code>, <code>columns1</code>, and <code>columns2</code>
are all language objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_count_raw(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = quote(tidyselect::everything()),
  batches = 1L,
  combine = TRUE,
  suffix1 = "1",
  suffix2 = "2",
  rep_workers = 1,
  columns1 = quote(tidyselect::everything()),
  columns2 = quote(tidyselect::everything()),
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_count_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_command1">command1</code></td>
<td>
<p>Language object to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_command2">command2</code></td>
<td>
<p>Language object  to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_batches">batches</code></td>
<td>
<p>Positive integer of length 1,
maximum number of batches (dynamic branches within static branches)
of the downstream (<code>command2</code>) targets. Batches
are formed from row groups of the <code>command1</code> target output.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_columns1">columns1</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>values</code>
to append to the output of all targets.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_columns2">columns2</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
In case of conflicts, <code>column1</code> takes precedence.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_count_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  tarchetypes::tar_map2_count_raw(
    "x",
    command1 = quote(
      tibble::tibble(
        arg1 = arg1,
        arg2 = seq_len(6)
       )
    ),
    command2 = quote(
      tibble::tibble(
        result = paste(arg1, arg2),
        random = sample.int(1e6, size = 1),
        length_input = length(arg1)
      )
    ),
    values = tibble::tibble(arg1 = letters[seq_len(2)]),
    batches = 3
   )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_map2_group'>Append the <code>tar_group</code> variable to a <code>tar_map2()</code> target.</h2><span id='topic+tar_map2_group'></span>

<h3>Description</h3>

<p>Append the <code>tar_group</code> variable to a <code>tar_map2()</code> target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_group(data, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_group_+3A_data">data</code></td>
<td>
<p>Data frame to be returned from the target.</p>
</td></tr>
<tr><td><code id="tar_map2_group_+3A_group">group</code></td>
<td>
<p>Function on the data to return the <code>tar_group</code> column.
If <code>group</code> is <code>NULL</code>, then no <code>tar_group</code> column is attached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use only. Users should not invoke
this function directly.
</p>


<h3>Value</h3>

<p>A data frame with a <code>tar_group</code> column attached (if <code>group</code>
is not <code>NULL</code>).
</p>

<hr>
<h2 id='tar_map2_raw'>Batched dynamic-within-static branching for data frames (raw version).</h2><span id='topic+tar_map2_raw'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames (raw version).
Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_raw(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = quote(tidyselect::everything()),
  group = quote(rep(1L, nrow(as.data.frame(!!.x)))),
  combine = TRUE,
  columns1 = quote(tidyselect::everything()),
  columns2 = quote(tidyselect::everything()),
  suffix1 = "1",
  suffix2 = "2",
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, base name of the targets.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_command1">command1</code></td>
<td>
<p>Language object to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_command2">command2</code></td>
<td>
<p>Language object  to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_group">group</code></td>
<td>
<p>Function on the data produced by <code>command1</code> to create the
<code>tar_group</code> column that determines the batching structure for the
<code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_columns1">columns1</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>values</code>
to append to the output of all targets.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_columns2">columns2</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
In case of conflicts, <code>column1</code> takes precedence.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <code>tar_map2()</code> except <code>name</code> is a character string
and <code>command1</code>, <code>command2</code>, <code>group</code>, <code>names</code>, <code>columns1</code>, and <code>columns2</code>
are language objects.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>

<hr>
<h2 id='tar_map2_run'>Run a dynamic batch of a <code>tar_map2()</code> target.</h2><span id='topic+tar_map2_run'></span>

<h3>Description</h3>

<p>Run a dynamic batch of a <code>tar_map2()</code> target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_run(command, values, columns, rep_workers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_run_+3A_command">command</code></td>
<td>
<p>Command to run.</p>
</td></tr>
<tr><td><code id="tar_map2_run_+3A_values">values</code></td>
<td>
<p>Data frame of named arguments produced by <code>command1</code>
that <code>command2</code> dynamically maps over. Different from the <code>values</code>
argument of <code>tar_map2()</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_run_+3A_columns">columns</code></td>
<td>
<p>tidyselect expression to select columns of <code>values</code>
to append to the result.</p>
</td></tr>
<tr><td><code id="tar_map2_run_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use only. Users should not invoke
this function directly.
</p>


<h3>Value</h3>

<p>A data frame with a <code>tar_group</code> column attached (if <code>group</code>
is not <code>NULL</code>).
</p>

<hr>
<h2 id='tar_map2_run_rep'>Run a rep in a <code>tar_map2()</code>-powered function.</h2><span id='topic+tar_map2_run_rep'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_run_rep(rep, values, command, batch, seeds, columns, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_run_rep_+3A_rep">rep</code></td>
<td>
<p>Rep number.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_values">values</code></td>
<td>
<p>Data frame of mapped-over values.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_command">command</code></td>
<td>
<p>R command to run.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_batch">batch</code></td>
<td>
<p>Batch number.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_seeds">seeds</code></td>
<td>
<p>Random number generator seeds of the batch.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_columns">columns</code></td>
<td>
<p>Expression for appending static columns.</p>
</td></tr>
<tr><td><code id="tar_map2_run_rep_+3A_envir">envir</code></td>
<td>
<p>Environment of the target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of running <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_map2_count().
</code></pre>

<hr>
<h2 id='tar_map2_size'>Dynamic-within-static branching for data frames
(size batching).</h2><span id='topic+tar_map2_size'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames,
where the user sets the (maximum) size of each batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_size(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = tidyselect::everything(),
  size = Inf,
  combine = TRUE,
  suffix1 = "1",
  suffix2 = "2",
  columns1 = tidyselect::everything(),
  columns2 = tidyselect::everything(),
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_size_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_command1">command1</code></td>
<td>
<p>R code to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_command2">command2</code></td>
<td>
<p>R code to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_size">size</code></td>
<td>
<p>Positive integer of length 1,
maximum number of rows in each batch for
the downstream (<code>command2</code>) targets. Batches
are formed from row groups of the <code>command1</code> target output.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_columns1">columns1</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>values</code>
to append to the output of all targets.
Columns already in the target output are not appended.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_columns2">columns2</code></td>
<td>
<p>A tidyselect expression to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
Columns already in the target output are not appended.
<code>columns1</code> takes precedence over <code>columns2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_size_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  tarchetypes::tar_map2_size(
    x,
    command1 = tibble::tibble(
      arg1 = arg1,
      arg2 = seq_len(6)
     ),
    command2 = tibble::tibble(
      result = paste(arg1, arg2),
      random = sample.int(1e9, size = 1),
      length_input = length(arg1)
    ),
    values = tibble::tibble(arg1 = letters[seq_len(2)]),
    size = 2
   )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_map2_size_raw'>Dynamic-within-static branching for data frames
(size batching; raw version).</h2><span id='topic+tar_map2_size_raw'></span>

<h3>Description</h3>

<p>Define targets for batched
dynamic-within-static branching for data frames,
where the user sets the (maximum) size of each batch.
Like <code>tar_map2_size()</code> except <code>name</code> is a character string
and <code>command1</code>, <code>command2</code>, <code>names</code>, <code>columns1</code>, and <code>columns2</code>
are all language objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_map2_size_raw(
  name,
  command1,
  command2,
  values = NULL,
  names = NULL,
  descriptions = quote(tidyselect::everything()),
  size = Inf,
  combine = TRUE,
  suffix1 = "1",
  suffix2 = "2",
  columns1 = quote(tidyselect::everything()),
  columns2 = quote(tidyselect::everything()),
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_map2_size_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_command1">command1</code></td>
<td>
<p>Language object to create named arguments to <code>command2</code>.
Must return a data frame with one row per call to <code>command2</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_command2">command2</code></td>
<td>
<p>Language object  to map over the data frame of arguments
produced by <code>command1</code>. Must return a data frame.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_values">values</code></td>
<td>
<p>Named list or data frame with values to iterate over.
The names are the names of symbols in the commands and pattern
statements, and the elements are values that get substituted
in place of those symbols. <code><a href="#topic+tar_map">tar_map()</a></code> uses these elements
to create new R code, so they should be basic types, symbols,
or R expressions. For objects even a little bit complicated,
especially objects with attributes, it is not obvious how to
convert the object into code that generates it.
For complicated objects, consider using <code>quote()</code> when
you define <code>values</code>, as shown at
<a href="https://github.com/ropensci/tarchetypes/discussions/105">https://github.com/ropensci/tarchetypes/discussions/105</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_names">names</code></td>
<td>
<p>Language object with a tidyselect expression
to select which columns of <code>values</code> to use to construct
statically branched target names. If <code>NULL</code>, then
short names are automatically generated.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_descriptions">descriptions</code></td>
<td>
<p>Names of a column in <code>values</code>
to append to the custom description of each generated target.
The value of <code>descriptions</code> should be a <code>tidyselect</code> expression
such as a call to <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_size">size</code></td>
<td>
<p>Positive integer of length 1,
maximum number of rows in each batch for
the downstream (<code>command2</code>) targets. Batches
are formed from row groups of the <code>command1</code> target output.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_combine">combine</code></td>
<td>
<p>Logical of length 1, whether to statically combine
all the results into a single target downstream.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_suffix1">suffix1</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command1</code> targets to distinguish
them from the <code>command2</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_suffix2">suffix2</code></td>
<td>
<p>Character of length 1,
suffix to apply to the <code>command2</code> targets to distinguish
them from the <code>command1</code> targets.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_columns1">columns1</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>values</code>
to append to the output of all targets.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_columns2">columns2</code></td>
<td>
<p>Language object, a tidyselect expression
to select which columns of <code>command1</code>
output to append to <code>command2</code> output.
In case of conflicts, <code>column1</code> takes precedence.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_map2_size_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static branching creates one pair of targets
for each row in <code>values</code>. In each pair,
there is an upstream non-dynamic target that runs <code>command1</code>
and a downstream dynamic target that runs <code>command2</code>.
<code>command1</code> produces a data frame of arguments to
<code>command2</code>, and <code>command2</code> dynamically maps over
these arguments in batches.
</p>


<h3>Value</h3>

<p>A list of new target objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  tarchetypes::tar_map2_size_raw(
    "x",
    command1 = quote(
      tibble::tibble(
        arg1 = arg1,
        arg2 = seq_len(6)
       )
    ),
    command2 = quote(
      tibble::tibble(
        result = paste(arg1, arg2),
        random = sample.int(1e6, size = 1),
        length_input = length(arg1)
      )
    ),
    values = tibble::tibble(arg1 = letters[seq_len(2)]),
    size = 2
   )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_plan'>A <code>drake</code>-plan-like pipeline archetype</h2><span id='topic+tar_plan'></span>

<h3>Description</h3>

<p>Simplify target specification in pipelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_plan(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_plan_+3A_...">...</code></td>
<td>
<p>Named and unnamed targets. All named targets must follow
the <code>drake</code>-plan-like <code>target = command</code> syntax, and all unnamed
arguments must be explicit calls to create target objects,
e.g. <code>tar_target()</code>, target archetypes like <code><a href="#topic+tar_render">tar_render()</a></code>, or similar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allows targets with just targets and commands
to be written in the pipeline as <code>target = command</code> instead of
<code>tar_target(target, command)</code>. Also supports ordinary
target objects if they are unnamed.
<code>tar_plan(x = 1, y = 2, tar_target(z, 3), tar_render(r, "r.Rmd"))</code>
is equivalent to
<code>list(tar_target(x, 1), tar_target(y, 2), tar_target(z, 3), tar_render(r, "r.Rmd"))</code>. # nolint
</p>


<h3>Value</h3>

<p>A list of <code>tar_target()</code> objects.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  library(tarchetypes)
  tar_plan(
    tarchetypes::tar_fst_tbl(data, data.frame(x = seq_len(26))),
    means = colMeans(data) # No need for tar_target() for simple cases.
  )
})
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_quarto'>Target with a Quarto project.</h2><span id='topic+tar_quarto'></span>

<h3>Description</h3>

<p>Shorthand to include a Quarto project in a
<code>targets</code> pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto(
  name,
  path = ".",
  working_directory = NULL,
  extra_files = character(0),
  execute = TRUE,
  execute_params = list(),
  cache = NULL,
  cache_refresh = FALSE,
  debug = FALSE,
  quiet = TRUE,
  quarto_args = NULL,
  pandoc_args = NULL,
  profile = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = NULL,
  library = NULL,
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_path">path</code></td>
<td>
<p>Character of length 1,
either the single <code style="white-space: pre;">&#8288;*.qmd&#8288;</code> source file to be rendered
or a directory containing a Quarto project.
Defaults to the working directory of the <code>targets</code> pipeline.
Passed directly to the <code>input</code> argument of <code>quarto::quarto_render()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_extra_files">extra_files</code></td>
<td>
<p>Character vector of extra files and
directories to track for changes. The target will be invalidated
(rerun on the next <code>tar_make()</code>) if the contents of these files changes.
No need to include anything already in the output of <code><a href="#topic+tar_quarto_files">tar_quarto_files()</a></code>,
the list of file dependencies automatically detected through
<code>quarto::quarto_inspect()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_execute">execute</code></td>
<td>
<p>Whether to execute embedded code chunks.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_execute_params">execute_params</code></td>
<td>
<p>Code, cannot be <code>NULL</code>.
<code>execute_params</code> evaluates to a named list of parameters
for parameterized Quarto documents. These parameters override the custom
custom elements of the <code>params</code> list in the YAML front-matter of the
Quarto source files. The list is quoted
(not evaluated until the target runs)
so that upstream targets can serve as parameter values.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_cache">cache</code></td>
<td>
<p>Cache execution output (uses knitr cache and jupyter-cache
respectively for Rmd and Jupyter input files).</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_cache_refresh">cache_refresh</code></td>
<td>
<p>Force refresh of execution cache.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_debug">debug</code></td>
<td>
<p>Leave intermediate files in place after render.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_quiet">quiet</code></td>
<td>
<p>Suppress warning and other messages.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_quarto_args">quarto_args</code></td>
<td>
<p>Character vector of other <code>quarto</code> CLI flag pass to the
command. This is mainly for advanced usage, e.g it can be useful for new
options added to quarto CLI and not yet supported as function argument.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_pandoc_args">pandoc_args</code></td>
<td>
<p>Additional command line options to pass to pandoc.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_profile">profile</code></td>
<td>
<p>Character of length 1, Quarto profile. If <code>NULL</code>,
the default profile will be used. Requires Quarto version 1.2 or higher.
See <a href="https://quarto.org/docs/projects/profiles.html">https://quarto.org/docs/projects/profiles.html</a> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_quarto_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_quarto()</code> is an alternative to <code>tar_target()</code> for
Quarto projects and standalone Quarto source documents
that depend on upstream targets. The Quarto
R source documents (<code style="white-space: pre;">&#8288;*.qmd&#8288;</code> and <code style="white-space: pre;">&#8288;*.Rmd&#8288;</code> files)
should mention dependency targets with <code>tar_load()</code> and <code>tar_read()</code>
in the active R code chunks (which also allows you to render the project
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_quarto()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the
R source reports and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return both the output
rendered files and the input dependency files (such as
Quarto source documents). All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>quarto::quarto_render()</code>.
</p>


<h3>Value</h3>

<p>A target object with <code>format = "file"</code>.
When this target runs, it returns a character vector
of file paths: the rendered documents, the Quarto source files,
and other input and output files.
The output files are determined by the YAML front-matter of
standalone Quarto documents and <code style="white-space: pre;">&#8288;_quarto.yml&#8288;</code> in Quarto projects,
and you can see these files with <code><a href="#topic+tar_quarto_files">tar_quarto_files()</a></code>
(powered by <code>quarto::quarto_inspect()</code>).
All returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Quarto troubleshooting</h3>

<p>If you encounter difficult errors, please read
<a href="https://github.com/quarto-dev/quarto-r/issues/16">https://github.com/quarto-dev/quarto-r/issues/16</a>.
In addition, please try to reproduce the error using
<code>quarto::quarto_render("your_report.qmd", execute_dir = getwd())</code>
without using <code>targets</code> at all. Isolating errors this way
makes them much easier to solve.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({  # tar_dir() runs code from a temporary directory.
# Unparameterized Quarto document:
lines &lt;- c(
  "---",
  "title: report.qmd source file",
  "output_format: html",
  "---",
  "Assume these lines are in report.qmd.",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
writeLines(lines, "report.qmd")
# Include the report in a pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_quarto(report, path = "report.qmd")
  )
}, ask = FALSE)
# Then, run the pipeline as usual.

# Parameterized Quarto:
lines &lt;- c(
  "---",
  "title: 'report.qmd source file with parameters'",
  "output_format: html_document",
  "params:",
  "  your_param: \"default value\"",
  "---",
  "Assume these lines are in report.qmd.",
  "```{r}",
  "print(params$your_param)",
  "```"
)
writeLines(lines, "report.qmd")
# Include the report in the pipeline as follows.
unlink("_targets.R") # In tar_dir(), not the user's file space.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_quarto(
      report,
      path = "report.qmd",
      execute_params = list(your_param = data)
    )
  )
}, ask = FALSE)
})
# Then, run the pipeline as usual.
}
</code></pre>

<hr>
<h2 id='tar_quarto_files'>Quarto file detection</h2><span id='topic+tar_quarto_files'></span>

<h3>Description</h3>

<p>Detect the important files in a Quarto project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_files(path = ".", profile = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_files_+3A_path">path</code></td>
<td>
<p>Character of length 1, either the file path
to a Quarto source document or the directory path
to a Quarto project. Defaults to the Quarto project in the
current working directory.</p>
</td></tr>
<tr><td><code id="tar_quarto_files_+3A_profile">profile</code></td>
<td>
<p>Character of length 1, Quarto profile. If <code>NULL</code>,
the default profile will be used. Requires Quarto version 1.2 or higher.
See <a href="https://quarto.org/docs/projects/profiles.html">https://quarto.org/docs/projects/profiles.html</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a thin wrapper that interprets the output
of <code>quarto::quarto_inspect()</code> and returns what <code>tarchetypes</code> needs to
know about the current Quarto project or document.
</p>


<h3>Value</h3>

<p>A named list of important file paths in a Quarto project or document:
</p>

<ul>
<li> <p><code>sources</code>: source files with <code>tar_load()</code>/<code>tar_read()</code>
target dependencies in R code chunks.
</p>
</li>
<li> <p><code>output</code>: output files that will be generated during
<code>quarto::quarto_render()</code>.
</p>
</li>
<li> <p><code>input</code>: pre-existing files required to render the project or document,
such as <code style="white-space: pre;">&#8288;_quarto.yml&#8288;</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Literate programming utilities: 
<code><a href="#topic+tar_knitr_deps">tar_knitr_deps</a>()</code>,
<code><a href="#topic+tar_knitr_deps_expr">tar_knitr_deps_expr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lines &lt;- c(
  "---",
  "title: source file",
  "---",
  "Assume these lines are in report.qmd.",
  "```{r}",
  "1 + 1",
  "```"
)
path &lt;- tempfile(fileext = ".qmd")
writeLines(lines, path)
# If Quarto is installed, run:
# tar_quarto_files(path)
</code></pre>

<hr>
<h2 id='tar_quarto_raw'>Target with a Quarto project (raw version).</h2><span id='topic+tar_quarto_raw'></span>

<h3>Description</h3>

<p>Shorthand to include a Quarto project or standalone
Quarto source document in a <code>targets</code> pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_raw(
  name,
  path = ".",
  working_directory = NULL,
  extra_files = character(0),
  execute = TRUE,
  execute_params = NULL,
  cache = NULL,
  cache_refresh = FALSE,
  debug = FALSE,
  quiet = TRUE,
  quarto_args = NULL,
  pandoc_args = NULL,
  profile = NULL,
  packages = NULL,
  library = NULL,
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_path">path</code></td>
<td>
<p>Character of length 1,
either the single <code style="white-space: pre;">&#8288;*.qmd&#8288;</code> source file to be rendered
or a directory containing a Quarto project.
Defaults to the working directory of the <code>targets</code> pipeline.
Passed directly to the <code>input</code> argument of <code>quarto::quarto_render()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_extra_files">extra_files</code></td>
<td>
<p>Character vector of extra files and
directories to track for changes. The target will be invalidated
(rerun on the next <code>tar_make()</code>) if the contents of these files changes.
No need to include anything already in the output of <code><a href="#topic+tar_quarto_files">tar_quarto_files()</a></code>,
the list of file dependencies automatically detected through
<code>quarto::quarto_inspect()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_execute">execute</code></td>
<td>
<p>Whether to execute embedded code chunks.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_execute_params">execute_params</code></td>
<td>
<p>A non-expression language object
(use <code>quote()</code>, not <code>expression()</code>) that
evaluates to a named list of parameters
for parameterized Quarto documents. These parameters override the custom
custom elements of the <code>params</code> list in the YAML front-matter of the
Quarto source files. The list is quoted
(not evaluated until the target runs)
so that upstream targets can serve as parameter values.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_cache">cache</code></td>
<td>
<p>Cache execution output (uses knitr cache and jupyter-cache
respectively for Rmd and Jupyter input files).</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_cache_refresh">cache_refresh</code></td>
<td>
<p>Force refresh of execution cache.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_debug">debug</code></td>
<td>
<p>Leave intermediate files in place after render.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_quiet">quiet</code></td>
<td>
<p>Suppress warning and other messages.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_quarto_args">quarto_args</code></td>
<td>
<p>Character vector of other <code>quarto</code> CLI flag pass to the
command. This is mainly for advanced usage, e.g it can be useful for new
options added to quarto CLI and not yet supported as function argument.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_pandoc_args">pandoc_args</code></td>
<td>
<p>Additional command line options to pass to pandoc.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_profile">profile</code></td>
<td>
<p>Character of length 1, Quarto profile. If <code>NULL</code>,
the default profile will be used. Requires Quarto version 1.2 or higher.
See <a href="https://quarto.org/docs/projects/profiles.html">https://quarto.org/docs/projects/profiles.html</a> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_packages">packages</code></td>
<td>
<p>Deprecated on 2023-09-05 (version 0.7.8.9000). Please
load R packages inside the Quarto report itself.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_library">library</code></td>
<td>
<p>Deprecated on 2023-09-05 (version 0.7.8.9000). Please
load R packages inside the Quarto report itself.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_quarto_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_quarto_raw()</code> is just like <code><a href="#topic+tar_quarto">tar_quarto()</a></code>
except that it uses standard evaluation for the
<code>name</code> and <code>execute_params</code> arguments (instead of quoting them).
</p>


<h3>Value</h3>

<p>A target object with <code>format = "file"</code>.
When this target runs, it returns a sorted character vector
of all the important file paths: the rendered documents,
the Quarto source files, and other input and output files.
The output files are determined by the YAML front-matter of
standalone Quarto documents and <code style="white-space: pre;">&#8288;_quarto.yml&#8288;</code> in Quarto projects,
and you can see these files with <code><a href="#topic+tar_quarto_files">tar_quarto_files()</a></code>
(powered by <code>quarto::quarto_inspect()</code>).
All returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>Quarto troubleshooting</h3>

<p>If you encounter difficult errors, please read
<a href="https://github.com/quarto-dev/quarto-r/issues/16">https://github.com/quarto-dev/quarto-r/issues/16</a>.
In addition, please try to reproduce the error using
<code>quarto::quarto_render("your_report.qmd", execute_dir = getwd())</code>
without using <code>targets</code> at all. Isolating errors this way
makes them much easier to solve.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({  # tar_dir() runs code from a temporary directory.
# Unparameterized Quarto document:
lines &lt;- c(
  "---",
  "title: report.qmd source file",
  "output_format: html",
  "---",
  "Assume these lines are in report.qmd.",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
# In tar_dir(), not part of the user's file space:
writeLines(lines, "report.qmd")
# Include the report in a pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_quarto_raw("report", path = "report.qmd")
  )
}, ask = FALSE)
# Then, run the pipeline as usual.

# Parameterized Quarto:
lines &lt;- c(
  "---",
  "title: 'report.qmd source file with parameters'",
  "output_format: html_document",
  "params:",
  "  your_param: \"default value\"",
  "---",
  "Assume these lines are in report.qmd.",
  "```{r}",
  "print(params$your_param)",
  "```"
)
# In tar_dir(), not part of the user's file space:
writeLines(lines, "report.qmd")
# Include the report in the pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_quarto_raw(
      "report",
      path = "report.qmd",
      execute_params = quote(list(your_param = data))
    )
  )
}, ask = FALSE)
# Then, run the pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_quarto_rep'>Parameterized Quarto with dynamic branching.</h2><span id='topic+tar_quarto_rep'></span>

<h3>Description</h3>

<p>Targets to render a parameterized Quarto document
with multiple sets of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_rep(
  name,
  path,
  working_directory = NULL,
  execute_params = data.frame(),
  batches = NULL,
  extra_files = character(0),
  execute = TRUE,
  cache = NULL,
  cache_refresh = FALSE,
  debug = FALSE,
  quiet = TRUE,
  quarto_args = NULL,
  pandoc_args = NULL,
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_rep_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_path">path</code></td>
<td>
<p>Character string, file path to the Quarto source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_execute_params">execute_params</code></td>
<td>
<p>Code to generate
a data frame or <code>tibble</code> with one row per rendered report
and one column per Quarto parameter. You may also include an
<code>output_file</code> column to specify the path of each rendered report.
If included, the <code>output_file</code> column must be a character vector
with one and only one output file for each row of parameters.
If an <code>output_file</code> column is not included,
then the output files are automatically determined using the parameters,
and the default file format is determined by the YAML front-matter
of the Quarto source document. Only the first file format is used,
the others are not generated.
Quarto parameters must not be named <code>tar_group</code> or <code>output_file</code>.
This <code>execute_params</code> argument is converted into the command for a target
that supplies the Quarto parameters.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_extra_files">extra_files</code></td>
<td>
<p>Character vector of extra files that <code>targets</code>
should track for changes. If the content of one of these files changes,
then the report will rerun over all the parameters on the next
<code>tar_make()</code>. These files are <em>extra</em> files, and they
do not include the Quarto
source document or rendered output document,
which are already tracked for changes. Examples include
bibliographies, style sheets, and supporting image files.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_execute">execute</code></td>
<td>
<p>Whether to execute embedded code chunks.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_cache">cache</code></td>
<td>
<p>Cache execution output (uses knitr cache and jupyter-cache
respectively for Rmd and Jupyter input files).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_cache_refresh">cache_refresh</code></td>
<td>
<p>Force refresh of execution cache.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_debug">debug</code></td>
<td>
<p>Leave intermediate files in place after render.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_quiet">quiet</code></td>
<td>
<p>Suppress warning and other messages.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_quarto_args">quarto_args</code></td>
<td>
<p>Character vector of other <code>quarto</code> CLI flag pass to the
command. This is mainly for advanced usage, e.g it can be useful for new
options added to quarto CLI and not yet supported as function argument.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_pandoc_args">pandoc_args</code></td>
<td>
<p>Additional command line options to pass to pandoc.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical of length 1, whether to use tidy evaluation
to resolve <code>execute_params</code>. Similar to the <code>tidy_eval</code>
argument of <code>targets::tar_target()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vectors::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>. In the case of list iteration, <code>tar_read(your_target)</code>
will return a list of lists, where the outer list has one element per
batch and each inner list has one element per rep within batch.
To un-batch this nested list, call
<code>tar_read(your_target, recursive = FALSE)</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code>tar_group()</code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_quarto_rep()</code> is an alternative to <code>tar_target()</code> for
a parameterized Quarto document that depends on other targets.
Parameters must be given as a data frame with one row per
rendered report and one column per parameter. An optional
<code>output_file</code> column may be included to set the output file path
of each rendered report. (See the <code>execute_params</code> argument for details.)
</p>
<p>The Quarto source should mention other dependency targets
<code>tar_load()</code> and <code>tar_read()</code> in the active code chunks
(which also allows you to render the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists
and appropriate defaults are specified for the parameters).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_quarto()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return the output
report files: the rendered document, the source file,
and file paths mentioned in <code>files</code>. All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>quarto::quarto_render()</code>.
</p>


<h3>Value</h3>

<p>A list of target objects to render the Quarto
reports. Changes to the parameters, source file, dependencies, etc.
will cause the appropriate targets to rerun during <code>tar_make()</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>Quarto troubleshooting</h3>

<p>If you encounter difficult errors, please read
<a href="https://github.com/quarto-dev/quarto-r/issues/16">https://github.com/quarto-dev/quarto-r/issues/16</a>.
In addition, please try to reproduce the error using
<code>quarto::quarto_render("your_report.qmd", execute_dir = getwd())</code>
without using <code>targets</code> at all. Isolating errors this way
makes them much easier to solve.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Parameterized Quarto:
lines &lt;- c(
  "---",
  "title: 'report.qmd file'",
  "output_format: html_document",
  "params:",
  "  par: \"default value\"",
  "---",
  "Assume these lines are in a file called report.qmd.",
  "```{r}",
  "print(params$par)",
  "```"
)
writeLines(lines, "report.qmd") # In tar_dir(), not the user's file space.
# The following pipeline will run the report for each row of params.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_quarto_rep(
      report,
      path = "report.qmd",
      execute_params = tibble::tibble(par = c(1, 2))
    )
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_quarto_rep_raw'>Parameterized Quarto with dynamic branching (raw version).</h2><span id='topic+tar_quarto_rep_raw'></span>

<h3>Description</h3>

<p>Targets to render a parameterized Quarto document
with multiple sets of parameters (raw version). Same as
<code>tar_quarto_rep()</code> except <code>name</code> is a character string,
<code>params</code> is an expression object,
and extra arguments to <code>quarto::quarto_render()</code> are passed through
the <code>args</code> argument instead of <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_rep_raw(
  name,
  path,
  working_directory = NULL,
  execute_params = expression(NULL),
  batches = NULL,
  extra_files = character(0),
  execute = TRUE,
  cache = NULL,
  cache_refresh = FALSE,
  debug = FALSE,
  quiet = TRUE,
  quarto_args = NULL,
  pandoc_args = NULL,
  rep_workers = 1,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_rep_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_path">path</code></td>
<td>
<p>Character string, file path to the Quarto source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_execute_params">execute_params</code></td>
<td>
<p>Expression object with code to generate
a data frame or <code>tibble</code> with one row per rendered report
and one column per Quarto parameter. You may also include an
<code>output_file</code> column to specify the path of each rendered report.
If included, the <code>output_file</code> column must be a character vector
with one and only one output file for each row of parameters.
If an <code>output_file</code> column is not included,
then the output files are automatically determined using the parameters,
and the default file format is determined by the YAML front-matter
of the Quarto source document. Only the first file format is used,
the others are not generated.
Quarto parameters must not be named <code>tar_group</code> or <code>output_file</code>.
This <code>execute_params</code> argument is converted into the command for a target
that supplies the Quarto parameters.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_batches">batches</code></td>
<td>
<p>Number of batches to group the Quarto files.
For a large number of reports, increase the number of batches
to decrease target-level overhead. Defaults to the number of
reports to render (1 report per batch).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_extra_files">extra_files</code></td>
<td>
<p>Character vector of extra files that <code>targets</code>
should track for changes. If the content of one of these files changes,
then the report will rerun over all the parameters on the next
<code>tar_make()</code>. These files are <em>extra</em> files, and they
do not include the Quarto
source document or rendered output document,
which are already tracked for changes. Examples include
bibliographies, style sheets, and supporting image files.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_execute">execute</code></td>
<td>
<p>Whether to execute embedded code chunks.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_cache">cache</code></td>
<td>
<p>Cache execution output (uses knitr cache and jupyter-cache
respectively for Rmd and Jupyter input files).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_cache_refresh">cache_refresh</code></td>
<td>
<p>Force refresh of execution cache.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_debug">debug</code></td>
<td>
<p>Leave intermediate files in place after render.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_quiet">quiet</code></td>
<td>
<p>Suppress warning and other messages.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_quarto_args">quarto_args</code></td>
<td>
<p>Character vector of other <code>quarto</code> CLI flag pass to the
command. This is mainly for advanced usage, e.g it can be useful for new
options added to quarto CLI and not yet supported as function argument.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_pandoc_args">pandoc_args</code></td>
<td>
<p>Additional command line options to pass to pandoc.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_format">format</code></td>
<td>
<p>Character of length 1, <code>format</code> argument to <code>tar_target()</code>
to store the data frame of Quarto parameters.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, <code>iteration</code> argument
to <code>tar_target()</code> for the Quarto documents. Does not apply
to the target with Quarto parameters (whose iteration
is always <code>"group"</code>).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_quarto_rep_raw()</code> is an alternative to <code>tar_target_raw()</code> for
parameterized Quarto reports that depend on other targets.
Parameters must be given as a data frame with one row per
rendered report and one column per parameter. An optional
<code>output_file</code> column may be included to set the output file path
of each rendered report. (See the <code>execute_params</code> argument for details.)
</p>
<p>The Quarto source should mention other dependency targets
<code>tar_load()</code> and <code>tar_read()</code> in the active code chunks
(which also allows you to render the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists
and appropriate defaults are specified for the parameters).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_quarto()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return the output
report files: the rendered document, the source file,
and then the <code style="white-space: pre;">&#8288;*_files/&#8288;</code> directory if it exists.
All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>quarto::quarto_render()</code>.
</p>


<h3>Value</h3>

<p>A list of target objects to render the Quarto
reports. Changes to the parameters, source file, dependencies, etc.
will cause the appropriate targets to rerun during <code>tar_make()</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>Quarto troubleshooting</h3>

<p>If you encounter difficult errors, please read
<a href="https://github.com/quarto-dev/quarto-r/issues/16">https://github.com/quarto-dev/quarto-r/issues/16</a>.
In addition, please try to reproduce the error using
<code>quarto::quarto_render("your_report.qmd", execute_dir = getwd())</code>
without using <code>targets</code> at all. Isolating errors this way
makes them much easier to solve.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Parameterized Quarto:
lines &lt;- c(
  "---",
  "title: 'report.qmd source file'",
  "output_format: html_document",
  "params:",
  "  par: \"default value\"",
  "---",
  "Assume these lines are in a file called report.qmd.",
  "```{r}",
  "print(params$par)",
  "```"
)
writeLines(lines, "report.qmd") # In tar_dir(), not the user's file space.
# The following pipeline will run the report for each row of params.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_quarto_rep_raw(
      "report",
      path = "report.qmd",
      execute_params = quote(tibble::tibble(par = c(1, 2)))
    )
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_quarto_rep_rep'>Run a rep in a <code>tar_quarto_rep()</code>.</h2><span id='topic+tar_quarto_rep_rep'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_rep_rep(rep, execute_params, args, default_output_file, seeds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_rep_rep_+3A_rep">rep</code></td>
<td>
<p>Rep number.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_rep_+3A_execute_params">execute_params</code></td>
<td>
<p>Quarto parameters.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_rep_+3A_args">args</code></td>
<td>
<p>Arguments to <code>quarto::quarto_render()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_rep_+3A_default_output_file">default_output_file</code></td>
<td>
<p>Default Quarto output file.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_rep_+3A_seeds">seeds</code></td>
<td>
<p>Random number generator seeds of the batch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output file paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_quarto_rep().
</code></pre>

<hr>
<h2 id='tar_quarto_rep_run'>Render a batch of parameterized Quarto reports
inside a <code>tar_quarto_rep()</code> target.</h2><span id='topic+tar_quarto_rep_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_quarto()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_rep_run(
  args,
  execute_params,
  extra_files,
  deps,
  default_output_file,
  rep_workers
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_rep_run_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>quarto::quarto_render()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_+3A_execute_params">execute_params</code></td>
<td>
<p>A data frame of Quarto parameters to branch over.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_+3A_extra_files">extra_files</code></td>
<td>
<p>Character vector of extra files that <code>targets</code>
should track for changes. If the content of one of these files changes,
then the report will rerun over all the parameters on the next
<code>tar_make()</code>. These files are <em>extra</em> files, and they
do not include the Quarto
source document or rendered output document,
which are already tracked for changes. Examples include
bibliographies, style sheets, and supporting image files.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_+3A_deps">deps</code></td>
<td>
<p>An unnamed list of target dependencies of the Quarto
report, automatically created by <code>tar_quarto_rep()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_+3A_default_output_file">default_output_file</code></td>
<td>
<p>Output file path determined by the
YAML front-matter of the Quarto source document.
Automatic output file names are based on this file.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the path to the Quarto
source file and the rendered output file. Both paths
depend on the input source path, and they have no defaults.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Parameterized Quarto:
lines &lt;- c(
  "---",
  "title: 'report.qmd source file'",
  "output_format: html_document",
  "params:",
  "  par: \"default value\"",
  "---",
  "Assume these lines are in a file called report.qmd.",
  "```{r}",
  "print(params$par)",
  "```"
)
writeLines(lines, "report.qmd") # In tar_dir(), not the user's file space.
args &lt;- list(
  input = "report.qmd",
  execute = TRUE,
  execute_dir = quote(getwd()),
  execute_daemon = 0,
  execute_daemon_restart = FALSE,
  execute_debug = FALSE,
  cache = FALSE,
  cache_refresh = FALSE,
  debug = FALSE,
  quiet = TRUE,
  as_job = FALSE
)
execute_params &lt;- tibble::tibble(
  par = c("non-default value 1", "non-default value 2"),
  output_file = c("report1.html", "report2.html")
)
tar_quarto_rep_run(
  args = args,
  execute_params = execute_params,
  extra_files = character(0),
  deps = NULL,
  default_output_file = "report_default.html"
)
})
}
</code></pre>

<hr>
<h2 id='tar_quarto_rep_run_params'>Prepare Quarto parameters for <code>tar_quarto_rep()</code>.</h2><span id='topic+tar_quarto_rep_run_params'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_quarto_rep()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_rep_run_params(execute_params, batches, default_output_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_rep_run_params_+3A_execute_params">execute_params</code></td>
<td>
<p>Data frame of Quarto parameters.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_params_+3A_batches">batches</code></td>
<td>
<p>Number of batches to split up the renderings.</p>
</td></tr>
<tr><td><code id="tar_quarto_rep_run_params_+3A_default_output_file">default_output_file</code></td>
<td>
<p>Default output file path deduced
from the YAML front-matter of the Quarto source document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A batched data frame of Quarto parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>execute_params &lt;- tibble::tibble(param1 = letters[seq_len(4)])
tar_quarto_rep_run_params(execute_params, 1, "report.html")
tar_quarto_rep_run_params(execute_params, 2, "report.html")
tar_quarto_rep_run_params(execute_params, 3, "report.html")
tar_quarto_rep_run_params(execute_params, 4, "report.html")
</code></pre>

<hr>
<h2 id='tar_quarto_run'>Render a Quarto project inside a <code>tar_quarto()</code> target.</h2><span id='topic+tar_quarto_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_quarto()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_quarto_run(args, deps, sources, output, input, profile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_quarto_run_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>quarto::quarto_render()</code>.</p>
</td></tr>
<tr><td><code id="tar_quarto_run_+3A_deps">deps</code></td>
<td>
<p>An unnamed list of target dependencies of the Quarto
source files.</p>
</td></tr>
<tr><td><code id="tar_quarto_run_+3A_sources">sources</code></td>
<td>
<p>Character vector of Quarto source files.</p>
</td></tr>
<tr><td><code id="tar_quarto_run_+3A_output">output</code></td>
<td>
<p>Character vector of Quarto output files and directories.</p>
</td></tr>
<tr><td><code id="tar_quarto_run_+3A_input">input</code></td>
<td>
<p>Character vector of non-source Quarto input files
and directories.</p>
</td></tr>
<tr><td><code id="tar_quarto_run_+3A_profile">profile</code></td>
<td>
<p>Quarto profile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted character vector with the paths to all the important
files that <code>targets</code> should track for changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({  # tar_dir() runs code from a temporary directory.
# Unparameterized Quarto document:
lines &lt;- c(
  "---",
  "title: Quarto source file",
  "output_format: html",
  "---",
  "Assume these lines are in the Quarto source file.",
  "```{r}",
  "1 + 1",
  "```"
)
tmp &lt;- tempfile(fileext = ".qmd")
writeLines(lines, tmp)
args &lt;- list(input = tmp, quiet = TRUE)
files &lt;- fs::path_ext_set(tmp, "html")
tar_quarto_run(args = args, deps = list(), files = files)
file.exists(files)
})
}
</code></pre>

<hr>
<h2 id='tar_render'>Target with an R Markdown document.</h2><span id='topic+tar_render'></span>

<h3>Description</h3>

<p>Shorthand to include an R Markdown document in a
<code>targets</code> pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render(
  name,
  path,
  output_file = NULL,
  working_directory = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_path">path</code></td>
<td>
<p>Character string, file path to the R Markdown source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_output_file">output_file</code></td>
<td>
<p>Character string, file path to the rendered output file.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_render_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_render_+3A_quiet">quiet</code></td>
<td>
<p>An option to suppress printing during rendering from knitr,
pandoc command line and others. To only suppress printing of the last
&quot;Output created: &quot; message, you can set <code>rmarkdown.render.message</code> to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="tar_render_+3A_...">...</code></td>
<td>
<p>Named arguments to <code>rmarkdown::render()</code>.
These arguments are evaluated when the target actually runs in
<code>tar_make()</code>, not when the target is defined. That means, for
example, you can use upstream targets as parameters of
parameterized R Markdown reports.
<code>tar_render(your_target, "your_report.Rmd", params = list(your_param = your_target))</code> # nolint
will run <code>rmarkdown::render("your_report.Rmd", params = list(your_param = your_target))</code>. # nolint
For parameterized reports, it is recommended to supply a distinct
<code>output_file</code> argument to each <code>tar_render()</code> call
and set useful defaults for parameters in the R Markdown source.
See the examples section for a demonstration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_render()</code> is an alternative to <code>tar_target()</code> for
R Markdown reports that depend on other targets. The R Markdown source
should mention dependency targets with <code>tar_load()</code> and <code>tar_read()</code>
in the active code chunks (which also allows you to render the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_render()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return both the output
report files and the input source file. All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>rmarkdown::render()</code>.
</p>


<h3>Value</h3>

<p>A target object with <code>format = "file"</code>.
When this target runs, it returns a character vector
of file paths: the rendered document, the source file,
and then the <code style="white-space: pre;">&#8288;*_files/&#8288;</code> directory if it exists.
Unlike <code>rmarkdown::render()</code>,
all returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({  # tar_dir() runs code from a temporary directory.
# Unparameterized R Markdown:
lines &lt;- c(
  "---",
  "title: report.Rmd source file",
  "output_format: html_document",
  "---",
  "Assume these lines are in report.Rmd.",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
# Include the report in a pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render(report, "report.Rmd")
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.

# Parameterized R Markdown:
lines &lt;- c(
  "---",
  "title: 'report.Rmd source file with parameters'",
  "output_format: html_document",
  "params:",
  "  your_param: \"default value\"",
  "---",
  "Assume these lines are in report.Rmd.",
  "```{r}",
  "print(params$your_param)",
  "```"
)
# Include the report in the pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render(report, "report.Rmd", params = list(your_param = data))
  )
}, ask = FALSE)
})
# Then, run the targets pipeline as usual.
}
</code></pre>

<hr>
<h2 id='tar_render_raw'>Target with an R Markdown document (raw version).</h2><span id='topic+tar_render_raw'></span>

<h3>Description</h3>

<p>Shorthand to include an R Markdown document in a
<code>targets</code> pipeline (raw version)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_raw(
  name,
  path,
  output_file = NULL,
  working_directory = NULL,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  deployment = "main",
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  render_arguments = quote(list())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_path">path</code></td>
<td>
<p>Character string, file path to the R Markdown source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_output_file">output_file</code></td>
<td>
<p>Character string, file path to the rendered output file.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_quiet">quiet</code></td>
<td>
<p>An option to suppress printing during rendering from knitr,
pandoc command line and others. To only suppress printing of the last
&quot;Output created: &quot; message, you can set <code>rmarkdown.render.message</code> to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="tar_render_raw_+3A_render_arguments">render_arguments</code></td>
<td>
<p>Optional language object with a list
of named arguments to <code>rmarkdown::render()</code>.
Cannot be an expression object.
(Use <code>quote()</code>, not <code>expression()</code>.)
The reason for quoting is that these arguments may depend on
upstream targets whose values are not available at
the time the target is defined, and because <code>tar_render_raw()</code>
is the &quot;raw&quot; version of a function, we want to avoid
all non-standard evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_render_raw()</code> is just like <code>tar_render()</code>
except that it uses standard evaluation. The <code>name</code> argument
is a character vector, and the <code>render_arguments</code> argument
is a language object.
</p>


<h3>Value</h3>

<p>A target object with <code>format = "file"</code>.
When this target runs, it returns a character vector
of file paths: the rendered document, the source file,
and then the <code style="white-space: pre;">&#8288;*_files/&#8288;</code> directory if it exists.
Unlike <code>rmarkdown::render()</code>,
all returned paths are <em>relative</em> paths to ensure portability
(so that the project can be moved from one file system to another
without invalidating the target).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Unparameterized R Markdown report:
lines &lt;- c(
  "---",
  "title: 'report.Rmd source file'",
  "output_format: html_document",
  "---",
  "Assume these lines are in report.Rmd.",
  "```{r}",
  "targets::tar_read(data)",
  "```"
)
# Include the report in the pipeline as follows:
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render_raw("report", "report.Rmd")
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.

# Parameterized R Markdown:
lines &lt;- c(
  "---",
  "title: 'report.Rmd source file with parameters.'",
  "output_format: html_document",
  "params:",
  "  your_param: \"default value\"",
  "---",
  "Assume these lines are in report.Rmd.",
  "```{r}",
  "print(params$your_param)",
  "```"
)
# Include this parameterized report in the pipeline as follows.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_target(data, data.frame(x = seq_len(26), y = letters)),
    tar_render_raw(
      "report",
      "report.Rmd",
      render_arguments = quote(list(params = list(your_param = data)))
    )
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_render_rep'>Parameterized R Markdown with dynamic branching.</h2><span id='topic+tar_render_rep'></span>

<h3>Description</h3>

<p>Targets to render a parameterized R Markdown report
with multiple sets of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_rep(
  name,
  path,
  working_directory = NULL,
  params = data.frame(),
  batches = NULL,
  rep_workers = 1,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_rep_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_path">path</code></td>
<td>
<p>Character string, file path to the R Markdown source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_params">params</code></td>
<td>
<p>Code to generate a data frame or <code>tibble</code>
with one row per rendered report
and one column per R Markdown parameter. You may also include an
<code>output_file</code> column to specify the path of each rendered report.
This <code>params</code> argument is converted into the command for a target
that supplies the R Markdown parameters.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vectors::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>. In the case of list iteration, <code>tar_read(your_target)</code>
will return a list of lists, where the outer list has one element per
batch and each inner list has one element per rep within batch.
To un-batch this nested list, call
<code>tar_read(your_target, recursive = FALSE)</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code>tar_group()</code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_quiet">quiet</code></td>
<td>
<p>An option to suppress printing during rendering from knitr,
pandoc command line and others. To only suppress printing of the last
&quot;Output created: &quot; message, you can set <code>rmarkdown.render.message</code> to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="tar_render_rep_+3A_...">...</code></td>
<td>
<p>Other named arguments to <code>rmarkdown::render()</code>.
Unlike <code><a href="#topic+tar_render">tar_render()</a></code>, these arguments are evaluated when the target
is defined, not when it is run. (The only reason to delay evaluation
in <code><a href="#topic+tar_render">tar_render()</a></code> was to handle R Markdown parameters, and
<code>tar_render_rep()</code> handles them differently.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_render_rep()</code> is an alternative to <code>tar_target()</code> for
parameterized R Markdown reports that depend on other targets.
Parameters must be given as a data frame with one row per
rendered report and one column per parameter. An optional
<code>output_file</code> column may be included to set the output file path
of each rendered report.
The R Markdown source should mention other dependency targets
<code>tar_load()</code> and <code>tar_read()</code> in the active code chunks
(which also allows you to render the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists
and appropriate defaults are specified for the parameters).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_render()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return the output
report files: the rendered document, the source file,
and then the <code style="white-space: pre;">&#8288;*_files/&#8288;</code> directory if it exists. All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>rmarkdown::render()</code>.
</p>


<h3>Value</h3>

<p>A list of target objects to render the R Markdown
reports. Changes to the parameters, source file, dependencies, etc.
will cause the appropriate targets to rerun during <code>tar_make()</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep_raw">tar_render_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Parameterized R Markdown:
lines &lt;- c(
  "---",
  "title: 'report.Rmd file'",
  "output_format: html_document",
  "params:",
  "  par: \"default value\"",
  "---",
  "Assume these lines are in a file called report.Rmd.",
  "```{r}",
  "print(params$par)",
  "```"
)
# The following pipeline will run the report for each row of params.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_render_rep(
      report,
      "report.Rmd",
      params = tibble::tibble(par = c(1, 2))
    )
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_render_rep_raw'>Parameterized R Markdown with dynamic branching (raw version).</h2><span id='topic+tar_render_rep_raw'></span>

<h3>Description</h3>

<p>Targets to render a parameterized R Markdown report
with multiple sets of parameters (raw version). Same as
<code>tar_render_rep()</code> except <code>name</code> is a character string,
<code>params</code> is an expression object,
and extra arguments to <code>rmarkdown::render()</code> are passed through
the <code>args</code> argument instead of <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_rep_raw(
  name,
  path,
  working_directory = NULL,
  params = expression(NULL),
  batches = NULL,
  rep_workers = 1,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description"),
  quiet = TRUE,
  args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_rep_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_path">path</code></td>
<td>
<p>Character string, file path to the R Markdown source file.
Must have length 1.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_working_directory">working_directory</code></td>
<td>
<p>Optional character string,
path to the working directory
to temporarily set when running the report.
The default is <code>NULL</code>, which runs the report from the
current working directory at the time the pipeline is run.
This default is recommended in the vast majority of cases.
To use anything other than <code>NULL</code>, you must manually set the value
of the <code>store</code> argument relative to the working directory in all calls
to <code>tar_read()</code> and <code>tar_load()</code> in the report. Otherwise,
these functions will not know where to find the data.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_params">params</code></td>
<td>
<p>Expression object with code to generate
a data frame or <code>tibble</code> with one row per rendered report
and one column per R Markdown parameter. You may also include an
<code>output_file</code> column to specify the path of each rendered report.
R Markdown parameters must not be named <code>tar_group</code> or <code>output_file</code>.
This <code>params</code> argument is converted into the command for a target
that supplies the R Markdown parameters.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_batches">batches</code></td>
<td>
<p>Number of batches to group the R Markdown files.
For a large number of reports, increase the number of batches
to decrease target-level overhead. Defaults to the number of
reports to render (1 report per batch).</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_format">format</code></td>
<td>
<p>Character of length 1, <code>format</code> argument to <code>tar_target()</code>
to store the data frame of R Markdown parameters.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, <code>iteration</code> argument
to <code>tar_target()</code> for the R Markdown documents. Does not apply
to the target with R Markdown parameters (whose iteration
is always <code>"group"</code>).</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_quiet">quiet</code></td>
<td>
<p>An option to suppress printing during rendering from knitr,
pandoc command line and others. To only suppress printing of the last
&quot;Output created: &quot; message, you can set <code>rmarkdown.render.message</code> to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="tar_render_rep_raw_+3A_args">args</code></td>
<td>
<p>Named list of other arguments to <code>rmarkdown::render()</code>.
Must not include <code>params</code> or <code>output_file</code>. Evaluated when the target
is defined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_render_rep_raw()</code> is an alternative to <code>tar_target_raw()</code> for
parameterized R Markdown reports that depend on other targets.
Parameters must be given as a data frame with one row per
rendered report and one column per parameter. An optional
<code>output_file</code> column may be included to set the output file path
of each rendered report.
The R Markdown source should mention other dependency targets
<code>tar_load()</code> and <code>tar_read()</code> in the active code chunks
(which also allows you to render the report
outside the pipeline if the <code style="white-space: pre;">&#8288;_targets/&#8288;</code> data store already exists
and appropriate defaults are specified for the parameters).
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
Then, <code>tar_render()</code> defines a special kind of target. It
1. Finds all the <code>tar_load()</code>/<code>tar_read()</code> dependencies in the report
and inserts them into the target's command.
This enforces the proper dependency relationships.
(Do not use <code>tar_load_raw()</code> or <code>tar_read_raw()</code> for this.)
2. Sets <code>format = "file"</code> (see <code>tar_target()</code>) so <code>targets</code>
watches the files at the returned paths and reruns the report
if those files change.
3. Configures the target's command to return the output
report files: the rendered document, the source file,
and then the <code style="white-space: pre;">&#8288;*_files/&#8288;</code> directory if it exists.
All these file paths
are relative paths so the project stays portable.
4. Forces the report to run in the user's current working directory
instead of the working directory of the report.
5. Sets convenient default options such as <code>deployment = "main"</code>
in the target and <code>quiet = TRUE</code> in <code>rmarkdown::render()</code>.
</p>


<h3>Value</h3>

<p>A list of target objects to render the R Markdown
reports. Changes to the parameters, source file, dependencies, etc.
will cause the appropriate targets to rerun during <code>tar_make()</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Literate programming limitations</h3>

<p>Literate programming files are messy and variable,
so functions like <code><a href="#topic+tar_render">tar_render()</a></code> have limitations:
* Child documents are not tracked for changes.
* Upstream target dependencies are not detected if <code>tar_read()</code>
and/or <code>tar_load()</code> are called from a user-defined function.
In addition, single target names must be mentioned and they must
be symbols. <code>tar_load("x")</code> and <code>tar_load(contains("x"))</code> may not
detect target <code>x</code>.
* Special/optional input/output files may not be detected in all cases.
* <code><a href="#topic+tar_render">tar_render()</a></code> and friends are for local files only. They do not
integrate with the cloud storage capabilities of <code>targets</code>.
</p>


<h3>See Also</h3>

<p>Other Literate programming targets: 
<code><a href="#topic+tar_knit">tar_knit</a>()</code>,
<code><a href="#topic+tar_knit_raw">tar_knit_raw</a>()</code>,
<code><a href="#topic+tar_quarto">tar_quarto</a>()</code>,
<code><a href="#topic+tar_quarto_raw">tar_quarto_raw</a>()</code>,
<code><a href="#topic+tar_quarto_rep">tar_quarto_rep</a>()</code>,
<code><a href="#topic+tar_quarto_rep_raw">tar_quarto_rep_raw</a>()</code>,
<code><a href="#topic+tar_render">tar_render</a>()</code>,
<code><a href="#topic+tar_render_raw">tar_render_raw</a>()</code>,
<code><a href="#topic+tar_render_rep">tar_render_rep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
# Parameterized R Markdown:
lines &lt;- c(
  "---",
  "title: 'report.Rmd source file'",
  "output_format: html_document",
  "params:",
  "  par: \"default value\"",
  "---",
  "Assume these lines are in a file called report.Rmd.",
  "```{r}",
  "print(params$par)",
  "```"
)
# The following pipeline will run the report for each row of params.
targets::tar_script({
  library(tarchetypes)
  list(
    tar_render_rep_raw(
      "report",
      "report.Rmd",
      params = quote(tibble::tibble(par = c(1, 2)))
    )
  )
}, ask = FALSE)
# Then, run the targets pipeline as usual.
})
}
</code></pre>

<hr>
<h2 id='tar_render_rep_rep'>Run a rep in a <code>tar_render_rep()</code>.</h2><span id='topic+tar_render_rep_rep'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_rep_rep(rep, params, args, path, seeds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_rep_rep_+3A_rep">rep</code></td>
<td>
<p>Rep number.</p>
</td></tr>
<tr><td><code id="tar_render_rep_rep_+3A_params">params</code></td>
<td>
<p>R Markdown parameters.</p>
</td></tr>
<tr><td><code id="tar_render_rep_rep_+3A_args">args</code></td>
<td>
<p>Arguments to <code>rmarkdown::render()</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_rep_+3A_path">path</code></td>
<td>
<p>R Markdown output file.</p>
</td></tr>
<tr><td><code id="tar_render_rep_rep_+3A_seeds">seeds</code></td>
<td>
<p>Random number generator seeds of the batch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output file paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_quarto_rep().
</code></pre>

<hr>
<h2 id='tar_render_rep_run'>Render a batch of parameterized R Markdown reports
inside a <code>tar_render_rep()</code> target.</h2><span id='topic+tar_render_rep_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_render()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_rep_run(path, params, args, deps, rep_workers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_rep_run_+3A_path">path</code></td>
<td>
<p>Path to the R Markdown source file.</p>
</td></tr>
<tr><td><code id="tar_render_rep_run_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>rmarkdown::render()</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_run_+3A_deps">deps</code></td>
<td>
<p>An unnamed list of target dependencies of the R Markdown
report, automatically created by <code>tar_render_rep()</code>.</p>
</td></tr>
<tr><td><code id="tar_render_rep_run_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the path to the R Markdown
source file and the rendered output file. Both paths
depend on the input source path, and they have no defaults.
</p>

<hr>
<h2 id='tar_render_rep_run_params'>Prepare R Markdown parameters for <code>tar_render_rep()</code>.</h2><span id='topic+tar_render_rep_run_params'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_render_rep()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_rep_run_params(params, batches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_rep_run_params_+3A_params">params</code></td>
<td>
<p>Data frame of R Markdown parameters.</p>
</td></tr>
<tr><td><code id="tar_render_rep_run_params_+3A_batches">batches</code></td>
<td>
<p>Number of batches to split up the renderings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A batched data frame of R Markdown parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- tibble::tibble(param1 = letters[seq_len(4)])
tar_render_rep_run_params(params, 1)
tar_render_rep_run_params(params, 2)
tar_render_rep_run_params(params, 3)
tar_render_rep_run_params(params, 4)
</code></pre>

<hr>
<h2 id='tar_render_run'>Render an R Markdown report inside a <code>tar_render()</code> target.</h2><span id='topic+tar_render_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_render()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_render_run(path, args, deps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_render_run_+3A_path">path</code></td>
<td>
<p>Path to the R Markdown source file.</p>
</td></tr>
<tr><td><code id="tar_render_run_+3A_args">args</code></td>
<td>
<p>A named list of arguments to <code>rmarkdown::render()</code>.</p>
</td></tr>
<tr><td><code id="tar_render_run_+3A_deps">deps</code></td>
<td>
<p>An unnamed list of target dependencies of the R Markdown
report, automatically created by <code>tar_render()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the path to the R Markdown source file
and the relative path to the output. These paths depend on the input
source file path and have no defaults.
</p>

<hr>
<h2 id='tar_rep'>Batched replication with dynamic branching.</h2><span id='topic+tar_rep'></span>

<h3>Description</h3>

<p>Batching is important for optimizing the efficiency
of heavily dynamically-branched workflows:
<a href="https://books.ropensci.org/targets/dynamic.html#batching">https://books.ropensci.org/targets/dynamic.html#batching</a>.
<code><a href="#topic+tar_rep">tar_rep()</a></code> replicates a command in strategically sized batches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep(
  name,
  command,
  batches = 1,
  reps = 1,
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_command">command</code></td>
<td>
<p>R code to run multiple times. Must return a list or
data frame because <code>tar_rep()</code> will try to append new elements/columns
<code>tar_batch</code> and <code>tar_rep</code> to the output to denote the batch
and rep-within-batch IDs, respectively.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_reps">reps</code></td>
<td>
<p>Number of replications in each batch. The total number
of replications is <code>batches * reps</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vectors::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>. In the case of list iteration, <code>tar_read(your_target)</code>
will return a list of lists, where the outer list has one element per
batch and each inner list has one element per rep within batch.
To un-batch this nested list, call
<code>tar_read(your_target, recursive = FALSE)</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a data frame. The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code>tar_group()</code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_rep()</code> and <code>tar_rep_raw()</code> each create two targets:
an upstream local stem
with an integer vector of batch ids, and a downstream pattern
that maps over the batch ids. (Thus, each batch is a branch.)
Each batch/branch replicates the command a certain number of times.
If the command returns a list or data frame, then
the targets from <code>tar_rep()</code> will try to append new elements/columns
<code>tar_batch</code>, <code>tar_rep</code>, and <code>tar_seed</code> to the output
to denote the batch, rep-within-batch index, and rep-specific seed,
respectively.
</p>
<p>Both batches and reps within each batch
are aggregated according to the method you specify
in the <code>iteration</code> argument. If <code>"list"</code>, reps and batches
are aggregated with <code>list()</code>. If <code>"vector"</code>,
then <code>vctrs::vec_c()</code>. If <code>"group"</code>, then <code>vctrs::vec_rbind()</code>.
</p>


<h3>Value</h3>

<p>A list of two targets, one upstream and one downstream.
The upstream target returns a numeric index of batch ids,
and the downstream one dynamically maps over the batch ids
to run the command multiple times.
If the command returns a list or data frame, then
the targets from <code>tar_rep()</code> will try to append new elements/columns
<code>tar_batch</code> and <code>tar_rep</code> to the output
to denote the batch and rep-within-batch IDs, respectively.
See the &quot;Target objects&quot; section for background.
</p>
<p><code>tar_read(your_target)</code> (on the downstream target with the actual work)
will return a list of lists, where the outer list has one element per
batch and each inner list has one element per rep within batch.
To un-batch this nested list, call
<code>tar_read(your_target, recursive = FALSE)</code>.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep(
      x,
      data.frame(x = sample.int(1e4, 2)),
      batches = 2,
      reps = 3
    )
  )
})
targets::tar_make()
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_rep_map'>Dynamic batched computation downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code> (deprecated).</h2><span id='topic+tar_rep_map'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+tar_rep2">tar_rep2()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep_map(
  name,
  command,
  ...,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_map_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_...">...</code></td>
<td>
<p>Symbols to name one or more upstream batched targets
created by <code><a href="#topic+tar_rep">tar_rep()</a></code>.
If you supply more than one such target, all those targets must have the
same number of batches and reps per batch. And they must all return
either data frames or lists. List targets must use <code>iteration = "list"</code>
in <code><a href="#topic+tar_rep">tar_rep()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep_map_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated in version 0.4.0, 2021-12-06.
</p>


<h3>Value</h3>

<p>A new target object to perform batched computation.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep(
      data1,
      data.frame(value = rnorm(1)),
      batches = 2,
      reps = 3
    ),
    tarchetypes::tar_rep(
      data2,
      list(value = rnorm(1)),
      batches = 2, reps = 3,
      iteration = "list" # List iteration is important for batched lists.
    ),
    tarchetypes::tar_rep2( # Use instead of tar_rep_map().
      aggregate,
      data.frame(value = data1$value + data2$value),
      data1,
      data2
    )
  )
})
targets::tar_make()
targets::tar_read(aggregate)
})
}
</code></pre>

<hr>
<h2 id='tar_rep_map_raw'>Dynamic batched computation downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code>
(raw; deprecated).</h2><span id='topic+tar_rep_map_raw'></span>

<h3>Description</h3>

<p>Deprecated. Use <code><a href="#topic+tar_rep2_raw">tar_rep2_raw()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep_map_raw(
  name,
  command,
  targets,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_map_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_targets">targets</code></td>
<td>
<p>Character vector of names of upstream batched targets
created by <code><a href="#topic+tar_rep">tar_rep()</a></code>.
If you supply more than one such target, all those targets must have the
same number of batches and reps per batch. And they must all return
either data frames or lists. List targets must use <code>iteration = "list"</code>
in <code><a href="#topic+tar_rep">tar_rep()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep_map_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated in version 0.4.0, 2021-12-06.
</p>


<h3>Value</h3>

<p>A new target object to perform batched computation
downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep(
      data1,
      data.frame(value = rnorm(1)),
      batches = 2,
      reps = 3
    ),
    tarchetypes::tar_rep(
      data2,
      list(value = rnorm(1)),
      batches = 2, reps = 3,
      iteration = "list" # List iteration is important for batched lists.
    ),
    tarchetypes::tar_rep2_raw( # Use instead of tar_rep_map_raw().
      "aggregate",
      quote(data.frame(value = data1$value + data2$value)),
      targets = c("data1", "data2")
    )
  )
})
targets::tar_make()
targets::tar_read(aggregate)
})
}
</code></pre>

<hr>
<h2 id='tar_rep_raw'>Batched replication with dynamic branching
(raw version).</h2><span id='topic+tar_rep_raw'></span>

<h3>Description</h3>

<p>Batching is important for optimizing the efficiency
of heavily dynamically-branched workflows:
<a href="https://books.ropensci.org/targets/dynamic.html#batching">https://books.ropensci.org/targets/dynamic.html#batching</a>.
<code><a href="#topic+tar_rep_raw">tar_rep_raw()</a></code> is just like <code><a href="#topic+tar_rep">tar_rep()</a></code> except the
name is a character string and the command is a
language object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep_raw(
  name,
  command,
  batches = 1,
  reps = 1,
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_command">command</code></td>
<td>
<p>Expression object with code to run multiple times.
Must return a list or data frame when evaluated.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_batches">batches</code></td>
<td>
<p>Number of batches. This is also the number of dynamic
branches created during <code>tar_make()</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_reps">reps</code></td>
<td>
<p>Number of replications in each batch. The total number
of replications is <code>batches * reps</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to the <code>command</code> argument.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_rep_raw()</code> creates two targets:
an upstream local stem
with an integer vector of batch ids, and a downstream pattern
that maps over the batch ids. (Thus, each batch is a branch.)
Each batch/branch replicates the command a certain number of times.
</p>
<p>Both batches and reps within each batch
are aggregated according to the method you specify
in the <code>iteration</code> argument. If <code>"list"</code>, reps and batches
are aggregated with <code>list()</code>. If <code>"vector"</code>,
then <code>vctrs::vec_c()</code>. If <code>"group"</code>, then <code>vctrs::vec_rbind()</code>.
</p>


<h3>Value</h3>

<p>A list of two target objects, one upstream and one downstream.
The upstream one does some work and returns some file paths,
and the downstream target is a pattern that applies <code>format = "file"</code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep_raw(
      "x",
      expression(data.frame(x = sample.int(1e4, 2))),
      batches = 2,
      reps = 3
    )
  )
})
targets::tar_make(callr_function = NULL)
targets::tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_rep_run'>Run a batch in a <code>tar_rep()</code> archetype.</h2><span id='topic+tar_rep_run'></span>

<h3>Description</h3>

<p>Internal function needed for <code>tar_rep()</code>.
Users should not invoke it directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep_run(command, batch, reps, iteration, rep_workers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_run_+3A_command">command</code></td>
<td>
<p>Expression object, command to replicate.</p>
</td></tr>
<tr><td><code id="tar_rep_run_+3A_batch">batch</code></td>
<td>
<p>Numeric of length 1, batch index.</p>
</td></tr>
<tr><td><code id="tar_rep_run_+3A_reps">reps</code></td>
<td>
<p>Numeric of length 1, number of reps per batch.</p>
</td></tr>
<tr><td><code id="tar_rep_run_+3A_iteration">iteration</code></td>
<td>
<p>Character, iteration method.</p>
</td></tr>
<tr><td><code id="tar_rep_run_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated results of multiple executions of the
user-defined command supplied to <code><a href="#topic+tar_rep">tar_rep()</a></code>. Depends on what
the user specifies. Common use cases are simulated datasets.
</p>

<hr>
<h2 id='tar_rep_run_map_rep'>Run a rep in <code>tar_rep()</code>.</h2><span id='topic+tar_rep_run_map_rep'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep_run_map_rep(rep, expr, batch, seeds, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep_run_map_rep_+3A_rep">rep</code></td>
<td>
<p>Rep number.</p>
</td></tr>
<tr><td><code id="tar_rep_run_map_rep_+3A_expr">expr</code></td>
<td>
<p>R expression to run.</p>
</td></tr>
<tr><td><code id="tar_rep_run_map_rep_+3A_batch">batch</code></td>
<td>
<p>Batch number.</p>
</td></tr>
<tr><td><code id="tar_rep_run_map_rep_+3A_seeds">seeds</code></td>
<td>
<p>Random number generator seeds of the batch.</p>
</td></tr>
<tr><td><code id="tar_rep_run_map_rep_+3A_envir">envir</code></td>
<td>
<p>Environment of the target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of running <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_rep().
</code></pre>

<hr>
<h2 id='tar_rep2'>Dynamic batched computation downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code></h2><span id='topic+tar_rep2'></span>

<h3>Description</h3>

<p>Batching is important for optimizing the efficiency
of heavily dynamically-branched workflows:
<a href="https://books.ropensci.org/targets/dynamic.html#batching">https://books.ropensci.org/targets/dynamic.html#batching</a>.
<code><a href="#topic+tar_rep2">tar_rep2()</a></code> uses dynamic branching to iterate
over the batches and reps of existing upstream targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep2(
  name,
  command,
  ...,
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep2_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_...">...</code></td>
<td>
<p>Symbols to name one or more upstream batched targets
created by <code><a href="#topic+tar_rep">tar_rep()</a></code>.
If you supply more than one such target, all those targets must have the
same number of batches and reps per batch. And they must all return
either data frames or lists. List targets must use <code>iteration = "list"</code>
in <code><a href="#topic+tar_rep">tar_rep()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep2_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new target object to perform batched computation.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2_raw">tar_rep2_raw</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep(
      data1,
      data.frame(value = rnorm(1)),
      batches = 2,
      reps = 3
    ),
    tarchetypes::tar_rep(
      data2,
      list(value = rnorm(1)),
      batches = 2, reps = 3,
      iteration = "list" # List iteration is important for batched lists.
    ),
    tarchetypes::tar_rep2(
      aggregate,
      data.frame(value = data1$value + data2$value),
      data1,
      data2
    )
  )
})
targets::tar_make()
targets::tar_read(aggregate)
})
}
</code></pre>

<hr>
<h2 id='tar_rep2_raw'>Dynamic batched computation downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code> (raw version).</h2><span id='topic+tar_rep2_raw'></span>

<h3>Description</h3>

<p>Batching is important for optimizing the efficiency
of heavily dynamically-branched workflows:
<a href="https://books.ropensci.org/targets/dynamic.html#batching">https://books.ropensci.org/targets/dynamic.html#batching</a>.
<code>tar_rep2_raw()</code>
is just like <code><a href="#topic+tar_rep2">tar_rep2()</a></code> except it accepts a character
of length 1 for <code>name</code>, a language object for <code>command</code>,
and a character vector of the names of the upstream batched targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep2_raw(
  name,
  command,
  targets,
  rep_workers = 1,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep2_raw_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_targets">targets</code></td>
<td>
<p>Character vector of names of upstream batched targets
created by <code><a href="#topic+tar_rep">tar_rep()</a></code>.
If you supply more than one such target, all those targets must have the
same number of batches and reps per batch. And they must all return
either data frames or lists. List targets must use <code>iteration = "list"</code>
in <code><a href="#topic+tar_rep">tar_rep()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_rep2_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new target object to perform batched computation
downstream of <code><a href="#topic+tar_rep">tar_rep()</a></code>.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Replicate-specific seeds</h3>

<p>In ordinary pipelines, each target has its own unique deterministic
pseudo-random number generator seed derived from its target name.
In batched replicate, however, each batch is a target with multiple
replicate within that batch. That is why <code><a href="#topic+tar_rep">tar_rep()</a></code>
and friends give each <em>replicate</em> its own unique seed.
Each replicate-specific seed is created
based on the dynamic parent target name,
<code>tar_option_get("seed")</code> (for <code>targets</code> version 0.13.5.9000 and above),
batch index, and rep-within-batch index.
The seed is set just before the replicate runs.
Replicate-specific seeds are invariant to batching structure.
In other words,
<code>tar_rep(name = x, command = rnorm(1), batches = 100, reps = 1, ...)</code>
produces the same numerical output as
<code>tar_rep(name = x, command = rnorm(1), batches = 10, reps = 10, ...)</code>
(but with different batch names).
Other target factories with this seed scheme are <code><a href="#topic+tar_rep2">tar_rep2()</a></code>,
<code><a href="#topic+tar_map_rep">tar_map_rep()</a></code>, <code><a href="#topic+tar_map2_count">tar_map2_count()</a></code>, <code><a href="#topic+tar_map2_size">tar_map2_size()</a></code>,
and <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>.
For the <code style="white-space: pre;">&#8288;tar_map2_*()&#8288;</code> functions,
it is possible to manually supply your own seeds
through the <code>command1</code> argument and then invoke them in your
custom code for <code>command2</code> (<code>set.seed()</code>, <code>withr::with_seed</code>,
or <code>withr::local_seed()</code>). For <code><a href="#topic+tar_render_rep">tar_render_rep()</a></code>,
custom seeds can be supplied to the <code>params</code> argument
and then invoked in the individual R Markdown reports.
Likewise with <code><a href="#topic+tar_quarto_rep">tar_quarto_rep()</a></code> and the <code>execute_params</code> argument.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_combine">tar_combine</a>()</code>,
<code><a href="#topic+tar_combine_raw">tar_combine_raw</a>()</code>,
<code><a href="#topic+tar_map">tar_map</a>()</code>,
<code><a href="#topic+tar_map2">tar_map2</a>()</code>,
<code><a href="#topic+tar_map2_count">tar_map2_count</a>()</code>,
<code><a href="#topic+tar_map2_count_raw">tar_map2_count_raw</a>()</code>,
<code><a href="#topic+tar_map2_raw">tar_map2_raw</a>()</code>,
<code><a href="#topic+tar_map2_size">tar_map2_size</a>()</code>,
<code><a href="#topic+tar_map2_size_raw">tar_map2_size_raw</a>()</code>,
<code><a href="#topic+tar_map_rep">tar_map_rep</a>()</code>,
<code><a href="#topic+tar_map_rep_raw">tar_map_rep_raw</a>()</code>,
<code><a href="#topic+tar_rep">tar_rep</a>()</code>,
<code><a href="#topic+tar_rep2">tar_rep2</a>()</code>,
<code><a href="#topic+tar_rep_map">tar_rep_map</a>()</code>,
<code><a href="#topic+tar_rep_map_raw">tar_rep_map_raw</a>()</code>,
<code><a href="#topic+tar_rep_raw">tar_rep_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_rep(
      data1,
      data.frame(value = rnorm(1)),
      batches = 2,
      reps = 3
    ),
    tarchetypes::tar_rep(
      data2,
      list(value = rnorm(1)),
      batches = 2, reps = 3,
      iteration = "list" # List iteration is important for batched lists.
    ),
    tarchetypes::tar_rep2_raw(
      "aggregate",
      quote(data.frame(value = data1$value + data2$value)),
      targets = c("data1", "data2")
    )
  )
})
targets::tar_make()
targets::tar_read(aggregate)
})
}
</code></pre>

<hr>
<h2 id='tar_rep2_run'>Run <code><a href="#topic+tar_rep2">tar_rep2()</a></code> batches.</h2><span id='topic+tar_rep2_run'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep2_run(command, batches, iteration, rep_workers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep2_run_+3A_command">command</code></td>
<td>
<p>R expression, the command to run on each rep.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_+3A_batches">batches</code></td>
<td>
<p>Named list of batch data to map over.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_+3A_iteration">iteration</code></td>
<td>
<p>Iteration method: <code>"list"</code>, <code>"vector"</code>, or <code>"group"</code>.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_+3A_rep_workers">rep_workers</code></td>
<td>
<p>Positive integer of length 1, number of local R
processes to use to run reps within batches in parallel. If 1,
then reps are run sequentially within each batch. If greater than 1,
then reps within batch are run in parallel using a PSOCK cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of batched replication.
</p>

<hr>
<h2 id='tar_rep2_run_rep'>Run a rep in a <code>tar_rep2()</code>-powered function.</h2><span id='topic+tar_rep2_run_rep'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_rep2_run_rep(rep, slice, command, batch, seeds, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_rep2_run_rep_+3A_rep">rep</code></td>
<td>
<p>Rep number.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_rep_+3A_slice">slice</code></td>
<td>
<p>Slice of the upstream batch data of the given rep.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_rep_+3A_command">command</code></td>
<td>
<p>R command to run.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_rep_+3A_batch">batch</code></td>
<td>
<p>Batch number.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_rep_+3A_seeds">seeds</code></td>
<td>
<p>Random number generator seeds of the batch.</p>
</td></tr>
<tr><td><code id="tar_rep2_run_rep_+3A_envir">envir</code></td>
<td>
<p>Environment of the target.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of running <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_rep2().
</code></pre>

<hr>
<h2 id='tar_select_names'>Select target names from a target list</h2><span id='topic+tar_select_names'></span>

<h3>Description</h3>

<p>Select the names of targets from a target list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_select_names(targets, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_select_names_+3A_targets">targets</code></td>
<td>
<p>A list of target objects as described in the
&quot;Target objects&quot; section. It does not matter how nested
the list is as long as the only leaf nodes are targets.</p>
</td></tr>
<tr><td><code id="tar_select_names_+3A_...">...</code></td>
<td>
<p>One or more comma-separated <code>tidyselect</code> expressions,
e.g. <code>starts_with("prefix")</code>. Just like <code>...</code> in <code>dplyr::select()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of target names.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other target selection: 
<code><a href="#topic+tar_select_targets">tar_select_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets &lt;- list(
  list(
    targets::tar_target(x, 1),
    targets::tar_target(y1, 2)
  ),
  targets::tar_target(y2, 3),
  targets::tar_target(z, 4)
)
tar_select_names(targets, starts_with("y"), contains("z"))
})
}
</code></pre>

<hr>
<h2 id='tar_select_targets'>Select target objects from a target list</h2><span id='topic+tar_select_targets'></span>

<h3>Description</h3>

<p>Select target objects from a target list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_select_targets(targets, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_select_targets_+3A_targets">targets</code></td>
<td>
<p>A list of target objects as described in the
&quot;Target objects&quot; section. It does not matter how nested
the list is as long as the only leaf nodes are targets.</p>
</td></tr>
<tr><td><code id="tar_select_targets_+3A_...">...</code></td>
<td>
<p>One or more comma-separated <code>tidyselect</code> expressions,
e.g. <code>starts_with("prefix")</code>. Just like <code>...</code> in <code>dplyr::select()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of target objects. See the &quot;Target objects&quot; section
of this help file.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other target selection: 
<code><a href="#topic+tar_select_names">tar_select_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets &lt;- list(
  list(
    targets::tar_target(x, 1),
    targets::tar_target(y1, 2)
  ),
  targets::tar_target(y2, 3),
  targets::tar_target(z, 4)
)
tar_select_targets(targets, starts_with("y"), contains("z"))
})
}
</code></pre>

<hr>
<h2 id='tar_skip'>Target with a custom cancellation condition.</h2><span id='topic+tar_skip'></span>

<h3>Description</h3>

<p>Create a target that cancels itself if a user-defined
decision rule is met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_skip(
  name,
  command,
  skip,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_skip_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="targets.html#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_skip">skip</code></td>
<td>
<p>R code for the skipping condition. If it evaluates to <code>TRUE</code>
during <code>tar_make()</code>, the target will cancel itself.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Whether to invoke tidy evaluation
(e.g. the <code style="white-space: pre;">&#8288;!!&#8288;</code> operator from <code>rlang</code>) as soon as the target is defined
(before <code>tar_make()</code>). Applies to arguments <code>command</code> and <code>skip</code>.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="targets.html#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="targets.html#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="targets.html#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_skip_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_skip_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_skip_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="targets.html#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="targets.html#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_skip_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_skip_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="targets.html#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="targets.html#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="targets.html#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_skip()</code> creates a target that cancels itself
whenever a custom condition is met. The mechanism of cancellation
is <code>targets::tar_cancel(your_condition)</code>, which allows skipping to happen
even if the target does not exist yet. This behavior differs from
<code>tar_cue(mode = "never")</code>, which still runs if the target does not exist.
</p>


<h3>Value</h3>

<p>A target object with <code>targets::tar_cancel(your_condition)</code> inserted
into the command.
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other targets with custom invalidation rules: 
<code><a href="#topic+tar_change">tar_change</a>()</code>,
<code><a href="#topic+tar_download">tar_download</a>()</code>,
<code><a href="#topic+tar_force">tar_force</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  list(
    tarchetypes::tar_skip(x, command = "value", skip = 1 &gt; 0)
  )
})
targets::tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_sub'>Create multiple expressions with symbol substitution.</h2><span id='topic+tar_sub'></span>

<h3>Description</h3>

<p>Loop over a grid of values and create an expression object
from each one. Helps with general metaprogramming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_sub(expr, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_sub_+3A_expr">expr</code></td>
<td>
<p>Starting expression. Values are iteratively substituted
in place of symbols in <code>expr</code> to create each new expression.</p>
</td></tr>
<tr><td><code id="tar_sub_+3A_values">values</code></td>
<td>
<p>List of values to substitute into <code>expr</code> to create
the expressions. All elements of <code>values</code> must have the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of expression objects. Often, these expression objects
evaluate to target objects (but not necessarily).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Metaprogramming utilities: 
<code><a href="#topic+tar_eval">tar_eval</a>()</code>,
<code><a href="#topic+tar_eval_raw">tar_eval_raw</a>()</code>,
<code><a href="#topic+tar_sub_raw">tar_sub_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tar_map() is incompatible with tar_render() because the latter
# operates on preexisting tar_target() objects. By contrast,
# tar_eval() and tar_sub() iterate over code farther upstream.
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = list("file1.Rmd", "file2.Rmd")
)
tar_sub(tar_render(name, file), values = values)
</code></pre>

<hr>
<h2 id='tar_sub_raw'>Create multiple expressions with symbol substitution (raw version).</h2><span id='topic+tar_sub_raw'></span>

<h3>Description</h3>

<p>Loop over a grid of values and create an expression object
from each one. Helps with general metaprogramming. Unlike <code><a href="#topic+tar_sub">tar_sub()</a></code>,
which quotes the <code>expr</code> argument, <code>tar_sub_raw()</code> assumes <code>expr</code>
is an expression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_sub_raw(expr, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_sub_raw_+3A_expr">expr</code></td>
<td>
<p>Expression object with the starting expression.
Values are iteratively substituted
in place of symbols in <code>expr</code> to create each new expression.</p>
</td></tr>
<tr><td><code id="tar_sub_raw_+3A_values">values</code></td>
<td>
<p>List of values to substitute into <code>expr</code> to create
the expressions. All elements of <code>values</code> must have the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of expression objects. Often, these expression objects
evaluate to target objects (but not necessarily).
See the &quot;Target objects&quot; section for background.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other Metaprogramming utilities: 
<code><a href="#topic+tar_eval">tar_eval</a>()</code>,
<code><a href="#topic+tar_eval_raw">tar_eval_raw</a>()</code>,
<code><a href="#topic+tar_sub">tar_sub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tar_map() is incompatible with tar_render() because the latter
# operates on preexisting tar_target() objects. By contrast,
# tar_eval_raw() and tar_sub_raw() iterate over code farther upstream.
values &lt;- list(
  name = lapply(c("name1", "name2"), as.symbol),
  file = c("file1.Rmd", "file2.Rmd")
)
tar_sub_raw(quote(tar_render(name, file)), values = values)
</code></pre>

<hr>
<h2 id='tarchetypes-package'>targets: Archetypes for Targets</h2><span id='topic+tarchetypes-package'></span>

<h3>Description</h3>

<p>A pipeline toolkit for R, the <code>targets</code> package brings together
function-oriented programming and Make-like declarative pipelines for
Statistics and data science. The <code>tarchetypes</code> package provides
convenient helper functions to create specialized targets, making
pipelines in targets easier and cleaner to write and understand.
</p>

<hr>
<h2 id='walk_ast'>Static code analysis for <code>tarchetypes</code>.</h2><span id='topic+walk_ast'></span>

<h3>Description</h3>

<p>Walk an abstract syntax tree and capture data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walk_ast(expr, walk_call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk_ast_+3A_expr">expr</code></td>
<td>
<p>A language object or function to scan.</p>
</td></tr>
<tr><td><code id="walk_ast_+3A_walk_call">walk_call</code></td>
<td>
<p>A function to handle a specific kind of function call
relevant to the code analysis at hand.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use only. Not a user-side function.
Powers functionality like automatic detection of <code>tar_load()</code>/<code>tar_read()</code>
dependencies in <code><a href="#topic+tar_render">tar_render()</a></code>.
Packages <code>codetools</code> and <code>CodeDepends</code> have different (more sophisticated
and elaborate) implementations of the concepts documented at
<a href="https://adv-r.hadley.nz/expressions.html#ast-funs">https://adv-r.hadley.nz/expressions.html#ast-funs</a>.
</p>


<h3>Value</h3>

<p>A character vector of data found during static code analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># How tar_render() really works:
expr &lt;- quote({
  if (a &gt; 1) {
    tar_load(target_name)
  }
  process_stuff(target_name)
})
walk_ast(expr, walk_call_knitr)
# Custom code analysis for developers of tarchetypes internals:
walk_custom &lt;- function(expr, counter) {
  # New internals should use targets::tar_deparse_safe(backtick = FALSE).
  name &lt;- deparse(expr[[1]])
  if (identical(name, "detect_this")) {
    counter_set_names(counter, as.character(expr[[2]]))
  }
}
expr &lt;- quote({
  for (i in seq_len(10)) {
    for (j in seq_len(20)) {
      if (i &gt; 1) {
        detect_this("prize")
      } else {
        ignore_this("penalty")
      }
    }
  }
})
walk_ast(expr, walk_custom)
</code></pre>

<hr>
<h2 id='walk_call_knitr'>Code analysis for knitr reports.</h2><span id='topic+walk_call_knitr'></span>

<h3>Description</h3>

<p>Walk an abstract syntax tree and capture knitr dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walk_call_knitr(expr, counter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk_call_knitr_+3A_expr">expr</code></td>
<td>
<p>A language object or function to scan.</p>
</td></tr>
<tr><td><code id="walk_call_knitr_+3A_counter">counter</code></td>
<td>
<p>An internal counter object that keeps track of detected
target names so far.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal use only. Not a user-side function.
Powers  automatic detection of <code>tar_load()</code>/<code>tar_read()</code>
dependencies in <code><a href="#topic+tar_render">tar_render()</a></code>.
Packages <code>codetools</code> and <code>CodeDepends</code> have different (more sophisticated
and elaborate) implementations of the concepts documented at
<a href="https://adv-r.hadley.nz/expressions.html#ast-funs">https://adv-r.hadley.nz/expressions.html#ast-funs</a>.
</p>


<h3>Value</h3>

<p>A character vector of target names found during static code analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># How tar_render() really works:
expr &lt;- quote({
  if (a &gt; 1) {
    tar_load(target_name)
  }
  process_stuff(target_name)
})
walk_ast(expr, walk_call_knitr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
