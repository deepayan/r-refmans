<!DOCTYPE html><html><head><title>Help for package DynTxRegime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DynTxRegime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.cycleList'><p>apply() for <code>List</code> objects</p></a></li>
<li><a href='#.newBOWL+2CNULL-method'><p>Create a BOWL Object for First Step of BOWL Algorithm</p></a></li>
<li><a href='#.newClassificationFit'><p>Complete a Classification Regression Step</p></a></li>
<li><a href='#.newClassificationObj'><p>Create an Object of Class <code>ClassificationFitObj</code></p></a></li>
<li><a href='#.newCVInfo'><p>Create a CVInfo Object</p></a></li>
<li><a href='#.newCVInfoObj'><p>Create a New CVInfoObj Object</p></a></li>
<li><a href='#.newEARL'><p>Complete an EARL Analysis</p></a></li>
<li><a href='#.newIQLearnFS_C'><p>Complete First Stage Analysis of Contrasts for Interactive Q-Learning Algorithm</p></a></li>
<li><a href='#.newIQLearnFS_ME'><p>Complete First Stage Analysis of Main Effects for Interactive Q-Learning Algorithm</p></a></li>
<li><a href='#.newIQLearnFS_VHet'><p>Complete First Stage Analysis of Residuals for Interactive Q-Learning Algorithm</p></a></li>
<li><a href='#.newIQLearnSS'><p>Complete Second Stage Analysis of Interactive Q-Learning Algorithm</p></a></li>
<li><a href='#.newKernelObj'><p>Create a KernelObj</p></a></li>
<li><a href='#.newLearning'><p>Complete a Learning Analysis</p></a></li>
<li><a href='#.newModel'><p>Combine model object models</p></a></li>
<li><a href='#.newOptim'><p>Complete an Optimization Step</p></a></li>
<li><a href='#.newOptimalClass'><p>Estimate the Optimal Treatment and Value Using Classification</p></a></li>
<li><a href='#.newOptimalSeq'><p>Complete a the Coarsened/Missing Data Analysis</p></a></li>
<li><a href='#.newOptimObj'><p>Create an OptimObj Object</p></a></li>
<li><a href='#.newOutcomeFit'><p>Perform an Outcome Regression Step</p></a></li>
<li><a href='#.newOutcomeObj'><p>Create a new <code>OutcomeObj</code> object</p></a></li>
<li><a href='#.newOWL'><p>Complete an OWL Analysis</p></a></li>
<li><a href='#.newPropensityFit'><p>Complete a Propensity Regression Step</p></a></li>
<li><a href='#.newPropensityObj'><p>Create a new <code>PropensityObj</code> object</p></a></li>
<li><a href='#.newQLearn'><p>Perform a Step of the Q-Learning Algorithm</p></a></li>
<li><a href='#.newRegime'><p>Create a new <code>Regime</code> object</p></a></li>
<li><a href='#.newRegimeObj'><p>Create a New <code>RegimeObj</code> Object</p></a></li>
<li><a href='#.newRWL'><p>Complete a Residual Weighted Learning Analysis</p></a></li>
<li><a href='#.newRWL+2CKernel-method'><p>Complete a Residual Weighted Learning Analysis</p></a></li>
<li><a href='#.newTxObj'><p>Create <code>TxObj</code> Object</p></a></li>
<li><a href='#.newTxSubset'><p>Create <code>TxSubset</code> Object</p></a></li>
<li><a href='#.newTypedFit'><p>Complete a Regression Step</p></a></li>
<li><a href='#.newTypedFitObj'><p>Create a new <code>TypedFitObj</code> object</p></a></li>
<li><a href='#.optimalClass'><p>Perform Classification Step</p></a></li>
<li><a href='#.seqFunc'><p>Define the Objective Function</p></a></li>
<li><a href='#bmiData'><p>Adolescent BMI dataset (generated toy example)</p></a></li>
<li><a href='#bowl'><p>Backwards Outcome Weighted Learning.</p></a></li>
<li><a href='#BOWL-class'><p>Class <code>BOWL</code></p></a></li>
<li><a href='#BOWL-methods'><p>Methods Available for Objects of Class <code>BOWL</code></p></a></li>
<li><a href='#BOWLBasic-class'><p>Class <code>BOWLBasic</code></p></a></li>
<li><a href='#BOWLBasic-methods'><p>Methods Available for Objects of Class <code>BOWLBasic</code></p></a></li>
<li><a href='#BOWLObj-class'><p>Class <code>BOWLObj</code></p></a></li>
<li><a href='#buildModelObjSubset'><p>Create Model Objects for Subsets of Data</p></a></li>
<li><a href='#Call'><p>Retrieve Unevaluated Original Call</p></a></li>
<li><a href='#classif'><p>Retrieve Classification Regression Analysis</p></a></li>
<li><a href='#ClassificationFit_fSet-class'><p>Class <code>ClassificationFit_fSet</code></p></a></li>
<li><a href='#ClassificationFit_fSet-methods'><p>Methods Available for Objects of Class <code>ClassificationFit_fSet</code></p></a></li>
<li><a href='#ClassificationFit_SubsetList-class'><p>Class <code>ClassificationFit_SubsetList</code></p></a></li>
<li><a href='#ClassificationFit_SubsetList-methods'><p>Methods Available for Objects of Class <code>ClassificationFit_SubsetList</code></p></a></li>
<li><a href='#ClassificationFit-class'><p>Class <code>ClassificationFit</code></p></a></li>
<li><a href='#ClassificationFit-methods'><p>Methods Available for Objects of Class <code>ClassificationFit</code></p></a></li>
<li><a href='#ClassificationObj-class'><p>Class <code>ClassificationObj</code></p></a></li>
<li><a href='#ClassificationObj-methods'><p>Methods Available for Objects of Class <code>ClassificationObj</code></p></a></li>
<li><a href='#coef'><p>Extract Model Coefficients From Objects Returned by Modeling Functions</p></a></li>
<li><a href='#createearl'><p>Create method object for EARL</p></a></li>
<li><a href='#createowl'><p>Create method object for Outcome Weighted Learning</p></a></li>
<li><a href='#createrwl'><p>Create method object for Residual Weighted Learning</p></a></li>
<li><a href='#CVBasic-class'><p>Class <code>CVBasic</code></p></a></li>
<li><a href='#cvInfo'><p>Extract Cross-Validation Results</p></a></li>
<li><a href='#CVInfo-class'><p>Class <code>CVInfo</code></p></a></li>
<li><a href='#CVInfo-methods'><p>Methods Available for Objects of Class <code>CVInfo</code></p></a></li>
<li><a href='#CVInfo2Par-class'><p>Class <code>CVInfo2Par</code></p></a></li>
<li><a href='#CVInfo2Par-methods'><p>Methods Available for Objects of Class <code>CVInfo2Par</code></p></a></li>
<li><a href='#CVInfokParam-class'><p>Class <code>CVInfokParam</code></p></a></li>
<li><a href='#CVInfokParam-methods'><p>Methods Available for Objects of Class <code>CVInfokParam</code></p></a></li>
<li><a href='#CVInfoLambda-class'><p>Class <code>CVInfoLambda</code></p></a></li>
<li><a href='#CVInfoLambda-methods'><p>Methods Available for Objects of Class <code>CVInfoLambda</code></p></a></li>
<li><a href='#CVInfoObj-class'><p>Class <code>CVInfoObj</code></p></a></li>
<li><a href='#CVInfoObj-methods'><p>Methods Available for Objects of Class <code>CVInfoObj</code></p></a></li>
<li><a href='#DecisionPointList-class'><p>Class <code>DecisionPointList</code></p></a></li>
<li><a href='#DecisionPointList-methods'><p>Methods Available for Objects of Class <code>DecisionPointList</code></p></a></li>
<li><a href='#DTRstep'><p>Identify Statistical Method Used to Obtain Result</p></a></li>
<li><a href='#DynTxRegime-class'><p>Class <code>DynTxRegime</code></p></a></li>
<li><a href='#DynTxRegime-internal-api'><p>Hidden methods</p></a></li>
<li><a href='#DynTxRegime-methods'><p>Methods Available for Objects of Class <code>DynTxRegime</code></p></a></li>
<li><a href='#earl'><p>Efficient Augmentation and Relaxation Learning</p></a></li>
<li><a href='#EARL-class'><p>Class <code>EARL</code></p></a></li>
<li><a href='#EARL-methods'><p>Methods Available for Objects of Class <code>EARL</code></p></a></li>
<li><a href='#estimator'><p>Retrieve the Estimated Value</p></a></li>
<li><a href='#ExpSurrogate-class'><p>Class <code>ExpSurrogate</code></p></a></li>
<li><a href='#ExpSurrogate-methods'><p>Methods Available for Objects of Class <code>ExpSurrogate</code></p></a></li>
<li><a href='#fitObject'><p>Objects Returned by Modeling Functions</p></a></li>
<li><a href='#fittedCont'><p>Retrieve the Fitted Contrast Component from Second Stage IQ-Learning</p></a></li>
<li><a href='#fittedMain'><p>Retrieve the Fitted Main Effects Component from Second Stage IQ-Learning</p></a></li>
<li><a href='#fSet'><p>Defining the fSet Input Variable</p></a></li>
<li><a href='#genetic'><p>Retrieve the Genetic Algorithm Results</p></a></li>
<li><a href='#getOutcome'><p>Retrieve Outcome for Both Tx Options When Tx is Binary</p></a></li>
<li><a href='#getPrWgt'><p>Retrieve Propensity for Tx Received</p></a></li>
<li><a href='#HingeSurrogate-class'><p>Class <code>HingeSurrogate</code></p></a></li>
<li><a href='#HingeSurrogate-methods'><p>Methods Available for Objects of Class <code>HingeSurrogate</code></p></a></li>
<li><a href='#HuberHingeSurrogate-class'><p>Class <code>HuberHingeSurrogate</code></p></a></li>
<li><a href='#HuberHingeSurrogate-methods'><p>Methods Available for Objects of Class <code>HuberHingeSurrogate</code></p></a></li>
<li><a href='#internal-earl-class'><p>Class <code>.earl</code></p></a></li>
<li><a href='#internal-earl-methods'><p>Methods Available for Objects of Class <code>.earl</code></p></a></li>
<li><a href='#internal-owl-class'><p>Class <code>.owl</code></p></a></li>
<li><a href='#internal-owl-methods'><p>Methods Available for Objects of Class <code>.owl</code></p></a></li>
<li><a href='#internal-rwl-class'><p>Class <code>.rwl</code></p></a></li>
<li><a href='#internal-rwl-methods'><p>Methods Available for Objects of Class <code>.rwl</code></p></a></li>
<li><a href='#iqLearn'><p>Interactive Q-Learning</p></a></li>
<li><a href='#IQLearnFS_C-class'><p>Class <code>IQLearnFS_C</code></p></a></li>
<li><a href='#IQLearnFS_C-methods'><p>Methods Available for Objects of Class <code>IQLearnFS_C</code></p></a></li>
<li><a href='#IQLearnFS_ME-class'><p>Class <code>IQLearnFS_ME</code></p></a></li>
<li><a href='#IQLearnFS_ME-methods'><p>Methods Available for Objects of Class <code>IQLearnFS_ME</code></p></a></li>
<li><a href='#IQLearnFS_VHet-class'><p>Class <code>IQLearnFS_VHet</code></p></a></li>
<li><a href='#IQLearnFS_VHet-methods'><p>Methods Available for Objects of Class <code>IQLearnFS_VHet</code></p></a></li>
<li><a href='#IQLearnFS-class'><p>Class <code>IQLearnFS</code></p></a></li>
<li><a href='#IQLearnFS-methods'><p>Methods Available for Objects of Class <code>IQLearnFS</code></p></a></li>
<li><a href='#IQLearnSS-class'><p>Class <code>IQLearnSS</code></p></a></li>
<li><a href='#IQLearnSS-methods'><p>Methods Available for Objects of Class <code>IQLearnSS</code></p></a></li>
<li><a href='#iter'><p>Defining the iter Input Variable</p></a></li>
<li><a href='#Kernel-class'><p>Class <code>Kernel</code></p></a></li>
<li><a href='#Kernel-methods'><p>Methods Available for Objects of Class <code>Kernel</code></p></a></li>
<li><a href='#KernelObj-class'><p>Class <code>KernelObj</code></p></a></li>
<li><a href='#KernelObj-methods'><p>Methods Available for Objects of Class <code>KernelObj</code></p></a></li>
<li><a href='#Learning-class'><p>Class <code>Learning</code></p></a></li>
<li><a href='#Learning-methods'><p>Methods Available for Objects of Class <code>Learning</code></p></a></li>
<li><a href='#LearningMulti-class'><p>Class <code>LearningMulti</code></p></a></li>
<li><a href='#LearningMulti-methods'><p>Methods Available for Objects of Class <code>LearningMulti</code></p></a></li>
<li><a href='#LearningObject-class'><p>Class <code>LearningObject</code></p></a></li>
<li><a href='#LearningObject-methods'><p>Methods Available for Objects of Class <code>LearningObject</code></p></a></li>
<li><a href='#LinearKernel-class'><p>Class <code>LinearKernel</code></p></a></li>
<li><a href='#LinearKernel-methods'><p>Methods Available for Objects of Class <code>LinearKernel</code></p></a></li>
<li><a href='#List-class'><p>Class <code>List</code></p></a></li>
<li><a href='#LogitSurrogate-class'><p>Class <code>LogitSurrogate</code></p></a></li>
<li><a href='#LogitSurrogate-methods'><p>Methods Available for Objects of Class <code>LogitSurrogate</code></p></a></li>
<li><a href='#MethodObject-class'><p>Class <code>MethodObject</code></p></a></li>
<li><a href='#MethodObject-methods'><p>Methods Available for Objects of Class <code>MethodObject</code></p></a></li>
<li><a href='#ModelObj_DecisionPointList-class'><p>Class ModelObj_DecisionPointList</p></a></li>
<li><a href='#ModelObj_SubsetList-class'><p>Class ModelObj_SubsetList</p></a></li>
<li><a href='#ModelObjSubset-class'><p>Class <code>ModelObjSubset</code></p></a></li>
<li><a href='#ModelObjSubset-methods'><p>Methods Available for Objects of Class <code>ModelObjSubset</code></p></a></li>
<li><a href='#moPropen'><p>Defining the moPropen Input Variable</p></a></li>
<li><a href='#MultiRadialKernel-class'><p>Class <code>MultiRadialKernel</code></p></a></li>
<li><a href='#MultiRadialKernel-methods'><p>Methods Available for Objects of Class <code>MultiRadialKernel</code></p></a></li>
<li><a href='#newBOWLStep'><p>Create a BOWL Object</p></a></li>
<li><a href='#newCVStep'><p>An n-Fold Cross Validation Step</p></a></li>
<li><a href='#newModelObjSubset'><p>Create Internal Model Objects for Subsets of Data</p></a></li>
<li><a href='#optimalClass'><p>Classification Perspective</p></a></li>
<li><a href='#OptimalClass-class'><p>Class <code>OptimalClass</code></p></a></li>
<li><a href='#OptimalClass-methods'><p>Methods Available for Objects of Class <code>OptimalClass</code></p></a></li>
<li><a href='#OptimalClassObj-class'><p>Class <code>OptimalClassObj</code></p></a></li>
<li><a href='#OptimalInfo-class'><p>Class <code>OptimalInfo</code></p></a></li>
<li><a href='#OptimalInfo-methods'><p>Methods Available for Objects of Class <code>OptimalInfo</code></p></a></li>
<li><a href='#OptimalObj-class'><p>Class <code>OptimalObj</code></p></a></li>
<li><a href='#OptimalObj-methods'><p>Methods Available for Objects of Class <code>OptimalObj</code></p></a></li>
<li><a href='#optimalSeq'><p>Missing or Coarsened Data Perspective - Genetic Algorithm</p></a></li>
<li><a href='#OptimalSeq-class'><p>Class <code>OptimalSeq</code></p></a></li>
<li><a href='#OptimalSeq-methods'><p>Methods Available for Objects of Class <code>OptimalSeq</code></p></a></li>
<li><a href='#OptimalSeqCoarsened-class'><p>Class Contains Results for the Coarsened Data IPW/AIPW Method</p></a></li>
<li><a href='#OptimalSeqCoarsened-methods'><p>Methods Available for Objects of Class <code>OptimalSeqCoarsened</code></p></a></li>
<li><a href='#OptimalSeqMissing-class'><p>Class Contains Results for the Missing Data IPW/AIPW Method</p></a></li>
<li><a href='#OptimalSeqMissing-methods'><p>Methods Available for Objects of Class <code>OptimalSeqMissing</code></p></a></li>
<li><a href='#OptimBasic-class'><p>Class <code>OptimBasic</code></p></a></li>
<li><a href='#OptimBasic-methods'><p>Methods Available for Objects of Class <code>OptimBasic</code></p></a></li>
<li><a href='#OptimKernel-class'><p>Class <code>OptimKernel</code></p></a></li>
<li><a href='#OptimKernel-methods'><p>Methods Available for Objects of Class <code>OptimKernel</code></p></a></li>
<li><a href='#optimObj'><p>Extract Optimization Results</p></a></li>
<li><a href='#OptimObj-class'><p>Class <code>OptimObj</code></p></a></li>
<li><a href='#OptimObj-methods'><p>Methods Available for Objects of Class <code>OptimObj</code></p></a></li>
<li><a href='#OptimStep'><p>Complete Cross-Validation Step and Final Optimization</p></a></li>
<li><a href='#OptimStep-class'><p>Class <code>OptimStep</code></p>
Class <code>OptimStep</code> holds results of a combined cross-validation and final
optimization step for weighted learning methods.</a></li>
<li><a href='#OptimStep-methods'><p>Methods Available for Objects of Class <code>OptimStep</code></p></a></li>
<li><a href='#optTx'><p>Extract or Estimate the Optimal Tx and Decision Functions</p></a></li>
<li><a href='#outcome'><p>Retrieve Outcome Regression Analysis</p></a></li>
<li><a href='#OutcomeIterateFit-class'><p>Class <code>OutcomeIterateFit</code></p></a></li>
<li><a href='#OutcomeIterateFit-methods'><p>Methods Available for Objects of Class <code>OutcomeIterateFit</code></p></a></li>
<li><a href='#OutcomeNoFit-class'><p>Class <code>OutcomeNoFit</code></p></a></li>
<li><a href='#OutcomeNoFit-methods'><p>Methods Available for Objects of Class <code>OutcomeNoFit</code></p></a></li>
<li><a href='#OutcomeObj-class'><p>Class <code>OutcomeObj</code></p></a></li>
<li><a href='#OutcomeObj-methods'><p>Methods Available for Objects of Class <code>OutcomeObj</code></p></a></li>
<li><a href='#OutcomeSimpleFit_fSet-class'><p>Class <code>OutcomeSimpleFit_fSet</code></p></a></li>
<li><a href='#OutcomeSimpleFit_fSet-methods'><p>Methods Available for Objects of Class <code>OutcomeSimpleFit_fSet</code></p></a></li>
<li><a href='#OutcomeSimpleFit_SubsetList-class'><p>Class <code>OutcomeSimpleFit_SubsetList</code></p></a></li>
<li><a href='#OutcomeSimpleFit_SubsetList-methods'><p>Methods Available for Objects of Class <code>OutcomeSimpleFit_SubsetList</code></p></a></li>
<li><a href='#OutcomeSimpleFit-class'><p>Class <code>OutcomeSimpleFit</code></p></a></li>
<li><a href='#OutcomeSimpleFit-methods'><p>Methods Available for Objects of Class <code>OutcomeSimpleFit</code></p></a></li>
<li><a href='#owl'><p>Outcome Weighted Learning</p></a></li>
<li><a href='#OWL-class'><p>Class <code>OWL</code></p></a></li>
<li><a href='#OWL-methods'><p>Methods Available for Objects of Class <code>OWL</code></p></a></li>
<li><a href='#plot'><p>Generates Plots as Defined by Modeling Functions</p></a></li>
<li><a href='#PolyKernel-class'><p>Class <code>PolyKernel</code></p></a></li>
<li><a href='#PolyKernel-methods'><p>Methods Available for Objects of Class <code>PolyKernel</code></p></a></li>
<li><a href='#propen'><p>Retrieve Propensity Regression Analysis</p></a></li>
<li><a href='#PropensityFit_fSet-class'><p>Class <code>PropensityFit_fSet</code></p></a></li>
<li><a href='#PropensityFit_fSet-methods'><p>Methods Available for Objects of Class <code>PropensityFit_fSet</code></p></a></li>
<li><a href='#PropensityFit_SubsetList-class'><p>Class <code>PropensityFit_SubsetList</code></p></a></li>
<li><a href='#PropensityFit_SubsetList-methods'><p>Methods Available for Objects of Class <code>PropensityFit_SubsetList</code></p></a></li>
<li><a href='#PropensityFit-class'><p>Class <code>PropensityFit</code></p></a></li>
<li><a href='#PropensityFit-methods'><p>Methods Available for Objects of Class <code>PropensityFit</code></p></a></li>
<li><a href='#PropensityObj-class'><p>Class <code>PropensityObj</code></p></a></li>
<li><a href='#PropensityObj-methods'><p>Methods Available for Objects of Class <code>PropensityObj</code></p></a></li>
<li><a href='#qLearn'><p>A Step of the Q-Learning Algorithm</p></a></li>
<li><a href='#QLearn-class'><p>Class <code>QLearn</code></p></a></li>
<li><a href='#QLearnObj-class'><p>Class <code>QLearnObj</code></p></a></li>
<li><a href='#RadialKernel-class'><p>Class <code>RadialKernel</code></p></a></li>
<li><a href='#RadialKernel-methods'><p>Methods Available for Objects of Class <code>RadialKernel</code></p></a></li>
<li><a href='#Regime-class'><p>Class <code>Regime</code></p></a></li>
<li><a href='#Regime-methods'><p>Methods Available for Objects of Class <code>Regime</code></p></a></li>
<li><a href='#regimeCoef'><p>Extract Regime Parameters</p></a></li>
<li><a href='#RegimeObj-class'><p>Class <code>RegimeObj</code></p></a></li>
<li><a href='#RegimeObj-methods'><p>Methods Available for Objects of Class <code>RegimeObj</code></p></a></li>
<li><a href='#residuals'><p>Extract Model Residuals</p></a></li>
<li><a href='#rwl'><p>Residual Weighted Learning</p></a></li>
<li><a href='#RWL-class'><p>Class <code>RWL</code></p></a></li>
<li><a href='#RWL-methods'><p>Methods Available for Objects of Class <code>RWL</code></p></a></li>
<li><a href='#sd'><p>Standard Deviation</p></a></li>
<li><a href='#SmoothRampSurrogate-class'><p>Class <code>SmoothRampSurrogate</code></p></a></li>
<li><a href='#SmoothRampSurrogate-methods'><p>Methods Available for Objects of Class <code>SmoothRampSurrogate</code></p></a></li>
<li><a href='#SqHingeSurrogate-class'><p>Class <code>SqHingeSurrogate</code></p></a></li>
<li><a href='#SqHingeSurrogate-methods'><p>Methods Available for Objects of Class <code>SqHingeSurrogate</code></p></a></li>
<li><a href='#SubsetList-class'><p>Class <code>SubsetList</code></p></a></li>
<li><a href='#SubsetList-methods'><p>Methods Available for Objects of Class <code>SubsetList</code></p></a></li>
<li><a href='#summary'><p>Result Summaries</p></a></li>
<li><a href='#Surrogate-class'><p>Class <code>Surrogate</code></p></a></li>
<li><a href='#Surrogate-methods'><p>Methods Available for Objects of Class <code>Surrogate</code></p></a></li>
<li><a href='#TxInfoBasic-class'><p>Class <code>TxInfoBasic</code></p></a></li>
<li><a href='#TxInfoBasic-methods'><p>Methods Available for Objects of Class <code>TxInfoBasic</code></p></a></li>
<li><a href='#TxInfoFactor-class'><p>Class TxInfoFactor</p></a></li>
<li><a href='#TxInfoFactor-methods'><p>Methods Available for Objects of Class <code>TxInfoFactor</code></p></a></li>
<li><a href='#TxInfoInteger-class'><p>Class TxInfoInteger</p></a></li>
<li><a href='#TxInfoInteger-methods'><p>Methods Available for Objects of Class <code>TxInfoInteger</code></p></a></li>
<li><a href='#TxInfoList'><p>Class <code>TxInfoList</code></p></a></li>
<li><a href='#TxInfoList-methods'><p>Methods Available for Objects of Class <code>TxInfoList</code></p></a></li>
<li><a href='#TxInfoNoSubsets-class'><p>Class <code>TxInfoNoSubsets</code></p></a></li>
<li><a href='#TxInfoNoSubsets-methods'><p>Methods Available for Objects of Class <code>TxInfoNoSubsets</code></p></a></li>
<li><a href='#TxInfoWithSubsets-class'><p>Class <code>TxInfoWithSubsets</code></p></a></li>
<li><a href='#TxInfoWithSubsets-methods'><p>Methods Available for Objects of Class <code>TxInfoWithSubsets</code></p></a></li>
<li><a href='#TxObj-class'><p>Class <code>TxObj</code></p></a></li>
<li><a href='#TxObj-methods'><p>Methods Available for Objects of Class <code>TxObj</code></p></a></li>
<li><a href='#TxSubset-class'><p>Class <code>TxSubset</code></p></a></li>
<li><a href='#TxSubset-methods'><p>Methods Available for Objects of Class <code>TxSubset</code></p></a></li>
<li><a href='#TxSubsetFactor-class'><p>Class <code>TxSubsetFactor</code></p></a></li>
<li><a href='#TxSubsetFactor-methods'><p>Methods Available for Objects of Class <code>TxSubsetFactor</code></p></a></li>
<li><a href='#TxSubsetInteger-class'><p>Class TxSubsetInteger</p></a></li>
<li><a href='#TxSubsetInteger-methods'><p>Methods Available for Objects of Class <code>TxSubsetInteger</code></p></a></li>
<li><a href='#TypedFit_fSet-class'><p>Class <code>TypedFit_fSet</code></p></a></li>
<li><a href='#TypedFit_fSet-methods'><p>Methods Available for Objects of Class <code>TypedFit_fSet</code></p></a></li>
<li><a href='#TypedFit_SubsetList-class'><p>Class <code>TypedFit_SubsetList</code></p></a></li>
<li><a href='#TypedFit_SubsetList-methods'><p>Methods Available for Objects of Class <code>TypedFit_SubsetList</code></p></a></li>
<li><a href='#TypedFit-class'><p>Class <code>TypedFit</code></p></a></li>
<li><a href='#TypedFit-methods'><p>Methods Available for Objects of Class <code>TypedFit</code></p></a></li>
<li><a href='#TypedFitObj-class'><p>Class <code>TypedFitObj</code></p></a></li>
<li><a href='#TypedFitObj-methods'><p>Methods Available for Objects of Class <code>TypedFitObj</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Estimating Optimal Dynamic Treatment Regimes</td>
</tr>
<tr>
<td>Version:</td>
<td>4.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-24</td>
</tr>
<tr>
<td>Author:</td>
<td>S. T. Holloway, E. B. Laber, K. A. Linn, B. Zhang, M. Davidian, and A. A. Tsiatis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shannon T. Holloway &lt;shannon.t.holloway@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to estimate dynamic treatment regimes using Interactive
  Q-Learning, Q-Learning, weighted learning, and value-search methods based on 
  Augmented Inverse Probability Weighted Estimators and Inverse Probability
  Weighted Estimators. Dynamic Treatment Regimes: Statistical Methods for 
  Precision Medicine, Tsiatis, A. A., Davidian, M. D., Holloway, S. T., and Laber, E. B., 
  Chapman &amp; Hall/CRC Press, 2020, ISBN:978-1-4987-6977-8.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, modelObj, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, rpart, nnet</td>
</tr>
<tr>
<td>Imports:</td>
<td>kernlab, rgenoud, dfoptim</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'A_generics.R' 'A_List.R' 'A_DecisionPointList.R'
'A_OptimalInfo.R' 'A_OptimalObj.R' 'A_DynTxRegime.R'
'A_ModelObjSubset.R' 'A_SubsetList.R' 'A_ModelObj_SubsetList.R'
'A_ModelObj_DecisionPointList.R' 'A_newModelObjSubset.R'
'B_TxInfoBasic.R' 'B_TxInfoFactor.R' 'B_TxInfoInteger.R'
'B_TxObj.R' 'B_TxInfoNoSubsets.R' 'B_TxSubset.R'
'B_TxSubsetInteger.R' 'B_TxSubsetFactor.R'
'B_TxInfoWithSubsets.R' 'B_TxInfoList.R' 'C_TypedFit.R'
'C_TypedFit_SubsetList.R' 'C_TypedFit_fSet.R' 'C_TypedFitObj.R'
'D_OutcomeNoFit.R' 'D_newModel.R' 'D_OutcomeSimpleFit.R'
'D_OutcomeSimpleFit_fSet.R' 'D_OutcomeIterateFit.R'
'D_OutcomeSimpleFit_SubsetList.R' 'D_OutcomeObj.R'
'E_class_QLearn.R' 'E_class_IQLearnSS.R' 'E_class_IQLearnFS.R'
'E_class_IQLearnFS_C.R' 'E_class_IQLearnFS_ME.R'
'E_class_IQLearnFS_VHet.R' 'E_iqLearnFSC.R' 'E_iqLearnFSM.R'
'E_iqLearnFSV.R' 'E_iqLearnSS.R' 'E_qLearn.R'
'F_PropensityFit.R' 'F_PropensityFit_fSet.R'
'F_PropensityFit_SubsetList.R' 'F_PropensityObj.R' 'G_Regime.R'
'G_RegimeObj.R' 'H_class_OptimalSeq.R'
'H_class_OptimalSeqCoarsened.R' 'H_class_OptimalSeqMissing.R'
'H_optimalSeq.R' 'I_ClassificationFit.R'
'I_ClassificationFit_SubsetList.R' 'I_ClassificationFit_fSet.R'
'I_ClassificationObj.R' 'J_class_OptimalClass.R'
'J_optimalClass.R' 'K_Kernel.R' 'K_MultiRadialKernel.R'
'K_RadialKernel.R' 'K_PolyKernel.R' 'K_LinearKernel.R'
'K_KernelObj.R' 'L_Surrogate.R' 'L_ExpSurrogate.R'
'L_HingeSurrogate.R' 'L_HuberHingeSurrogate.R'
'L_LogitSurrogate.R' 'L_SmoothRampSurrogate.R'
'L_SqHingeSurrogate.R' 'M_MethodObject.R' 'M_OptimBasic.R'
'M_OptimKernel.R' 'M_OptimObj.R' 'N_CVBasic.R' 'N_CVInfo.R'
'N_CVInfoLambda.R' 'N_CVInfokParam.R' 'N_CVInfo2Par.R'
'N_CVInfoObj.R' 'N_OptimStep.R' 'O_LearningObject.R'
'O_Learning.R' 'O_LearningMulti.R' 'P_class_.owl.R'
'P_class_OWL.R' 'P_owl.R' 'Q_class_.rwl.R' 'Q_class_RWL.R'
'Q_rwl.R' 'R_class_BOWLBasic.R' 'R_class_BOWL.R' 'R_bowl.R'
'S_class_.earl.R' 'S_class_EARL.R' 'S_earl.R'
'checkFSetAndOutcomeModels.R' 'checkFSetAndPropensityModels.R'
'checkInputs.R' 'internalTest.R' 'titleIt.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 16:38:56 UTC; 19194</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 17:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.cycleList'>apply() for <code>List</code> objects</h2><span id='topic+.cycleList'></span><span id='topic+.cycleList+2CList-method'></span><span id='topic+.cycleList+2CDecisionPointList-method'></span><span id='topic+.cycleList+2CSubsetList-method'></span>

<h3>Description</h3>

<p>Applies the specified function to each element of the <code>List</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cycleList(object, ...)

## S4 method for signature 'List'
.cycleList(object, func, trm = "object", nm = NULL, ...)

## S4 method for signature 'DecisionPointList'
.cycleList(object, func, trm = "object", nm = "dp=", ...)

## S4 method for signature 'SubsetList'
.cycleList(object, func, trm = "object", nm = "Subset=", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".cycleList_+3A_object">object</code></td>
<td>
<p>The object inheriting from list to which func is applied.</p>
</td></tr>
<tr><td><code id=".cycleList_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to func.</p>
</td></tr>
<tr><td><code id=".cycleList_+3A_func">func</code></td>
<td>
<p>A character. The name of the function to be called for
each element of object.</p>
</td></tr>
<tr><td><code id=".cycleList_+3A_trm">trm</code></td>
<td>
<p>A character. The formal input argument name through
which each element of object is passed to func.</p>
</td></tr>
<tr><td><code id=".cycleList_+3A_nm">nm</code></td>
<td>
<p>A character. The naming convention for element of the
returned list or displayed in print/show calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If func returns a value object, a list containing the
value objects returned by func.
</p>

<hr>
<h2 id='.newBOWL+2CNULL-method'>Create a BOWL Object for First Step of BOWL Algorithm</h2><span id='topic+.newBOWL+2CNULL-method'></span><span id='topic+.newBOWL+2CBOWL-method'></span>

<h3>Description</h3>

<p>Create a BOWL Object for First Step of BOWL Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''NULL''
.newBOWL(
  BOWLObj,
  moPropen,
  fSet,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  kernel,
  surrogate,
  suppress,
  guess,
  ...
)

## S4 method for signature 'BOWL'
.newBOWL(
  BOWLObj,
  moPropen,
  fSet,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  kernel,
  surrogate,
  suppress,
  guess,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_bowlobj">BOWLObj</code></td>
<td>
<p>NULL or an object returned from a previous step</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_mopropen">moPropen</code></td>
<td>
<p>modelObj or modelObjSubset for propensity modeling</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_fset">fSet</code></td>
<td>
<p>optional function defining subsets for modeling</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_data">data</code></td>
<td>
<p>data.frame of covariates</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_response">response</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_txname">txName</code></td>
<td>
<p>treatment variable column header in data</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_lambdas">lambdas</code></td>
<td>
<p>tuning parameter(s)</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_cvfolds">cvFolds</code></td>
<td>
<p>number of cross-validation folds</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if prints to screen are to be executed</p>
</td></tr>
<tr><td><code id=".newBOWL+2B2CNULL-method_+3A_guess">guess</code></td>
<td>
<p>Starting values for optimization</p>
</td></tr>
</table>

<hr>
<h2 id='.newClassificationFit'>Complete a Classification Regression Step</h2><span id='topic+.newClassificationFit'></span><span id='topic+.newClassificationFit+2CmodelObj+2CTxInfoNoSubsets-method'></span><span id='topic+.newClassificationFit+2CModelObj_SubsetList+2CTxInfoWithSubsets-method'></span><span id='topic+.newClassificationFit+2CmodelObj+2CTxInfoWithSubsets-method'></span>

<h3>Description</h3>

<p>Methods dispatch appropriate typed fit methods based on the modeling
object specified by the user and the feasible tx definitions.
The value object returned depends on the underlying typed fit method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newClassificationFit(moClass, txObj, ...)

## S4 method for signature 'modelObj,TxInfoNoSubsets'
.newClassificationFit(moClass, txObj, response, data, suppress, ...)

## S4 method for signature 'ModelObj_SubsetList,TxInfoWithSubsets'
.newClassificationFit(moClass, data, response, txObj, suppress, ...)

## S4 method for signature 'modelObj,TxInfoWithSubsets'
.newClassificationFit(moClass, txObj, response, data, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newClassificationFit_+3A_moclass">moClass</code></td>
<td>
<p>modeling object(s) defining the classification regression</p>
</td></tr>
<tr><td><code id=".newClassificationFit_+3A_txobj">txObj</code></td>
<td>
<p>TxObj defining the tx feasible sets</p>
</td></tr>
<tr><td><code id=".newClassificationFit_+3A_...">...</code></td>
<td>
<p>additional arguments. Ignored.</p>
</td></tr>
<tr><td><code id=".newClassificationFit_+3A_data">data</code></td>
<td>
<p>data.frame of covariates and tx received</p>
</td></tr>
<tr><td><code id=".newClassificationFit_+3A_suppress">suppress</code></td>
<td>
<p>logical indicating user's screen printing preference</p>
</td></tr>
</table>

<hr>
<h2 id='.newClassificationObj'>Create an Object of Class <code>ClassificationFitObj</code></h2><span id='topic+.newClassificationObj'></span><span id='topic+.newClassificationObj+2CANY-method'></span>

<h3>Description</h3>

<p>Method calls .newClassificationFit() and stores the result in @classif.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newClassificationObj(moClass, txObj, ...)

## S4 method for signature 'ANY'
.newClassificationObj(moClass, txObj, data, response, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newClassificationObj_+3A_moclass">moClass</code></td>
<td>
<p>modeling object(s) defining the classification regression</p>
</td></tr>
<tr><td><code id=".newClassificationObj_+3A_txobj">txObj</code></td>
<td>
<p>TxObj defining the tx feasible sets</p>
</td></tr>
<tr><td><code id=".newClassificationObj_+3A_...">...</code></td>
<td>
<p>additional arguments. Ignored.</p>
</td></tr>
<tr><td><code id=".newClassificationObj_+3A_data">data</code></td>
<td>
<p>data.frame of covariates and tx received</p>
</td></tr>
<tr><td><code id=".newClassificationObj_+3A_suppress">suppress</code></td>
<td>
<p>logical indicating user's screen printing preference</p>
</td></tr>
</table>

<hr>
<h2 id='.newCVInfo'>Create a CVInfo Object</h2><span id='topic+.newCVInfo'></span><span id='topic+.newCVInfo+2CANY+2CANY-method'></span><span id='topic+.newCVInfo+2Cnumeric+2CKernel-method'></span><span id='topic+.newCVInfo+2Cnumeric+2CMultiRadialKernel-method'></span><span id='topic+.newCVInfo+2Carray+2CKernel-method'></span><span id='topic+.newCVInfo+2Carray+2CMultiRadialKernel-method'></span>

<h3>Description</h3>

<p>Dispatch appropriate cross-validation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newCVInfo(lambdas, kernel, ...)

## S4 method for signature 'ANY,ANY'
.newCVInfo(lambdas, kernel, ...)

## S4 method for signature 'numeric,Kernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)

## S4 method for signature 'numeric,MultiRadialKernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)

## S4 method for signature 'array,Kernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)

## S4 method for signature 'array,MultiRadialKernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)

## S4 method for signature 'numeric,MultiRadialKernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)

## S4 method for signature 'array,MultiRadialKernel'
.newCVInfo(lambdas, kernel, methodObject, cvObject, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newCVInfo_+3A_lambdas">lambdas</code></td>
<td>
<p>tuning parameters</p>
</td></tr>
<tr><td><code id=".newCVInfo_+3A_kernel">kernel</code></td>
<td>
<p>kernel object</p>
</td></tr>
</table>

<hr>
<h2 id='.newCVInfoObj'>Create a New CVInfoObj Object</h2><span id='topic+.newCVInfoObj'></span><span id='topic+.newCVInfoObj+2CANY+2CKernel-method'></span>

<h3>Description</h3>

<p>Call newCVInfo and stores result in @cvInfo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newCVInfoObj(lambdas, kernel, ...)

## S4 method for signature 'ANY,Kernel'
.newCVInfoObj(lambdas, kernel, methodObject, cvObject, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newCVInfoObj_+3A_lambdas">lambdas</code></td>
<td>
<p>Tuning parameters to be considered</p>
</td></tr>
<tr><td><code id=".newCVInfoObj_+3A_kernel">kernel</code></td>
<td>
<p>Kernel (w/kernel parameters) to be considered</p>
</td></tr>
<tr><td><code id=".newCVInfoObj_+3A_...">...</code></td>
<td>
<p>Additional arguments as needed</p>
</td></tr>
<tr><td><code id=".newCVInfoObj_+3A_methodobject">methodObject</code></td>
<td>
<p>Object parameters for weighted learning method</p>
</td></tr>
<tr><td><code id=".newCVInfoObj_+3A_cvobject">cvObject</code></td>
<td>
<p>Cross-Validation object</p>
</td></tr>
<tr><td><code id=".newCVInfoObj_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if screen prints are generated</p>
</td></tr>
</table>

<hr>
<h2 id='.newEARL'>Complete an EARL Analysis</h2><span id='topic+.newEARL'></span>

<h3>Description</h3>

<p>Complete an EARL Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newEARL(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  surrogate,
  iter,
  guess,
  kernel,
  fSet,
  suppress,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newEARL_+3A_mopropen">moPropen</code></td>
<td>
<p>modelObj for propensity modeling</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_momain">moMain</code></td>
<td>
<p>modelObj for main effects of outcome model</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_mocont">moCont</code></td>
<td>
<p>modelObj for contrasts of outcome model</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_data">data</code></td>
<td>
<p>data.frame of covariates</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_txname">txName</code></td>
<td>
<p>Tx variable column header in data</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_lambdas">lambdas</code></td>
<td>
<p>Tuning parameter(s)</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_cvfolds">cvFolds</code></td>
<td>
<p>Number of cross-validation folds</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_iter">iter</code></td>
<td>
<p>Maximum iterations for outcome regression</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_guess">guess</code></td>
<td>
<p>optional numeric vector providing starting values for
optimization methods</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object or SubsetList</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_fset">fSet</code></td>
<td>
<p>NULL or function defining subset rules</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if prints to screen are executed</p>
</td></tr>
<tr><td><code id=".newEARL_+3A_...">...</code></td>
<td>
<p>Additional inputs for optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An EARL object
</p>

<hr>
<h2 id='.newIQLearnFS_C'>Complete First Stage Analysis of Contrasts for Interactive Q-Learning Algorithm</h2><span id='topic+.newIQLearnFS_C'></span><span id='topic+.newIQLearnFS_C+2CmodelObj+2CmodelObj+2CIQLearnSS-method'></span><span id='topic+.newIQLearnFS_C+2CmodelObj+2CNULL+2CIQLearnSS-method'></span><span id='topic+.newIQLearnFS_C+2CNULL+2CmodelObj+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Performs regression on the fitted contrasts of the second stage regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newIQLearnFS_C(moMain, moCont, response, ...)

## S4 method for signature 'modelObj,modelObj,IQLearnSS'
.newIQLearnFS_C(moMain, moCont, response, data, txName, iter, suppress)

## S4 method for signature 'modelObj,'NULL',IQLearnSS'
.newIQLearnFS_C(moMain, moCont, response, data, txName, iter, suppress)

## S4 method for signature ''NULL',modelObj,IQLearnSS'
.newIQLearnFS_C(moMain, moCont, response, data, txName, iter, suppress)
</code></pre>

<hr>
<h2 id='.newIQLearnFS_ME'>Complete First Stage Analysis of Main Effects for Interactive Q-Learning Algorithm</h2><span id='topic+.newIQLearnFS_ME'></span><span id='topic+.newIQLearnFS_ME+2CmodelObj+2CmodelObj+2CIQLearnSS-method'></span><span id='topic+.newIQLearnFS_ME+2CmodelObj+2CNULL+2CIQLearnSS-method'></span><span id='topic+.newIQLearnFS_ME+2CNULL+2CmodelObj+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Performs regression on the fitted main effects the second stage regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newIQLearnFS_ME(moMain, moCont, response, ...)

## S4 method for signature 'modelObj,modelObj,IQLearnSS'
.newIQLearnFS_ME(moMain, moCont, data, response, txName, iter, suppress)

## S4 method for signature 'modelObj,'NULL',IQLearnSS'
.newIQLearnFS_ME(moMain, moCont, data, response, txName, iter, suppress)

## S4 method for signature ''NULL',modelObj,IQLearnSS'
.newIQLearnFS_ME(moMain, moCont, data, response, txName, iter, suppress)
</code></pre>

<hr>
<h2 id='.newIQLearnFS_VHet'>Complete First Stage Analysis of Residuals for Interactive Q-Learning Algorithm</h2><span id='topic+.newIQLearnFS_VHet'></span><span id='topic+.newIQLearnFS_VHet+2CIQLearnFS_C+2CmodelObj+2CmodelObj-method'></span><span id='topic+.newIQLearnFS_VHet+2CIQLearnFS_C+2CmodelObj+2CNULL-method'></span><span id='topic+.newIQLearnFS_VHet+2CIQLearnFS_C+2CNULL+2CmodelObj-method'></span>

<h3>Description</h3>

<p>Performs log-linear regression on the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newIQLearnFS_VHet(object, moMain, moCont, ...)

## S4 method for signature 'IQLearnFS_C,modelObj,modelObj'
.newIQLearnFS_VHet(object, moMain, moCont, data, iter, suppress)

## S4 method for signature 'IQLearnFS_C,modelObj,'NULL''
.newIQLearnFS_VHet(object, moMain, moCont, data, iter, suppress)

## S4 method for signature 'IQLearnFS_C,'NULL',modelObj'
.newIQLearnFS_VHet(object, moMain, moCont, data, iter, suppress)
</code></pre>

<hr>
<h2 id='.newIQLearnSS'>Complete Second Stage Analysis of Interactive Q-Learning Algorithm</h2><span id='topic+.newIQLearnSS'></span><span id='topic+.newIQLearnSS+2CmodelObj+2CmodelObj-method'></span><span id='topic+.newIQLearnSS+2CmodelObj+2CNULL-method'></span><span id='topic+.newIQLearnSS+2CNULL+2CmodelObj-method'></span>

<h3>Description</h3>

<p>Performs the regression of the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newIQLearnSS(moMain, moCont, ...)

## S4 method for signature 'modelObj,modelObj'
.newIQLearnSS(moMain, moCont, data, response, txName, iter, suppress)

## S4 method for signature 'modelObj,'NULL''
.newIQLearnSS(moMain, moCont, data, response, txName, iter, suppress)

## S4 method for signature ''NULL',modelObj'
.newIQLearnSS(moMain, moCont, data, response, txName, iter, suppress)
</code></pre>

<hr>
<h2 id='.newKernelObj'>Create a KernelObj</h2><span id='topic+.newKernelObj'></span><span id='topic+.newKernelObj+2Ccharacter+2Cformula-method'></span><span id='topic+.newKernelObj+2Clist+2Clist-method'></span>

<h3>Description</h3>

<p>Processes input to determine type of kernel, creates it, and stores in 
@slot kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newKernelObj(kernel, model, ...)

## S4 method for signature 'character,formula'
.newKernelObj(kernel, model, data, kparam = NULL, ...)

## S4 method for signature 'list,list'
.newKernelObj(kernel, model, data, kparam = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newKernelObj_+3A_kernel">kernel</code></td>
<td>
<p>A character. Name of kernel</p>
</td></tr>
<tr><td><code id=".newKernelObj_+3A_model">model</code></td>
<td>
<p>A formula or list of formula</p>
</td></tr>
</table>

<hr>
<h2 id='.newLearning'>Complete a Learning Analysis</h2><span id='topic+.newLearning'></span><span id='topic+.newLearning+2CNULL+2CKernel-method'></span><span id='topic+.newLearning+2Cfunction+2CKernel-method'></span><span id='topic+.newLearning+2Cfunction+2CSubsetList-method'></span>

<h3>Description</h3>

<p>Performs a weighted learning analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newLearning(fSet, kernel, ...)

## S4 method for signature ''NULL',Kernel'
.newLearning(
  fSet,
  kernel,
  ...,
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  iter,
  surrogate,
  suppress,
  guess,
  createObj,
  prodPi = 1,
  index = NULL
)

## S4 method for signature ''function',Kernel'
.newLearning(
  fSet,
  kernel,
  ...,
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  iter,
  surrogate,
  suppress,
  guess,
  createObj,
  prodPi = 1,
  index = NULL
)

## S4 method for signature ''function',SubsetList'
.newLearning(
  fSet,
  kernel,
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  iter,
  surrogate,
  suppress,
  guess,
  createObj,
  prodPi = 1,
  index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newLearning_+3A_fset">fSet</code></td>
<td>
<p>NULL or function defining subset rules</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object or SubsetList</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_...">...</code></td>
<td>
<p>Additional inputs for optimization</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_mopropen">moPropen</code></td>
<td>
<p>modelObj for propensity model</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_momain">moMain</code></td>
<td>
<p>modelObj for main effects of outcome model</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_mocont">moCont</code></td>
<td>
<p>modelObj for contrasts of outcome model</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_data">data</code></td>
<td>
<p>data.frame of covariates</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_txname">txName</code></td>
<td>
<p>Tx variable column header in data</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_lambdas">lambdas</code></td>
<td>
<p>Tuning parameter(s)</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_cvfolds">cvFolds</code></td>
<td>
<p>Number of cross-validation folds</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations for outcome regression</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if prints to screen are executed</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_guess">guess</code></td>
<td>
<p>optional numeric vector providing starting values for
optimization methods</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_createobj">createObj</code></td>
<td>
<p>A function name defining the method object for a
specific learning algorithm</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_prodpi">prodPi</code></td>
<td>
<p>A vector of propensity weights</p>
</td></tr>
<tr><td><code id=".newLearning_+3A_index">index</code></td>
<td>
<p>The subset of individuals to be included in learning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Learning</code> object
</p>

<hr>
<h2 id='.newModel'>Combine model object models</h2><span id='topic+.newModel'></span><span id='topic+.newModel+2CmodelObj+2CmodelObj-method'></span><span id='topic+.newModel+2CmodelObj+2CNULL-method'></span><span id='topic+.newModel+2CNULL+2CmodelObj-method'></span>

<h3>Description</h3>

<p>Combines moMain and moCont into a single modeling object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newModel(moMain, moCont, ...)

## S4 method for signature 'modelObj,modelObj'
.newModel(moMain, moCont, txName, suppress)

## S4 method for signature 'modelObj,'NULL''
.newModel(moMain, moCont, txName, suppress)

## S4 method for signature ''NULL',modelObj'
.newModel(moMain, moCont, txName, suppress)
</code></pre>

<hr>
<h2 id='.newOptim'>Complete an Optimization Step</h2><span id='topic+.newOptim'></span><span id='topic+.newOptim+2CLinearKernel-method'></span><span id='topic+.newOptim+2CKernel-method'></span>

<h3>Description</h3>

<p>Dispatches appropriate methods to optimize an object function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOptim(kernel, ...)

## S4 method for signature 'LinearKernel'
.newOptim(kernel, lambda, methodObject, suppress, ...)

## S4 method for signature 'Kernel'
.newOptim(kernel, lambda, methodObject, suppress, ...)
</code></pre>

<hr>
<h2 id='.newOptimalClass'>Estimate the Optimal Treatment and Value Using Classification</h2><span id='topic+.newOptimalClass'></span><span id='topic+.newOptimalClass+2Cvector-method'></span><span id='topic+.newOptimalClass+2COptimalClass-method'></span>

<h3>Description</h3>

<p>Method dispatches the appropriate function to obtain estimates for the
optimal treatment and value using classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOptimalClass(response, ...)

## S4 method for signature 'vector'
.newOptimalClass(
  moPropen,
  moMain,
  moCont,
  moClass,
  data,
  response,
  txName,
  iter,
  fSet,
  suppress,
  ...
)

## S4 method for signature 'OptimalClass'
.newOptimalClass(
  moPropen,
  moMain,
  moCont,
  moClass,
  data,
  response,
  txName,
  iter,
  fSet,
  suppress,
  ...
)
</code></pre>

<hr>
<h2 id='.newOptimalSeq'>Complete a the Coarsened/Missing Data Analysis</h2><span id='topic+.newOptimalSeq'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2Clist-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CNULL+2Clist-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CNULL+2CModelObj_DecisionPointList+2Clist-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CNULL+2CNULL+2Clist-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CNULL+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CNULL+2CModelObj_DecisionPointList+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CModelObj_DecisionPointList+2CNULL+2CNULL+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CmodelObj+2CmodelObj+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CmodelObj+2CNULL+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CNULL+2CmodelObj+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CNULL+2CNULL+2CNULL-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CmodelObj+2CmodelObj+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CmodelObj+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CNULL+2CmodelObj+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CNULL+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CmodelObj+2CmodelObj+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CmodelObj+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CNULL+2CmodelObj+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CNULL+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CModelObj_SubsetList+2CModelObj_SubsetList+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CModelObj_SubsetList+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CModelObj_SubsetList+2CNULL+2CModelObj_SubsetList+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CModelObj_SubsetList+2CModelObj_SubsetList+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CModelObj_SubsetList+2CNULL+2Cfunction-method'></span><span id='topic+.newOptimalSeq+2CmodelObj+2CNULL+2CModelObj_SubsetList+2Cfunction-method'></span>

<h3>Description</h3>

<p>Dispatches appropriate coarsened or missing data perspective method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOptimalSeq(moPropen, moMain, moCont, fSet, ...)

## S4 method for signature 
## 'ModelObj_DecisionPointList,
##   ModelObj_DecisionPointList,
##   ModelObj_DecisionPointList,
##   list'
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_DecisionPointList,ModelObj_DecisionPointList,&lsquo;NULL',list&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_DecisionPointList,&lsquo;NULL',ModelObj_DecisionPointList,list&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_DecisionPointList,'NULL','NULL',list'
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_DecisionPointList,
##   ModelObj_DecisionPointList,
##   ModelObj_DecisionPointList,
##   &lsquo;NULL'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_DecisionPointList,ModelObj_DecisionPointList,&lsquo;NULL','NULL'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_DecisionPointList,&lsquo;NULL',ModelObj_DecisionPointList,'NULL'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_DecisionPointList,'NULL','NULL','NULL''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,modelObj,modelObj,'NULL''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,modelObj,'NULL','NULL''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,'NULL',modelObj,'NULL''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,'NULL','NULL','NULL''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,modelObj,modelObj,'function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,modelObj,'NULL','function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,'NULL',modelObj,'function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,'NULL','NULL','function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_SubsetList,modelObj,modelObj,'function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_SubsetList,modelObj,'NULL','function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_SubsetList,'NULL',modelObj,'function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'ModelObj_SubsetList,'NULL','NULL','function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_SubsetList,
##   ModelObj_SubsetList,
##   ModelObj_SubsetList,
##   &lsquo;function'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_SubsetList,ModelObj_SubsetList,&lsquo;NULL','function'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'ModelObj_SubsetList,&lsquo;NULL',ModelObj_SubsetList,'function'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 
## 'modelObj,ModelObj_SubsetList,ModelObj_SubsetList,&lsquo;function'&rsquo;
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,ModelObj_SubsetList,'NULL','function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)

## S4 method for signature 'modelObj,'NULL',ModelObj_SubsetList,'function''
.newOptimalSeq(
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimesObj,
  fSet,
  iter,
  suppress,
  argsList,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newOptimalSeq_+3A_mopropen">moPropen</code></td>
<td>
<p>model object(s) for propensity regression</p>
</td></tr>
<tr><td><code id=".newOptimalSeq_+3A_momain">moMain</code></td>
<td>
<p>model object(s) for main effects of outcome regression</p>
</td></tr>
<tr><td><code id=".newOptimalSeq_+3A_mocont">moCont</code></td>
<td>
<p>model object(s) for contrasts of outcome regression</p>
</td></tr>
<tr><td><code id=".newOptimalSeq_+3A_fset">fSet</code></td>
<td>
<p>function(s) defining feasible tx</p>
</td></tr>
<tr><td><code id=".newOptimalSeq_+3A_...">...</code></td>
<td>
<p>additional inputs.</p>
</td></tr>
</table>

<hr>
<h2 id='.newOptimObj'>Create an OptimObj Object</h2><span id='topic+.newOptimObj'></span><span id='topic+.newOptimObj+2CANY-method'></span><span id='topic+.newOptimObj+2C.rwl-method'></span>

<h3>Description</h3>

<p>Call newOptim and stores result under common name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOptimObj(methodObject, kernel, ...)

## S4 method for signature 'ANY'
.newOptimObj(methodObject, lambda, suppress, ...)

## S4 method for signature '.rwl'
.newOptimObj(methodObject, lambda, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newOptimObj_+3A_methodobject">methodObject</code></td>
<td>
<p>object containing parameters needed by a weighted 
learning method</p>
</td></tr>
<tr><td><code id=".newOptimObj_+3A_...">...</code></td>
<td>
<p>additional inputs passed to optimization routine.</p>
</td></tr>
<tr><td><code id=".newOptimObj_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameters</p>
</td></tr>
<tr><td><code id=".newOptimObj_+3A_suppress">suppress</code></td>
<td>
<p>integer indicating screen print preferences</p>
</td></tr>
</table>

<hr>
<h2 id='.newOutcomeFit'>Perform an Outcome Regression Step</h2><span id='topic+.newOutcomeFit'></span><span id='topic+.newOutcomeFit+2CNULL+2CNULL+2CTxObj+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CmodelObj+2CTxInfoNoSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CNULL+2CTxInfoNoSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CNULL+2CmodelObj+2CTxInfoNoSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CmodelObj+2CTxInfoWithSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CNULL+2CTxInfoWithSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CNULL+2CmodelObj+2CTxInfoWithSubsets+2CNULL-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CmodelObj+2CTxInfoWithSubsets+2Cinteger-method'></span><span id='topic+.newOutcomeFit+2CmodelObj+2CmodelObj+2CTxInfoNoSubsets+2Cinteger-method'></span><span id='topic+.newOutcomeFit+2CModelObj_SubsetList+2CModelObj_SubsetList+2CTxInfoWithSubsets+2Cinteger-method'></span><span id='topic+.newOutcomeFit+2CModelObj_SubsetList+2CModelObj_SubsetList+2CTxInfoWithSubsets+2CANY-method'></span><span id='topic+.newOutcomeFit+2CModelObj_SubsetList+2CNULL+2CTxInfoWithSubsets+2CANY-method'></span><span id='topic+.newOutcomeFit+2CNULL+2CModelObj_SubsetList+2CTxInfoWithSubsets+2CANY-method'></span>

<h3>Description</h3>

<p>Dispatch appropriate methods to perform outcome regression step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOutcomeFit(moMain, moCont, txObj, iter, ...)

## S4 method for signature ''NULL','NULL',TxObj,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature 'modelObj,modelObj,TxInfoNoSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature 'modelObj,'NULL',TxInfoNoSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature ''NULL',modelObj,TxInfoNoSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature 'modelObj,modelObj,TxInfoWithSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature 'modelObj,'NULL',TxInfoWithSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature ''NULL',modelObj,TxInfoWithSubsets,'NULL''
.newOutcomeFit(moMain, moCont, txObj, iter, data, response, suppress)

## S4 method for signature 'modelObj,modelObj,TxInfoWithSubsets,integer'
.newOutcomeFit(moMain, moCont, response, txObj, data, iter, suppress)

## S4 method for signature 'modelObj,modelObj,TxInfoNoSubsets,integer'
.newOutcomeFit(moMain, moCont, response, txObj, data, iter, suppress)

## S4 method for signature 
## 'ModelObj_SubsetList,ModelObj_SubsetList,TxInfoWithSubsets,integer'
.newOutcomeFit(moMain, moCont, response, txObj, data, iter, suppress)

## S4 method for signature 
## 'ModelObj_SubsetList,ModelObj_SubsetList,TxInfoWithSubsets,ANY'
.newOutcomeFit(moMain, moCont, txObj, data, response, iter, suppress)

## S4 method for signature 'ModelObj_SubsetList,'NULL',TxInfoWithSubsets,ANY'
.newOutcomeFit(moMain, moCont, txObj, data, response, iter, suppress)

## S4 method for signature ''NULL',ModelObj_SubsetList,TxInfoWithSubsets,ANY'
.newOutcomeFit(moMain, moCont, txObj, data, response, iter, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newOutcomeFit_+3A_momain">moMain</code></td>
<td>
<p>A modeling object for main effects or NULL</p>
</td></tr>
<tr><td><code id=".newOutcomeFit_+3A_mocont">moCont</code></td>
<td>
<p>A modeling object for contrasts or NULL</p>
</td></tr>
<tr><td><code id=".newOutcomeFit_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newOutcomeFit_+3A_iter">iter</code></td>
<td>
<p>NULL or numeric</p>
</td></tr>
<tr><td><code id=".newOutcomeFit_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.newOutcomeObj'>Create a new <code>OutcomeObj</code> object</h2><span id='topic+.newOutcomeObj'></span><span id='topic+.newOutcomeObj+2CANY+2CANY+2CANY-method'></span><span id='topic+.newOutcomeObj+2CModelObj_DecisionPointList+2CModelObj_DecisionPointList+2CTxInfoList-method'></span><span id='topic+.newOutcomeObj+2CModelObj_DecisionPointList+2CANY+2CTxInfoList-method'></span><span id='topic+.newOutcomeObj+2CNULL+2CModelObj_DecisionPointList+2CTxInfoList-method'></span>

<h3>Description</h3>

<p>Calls newOutcomeFit and stores in @outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOutcomeObj(moMain, moCont, txObj, iter, ...)

## S4 method for signature 'ANY,ANY,ANY'
.newOutcomeObj(moMain, moCont, txObj, data, response, iter, suppress)

## S4 method for signature 
## 'ModelObj_DecisionPointList,ModelObj_DecisionPointList,TxInfoList'
.newOutcomeObj(moMain, moCont, txObj, data, response, iter, suppress, ...)

## S4 method for signature 'ModelObj_DecisionPointList,ANY,TxInfoList'
.newOutcomeObj(moMain, moCont, txObj, data, response, iter, suppress, ...)

## S4 method for signature ''NULL',ModelObj_DecisionPointList,TxInfoList'
.newOutcomeObj(moMain, moCont, txObj, data, response, iter, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newOutcomeObj_+3A_momain">moMain</code></td>
<td>
<p>A modeling object for main effects</p>
</td></tr>
<tr><td><code id=".newOutcomeObj_+3A_mocont">moCont</code></td>
<td>
<p>A modeling object for contrasts</p>
</td></tr>
<tr><td><code id=".newOutcomeObj_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newOutcomeObj_+3A_iter">iter</code></td>
<td>
<p>NULL or integer</p>
</td></tr>
<tr><td><code id=".newOutcomeObj_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.newOWL'>Complete an OWL Analysis</h2><span id='topic+.newOWL'></span>

<h3>Description</h3>

<p>Complete an OWL Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newOWL(
  moPropen,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  kernel,
  fSet,
  surrogate,
  suppress,
  guess,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newOWL_+3A_mopropen">moPropen</code></td>
<td>
<p>modelObj for propensity modeling</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_data">data</code></td>
<td>
<p>data.frame of covariates</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_txname">txName</code></td>
<td>
<p>Tx variable column header in data</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_lambdas">lambdas</code></td>
<td>
<p>Tuning parameter(s)</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_cvfolds">cvFolds</code></td>
<td>
<p>Number of cross-validation folds</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object or SubsetList</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_fset">fSet</code></td>
<td>
<p>NULL or function defining subset rules</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if prints to screen are executed</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_guess">guess</code></td>
<td>
<p>optional numeric vector providing starting values for
optimization methods</p>
</td></tr>
<tr><td><code id=".newOWL_+3A_...">...</code></td>
<td>
<p>Additional inputs for optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An OWL object
</p>

<hr>
<h2 id='.newPropensityFit'>Complete a Propensity Regression Step</h2><span id='topic+.newPropensityFit'></span><span id='topic+.newPropensityFit+2CmodelObj+2CTxInfoNoSubsets-method'></span><span id='topic+.newPropensityFit+2CmodelObj+2CTxInfoWithSubsets-method'></span><span id='topic+.newPropensityFit+2CModelObj_SubsetList+2CTxInfoWithSubsets-method'></span>

<h3>Description</h3>

<p>Dispatches appropriate method for completing propensity regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newPropensityFit(moPropen, txObj, ...)

## S4 method for signature 'modelObj,TxInfoNoSubsets'
.newPropensityFit(moPropen, txObj, data, suppress)

## S4 method for signature 'modelObj,TxInfoWithSubsets'
.newPropensityFit(moPropen, txObj, data, suppress)

## S4 method for signature 'ModelObj_SubsetList,TxInfoWithSubsets'
.newPropensityFit(moPropen, txObj, data, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newPropensityFit_+3A_mopropen">moPropen</code></td>
<td>
<p>A modeling object</p>
</td></tr>
<tr><td><code id=".newPropensityFit_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newPropensityFit_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.newPropensityObj'>Create a new <code>PropensityObj</code> object</h2><span id='topic+.newPropensityObj'></span><span id='topic+.newPropensityObj+2CANY+2CANY-method'></span><span id='topic+.newPropensityObj+2CModelObj_DecisionPointList+2CTxInfoList-method'></span>

<h3>Description</h3>

<p>Calls newPropensityFit and stores result in @propen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newPropensityObj(moPropen, txObj, data, suppress, ...)

## S4 method for signature 'ANY,ANY'
.newPropensityObj(moPropen, txObj, data, suppress)

## S4 method for signature 'ModelObj_DecisionPointList,TxInfoList'
.newPropensityObj(moPropen, txObj, data, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newPropensityObj_+3A_mopropen">moPropen</code></td>
<td>
<p>A modeling object</p>
</td></tr>
<tr><td><code id=".newPropensityObj_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newPropensityObj_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.newQLearn'>Perform a Step of the Q-Learning Algorithm</h2><span id='topic+.newQLearn'></span><span id='topic+.newQLearn+2Cvector-method'></span><span id='topic+.newQLearn+2CQLearn-method'></span>

<h3>Description</h3>

<p>Method performs all necessary regression and predictions steps for a
single step of the Q-learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newQLearn(response, ...)

## S4 method for signature 'vector'
.newQLearn(moMain, moCont, fSet, response, data, txName, iter, suppress)

## S4 method for signature 'QLearn'
.newQLearn(moMain, moCont, fSet, response, data, txName, iter, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newQLearn_+3A_response">response</code></td>
<td>
<p>a vector or the value object returned by a prior call to 
qlearn()</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_momain">moMain</code></td>
<td>
<p>modeling object specifying the main effects component of the
outcome model</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_mocont">moCont</code></td>
<td>
<p>modeling object specifying the contrasts component of the
outcome model</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_fset">fSet</code></td>
<td>
<p>function defining the feasible tx subsets</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_data">data</code></td>
<td>
<p>data.frame of covariates and tx received</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_txname">txName</code></td>
<td>
<p>character name of tx variable in data</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_iter">iter</code></td>
<td>
<p>the maximum number of iterations in the iterative algorithm</p>
</td></tr>
<tr><td><code id=".newQLearn_+3A_suppress">suppress</code></td>
<td>
<p>logical indicating user's screen printing preference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class QLearn.
</p>

<hr>
<h2 id='.newRegime'>Create a new <code>Regime</code> object</h2><span id='topic+.newRegime'></span><span id='topic+.newRegime+2Cfunction-method'></span>

<h3>Description</h3>

<p>Create a new <code>Regime</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newRegime(object)

## S4 method for signature ''function''
.newRegime(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newRegime_+3A_object">object</code></td>
<td>
<p>A function defining the treatment regime</p>
</td></tr>
</table>

<hr>
<h2 id='.newRegimeObj'>Create a New <code>RegimeObj</code> Object</h2><span id='topic+.newRegimeObj'></span><span id='topic+.newRegimeObj+2Cfunction-method'></span><span id='topic+.newRegimeObj+2Clist-method'></span>

<h3>Description</h3>

<p>Calls newRegime and stores object in @regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newRegimeObj(object)

## S4 method for signature ''function''
.newRegimeObj(object)

## S4 method for signature 'list'
.newRegimeObj(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newRegimeObj_+3A_object">object</code></td>
<td>
<p>A function defining the treatment regime</p>
</td></tr>
</table>

<hr>
<h2 id='.newRWL'>Complete a Residual Weighted Learning Analysis</h2><span id='topic+.newRWL'></span><span id='topic+.newRWL+2CSubsetList-method'></span>

<h3>Description</h3>

<p>Complete a Residual Weighted Learning Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newRWL(kernel, ...)

## S4 method for signature 'SubsetList'
.newRWL(
  moPropen,
  moMain,
  responseType,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  surrogate,
  guess,
  kernel,
  fSet,
  suppress,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newRWL_+3A_kernel">kernel</code></td>
<td>
<p>A Kernel object</p>
</td></tr>
</table>

<hr>
<h2 id='.newRWL+2CKernel-method'>Complete a Residual Weighted Learning Analysis</h2><span id='topic+.newRWL+2CKernel-method'></span>

<h3>Description</h3>

<p>Complete a Residual Weighted Learning Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Kernel'
.newRWL(
  moPropen,
  moMain,
  responseType,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  surrogate,
  guess,
  kernel,
  fSet,
  suppress,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_mopropen">moPropen</code></td>
<td>
<p>modelObj for propensity modeling</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_momain">moMain</code></td>
<td>
<p>modelObj for main effects</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_responsetype">responseType</code></td>
<td>
<p>Character indicating type of response</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_data">data</code></td>
<td>
<p>data.frame of covariates</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_response">response</code></td>
<td>
<p>vector of responses</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_txname">txName</code></td>
<td>
<p>treatment variable column header in data</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_lambdas">lambdas</code></td>
<td>
<p>tuning parameter(s)</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_cvfolds">cvFolds</code></td>
<td>
<p>number of cross-validation folds</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_guess">guess</code></td>
<td>
<p>optional numeric vector providing starting values for
optimization methods</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_fset">fSet</code></td>
<td>
<p>Function or NULL defining subsets</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if prints to screen are executed</p>
</td></tr>
<tr><td><code id=".newRWL+2B2CKernel-method_+3A_...">...</code></td>
<td>
<p>Additional inputs for optimization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An RWL object
</p>

<hr>
<h2 id='.newTxObj'>Create <code>TxObj</code> Object</h2><span id='topic+.newTxObj'></span><span id='topic+.newTxObj+2CANY+2Ccharacter-method'></span><span id='topic+.newTxObj+2CNULL+2Ccharacter-method'></span><span id='topic+.newTxObj+2Cfunction+2Ccharacter-method'></span><span id='topic+.newTxObj+2Clist+2Clist-method'></span><span id='topic+.newTxObj+2CNULL+2Clist-method'></span>

<h3>Description</h3>

<p>Creates appropriate <code>TxObj</code> based on class of fSet and txName.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newTxObj(fSet, txName, ...)

## S4 method for signature 'ANY,character'
.newTxObj(fSet, txName, ...)

## S4 method for signature ''NULL',character'
.newTxObj(fSet, txName, data, suppress, verify = TRUE)

## S4 method for signature ''function',character'
.newTxObj(fSet, txName, data, suppress, verify = TRUE)

## S4 method for signature 'list,list'
.newTxObj(fSet, txName, data, suppress, verify = TRUE)

## S4 method for signature ''NULL',list'
.newTxObj(fSet, txName, data, suppress, verify = TRUE)
</code></pre>

<hr>
<h2 id='.newTxSubset'>Create <code>TxSubset</code> Object</h2><span id='topic+.newTxSubset'></span><span id='topic+.newTxSubset+2Cfunction+2CANY-method'></span><span id='topic+.newTxSubset+2Cfunction+2Cinteger-method'></span><span id='topic+.newTxSubset+2Cfunction+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Processes input to determine ptsSubset and singleton to create a
<code>TxSubset</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newTxSubset(fSet, superset, ...)

## S4 method for signature ''function',ANY'
.newTxSubset(fSet, superset, ..., data, verify, suppress)

## S4 method for signature ''function',integer'
.newTxSubset(fSet, superset, txName, data, verify, ...)

## S4 method for signature ''function',character'
.newTxSubset(fSet, superset, ..., txName, data, verify)
</code></pre>

<hr>
<h2 id='.newTypedFit'>Complete a Regression Step</h2><span id='topic+.newTypedFit'></span><span id='topic+.newTypedFit+2CmodelObj+2CTxInfoNoSubsets-method'></span><span id='topic+.newTypedFit+2CModelObj_SubsetList+2CTxInfoWithSubsets-method'></span><span id='topic+.newTypedFit+2CmodelObj+2CTxInfoWithSubsets-method'></span>

<h3>Description</h3>

<p>This function completes a regression step and stores a character object
used to identify the purpose of the step, such as a propensity or
outcome regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newTypedFit(modelObj, txObj, ...)

## S4 method for signature 'modelObj,TxInfoNoSubsets'
.newTypedFit(modelObj, txObj, response, data, type, suppress)

## S4 method for signature 'ModelObj_SubsetList,TxInfoWithSubsets'
.newTypedFit(modelObj, txObj, data, response, type, suppress)

## S4 method for signature 'modelObj,TxInfoWithSubsets'
.newTypedFit(modelObj, txObj, data, response, type, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newTypedFit_+3A_modelobj">modelObj</code></td>
<td>
<p>A modeling object</p>
</td></tr>
<tr><td><code id=".newTypedFit_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newTypedFit_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.newTypedFitObj'>Create a new <code>TypedFitObj</code> object</h2><span id='topic+.newTypedFitObj'></span><span id='topic+.newTypedFitObj+2CANY-method'></span>

<h3>Description</h3>

<p>Call newTypedFit and stores result in @fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newTypedFitObj(modelObj, txObj, ...)

## S4 method for signature 'ANY'
.newTypedFitObj(modelObj, txObj, response, data, type, suppress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newTypedFitObj_+3A_modelobj">modelObj</code></td>
<td>
<p>A modeling object</p>
</td></tr>
<tr><td><code id=".newTypedFitObj_+3A_txobj">txObj</code></td>
<td>
<p>A TxObj object</p>
</td></tr>
<tr><td><code id=".newTypedFitObj_+3A_...">...</code></td>
<td>
<p>Any optional additional input.</p>
</td></tr>
</table>

<hr>
<h2 id='.optimalClass'>Perform Classification Step</h2><span id='topic+.optimalClass'></span>

<h3>Description</h3>

<p>Perform Classification Step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.optimalClass(
  moPropen,
  moMain,
  moCont,
  moClass,
  data,
  response,
  txName,
  iter,
  fSet,
  suppress,
  step
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".optimalClass_+3A_mopropen">moPropen</code></td>
<td>
<p>model object(s) for propensity regression</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_momain">moMain</code></td>
<td>
<p>model object(s) for main effects of outcome regression or NULL</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_mocont">moCont</code></td>
<td>
<p>model object(s) for contrasts of outcome regression or NULL</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_moclass">moClass</code></td>
<td>
<p>model object(s) for classification procedure</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_data">data</code></td>
<td>
<p>data.frame of covariates and treatment history</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_response">response</code></td>
<td>
<p>vector of responses</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_txname">txName</code></td>
<td>
<p>character of column header of data containing tx</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations for outcome regression or NULL</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_fset">fSet</code></td>
<td>
<p>function defining subsets or NULL</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating screen printing preference</p>
</td></tr>
<tr><td><code id=".optimalClass_+3A_step">step</code></td>
<td>
<p>integer indicating step of algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class OptimalClass
</p>

<hr>
<h2 id='.seqFunc'>Define the Objective Function</h2><span id='topic+.seqFunc'></span><span id='topic+.seqFunc+2Cnumeric+2CTxInfoList-method'></span><span id='topic+.seqFunc+2Cnumeric+2CTxObj-method'></span>

<h3>Description</h3>

<p>Method is defined by inheriting classes to define the objective function
optmized by the genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.seqFunc(eta, txObj, ...)

## S4 method for signature 'numeric,TxInfoList'
.seqFunc(eta, txObj, regimesObj, l.data, outcomeObj, propenObj, response)

## S4 method for signature 'numeric,TxObj'
.seqFunc(eta, txObj, regimesObj, l.data, outcomeObj, propenObj, response)
</code></pre>

<hr>
<h2 id='bmiData'>Adolescent BMI dataset (generated toy example)</h2><span id='topic+bmiData'></span>

<h3>Description</h3>

<p>A dataset generated to mimic data from a two-stage randomized clinical trial 
that studied the effect of meal replacement shakes on adolescent obesity. 
The dataset contains the following covariates collected at the start of the 
first stage: &quot;gender,&quot; &quot;race,&quot; &quot;parentBMI,&quot; and &quot;baselineBMI.&quot; At the 
second-stage, &quot;month4BMI&quot; was collected. Variables &quot;A1&quot; and &quot;A2&quot; are the 
randomized treatments at stages one and two, and &quot;month12BMI&quot; is the primary 
outcome collected at the end of stage two.
</p>


<h3>Format</h3>

<p>A matrix with rows corresponding to patients.
</p>


<h3>Source</h3>

<p>Generated by Kristin A. Linn in R
</p>

<hr>
<h2 id='bowl'>Backwards Outcome Weighted Learning.</h2><span id='topic+bowl'></span>

<h3>Description</h3>

<p>Function performs a single step
of the bowl method. Multiple decision points can be analyzed by
repeated calls, as is done for qLearn() and optimalClass().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bowl(
  ...,
  moPropen,
  data,
  reward,
  txName,
  regime,
  response,
  BOWLObj = NULL,
  lambdas = 2,
  cvFolds = 0L,
  kernel = "linear",
  kparam = NULL,
  fSet = NULL,
  surrogate = "hinge",
  verbose = 2L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bowl_+3A_...">...</code></td>
<td>
<p>Used primarily to require named input. However, inputs for
the optimization methods can be sent through the ellipsis. If surrogate
is hinge, the optimization method is dfoptim::hjk(). For all other 
surrogates, stats::optim() is used.</p>
</td></tr>
<tr><td><code id="bowl_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the propensity for tx.
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="bowl_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx histories.</p>
</td></tr>
<tr><td><code id="bowl_+3A_reward">reward</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code id="bowl_+3A_txname">txName</code></td>
<td>
<p>A character object.
The column header of <em>data</em> that corresponds to the tx covariate</p>
</td></tr>
<tr><td><code id="bowl_+3A_regime">regime</code></td>
<td>
<p>A formula object or a list of formula objects.
The covariates to be included in the decision function/kernel. 
If a list is provided,
this specifies that there is an underlying subset structure &ndash; fSet must
then be defined. For subsets, the name of each element of the list must 
correspond to the name of a subset. If a regime is to be estimated using
multiple subsets combined, each subset must be included in the name and
separated by a comma (no spaces).</p>
</td></tr>
<tr><td><code id="bowl_+3A_response">response</code></td>
<td>
<p>A numeric vector.
The same as reward above. Allows for naming convention followed in most
DynTxRegime methods.</p>
</td></tr>
<tr><td><code id="bowl_+3A_bowlobj">BOWLObj</code></td>
<td>
<p>NULL or <code><a href="#topic+BOWL-class">BOWL-class</a></code> object returned from 
previous call to bowl(). If NULL, indicates that the function call is 
for the first STEP of the BOWL algorithm (i.e., the final decision point). 
If a <code><a href="#topic+BOWL-class">BOWL-class</a></code> object, assumed that the object was 
returned by the preceding step of the BOWL algorithm.</p>
</td></tr>
<tr><td><code id="bowl_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric object or a numeric vector object giving the
penalty tuning parameter(s). If more than 1 is provided,
the set of tuning parameter values to be considered in the
cross-validation algorithm (note that cvFolds must be positive in this case).</p>
</td></tr>
<tr><td><code id="bowl_+3A_cvfolds">cvFolds</code></td>
<td>
<p>If cross-validation is to be used to select the tuning
parameters and/or kernel parameters, the number of folds.</p>
</td></tr>
<tr><td><code id="bowl_+3A_kernel">kernel</code></td>
<td>
<p>A character object.
Must be one of {'linear', 'poly', 'radial'}</p>
</td></tr>
<tr><td><code id="bowl_+3A_kparam">kparam</code></td>
<td>
<p>A numeric object. <br />
If kernel = linear, kparam is ignored. <br />
If kernel = poly, kparam is the degree of the polynomial. <br />
If kernel = radial, kparam is the inverse bandwidth of the
kernel. If a vector of bandwidth parameters is given,
cross-validation will be used to select the parameter
(note that cvFolds must be positive in this case).</p>
</td></tr>
<tr><td><code id="bowl_+3A_fset">fSet</code></td>
<td>
<p>A function or NULL defining subset structure. See ?fSet for
details.</p>
</td></tr>
<tr><td><code id="bowl_+3A_surrogate">surrogate</code></td>
<td>
<p>The surrogate 0-1 loss function. Must be one of
{'logit', 'exp', 'hinge', 'sqhinge', 'huber'}.</p>
</td></tr>
<tr><td><code id="bowl_+3A_verbose">verbose</code></td>
<td>
<p>An integer or logical. If 0, no screen prints are generated. If 1,
screen prints are generated with the exception of optimization results
obtained in iterative algorithm. If 2, all screen prints are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+BOWL-class">BOWL-class</a></code> object
</p>


<h3>References</h3>

<p>Yingqi Zhao, Donglin Zeng, Eric B. Laber, Michael R. Kosorok
(2015)
New statistical learning methods for estimating optimal dynamic
treatment regimes.
Journal of the American Statistical Association,
110:510, 583&ndash;598.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other weighted learning methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other multiple decision point methods: 
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# define the negative 4 month change in BMI from baseline
y4 &lt;- -100*(bmiData[,5L] - bmiData[,4L])/bmiData[,4L]

# reward for second stage
rewardSS &lt;- y12 - y4

#### Second-stage regression

# Constant propensity model
moPropen &lt;- buildModelObj(model = ~1,
                          solver.method = 'glm',
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

fitSS &lt;- bowl(moPropen = moPropen,
              data = bmiData, reward = rewardSS,  txName = 'A2', 
              regime = ~ parentBMI + month4BMI)

##Available methods

  # Coefficients of the propensity score regression
  coef(fitSS)

  # Description of method used to obtain object
  DTRstep(fitSS)

  # Estimated value of the optimal treatment regime for training set
  estimator(fitSS)

  # Value object returned by propensity score regression method
  fitObject(fitSS)

  # Summary of optimization routine
  optimObj(fitSS)

  # Estimated optimal treatment for training data
  optTx(fitSS)

  # Estimated optimal treatment for new data
  optTx(fitSS, bmiData)

  # Plots if defined by propensity regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(fitSS)
  plot(fitSS, suppress = TRUE)

  # Value object returned by propensity score regression method
  propen(fitSS)

  # Parameter estimates for decision function
  regimeCoef(fitSS)

  # Show main results of method
  show(fitSS)

  # Show summary results of method
  summary(fitSS)
 
#### First-stage regression

# Constant propensity model
fitFS &lt;- bowl(moPropen = moPropen,
              data = bmiData, reward = y4,  txName = 'A1', 
              regime = ~ gender + parentBMI,
              BOWLObj = fitSS, lambdas = c(0.5, 1.0), cvFolds = 4L)

##Available methods for fitFS are as shown above for fitSS

  # Results of the cross-validation
  cvInfo(fitFS)

</code></pre>

<hr>
<h2 id='BOWL-class'>Class <code>BOWL</code></h2><span id='topic+BOWL-class'></span>

<h3>Description</h3>

<p>Class <code>BOWL</code> contains results from a single step of BOWL algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>step</code></dt><dd><p>Integer indicating step of the algorithm</p>
</dd>
<dt><code>analysis</code></dt><dd><p>Contains a Learning or LearningMulti object.</p>
</dd>
<dt><code>analysis@txInfo</code></dt><dd><p>Feasible tx information.</p>
</dd>
<dt><code>analysis@propen</code></dt><dd><p>Propensity regression analysis.</p>
</dd>
<dt><code>analysis@outcome</code></dt><dd><p>Outcome regression analysis.</p>
</dd>
<dt><code>analysis@cvInfo</code></dt><dd><p>Cross-validation analysis if single regime.</p>
</dd>
<dt><code>analysis@optim</code></dt><dd><p>Optimization analysis if single regime.</p>
</dd>
<dt><code>analysis@optimResult</code></dt><dd><p>list of cross-validation and optimization results
if multiple regimes. optimResult[[i]]@cvInfo and optimResult[[i]]@optim.</p>
</dd>
<dt><code>analysis@optimal</code></dt><dd><p>Estimated optimal Tx and value.</p>
</dd>
<dt><code>analysis@call</code></dt><dd><p>Unevaluated call to statistical method.</p>
</dd>
<dt><code>prodPi</code></dt><dd><p>Vector of the products of the propensity for the tx received</p>
</dd>
<dt><code>sumR</code></dt><dd><p>Vector of the sum of the rewards</p>
</dd>
<dt><code>index</code></dt><dd><p>Vector indicating compliance with estimated optimal regime</p>
</dd>
</dl>

<hr>
<h2 id='BOWL-methods'>Methods Available for Objects of Class <code>BOWL</code></h2><span id='topic+BOWL-methods'></span><span id='topic+print+2CBOWL-method'></span><span id='topic+show+2CBOWL-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>BOWL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BOWL'
print(x, ...)

## S4 method for signature 'BOWL'
show(object)
</code></pre>

<hr>
<h2 id='BOWLBasic-class'>Class <code>BOWLBasic</code></h2><span id='topic+BOWLBasic-class'></span>

<h3>Description</h3>

<p>Class <code>BOWLBasic</code> contains the results for a single OWL analysis and the
weights needed for next iteration
</p>


<h3>Slots</h3>


<dl>
<dt><code>analysis</code></dt><dd><p>Contains a Learning or LearningMulti object.</p>
</dd>
<dt><code>analysis@txInfo</code></dt><dd><p>Feasible tx information.</p>
</dd>
<dt><code>analysis@propen</code></dt><dd><p>Propensity regression analysis.</p>
</dd>
<dt><code>analysis@outcome</code></dt><dd><p>Outcome regression analysis.</p>
</dd>
<dt><code>analysis@cvInfo</code></dt><dd><p>Cross-validation analysis if single regime.</p>
</dd>
<dt><code>analysis@optim</code></dt><dd><p>Optimization analysis if single regime.</p>
</dd>
<dt><code>analysis@optimResult</code></dt><dd><p>list of cross-validation and optimization results
if multiple regimes. optimResult[[i]]@cvInfo and optimResult[[i]]@optim.</p>
</dd>
<dt><code>analysis@optimal</code></dt><dd><p>Estimated optimal Tx and value.</p>
</dd>
<dt><code>analysis@call</code></dt><dd><p>Unevaluated call to statistical method.</p>
</dd>
<dt><code>prodPi</code></dt><dd><p>Vector of the products of the propensity for the tx received</p>
</dd>
<dt><code>sumR</code></dt><dd><p>Vector of the sum of the rewards</p>
</dd>
<dt><code>index</code></dt><dd><p>Vector indicating compliance with estimated optimal regime</p>
</dd>
</dl>

<hr>
<h2 id='BOWLBasic-methods'>Methods Available for Objects of Class <code>BOWLBasic</code></h2><span id='topic+BOWLBasic-methods'></span><span id='topic+Call+2CBOWLBasic-method'></span><span id='topic+coef+2CBOWLBasic-method'></span><span id='topic+cvInfo+2CBOWLBasic-method'></span><span id='topic+estimator+2CBOWLBasic-method'></span><span id='topic+fitObject+2CBOWLBasic-method'></span><span id='topic+optimObj+2CBOWLBasic-method'></span><span id='topic+optTx+2CBOWLBasic+2Cdata.frame-method'></span><span id='topic+optTx+2CBOWLBasic+2Cmissing-method'></span><span id='topic+outcome+2CBOWLBasic-method'></span><span id='topic+plot+2CBOWLBasic+2CANY-method'></span><span id='topic+print+2CBOWLBasic-method'></span><span id='topic+propen+2CBOWLBasic-method'></span><span id='topic+regimeCoef+2CBOWLBasic-method'></span><span id='topic+show+2CBOWLBasic-method'></span><span id='topic+summary+2CBOWLBasic-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>BOWLBasic</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BOWLBasic'
Call(name, ...)

## S4 method for signature 'BOWLBasic'
coef(object, ...)

## S4 method for signature 'BOWLBasic'
cvInfo(object, ...)

## S4 method for signature 'BOWLBasic'
estimator(x, ...)

## S4 method for signature 'BOWLBasic'
fitObject(object, ...)

## S4 method for signature 'BOWLBasic'
optimObj(object, ...)

## S4 method for signature 'BOWLBasic,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'BOWLBasic,missing'
optTx(x, newdata, ...)

## S4 method for signature 'BOWLBasic'
outcome(object, ...)

## S4 method for signature 'BOWLBasic,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'BOWLBasic'
print(x, ...)

## S4 method for signature 'BOWLBasic'
propen(object, ...)

## S4 method for signature 'BOWLBasic'
regimeCoef(object, ...)

## S4 method for signature 'BOWLBasic'
show(object)

## S4 method for signature 'BOWLBasic'
summary(object, ...)
</code></pre>

<hr>
<h2 id='BOWLObj-class'>Class <code>BOWLObj</code></h2><span id='topic+BOWLObj-class'></span>

<h3>Description</h3>

<p>Class <code>BOWLObj</code> contains product and sum information required for 
iteration
</p>


<h3>Slots</h3>


<dl>
<dt><code>prodPi</code></dt><dd><p>Vector of the products of the propensity for the tx received</p>
</dd>
<dt><code>sumR</code></dt><dd><p>Vector of the sum of the rewards</p>
</dd>
<dt><code>index</code></dt><dd><p>Vector indicating compliance with estimated optimal regime</p>
</dd>
</dl>

<hr>
<h2 id='buildModelObjSubset'>Create Model Objects for Subsets of Data</h2><span id='topic+buildModelObjSubset'></span>

<h3>Description</h3>

<p>Extends the buildModelObj() function of package <span class="pkg">modelObj</span>. Here,
the returned model object includes a specification of the 
decision point and subset of the data to which the model is to 
be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildModelObjSubset(
  ...,
  model,
  solver.method,
  solver.args = NULL,
  predict.method = NULL,
  predict.args = NULL,
  dp = 1L,
  subset = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildModelObjSubset_+3A_...">...</code></td>
<td>
<p>ignored. Included to require named input.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_model">model</code></td>
<td>
<p>An object of class <code>formula</code>. The symbolic description
of the model to be fitted. If the regression method specified in
solver.method accepts as input a <code>formula</code> object,
model is passed to the solver.method function. If the regression method
instead accepts a matrix of covariates as the model to fit, <code>model</code> is
used to obtain the model matrix that is passed to the solver.method
function.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_solver.method">solver.method</code></td>
<td>
<p>An object of class <code>character</code>. The name of 
the R function to be used to obtain parameter estimates, e.g., 'lm', 
'glm', or 'rpart'. The specified function MUST have a 
corresponding predict method, which can be the generic predict() function.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_solver.args">solver.args</code></td>
<td>
<p>An object of class <code>list</code>. Additional arguments 
to be sent to the function specified in solver.method. This 
argument must be provided as a named list, where the name of each element 
matches a formal argument of the function specified in 
solver.method. For example, if a logistic regression using 
'glm' is desired, 
</p>
<pre>
solver.method = "glm"
solver.args = list("family"=binomial)
</pre>
<p>See Details section for further information.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_predict.method">predict.method</code></td>
<td>
<p>An object of class <code>character</code>. The name of 
the R function to be used to obtain  predictions, e.g., 'predict.lm', 
'predict', or 'predict.glm'.  If no function is explicitly 
given, the generic <code>predict()</code> is assumed. For many regression 
methods, the generic <code>predict()</code> method is appropriate.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_predict.args">predict.args</code></td>
<td>
<p>An object of class <code>list</code>. Additional arguments 
to be sent to the function specified in predict.method. This 
argument must be provided as a named list, where the name of each 
element matches a formal argument of the function specified in 
predict.method. For example, if a logistic regression using 
'glm' was used to fit the model and predictions on the scale of the 
response are desired, 
</p>
<pre>
predict.method = "predict.glm"
predict.args = list("type"="response").
</pre>
<p>See Details section for further information.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_dp">dp</code></td>
<td>
<p>An object of class <code>integer</code>. The decision point for which 
this model and subset are defined.</p>
</td></tr>
<tr><td><code id="buildModelObjSubset_+3A_subset">subset</code></td>
<td>
<p>An object of class <code>character</code>. A nickname for the 
subset for which model and methods are to be used. This argument will 
be used by the methods of <span class="pkg">DynTxRegime</span> to &quot;link&quot; input arguments. 
In the event that a model is to be fit using more than 1 subset, 
collapse the subset names into a single character string separating 
each with a comma. For example, if the model is to be fit using patients 
in both subsets &quot;a&quot; and &quot;b,&quot; the subset nickname should be &quot;a,b&quot; (no space).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some settings, an analyst may want to use different models for unique 
subsets of the data. <code>buildModelObjSubset()</code> provides a mechanism for 
users to define models for such subset. Specifically, models are specified 
in connection with the decision point and subset to which they are to be 
applied. 
</p>
<p>See ?modelObj for further details
</p>


<h3>Value</h3>

<p>An object of class <code>ModelObjSubset</code>, which contains a  
complete description of the conditions under which a model  is to be  
used and the R methods to be used to obtain parameter estimates and  
predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Consider a 2 decision point trial. At the 1st decision point, the subset of 
# treatment options available to each patient is always set "set1."
# At the 2nd decision point, some patients are eligible to receive
# treatment from set "set2a" and others from set "set2b." The outcome
# for these subsets will be modeled as ~ x1 + x2 and ~ x2 + x3, respectively.
#
# All parameter estimates are to be obtained used lm and predictions obtained using predict.
#
# The following illustrates how to build these model objects.

  model &lt;- list()

  model[[1]] &lt;- buildModelObjSubset(dp = 1, subset = "set1",
                                    model = ~ x1 + x2 + x3, solver.method = 'lm')

  model[[2]] &lt;- buildModelObjSubset(dp = 2, subset = "set2a",
                                    model = ~ ~ x1 + x2, solver.method = 'lm')

  model[[3]] &lt;- buildModelObjSubset(dp = 2, subset = "set2b",
                                    model = ~ x2 + x3, solver.method = 'lm')

</code></pre>

<hr>
<h2 id='Call'>Retrieve Unevaluated Original Call</h2><span id='topic+Call'></span>

<h3>Description</h3>

<p>Returns the unevaluated original call to a DynTxRegime statistical method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Call(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Call_+3A_name">name</code></td>
<td>
<p>Object for which call is desired</p>
</td></tr>
<tr><td><code id="Call_+3A_...">...</code></td>
<td>
<p>Optional additional input required by R's base call().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>

<hr>
<h2 id='classif'>Retrieve Classification Regression Analysis</h2><span id='topic+classif'></span><span id='topic+classif+2COptimalClass-method'></span>

<h3>Description</h3>

<p>Method retrieves the value object returned by the user specified
classification regression modeling object(s). Exact structure of the 
returned object will vary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classif(object, ...)

## S4 method for signature 'OptimalClass'
classif(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classif_+3A_object">object</code></td>
<td>
<p>Value object returned from a method that uses classification
regression</p>
</td></tr>
<tr><td><code id="classif_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='ClassificationFit_fSet-class'>Class <code>ClassificationFit_fSet</code></h2><span id='topic+ClassificationFit_fSet-class'></span>

<h3>Description</h3>

<p>Class <code>ClassificationFit_fSet</code> contains a <code>TypedFit_fSet</code> object to
define a classification regression result when subsets are identified but
not modeled uniquely.
</p>

<hr>
<h2 id='ClassificationFit_fSet-methods'>Methods Available for Objects of Class <code>ClassificationFit_fSet</code></h2><span id='topic+ClassificationFit_fSet-methods'></span><span id='topic+classif+2CClassificationFit_fSet-method'></span><span id='topic+coef+2CClassificationFit_fSet-method'></span><span id='topic+fitObject+2CClassificationFit_fSet-method'></span><span id='topic+.predictAll+2CClassificationFit_fSet+2Cdata.frame-method'></span><span id='topic+summary+2CClassificationFit_fSet-method'></span>

<h3>Description</h3>

<p><code>.predictAll(object, newdata)</code>
predicts optimal treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClassificationFit_fSet'
classif(object, ...)

## S4 method for signature 'ClassificationFit_fSet'
coef(object, ...)

## S4 method for signature 'ClassificationFit_fSet'
fitObject(object, ...)

## S4 method for signature 'ClassificationFit_fSet,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'ClassificationFit_fSet'
summary(object, ...)
</code></pre>

<hr>
<h2 id='ClassificationFit_SubsetList-class'>Class <code>ClassificationFit_SubsetList</code></h2><span id='topic+ClassificationFit_SubsetList-class'></span>

<h3>Description</h3>

<p>Class <code>ClassificationFit_SubsetList</code> contains a 
<code>TypedFit_SubsetList</code> object to define classification regression
results when subsets are identified and modeled uniquely.
</p>

<hr>
<h2 id='ClassificationFit_SubsetList-methods'>Methods Available for Objects of Class <code>ClassificationFit_SubsetList</code></h2><span id='topic+ClassificationFit_SubsetList-methods'></span><span id='topic+classif+2CClassificationFit_SubsetList-method'></span><span id='topic+coef+2CClassificationFit_SubsetList-method'></span><span id='topic+fitObject+2CClassificationFit_SubsetList-method'></span><span id='topic+predict+2CClassificationFit_SubsetList-method'></span><span id='topic+.predictAll+2CClassificationFit_SubsetList+2Cdata.frame-method'></span><span id='topic+summary+2CClassificationFit_SubsetList-method'></span>

<h3>Description</h3>

<p><code>.predictAll(object, newdata)</code>
predicts optimal treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClassificationFit_SubsetList'
classif(object, ...)

## S4 method for signature 'ClassificationFit_SubsetList'
coef(object, ...)

## S4 method for signature 'ClassificationFit_SubsetList'
fitObject(object, ...)

## S4 method for signature 'ClassificationFit_SubsetList'
predict(object, ...)

## S4 method for signature 'ClassificationFit_SubsetList,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'ClassificationFit_SubsetList'
summary(object, ...)
</code></pre>

<hr>
<h2 id='ClassificationFit-class'>Class <code>ClassificationFit</code></h2><span id='topic+ClassificationFit-class'></span>

<h3>Description</h3>

<p>Class <code>ClassificationFit</code> combines a <code>TypedFit</code> object and a 
<code>TxInfoNoSubsets</code> object to define a classification regression result
when subsets are not identified.
</p>

<hr>
<h2 id='ClassificationFit-methods'>Methods Available for Objects of Class <code>ClassificationFit</code></h2><span id='topic+ClassificationFit-methods'></span><span id='topic+classif+2CClassificationFit-method'></span><span id='topic+coef+2CClassificationFit-method'></span><span id='topic+fitObject+2CClassificationFit-method'></span><span id='topic+plot+2CClassificationFit+2CANY-method'></span><span id='topic+predict+2CClassificationFit-method'></span><span id='topic+.predictAll+2CClassificationFit+2Cdata.frame-method'></span><span id='topic+print+2CClassificationFit-method'></span><span id='topic+show+2CClassificationFit-method'></span><span id='topic+summary+2CClassificationFit-method'></span>

<h3>Description</h3>

<p><code>.predictAll(object, newdata)</code>
predicts optimal treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClassificationFit'
classif(object, ...)

## S4 method for signature 'ClassificationFit'
coef(object, ...)

## S4 method for signature 'ClassificationFit'
fitObject(object, ...)

## S4 method for signature 'ClassificationFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'ClassificationFit'
predict(object, ...)

## S4 method for signature 'ClassificationFit,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'ClassificationFit'
print(x, ...)

## S4 method for signature 'ClassificationFit'
show(object)

## S4 method for signature 'ClassificationFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='ClassificationObj-class'>Class <code>ClassificationObj</code></h2><span id='topic+ClassificationObj-class'></span>

<h3>Description</h3>

<p>Stores classification regression results under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>classif</code></dt><dd><p>ANY - required to be NA, <code>ClassificationFit</code>, 
<code>ClassificationFit_fSet</code>, or <br /> <code>ClassificationFit_SubsetList</code>.</p>
</dd>
</dl>

<hr>
<h2 id='ClassificationObj-methods'>Methods Available for Objects of Class <code>ClassificationObj</code></h2><span id='topic+ClassificationObj-methods'></span><span id='topic+classif+2CClassificationObj-method'></span><span id='topic+coef+2CClassificationObj-method'></span><span id='topic+fitObject+2CClassificationObj-method'></span><span id='topic+plot+2CClassificationObj+2CANY-method'></span><span id='topic+predict+2CClassificationObj-method'></span><span id='topic+.predictAll+2CClassificationObj+2Cdata.frame-method'></span><span id='topic+print+2CClassificationObj-method'></span><span id='topic+show+2CClassificationObj-method'></span><span id='topic+summary+2CClassificationObj-method'></span>

<h3>Description</h3>

<p><code>.predictAll(object, newdata)</code>
predicts optimal treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ClassificationObj'
classif(object, ...)

## S4 method for signature 'ClassificationObj'
coef(object, ...)

## S4 method for signature 'ClassificationObj'
fitObject(object, ...)

## S4 method for signature 'ClassificationObj,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'ClassificationObj'
predict(object, ...)

## S4 method for signature 'ClassificationObj,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'ClassificationObj'
print(x, ...)

## S4 method for signature 'ClassificationObj'
show(object)

## S4 method for signature 'ClassificationObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='coef'>Extract Model Coefficients From Objects Returned by Modeling Functions</h2><span id='topic+coef'></span>

<h3>Description</h3>

<p>A list is returned, one element for each regression step required by
the statistical method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>Value object returned by any statistical method implemented
in DynTxRegime.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>Optional additional inputs defined by coefficient methods of 
selected regression functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>
<p>The exact structure of the returned list will vary depending on
the statistical method. 
For methods that include a propensity regression, the returned list will 
include an element named 'propen'. For methods that include an outcome 
regression, the returned list will include an element named 'outcome'.
</p>

<hr>
<h2 id='createearl'>Create method object for EARL</h2><span id='topic+createearl'></span><span id='topic+.createearl'></span>

<h3>Description</h3>

<p>Create method object for EARL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.createearl(kernel, txVec, response, prWgt, surrogate, guess = NULL, mu, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createearl_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="createearl_+3A_txvec">txVec</code></td>
<td>
<p>Vector of tx coded as -1/1</p>
</td></tr>
<tr><td><code id="createearl_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id="createearl_+3A_prwgt">prWgt</code></td>
<td>
<p>Vector of propensity for tx received</p>
</td></tr>
<tr><td><code id="createearl_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object indicating surrogate loss-function</p>
</td></tr>
<tr><td><code id="createearl_+3A_guess">guess</code></td>
<td>
<p>Vector of estimated regime parameters</p>
</td></tr>
<tr><td><code id="createearl_+3A_mu">mu</code></td>
<td>
<p>Matrix of outcome regression (zero/ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An .earl object
</p>

<hr>
<h2 id='createowl'>Create method object for Outcome Weighted Learning</h2><span id='topic+createowl'></span><span id='topic+.createowl'></span>

<h3>Description</h3>

<p>Create method object for Outcome Weighted Learning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.createowl(..., kernel, txVec, response, prWgt, surrogate, guess = NULL, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createowl_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="createowl_+3A_txvec">txVec</code></td>
<td>
<p>Vector of tx coded as -1/1</p>
</td></tr>
<tr><td><code id="createowl_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id="createowl_+3A_prwgt">prWgt</code></td>
<td>
<p>Vector of propensity for tx received</p>
</td></tr>
<tr><td><code id="createowl_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object indicating surrogate loss-function</p>
</td></tr>
<tr><td><code id="createowl_+3A_guess">guess</code></td>
<td>
<p>Vector of estimated regime parameters</p>
</td></tr>
<tr><td><code id="createowl_+3A_mu">mu</code></td>
<td>
<p>Matrix of outcome regression (zero/ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An .owl object
</p>

<hr>
<h2 id='createrwl'>Create method object for Residual Weighted Learning</h2><span id='topic+createrwl'></span><span id='topic+.createrwl'></span><span id='topic+.createrwlcount'></span>

<h3>Description</h3>

<p>Create method object for Residual Weighted Learning
</p>
<p>Create method object for Residual Weighted Learning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.createrwl(kernel, txVec, response, prWgt, surrogate, guess = NULL, mu, ...)

.createrwlcount(
  kernel,
  txVec,
  response,
  prWgt,
  surrogate,
  guess = NULL,
  mu,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createrwl_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="createrwl_+3A_txvec">txVec</code></td>
<td>
<p>Vector of tx coded as -1/1</p>
</td></tr>
<tr><td><code id="createrwl_+3A_response">response</code></td>
<td>
<p>Vector of responses</p>
</td></tr>
<tr><td><code id="createrwl_+3A_prwgt">prWgt</code></td>
<td>
<p>Vector of propensity for tx received</p>
</td></tr>
<tr><td><code id="createrwl_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object indicating surrogate loss-function</p>
</td></tr>
<tr><td><code id="createrwl_+3A_guess">guess</code></td>
<td>
<p>Vector of estimated regime parameters</p>
</td></tr>
<tr><td><code id="createrwl_+3A_mu">mu</code></td>
<td>
<p>Matrix of outcome regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>.rwl</code> object
</p>
<p>An <code>.rwl</code> object
</p>

<hr>
<h2 id='CVBasic-class'>Class <code>CVBasic</code></h2><span id='topic+CVBasic-class'></span>

<h3>Description</h3>

<p>Class <code>CVBasic</code> holds cross-validation procedure parameters
</p>


<h3>Slots</h3>


<dl>
<dt><code>folds</code></dt><dd><p>An integer</p>
</dd>
<dt><code>sample</code></dt><dd><p>A lsit</p>
</dd>
</dl>

<hr>
<h2 id='cvInfo'>Extract Cross-Validation Results</h2><span id='topic+cvInfo'></span>

<h3>Description</h3>

<p>Extract cross-validation results from the value object returned by a 
weighted learning statistical method of DynTxRegime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvInfo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvInfo_+3A_object">object</code></td>
<td>
<p>A value object returned by a weighted learning statistical 
method of DynTxRegime</p>
</td></tr>
<tr><td><code id="cvInfo_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are developed for all weighted learning methods implemented in
DynTxRegime. Specifically, OWL, RWL, BOWL, and EARL.
</p>

<hr>
<h2 id='CVInfo-class'>Class <code>CVInfo</code></h2><span id='topic+CVInfo-class'></span>

<h3>Description</h3>

<p>Class <code>CVInfo</code> holds cross-validation procedure results
</p>


<h3>Slots</h3>


<dl>
<dt><code>value</code></dt><dd><p>Values obtained for each parameter combination</p>
</dd>
<dt><code>params</code></dt><dd><p>list of parameter values considered</p>
</dd>
<dt><code>optimal</code></dt><dd><p>list of optimal parameter values</p>
</dd>
</dl>

<hr>
<h2 id='CVInfo-methods'>Methods Available for Objects of Class <code>CVInfo</code></h2><span id='topic+CVInfo-methods'></span><span id='topic+.getPars+2CCVInfo-method'></span><span id='topic+.getOptimal+2CCVInfo-method'></span><span id='topic+.getValue+2CCVInfo-method'></span><span id='topic+cvInfo+2CCVInfo-method'></span><span id='topic+print+2CCVInfo-method'></span><span id='topic+show+2CCVInfo-method'></span><span id='topic+summary+2CCVInfo-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>CVInfo</code>
</p>
<p><code>.getPars</code>
retrieves parameters considered in cross-validation.
</p>
<p><code>.getOptimal</code>
retrieves optimal parameters identified in cross-validation.
</p>
<p><code>.getValue</code>
retrieves values obtained in cross-validation.
</p>
<p><code>cvInfo</code>
retrieves cross-validation information.
</p>
<p><code>print</code>
print cross-validation results.
</p>
<p><code>show</code>
display cross-validation results.
</p>
<p><code>summary</code>
summarize cross-validation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CVInfo'
.getPars(object)

## S4 method for signature 'CVInfo'
.getOptimal(object)

## S4 method for signature 'CVInfo'
.getValue(object)

## S4 method for signature 'CVInfo'
cvInfo(object)

## S4 method for signature 'CVInfo'
print(x, ...)

## S4 method for signature 'CVInfo'
show(object)

## S4 method for signature 'CVInfo'
summary(object, ...)
</code></pre>

<hr>
<h2 id='CVInfo2Par-class'>Class <code>CVInfo2Par</code></h2><span id='topic+CVInfo2Par-class'></span>

<h3>Description</h3>

<p>Class <code>CVInfo2Par</code> holds information regarding cross-validation
procedure when multiple kernel parameters and tuning parameters are 
considered.
</p>


<h3>Slots</h3>


<dl>
<dt><code>value</code></dt><dd><p>Matrix of values at parameters considered</p>
</dd>
</dl>

<hr>
<h2 id='CVInfo2Par-methods'>Methods Available for Objects of Class <code>CVInfo2Par</code></h2><span id='topic+CVInfo2Par-methods'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>CVInfo2Par</code>
</p>

<hr>
<h2 id='CVInfokParam-class'>Class <code>CVInfokParam</code></h2><span id='topic+CVInfokParam-class'></span>

<h3>Description</h3>

<p>Class <code>CVInfokParam</code> holds information regarding cross-validation
procedure when only multiple kernel parameters values are considered.
</p>


<h3>Slots</h3>


<dl>
<dt><code>value</code></dt><dd><p>Array of values at parameters considered</p>
</dd>
</dl>

<hr>
<h2 id='CVInfokParam-methods'>Methods Available for Objects of Class <code>CVInfokParam</code></h2><span id='topic+CVInfokParam-methods'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>CVInfokParam</code>
</p>

<hr>
<h2 id='CVInfoLambda-class'>Class <code>CVInfoLambda</code></h2><span id='topic+CVInfoLambda-class'></span>

<h3>Description</h3>

<p>Class <code>CVInfoLambda</code> holds information regarding cross-validation
procedure when only multiple lambda values are considered.
</p>


<h3>Slots</h3>


<dl>
<dt><code>value</code></dt><dd><p>Array of values at tuning parameters considered</p>
</dd>
</dl>

<hr>
<h2 id='CVInfoLambda-methods'>Methods Available for Objects of Class <code>CVInfoLambda</code></h2><span id='topic+CVInfoLambda-methods'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>CVInfoLambda</code>
</p>

<hr>
<h2 id='CVInfoObj-class'>Class <code>CVInfoObj</code></h2><span id='topic+CVInfoObj-class'></span>

<h3>Description</h3>

<p>Class <code>CVInfoObj</code> holds information regarding cross-validation
procedure under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cvInfo</code></dt><dd><p>ANY expected to be CVInfo or NULL</p>
</dd>
</dl>

<hr>
<h2 id='CVInfoObj-methods'>Methods Available for Objects of Class <code>CVInfoObj</code></h2><span id='topic+CVInfoObj-methods'></span><span id='topic+.getPars+2CCVInfoObj-method'></span><span id='topic+.getOptimal+2CCVInfoObj-method'></span><span id='topic+.getValue+2CCVInfoObj-method'></span><span id='topic+cvInfo+2CCVInfoObj-method'></span><span id='topic+print+2CCVInfoObj-method'></span><span id='topic+show+2CCVInfoObj-method'></span><span id='topic+summary+2CCVInfoObj-method'></span>

<h3>Description</h3>

<p>Call methods equivalently named for object inheriting from CVInfo.
Methods dispached depend on object in @cvInfo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CVInfoObj'
.getPars(object)

## S4 method for signature 'CVInfoObj'
.getOptimal(object)

## S4 method for signature 'CVInfoObj'
.getValue(object)

## S4 method for signature 'CVInfoObj'
cvInfo(object)

## S4 method for signature 'CVInfoObj'
print(x, ...)

## S4 method for signature 'CVInfoObj'
show(object)

## S4 method for signature 'CVInfoObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='DecisionPointList-class'>Class <code>DecisionPointList</code></h2><span id='topic+DecisionPointList-class'></span><span id='topic+initialize+2CDecisionPointList-method'></span>

<h3>Description</h3>

<p>Class <code>DecisionListList</code> represents a <code>List</code> for decision points.
This class extends <code>List</code> to require non-zero length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecisionPointList'
initialize(.Object, ...)
</code></pre>

<hr>
<h2 id='DecisionPointList-methods'>Methods Available for Objects of Class <code>DecisionPointList</code></h2><span id='topic+DecisionPointList-methods'></span><span id='topic+plot+2CDecisionPointList+2CANY-method'></span><span id='topic+print+2CDecisionPointList-method'></span><span id='topic+show+2CDecisionPointList-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>DecisionPointList</code>
</p>
<p><code>plot(x,suppress)</code>
generates plots of the regression analysis for each decision point.
If suppress = FALSE, titles of plot will include the decision point
identifier.
</p>
<p><code>print(x)</code>
adds decision point information to print statements.
Each decision point is preceded by 'dp=x' where x is the decision point
number.
</p>
<p><code>show(object)</code>
adds decision point information to show statements.
Each decision point is preceded by 'dp=x' where x is the decision point
number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecisionPointList,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'DecisionPointList'
print(x, ...)

## S4 method for signature 'DecisionPointList'
show(object)
</code></pre>

<hr>
<h2 id='DTRstep'>Identify Statistical Method Used to Obtain Result</h2><span id='topic+DTRstep'></span>

<h3>Description</h3>

<p>Prints are displays a brief description of the statistical method used to
obtain the input object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTRstep(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTRstep_+3A_object">object</code></td>
<td>
<p>Value object returned by any statistical method of DynTxRegime</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>

<hr>
<h2 id='DynTxRegime-class'>Class <code>DynTxRegime</code></h2><span id='topic+DynTxRegime-class'></span>

<h3>Description</h3>

<p>Class <code>DynTxRegime</code> is a component of all statistical methods 
implemented in the package. This class contains the estimated optimal Tx, 
decision functions if applicable, the estimated value and the original 
unevaluated call. It extends internal class <code>OptimalObj</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>object of class call or NULL</p>
</dd>
</dl>

<hr>
<h2 id='DynTxRegime-internal-api'>Hidden methods</h2><span id='topic+DynTxRegime-internal-api'></span><span id='topic+tmp'></span><span id='topic+initialize+2CList-method'></span><span id='topic++5B+5B+3C-+2CList-method'></span><span id='topic++5B+5B+3C-+2CDecisionPointList-method'></span><span id='topic+.getDecisionPoint'></span><span id='topic+.getSubset'></span><span id='topic+initialize+2CSubsetList-method'></span><span id='topic++5B+5B+3C-+2CSubsetList-method'></span><span id='topic+plot+2CModelObj_SubsetList+2CANY-method'></span><span id='topic+plot+2CModelObj_DecisionPointList+2CANY-method'></span><span id='topic+.compareTx'></span><span id='topic+.convertFromBinary'></span><span id='topic+.convertToBinary'></span><span id='topic+.convertTx'></span><span id='topic+.getLevels'></span><span id='topic+.getSuperset'></span><span id='topic+.getTxName'></span><span id='topic+.validTx'></span><span id='topic+.getPtsSubset'></span><span id='topic+.getSingleton'></span><span id='topic+.getSubsetRule'></span><span id='topic+.getSubsets'></span><span id='topic+.getSubsetRule+2CANY-method'></span><span id='topic+.identifySubsets'></span><span id='topic+.identifySubsets+2Clist+2Cdata.frame-method'></span><span id='topic+.identifySubsets+2Clist+2Clist-method'></span><span id='topic+.identifySubsets+2CANY+2Cdata.frame-method'></span><span id='topic+.identifySubsets+2CANY+2Clist-method'></span><span id='topic+.identifySubsets+2CANY+2CANY-method'></span><span id='topic+initialize+2CTxInfoList-method'></span><span id='topic+.predictAll'></span><span id='topic+.predictMu'></span><span id='topic+Call+2CQLearn-method'></span><span id='topic+coef+2CQLearn-method'></span><span id='topic+DTRstep+2CQLearn-method'></span><span id='topic+estimator+2CQLearn-method'></span><span id='topic+fitObject+2CQLearn-method'></span><span id='topic+optTx+2CQLearn+2Cdata.frame-method'></span><span id='topic+optTx+2CQLearn+2Cmissing-method'></span><span id='topic+outcome+2CQLearn-method'></span><span id='topic+plot+2CQLearn+2Cmissing-method'></span><span id='topic+print+2CQLearn-method'></span><span id='topic+show+2CQLearn-method'></span><span id='topic+summary+2CQLearn-method'></span><span id='topic+DTRstep+2CIQLearnSS-method'></span><span id='topic+DTRstep+2CIQLearnFS_C-method'></span><span id='topic+DTRstep+2CIQLearnFS_ME-method'></span><span id='topic+DTRstep+2CIQLearnFS_VHet-method'></span><span id='topic+.getNumPars'></span><span id='topic+.getParNames'></span><span id='topic+.getPars'></span><span id='topic+.getRegimeFunction'></span><span id='topic+.predictOptimalTx'></span><span id='topic+.setPars'></span><span id='topic+Call+2COptimalSeq-method'></span><span id='topic+coef+2COptimalSeq-method'></span><span id='topic+DTRstep+2COptimalSeq-method'></span><span id='topic+estimator+2COptimalSeq-method'></span><span id='topic+fitObject+2COptimalSeq-method'></span><span id='topic+optTx+2COptimalSeq+2Cdata.frame-method'></span><span id='topic+optTx+2COptimalSeq+2Cmissing-method'></span><span id='topic+outcome+2COptimalSeq-method'></span><span id='topic+plot+2COptimalSeq+2Cmissing-method'></span><span id='topic+propen+2COptimalSeq-method'></span><span id='topic+regimeCoef+2COptimalSeq-method'></span><span id='topic+summary+2COptimalSeq-method'></span><span id='topic+Call+2COptimalClass-method'></span><span id='topic+coef+2COptimalClass-method'></span><span id='topic+DTRstep+2COptimalClass-method'></span><span id='topic+estimator+2COptimalClass-method'></span><span id='topic+fitObject+2COptimalClass-method'></span><span id='topic+optTx+2COptimalClass+2Cdata.frame-method'></span><span id='topic+optTx+2COptimalClass+2Cmissing-method'></span><span id='topic+outcome+2COptimalClass-method'></span><span id='topic+plot+2COptimalClass+2Cmissing-method'></span><span id='topic+propen+2COptimalClass-method'></span><span id='topic+summary+2COptimalClass-method'></span><span id='topic+initialize+2CKernel-method'></span><span id='topic+.getKernelX'></span><span id='topic+.kernel'></span><span id='topic+.kernelNumPars'></span><span id='topic+.dPhiFunc'></span><span id='topic+.optim'></span><span id='topic+.phiFunc'></span><span id='topic+.dobjFn'></span><span id='topic+.objFn'></span><span id='topic+.subsetObject'></span><span id='topic+.valueFunc'></span><span id='topic+.optimFunc'></span><span id='topic+initialize+2CCVBasic-method'></span><span id='topic+.getValue'></span><span id='topic+.getOptimal'></span><span id='topic+Call+2COWL-method'></span><span id='topic+coef+2COWL-method'></span><span id='topic+cvInfo+2COWL-method'></span><span id='topic+DTRstep+2COWL-method'></span><span id='topic+estimator+2COWL-method'></span><span id='topic+fitObject+2COWL-method'></span><span id='topic+optimObj+2COWL-method'></span><span id='topic+optTx+2COWL+2Cdata.frame-method'></span><span id='topic+optTx+2COWL+2Cmissing-method'></span><span id='topic+outcome+2COWL-method'></span><span id='topic+plot+2COWL+2Cmissing-method'></span><span id='topic+propen+2COWL-method'></span><span id='topic+regimeCoef+2COWL-method'></span><span id='topic+summary+2COWL-method'></span><span id='topic+Call+2CRWL-method'></span><span id='topic+coef+2CRWL-method'></span><span id='topic+cvInfo+2CRWL-method'></span><span id='topic+DTRstep+2CRWL-method'></span><span id='topic+estimator+2CRWL-method'></span><span id='topic+fitObject+2CRWL-method'></span><span id='topic+optimObj+2CRWL-method'></span><span id='topic+optTx+2CRWL+2Cdata.frame-method'></span><span id='topic+optTx+2CRWL+2Cmissing-method'></span><span id='topic+outcome+2CRWL-method'></span><span id='topic+plot+2CRWL+2Cmissing-method'></span><span id='topic+propen+2CRWL-method'></span><span id='topic+regimeCoef+2CRWL-method'></span><span id='topic+residuals+2CRWL-method'></span><span id='topic+summary+2CRWL-method'></span><span id='topic+.newBOWL'></span><span id='topic+Call+2CBOWL-method'></span><span id='topic+cvInfo+2CBOWL-method'></span><span id='topic+coef+2CBOWL-method'></span><span id='topic+DTRstep+2CBOWL-method'></span><span id='topic+estimator+2CBOWL-method'></span><span id='topic+fitObject+2CBOWL-method'></span><span id='topic+optimObj+2CBOWL-method'></span><span id='topic+optTx+2CBOWL+2Cdata.frame-method'></span><span id='topic+optTx+2CBOWL+2Cmissing-method'></span><span id='topic+outcome+2CBOWL-method'></span><span id='topic+plot+2CBOWL+2Cmissing-method'></span><span id='topic+propen+2CBOWL-method'></span><span id='topic+regimeCoef+2CBOWL-method'></span><span id='topic+summary+2CBOWL-method'></span><span id='topic+Call+2CEARL-method'></span><span id='topic+coef+2CEARL-method'></span><span id='topic+cvInfo+2CEARL-method'></span><span id='topic+DTRstep+2CEARL-method'></span><span id='topic+estimator+2CEARL-method'></span><span id='topic+fitObject+2CEARL-method'></span><span id='topic+optimObj+2CEARL-method'></span><span id='topic+optTx+2CEARL+2Cdata.frame-method'></span><span id='topic+optTx+2CEARL+2Cmissing-method'></span><span id='topic+outcome+2CEARL-method'></span><span id='topic+plot+2CEARL+2Cmissing-method'></span><span id='topic+propen+2CEARL-method'></span><span id='topic+regimeCoef+2CEARL-method'></span><span id='topic+summary+2CEARL-method'></span>

<h3>Description</h3>

<p>Hidden methods
</p>
<p>Retrieve the Decision Point to which modelObj Pertains
</p>
<p>Retrieve the Subset to which modelObj Pertains
</p>
<p>Constructor method of SubsetList Class
</p>
<p>Compare Equivalence of Provided Treatment Vectors
</p>
<p>Convert a -1/1 Tx to User Provided Tx
</p>
<p>Convert a User Provided Tx Variable to Binary -1/1
</p>
<p>Convert Provided Treatment Vector to Appropriate Class
</p>
<p>Get Treatment Levels
</p>
<p>Retrieve Superset
</p>
<p>Retrieve Treatment Variable Name
</p>
<p>Ensure Validity of Provided Treatment Vector
</p>
<p>Make Predictions for all Treatments.
</p>
<p>Make Predictions for all Treatments.
</p>
<p>Uses .predictAll() defined for OutcomeObj objects
</p>
<p>Uses optTx defined for DynTxRegime objects
</p>
<p>Print Q-Learning Information
</p>
<p>Show Q-Learning Information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmp(x)

## S4 method for signature 'List'
initialize(.Object, ...)

## S4 replacement method for signature 'List'
x[[i]] &lt;- value

## S4 replacement method for signature 'DecisionPointList'
x[[i]] &lt;- value

.getDecisionPoint(object)

.getSubset(object)

## S4 method for signature 'SubsetList'
initialize(.Object, ...)

## S4 replacement method for signature 'SubsetList'
x[[i]] &lt;- value

## S4 method for signature 'ModelObj_SubsetList,ANY'
plot(x, y, ...)

## S4 method for signature 'ModelObj_DecisionPointList,ANY'
plot(x, y, ...)

.compareTx(object, vec1, vec2)

.convertFromBinary(txObj, ...)

.convertToBinary(txObj, ...)

.convertTx(object, txVec)

.getLevels(object, txVec)

.getSuperset(object)

.getTxName(object)

.validTx(object, txVec)

.getPtsSubset(object)

.getSingleton(object)

.getSubsetRule(object)

.getSubsets(object)

## S4 method for signature 'ANY'
.getSubsetRule(object)

.identifySubsets(fSetResult, input, ...)

## S4 method for signature 'list,data.frame'
.identifySubsets(fSetResult, input, ..., fSet)

## S4 method for signature 'list,list'
.identifySubsets(fSetResult, input, ..., fSet)

## S4 method for signature 'ANY,data.frame'
.identifySubsets(fSetResult, input, ..., fSet)

## S4 method for signature 'ANY,list'
.identifySubsets(fSetResult, input, ..., fSet)

## S4 method for signature 'ANY,ANY'
.identifySubsets(fSetResult, input, ..., fSet)

## S4 method for signature 'TxInfoList'
initialize(.Object, ...)

.predictAll(object, newdata, ...)

.predictMu(object, data, ...)

## S4 method for signature 'QLearn'
Call(name, ...)

## S4 method for signature 'QLearn'
coef(object, ...)

## S4 method for signature 'QLearn'
DTRstep(object)

## S4 method for signature 'QLearn'
estimator(x, ...)

## S4 method for signature 'QLearn'
fitObject(object, ...)

## S4 method for signature 'QLearn,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'QLearn,missing'
optTx(x, newdata, ...)

## S4 method for signature 'QLearn'
outcome(object, ...)

## S4 method for signature 'QLearn,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'QLearn'
print(x, ...)

## S4 method for signature 'QLearn'
show(object)

## S4 method for signature 'QLearn'
summary(object, ...)

## S4 method for signature 'IQLearnSS'
DTRstep(object)

## S4 method for signature 'IQLearnFS_C'
DTRstep(object)

## S4 method for signature 'IQLearnFS_ME'
DTRstep(object)

## S4 method for signature 'IQLearnFS_VHet'
DTRstep(object)

.getNumPars(object)

.getParNames(object)

.getPars(object)

.getRegimeFunction(object)

.predictOptimalTx(x, newdata, ...)

.setPars(object, pars)

## S4 method for signature 'OptimalSeq'
Call(name, ...)

## S4 method for signature 'OptimalSeq'
coef(object, ...)

## S4 method for signature 'OptimalSeq'
DTRstep(object)

## S4 method for signature 'OptimalSeq'
estimator(x, ...)

## S4 method for signature 'OptimalSeq'
fitObject(object, ...)

## S4 method for signature 'OptimalSeq,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalSeq,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalSeq'
outcome(object, ...)

## S4 method for signature 'OptimalSeq,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'OptimalSeq'
propen(object, ...)

## S4 method for signature 'OptimalSeq'
regimeCoef(object, ...)

## S4 method for signature 'OptimalSeq'
summary(object, ...)

## S4 method for signature 'OptimalClass'
Call(name, ...)

## S4 method for signature 'OptimalClass'
coef(object, ...)

## S4 method for signature 'OptimalClass'
DTRstep(object)

## S4 method for signature 'OptimalClass'
estimator(x, ...)

## S4 method for signature 'OptimalClass'
fitObject(object, ...)

## S4 method for signature 'OptimalClass,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalClass,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalClass'
outcome(object, ...)

## S4 method for signature 'OptimalClass,missing'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OptimalClass'
propen(object, ...)

## S4 method for signature 'OptimalClass'
summary(object, ...)

## S4 method for signature 'Kernel'
initialize(.Object, data, model, kparam, ...)

.getKernelX(data, object, ...)

.kernel(object, x1, x2, ...)

.kernelNumPars(object, ...)

.dPhiFunc(surrogate, ...)

.optim(surrogate, ...)

.phiFunc(surrogate, ...)

.dobjFn(par, methodObject, kernel, ...)

.objFn(par, methodObject, kernel, ...)

.subsetObject(methodObject, ...)

.valueFunc(methodObject, ...)

.optimFunc(methodObject, ...)

## S4 method for signature 'CVBasic'
initialize(.Object, cvFolds, txVec, ...)

.getValue(object)

.getOptimal(object)

## S4 method for signature 'OWL'
Call(name, ...)

## S4 method for signature 'OWL'
coef(object, ...)

## S4 method for signature 'OWL'
cvInfo(object, ...)

## S4 method for signature 'OWL'
DTRstep(object)

## S4 method for signature 'OWL'
estimator(x, ...)

## S4 method for signature 'OWL'
fitObject(object, ...)

## S4 method for signature 'OWL'
optimObj(object, ...)

## S4 method for signature 'OWL,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'OWL,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OWL'
outcome(object, ...)

## S4 method for signature 'OWL,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'OWL'
propen(object, ...)

## S4 method for signature 'OWL'
regimeCoef(object, ...)

## S4 method for signature 'OWL'
summary(object, ...)

## S4 method for signature 'RWL'
Call(name, ...)

## S4 method for signature 'RWL'
coef(object, ...)

## S4 method for signature 'RWL'
cvInfo(object, ...)

## S4 method for signature 'RWL'
DTRstep(object)

## S4 method for signature 'RWL'
estimator(x, ...)

## S4 method for signature 'RWL'
fitObject(object, ...)

## S4 method for signature 'RWL'
optimObj(object, ...)

## S4 method for signature 'RWL,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'RWL,missing'
optTx(x, newdata, ...)

## S4 method for signature 'RWL'
outcome(object, ...)

## S4 method for signature 'RWL,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'RWL'
propen(object, ...)

## S4 method for signature 'RWL'
regimeCoef(object, ...)

## S4 method for signature 'RWL'
residuals(object, ...)

## S4 method for signature 'RWL'
summary(object, ...)

.newBOWL(BOWLObj, ...)

## S4 method for signature 'BOWL'
Call(name, ...)

## S4 method for signature 'BOWL'
cvInfo(object, ...)

## S4 method for signature 'BOWL'
coef(object, ...)

## S4 method for signature 'BOWL'
DTRstep(object)

## S4 method for signature 'BOWL'
estimator(x, ...)

## S4 method for signature 'BOWL'
fitObject(object, ...)

## S4 method for signature 'BOWL'
optimObj(object, ...)

## S4 method for signature 'BOWL,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'BOWL,missing'
optTx(x, newdata, ...)

## S4 method for signature 'BOWL'
outcome(object, ...)

## S4 method for signature 'BOWL,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'BOWL'
propen(object, ...)

## S4 method for signature 'BOWL'
regimeCoef(object, ...)

## S4 method for signature 'BOWL'
summary(object, ...)

## S4 method for signature 'EARL'
Call(name, ...)

## S4 method for signature 'EARL'
coef(object, ...)

## S4 method for signature 'EARL'
cvInfo(object, ...)

## S4 method for signature 'EARL'
DTRstep(object)

## S4 method for signature 'EARL'
estimator(x, ...)

## S4 method for signature 'EARL'
fitObject(object, ...)

## S4 method for signature 'EARL'
optimObj(object, ...)

## S4 method for signature 'EARL,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'EARL,missing'
optTx(x, newdata, ...)

## S4 method for signature 'EARL'
outcome(object, ...)

## S4 method for signature 'EARL,missing'
plot(x, y, suppress = FALSE, ...)

## S4 method for signature 'EARL'
propen(object, ...)

## S4 method for signature 'EARL'
regimeCoef(object, ...)

## S4 method for signature 'EARL'
summary(object, ...)
</code></pre>

<hr>
<h2 id='DynTxRegime-methods'>Methods Available for Objects of Class <code>DynTxRegime</code></h2><span id='topic+DynTxRegime-methods'></span><span id='topic+Call+2CDynTxRegime-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>DynTxRegime</code>
</p>
<p><code>Call(name)</code>
retrieves the unevaluated call to the original statistical method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DynTxRegime'
Call(name, ...)
</code></pre>

<hr>
<h2 id='earl'>Efficient Augmentation and Relaxation Learning</h2><span id='topic+earl'></span>

<h3>Description</h3>

<p>Efficient Augmentation and Relaxation Learning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earl(
  ...,
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regime,
  iter = 0L,
  fSet = NULL,
  lambdas = 0.5,
  cvFolds = 0L,
  surrogate = "hinge",
  kernel = "linear",
  kparam = NULL,
  verbose = 2L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="earl_+3A_...">...</code></td>
<td>
<p>Used primarily to require named input. However, inputs for
the optimization methods can be sent through the ellipsis. If surrogate
is hinge, the optimization method is dfoptim::hjk(). For all other 
surrogates, stats::optim() is used.</p>
</td></tr>
<tr><td><code id="earl_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the propensity for treatment.
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="earl_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the main effects of the outcome.
See ?modelObj for details.</p>
</td></tr>
<tr><td><code id="earl_+3A_mocont">moCont</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the contrasts of the outcome.
See ?modelObj for details.</p>
</td></tr>
<tr><td><code id="earl_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx histories</p>
</td></tr>
<tr><td><code id="earl_+3A_response">response</code></td>
<td>
<p>The response variable.</p>
</td></tr>
<tr><td><code id="earl_+3A_txname">txName</code></td>
<td>
<p>A character object.
The column header of <em>data</em> that corresponds to the tx covariate</p>
</td></tr>
<tr><td><code id="earl_+3A_regime">regime</code></td>
<td>
<p>A formula object or a list of formula objects.
The covariates to be included in classification. If a list is provided,
this specifies that there is an underlying subset structure &ndash; fSet must
then be defined.</p>
</td></tr>
<tr><td><code id="earl_+3A_iter">iter</code></td>
<td>
<p>Maximum number of iterations for outcome regression</p>
</td></tr>
<tr><td><code id="earl_+3A_fset">fSet</code></td>
<td>
<p>A function or NULL defining subset structure</p>
</td></tr>
<tr><td><code id="earl_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric object or a numeric vector object giving the
penalty tuning parameter. If more than 1 is provided,
the finite set of values to be considered in the
cross-validation algorithm</p>
</td></tr>
<tr><td><code id="earl_+3A_cvfolds">cvFolds</code></td>
<td>
<p>If cross-validation is to be used to select the tuning
parameters, the number of folds.</p>
</td></tr>
<tr><td><code id="earl_+3A_surrogate">surrogate</code></td>
<td>
<p>The surrogate 0-1 loss function must be one of
logit, exp, hinge, sqhinge, huber</p>
</td></tr>
<tr><td><code id="earl_+3A_kernel">kernel</code></td>
<td>
<p>A character object.
must be one of {&quot;linear&quot;, &quot;poly&quot;, &quot;radial&quot;}</p>
</td></tr>
<tr><td><code id="earl_+3A_kparam">kparam</code></td>
<td>
<p>A numeric object of NULL.
If kernel = linear, kparam is ignored.
If kernel = poly, kparam is the degree of the polynomial
If kernel = radial, kparam is the inverse bandwidth of the
kernel. If a vector of bandwidth parameters is given,
cross-validation will be used to select the parameter</p>
</td></tr>
<tr><td><code id="earl_+3A_verbose">verbose</code></td>
<td>
<p>An integer or logical. If 0, no screen prints are generated. If 1,
screen prints are generated with the exception of optimization results
obtained in iterative algorithm. If 2, all screen prints are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an EARL object
</p>


<h3>References</h3>

<p>Ying-Qi Zhao, Eric Laber, Sumona Saha and Bruce E. Sands
(2016+)
Efficient augmentation and relaxation learning for treatment
regimes using observational data
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other weighted learning methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# propensity model
moPropen &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                          solver.method = 'glm',
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

fitEARL &lt;- earl(moPropen = moPropen, moMain = moMain, moCont = moCont,
              data = bmiData, response = y12,  txName = 'A2', 
              regime = ~ parentBMI + month4BMI,
              surrogate = 'logit', kernel = 'poly', kparam = 2)

##Available methods

  # Coefficients of the regression objects
  coef(fitEARL)

  # Description of method used to obtain object
  DTRstep(fitEARL)

  # Estimated value of the optimal treatment regime for training set
  estimator(fitEARL)

  # Value object returned by regression methods
  fitObject(fitEARL)

  # Summary of optimization routine
  optimObj(fitEARL)

  # Estimated optimal treatment for training data
  optTx(fitEARL)

  # Estimated optimal treatment for new data
  optTx(fitEARL, bmiData)

  # Value object returned by outcome regression method
  outcome(fitEARL)

  # Plots if defined by regression methods
  dev.new()
  par(mfrow = c(2,4))

  plot(fitEARL)
  plot(fitEARL, suppress = TRUE)

  # Value object returned by propensity score regression method
  propen(fitEARL)

  # Parameter estimates for decision function
  regimeCoef(fitEARL)

  # Show main results of method
  show(fitEARL)

  # Show summary results of method
  summary(fitEARL)
 
</code></pre>

<hr>
<h2 id='EARL-class'>Class <code>EARL</code></h2><span id='topic+EARL-class'></span>

<h3>Description</h3>

<p>Class <code>EARL</code> contains results for an EARL analysis.
</p>


<h3>Slots</h3>


<dl>
<dt><code>analysis</code></dt><dd><p>Contains a Learning or LearningMulti object.</p>
</dd>
<dt><code>analysis@txInfo</code></dt><dd><p>Feasible tx information.</p>
</dd>
<dt><code>analysis@propen</code></dt><dd><p>Propensity regression analysis.</p>
</dd>
<dt><code>analysis@outcome</code></dt><dd><p>Outcome regression analysis.</p>
</dd>
<dt><code>analysis@cvInfo</code></dt><dd><p>Cross-validation analysis if single regime.</p>
</dd>
<dt><code>analysis@optim</code></dt><dd><p>Optimization analysis if single regime.</p>
</dd>
<dt><code>analysis@optimResult</code></dt><dd><p>list of cross-validation and optimization results
if multiple regimes. optimResult[[i]]@cvInfo and optimResult[[i]]@optim.</p>
</dd>
<dt><code>analysis@optimal</code></dt><dd><p>Estimated optimal Tx and value.</p>
</dd>
<dt><code>analysis@call</code></dt><dd><p>Unevaluated call to statistical method.</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Post-Processing of Optimization Analysis</h3>


<dl>
<dt>cvInfo</dt><dd><p>: 
Retrieve cross-validation results.  </p>
</dd>
<dt>optimObj</dt><dd><p>: 
Retrieve value object returned by optimization method(s).  </p>
</dd>
<dt>regimeCoef</dt><dd><p>: 
Retrieve estimated parameters for optimal tx regime.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='EARL-methods'>Methods Available for Objects of Class <code>EARL</code></h2><span id='topic+EARL-methods'></span><span id='topic+print+2CEARL-method'></span><span id='topic+show+2CEARL-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>EARL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EARL'
print(x, ...)

## S4 method for signature 'EARL'
show(object)
</code></pre>

<hr>
<h2 id='estimator'>Retrieve the Estimated Value</h2><span id='topic+estimator'></span><span id='topic+estimator+2CIQLearnFS-method'></span><span id='topic+estimator+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Retrieve the value as estimated by the statistical method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimator(x, ...)

## S4 method for signature 'IQLearnFS'
estimator(x, w = NULL, y = NULL, z = NULL, dens = NULL)

## S4 method for signature 'IQLearnSS'
estimator(x, w = NULL, y = NULL, z = NULL, dens = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimator_+3A_x">x</code></td>
<td>
<p>a DynTxRegime Object.</p>
</td></tr>
<tr><td><code id="estimator_+3A_...">...</code></td>
<td>
<p>Optional additional input. Ignored.</p>
</td></tr>
<tr><td><code id="estimator_+3A_w">w</code></td>
<td>
<p>If IQ-Learning, object of class IQLearnSS, IQLearnFS_C, 
IQLearnFS_ME, or IQLearnFS_VHet</p>
</td></tr>
<tr><td><code id="estimator_+3A_y">y</code></td>
<td>
<p>If IQ-Learning, object of class IQLearnSS, IQLearnFS_C, 
IQLearnFS_ME, or IQLearnFS_VHet</p>
</td></tr>
<tr><td><code id="estimator_+3A_z">z</code></td>
<td>
<p>If IQ-Learning, object of class IQLearnSS, IQLearnFS_C, 
IQLearnFS_ME, or IQLearnFS_VHet</p>
</td></tr>
<tr><td><code id="estimator_+3A_dens">dens</code></td>
<td>
<p>If IQ-Learning, one of {&quot;norm&quot;, &quot;nonpar&quot;}</p>
</td></tr>
</table>

<hr>
<h2 id='ExpSurrogate-class'>Class <code>ExpSurrogate</code></h2><span id='topic+ExpSurrogate-class'></span>

<h3>Description</h3>

<p>Exponential surrogate for 0/1 loss.
</p>

<hr>
<h2 id='ExpSurrogate-methods'>Methods Available for Objects of Class <code>ExpSurrogate</code></h2><span id='topic+ExpSurrogate-methods'></span><span id='topic+.phiFunc+2CExpSurrogate-method'></span><span id='topic+.dPhiFunc+2CExpSurrogate-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>ExpSurrogate</code>
</p>
<p><code>.phiFunc</code>
calculates exponential surrogate loss-function
</p>
<p><code>.dphiFunc</code>
calculates derivative of exponential surrogate loss-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ExpSurrogate'
.phiFunc(surrogate, u)

## S4 method for signature 'ExpSurrogate'
.dPhiFunc(surrogate, u, du)
</code></pre>

<hr>
<h2 id='fitObject'>Objects Returned by Modeling Functions</h2><span id='topic+fitObject'></span>

<h3>Description</h3>

<p>Returns a list of the objects returned by all modeling functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitObject(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitObject_+3A_object">object</code></td>
<td>
<p>Value object returned by a statistical method of DynTxRegime</p>
</td></tr>
<tr><td><code id="fitObject_+3A_...">...</code></td>
<td>
<p>Optional additional inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>
<p>The exact structure of the returned list will vary depending on
the statistical method. 
For methods that include a propensity regression, the returned list will 
include an element named 'propen'. For methods that include an outcome 
regression, the returned list will include an element named 'outcome'.
</p>

<hr>
<h2 id='fittedCont'>Retrieve the Fitted Contrast Component from Second Stage IQ-Learning</h2><span id='topic+fittedCont'></span><span id='topic+fittedCont+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Extracts the contrasts component of the fitted outcome regression
the second-stage analysis of the interactive Q-Learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fittedCont(object, ...)

## S4 method for signature 'IQLearnSS'
fittedCont(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fittedCont_+3A_object">object</code></td>
<td>
<p>An object of class IQLearnSS</p>
</td></tr>
<tr><td><code id="fittedCont_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='fittedMain'>Retrieve the Fitted Main Effects Component from Second Stage IQ-Learning</h2><span id='topic+fittedMain'></span><span id='topic+fittedMain+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Extracts the main effects component of the fitted outcome regression for
the second-stage analysis of the interactive Q-Learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fittedMain(object, ...)

## S4 method for signature 'IQLearnSS'
fittedMain(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fittedMain_+3A_object">object</code></td>
<td>
<p>An object of class IQLearnSS</p>
</td></tr>
<tr><td><code id="fittedMain_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='fSet'>Defining the fSet Input Variable</h2><span id='topic+fSet'></span>

<h3>Description</h3>

<p>Several of the statistical methods implemented in package
<span class="pkg">DynTxRegime</span> allow for subset modeling or limiting
of feasible treatment options. This section details how this
input is to be defined.
</p>


<h3>Details</h3>

<p>In general, input <code>fSet</code> is used to define subsets of patients 
within an analysis. These subsets can be specified to (1) limit 
available treatments, (2) use different models for the propensity 
score and/or outcome regressions, and/or 
(3) use different decision function models for 
each subset of patients. The combination of inputs <code>moPropen</code>,
<code>moMain</code>, <code>moCont</code>, <code>fSet</code>, and/or <code>regimes</code> 
determines which of these scenarios is 
being considered. We cover some common situations below.
</p>
<p>Regardless of the purpose for specifying <code>fSet</code>, it must be a 
function that returns a list. There are two options for defining the 
function. Version 1 is that of the original <span class="pkg">DynTxRegime</span> package. 
In this version, <code>fSet</code> defines the rules
for determining the subset of treatment options for an INDIVIDUAL.
The first element of the returned list is a character, which we term
the subset 'nickname.' This nickname is for bookkeeping purposes 
and is used to link models to subsets. The second element 
of the returned list is a vector 
of available treatment options for the subset. The formal arguments of 
the function must include (i) 'data' or (ii) individual covariate 
names as given by the column headers of <code>data</code>. An example using the 
covariate name input form is
</p>
<pre>
fSet &lt;- function(a1) {
  if (a1 &gt; 1) {
    subset &lt;- list('subA',c(1,2))
  } else {
    subset &lt;- list('subB',c(3,4) )
  }
  return(subset)
}</pre>
<p>This function indicates that if an individual has covariate a1 &gt; 1, 
they are a member of subset 'subA' and their feasible
treatment options are {1,2}. If a1 &lt;= 1, they are a member of subset
'subB' and their feasible treatment options are {3,4}.
</p>
<p>A more efficient implementation for <code>fSet</code> is now accepted. In
the second form, <code>fSet</code> defines the subset of treatment options
for the full DATASET. It is again a function with
formal arguments  (i) 'data' or (ii) individual covariate names as 
given by the column headers of <code>data</code>. The function returns a list 
containing two elements: 'subsets' and 'txOpts.'  Element 'subsets' is 
a list comprising all treatment subsets; each element of the list contains 
the nickname and treatment options for a single subset. Element
'txOpts' is a character vector indicating the subset of which
each individual is a member. In this new format, 
the equivalent definition of <code>fSet</code> as that given above is:
</p>
<pre>
fSet &lt;- function(a1) {
  subsets &lt;- list(list('subA', c(1,2)),
                  list('subB', c(3,4)))
  txOpts &lt;- rep('subB', length(x = a1))
  txOpts[a1 &gt; 1] &lt;- 'subA'

  return(list("subsets" = subsets,
              "txOpts" = txOpts))
}</pre>
<p>Though a bit more complicated, this version is much more efficient as
it processes the entire dataset at once rather than each individual 
separately.
</p>
<p>The simplest scenario involving <code>fSet</code> is to define feasible 
treatment options and the rules that dictate how those treatment 
options are determined. For example, 
responder/non-responder scenarios are often encountered in
multiple-decision-point settings. An example of this scenario is:
patients that respond to the first stage treatment
remain on the original treatment; those that
do not respond to the first stage treatment
have all treatment options available to them at the second stage. 
In this case, the 
propensity score models for the second stage
are fit using only 'non-responders' for whom 
more than 1 treatment option is available. 
</p>
<p>An example of an appropriate <code>fSet</code> function for
the second-stage is
</p>
<pre> 
fSet &lt;- function(data) { 
   if (data\$responder  == 0L) { 
     subset &lt;- list('subA',c(1L,2L))
   } else if (data\$tx1 == 1L) { 
     subset &lt;- list('subB',c(1L) )
   } else if (data\$tx1 == 2L) { 
     subset &lt;- list('subC',c(2L) )
   } 
   return(subset) 
} </pre>
<p>for version 1 or for version 2
</p>
<pre>
fSet &lt;- function(data) {
  subsets &lt;- list(list('subA', c(1L,2L)),
                  list('subB', c(1L)),
                  list('subC', c(2L)))
  txOpts &lt;- character(nrow(x = data))
  txOpts[data$tx1 == 1L] &lt;- 'subB'
  txOpts[data$tx1 == 2L] &lt;- 'subC'
  txOpts[data$responder == 0L] &lt;- 'subA'

  return(list("subsets" = subsets,
              "txOpts" = txOpts))
}</pre>
<p>The functions above specify that patients with covariate responder = 0 
receive treatments from subset 'subA,' which comprises treatments 
A = (1,2). Patients with covariate responder = 1 receive treatment 
from subset 'subB' or 'subC' depending on the first stage treatment
received. If
<code>fSet</code> is specified in this way, the form of the model object depends
on the training data. Specifically, if the training data obeys the feasible
treatment rule (here, all individuals with responder = 1 received tx
in accordance with fSet), <code>moPropen</code> would be a <code>"modelObj"</code>;
the propensity model will be fit using only those patients with 
responder = 0; those with responder = 1 always receive the appropriate
second stage treatment with probability 1.0. However, if the data
are from an observation study and the training data do not obey the
feasible treatment rules (here, some individuals with responder = 1 received 
tx = 0; others tx = 1), the responder = 1 data must be modeled and moPropen
must be provided as one or more ModelObjSubset() objects.
</p>
<p>If outcome regression is used by the method,
<code>moMain</code> and <code>moCont</code> can be either objects
of class <code>"modelObj"</code> if only responder = 0 patients are to be used
to obtain parameter estimates or as lists of objects of class 
<code>"ModelObjSubset"</code> if subsets are to be analyzed individually or
combined for a single fit of all data.
</p>
<p>For a scenario where all patients have the same set of treatment
options available, but subsets of patients are to be analyzed using 
different models. We cane define <code>fSet</code> as
</p>
<pre> 
fSet &lt;- function(data) { 
   if (data\$a1 == 1) { 
     subset &lt;- list('subA',c(1L,2L))
   } else { 
     subset &lt;- list('subB',c(1L,2L) )
   } 
   return(subset) 
} </pre>
<p>for version 1 or in the format of version 2
</p>
<pre>
fSet &lt;- function(data)
{
  subsets &lt;- list(list('subA', c(1L,2L)),
                  list('subB', c(1L,2L)))
  txOpts &lt;- rep('subB', nrow(x = data))
  txOpts[data$a1 == 1L] &lt;- 'subA'

  return(list("subsets" = subsets,
              "txOpts" = txOpts))
}</pre>
<p>where all patients have the same treatment options available, A = (1,2),
but different regression models will be fit for each subset (case 2 above) 
and/or different decision function models (case 3 above) for each
subset. If different propensity score models are used, <code>moPropen</code> 
must be a list of objects of class <code>"modelObjSubset."</code>
Perhaps,
</p>
<pre> 
  propenA &lt;- buildModelObjSubset(model = ~1,
                                 solver.method = 'glm',
                                 solver.args = list('family'='binomial'),
                                 predict.method = 'predict.glm',
                                 predict.args = list(type='response'),
                                 subset = 'subA')

  propenB &lt;- buildModelObjSubset(model = ~1,
                                 solver.method = 'glm',
                                 solver.args = list('family'='binomial'),
                                 predict.method = 'predict.glm',
                                 predict.args = list(type='response'),
                                 subset = 'subB')

  moPropen &lt;- list(propenA, propenB)
 </pre>
<p>If different decision function models are to be fit, <code>regimes</code>
would take a form similar to
</p>
<pre> 
  regimes &lt;- list( 'subA' = ~x1 + x2,
                   'subB' = ~x2 )
</pre>
<p>Notice that the names of the elements of <code>regimes</code> and the subsets passed to
buildModelObjSubset() correspond to the names defined by <code>fSet</code>,
i.e., 'subA' or 'subB.' These nicknames are used for bookkeeping and 
link subsets to the appropriate models.
</p>
<p>For a single-decision-point analysis, <code>fSet</code>
is a single function. For multiple-decision-point analyses,
<code>fSet</code> is a list of functions where each element of 
the list corresponds to the decision point (1st element &lt;-
1st decision point, etc.)
</p>

<hr>
<h2 id='genetic'>Retrieve the Genetic Algorithm Results</h2><span id='topic+genetic'></span><span id='topic+genetic+2COptimalSeq-method'></span>

<h3>Description</h3>

<p>Retrieve the value object returned by rgenoud() in optimalSeq().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genetic(object, ...)

## S4 method for signature 'OptimalSeq'
genetic(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genetic_+3A_object">object</code></td>
<td>
<p>Value object returned by optimalSeq()</p>
</td></tr>
<tr><td><code id="genetic_+3A_...">...</code></td>
<td>
<p>Optional inputs. Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='getOutcome'>Retrieve Outcome for Both Tx Options When Tx is Binary</h2><span id='topic+getOutcome'></span><span id='topic+.getOutcome'></span><span id='topic+.getOutcome2'></span>

<h3>Description</h3>

<p>Retrieve Outcome for Both Tx Options When Tx is Binary
</p>
<p>Retrieve Outcome for Both Tx Options When Tx is Binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getOutcome(outcomeObj, txObj, data)

.getOutcome2(outcomeObj, txObj, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutcome_+3A_outcomeobj">outcomeObj</code></td>
<td>
<p>a OutcomeObj</p>
</td></tr>
<tr><td><code id="getOutcome_+3A_txobj">txObj</code></td>
<td>
<p>a TxObj</p>
</td></tr>
<tr><td><code id="getOutcome_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of outcome under binary tx.
</p>
<p>matrix of outcome under binary tx.
</p>

<hr>
<h2 id='getPrWgt'>Retrieve Propensity for Tx Received</h2><span id='topic+getPrWgt'></span><span id='topic+.getPrWgt'></span>

<h3>Description</h3>

<p>Retrieve Propensity for Tx Received
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getPrWgt(propenObj, txObj, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPrWgt_+3A_propenobj">propenObj</code></td>
<td>
<p>a PropensityObj</p>
</td></tr>
<tr><td><code id="getPrWgt_+3A_txobj">txObj</code></td>
<td>
<p>a TxObj</p>
</td></tr>
<tr><td><code id="getPrWgt_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of propensity for tx received.
</p>

<hr>
<h2 id='HingeSurrogate-class'>Class <code>HingeSurrogate</code></h2><span id='topic+HingeSurrogate-class'></span>

<h3>Description</h3>

<p>Hinge surrogate for 0/1 loss function.
</p>

<hr>
<h2 id='HingeSurrogate-methods'>Methods Available for Objects of Class <code>HingeSurrogate</code></h2><span id='topic+HingeSurrogate-methods'></span><span id='topic+.phiFunc+2CHingeSurrogate-method'></span><span id='topic+.dPhiFunc+2CHingeSurrogate-method'></span><span id='topic+.optim+2CHingeSurrogate-method'></span>

<h3>Description</h3>

<p>Utilizes dfoptim::hjk to obtain parameter estimates. Requires that
the objective function be defined by the calling learning method.
Returns NULL if optimization is not successful due to problems or
the list object returned by dfoptim::hjk if optimization is successful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HingeSurrogate'
.phiFunc(surrogate, u)

## S4 method for signature 'HingeSurrogate'
.dPhiFunc(surrogate, u, du)

## S4 method for signature 'HingeSurrogate'
.optim(surrogate, par, lambda, fn, gr, suppress, ...)
</code></pre>

<hr>
<h2 id='HuberHingeSurrogate-class'>Class <code>HuberHingeSurrogate</code></h2><span id='topic+HuberHingeSurrogate-class'></span>

<h3>Description</h3>

<p>Huberized hinge surrogate for 0/1 loss function.
</p>

<hr>
<h2 id='HuberHingeSurrogate-methods'>Methods Available for Objects of Class <code>HuberHingeSurrogate</code></h2><span id='topic+HuberHingeSurrogate-methods'></span><span id='topic+.phiFunc+2CHuberHingeSurrogate-method'></span><span id='topic+.dPhiFunc+2CHuberHingeSurrogate-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>HuberHingeSurrogate</code>
</p>
<p><code>.phiFunc</code>
calculates huberized hinge surrogate loss-function
</p>
<p><code>.dphiFunc</code>
calculates derivative of huberized hinge surrogate loss-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HuberHingeSurrogate'
.phiFunc(surrogate, u)

## S4 method for signature 'HuberHingeSurrogate'
.dPhiFunc(surrogate, u, du)
</code></pre>

<hr>
<h2 id='internal-earl-class'>Class <code>.earl</code></h2><span id='topic+internal-earl-class'></span>

<h3>Description</h3>

<p>Class <code>.earl</code> stores parameters required for EARL optimization step.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>Matrix of covariates for kernel</p>
</dd>
<dt><code>wp</code></dt><dd><p>Vector of positive weights</p>
</dd>
<dt><code>wn</code></dt><dd><p>Vector of negative weights</p>
</dd>
<dt><code>mu</code></dt><dd><p>Matrix of outcome regression</p>
</dd>
<dt><code>txVec</code></dt><dd><p>Vector of treatment coded as -1/1</p>
</dd>
<dt><code>invPi</code></dt><dd><p>Vector of inverse propensity for treatment received</p>
</dd>
<dt><code>response</code></dt><dd><p>Vector of the response</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>The Surrogate for the loss-function</p>
</dd>
<dt><code>par</code></dt><dd><p>Vector of regime parameters</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The Kernel defining the decision function</p>
</dd>
</dl>

<hr>
<h2 id='internal-earl-methods'>Methods Available for Objects of Class <code>.earl</code></h2><span id='topic+internal-earl-methods'></span><span id='topic+.subsetObject+2C.earl-method'></span><span id='topic+.objFn+2Cnumeric+2C.earl+2CLinearKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.earl+2CLinearKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.earl+2CKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.earl+2CKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.earl+2CMultiRadialKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.earl+2CMultiRadialKernel-method'></span><span id='topic+.valueFunc+2C.earl-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>.earl</code>
</p>
<p><code>.objFn</code> not allowed for EARL with multiple radial kernels
</p>
<p><code>.dobjFn</code> not allowed for EARL with multiple radial kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature '.earl'
.subsetObject(methodObject, subset)

## S4 method for signature 'numeric,.earl,LinearKernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.earl,LinearKernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.earl,Kernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.earl,Kernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.earl,MultiRadialKernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.earl,MultiRadialKernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature '.earl'
.valueFunc(methodObject, optTx, ...)
</code></pre>

<hr>
<h2 id='internal-owl-class'>Class <code>.owl</code></h2><span id='topic+internal-owl-class'></span>

<h3>Description</h3>

<p>Class <code>.owl</code> stores parameters required for OWL optimization step
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>Matrix of covariates for kernel</p>
</dd>
<dt><code>txSignR</code></dt><dd><p>Vector of tx multiplied by the sign of the response</p>
</dd>
<dt><code>txVec</code></dt><dd><p>Vector of tx coded as -1/1</p>
</dd>
<dt><code>absRinvPi</code></dt><dd><p>Vector of the absolute value of the response weighted by
the propensity for the tx received</p>
</dd>
<dt><code>response</code></dt><dd><p>Vector of the response</p>
</dd>
<dt><code>invPi</code></dt><dd><p>Vector of the inverse of the propensity for the tx received</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>The Surrogate for the loss-function</p>
</dd>
<dt><code>pars</code></dt><dd><p>Vector of regime parameters</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The Kernel defining the decision function</p>
</dd>
</dl>

<hr>
<h2 id='internal-owl-methods'>Methods Available for Objects of Class <code>.owl</code></h2><span id='topic+internal-owl-methods'></span><span id='topic+.subsetObject+2C.owl-method'></span><span id='topic+.objFn+2Cnumeric+2C.owl+2CKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.owl+2CKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.owl+2CLinearKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.owl+2CLinearKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.owl+2CMultiRadialKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.owl+2CMultiRadialKernel-method'></span><span id='topic+.valueFunc+2C.owl-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>.owl</code>
</p>
<p><code>.objFn</code> is not allowed for OWL with multiple radial kernels
</p>
<p><code>.dobjFn</code> is not allowed for OWL with multiple radial kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature '.owl'
.subsetObject(methodObject, subset)

## S4 method for signature 'numeric,.owl,Kernel'
.objFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature 'numeric,.owl,Kernel'
.dobjFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature 'numeric,.owl,LinearKernel'
.objFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature 'numeric,.owl,LinearKernel'
.dobjFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature 'numeric,.owl,MultiRadialKernel'
.objFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature 'numeric,.owl,MultiRadialKernel'
.dobjFn(par, methodObject, kernel, ..., lambda)

## S4 method for signature '.owl'
.valueFunc(methodObject, ..., optTx)
</code></pre>

<hr>
<h2 id='internal-rwl-class'>Class <code>.rwl</code></h2><span id='topic+internal-rwl-class'></span>

<h3>Description</h3>

<p>Class <code>.rwl</code> stores parameters required for an RWL optimization step
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>Matrix of covariates for kernel</p>
</dd>
<dt><code>txVec</code></dt><dd><p>Vector of treatment coded as -1/1</p>
</dd>
<dt><code>absRinvPi</code></dt><dd><p>Vector of the absolute value of the residual weighted by
the propensity for the treatment received</p>
</dd>
<dt><code>residual</code></dt><dd><p>Vector of the residuals</p>
</dd>
<dt><code>response</code></dt><dd><p>Vector of the response</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of beta parameters</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>The Surrogate for the loss-function</p>
</dd>
<dt><code>pars</code></dt><dd><p>Vector of regime parameters</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The Kernel defining the decision function</p>
</dd>
</dl>

<hr>
<h2 id='internal-rwl-methods'>Methods Available for Objects of Class <code>.rwl</code></h2><span id='topic+internal-rwl-methods'></span><span id='topic+.subsetObject+2C.rwl-method'></span><span id='topic+.objFn+2Cnumeric+2C.rwl+2CLinearKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.rwl+2CLinearKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.rwl+2CKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.rwl+2CKernel-method'></span><span id='topic+.objFn+2Cnumeric+2C.rwl+2CMultiRadialKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2C.rwl+2CMultiRadialKernel-method'></span><span id='topic+.valueFunc+2C.rwl-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>.rwl</code>
</p>
<p><code>.objFn</code>
not allowed for RWL With multiple radial kernels
</p>
<p><code>.dobjFn</code>
not allowed for RWL With multiple radial kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature '.rwl'
.subsetObject(methodObject, subset)

## S4 method for signature 'numeric,.rwl,LinearKernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.rwl,LinearKernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.rwl,Kernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.rwl,Kernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.rwl,MultiRadialKernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,.rwl,MultiRadialKernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature '.rwl'
.valueFunc(methodObject, optTx, ...)
</code></pre>

<hr>
<h2 id='iqLearn'>Interactive Q-Learning</h2><span id='topic+iqLearn'></span><span id='topic+iqLearnSS'></span><span id='topic+iqLearnFSM'></span><span id='topic+iqLearnFSV'></span><span id='topic+iqLearnFSC'></span>

<h3>Description</h3>

<p>The complete interactive Q-Learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Second-Stage Analysis
iqLearnSS(..., moMain, moCont, data, response, txName, iter = 0L, 
          verbose = TRUE)

## First-Stage Analysis for Fitted Main Effects
iqLearnFSM(..., moMain, moCont, data, response, txName, iter = 0L, 
           verbose = TRUE)

## First-Stage Analysis for Fitted Contrasts
iqLearnFSC(..., moMain, moCont, data, response, txName, iter = 0L, 
           verbose = TRUE)

## First-Stage Analysis of Contrast Variance Log-Linear Model
iqLearnFSV(..., object, moMain, moCont, data, iter = 0L, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iqLearn_+3A_...">...</code></td>
<td>
<p>ignored. Provided to require named inputs.</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj or a list of objects of class
modelObjSubset, which define the models and R methods to be used to
obtain parameter estimates and predictions for the main effects component 
of the outcome regression. See ?modelObj and/or ?modelObjSubset for 
details. NULL is an acceptable value if moCont is defined.</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_mocont">moCont</code></td>
<td>
<p>An object of class modelObj or a list of objects of class
modelObjSubset, which define the models and R methods to be used to 
obtain parameter estimates and predictions for the contrasts component 
of the outcome regression. See ?modelObj and/or ?modelObjSubset for 
details. NULL is an acceptable value if moMain is defined.</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_data">data</code></td>
<td>
<p>A data frame of covariates and treatment history.</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_response">response</code></td>
<td>
<p>For the second stage analysis, the response vector.
For first stage analyses, the value object returned by iqLearnSS().</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_object">object</code></td>
<td>
<p>The value object returned by iqLearFSC()</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_txname">txName</code></td>
<td>
<p>A character string giving column header of treatment variable
in data</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_iter">iter</code></td>
<td>
<p>An integer. See ?iter for details</p>
</td></tr>
<tr><td><code id="iqLearn_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If TRUE, screen prints are generated.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Laber, EB, Linn, KA, and Stefanski, LA (2014).
Interactive model building for Q-Learning.
Biometrika, 101, 831&ndash;847. PMCID: PMC4274394.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other multiple decision point methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

#### Full Interactive Q-Learning Algorithm

### Second-Stage Analysis

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+month4BMI,
                        solver.method = 'lm')

fitSS &lt;- iqLearnSS(moMain = moMain, moCont = moCont,
                   data = bmiData, response = y12,  txName = 'A2')

### First-Stage Analysis Main Effects Term

# main effects model
moMain &lt;- buildModelObj(model = ~parentBMI+baselineBMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+baselineBMI,
                        solver.method = 'lm')

fitFSM &lt;- iqLearnFSM(moMain = moMain, moCont = moCont,
                     data = bmiData, response = fitSS,  txName = 'A1')

### First-Stage Analysis Contrasts Term

# contrasts model
moMain &lt;- buildModelObj(model = ~parentBMI+baselineBMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+baselineBMI,
                        solver.method = 'lm')

fitFSC &lt;- iqLearnFSC(moMain = moMain, moCont = moCont,
                     data = bmiData, response = fitSS,  txName = 'A1')

### First-Stage Analysis Contrasts Variance - Log-linear

# contrasts variance model
moMain &lt;- buildModelObj(model = ~baselineBMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~baselineBMI,
                        solver.method = 'lm')

fitFSV &lt;- iqLearnFSV(object = fitFSC, moMain = moMain, moCont = moCont,
                     data = bmiData)

####Available methods

  ### Estimated value
  estimator(x = fitFSC, y = fitFSM, z = fitFSV, w = fitSS, dens = 'nonpar')

  ## Estimated optimal treatment and decision functions for training data
  ## Second stage optimal treatments
  optTx(x = fitSS)

  ## First stage optimal treatments when contrast variance is modeled.
  optTx(x = fitFSM, y = fitFSC, z = fitFSV, dens = 'nonpar')

  ## First stage optimal treatments when contrast variance is constant.
  optTx(x = fitFSM, y = fitFSC, dens = 'nonpar')

  ## Estimated optimal treatment and decision functions for new data
  ## Second stage optimal treatments
  optTx(x = fitSS, bmiData)

  ## First stage optimal treatments when contrast variance is modeled.
  optTx(x = fitFSM, y = fitFSC, z = fitFSV, dens = 'nonpar', bmiData)

  ## First stage optimal treatments when contrast variance is constant.
  optTx(x = fitFSM, y = fitFSC, dens = 'nonpar', bmiData)

### The following methods are available for all objects: fitSS, fitFSM,
### fitFSC and fitFSV. We include only one here for illustration.

  # Coefficients of the outcome regression objects
  coef(object = fitSS)

  # Description of method used to obtain object
  DTRstep(object = fitFSM)

  # Value object returned by outcome regression method
  fitObject(object = fitFSC)

  # Value object returned by outcome regression method
  outcome(object = fitFSV)

  # Plots if defined by outcome regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(x = fitSS)
  plot(x = fitSS, suppress = TRUE)

  # Show main results of method
  show(object = fitFSM)

  # Show summary results of method
  summary(object = fitFSV)

</code></pre>

<hr>
<h2 id='IQLearnFS_C-class'>Class <code>IQLearnFS_C</code></h2><span id='topic+IQLearnFS_C-class'></span>

<h3>Description</h3>

<p>Class <code>IQLearnFS_C</code> contains the results for the first stage
contrasts component of the interactive Q-Learning algorithm.
Objects of this class are returned by iqLearnFSC().
</p>


<h3>Slots</h3>


<dl>
<dt><code>txVec</code></dt><dd><p>: A numeric. treatment vector from training data</p>
</dd>
<dt><code>residuals</code></dt><dd><p>: A numeric. residuals of the fit</p>
</dd>
<dt><code>step</code></dt><dd><p>: Not used in this context.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>: The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>: The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>: The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<dl>
<dt>residuals</dt><dd><p>:Retrieve the residuals of the regression.</p>
</dd>
<dt>sd</dt><dd><p>:Retrieve the standard deviation of the residuals.</p>
</dd>
</dl>


<hr>
<h2 id='IQLearnFS_C-methods'>Methods Available for Objects of Class <code>IQLearnFS_C</code></h2><span id='topic+IQLearnFS_C-methods'></span><span id='topic+print+2CIQLearnFS_C-method'></span><span id='topic+show+2CIQLearnFS_C-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>IQLearnFS_C</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IQLearnFS_C'
print(x, ...)

## S4 method for signature 'IQLearnFS_C'
show(object)
</code></pre>

<hr>
<h2 id='IQLearnFS_ME-class'>Class <code>IQLearnFS_ME</code></h2><span id='topic+IQLearnFS_ME-class'></span>

<h3>Description</h3>

<p>Class <code>IQLearnFS_ME</code> contains the results for the first stage
main effects component of the interactive Q-Learning algorithm.
Objects of this class are returned by iqLearnFSM().
</p>


<h3>Slots</h3>


<dl>
<dt><code>step</code></dt><dd><p>: Not used in this context.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>: The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>: The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>: The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='IQLearnFS_ME-methods'>Methods Available for Objects of Class <code>IQLearnFS_ME</code></h2><span id='topic+IQLearnFS_ME-methods'></span><span id='topic+print+2CIQLearnFS_ME-method'></span><span id='topic+show+2CIQLearnFS_ME-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>IQLearnFS_ME</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IQLearnFS_ME'
print(x, ...)

## S4 method for signature 'IQLearnFS_ME'
show(object)
</code></pre>

<hr>
<h2 id='IQLearnFS_VHet-class'>Class <code>IQLearnFS_VHet</code></h2><span id='topic+IQLearnFS_VHet-class'></span>

<h3>Description</h3>

<p>Class <code>IQLearnFS_VHet</code> contains the results for the first stage
residuals component of the interactive Q-Learning algorithm.
Objects of this class are returned by iqLearnFSV().
</p>


<h3>Slots</h3>


<dl>
<dt><code>residuals</code></dt><dd><p>: Standardized residuals of contrast after modeling</p>
</dd>
<dt><code>scale</code></dt><dd><p>: Scaling factor for stdization</p>
</dd>
<dt><code>step</code></dt><dd><p>: Not used in this context.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>: The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>: The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>: The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<dl>
<dt>residuals</dt><dd><p>:Retrieve the residuals of the regression.</p>
</dd>
<dt>qqplot</dt><dd><p>QQ plot of the residuals for the interactive Q-Learning algorithm.</p>
</dd>
</dl>


<hr>
<h2 id='IQLearnFS_VHet-methods'>Methods Available for Objects of Class <code>IQLearnFS_VHet</code></h2><span id='topic+IQLearnFS_VHet-methods'></span><span id='topic+print+2CIQLearnFS_VHet-method'></span><span id='topic+qqplot+2CIQLearnFS_VHet-method'></span><span id='topic+show+2CIQLearnFS_VHet-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>IQLearnFS_VHet</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IQLearnFS_VHet'
print(x, ...)

## S4 method for signature 'IQLearnFS_VHet'
qqplot(
  x,
  y,
  plot.it = TRUE,
  xlab = deparse1(substitute(x)),
  ylab = deparse1(substitute(y)),
  ...,
  conf.level = NULL,
  conf.args = list(exact = NULL, simulate.p.value = FALSE, B = 2000, col = NA, border =
    NULL)
)

## S4 method for signature 'IQLearnFS_VHet'
show(object)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>qqplot(IQLearnFS_VHet)</code>: 
</p>
</li></ul>

<hr>
<h2 id='IQLearnFS-class'>Class <code>IQLearnFS</code></h2><span id='topic+IQLearnFS-class'></span>

<h3>Description</h3>

<p>Class <code>IQLearnFS</code> contains results for a component of the first stage
analysis of the interactive Q-Learning algorithm.
</p>

<hr>
<h2 id='IQLearnFS-methods'>Methods Available for Objects of Class <code>IQLearnFS</code></h2><span id='topic+IQLearnFS-methods'></span><span id='topic+print+2CIQLearnFS-method'></span><span id='topic+show+2CIQLearnFS-method'></span><span id='topic+summary+2CIQLearnFS-method'></span>

<h3>Description</h3>

<p>Employs methods defined for <code>QLearn</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IQLearnFS'
print(x, ...)

## S4 method for signature 'IQLearnFS'
show(object)

## S4 method for signature 'IQLearnFS'
summary(object, ...)
</code></pre>

<hr>
<h2 id='IQLearnSS-class'>Class <code>IQLearnSS</code></h2><span id='topic+IQLearnSS-class'></span>

<h3>Description</h3>

<p>Class <code>IQLearnSS</code> contains the results for the second stage
of the interactive Q-Learning algorithm. Objects of this class are
returned by iqLearnSS().
</p>


<h3>Slots</h3>


<dl>
<dt><code>yContHat</code></dt><dd><p>: A numeric. Estimated contrast component</p>
</dd>
<dt><code>yMainHat</code></dt><dd><p>: A numeric. Estimated main effects component</p>
</dd>
<dt><code>delta</code></dt><dd><p>: A numeric. Indicator of compliance * response used for value calc</p>
</dd>
<dt><code>step</code></dt><dd><p>: Not used in this context.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>: The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>: The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>: The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>


<dl>
<dt>fittCont</dt><dd><p>:Retrieve the contrasts component of the regression.</p>
</dd>
<dt>fittMain</dt><dd><p>:Retrieve the main effects component of the regression.</p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='IQLearnSS-methods'>Methods Available for Objects of Class <code>IQLearnSS</code></h2><span id='topic+IQLearnSS-methods'></span><span id='topic+print+2CIQLearnSS-method'></span><span id='topic+show+2CIQLearnSS-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>IQLearnSS</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IQLearnSS'
print(x, ...)

## S4 method for signature 'IQLearnSS'
show(object)
</code></pre>

<hr>
<h2 id='iter'>Defining the iter Input Variable</h2><span id='topic+iter'></span>

<h3>Description</h3>

<p>Several of the statistical methods implemented in package
<span class="pkg">DynTxRegime</span> allow for an iterative algorithm
when completing an outcome regression. 
This section details how this
input is to be defined.
</p>


<h3>Details</h3>

<p>Outcome regression models are specified by the main effects components 
(<code>moMain</code>) and the contrasts component (<code>moCont</code>). 
Assuming that the  
treatment is denoted as binary A, the full regression model is:  
moMain + A*moCont. There are two ways to fit this model: (i)  
in the full model formulation (moMain + A*moCont) or (ii) each  
component, <code>moMain</code> and <code>moCont</code>, is fit separately. 
<code>iter</code> specifies  
if (i) or (ii) should be used.
</p>
<p><code>iter</code> &gt;= 1 indicates that <code>moMain</code> and <code>moCont</code>
are to be
fit separately using an iterative algorithm. 
<code>iter</code> is the maximum number of iterations.
Assume Y = Ymain + Ycont;
the iterative algorithm is as follows:
</p>
<p>(1) hat(Ycont) = 0;
</p>
<p>(2) Ymain = Y - hat(Ycont);
</p>
<p>(3) fit Ymain ~ moMain;
</p>
<p>(4) set Ycont = Y - hat(Ymain)
</p>
<p>(5) fit Ycont ~ A*moCont;
</p>
<p>(6) Repeat steps (2) - (5) until convergence or
a maximum of iter iterations. 
</p>
<p>This choice allows the user to specify, for example,
a linear main effects component and a non-linear
contrasts component.
</p>
<p><code>iter</code> &lt;= 0 indicates that the full model formulation is to be
used. The components <code>moMain</code> and <code>moCont</code> will be 
combined in the package and fit as a single object.
Note that if <code>iter</code> &lt;= 0, all non-model components of
<code>moMain</code> and <code>moCont</code> must be identical. Specifically,
the regression method and any non-default arguments
should be identical. 
By default, the specifications in <code>moMain</code> are used.
</p>

<hr>
<h2 id='Kernel-class'>Class <code>Kernel</code></h2><span id='topic+Kernel-class'></span>

<h3>Description</h3>

<p>Class <code>Kernel</code> holds information regarding the decision function kernel
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>An formula. Defines the covariates of the kernel.</p>
</dd>
<dt><code>X</code></dt><dd><p>A matrix. The covariates of the kernel</p>
</dd>
<dt><code>kparam</code></dt><dd><p>ANY. The kernel parameter</p>
</dd>
</dl>

<hr>
<h2 id='Kernel-methods'>Methods Available for Objects of Class <code>Kernel</code></h2><span id='topic+Kernel-methods'></span><span id='topic+.getKernelX+2Cdata.frame+2CKernel-method'></span><span id='topic+.kernelNumPars+2CKernel-method'></span><span id='topic+.kernel+2CKernel+2Cmissing+2Cmissing-method'></span><span id='topic+.kernel+2CKernel+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+.kernel+2CKernel+2Cvector+2Cvector-method'></span><span id='topic+.kernel+2CKernel+2Cvector+2Cdata.frame-method'></span><span id='topic+.kernel+2CKernel+2Cdata.frame+2Cvector-method'></span><span id='topic+.kernel+2CKernel+2Cmatrix+2Cdata.frame-method'></span><span id='topic+.kernel+2CKernel+2Cdata.frame+2Cmatrix-method'></span><span id='topic+.kernel+2CKernel+2Cvector+2Cmatrix-method'></span><span id='topic+.kernel+2CKernel+2Cmatrix+2Cvector-method'></span><span id='topic+.kernel+2CKernel+2Cmatrix+2Cmatrix-method'></span><span id='topic+print+2CKernel-method'></span><span id='topic+show+2CKernel-method'></span><span id='topic+summary+2CKernel-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>Kernel</code>
</p>
<p><code>.getKernelX</code>
retrieves the covariates matrix of the kernel.
</p>
<p><code>.kernelNumPars</code>
retrieves the number of covariates of the kernel.
</p>
<p><code>.kernel</code>
calculates the kernel
</p>
<p><code>print</code>
prints kernel model.
</p>
<p><code>show</code>
displays kernel model.
</p>
<p><code>summary</code>
returns a list containing the kernel model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame,Kernel'
.getKernelX(data, object)

## S4 method for signature 'Kernel'
.kernelNumPars(object, ...)

## S4 method for signature 'Kernel,missing,missing'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,data.frame,data.frame'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,vector,vector'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,vector,data.frame'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,data.frame,vector'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,matrix,data.frame'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,data.frame,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,vector,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,matrix,vector'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel,matrix,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'Kernel'
print(x, ...)

## S4 method for signature 'Kernel'
show(object)

## S4 method for signature 'Kernel'
summary(object, ...)
</code></pre>

<hr>
<h2 id='KernelObj-class'>Class <code>KernelObj</code></h2><span id='topic+KernelObj-class'></span><span id='topic+.kernelNumPars+2CKernelObj-method'></span>

<h3>Description</h3>

<p>Class <code>KernelObj</code> holds decision function kernel information
under a common name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelObj'
.kernelNumPars(object, ...)
</code></pre>


<h3>Slots</h3>


<dl>
<dt><code>kernel</code></dt><dd><p>ANY expected to be <code>Kernel</code> or <code>SubsetList</code></p>
</dd>
</dl>

<hr>
<h2 id='KernelObj-methods'>Methods Available for Objects of Class <code>KernelObj</code></h2><span id='topic+KernelObj-methods'></span><span id='topic+.getKernelX+2Cdata.frame+2CKernelObj-method'></span><span id='topic+.kernel+2CKernelObj+2CANY+2CANY-method'></span><span id='topic+.kernel+2CKernelObj+2Cmissing+2Cmissing-method'></span><span id='topic+.kernel+2CKernelObj+2Cmissing+2CANY-method'></span><span id='topic+.kernel+2CKernelObj+2CANY+2Cmissing-method'></span><span id='topic+print+2CKernelObj-method'></span><span id='topic+show+2CKernelObj-method'></span><span id='topic+summary+2CKernelObj-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>KernelObj</code>
</p>
<p><code>.getKernelX</code>
not allowed.
</p>
<p><code>.kernel</code>
not allowed.
</p>
<p><code>print</code>
prints kernel model. Includes &quot;Kernel&quot; as header.
</p>
<p><code>show</code>
displays kernel model. Includes &quot;Kernel&quot; as header.
</p>
<p><code>summary</code>
not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame,KernelObj'
.getKernelX(data, object)

## S4 method for signature 'KernelObj,ANY,ANY'
.kernel(object, x1, x2, ...)

## S4 method for signature 'KernelObj,missing,missing'
.kernel(object, x1, x2, ...)

## S4 method for signature 'KernelObj,missing,ANY'
.kernel(object, x1, x2, ...)

## S4 method for signature 'KernelObj,ANY,missing'
.kernel(object, x1, x2, ...)

## S4 method for signature 'KernelObj'
print(x, ...)

## S4 method for signature 'KernelObj'
show(object)

## S4 method for signature 'KernelObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='Learning-class'>Class <code>Learning</code></h2><span id='topic+Learning-class'></span>

<h3>Description</h3>

<p>Class <code>Learning</code> contains results for a learning analysis with one 
regime.
</p>


<h3>Slots</h3>


<dl>
<dt><code>txInfo</code></dt><dd><p>Feasible tx information</p>
</dd>
<dt><code>propen</code></dt><dd><p>Propensity regression analysis</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Outcome regression analysis</p>
</dd>
<dt><code>optim</code></dt><dd><p>Optimization analysis</p>
</dd>
</dl>

<hr>
<h2 id='Learning-methods'>Methods Available for Objects of Class <code>Learning</code></h2><span id='topic+Learning-methods'></span><span id='topic+Call+2CLearning-method'></span><span id='topic+cvInfo+2CLearning-method'></span><span id='topic+coef+2CLearning-method'></span><span id='topic+estimator+2CLearning-method'></span><span id='topic+fitObject+2CLearning-method'></span><span id='topic+optimObj+2CLearning-method'></span><span id='topic+optTx+2CLearning+2Cdata.frame-method'></span><span id='topic+optTx+2CLearning+2Cmissing-method'></span><span id='topic+outcome+2CLearning-method'></span><span id='topic+plot+2CLearning+2CANY-method'></span><span id='topic+print+2CLearning-method'></span><span id='topic+propen+2CLearning-method'></span><span id='topic+regimeCoef+2CLearning-method'></span><span id='topic+show+2CLearning-method'></span><span id='topic+summary+2CLearning-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>Learning</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Learning'
Call(name, ...)

## S4 method for signature 'Learning'
cvInfo(object, ...)

## S4 method for signature 'Learning'
coef(object, ...)

## S4 method for signature 'Learning'
estimator(x, ...)

## S4 method for signature 'Learning'
fitObject(object, ...)

## S4 method for signature 'Learning'
optimObj(object, ...)

## S4 method for signature 'Learning,data.frame'
optTx(x, newdata)

## S4 method for signature 'Learning,missing'
optTx(x, newdata, ...)

## S4 method for signature 'Learning'
outcome(object, ...)

## S4 method for signature 'Learning,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'Learning'
print(x, ...)

## S4 method for signature 'Learning'
propen(object, ...)

## S4 method for signature 'Learning'
regimeCoef(object, ...)

## S4 method for signature 'Learning'
show(object)

## S4 method for signature 'Learning'
summary(object, ...)
</code></pre>

<hr>
<h2 id='LearningMulti-class'>Class <code>LearningMulti</code></h2><span id='topic+LearningMulti-class'></span>

<h3>Description</h3>

<p>Class <code>LearningMulti</code> contains results for a learning analysis 
with multiple regimes.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optimResult</code></dt><dd><p>ANY containing a list of OptimStep results</p>
</dd>
</dl>

<hr>
<h2 id='LearningMulti-methods'>Methods Available for Objects of Class <code>LearningMulti</code></h2><span id='topic+LearningMulti-methods'></span><span id='topic+Call+2CLearningMulti-method'></span><span id='topic+cvInfo+2CLearningMulti-method'></span><span id='topic+coef+2CLearningMulti-method'></span><span id='topic+estimator+2CLearningMulti-method'></span><span id='topic+fitObject+2CLearningMulti-method'></span><span id='topic+optimObj+2CLearningMulti-method'></span><span id='topic+optTx+2CLearningMulti+2Cdata.frame-method'></span><span id='topic+optTx+2CLearningMulti+2Cmissing-method'></span><span id='topic+outcome+2CLearningMulti-method'></span><span id='topic+plot+2CLearningMulti+2CANY-method'></span><span id='topic+print+2CLearningMulti-method'></span><span id='topic+propen+2CLearningMulti-method'></span><span id='topic+regimeCoef+2CLearningMulti-method'></span><span id='topic+show+2CLearningMulti-method'></span><span id='topic+summary+2CLearningMulti-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>LearningMulti</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LearningMulti'
Call(name, ...)

## S4 method for signature 'LearningMulti'
cvInfo(object, ...)

## S4 method for signature 'LearningMulti'
coef(object, ...)

## S4 method for signature 'LearningMulti'
estimator(x, ...)

## S4 method for signature 'LearningMulti'
fitObject(object, ...)

## S4 method for signature 'LearningMulti'
optimObj(object, ...)

## S4 method for signature 'LearningMulti,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'LearningMulti,missing'
optTx(x, newdata, ...)

## S4 method for signature 'LearningMulti'
outcome(object, ...)

## S4 method for signature 'LearningMulti,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'LearningMulti'
print(x, ...)

## S4 method for signature 'LearningMulti'
propen(object, ...)

## S4 method for signature 'LearningMulti'
regimeCoef(object, ...)

## S4 method for signature 'LearningMulti'
show(object)

## S4 method for signature 'LearningMulti'
summary(object, ...)
</code></pre>

<hr>
<h2 id='LearningObject-class'>Class <code>LearningObject</code></h2><span id='topic+LearningObject-class'></span>

<h3>Description</h3>

<p>Class <code>LearningObject</code> contains stores parameters required for 
weighted learning optimization step
</p>


<h3>Slots</h3>


<dl>
<dt><code>mu</code></dt><dd><p>Matrix of outcome regression</p>
</dd>
<dt><code>txVec</code></dt><dd><p>Vector of treatment coded as -1/1</p>
</dd>
<dt><code>invPi</code></dt><dd><p>Vector of inverse propensity for treatment received</p>
</dd>
<dt><code>response</code></dt><dd><p>Vector of the response</p>
</dd>
</dl>

<hr>
<h2 id='LearningObject-methods'>Methods Available for Objects of Class <code>LearningObject</code></h2><span id='topic+LearningObject-methods'></span><span id='topic+.subsetObject+2CLearningObject-method'></span><span id='topic+.objFn+2Cnumeric+2CLearningObject+2CKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2CLearningObject+2CKernel-method'></span><span id='topic+.valueFunc+2CLearningObject-method'></span><span id='topic+.createLearningObject'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>LearningObject</code>
</p>
<p>Create LearningObject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LearningObject'
.subsetObject(methodObject, subset)

## S4 method for signature 'numeric,LearningObject,Kernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,LearningObject,Kernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'LearningObject'
.valueFunc(methodObject, optTx, ...)

.createLearningObject(
  kernel,
  surrogate,
  mu,
  txVec,
  response,
  prWgt,
  guess = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LearningObject-methods_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object indicating surrogate loss-function</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_mu">mu</code></td>
<td>
<p>Matrix of predicted outcome on binary tx coding</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_txvec">txVec</code></td>
<td>
<p>Tx vector coded as -1/1</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_response">response</code></td>
<td>
<p>vector of response</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_prwgt">prWgt</code></td>
<td>
<p>propensity wgt for tx received</p>
</td></tr>
<tr><td><code id="LearningObject-methods_+3A_guess">guess</code></td>
<td>
<p>Vector of estimated regime parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LearningObject object
</p>

<hr>
<h2 id='LinearKernel-class'>Class <code>LinearKernel</code></h2><span id='topic+LinearKernel-class'></span>

<h3>Description</h3>

<p>Class <code>LinearKernel</code> holds information regarding decision function 
when kernel is linear
</p>

<hr>
<h2 id='LinearKernel-methods'>Methods Available for Objects of Class <code>LinearKernel</code></h2><span id='topic+LinearKernel-methods'></span><span id='topic+.kernelNumPars+2CLinearKernel-method'></span><span id='topic+.kernel+2CLinearKernel+2Cmatrix+2Cmatrix-method'></span><span id='topic+print+2CLinearKernel-method'></span><span id='topic+show+2CLinearKernel-method'></span><span id='topic+summary+2CLinearKernel-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>LinearKernel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LinearKernel'
.kernelNumPars(object, ...)

## S4 method for signature 'LinearKernel,matrix,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'LinearKernel'
print(x, ...)

## S4 method for signature 'LinearKernel'
show(object)

## S4 method for signature 'LinearKernel'
summary(object, ...)
</code></pre>

<hr>
<h2 id='List-class'>Class <code>List</code></h2><span id='topic+List-class'></span>

<h3>Description</h3>

<p>Class <code>List</code> mimics a <code>list</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>names</code></dt><dd><p>Character vector of names for elements</p>
</dd>
</dl>

<hr>
<h2 id='LogitSurrogate-class'>Class <code>LogitSurrogate</code></h2><span id='topic+LogitSurrogate-class'></span>

<h3>Description</h3>

<p>Logistic surrogate for 0/1 loss function.
</p>

<hr>
<h2 id='LogitSurrogate-methods'>Methods Available for Objects of Class <code>LogitSurrogate</code></h2><span id='topic+LogitSurrogate-methods'></span><span id='topic+.phiFunc+2CLogitSurrogate-method'></span><span id='topic+.dPhiFunc+2CLogitSurrogate-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>LogitSurrogate</code>
</p>
<p><code>.phiFunc</code>
calculates logistic surrogate loss-function
</p>
<p><code>.dphiFunc</code>
calculates derivative of logistic surrogate loss-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LogitSurrogate'
.phiFunc(surrogate, u)

## S4 method for signature 'LogitSurrogate'
.dPhiFunc(surrogate, u, du)
</code></pre>

<hr>
<h2 id='MethodObject-class'>Class <code>MethodObject</code></h2><span id='topic+MethodObject-class'></span>

<h3>Description</h3>

<p>Class <code>MethodObject</code> stores parameters required for optimization step
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>Matrix of covariates for kernel</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>The Surrogate for the loss-function</p>
</dd>
<dt><code>pars</code></dt><dd><p>Vector of regime parameters</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The Kernel defining the decision function</p>
</dd>
</dl>

<hr>
<h2 id='MethodObject-methods'>Methods Available for Objects of Class <code>MethodObject</code></h2><span id='topic+MethodObject-methods'></span><span id='topic+.subsetObject+2CMethodObject-method'></span><span id='topic+.objFn+2Cnumeric+2CMethodObject+2CKernel-method'></span><span id='topic+.dobjFn+2Cnumeric+2CMethodObject+2CKernel-method'></span><span id='topic+.valueFunc+2CMethodObject-method'></span><span id='topic+.createMethodObject'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>MethodObject</code>
</p>
<p>Create method object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MethodObject'
.subsetObject(methodObject, subset)

## S4 method for signature 'numeric,MethodObject,Kernel'
.objFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'numeric,MethodObject,Kernel'
.dobjFn(par, methodObject, kernel, lambda, ...)

## S4 method for signature 'MethodObject'
.valueFunc(methodObject, optTx, ...)

.createMethodObject(kernel, surrogate, guess = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MethodObject-methods_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="MethodObject-methods_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object indicating surrogate loss-function</p>
</td></tr>
<tr><td><code id="MethodObject-methods_+3A_guess">guess</code></td>
<td>
<p>Vector of estimated regime parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MethodObject object
</p>

<hr>
<h2 id='ModelObj_DecisionPointList-class'>Class ModelObj_DecisionPointList</h2><span id='topic+ModelObj_DecisionPointList-class'></span><span id='topic+initialize+2CModelObj_DecisionPointList-method'></span>

<h3>Description</h3>

<p>Class <code>ModelObj_DecisionPointList</code> represents a <code>List</code> for 
multiple decision points. Contents can be other modelObj or ModeObj_SubsetList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ModelObj_DecisionPointList'
initialize(.Object, ...)
</code></pre>

<hr>
<h2 id='ModelObj_SubsetList-class'>Class ModelObj_SubsetList</h2><span id='topic+ModelObj_SubsetList-class'></span><span id='topic+initialize+2CModelObj_SubsetList-method'></span>

<h3>Description</h3>

<p>Class <code>ModelObj_SubsetList</code> represents a <code>List</code> for subset
modelObj.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ModelObj_SubsetList'
initialize(.Object, ...)
</code></pre>

<hr>
<h2 id='ModelObjSubset-class'>Class <code>ModelObjSubset</code></h2><span id='topic+ModelObjSubset-class'></span>

<h3>Description</h3>

<p>Class <code>ModelObjSubset</code> stores a modelObj object with pertinent subset
information
</p>


<h3>Slots</h3>


<dl>
<dt><code>decisionPoint</code></dt><dd><p>integer indicating the decision point for modelObj</p>
</dd>
<dt><code>subset</code></dt><dd><p>character indicating the subset for modelObj
</p>
<p>import modelObj</p>
</dd>
</dl>

<hr>
<h2 id='ModelObjSubset-methods'>Methods Available for Objects of Class <code>ModelObjSubset</code></h2><span id='topic+ModelObjSubset-methods'></span><span id='topic+.getDecisionPoint+2CModelObjSubset-method'></span><span id='topic+.getSubset+2CModelObjSubset-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>ModelObjSubset</code>
</p>
<p><code>.getDecisionPoint(object)</code>
retrieves the decision point to which object pertains
</p>
<p><code>.getSubset(object)</code>
retrieves the subset to which object pertains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ModelObjSubset'
.getDecisionPoint(object)

## S4 method for signature 'ModelObjSubset'
.getSubset(object)
</code></pre>

<hr>
<h2 id='moPropen'>Defining the moPropen Input Variable</h2><span id='topic+moPropen'></span>

<h3>Description</h3>

<p>Several of the statistical methods implemented in package
<span class="pkg">DynTxRegime</span> use propensity score modeling. 
This section details how this
input is to be defined.
</p>


<h3>Details</h3>

<p>For input <code>moPropen</code>, the method specified to obtain predictions 
MUST return the prediction on the scale of the probability,
i.e., predictions must be in the range (0,1). In 
addition, <code>moPropen</code> differs from standard <code>"modelObj"</code> 
objects in that an additional element may be required in 
<code>predict.args</code>. Recall, <code>predict.args</code> is the list of control 
parameters passed to the prediction method. An additional control 
parameter, <code>propen.missing</code> can be included. <code>propen.missing</code> 
takes value &quot;smallest&quot; or &quot;largest&quot;. It will be required if the 
prediction method returns predictions for only a subset of the 
treatment data; e.g., predict.glm(). <code>propen.missing</code> indicates if 
it is the smallest or the largest treatment value that is missing
from the returned predictions.
</p>
<p>For example, fitting a binary treatment (A in {0,1}) using
</p>
<pre>
  moPropen &lt;- buildModelObj(model = ~1,
                            solver.method = 'glm',
                            solver.args = list('family'='binomial'),
                            predict.method = 'predict.glm',
                            predict.args = list(type='response'))
</pre>
<p>returns only P(A=1). P(A=0) is &quot;missing,&quot; and thus
</p>
<pre>
  moPropen &lt;- buildModelObj(model = ~1,
                            solver.method = 'glm',
                            solver.args = list('family'='binomial'),
                            predict.method = 'predict.glm',
                            predict.args = list(type='response',
                                                propen.missing = 'smallest'))
</pre>
<p>If the dimension of the value returned by the prediction method is 
less than the number of treatment options and no value is provided 
in <code>propen.missing</code>, it is assumed that the smallest valued treatment
option is missing. Here, 'smallest' indicates the lowest value 
integer if treatment is an integer, or the 'base' level if treatment 
is a factor.
</p>

<hr>
<h2 id='MultiRadialKernel-class'>Class <code>MultiRadialKernel</code></h2><span id='topic+MultiRadialKernel-class'></span>

<h3>Description</h3>

<p>Class <code>MultiRadialKernel</code> holds information regarding decision function 
when kernel is radial and multiple kernel parameters
</p>

<hr>
<h2 id='MultiRadialKernel-methods'>Methods Available for Objects of Class <code>MultiRadialKernel</code></h2><span id='topic+MultiRadialKernel-methods'></span><span id='topic+.kernel+2CMultiRadialKernel+2Cmatrix+2Cmatrix-method'></span><span id='topic+print+2CMultiRadialKernel-method'></span><span id='topic+show+2CMultiRadialKernel-method'></span><span id='topic+summary+2CMultiRadialKernel-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>MultiRadialKernel</code>
</p>
<p><code>.kernel</code>
not allowed.
</p>
<p><code>print</code>
not allowed.
</p>
<p><code>show</code>
not allowed.
</p>
<p><code>summary</code>
not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultiRadialKernel,matrix,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'MultiRadialKernel'
print(x, ...)

## S4 method for signature 'MultiRadialKernel'
show(object)

## S4 method for signature 'MultiRadialKernel'
summary(object, ...)
</code></pre>

<hr>
<h2 id='newBOWLStep'>Create a BOWL Object</h2><span id='topic+newBOWLStep'></span><span id='topic+.newBOWLStep'></span>

<h3>Description</h3>

<p>Create a BOWL Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newBOWLStep(
  moPropen,
  fSet,
  data,
  response,
  txName,
  lambdas,
  cvFolds,
  kernel,
  surrogate,
  suppress,
  guess,
  prodPi,
  index,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newBOWLStep_+3A_mopropen">moPropen</code></td>
<td>
<p>model object for propensity</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_fset">fSet</code></td>
<td>
<p>function specifying subsets or NULL</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_data">data</code></td>
<td>
<p>data.frame of covariates and tx</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_response">response</code></td>
<td>
<p>vector of responses</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_txname">txName</code></td>
<td>
<p>character indicating tx column in data</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_lambdas">lambdas</code></td>
<td>
<p>vector of tuning parameters</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_cvfolds">cvFolds</code></td>
<td>
<p>number of cross-validation folds or NULL</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_kernel">kernel</code></td>
<td>
<p>Kernel object</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_surrogate">surrogate</code></td>
<td>
<p>Surrogate object</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_guess">guess</code></td>
<td>
<p>vector of starting value for regime parameterse</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_prodpi">prodPi</code></td>
<td>
<p>vector of previous step propensity weights</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_index">index</code></td>
<td>
<p>vector indicating previous compliance with regime</p>
</td></tr>
<tr><td><code id="newBOWLStep_+3A_...">...</code></td>
<td>
<p>additional inputs sent to optimization method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BOWLBasic object
</p>

<hr>
<h2 id='newCVStep'>An n-Fold Cross Validation Step</h2><span id='topic+newCVStep'></span><span id='topic+.newCVStep'></span>

<h3>Description</h3>

<p>An n-Fold Cross Validation Step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newCVStep(cvObject, methodObject, lambda, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newCVStep_+3A_cvobject">cvObject</code></td>
<td>
<p>Information regarding folds and treatment groups</p>
</td></tr>
<tr><td><code id="newCVStep_+3A_methodobject">methodObject</code></td>
<td>
<p>Information needed for method specific objective function</p>
</td></tr>
<tr><td><code id="newCVStep_+3A_lambda">lambda</code></td>
<td>
<p>numeric A single tuning parameter value</p>
</td></tr>
<tr><td><code id="newCVStep_+3A_suppress">suppress</code></td>
<td>
<p>integer indicating printing preference</p>
</td></tr>
<tr><td><code id="newCVStep_+3A_...">...</code></td>
<td>
<p>additional inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The average value across all successfully trained folds
</p>

<hr>
<h2 id='newModelObjSubset'>Create Internal Model Objects for Subsets of Data</h2><span id='topic+newModelObjSubset'></span><span id='topic+.newModelObjSubset'></span>

<h3>Description</h3>

<p>Create Internal Model Objects for Subsets of Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newModelObjSubset(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newModelObjSubset_+3A_object">object</code></td>
<td>
<p>A list of modelObj or ModelObjSubset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ModelObj_SubsetList</code> if a single decision 
point or an object of class <code>ModelObj_DecisionPointList</code> if multiple 
decision points.
</p>

<hr>
<h2 id='optimalClass'>Classification Perspective</h2><span id='topic+optimalClass'></span>

<h3>Description</h3>

<p>Classification Perspective
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimalClass(
  ...,
  moPropen,
  moMain,
  moCont,
  moClass,
  data,
  response,
  txName,
  iter = 0L,
  fSet = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimalClass_+3A_...">...</code></td>
<td>
<p>Included to require named inputs</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj, which defines the models and R
methods to be used to obtain parameter estimates and
predictions for the propensity for treatment. 
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj, which defines the models and R
methods to be used to obtain parameter estimates and
predictions for for the main effects component of the 
outcome regression. 
See ?modelObj for details.
NULL is an appropriate value.</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_mocont">moCont</code></td>
<td>
<p>An object of class modelObj, which defines the models and R
methods to be used to obtain parameter estimates and
predictions for for the contrasts component of the
outcome regression. 
See ?modelObj for details.
NULL is an appropriate value.</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_moclass">moClass</code></td>
<td>
<p>An object of class modelObj, which defines the
models and R methods to be used to obtain parameter 
estimates and predictions for the classification. 
See ?modelObj for details.</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx histories</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_response">response</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_txname">txName</code></td>
<td>
<p>An character giving the column header of the column in data
that contains the tx covariate.</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_iter">iter</code></td>
<td>
<p>An integer
See ?iter for details</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_fset">fSet</code></td>
<td>
<p>A function or NULL. 
This argument allows the user to specify the subset of tx 
options available to a patient. 
See ?fSet for details of allowed structure</p>
</td></tr>
<tr><td><code id="optimalClass_+3A_verbose">verbose</code></td>
<td>
<p>A logical 
If FALSE, screen prints are suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class OptimalClass
</p>


<h3>References</h3>

<p>Baqun Zhang, Anastasios A. Tsiatis, Marie Davidian, Min Zhang and
Eric B. Laber. &quot;Estimating optimal tx regimes from a classification
perspective.&quot; Stat 2012; 1: 103-114. 
</p>
<p>Note that this method is a single decision point, binary treatment
method. For multiple decision points, can be called repeatedly.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other multiple decision point methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# Define the propensity for treatment model and methods.
moPropen &lt;- buildModelObj(model =  ~ 1, 
                          solver.method = 'glm', 
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

# classification model
library(rpart)
moClass &lt;- buildModelObj(model = ~parentBMI+month4BMI+race+gender,
                         solver.method = 'rpart',
                         solver.args = list(method="class"),
                         predict.args = list(type='class'))

#### Second-Stage Analysis using IPW
fitSS_IPW &lt;- optimalClass(moPropen = moPropen, 
                          moClass = moClass,
                          data = bmiData, response = y12,  txName = 'A2')

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+month4BMI,
                        solver.method = 'lm')

#### Second-Stage Analysis using AIPW
fitSS_AIPW &lt;- optimalClass(moPropen = moPropen, 
                           moMain = moMain, moCont = moCont,
                           moClass = moClass,
                           data = bmiData, response = y12,  txName = 'A2')

##Available methods

  # Retrieve the classification regression object
  classif(object = fitSS_AIPW)

  # Coefficients of the outcome regression objects
  coef(object = fitSS_AIPW)

  # Description of method used to obtain object
  DTRstep(object = fitSS_AIPW)

  # Estimated value of the optimal treatment regime for training set
  estimator(x = fitSS_AIPW)

  # Value object returned by outcome regression method
  fitObject(object = fitSS_AIPW)

  # Estimated optimal treatment and decision functions for training data
  optTx(x = fitSS_AIPW)

  # Estimated optimal treatment and decision functions for new data
  optTx(x = fitSS_AIPW, newdata = bmiData)

  # Value object returned by outcome regression method
  outcome(object = fitSS_AIPW)
  outcome(object = fitSS_IPW)

  # Plots if defined by outcome regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(x = fitSS_AIPW)
  plot(x = fitSS_AIPW, suppress = TRUE)

  # Retrieve the value object returned by propensity regression method
  propen(object = fitSS_AIPW)

  # Show main results of method
  show(object = fitSS_AIPW)

  # Show summary results of method
  summary(object = fitSS_AIPW)
 
#### First-stage Analysis using AIPW

 # Define the propensity for treatment model and methods.
 moPropen &lt;- buildModelObj(model =  ~ 1, 
                           solver.method = 'glm', 
                           solver.args = list('family'='binomial'),
                           predict.method = 'predict.glm',
                           predict.args = list(type='response'))

# classification model
moClass &lt;- buildModelObj(model = ~parentBMI+baselineBMI+race+gender,
                         solver.method = 'rpart',
                         solver.args = list(method="class"),
                         predict.args = list(type='class'))

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+baselineBMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+baselineBMI,
                        solver.method = 'lm')

fitFS_AIPW &lt;- optimalClass(moPropen = moPropen, 
                           moMain = moMain, moCont = moCont,
                           moClass = moClass,
                           data = bmiData, response = fitSS_AIPW,  
                           txName = 'A1')

##Available methods for fitFS_AIPW are as shown above for fitSS_AIPW

</code></pre>

<hr>
<h2 id='OptimalClass-class'>Class <code>OptimalClass</code></h2><span id='topic+OptimalClass-class'></span>

<h3>Description</h3>

<p>Class <code>OptimalClass</code> contains results for a single decision point 
when estimates are obtained from the classification perspective.
Objects of this class are returned by optimalClass().
</p>


<h3>Slots</h3>


<dl>
<dt><code>step</code></dt><dd><p>Step in the algorithm.</p>
</dd>
<dt><code>analysis</code></dt><dd><p>Analysis results.</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>classif</dt><dd><p>: 
Retrieve value object returned by classification regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='OptimalClass-methods'>Methods Available for Objects of Class <code>OptimalClass</code></h2><span id='topic+OptimalClass-methods'></span><span id='topic+print+2COptimalClass-method'></span><span id='topic+show+2COptimalClass-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalClass</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalClass'
print(x, ...)

## S4 method for signature 'OptimalClass'
show(object)
</code></pre>

<hr>
<h2 id='OptimalClassObj-class'>Class <code>OptimalClassObj</code></h2><span id='topic+OptimalClassObj-class'></span>

<h3>Description</h3>

<p>Class <code>OptimalClassObj</code> contains results for a single decision point 
when estimates are obtained from the classification perspective.
Objects of this class are returned by optimalClass().
</p>


<h3>Slots</h3>


<dl>
<dt><code>class</code></dt><dd><p>Results of the classification step.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Results of the outcome regression step.</p>
</dd>
<dt><code>propen</code></dt><dd><p>Results of the propensity step.</p>
</dd>
<dt><code>optimal</code></dt><dd><p>Estimated optimal tx and value</p>
</dd>
<dt><code>Call</code></dt><dd><p>Unevaluated call.</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>classif</dt><dd><p>: 
Retrieve value object returned by classification regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='OptimalInfo-class'>Class <code>OptimalInfo</code></h2><span id='topic+OptimalInfo-class'></span>

<h3>Description</h3>

<p>Class <code>OptimalInfo</code> stores the estimated optimal tx, decision functions,
and estimated value.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optimalTx</code></dt><dd><p>a vector of the estimated optimal tx</p>
</dd>
<dt><code>estimatedValue</code></dt><dd><p>a vector of the estimated value</p>
</dd>
<dt><code>decisionFunc</code></dt><dd><p>a vector or matrix containing the values used to determine
@optimalTx (if applicable)</p>
</dd>
</dl>

<hr>
<h2 id='OptimalInfo-methods'>Methods Available for Objects of Class <code>OptimalInfo</code></h2><span id='topic+OptimalInfo-methods'></span><span id='topic+estimator+2COptimalInfo-method'></span><span id='topic+optTx+2COptimalInfo+2Cmissing-method'></span><span id='topic+optTx+2COptimalInfo+2CANY-method'></span><span id='topic+print+2COptimalInfo-method'></span><span id='topic+show+2COptimalInfo-method'></span><span id='topic+summary+2COptimalInfo-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalInfo</code>
</p>
<p><code>estimator(x)</code> 
defines the estimated value to be the mean of the vector stored in 
@estimatedValue
</p>
<p><code>optTx(x)</code> 
returns the contents of @optimalTx and @decisionFunc as a list
</p>
<p><code>optTx(x, newdata)</code> 
returns an error
</p>
<p><code>print(x)</code>
Prints a summary table of the recommended tx for the training data and the
estimated value
</p>
<p><code>show(object)</code>
Displays a summary table of the recommended tx for the training data and
the estimated value
</p>
<p><code>summary(object)</code>
Returns a list containing a summary table of the recommended tx for the 
training data and the estimated value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalInfo'
estimator(x)

## S4 method for signature 'OptimalInfo,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalInfo,ANY'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalInfo'
print(x, ...)

## S4 method for signature 'OptimalInfo'
show(object)

## S4 method for signature 'OptimalInfo'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OptimalObj-class'>Class <code>OptimalObj</code></h2><span id='topic+OptimalObj-class'></span>

<h3>Description</h3>

<p>Class <code>OptimalObj</code> stores the estimated optimal Tx, decision functions
and estimated value under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optimal</code></dt><dd><p>ANY - must be <code>OptimalInfo</code> or 
<code>DecisionPointList</code> of <code>OptimalInfo</code></p>
</dd>
</dl>

<hr>
<h2 id='OptimalObj-methods'>Methods Available for Objects of Class <code>OptimalObj</code></h2><span id='topic+OptimalObj-methods'></span><span id='topic+estimator+2COptimalObj-method'></span><span id='topic+optTx+2COptimalObj+2Cmissing-method'></span><span id='topic+optTx+2COptimalObj+2Cdata.frame-method'></span><span id='topic+print+2COptimalObj-method'></span><span id='topic+show+2COptimalObj-method'></span><span id='topic+summary+2COptimalObj-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalObj</code>
</p>
<p><code>estimator(x)</code> 
retrieves the estimated value obtained by a statistical method.
Method called determined by class of @optimal.
</p>
<p><code>optTx(x)</code> 
returns the estimated decision function and/or optimal tx
Method called determined by class of @optimal.
</p>
<p><code>optTx(x, newdata)</code> 
returns an error
</p>
<p><code>print(x)</code>
Prints summary information regarding recommended tx and the estimated
value. Method called determined by class of @optimal.
</p>
<p><code>show(object)</code>
Displays summary information regarding recommended tx and the estimated
value. Method called determined by class of @optimal.
</p>
<p><code>summary(object)</code>
Returns a summary of estimated decision functions and/or optimal tx. 
Method called determined by class of @optimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalObj'
estimator(x)

## S4 method for signature 'OptimalObj,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalObj,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalObj'
print(x, ...)

## S4 method for signature 'OptimalObj'
show(object)

## S4 method for signature 'OptimalObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='optimalSeq'>Missing or Coarsened Data Perspective - Genetic Algorithm</h2><span id='topic+optimalSeq'></span>

<h3>Description</h3>

<p>Missing or Coarsened Data Perspective - Genetic Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimalSeq(
  ...,
  moPropen,
  moMain,
  moCont,
  data,
  response,
  txName,
  regimes,
  fSet = NULL,
  refit = FALSE,
  iter = 0L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimalSeq_+3A_...">...</code></td>
<td>
<p>Additional arguments required by rgenoud. At a minimum this
should include Domains, pop.size and starting.values.
See ?rgenoud for more information.</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj, a list of objects of class
modelObj, or a list of object of class modelObjSubset,
which define the models and R methods to be used to obtain
parameter estimates and predictions for the propensity for
treatment.
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj, a list of objects of class
modelObj, or a list of object of class modelObjSubset,
which define the models and R methods to be used to obtain
parameter estimates and predictions for the main effects
component of the outcome regression.
See ?modelObj and/or ?modelObjSubset for details.
NULL is an acceptable input if IPWE is desired or there is
no main effects component of the outcome regression model.</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_mocont">moCont</code></td>
<td>
<p>An object of class modelObj, a list of objects of class
modelObj, or a list of object of class modelObjSubset,
which define the models and R methods to be used to obtain
parameter estimates and predictions for the contrasts
component of the outcome regression.
See ?modelObj and/or ?modelObjSubset for details.
NULL is an acceptable input if IPWE is desired or there is
no contrast component of the outcome regression model.</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx history</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_response">response</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_txname">txName</code></td>
<td>
<p>A vector of characters.
The column headers of <em>data</em> that correspond to the tx
covariate for each decision point.
The ordering should be sequential, i.e., the 1st element
gives column name for the 1st decision point tx, the
2nd gives column name for the 2nd decision point tx,
etc.</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_regimes">regimes</code></td>
<td>
<p>A function or a list of functions.
For each decision point, a function defining the tx
rule. For example, if the tx rule is : I(eta_1 &lt; x1),
regimes is defined as
regimes &lt;- function(a,data) {as.numeric(a &lt; data$x1)}
THE LAST ARGUMENT IS ALWAYS TAKEN TO BE THE DATA.FRAME</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_fset">fSet</code></td>
<td>
<p>A function or a list of functions.
This argument allows the user to specify the subset of tx
options available to a patient or the subset of patients
that will be modeled uniquely.
see ?fSet for details</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_refit">refit</code></td>
<td>
<p>No longer used</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_iter">iter</code></td>
<td>
<p>An integer. See ?iter for details</p>
</td></tr>
<tr><td><code id="optimalSeq_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If FALSE, screen prints are suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from class OptimalSeq
</p>


<h3>References</h3>

<p>Baqun Zhang, Anastasios A. Tsiatis, Eric B. Laber &amp; Marie Davidian,
&quot;A Robust Method for Estimating Optimal Treatment Regimes&quot;,
Biometrics, 68, 1010-1018.
</p>
<p>Baqun Zhang, Anastasios A. Tsiatis, Eric B. Laber &amp; Marie Davidian,
&quot;Robust estimation of optimal treatment regimes for sequential
treatment decisions&quot;, Biometrika (2013) pp.1-14.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other multiple decision point methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# Define the propensity for treatment model and methods.
# Will use constant model for both decision points
moPropen &lt;- buildModelObj(model =  ~ 1, 
                          solver.method = 'glm', 
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))
moPropen &lt;- list(moPropen, moPropen)

# outcome model second stage
moMain2 &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                         solver.method = 'lm')

moCont2 &lt;- buildModelObj(model = ~race + parentBMI+month4BMI,
                         solver.method = 'lm')

# outcome model first stage
moMain1 &lt;- buildModelObj(model = ~parentBMI+baselineBMI,
                         solver.method = 'lm')

moCont1 &lt;- buildModelObj(model = ~race + parentBMI+baselineBMI,
                         solver.method = 'lm')

moMain &lt;- list(moMain1, moMain2)
moCont &lt;- list(moCont1, moCont2)

# regime function second stage
regime2 &lt;- function(eta1, eta2, data) {
             tst &lt;- {data$parentBMI &gt; eta1} &amp; {data$month4BMI &gt; eta2}
             rec &lt;- rep('MR', nrow(x = data))
             rec[!tst] &lt;- 'CD'
             return( rec )
           }

# regime function first stage
regime1 &lt;- function(eta1, eta2, data) {
             tst &lt;- {data$parentBMI &gt; eta1} &amp; {data$baselineBMI &gt; eta2}
             rec &lt;- rep('MR', nrow(x = data))
             rec[!tst] &lt;- 'CD'
             return( rec )
           }

regimes &lt;- list(regime1, regime2)

#### Analysis using AIPW
## Not run: 
fit_AIPW &lt;- optimalSeq(moPropen = moPropen, 
                       moMain = moMain, moCont = moCont,
                       regimes = regimes,
                       data = bmiData, response = y12,  txName = c('A1','A2'),
                       Domains = cbind(rep(0,4),rep(100,4)),
                       pop.size = 100, starting.values = rep(25,4))

##Available methods

  # Coefficients of the regression objects
  coef(object = fit_AIPW)

  # Description of method used to obtain object
  DTRstep(object = fit_AIPW)

  # Estimated value of the optimal treatment regime for training set
  estimator(x = fit_AIPW)

  # Value object returned by regression methods
  fitObject(object = fit_AIPW)

  # Retrieve the results of genetic algorithm
  genetic(object = fit_AIPW)

  # Estimated optimal treatment and decision functions for training data
  optTx(x = fit_AIPW)

  # Estimated optimal treatment and decision functions for new data
  optTx(x = fit_AIPW, newdata = bmiData)

  # Value object returned by outcome regression method
  outcome(object = fit_AIPW)

  # Plots if defined by regression methods
  dev.new()
  par(mfrow = c(2,4))

  plot(x = fit_AIPW)
  plot(x = fit_AIPW, suppress = TRUE)

  # Retrieve the value object returned by propensity regression method
  propen(object = fit_AIPW)

  # Show main results of method
  show(object = fit_AIPW)

  # Show summary results of method
  summary(object = fit_AIPW)

## End(Not run)
#### Single Decision Point Analysis using IPW

# Define the propensity for treatment model and methods.
moPropen &lt;- buildModelObj(model =  ~ 1, 
                          solver.method = 'glm', 
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

# regime function second stage
regime &lt;- function(eta1, eta2, data) {
            tst &lt;- {data$parentBMI &gt; eta1} &amp; {data$month4BMI &gt; eta2}
            rec &lt;- rep('MR', nrow(x = data))
            rec[!tst] &lt;- 'CD'
            return( rec )
          }
## Not run: 
fit_IPW &lt;- optimalSeq(moPropen = moPropen, 
                      regimes = regime,
                      data = bmiData, response = y12,  txName = 'A2',
                      Domains = cbind(rep(0,2),rep(100,2)),
                      pop.size = 100, starting.values = rep(25,2))

##Available methods

  # Coefficients of the regression objects
  coef(object = fit_IPW)

  # Description of method used to obtain object
  DTRstep(object = fit_IPW)

  # Estimated value of the optimal treatment regime for training set
  estimator(x = fit_IPW)

  # Value object returned by regression method
  fitObject(object = fit_IPW)

  # Retrieve the results of genetic algorithm
  genetic(object = fit_IPW)

  # Estimated optimal treatment and decision functions for training data
  optTx(x = fit_IPW)

  # Estimated optimal treatment and decision functions for new data
  optTx(x = fit_IPW, newdata = bmiData)

  # Value object returned by outcome regression method
  outcome(object = fit_IPW)

  # Plots if defined by outcome regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(x = fit_IPW)
  plot(x = fit_IPW, suppress = TRUE)

  # Retrieve the value object returned by propensity regression method
  propen(object = fit_IPW)

  # Show main results of method
  show(object = fit_IPW)

  # Show summary results of method
  summary(object = fit_IPW)

## End(Not run)
</code></pre>

<hr>
<h2 id='OptimalSeq-class'>Class <code>OptimalSeq</code></h2><span id='topic+OptimalSeq-class'></span>

<h3>Description</h3>

<p>Class <code>OptimalSeq</code> contains the results for the estimated optimal tx
and value when estimated from a coarsened or missing data perspective.
</p>


<h3>Slots</h3>


<dl>
<dt><code>genetic</code></dt><dd><p>A list containing the results from the genetic algorithm</p>
</dd>
<dt><code>propen</code></dt><dd><p>Results of the propensity regression step</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Results of the outcome regression step</p>
</dd>
<dt><code>regime</code></dt><dd><p>Results for the regime.</p>
</dd>
<dt><code>optimal</code></dt><dd><p>Results for the estimated optimal tx and value</p>
</dd>
<dt><code>Call</code></dt><dd><p>The unevaluated call.</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>regimeCoef</dt><dd><p>: 
Retrieve the estimated regime parameters. </p>
</dd>
</dl>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='OptimalSeq-methods'>Methods Available for Objects of Class <code>OptimalSeq</code></h2><span id='topic+OptimalSeq-methods'></span><span id='topic+print+2COptimalSeq-method'></span><span id='topic+show+2COptimalSeq-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalSeq</code>
</p>
<p><code>print(x)</code>
prints main results of a coarsened/missing data analysis
</p>
<p><code>show(object)</code>
displays main results of a coarsened/missing data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalSeq'
print(x, ...)

## S4 method for signature 'OptimalSeq'
show(object)
</code></pre>

<hr>
<h2 id='OptimalSeqCoarsened-class'>Class Contains Results for the Coarsened Data IPW/AIPW Method</h2><span id='topic+OptimalSeqCoarsened-class'></span>

<h3>Description</h3>

<p>Methods for multiple decision point analyses. Class inherits directly from
<code>OptimalSeq</code> and all methods defined for objects of class <code>OptimaSeq</code>
are defined for this class.
</p>

<hr>
<h2 id='OptimalSeqCoarsened-methods'>Methods Available for Objects of Class <code>OptimalSeqCoarsened</code></h2><span id='topic+OptimalSeqCoarsened-methods'></span><span id='topic+Call+2COptimalSeqCoarsened-method'></span><span id='topic+coef+2COptimalSeqCoarsened-method'></span><span id='topic+DTRstep+2COptimalSeqCoarsened-method'></span><span id='topic+estimator+2COptimalSeqCoarsened-method'></span><span id='topic+fitObject+2COptimalSeqCoarsened-method'></span><span id='topic+genetic+2COptimalSeqCoarsened-method'></span><span id='topic+optTx+2COptimalSeqCoarsened+2Cdata.frame-method'></span><span id='topic+optTx+2COptimalSeqCoarsened+2Cmissing-method'></span><span id='topic+outcome+2COptimalSeqCoarsened-method'></span><span id='topic+plot+2COptimalSeqCoarsened+2CANY-method'></span><span id='topic+print+2COptimalSeqCoarsened-method'></span><span id='topic+propen+2COptimalSeqCoarsened-method'></span><span id='topic+regimeCoef+2COptimalSeqCoarsened-method'></span><span id='topic+show+2COptimalSeqCoarsened-method'></span><span id='topic+summary+2COptimalSeqCoarsened-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalSeqCoarsened</code>
</p>
<p><code>Call(name)</code>
returns the unevaluated call to method
</p>
<p><code>coef(object)</code>
retrieves coefficients of model functions. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>DTRstep(x)</code>
print statement indicating the coarsened data perspective
</p>
<p><code>estimator(x)</code>
retrieves the estimated value. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>fitObject(object)</code>
retrieves value objects of model functions. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>genetic(object)</code>
retrieves genetic algorithm results. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>optTx(x,newdata)</code>
estimates optimal tx. Calls method defined for <code>OptimalSeq</code>.
</p>
<p><code>optTx(x)</code>
retrieves the optimal tx. Calls method defined for <code>OptimalSeq</code>.
</p>
<p><code>outcome(object)</code>
retrieves value object returned by outcome model functions. Calls method 
defined for <code>OptimalSeq</code>.
</p>
<p><code>plot(x,suppress)</code>
generates plot for model functions. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>print(x)</code>
Extends method defined for <code>OptimalSeq</code> to include DTRStep()
</p>
<p><code>propen(object)</code>
retrieves value object returned by propensity model functions. Calls method 
defined for <code>OptimalSeq</code>.
</p>
<p><code>regimeCoef(object)</code>
retrieves estimated tx regime parameters. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>show(object)</code>
Extends method defined for <code>OptimalSeq</code> to include DTRStep()
</p>
<p><code>summary(object)</code>
retrieves summary information. Calls method defined for <code>OptimalSeq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalSeqCoarsened'
Call(name, ...)

## S4 method for signature 'OptimalSeqCoarsened'
coef(object, ...)

## S4 method for signature 'OptimalSeqCoarsened'
DTRstep(object)

## S4 method for signature 'OptimalSeqCoarsened'
estimator(x, ...)

## S4 method for signature 'OptimalSeqCoarsened'
fitObject(object, ...)

## S4 method for signature 'OptimalSeqCoarsened'
genetic(object, ...)

## S4 method for signature 'OptimalSeqCoarsened,data.frame'
optTx(x, newdata, ..., dp = 1)

## S4 method for signature 'OptimalSeqCoarsened,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalSeqCoarsened'
outcome(object, ...)

## S4 method for signature 'OptimalSeqCoarsened,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OptimalSeqCoarsened'
print(x, ...)

## S4 method for signature 'OptimalSeqCoarsened'
propen(object, ...)

## S4 method for signature 'OptimalSeqCoarsened'
regimeCoef(object, ...)

## S4 method for signature 'OptimalSeqCoarsened'
show(object)

## S4 method for signature 'OptimalSeqCoarsened'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OptimalSeqMissing-class'>Class Contains Results for the Missing Data IPW/AIPW Method</h2><span id='topic+OptimalSeqMissing-class'></span>

<h3>Description</h3>

<p>Methods for single decision point analyses. Class inherits directly from
<code>OptimalSeq</code> and all methods defined for objects of class <code>OptimaSeq</code>
are defined for this class.
</p>

<hr>
<h2 id='OptimalSeqMissing-methods'>Methods Available for Objects of Class <code>OptimalSeqMissing</code></h2><span id='topic+OptimalSeqMissing-methods'></span><span id='topic+Call+2COptimalSeqMissing-method'></span><span id='topic+coef+2COptimalSeqMissing-method'></span><span id='topic+DTRstep+2COptimalSeqMissing-method'></span><span id='topic+estimator+2COptimalSeqMissing-method'></span><span id='topic+fitObject+2COptimalSeqMissing-method'></span><span id='topic+genetic+2COptimalSeqMissing-method'></span><span id='topic+optTx+2COptimalSeqMissing+2Cdata.frame-method'></span><span id='topic+optTx+2COptimalSeqMissing+2Cmissing-method'></span><span id='topic+outcome+2COptimalSeqMissing-method'></span><span id='topic+plot+2COptimalSeqMissing+2CANY-method'></span><span id='topic+print+2COptimalSeqMissing-method'></span><span id='topic+propen+2COptimalSeqMissing-method'></span><span id='topic+regimeCoef+2COptimalSeqMissing-method'></span><span id='topic+show+2COptimalSeqMissing-method'></span><span id='topic+summary+2COptimalSeqMissing-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimalSeqMissing</code>
</p>
<p><code>Call(name)</code>
returns the unevaluated call to method
</p>
<p>Retrieve coefficients of fits
</p>
<p><code>DTRstep(x)</code>
print statement indicating the coarsened data perspective
</p>
<p><code>estimator(x)</code>
retrieves the estimated value.  Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>fitObject(object)</code>
retrieves value objects of model functions. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>genetic(object)</code>
retrieves genetic algorithm results. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p>Predict Optimal Treatment and Decision Function Based on a 
Missing Data AIPW Analysis
</p>
<p><code>optTx(x)</code>
retrieves the optimal tx. Calls method defined for <code>OptimalSeq</code>.
</p>
<p><code>outcome(object)</code>
retrieves value object returned by outcome model functions. Calls method 
defined for <code>OptimalSeq</code>.
</p>
<p><code>plot(x,suppress)</code>
generates plot for model functions. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>print(x)</code>
Extends method defined for <code>OptimalSeq</code> to include DTRStep()
</p>
<p><code>propen(object)</code>
retrieves value object returned by propensity model functions. Calls method 
defined for <code>OptimalSeq</code>.
</p>
<p><code>regimeCoef(object)</code>
retrieves estimated tx regime parameters. Calls method defined for 
<code>OptimalSeq</code>.
</p>
<p><code>show(object)</code>
Extends method defined for <code>OptimalSeq</code> to include DTRStep()
</p>
<p><code>summary(object)</code>
retrieves summary information. Calls method defined for <code>OptimalSeq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimalSeqMissing'
Call(name, ...)

## S4 method for signature 'OptimalSeqMissing'
coef(object, ...)

## S4 method for signature 'OptimalSeqMissing'
DTRstep(object)

## S4 method for signature 'OptimalSeqMissing'
estimator(x, ...)

## S4 method for signature 'OptimalSeqMissing'
fitObject(object, ...)

## S4 method for signature 'OptimalSeqMissing'
genetic(object, ...)

## S4 method for signature 'OptimalSeqMissing,data.frame'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalSeqMissing,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimalSeqMissing'
outcome(object, ...)

## S4 method for signature 'OptimalSeqMissing,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OptimalSeqMissing'
print(x, ...)

## S4 method for signature 'OptimalSeqMissing'
propen(object, ...)

## S4 method for signature 'OptimalSeqMissing'
regimeCoef(object, ...)

## S4 method for signature 'OptimalSeqMissing'
show(object)

## S4 method for signature 'OptimalSeqMissing'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OptimBasic-class'>Class <code>OptimBasic</code></h2><span id='topic+OptimBasic-class'></span>

<h3>Description</h3>

<p>Class <code>OptimBasic</code> holds results of an optimization step when linear
kernel is used for decision function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda</code></dt><dd><p>A numeric, tuning parameter</p>
</dd>
<dt><code>optim</code></dt><dd><p>A list, value object returned by optimization method
expected optimization methods are optim and hjk</p>
</dd>
<dt><code>surrogate</code></dt><dd><p>A Surrogate object specifying loss-function surrogate</p>
</dd>
</dl>

<hr>
<h2 id='OptimBasic-methods'>Methods Available for Objects of Class <code>OptimBasic</code></h2><span id='topic+OptimBasic-methods'></span><span id='topic+optimObj+2COptimBasic-method'></span><span id='topic+.predictOptimalTx+2COptimBasic+2Cmatrix-method'></span><span id='topic+.predictOptimalTx+2COptimBasic+2Cdata.frame-method'></span><span id='topic+.predictOptimalTx+2COptimBasic+2Cmissing-method'></span><span id='topic+print+2COptimBasic-method'></span><span id='topic+regimeCoef+2COptimBasic-method'></span><span id='topic+show+2COptimBasic-method'></span><span id='topic+summary+2COptimBasic-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimBasic</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimBasic'
optimObj(object, ...)

## S4 method for signature 'OptimBasic,matrix'
.predictOptimalTx(x, newdata)

## S4 method for signature 'OptimBasic,data.frame'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimBasic,missing'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimBasic'
print(x, ...)

## S4 method for signature 'OptimBasic'
regimeCoef(object, ...)

## S4 method for signature 'OptimBasic'
show(object)

## S4 method for signature 'OptimBasic'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OptimKernel-class'>Class <code>OptimKernel</code></h2><span id='topic+OptimKernel-class'></span>

<h3>Description</h3>

<p>Class <code>OptimKernel</code> holds results of an optimization step when non-linear
kernel is used for decision function.
</p>

<hr>
<h2 id='OptimKernel-methods'>Methods Available for Objects of Class <code>OptimKernel</code></h2><span id='topic+OptimKernel-methods'></span><span id='topic+.predictOptimalTx+2COptimKernel+2Cmatrix-method'></span><span id='topic+.predictOptimalTx+2COptimKernel+2Cdata.frame-method'></span><span id='topic+.predictOptimalTx+2COptimKernel+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimKernel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimKernel,matrix'
.predictOptimalTx(x, newdata)

## S4 method for signature 'OptimKernel,data.frame'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimKernel,missing'
.predictOptimalTx(x, newdata, ...)
</code></pre>

<hr>
<h2 id='optimObj'>Extract Optimization Results</h2><span id='topic+optimObj'></span>

<h3>Description</h3>

<p>Retrieves the value object returned by the optimization method for
weighted learning methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimObj(object, ...)

## S4 method for signature 'OWL'
optimObj(object, ...)

## S4 method for signature 'RWL'
optimObj(object, ...)

## S4 method for signature 'BOWL'
optimObj(object, ...)

## S4 method for signature 'EARL'
optimObj(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimObj_+3A_object">object</code></td>
<td>
<p>A value object returned by a statistical method of DynTxRegime
that uses optimization to estimate regime parameters.</p>
</td></tr>
<tr><td><code id="optimObj_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='OptimObj-class'>Class <code>OptimObj</code></h2><span id='topic+OptimObj-class'></span>

<h3>Description</h3>

<p>Class <code>OptimObj</code> stores the optimization results under a common name
for weighted learning methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>optim</code></dt><dd><p>ANY - expected to be <code>OptimBasic</code> or <code>OptimKernel</code></p>
</dd>
</dl>

<hr>
<h2 id='OptimObj-methods'>Methods Available for Objects of Class <code>OptimObj</code></h2><span id='topic+OptimObj-methods'></span><span id='topic+optimObj+2COptimObj-method'></span><span id='topic+.predictOptimalTx+2COptimObj+2Cmatrix-method'></span><span id='topic+.predictOptimalTx+2COptimObj+2Cdata.frame-method'></span><span id='topic+.predictOptimalTx+2COptimObj+2Cmissing-method'></span><span id='topic+print+2COptimObj-method'></span><span id='topic+regimeCoef+2COptimObj-method'></span><span id='topic+show+2COptimObj-method'></span><span id='topic+summary+2COptimObj-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimObj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimObj'
optimObj(object, ...)

## S4 method for signature 'OptimObj,matrix'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimObj,data.frame'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimObj,missing'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimObj'
print(x, ...)

## S4 method for signature 'OptimObj'
regimeCoef(object, ...)

## S4 method for signature 'OptimObj'
show(object)

## S4 method for signature 'OptimObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OptimStep'>Complete Cross-Validation Step and Final Optimization</h2><span id='topic+OptimStep'></span><span id='topic+.OptimStep'></span>

<h3>Description</h3>

<p>Complete Cross-Validation Step and Final Optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.OptimStep(methodObject, lambdas, cvFolds, txVec, suppress, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OptimStep_+3A_methodobject">methodObject</code></td>
<td>
<p>Object parameters for weighted learning method</p>
</td></tr>
<tr><td><code id="OptimStep_+3A_lambdas">lambdas</code></td>
<td>
<p>tuning parameter</p>
</td></tr>
<tr><td><code id="OptimStep_+3A_cvfolds">cvFolds</code></td>
<td>
<p>number of cross-validation folds</p>
</td></tr>
<tr><td><code id="OptimStep_+3A_suppress">suppress</code></td>
<td>
<p>integer indicating screen printing preferences</p>
</td></tr>
</table>

<hr>
<h2 id='OptimStep-class'>Class <code>OptimStep</code>
Class <code>OptimStep</code> holds results of a combined cross-validation and final
optimization step for weighted learning methods.</h2><span id='topic+OptimStep-class'></span>

<h3>Description</h3>

<p>Class <code>OptimStep</code>
Class <code>OptimStep</code> holds results of a combined cross-validation and final
optimization step for weighted learning methods.
</p>

<hr>
<h2 id='OptimStep-methods'>Methods Available for Objects of Class <code>OptimStep</code></h2><span id='topic+OptimStep-methods'></span><span id='topic+Call+2COptimStep-method'></span><span id='topic+cvInfo+2COptimStep-method'></span><span id='topic+estimator+2COptimStep-method'></span><span id='topic+optimObj+2COptimStep-method'></span><span id='topic+optTx+2COptimStep+2Cmissing-method'></span><span id='topic+.predictOptimalTx+2COptimStep+2Cmatrix-method'></span><span id='topic+.predictOptimalTx+2COptimStep+2Cdata.frame-method'></span><span id='topic+.predictOptimalTx+2COptimStep+2Cmissing-method'></span><span id='topic+print+2COptimStep-method'></span><span id='topic+regimeCoef+2COptimStep-method'></span><span id='topic+show+2COptimStep-method'></span><span id='topic+summary+2COptimStep-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OptimStep</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OptimStep'
Call(name, ...)

## S4 method for signature 'OptimStep'
cvInfo(object)

## S4 method for signature 'OptimStep'
estimator(x, ...)

## S4 method for signature 'OptimStep'
optimObj(object)

## S4 method for signature 'OptimStep,missing'
optTx(x, newdata, ...)

## S4 method for signature 'OptimStep,matrix'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimStep,data.frame'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimStep,missing'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'OptimStep'
print(x, ...)

## S4 method for signature 'OptimStep'
regimeCoef(object)

## S4 method for signature 'OptimStep'
show(object)

## S4 method for signature 'OptimStep'
summary(object, ...)
</code></pre>

<hr>
<h2 id='optTx'>Extract or Estimate the Optimal Tx and Decision Functions</h2><span id='topic+optTx'></span><span id='topic+optTx+2CIQLearnFS+2Cdata.frame-method'></span><span id='topic+optTx+2CIQLearnFS+2Cmissing-method'></span>

<h3>Description</h3>

<p>If newdata is provided, the results of the statistical method are used
to estimate the decision functions and/or optimal tx. If
newdata is missing, the estimated decision functions and/or optimal tx
obtained for the original training data are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optTx(x, newdata, ...)

## S4 method for signature 'IQLearnFS,data.frame'
optTx(x, newdata, ..., y = NULL, z = NULL, dens = NULL)

## S4 method for signature 'IQLearnFS,missing'
optTx(x, newdata, ..., y = NULL, z = NULL, dens = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optTx_+3A_x">x</code></td>
<td>
<p>a DynTxRegime Object.</p>
</td></tr>
<tr><td><code id="optTx_+3A_newdata">newdata</code></td>
<td>
<p>Optional data.frame if estimates for new patients are desired.</p>
</td></tr>
<tr><td><code id="optTx_+3A_...">...</code></td>
<td>
<p>Optional additional input.</p>
</td></tr>
<tr><td><code id="optTx_+3A_y">y</code></td>
<td>
<p>Object of class IQLearnFS</p>
</td></tr>
<tr><td><code id="optTx_+3A_z">z</code></td>
<td>
<p>Object of class IQLearnFS</p>
</td></tr>
<tr><td><code id="optTx_+3A_dens">dens</code></td>
<td>
<p>one of {norm, nonpar}</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>

<hr>
<h2 id='outcome'>Retrieve Outcome Regression Analysis</h2><span id='topic+outcome'></span>

<h3>Description</h3>

<p>For statistical methods that require an outcome regression analysis,
the value object returned by the modeling function(s) is retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outcome(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outcome_+3A_object">object</code></td>
<td>
<p>A value object returned by a statistical method of DynTxRegime.</p>
</td></tr>
<tr><td><code id="outcome_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime
that use outcome regression.
</p>

<hr>
<h2 id='OutcomeIterateFit-class'>Class <code>OutcomeIterateFit</code></h2><span id='topic+OutcomeIterateFit-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeIterateFit</code> is a an outcome regression step completed
using the iterative algorithm.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fitObjC</code></dt><dd><p>Contrast Result</p>
</dd>
<dt><code>fitObjM</code></dt><dd><p>Main Effects Result</p>
</dd>
</dl>

<hr>
<h2 id='OutcomeIterateFit-methods'>Methods Available for Objects of Class <code>OutcomeIterateFit</code></h2><span id='topic+OutcomeIterateFit-methods'></span><span id='topic+coef+2COutcomeIterateFit-method'></span><span id='topic+fitObject+2COutcomeIterateFit-method'></span><span id='topic+outcome+2COutcomeIterateFit-method'></span><span id='topic+plot+2COutcomeIterateFit+2CANY-method'></span><span id='topic+predict+2COutcomeIterateFit-method'></span><span id='topic+.predictAll+2COutcomeIterateFit+2Cdata.frame-method'></span><span id='topic+print+2COutcomeIterateFit-method'></span><span id='topic+show+2COutcomeIterateFit-method'></span><span id='topic+summary+2COutcomeIterateFit-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>OutcomeSimpleFit</code>,
<code>OutcomeSimpleFit_fSet</code>, or <code>OutcomeSimpleFit_SubsetList</code>.
Exact method dispatched depends on classes of @fitObjC and @fitObjM.
When a value object is returned, it is a list.
</p>
<p><code>.predictAll(object, newdata)</code> combines the two components into a
single optimal tx and decision function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeIterateFit'
coef(object, ...)

## S4 method for signature 'OutcomeIterateFit'
fitObject(object, ...)

## S4 method for signature 'OutcomeIterateFit'
outcome(object, ...)

## S4 method for signature 'OutcomeIterateFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OutcomeIterateFit'
predict(object, ...)

## S4 method for signature 'OutcomeIterateFit,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'OutcomeIterateFit'
print(x, ...)

## S4 method for signature 'OutcomeIterateFit'
show(object)

## S4 method for signature 'OutcomeIterateFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OutcomeNoFit-class'>Class <code>OutcomeNoFit</code></h2><span id='topic+OutcomeNoFit-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeNoFit</code> designates that an outcome regression step
was not performed. This acts as a place holder for IPW based methods.
</p>

<hr>
<h2 id='OutcomeNoFit-methods'>Methods Available for Objects of Class <code>OutcomeNoFit</code></h2><span id='topic+OutcomeNoFit-methods'></span><span id='topic+.predictAll+2COutcomeNoFit+2Cdata.frame-method'></span><span id='topic+.predictMu+2COutcomeNoFit+2Cdata.frame-method'></span><span id='topic+outcome+2COutcomeNoFit-method'></span><span id='topic+coef+2COutcomeNoFit-method'></span><span id='topic+fitObject+2COutcomeNoFit-method'></span><span id='topic+plot+2COutcomeNoFit+2CANY-method'></span><span id='topic+predict+2COutcomeNoFit-method'></span><span id='topic+print+2COutcomeNoFit-method'></span><span id='topic+show+2COutcomeNoFit-method'></span><span id='topic+summary+2COutcomeNoFit-method'></span>

<h3>Description</h3>

<p>Methods return NULL, NA or zero values.
</p>
<p><code>.predictAll(object, newdata)</code> returns a list containing the optimal
tx as a vector of NA values and the decision function as a matrix of 0
</p>
<p><code>.predictMu(object, newdata)</code>
predicts outcome for all tx options.
Returns the matrix of outcomes predicted for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeNoFit,data.frame'
.predictAll(object, newdata)

## S4 method for signature 'OutcomeNoFit,data.frame'
.predictMu(object, data, ...)

## S4 method for signature 'OutcomeNoFit'
outcome(object, ...)

## S4 method for signature 'OutcomeNoFit'
coef(object, ...)

## S4 method for signature 'OutcomeNoFit'
fitObject(object, ...)

## S4 method for signature 'OutcomeNoFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OutcomeNoFit'
predict(object, ...)

## S4 method for signature 'OutcomeNoFit'
print(x, ...)

## S4 method for signature 'OutcomeNoFit'
show(object)

## S4 method for signature 'OutcomeNoFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OutcomeObj-class'>Class <code>OutcomeObj</code></h2><span id='topic+OutcomeObj-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeObj</code> groups outcome regression results under a common
name
</p>


<h3>Slots</h3>


<dl>
<dt><code>outcome</code></dt><dd><p>ANY - expected to be <code>OutcomeNoFit</code>, 
<code>OutcomeSimpleFit</code>,
<code>OutcomeSimpleFit_fSet</code>, <code>OutcomeSimpleFit_SubsetList</code>, 
<code>OutcomeIterateFit</code>, or <code>DecisionPointList</code>.</p>
</dd>
</dl>

<hr>
<h2 id='OutcomeObj-methods'>Methods Available for Objects of Class <code>OutcomeObj</code></h2><span id='topic+OutcomeObj-methods'></span><span id='topic+coef+2COutcomeObj-method'></span><span id='topic+fitObject+2COutcomeObj-method'></span><span id='topic+outcome+2COutcomeObj-method'></span><span id='topic+plot+2COutcomeObj+2CANY-method'></span><span id='topic+.predictAll+2COutcomeObj+2Cdata.frame-method'></span><span id='topic+.predictMu+2COutcomeObj+2Cdata.frame-method'></span><span id='topic+predict+2COutcomeObj-method'></span><span id='topic+print+2COutcomeObj-method'></span><span id='topic+show+2COutcomeObj-method'></span><span id='topic+summary+2COutcomeObj-method'></span>

<h3>Description</h3>

<p>Most value objects returned are a list with one element 'outcome'.
Methods dispatched and objects returned in the element 'outcome'
depend on class of @outcome.
Exceptions are noted below.
</p>
<p><code>outcome(object)</code> does not return the overarching list
structure, but only the contents of list[[ outcome ]].
</p>
<p><code>plot(x)</code> concatenated 'outcome' to the title if suppress = FALSE.
</p>
<p><code>.predictAll(object, newdata)</code> does not return the overarching list
structure, but only the contents of list[[ outcome ]].
</p>
<p><code>.predictMu(object, newdata)</code>
predicts outcome for all tx options.
Returns the matrix of outcomes predicted for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>
<p><code>predict(object)</code> does not return the overarching list
structure, but only the contents of list[[ outcome ]].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeObj'
coef(object, ...)

## S4 method for signature 'OutcomeObj'
fitObject(object, ...)

## S4 method for signature 'OutcomeObj'
outcome(object, ...)

## S4 method for signature 'OutcomeObj,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OutcomeObj,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'OutcomeObj,data.frame'
.predictMu(object, data, ...)

## S4 method for signature 'OutcomeObj'
predict(object, ...)

## S4 method for signature 'OutcomeObj'
print(x, ...)

## S4 method for signature 'OutcomeObj'
show(object)

## S4 method for signature 'OutcomeObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='OutcomeSimpleFit_fSet-class'>Class <code>OutcomeSimpleFit_fSet</code></h2><span id='topic+OutcomeSimpleFit_fSet-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeSimpleFit_fSet</code> is a <code>TypedFit_fSet</code> identified as
being for an outcome regression step.
</p>

<hr>
<h2 id='OutcomeSimpleFit_fSet-methods'>Methods Available for Objects of Class <code>OutcomeSimpleFit_fSet</code></h2><span id='topic+OutcomeSimpleFit_fSet-methods'></span><span id='topic+outcome+2COutcomeSimpleFit_fSet-method'></span><span id='topic+.predictAll+2COutcomeSimpleFit_fSet+2Cdata.frame-method'></span><span id='topic+.predictMu+2COutcomeSimpleFit_fSet+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit_fSet</code>
</p>
<p><code>.predictAll(object, newdata)</code>
predicts outcome for all tx options.
Returns a list containing 'optimalTx' the tx yielding the largest 
predicted outcome and 'decisionFunc' the matrix of outcomes predicted
for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>
<p><code>.predictMu(object, newdata)</code>
predicts outcome for all tx options.
Returns the matrix of outcomes predicted for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeSimpleFit_fSet'
outcome(object, ...)

## S4 method for signature 'OutcomeSimpleFit_fSet,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'OutcomeSimpleFit_fSet,data.frame'
.predictMu(object, data, ...)
</code></pre>

<hr>
<h2 id='OutcomeSimpleFit_SubsetList-class'>Class <code>OutcomeSimpleFit_SubsetList</code></h2><span id='topic+OutcomeSimpleFit_SubsetList-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeSimpleFit_SubsetList</code> is a <code>TypedFit_SubsetList</code> 
identified as being for an outcome regression step.
</p>

<hr>
<h2 id='OutcomeSimpleFit_SubsetList-methods'>Methods Available for Objects of Class <code>OutcomeSimpleFit_SubsetList</code></h2><span id='topic+OutcomeSimpleFit_SubsetList-methods'></span><span id='topic+outcome+2COutcomeSimpleFit_SubsetList-method'></span><span id='topic+predict+2COutcomeSimpleFit_SubsetList-method'></span><span id='topic+.predictAll+2COutcomeSimpleFit_SubsetList+2Cdata.frame-method'></span><span id='topic+.predictMu+2COutcomeSimpleFit_SubsetList+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit_SubsetList</code>
</p>
<p><code>.predictAll(object, newdata)</code>
predicts outcome for all tx options.
Returns a list containing 'optimalTx' the tx yielding the largest 
predicted outcome and 'decisionFunc' the matrix of outcomes predicted
for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>
<p><code>.predictMu(object, data)</code>
predicts outcome for all tx options.
Returns the matrix of outcomes predicted for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeSimpleFit_SubsetList'
outcome(object, ...)

## S4 method for signature 'OutcomeSimpleFit_SubsetList'
predict(object, newdata, ...)

## S4 method for signature 'OutcomeSimpleFit_SubsetList,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'OutcomeSimpleFit_SubsetList,data.frame'
.predictMu(object, data, ...)
</code></pre>

<hr>
<h2 id='OutcomeSimpleFit-class'>Class <code>OutcomeSimpleFit</code></h2><span id='topic+OutcomeSimpleFit-class'></span>

<h3>Description</h3>

<p>Class <code>OutcomeSimpleFit</code> is a <code>TypedFit</code> identified as being
for an outcome regression step.
</p>

<hr>
<h2 id='OutcomeSimpleFit-methods'>Methods Available for Objects of Class <code>OutcomeSimpleFit</code></h2><span id='topic+OutcomeSimpleFit-methods'></span><span id='topic+coef+2COutcomeSimpleFit-method'></span><span id='topic+fitObject+2COutcomeSimpleFit-method'></span><span id='topic+outcome+2COutcomeSimpleFit-method'></span><span id='topic+plot+2COutcomeSimpleFit+2CANY-method'></span><span id='topic+predict+2COutcomeSimpleFit-method'></span><span id='topic+.predictAll+2COutcomeSimpleFit+2Cdata.frame-method'></span><span id='topic+.predictMu+2COutcomeSimpleFit+2Cdata.frame-method'></span><span id='topic+print+2COutcomeSimpleFit-method'></span><span id='topic+show+2COutcomeSimpleFit-method'></span><span id='topic+summary+2COutcomeSimpleFit-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit</code>
</p>
<p><code>.predictAll(object, newdata)</code>
predicts outcome for all tx options.
Returns a list containing 'optimalTx' the tx yielding the largest 
predicted outcome and 'decisionFunc' the matrix of outcomes predicted
for all tx.
</p>
<p><code>.predictMu(object, newdata)</code>
predicts outcome for all tx options.
Returns the matrix of outcomes predicted for all tx. 
Predicted outcomes for tx not available to a pt are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutcomeSimpleFit'
coef(object, ...)

## S4 method for signature 'OutcomeSimpleFit'
fitObject(object, ...)

## S4 method for signature 'OutcomeSimpleFit'
outcome(object, ...)

## S4 method for signature 'OutcomeSimpleFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'OutcomeSimpleFit'
predict(object, ...)

## S4 method for signature 'OutcomeSimpleFit,data.frame'
.predictAll(object, newdata)

## S4 method for signature 'OutcomeSimpleFit,data.frame'
.predictMu(object, data, ...)

## S4 method for signature 'OutcomeSimpleFit'
print(x, ...)

## S4 method for signature 'OutcomeSimpleFit'
show(object)

## S4 method for signature 'OutcomeSimpleFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='owl'>Outcome Weighted Learning</h2><span id='topic+owl'></span>

<h3>Description</h3>

<p>Outcome Weighted Learning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>owl(
  ...,
  moPropen,
  data,
  reward,
  txName,
  regime,
  response,
  lambdas = 2,
  cvFolds = 0L,
  kernel = "linear",
  kparam = NULL,
  surrogate = "hinge",
  verbose = 2L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="owl_+3A_...">...</code></td>
<td>
<p>Used primarily to require named input. However, inputs for
the optimization methods can be sent through the ellipsis. If surrogate
is hinge, the optimization method is kernlab::ipop(). For all other 
surrogates, stats::optim() is used.</p>
</td></tr>
<tr><td><code id="owl_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj, which defines the model and
R methods to be used to obtain parameter estimates and
predictions for the propensity for treatment.
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="owl_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx histories</p>
</td></tr>
<tr><td><code id="owl_+3A_reward">reward</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="owl_+3A_txname">txName</code></td>
<td>
<p>A character object.
The column header of <em>data</em> that corresponds to the tx covariate</p>
</td></tr>
<tr><td><code id="owl_+3A_regime">regime</code></td>
<td>
<p>A formula object or a character vector.
The covariates to be included in classification</p>
</td></tr>
<tr><td><code id="owl_+3A_response">response</code></td>
<td>
<p>A numeric vector.
The reward. Allows for naming convention followed in most
DynTxRegime methods.</p>
</td></tr>
<tr><td><code id="owl_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric object or a numeric vector object giving the
penalty tuning parameter. If more than 1 is provided,
the finite set of values to be considered in the
cross-validation algorithm</p>
</td></tr>
<tr><td><code id="owl_+3A_cvfolds">cvFolds</code></td>
<td>
<p>If cross-validation is to be used to select the tuning
parameters, the number of folds.</p>
</td></tr>
<tr><td><code id="owl_+3A_kernel">kernel</code></td>
<td>
<p>A character object.
must be one of {&quot;linear&quot;, &quot;poly&quot;, &quot;radial&quot;}</p>
</td></tr>
<tr><td><code id="owl_+3A_kparam">kparam</code></td>
<td>
<p>A numeric object of NULL.
If kernel = linear, kparam is ignored.
If kernel = poly, kparam is the degree of the polynomial
If kernel = radial, kparam is the inverse bandwidth of the
kernel. If a vector of bandwidth parameters is given,
cross-validation will be used to select the parameter</p>
</td></tr>
<tr><td><code id="owl_+3A_surrogate">surrogate</code></td>
<td>
<p>The surrogate 0-1 loss function must be one of
logit, exp, hinge, sqhinge, huber</p>
</td></tr>
<tr><td><code id="owl_+3A_verbose">verbose</code></td>
<td>
<p>An integer or logical. If 0, no screen prints are generated. If 1,
screen prints are generated with the exception of optimization results
obtained in iterative algorithm. If 2, all screen prints are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an OWL object
</p>


<h3>References</h3>

<p>Yingqi Zhao, Donglin Zeng, A. John Rush,
Michael R. Kosorok (2012)
Estimated individualized treatment rules using outcome weighted
learning. Journal of the American Statistical Association,
107(409): 1106-1118. PMCID: 3636816
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other weighted learning methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# propensity model
moPropen &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                          solver.method = 'glm',
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

fitOWL &lt;- owl(moPropen = moPropen,
              data = bmiData, reward = y12,  txName = 'A2', 
              regime = ~ parentBMI + month4BMI,
              surrogate = 'hinge', kernel = 'linear', kparam = NULL)

##Available methods

  # Coefficients of the propensity score regression
  coef(fitOWL)

  # Description of method used to obtain object
  DTRstep(fitOWL)

  # Estimated value of the optimal treatment regime for training set
  estimator(fitOWL)

  # Value object returned by propensity score regression method
  fitObject(fitOWL)

  # Summary of optimization routine
  optimObj(fitOWL)

  # Estimated optimal treatment for training data
  optTx(fitOWL)

  # Estimated optimal treatment for new data
  optTx(fitOWL, bmiData)

  # Plots if defined by propensity regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(fitOWL)
  plot(fitOWL, suppress = TRUE)

  # Value object returned by propensity score regression method
  propen(fitOWL)

  # Parameter estimates for decision function
  regimeCoef(fitOWL)

  # Show main results of method
  show(fitOWL)

  # Show summary results of method
  summary(fitOWL)
 
</code></pre>

<hr>
<h2 id='OWL-class'>Class <code>OWL</code></h2><span id='topic+OWL-class'></span>

<h3>Description</h3>

<p>Class <code>OWL</code> contains results for an OWL analysis.
</p>


<h3>Slots</h3>


<dl>
<dt><code>analysis</code></dt><dd><p>Contains a Learning or LearningMulti object.</p>
</dd>
<dt><code>analysis@txInfo</code></dt><dd><p>Feasible tx information.</p>
</dd>
<dt><code>analysis@propen</code></dt><dd><p>Propensity regression analysis.</p>
</dd>
<dt><code>analysis@outcome</code></dt><dd><p>Outcome regression analysis.</p>
</dd>
<dt><code>analysis@cvInfo</code></dt><dd><p>Cross-validation analysis if single regime.</p>
</dd>
<dt><code>analysis@optim</code></dt><dd><p>Optimization analysis if single regime.</p>
</dd>
<dt><code>analysis@optimResult</code></dt><dd><p>list of cross-validation and optimization results
if multiple regimes. optimResult[[i]]@cvInfo and optimResult[[i]]@optim.</p>
</dd>
<dt><code>analysis@optimal</code></dt><dd><p>Estimated optimal Tx and value.</p>
</dd>
<dt><code>analysis@call</code></dt><dd><p>Unevaluated call to statistical method.</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Post-Processing of Optimization Analysis</h3>


<dl>
<dt>cvInfo</dt><dd><p>: 
Retrieve cross-validation results.  </p>
</dd>
<dt>optimObj</dt><dd><p>: 
Retrieve value object returned by optimization method(s).  </p>
</dd>
<dt>regimeCoef</dt><dd><p>: 
Retrieve estimated parameters for optimal tx regime.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='OWL-methods'>Methods Available for Objects of Class <code>OWL</code></h2><span id='topic+OWL-methods'></span><span id='topic+print+2COWL-method'></span><span id='topic+show+2COWL-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>OWL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OWL'
print(x, ...)

## S4 method for signature 'OWL'
show(object)
</code></pre>

<hr>
<h2 id='plot'>Generates Plots as Defined by Modeling Functions</h2><span id='topic+plot'></span>

<h3>Description</h3>

<p>Calls plot() method for all regression steps of a statistical method
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>Value object returned by a statistical method</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="plot_+3A_suppress">suppress</code></td>
<td>
<p>T/F indicating if titles should be concatenated with
information indicating the specific regression step</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Optional additional inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>

<hr>
<h2 id='PolyKernel-class'>Class <code>PolyKernel</code></h2><span id='topic+PolyKernel-class'></span>

<h3>Description</h3>

<p>Class <code>PolyKernel</code> holds information regarding decision function 
when kernel is polynomial
</p>

<hr>
<h2 id='PolyKernel-methods'>Methods Available for Objects of Class <code>PolyKernel</code></h2><span id='topic+PolyKernel-methods'></span><span id='topic+.kernel+2CPolyKernel+2Cmatrix+2Cmatrix-method'></span><span id='topic+print+2CPolyKernel-method'></span><span id='topic+show+2CPolyKernel-method'></span><span id='topic+summary+2CPolyKernel-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>PolyKernel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PolyKernel,matrix,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'PolyKernel'
print(x, ...)

## S4 method for signature 'PolyKernel'
show(object)

## S4 method for signature 'PolyKernel'
summary(object, ...)
</code></pre>

<hr>
<h2 id='propen'>Retrieve Propensity Regression Analysis</h2><span id='topic+propen'></span>

<h3>Description</h3>

<p>For statistical methods that require a propensity regression analysis,
the value object returned by the modeling function(s) is retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propen(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propen_+3A_object">object</code></td>
<td>
<p>A value object returned by a statistical method of DynTxRegime.</p>
</td></tr>
<tr><td><code id="propen_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime
that use propensity regression.
</p>

<hr>
<h2 id='PropensityFit_fSet-class'>Class <code>PropensityFit_fSet</code></h2><span id='topic+PropensityFit_fSet-class'></span>

<h3>Description</h3>

<p>Class <code>PropensityFit_fSet</code> is a <code>TypedFit_fSet</code> identified as being
for a propensity regression step.
</p>


<h3>Slots</h3>


<dl>
<dt><code>small</code></dt><dd><p>A logical TRUE indicates that the smallest valued tx is
missing; FALSE indicates that the largest valued tx is missing</p>
</dd>
<dt><code>levs</code></dt><dd><p>A vector; the set of treatment options included in fit.</p>
</dd>
</dl>

<hr>
<h2 id='PropensityFit_fSet-methods'>Methods Available for Objects of Class <code>PropensityFit_fSet</code></h2><span id='topic+PropensityFit_fSet-methods'></span><span id='topic+coef+2CPropensityFit_fSet-method'></span><span id='topic+fitObject+2CPropensityFit_fSet-method'></span><span id='topic+.predictAll+2CPropensityFit_fSet+2Cdata.frame-method'></span><span id='topic+propen+2CPropensityFit_fSet-method'></span><span id='topic+summary+2CPropensityFit_fSet-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit_fSet</code>
</p>
<p><code>.predictAll(object, newdata)</code>
predicts propensity for all tx options.
Returns a matrix of propensities predicted for all tx. 
Tx options not available to a pt are coded as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PropensityFit_fSet'
coef(object, ...)

## S4 method for signature 'PropensityFit_fSet'
fitObject(object, ...)

## S4 method for signature 'PropensityFit_fSet,data.frame'
.predictAll(object, newdata, suppress = TRUE)

## S4 method for signature 'PropensityFit_fSet'
propen(object, ...)

## S4 method for signature 'PropensityFit_fSet'
summary(object, ...)
</code></pre>

<hr>
<h2 id='PropensityFit_SubsetList-class'>Class <code>PropensityFit_SubsetList</code></h2><span id='topic+PropensityFit_SubsetList-class'></span>

<h3>Description</h3>

<p>Class <code>PropensityFit_SubsetList</code> is a <code>TypedFit_SubsetList</code> 
identified as being for a propensity regression step.
</p>


<h3>Slots</h3>


<dl>
<dt><code>small</code></dt><dd><p>A logical vector TRUE indicates that the smallest valued tx is
missing; FALSE indicates that the largest valued tx is missing</p>
</dd>
<dt><code>levs</code></dt><dd><p>A list; the set of treatment options included in each fit.</p>
</dd>
</dl>

<hr>
<h2 id='PropensityFit_SubsetList-methods'>Methods Available for Objects of Class <code>PropensityFit_SubsetList</code></h2><span id='topic+PropensityFit_SubsetList-methods'></span><span id='topic+coef+2CPropensityFit_SubsetList-method'></span><span id='topic+fitObject+2CPropensityFit_SubsetList-method'></span><span id='topic+.predictAll+2CPropensityFit_SubsetList+2Cdata.frame-method'></span><span id='topic+propen+2CPropensityFit_SubsetList-method'></span><span id='topic+summary+2CPropensityFit_SubsetList-method'></span>

<h3>Description</h3>

<p>Most methods call equivalently named methods defined for 
<code>TypedFit_SubsetList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PropensityFit_SubsetList'
coef(object, ...)

## S4 method for signature 'PropensityFit_SubsetList'
fitObject(object, ...)

## S4 method for signature 'PropensityFit_SubsetList,data.frame'
.predictAll(object, newdata, suppress = TRUE)

## S4 method for signature 'PropensityFit_SubsetList'
propen(object, ...)

## S4 method for signature 'PropensityFit_SubsetList'
summary(object, ...)
</code></pre>

<hr>
<h2 id='PropensityFit-class'>Class <code>PropensityFit</code></h2><span id='topic+PropensityFit-class'></span>

<h3>Description</h3>

<p>Class <code>PropensityFit</code> is a <code>TypedFit</code> identified as being
for a propensity regression step.
</p>


<h3>Slots</h3>


<dl>
<dt><code>small</code></dt><dd><p>A logical TRUE indicates that the smallest valued tx is
missing; FALSE indicates that the largest valued tx is missing</p>
</dd>
<dt><code>levs</code></dt><dd><p>A vector; the set of treatment options included in fit.</p>
</dd>
</dl>

<hr>
<h2 id='PropensityFit-methods'>Methods Available for Objects of Class <code>PropensityFit</code></h2><span id='topic+PropensityFit-methods'></span><span id='topic+coef+2CPropensityFit-method'></span><span id='topic+fitObject+2CPropensityFit-method'></span><span id='topic+plot+2CPropensityFit+2CANY-method'></span><span id='topic+predict+2CPropensityFit-method'></span><span id='topic+.predictAll+2CPropensityFit+2Cdata.frame-method'></span><span id='topic+print+2CPropensityFit-method'></span><span id='topic+propen+2CPropensityFit-method'></span><span id='topic+show+2CPropensityFit-method'></span><span id='topic+summary+2CPropensityFit-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit</code>
</p>
<p><code>.predictAll(object, newdata)</code>
predicts propensity for all tx options.
Returns a matrix of propensities predicted for all tx.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PropensityFit'
coef(object, ...)

## S4 method for signature 'PropensityFit'
fitObject(object, ...)

## S4 method for signature 'PropensityFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'PropensityFit'
predict(object, ...)

## S4 method for signature 'PropensityFit,data.frame'
.predictAll(object, newdata, suppress = TRUE)

## S4 method for signature 'PropensityFit'
print(x, ...)

## S4 method for signature 'PropensityFit'
propen(object, ...)

## S4 method for signature 'PropensityFit'
show(object)

## S4 method for signature 'PropensityFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='PropensityObj-class'>Class <code>PropensityObj</code></h2><span id='topic+PropensityObj-class'></span>

<h3>Description</h3>

<p>Class <code>PropensityObj</code> groups Propensity regression results under a 
common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Propensity</code></dt><dd><p>ANY - expected to be <code>PropensityFit</code>,
<code>PropensityFit_fSet</code>, <code>PropensityFit_SubsetList</code>, 
or <code>DecisionPointList</code>.</p>
</dd>
</dl>

<hr>
<h2 id='PropensityObj-methods'>Methods Available for Objects of Class <code>PropensityObj</code></h2><span id='topic+PropensityObj-methods'></span><span id='topic+coef+2CPropensityObj-method'></span><span id='topic+fitObject+2CPropensityObj-method'></span><span id='topic+plot+2CPropensityObj+2CANY-method'></span><span id='topic+.predictAll+2CPropensityObj+2Cdata.frame-method'></span><span id='topic+predict+2CPropensityObj-method'></span><span id='topic+print+2CPropensityObj-method'></span><span id='topic+propen+2CPropensityObj-method'></span><span id='topic+show+2CPropensityObj-method'></span><span id='topic+summary+2CPropensityObj-method'></span>

<h3>Description</h3>

<p>Most value objects returned are a list with one element 'propen'.
Methods dispatched and objects returned in the element 'propen'
depend on class of @propen.
Exceptions are noted below.
</p>
<p><code>plot(x)</code> concatenates 'Propensity' to the title if suppress = FALSE.
</p>
<p><code>.predictAll(object, newdata)</code> does not return the overarching list
structure, but only the contents of list[[ propen ]].
</p>
<p><code>predict(object)</code> does not return the overarching list
structure, but only the contents of list[[ propen ]].
</p>
<p><code>propen(object)</code> does not return the overarching list
structure, but only the contents of list[[ propen ]].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PropensityObj'
coef(object, ...)

## S4 method for signature 'PropensityObj'
fitObject(object, ...)

## S4 method for signature 'PropensityObj,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'PropensityObj,data.frame'
.predictAll(object, newdata, ...)

## S4 method for signature 'PropensityObj'
predict(object, ...)

## S4 method for signature 'PropensityObj'
print(x, ...)

## S4 method for signature 'PropensityObj'
propen(object, ...)

## S4 method for signature 'PropensityObj'
show(object)

## S4 method for signature 'PropensityObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='qLearn'>A Step of the Q-Learning Algorithm</h2><span id='topic+qLearn'></span>

<h3>Description</h3>

<p>Performs a single step of the Q-Learning algorithm.
If an object of class <code>QLearn</code> is passed through input response, 
it is assumed that the <code>QLearn</code> object is the value object returned
from the preceding step of the Q-Learning algorithm, and
the value fit by the regression is taken from the <code>QLearn</code> object.
If a vector is passed through input response, it is assumed that the
call if for the first step in the Q-Learning algorithm, and 
models are fit using the provided response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qLearn(
  ...,
  moMain,
  moCont,
  data,
  response,
  txName,
  fSet = NULL,
  iter = 0L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qLearn_+3A_...">...</code></td>
<td>
<p>ignored. Provided to require named inputs.</p>
</td></tr>
<tr><td><code id="qLearn_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj or a list of objects of class
modelObjSubset, which define the models and R methods to be used to
obtain parameter estimates and predictions for the main effects component 
of the outcome regression. <br />
See ?modelObj and/or ?modelObjSubset for details. <br />
NULL is an acceptable value if moCont is defined.</p>
</td></tr>
<tr><td><code id="qLearn_+3A_mocont">moCont</code></td>
<td>
<p>An object of class modelObj or a list of objects of class
modelObjSubset, which define the models and R methods to be used to 
obtain parameter estimates and predictions for the contrasts component 
of the outcome regression. <br />
See ?modelObj and/or ?modelObjSubset for details. <br />
NULL is an acceptable value if moMain is defined.</p>
</td></tr>
<tr><td><code id="qLearn_+3A_data">data</code></td>
<td>
<p>A data frame of covariates and treatment history.</p>
</td></tr>
<tr><td><code id="qLearn_+3A_response">response</code></td>
<td>
<p>A response vector or object of class QLearn from a previous
Q-Learning step.</p>
</td></tr>
<tr><td><code id="qLearn_+3A_txname">txName</code></td>
<td>
<p>A character string giving column header of treatment variable
in data</p>
</td></tr>
<tr><td><code id="qLearn_+3A_fset">fSet</code></td>
<td>
<p>NULL or a function. This argument allows the user to specify 
the subset of treatment options available to a patient. 
See ?fSet for details of allowed structure</p>
</td></tr>
<tr><td><code id="qLearn_+3A_iter">iter</code></td>
<td>
<p>An integer. See ?iter for details</p>
</td></tr>
<tr><td><code id="qLearn_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If TRUE, screen prints are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+QLearn-class">QLearn-class</a>
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>
<p>Other multiple decision point methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+rwl">rwl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+month4BMI,
                        solver.method = 'lm')

#### Second-Stage Analysis
fitSS &lt;- qLearn(moMain = moMain, moCont = moCont,
                data = bmiData, response = y12,  txName = 'A2')

##Available methods

  # Coefficients of the outcome regression objects
  coef(fitSS)

  # Description of method used to obtain object
  DTRstep(fitSS)

  # Estimated value of the optimal treatment regime for training set
  estimator(fitSS)

  # Value object returned by outcome regression method
  fitObject(fitSS)

  # Estimated optimal treatment and decision functions for training data
  optTx(fitSS)

  # Estimated optimal treatment and decision functions for new data
  optTx(fitSS, bmiData)

  # Value object returned by outcome regression method
  outcome(fitSS)

  # Plots if defined by outcome regression method
  dev.new()
  par(mfrow = c(2,4))

  plot(fitSS)
  plot(fitSS, suppress = TRUE)

  # Show main results of method
  show(fitSS)

  # Show summary results of method
  summary(fitSS)
 
#### First-stage Analysis

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+baselineBMI,
                        solver.method = 'lm')

moCont &lt;- buildModelObj(model = ~race + parentBMI+baselineBMI,
                        solver.method = 'lm')

fitFS &lt;- qLearn(moMain = moMain, moCont = moCont,
                data = bmiData, response = fitSS,  txName = 'A1')

##Available methods for fitFS are as shown above for fitSS

</code></pre>

<hr>
<h2 id='QLearn-class'>Class <code>QLearn</code></h2><span id='topic+QLearn-class'></span>

<h3>Description</h3>

<p>Class <code>QLearn</code> contains the results for a Q-Learning step
</p>


<h3>Slots</h3>


<dl>
<dt><code>step</code></dt><dd><p>An integer indicating the step of the Q-Learning algorithm.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='QLearnObj-class'>Class <code>QLearnObj</code></h2><span id='topic+QLearnObj-class'></span>

<h3>Description</h3>

<p>Class <code>QLearnObj</code> contains the results for a Q-Learning step
</p>


<h3>Slots</h3>


<dl>
<dt><code>outcome</code></dt><dd><p>The outcome regression analysis</p>
</dd>
<dt><code>txInfo</code></dt><dd><p>The feasible tx information</p>
</dd>
<dt><code>optimal</code></dt><dd><p>The estimated optimal tx, decision function, and value</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='RadialKernel-class'>Class <code>RadialKernel</code></h2><span id='topic+RadialKernel-class'></span>

<h3>Description</h3>

<p>Class <code>RadialKernel</code> holds information regarding decision function 
when kernel is radial
</p>

<hr>
<h2 id='RadialKernel-methods'>Methods Available for Objects of Class <code>RadialKernel</code></h2><span id='topic+RadialKernel-methods'></span><span id='topic+.kernel+2CRadialKernel+2Cmatrix+2Cmatrix-method'></span><span id='topic+print+2CRadialKernel-method'></span><span id='topic+show+2CRadialKernel-method'></span><span id='topic+summary+2CRadialKernel-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>RadialKernel</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RadialKernel,matrix,matrix'
.kernel(object, x1, x2, ...)

## S4 method for signature 'RadialKernel'
print(x, ...)

## S4 method for signature 'RadialKernel'
show(object)

## S4 method for signature 'RadialKernel'
summary(object, ...)
</code></pre>

<hr>
<h2 id='Regime-class'>Class <code>Regime</code></h2><span id='topic+Regime-class'></span>

<h3>Description</h3>

<p>Class <code>Regime</code> holds information regarding regimes communicated 
through functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nVars</code></dt><dd><p>An integer. The number of parameters to be estimated</p>
</dd>
<dt><code>vNames</code></dt><dd><p>A character. The names of the parameters to be estimated</p>
</dd>
<dt><code>func</code></dt><dd><p>A function. The user specified function that defines the regime</p>
</dd>
<dt><code>pars</code></dt><dd><p>A numeric. The estimated parameters</p>
</dd>
</dl>

<hr>
<h2 id='Regime-methods'>Methods Available for Objects of Class <code>Regime</code></h2><span id='topic+Regime-methods'></span><span id='topic+.getNumPars+2CRegime-method'></span><span id='topic+.getParNames+2CRegime-method'></span><span id='topic+.getPars+2CRegime-method'></span><span id='topic+.getRegimeFunction+2CRegime-method'></span><span id='topic+.predictOptimalTx+2CRegime+2Cdata.frame-method'></span><span id='topic+print+2CRegime-method'></span><span id='topic+regimeCoef+2CRegime-method'></span><span id='topic+.setPars+2CRegime+2Cnumeric-method'></span><span id='topic+show+2CRegime-method'></span><span id='topic+summary+2CRegime-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>Regime</code>
</p>
<p><code>.getNumPars</code>
retrieves the number of parameters in the regime to be estimated.
</p>
<p><code>.getParNames</code>
retrieves the parameter names in the regime.
</p>
<p><code>.getPars</code>
retrieves current estimates for regime parameters.
</p>
<p><code>.getRegimeFunction</code>
retrieves the user specified function definition of the regime.
</p>
<p><code>.predictOptimalTx</code>
executes user specified function using current estimated parameters and
provided data to determine recommended tx.
</p>
<p><code>print</code>
prints the current estimates for the regime parameters.
</p>
<p><code>regimeCoef</code>
retrieves the current estimates for the regime parameters
</p>
<p><code>.setPars</code>
sets the parameter estimates to the provided values.
</p>
<p><code>show</code>
displays the current estimates for the regime parameters.
</p>
<p><code>summary</code>
retrieves the current estimates for the regime parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Regime'
.getNumPars(object)

## S4 method for signature 'Regime'
.getParNames(object)

## S4 method for signature 'Regime'
.getPars(object)

## S4 method for signature 'Regime'
.getRegimeFunction(object)

## S4 method for signature 'Regime,data.frame'
.predictOptimalTx(x, newdata, ...)

## S4 method for signature 'Regime'
print(x, ...)

## S4 method for signature 'Regime'
regimeCoef(object, ...)

## S4 method for signature 'Regime,numeric'
.setPars(object, pars)

## S4 method for signature 'Regime'
show(object)

## S4 method for signature 'Regime'
summary(object, ...)
</code></pre>

<hr>
<h2 id='regimeCoef'>Extract Regime Parameters</h2><span id='topic+regimeCoef'></span>

<h3>Description</h3>

<p>Extract the estimated regime parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regimeCoef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regimeCoef_+3A_object">object</code></td>
<td>
<p>A value object returned by a statistical method of DynTxRegime.</p>
</td></tr>
<tr><td><code id="regimeCoef_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime
that use a non-regression based regime. Specifically, OptimalSeq, OWL,
BOWL, RWL, and EARL.
</p>

<hr>
<h2 id='RegimeObj-class'>Class <code>RegimeObj</code></h2><span id='topic+RegimeObj-class'></span>

<h3>Description</h3>

<p>Class <code>RegimeObj</code> holds information regarding regimes communicated 
through functions under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>regime</code></dt><dd><p>ANY expected to be <code>Regime</code> or <code>DecisionPointList</code></p>
</dd>
</dl>

<hr>
<h2 id='RegimeObj-methods'>Methods Available for Objects of Class <code>RegimeObj</code></h2><span id='topic+RegimeObj-methods'></span><span id='topic+.getNumPars+2CRegimeObj-method'></span><span id='topic+.getParNames+2CRegimeObj-method'></span><span id='topic+.getPars+2CRegimeObj-method'></span><span id='topic+.getRegimeFunction+2CRegimeObj-method'></span><span id='topic+.predictOptimalTx+2CRegimeObj+2Cdata.frame-method'></span><span id='topic+print+2CRegimeObj-method'></span><span id='topic+regimeCoef+2CRegimeObj-method'></span><span id='topic+.setPars+2CRegimeObj+2Cnumeric-method'></span><span id='topic+show+2CRegimeObj-method'></span><span id='topic+summary+2CRegimeObj-method'></span>

<h3>Description</h3>

<p>Methods dispatch equivalantly named functions defined for Regime or
DecisionPointList objects. Method dispatched dictated by object stored
in @regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RegimeObj'
.getNumPars(object)

## S4 method for signature 'RegimeObj'
.getParNames(object)

## S4 method for signature 'RegimeObj'
.getPars(object)

## S4 method for signature 'RegimeObj'
.getRegimeFunction(object)

## S4 method for signature 'RegimeObj,data.frame'
.predictOptimalTx(x, newdata, dp = 1L, ...)

## S4 method for signature 'RegimeObj'
print(x, ...)

## S4 method for signature 'RegimeObj'
regimeCoef(object, ...)

## S4 method for signature 'RegimeObj,numeric'
.setPars(object, pars)

## S4 method for signature 'RegimeObj'
show(object)

## S4 method for signature 'RegimeObj'
summary(object, ...)
</code></pre>

<hr>
<h2 id='residuals'>Extract Model Residuals</h2><span id='topic+residuals'></span><span id='topic+residuals+2CIQLearnFS_C-method'></span><span id='topic+residuals+2CIQLearnFS_VHet-method'></span>

<h3>Description</h3>

<p>Retrieve residuals from an interactive Q-Learning step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals(object, ...)

## S4 method for signature 'IQLearnFS_C'
residuals(object, ...)

## S4 method for signature 'IQLearnFS_VHet'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>A value object returned by iqLearnC() or iqLearnVar()</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='rwl'>Residual Weighted Learning</h2><span id='topic+rwl'></span>

<h3>Description</h3>

<p>Residual Weighted Learning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwl(
  ...,
  moPropen,
  moMain,
  data,
  reward,
  txName,
  regime,
  response,
  fSet = NULL,
  lambdas = 2,
  cvFolds = 0L,
  kernel = "linear",
  kparam = NULL,
  responseType = "continuous",
  verbose = 2L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwl_+3A_...">...</code></td>
<td>
<p>Used primarily to require named input. However, inputs for
the optimization methods can be sent through the ellipsis. The
optimization method is stats::optim().</p>
</td></tr>
<tr><td><code id="rwl_+3A_mopropen">moPropen</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the propensity for treatment.
See ?moPropen for details.</p>
</td></tr>
<tr><td><code id="rwl_+3A_momain">moMain</code></td>
<td>
<p>An object of class modelObj or modelObjSubset, which 
defines the model and
R methods to be used to obtain parameter estimates and
predictions for the main effects of the outcome.
See ?modelObj for details.</p>
</td></tr>
<tr><td><code id="rwl_+3A_data">data</code></td>
<td>
<p>A data frame of the covariates and tx histories</p>
</td></tr>
<tr><td><code id="rwl_+3A_reward">reward</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="rwl_+3A_txname">txName</code></td>
<td>
<p>A character object.
The column header of <em>data</em> that corresponds to the tx covariate</p>
</td></tr>
<tr><td><code id="rwl_+3A_regime">regime</code></td>
<td>
<p>A formula object or a list of formula objects.
The covariates to be included in classification. If a list is provided,
this specifies that there is an underlying subset structure &ndash; fSet must
then be defined.</p>
</td></tr>
<tr><td><code id="rwl_+3A_response">response</code></td>
<td>
<p>A numeric vector.
The reward. Allows for naming convention followed in most
DynTxRegime methods.</p>
</td></tr>
<tr><td><code id="rwl_+3A_fset">fSet</code></td>
<td>
<p>A function or NULL defining subset structure</p>
</td></tr>
<tr><td><code id="rwl_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric object or a numeric vector object giving the
penalty tuning parameter. If more than 1 is provided,
the finite set of values to be considered in the
cross-validation algorithm</p>
</td></tr>
<tr><td><code id="rwl_+3A_cvfolds">cvFolds</code></td>
<td>
<p>If cross-validation is to be used to select the tuning
parameters, the number of folds.</p>
</td></tr>
<tr><td><code id="rwl_+3A_kernel">kernel</code></td>
<td>
<p>A character object.
must be one of {&quot;linear&quot;, &quot;poly&quot;, &quot;radial&quot;}</p>
</td></tr>
<tr><td><code id="rwl_+3A_kparam">kparam</code></td>
<td>
<p>A numeric object of NULL.
If kernel = linear, kparam is ignored.
If kernel = poly, kparam is the degree of the polynomial
If kernel = radial, kparam is the inverse bandwidth of the
kernel. If a vector of bandwidth parameters is given,
cross-validation will be used to select the parameter</p>
</td></tr>
<tr><td><code id="rwl_+3A_responsetype">responseType</code></td>
<td>
<p>A character indicating if response is continuous, binary
or count data.</p>
</td></tr>
<tr><td><code id="rwl_+3A_verbose">verbose</code></td>
<td>
<p>An integer or logical. If 0, no screen prints are generated. If 1,
screen prints are generated with the exception of optimization results
obtained in iterative algorithm. If 2, all screen prints are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an RWL object
</p>


<h3>References</h3>

<p>Xin Zhou, Nicole Mayer-Hamblett, Umer Khan, and Michael R Kosorok
(2017)
Residual weighted learning for estimating individualized
treatment rules. Journal of the American Statistical Association,
112, 169&ndash;187.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+iqLearn">iqLearn</a></code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>
<p>Other weighted learning methods: 
<code><a href="#topic+bowl">bowl</a>()</code>,
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>
</p>
<p>Other single decision point methods: 
<code><a href="#topic+earl">earl</a>()</code>,
<code><a href="#topic+optimalClass">optimalClass</a>()</code>,
<code><a href="#topic+optimalSeq">optimalSeq</a>()</code>,
<code><a href="#topic+owl">owl</a>()</code>,
<code><a href="#topic+qLearn">qLearn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
# Load and process data set
data(bmiData)

# define the negative 12 month change in BMI from baseline
y12 &lt;- -100*(bmiData[,6L] - bmiData[,4L])/bmiData[,4L]

# propensity model
moPropen &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                          solver.method = 'glm',
                          solver.args = list('family'='binomial'),
                          predict.method = 'predict.glm',
                          predict.args = list(type='response'))

# outcome model
moMain &lt;- buildModelObj(model = ~parentBMI+month4BMI,
                        solver.method = 'lm')

fitRWL &lt;- rwl(moPropen = moPropen, moMain = moMain,
              data = bmiData, reward = y12,  txName = 'A2', 
              regime = ~ parentBMI + month4BMI,
              kernel = 'radial', kparam = 1.5)

##Available methods

  # Coefficients of the regression objects
  coef(fitRWL)

  # Description of method used to obtain object
  DTRstep(fitRWL)

  # Estimated value of the optimal treatment regime for training set
  estimator(fitRWL)

  # Value object returned by regression methods
  fitObject(fitRWL)

  # Summary of optimization routine
  optimObj(fitRWL)

  # Estimated optimal treatment for training data
  optTx(fitRWL)

  # Estimated optimal treatment for new data
  optTx(fitRWL, bmiData)

  # Value object returned by outcome regression method
  outcome(fitRWL)

  # Plots if defined by regression methods
  dev.new()
  par(mfrow = c(2,4))

  plot(fitRWL)
  plot(fitRWL, suppress = TRUE)

  # Value object returned by propensity score regression method
  propen(fitRWL)

  # Parameter estimates for decision function
  regimeCoef(fitRWL)

  # Show main results of method
  show(fitRWL)

  # Show summary results of method
  summary(fitRWL)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='RWL-class'>Class <code>RWL</code></h2><span id='topic+RWL-class'></span>

<h3>Description</h3>

<p>Class <code>RWL</code> contains results for an RWL analysis.
</p>


<h3>Slots</h3>


<dl>
<dt><code>responseType</code></dt><dd><p>character indicating type of response</p>
</dd>
<dt><code>residuals</code></dt><dd><p>vector of outcome residuals</p>
</dd>
<dt><code>beta</code></dt><dd><p>vector of regime parameters</p>
</dd>
<dt><code>analysis</code></dt><dd><p>Contains a Learning or LearningMulti object</p>
</dd>
<dt><code>analysis@txInfo</code></dt><dd><p>Feasible tx information</p>
</dd>
<dt><code>analysis@propen</code></dt><dd><p>Propensity regression analysis</p>
</dd>
<dt><code>analysis@outcome</code></dt><dd><p>Outcome regression analysis</p>
</dd>
<dt><code>analysis@cvInfo</code></dt><dd><p>Cross-validation analysis if single regime</p>
</dd>
<dt><code>analysis@optim</code></dt><dd><p>Optimization analysis if single regime</p>
</dd>
<dt><code>analysis@optimResult</code></dt><dd><p>list of cross-validation and optimization results
if multiple regimes. optimResult[[i]]@cvInfo and optimResult[[i]]@optim</p>
</dd>
<dt><code>analysis@optimal</code></dt><dd><p>Estimated optimal Tx and value</p>
</dd>
<dt><code>analysis@Call</code></dt><dd><p>Unevaluated Call</p>
</dd>
</dl>


<h3>Methods For Post-Processing of Regression Analysis</h3>


<dl>
<dt>outcome</dt><dd><p>: 
Retrieve value object returned by outcome regression methods.  </p>
</dd>
</dl>


<dl>
<dt>propen</dt><dd><p>: 
Retrieve value object returned by propensity regression methods.  </p>
</dd>
</dl>


<dl>
<dt>coef</dt><dd><p>: 
Retrieve parameter estimates for all regression steps. </p>
</dd>
<dt>fitObject</dt><dd><p>: 
Retrieve value object returned by regression methods. </p>
</dd>
<dt>plot</dt><dd><p>: 
Generate plots for regression analyses.  </p>
</dd>
</dl>



<h3>Methods For Post-Processing of Optimization Analysis</h3>


<dl>
<dt>cvInfo</dt><dd><p>: 
Retrieve cross-validation results.  </p>
</dd>
<dt>optimObj</dt><dd><p>: 
Retrieve value object returned by optimization method(s).  </p>
</dd>
<dt>regimeCoef</dt><dd><p>: 
Retrieve estimated parameters for optimal tx regime.  </p>
</dd>
</dl>



<h3>Methods For Accessing Main Results</h3>


<dl>
<dt>DTRstep</dt><dd><p>: 
Retrieve description of method used to create object. </p>
</dd>
<dt>estimator</dt><dd><p>: 
Retrieve the estimated value of the estimated
optimal regime for the training data set. </p>
</dd>
<dt>optTx</dt><dd><p>: 
Retrieve/predict the estimated decision functions and/or optimal tx. </p>
</dd>
<dt>print</dt><dd><p>: 
Print main results of analysis.</p>
</dd>
<dt>show</dt><dd><p>: 
Show main results of analysis.</p>
</dd>
<dt>summary</dt><dd><p>: 
Retrieve summary information.</p>
</dd>
</dl>


<hr>
<h2 id='RWL-methods'>Methods Available for Objects of Class <code>RWL</code></h2><span id='topic+RWL-methods'></span><span id='topic+print+2CRWL-method'></span><span id='topic+show+2CRWL-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>RWL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RWL'
print(x, ...)

## S4 method for signature 'RWL'
show(object)
</code></pre>

<hr>
<h2 id='sd'>Standard Deviation</h2><span id='topic+sd'></span><span id='topic+sd+2CIQLearnFS_C-method'></span>

<h3>Description</h3>

<p>Retrieve the standard deviation of the residuals for the first-stage contrasts
regression in the interactive Q-Learning algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd(x, na.rm=FALSE)

  ## S4 method for IQLearnFS_C
  sd(x, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>An object of class <code>IQLearnFS_C</code></p>
</td></tr>
<tr><td><code id="sd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>

<hr>
<h2 id='SmoothRampSurrogate-class'>Class <code>SmoothRampSurrogate</code></h2><span id='topic+SmoothRampSurrogate-class'></span>

<h3>Description</h3>

<p>Components of smoothed ramp surrogate for 0/1 loss function.
</p>

<hr>
<h2 id='SmoothRampSurrogate-methods'>Methods Available for Objects of Class <code>SmoothRampSurrogate</code></h2><span id='topic+SmoothRampSurrogate-methods'></span><span id='topic+.phiFunc+2CSmoothRampSurrogate-method'></span><span id='topic+.dPhiFunc+2CSmoothRampSurrogate-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>SmoothRampSurrogate</code>
</p>
<p><code>.phiFunc</code>
calculates smoothed ramp surrogate loss-function
</p>
<p><code>.dphiFunc</code>
calculates derivative of smoothed ramp surrogate loss-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothRampSurrogate'
.phiFunc(surrogate, u, res)

## S4 method for signature 'SmoothRampSurrogate'
.dPhiFunc(surrogate, u, du, res)
</code></pre>

<hr>
<h2 id='SqHingeSurrogate-class'>Class <code>SqHingeSurrogate</code></h2><span id='topic+SqHingeSurrogate-class'></span>

<h3>Description</h3>

<p>Squared hinge surrogate for 0/1 loss function
</p>

<hr>
<h2 id='SqHingeSurrogate-methods'>Methods Available for Objects of Class <code>SqHingeSurrogate</code></h2><span id='topic+SqHingeSurrogate-methods'></span><span id='topic+.phiFunc+2CSqHingeSurrogate-method'></span><span id='topic+.dPhiFunc+2CSqHingeSurrogate-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>SqHingeSurrogate</code>
</p>
<p><code>.phiFunc</code>
calculates squared hinge surrogate loss-function
</p>
<p><code>.dphiFunc</code>
calculates derivative of squared hinge surrogate loss-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SqHingeSurrogate'
.phiFunc(surrogate, u)

## S4 method for signature 'SqHingeSurrogate'
.dPhiFunc(surrogate, u, du)
</code></pre>

<hr>
<h2 id='SubsetList-class'>Class <code>SubsetList</code></h2><span id='topic+SubsetList-class'></span>

<h3>Description</h3>

<p>Class <code>SubsetList</code> represents a <code>List</code> for subset specifications.
This class extends <code>List</code> to require non-zero length and named elements.
</p>

<hr>
<h2 id='SubsetList-methods'>Methods Available for Objects of Class <code>SubsetList</code></h2><span id='topic+SubsetList-methods'></span><span id='topic+plot+2CSubsetList+2CANY-method'></span><span id='topic+print+2CSubsetList-method'></span><span id='topic+show+2CSubsetList-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>SubsetList</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SubsetList,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'SubsetList'
print(x, ...)

## S4 method for signature 'SubsetList'
show(object)
</code></pre>

<hr>
<h2 id='summary'>Result Summaries</h2><span id='topic+summary'></span>

<h3>Description</h3>

<p>Returns a list of the primary results, including regression results, 
optimization results, estimated tx and value, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>Value object returned by a statistical method</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Optional additional inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are defined for all statistical methods implemented in DynTxRegime.
</p>
<p>The exact structure of the returned list will vary depending on
the statistical method.
</p>

<hr>
<h2 id='Surrogate-class'>Class <code>Surrogate</code></h2><span id='topic+Surrogate-class'></span>

<h3>Description</h3>

<p>General class for surrogate objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>we</code></dt><dd><p>included to avoid VIRTUAL designation</p>
</dd>
</dl>

<hr>
<h2 id='Surrogate-methods'>Methods Available for Objects of Class <code>Surrogate</code></h2><span id='topic+Surrogate-methods'></span><span id='topic+.optim+2CSurrogate-method'></span>

<h3>Description</h3>

<p>Utilizes stats::optim to obtain parameter estimates. Requires that
the objective function and its derivative are defined by the
calling learning method. Returns NULL if optimization is not successful 
due to problems;
a vector of the current parameter estimates if optimization is not
successful because it hit the maximum number if iterations; and
the list object returned by stats::optim if optimization is successful
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Surrogate'
.optim(surrogate, par, lambda, fn, gr, suppress, ...)
</code></pre>

<hr>
<h2 id='TxInfoBasic-class'>Class <code>TxInfoBasic</code></h2><span id='topic+TxInfoBasic-class'></span>

<h3>Description</h3>

<p>Class <code>TxInfoBasic</code> stores basic treatment information.
</p>


<h3>Slots</h3>


<dl>
<dt><code>superset</code></dt><dd><p>A vector of all possible tx options.</p>
</dd>
<dt><code>txName</code></dt><dd><p>A character - column header of data.frame that contains tx 
variable</p>
</dd>
</dl>

<hr>
<h2 id='TxInfoBasic-methods'>Methods Available for Objects of Class <code>TxInfoBasic</code></h2><span id='topic+TxInfoBasic-methods'></span><span id='topic+.compareTx+2CTxInfoBasic+2CANY+2CANY-method'></span><span id='topic+.convertFromBinary+2CTxInfoBasic-method'></span><span id='topic+.convertToBinary+2CTxInfoBasic-method'></span><span id='topic+.convertTx+2CTxInfoBasic-method'></span><span id='topic+.getLevels+2CTxInfoBasic+2CANY-method'></span><span id='topic+.getSuperset+2CTxInfoBasic-method'></span><span id='topic+.getTxName+2CTxInfoBasic-method'></span><span id='topic+.validTx+2CTxInfoBasic-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoBasic</code>
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
not allowed
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding
</p>
<p><code>.convertToBinary(txObj, data)</code>
converts user specified tx variable to binary -1/1
</p>
<p><code>.convertTx(object, txVec)</code>
not allowed
</p>
<p><code>.getLevels(object, txVec)</code>
not allowed
</p>
<p><code>.getSuperset(object)</code>
retrieves superset information
</p>
<p><code>.getTxName(object)</code>
retrieve tx variable name
</p>
<p><code>.validTx(object, txVec)</code>
ensures all elements in txVec are allowed by superset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxInfoBasic,ANY,ANY'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxInfoBasic'
.convertFromBinary(txObj, txVec, ...)

## S4 method for signature 'TxInfoBasic'
.convertToBinary(txObj, ..., txVec)

## S4 method for signature 'TxInfoBasic'
.convertTx(object, txVec)

## S4 method for signature 'TxInfoBasic,ANY'
.getLevels(object, txVec)

## S4 method for signature 'TxInfoBasic'
.getSuperset(object)

## S4 method for signature 'TxInfoBasic'
.getTxName(object)

## S4 method for signature 'TxInfoBasic'
.validTx(object, txVec)
</code></pre>

<hr>
<h2 id='TxInfoFactor-class'>Class TxInfoFactor</h2><span id='topic+TxInfoFactor-class'></span>

<h3>Description</h3>

<p>Class <code>TxInfoFactor</code> extends <code>TxInfoBasic</code> to identify treatments 
as factor
</p>


<h3>Slots</h3>


<dl>
<dt><code>superset</code></dt><dd><p>character of all allowed tx options</p>
</dd>
</dl>

<hr>
<h2 id='TxInfoFactor-methods'>Methods Available for Objects of Class <code>TxInfoFactor</code></h2><span id='topic+TxInfoFactor-methods'></span><span id='topic+.compareTx+2CTxInfoFactor+2Cfactor+2Cfactor-method'></span><span id='topic+.convertFromBinary+2CTxInfoFactor-method'></span><span id='topic+.convertTx+2CTxInfoFactor-method'></span><span id='topic+.getLevels+2CTxInfoFactor+2Cfactor-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoFactor</code>
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
compares vec1 and vec2 to identify equivalent elements.
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
converts txVec to factor.
</p>
<p><code>.getLevels(object, txVec)</code>
determines tx levels contains in txVec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxInfoFactor,factor,factor'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxInfoFactor'
.convertFromBinary(txObj, txVec, ...)

## S4 method for signature 'TxInfoFactor'
.convertTx(object, txVec)

## S4 method for signature 'TxInfoFactor,factor'
.getLevels(object, txVec)
</code></pre>

<hr>
<h2 id='TxInfoInteger-class'>Class TxInfoInteger</h2><span id='topic+TxInfoInteger-class'></span>

<h3>Description</h3>

<p>Class <code>TxInfoInteger</code> extends <code>TxInfoBasic</code> to identify treatments 
as integer.
</p>

<hr>
<h2 id='TxInfoInteger-methods'>Methods Available for Objects of Class <code>TxInfoInteger</code></h2><span id='topic+TxInfoInteger-methods'></span><span id='topic+.compareTx+2CTxInfoInteger+2Cinteger+2Cinteger-method'></span><span id='topic+.convertFromBinary+2CTxInfoInteger-method'></span><span id='topic+.convertTx+2CTxInfoInteger-method'></span><span id='topic+.getLevels+2CTxInfoInteger+2Cinteger-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoInteger</code>
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
compares vec1 and vec2 to identify equivalent elements.
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
converts txVec to factor.
</p>
<p><code>.getLevels(object, txVec)</code>
determines tx levels contains in txVec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxInfoInteger,integer,integer'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxInfoInteger'
.convertFromBinary(txObj, txVec, ...)

## S4 method for signature 'TxInfoInteger'
.convertTx(object, txVec)

## S4 method for signature 'TxInfoInteger,integer'
.getLevels(object, txVec)
</code></pre>

<hr>
<h2 id='TxInfoList'>Class <code>TxInfoList</code></h2><span id='topic+TxInfoList'></span>

<h3>Description</h3>

<p>Class <code>TxInfoList</code> extends class <code>TxObj</code> to indicate that
\@txInfo is of class <code>List</code>. Each element of that list corresponds
to a decision point. All methods called with this object throw errors.
</p>


<h3>Slots</h3>


<dl>
<dt><code>txInfo</code></dt><dd><p>A List object</p>
</dd>
</dl>

<hr>
<h2 id='TxInfoList-methods'>Methods Available for Objects of Class <code>TxInfoList</code></h2><span id='topic+TxInfoList-methods'></span><span id='topic+.getPtsSubset+2CTxInfoList-method'></span><span id='topic+.getSingleton+2CTxInfoList-method'></span><span id='topic+.getSubsetRule+2CTxInfoList-method'></span><span id='topic+.getSubsets+2CTxInfoList-method'></span><span id='topic+.getSuperset+2CTxInfoList-method'></span><span id='topic+.getTxName+2CTxInfoList-method'></span><span id='topic+.validTx+2CTxInfoList-method'></span><span id='topic+.compareTx+2CTxInfoList+2CANY+2CANY-method'></span><span id='topic+.convertTx+2CTxInfoList-method'></span><span id='topic+.getLevels+2CTxInfoList+2CANY-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoList</code>
</p>
<p><code>.getPtsSubset(object)</code>
not allowed.
</p>
<p><code>.getSingleton(object)</code>
not allowed.
</p>
<p><code>.getSubsetRule(object)</code>
not allowed.
</p>
<p><code>.getSubsets(object)</code>
not allowed.
</p>
<p><code>.getSuperset(object)</code>
not allowed.
</p>
<p><code>.getTxName(object)</code>
not allowed.
</p>
<p><code>.validTx(object, txVec)</code>
not allowed.
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
not allowed.
</p>
<p><code>.convertTx(object, txVec)</code>
not allowed.
</p>
<p><code>.getLevels(object, txVec)</code>
not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxInfoList'
.getPtsSubset(object)

## S4 method for signature 'TxInfoList'
.getSingleton(object)

## S4 method for signature 'TxInfoList'
.getSubsetRule(object)

## S4 method for signature 'TxInfoList'
.getSubsets(object)

## S4 method for signature 'TxInfoList'
.getSuperset(object)

## S4 method for signature 'TxInfoList'
.getTxName(object)

## S4 method for signature 'TxInfoList'
.validTx(object)

## S4 method for signature 'TxInfoList,ANY,ANY'
.compareTx(object)

## S4 method for signature 'TxInfoList'
.convertTx(object)

## S4 method for signature 'TxInfoList,ANY'
.getLevels(object)
</code></pre>

<hr>
<h2 id='TxInfoNoSubsets-class'>Class <code>TxInfoNoSubsets</code></h2><span id='topic+TxInfoNoSubsets-class'></span>

<h3>Description</h3>

<p>Class <code>TxInfoNoSubsets</code> extends class <code>TxObj</code> to indicate that
\@txInfo is of class <code>TxInfoBasic</code> and thus no subsets were identified.
</p>


<h3>Slots</h3>


<dl>
<dt><code>txInfo</code></dt><dd><p>A TxInfoBasic object</p>
</dd>
</dl>

<hr>
<h2 id='TxInfoNoSubsets-methods'>Methods Available for Objects of Class <code>TxInfoNoSubsets</code></h2><span id='topic+TxInfoNoSubsets-methods'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoNoSubsets</code>
</p>

<hr>
<h2 id='TxInfoWithSubsets-class'>Class <code>TxInfoWithSubsets</code></h2><span id='topic+TxInfoWithSubsets-class'></span>

<h3>Description</h3>

<p>Class <code>TxInfoWithSubsets</code> extends class <code>TxObj</code> to indicate that
\@txInfo is of class <code>TxInfoSubset</code> and thus subsets were identified.
</p>


<h3>Slots</h3>


<dl>
<dt><code>txInfo</code></dt><dd><p>A TxSubset object</p>
</dd>
</dl>

<hr>
<h2 id='TxInfoWithSubsets-methods'>Methods Available for Objects of Class <code>TxInfoWithSubsets</code></h2><span id='topic+TxInfoWithSubsets-methods'></span><span id='topic+.getPtsSubset+2CTxInfoWithSubsets-method'></span><span id='topic+.getSingleton+2CTxInfoWithSubsets-method'></span><span id='topic+.getSubsetRule+2CTxInfoWithSubsets-method'></span><span id='topic+.getSubsets+2CTxInfoWithSubsets-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxInfoWithSubsets</code>
</p>
<p><code>.getPtsSubset(object)</code>
retrieves subset name to which each pt is a member. Method dispatched
depends on class of @txInfo.
</p>
<p><code>.getSingleton(object)</code>
retrieves T/F indicating if &gt;1 tx is available to each pt. Method dispatched
depends on class of @txInfo.
</p>
<p><code>.getSubsetRule(object)</code>
retrieves feasible tx function. Method dispatched
depends on class of @txInfo.
</p>
<p><code>.getSubsets(object)</code>
retrieves feasible tx information. Method dispatched
depends on class of @txInfo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxInfoWithSubsets'
.getPtsSubset(object)

## S4 method for signature 'TxInfoWithSubsets'
.getSingleton(object)

## S4 method for signature 'TxInfoWithSubsets'
.getSubsetRule(object)

## S4 method for signature 'TxInfoWithSubsets'
.getSubsets(object)
</code></pre>

<hr>
<h2 id='TxObj-class'>Class <code>TxObj</code></h2><span id='topic+TxObj-class'></span>

<h3>Description</h3>

<p>Storage Class to group tx information under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>txInfo</code></dt><dd><p>Any object &ndash; expected to be of class TxInfoBasic,
TxInfoSubset, or DecisionPointList</p>
</dd>
</dl>

<hr>
<h2 id='TxObj-methods'>Methods Available for Objects of Class <code>TxObj</code></h2><span id='topic+TxObj-methods'></span><span id='topic+.compareTx+2CTxObj+2CANY+2CANY-method'></span><span id='topic+.convertFromBinary+2CTxObj-method'></span><span id='topic+.convertToBinary+2CTxObj-method'></span><span id='topic+.convertTx+2CTxObj-method'></span><span id='topic+.getLevels+2CTxObj+2CANY-method'></span><span id='topic+.getSuperset+2CTxObj-method'></span><span id='topic+.getTxName+2CTxObj-method'></span><span id='topic+.validTx+2CTxObj-method'></span>

<h3>Description</h3>

<p>Methods dispatched depend on class of @txInfo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxObj,ANY,ANY'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxObj'
.convertFromBinary(txObj, ...)

## S4 method for signature 'TxObj'
.convertToBinary(txObj, ...)

## S4 method for signature 'TxObj'
.convertTx(object, txVec)

## S4 method for signature 'TxObj,ANY'
.getLevels(object, txVec)

## S4 method for signature 'TxObj'
.getSuperset(object)

## S4 method for signature 'TxObj'
.getTxName(object)

## S4 method for signature 'TxObj'
.validTx(object, txVec)
</code></pre>

<hr>
<h2 id='TxSubset-class'>Class <code>TxSubset</code></h2><span id='topic+TxSubset-class'></span>

<h3>Description</h3>

<p>Class <code>TxSubset</code> stores subset information for tx
</p>


<h3>Slots</h3>


<dl>
<dt><code>ptsSubset</code></dt><dd><p>A character vector. The name of the subset of which each 
patient is a member</p>
</dd>
<dt><code>subsetRule</code></dt><dd><p>A function. The fSet function provided by user.</p>
</dd>
<dt><code>subsets</code></dt><dd><p>A list. The feasible treatments for each subset. The elements
must be named and contain tx subsets</p>
</dd>
<dt><code>singleton</code></dt><dd><p>A logical vector. TRUE indicates if 1 tx is available to
each patient</p>
</dd>
</dl>

<hr>
<h2 id='TxSubset-methods'>Methods Available for Objects of Class <code>TxSubset</code></h2><span id='topic+TxSubset-methods'></span><span id='topic+.convertFromBinary+2CTxSubset-method'></span><span id='topic+.convertToBinary+2CTxSubset-method'></span><span id='topic+.getPtsSubset+2CTxSubset-method'></span><span id='topic+.getSingleton+2CTxSubset-method'></span><span id='topic+.getSubsetRule+2CTxSubset-method'></span><span id='topic+.getSubsets+2CTxSubset-method'></span><span id='topic+.validTx+2CTxSubset-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxSubset</code>
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding.
</p>
<p><code>.convertToBinary(txObj, data)</code>
converts user specified tx variable to binary -1/1.
</p>
<p><code>.getPtsSubset(object)</code>
retrieve subset name for which each pt is a member.
</p>
<p><code>.getSingleton(object)</code>
retrieve T/F indicator of only 1 tx option available to each pt.
</p>
<p><code>.getSubsetRule(object)</code>
retrieve feasible set identification rule.
</p>
<p><code>.getSubsets(object)</code>
retrieve subset names and tx options.
</p>
<p><code>.validTx(object, txVec)</code>
ensures all elements in txVec are allowed by superset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxSubset'
.convertFromBinary(txObj, ..., txVec)

## S4 method for signature 'TxSubset'
.convertToBinary(txObj, ...)

## S4 method for signature 'TxSubset'
.getPtsSubset(object)

## S4 method for signature 'TxSubset'
.getSingleton(object)

## S4 method for signature 'TxSubset'
.getSubsetRule(object)

## S4 method for signature 'TxSubset'
.getSubsets(object)

## S4 method for signature 'TxSubset'
.validTx(object, txVec)
</code></pre>

<hr>
<h2 id='TxSubsetFactor-class'>Class <code>TxSubsetFactor</code></h2><span id='topic+TxSubsetFactor-class'></span>

<h3>Description</h3>

<p>Class <code>TxSubsetFactor</code> stores subset information for tx when tx is
a factor
</p>

<hr>
<h2 id='TxSubsetFactor-methods'>Methods Available for Objects of Class <code>TxSubsetFactor</code></h2><span id='topic+TxSubsetFactor-methods'></span><span id='topic+.convertFromBinary+2CTxSubsetFactor-method'></span><span id='topic+.convertToBinary+2CTxSubsetFactor-method'></span><span id='topic+.getPtsSubset+2CTxSubsetFactor-method'></span><span id='topic+.getSingleton+2CTxSubsetFactor-method'></span><span id='topic+.getSubsetRule+2CTxSubsetFactor-method'></span><span id='topic+.getSubsets+2CTxSubsetFactor-method'></span><span id='topic+.compareTx+2CTxSubsetFactor+2Cfactor+2Cfactor-method'></span><span id='topic+.convertTx+2CTxSubsetFactor-method'></span><span id='topic+.getLevels+2CTxSubsetFactor+2Cfactor-method'></span><span id='topic+.getSuperset+2CTxSubsetFactor-method'></span><span id='topic+.getTxName+2CTxSubsetFactor-method'></span><span id='topic+.validTx+2CTxSubsetFactor-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxSubsetFactor</code>
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.convertToBinary(txObj, data)</code>
converts user specified tx variable to binary -1/1.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getPtsSubset(object)</code>
retrieve subset name for which each pt is a member.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSingleton(object)</code>
retrieve T/F indicator of only 1 tx option available to each pt.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSubsetRule(object)</code>
retrieve feasible set identification rule.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSubsets(object)</code>
retrieve subset names and tx options.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
compares vec1 and vec2 to identify equivalent elements.
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
converts txVec to factor.
</p>
<p><code>.getLevels(object, txVec)</code>
determines tx levels contains in txVec.
</p>
<p><code>.getSuperset(object)</code>
retrieves superset. Uses method defined for TxInfoFactor objects.
</p>
<p><code>.getTxName(object)</code>
retrieves tx variable name. Uses method defined for TxInfoFactor objects.
</p>
<p><code>.validTx(object, txVec)</code>
ensures all elements in txVec are allowed by superset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxSubsetFactor'
.convertFromBinary(txObj, ..., txVec)

## S4 method for signature 'TxSubsetFactor'
.convertToBinary(txObj, ..., txVec, data)

## S4 method for signature 'TxSubsetFactor'
.getPtsSubset(object)

## S4 method for signature 'TxSubsetFactor'
.getSingleton(object)

## S4 method for signature 'TxSubsetFactor'
.getSubsetRule(object)

## S4 method for signature 'TxSubsetFactor'
.getSubsets(object)

## S4 method for signature 'TxSubsetFactor,factor,factor'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxSubsetFactor'
.convertTx(object, txVec)

## S4 method for signature 'TxSubsetFactor,factor'
.getLevels(object, txVec)

## S4 method for signature 'TxSubsetFactor'
.getSuperset(object)

## S4 method for signature 'TxSubsetFactor'
.getTxName(object)

## S4 method for signature 'TxSubsetFactor'
.validTx(object, txVec)
</code></pre>

<hr>
<h2 id='TxSubsetInteger-class'>Class TxSubsetInteger</h2><span id='topic+TxSubsetInteger-class'></span>

<h3>Description</h3>

<p>Class <code>TxSubsetInteger</code> stores subset information for treatment
</p>

<hr>
<h2 id='TxSubsetInteger-methods'>Methods Available for Objects of Class <code>TxSubsetInteger</code></h2><span id='topic+TxSubsetInteger-methods'></span><span id='topic+.convertFromBinary+2CTxSubsetInteger-method'></span><span id='topic+.convertToBinary+2CTxSubsetInteger-method'></span><span id='topic+.getPtsSubset+2CTxSubsetInteger-method'></span><span id='topic+.getSingleton+2CTxSubsetInteger-method'></span><span id='topic+.getSubsetRule+2CTxSubsetInteger-method'></span><span id='topic+.getSubsets+2CTxSubsetInteger-method'></span><span id='topic+.compareTx+2CTxSubsetInteger+2Cinteger+2Cinteger-method'></span><span id='topic+.convertTx+2CTxSubsetInteger-method'></span><span id='topic+.getLevels+2CTxSubsetInteger+2Cinteger-method'></span><span id='topic+.getSuperset+2CTxSubsetInteger-method'></span><span id='topic+.getTxName+2CTxSubsetInteger-method'></span><span id='topic+.validTx+2CTxSubsetInteger-method'></span>

<h3>Description</h3>

<p>Methods Available for Objects of Class <code>TxSubsetInteger</code>
</p>
<p><code>.convertFromBinary(txObj, txVec)</code>
converts a -1/1 Tx to user provided tx coding.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.convertToBinary(txObj, data)</code>
converts user specified tx variable to binary -1/1.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getPtsSubset(object)</code>
retrieve subset name for which each pt is a member.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSingleton(object)</code>
retrieve T/F indicator of only 1 tx option available to each pt.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSubsetRule(object)</code>
retrieve feasible set identification rule.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.getSubsets(object)</code>
retrieve subset names and tx options.
Call method defined for <code>TxSubset</code>.
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
compares vec1 and vec2 to identify equivalent elements.
</p>
<p><code>.compareTx(object, vec1, vec2)</code>
converts txVec to factor.
</p>
<p><code>.getLevels(object, txVec)</code>
determines tx levels contains in txVec.
</p>
<p><code>.getSuperset(object)</code>
retrieves superset. Uses method defined for TxInfoInteger objects.
</p>
<p><code>.getTxName(object)</code>
retrieves tx variable name. Uses method defined for TxInfoInteger objects.
</p>
<p><code>.validTx(object, txVec)</code>
ensures all elements in txVec are allowed by superset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TxSubsetInteger'
.convertFromBinary(txObj, txVec, ...)

## S4 method for signature 'TxSubsetInteger'
.convertToBinary(txObj, ..., txVec, data)

## S4 method for signature 'TxSubsetInteger'
.getPtsSubset(object)

## S4 method for signature 'TxSubsetInteger'
.getSingleton(object)

## S4 method for signature 'TxSubsetInteger'
.getSubsetRule(object)

## S4 method for signature 'TxSubsetInteger'
.getSubsets(object)

## S4 method for signature 'TxSubsetInteger,integer,integer'
.compareTx(object, vec1, vec2)

## S4 method for signature 'TxSubsetInteger'
.convertTx(object, txVec)

## S4 method for signature 'TxSubsetInteger,integer'
.getLevels(object, txVec)

## S4 method for signature 'TxSubsetInteger'
.getSuperset(object)

## S4 method for signature 'TxSubsetInteger'
.getTxName(object)

## S4 method for signature 'TxSubsetInteger'
.validTx(object, txVec)
</code></pre>

<hr>
<h2 id='TypedFit_fSet-class'>Class <code>TypedFit_fSet</code></h2><span id='topic+TypedFit_fSet-class'></span>

<h3>Description</h3>

<p>Class <code>TypedFit_fSet</code> is a <code>TypedFit</code> when subsets are identified
but not modeled independently.
</p>

<hr>
<h2 id='TypedFit_fSet-methods'>Methods Available for Objects of Class <code>TypedFit_fSet</code></h2><span id='topic+TypedFit_fSet-methods'></span><span id='topic+coef+2CTypedFit_fSet-method'></span><span id='topic+fitObject+2CTypedFit_fSet-method'></span><span id='topic+plot+2CTypedFit_fSet+2CANY-method'></span><span id='topic+predict+2CTypedFit_fSet-method'></span><span id='topic+print+2CTypedFit_fSet-method'></span><span id='topic+show+2CTypedFit_fSet-method'></span><span id='topic+summary+2CTypedFit_fSet-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit</code>
objects.
</p>
<p><code>predict(object, ...)</code>
Patients with only 1 tx option are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TypedFit_fSet'
coef(object, ...)

## S4 method for signature 'TypedFit_fSet'
fitObject(object, ...)

## S4 method for signature 'TypedFit_fSet,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'TypedFit_fSet'
predict(object, newdata, ...)

## S4 method for signature 'TypedFit_fSet'
print(x, ...)

## S4 method for signature 'TypedFit_fSet'
show(object)

## S4 method for signature 'TypedFit_fSet'
summary(object, ...)
</code></pre>

<hr>
<h2 id='TypedFit_SubsetList-class'>Class <code>TypedFit_SubsetList</code></h2><span id='topic+TypedFit_SubsetList-class'></span>

<h3>Description</h3>

<p>Class <code>TypedFit_SubsetList</code> is <code>SubsetList</code> of <code>TypedFit</code> 
used when subsets are identified and modeled independently.
</p>

<hr>
<h2 id='TypedFit_SubsetList-methods'>Methods Available for Objects of Class <code>TypedFit_SubsetList</code></h2><span id='topic+TypedFit_SubsetList-methods'></span><span id='topic+coef+2CTypedFit_SubsetList-method'></span><span id='topic+fitObject+2CTypedFit_SubsetList-method'></span><span id='topic+plot+2CTypedFit_SubsetList+2CANY-method'></span><span id='topic+predict+2CTypedFit_SubsetList-method'></span><span id='topic+print+2CTypedFit_SubsetList-method'></span><span id='topic+show+2CTypedFit_SubsetList-method'></span><span id='topic+summary+2CTypedFit_SubsetList-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit</code>
objects. When a value object is returned, it is a list. The element
names of the list are the subset names to which the result pertains.
</p>
<p><code>predict(object, ...)</code>
Patients not in subset are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TypedFit_SubsetList'
coef(object, ...)

## S4 method for signature 'TypedFit_SubsetList'
fitObject(object, ...)

## S4 method for signature 'TypedFit_SubsetList,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'TypedFit_SubsetList'
predict(object, newdata, ...)

## S4 method for signature 'TypedFit_SubsetList'
print(x, ...)

## S4 method for signature 'TypedFit_SubsetList'
show(object)

## S4 method for signature 'TypedFit_SubsetList'
summary(object, ...)
</code></pre>

<hr>
<h2 id='TypedFit-class'>Class <code>TypedFit</code></h2><span id='topic+TypedFit-class'></span>

<h3>Description</h3>

<p>Class <code>TypedFit</code> is a <code>modelObjFit</code> combined with a character
to identify its purpose.
</p>

<hr>
<h2 id='TypedFit-methods'>Methods Available for Objects of Class <code>TypedFit</code></h2><span id='topic+TypedFit-methods'></span><span id='topic+coef+2CTypedFit-method'></span><span id='topic+fitObject+2CTypedFit-method'></span><span id='topic+plot+2CTypedFit+2CANY-method'></span><span id='topic+print+2CTypedFit-method'></span><span id='topic+show+2CTypedFit-method'></span><span id='topic+summary+2CTypedFit-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>modelObjFit</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TypedFit'
coef(object, ...)

## S4 method for signature 'TypedFit'
fitObject(object, ...)

## S4 method for signature 'TypedFit,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'TypedFit'
print(x, ...)

## S4 method for signature 'TypedFit'
show(object)

## S4 method for signature 'TypedFit'
summary(object, ...)
</code></pre>

<hr>
<h2 id='TypedFitObj-class'>Class <code>TypedFitObj</code></h2><span id='topic+TypedFitObj-class'></span>

<h3>Description</h3>

<p>Class <code>TypedFit_SubsetList</code> allows for TypedFit based objects to be 
grouped under a common name.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code></dt><dd><p>ANY - expected to be <code>TypedFit</code>, <code>TypedFit_fSet</code>.
<code>TypedFit_SubsetList</code> or <code>DecisionPointList</code> of these.</p>
</dd>
</dl>

<hr>
<h2 id='TypedFitObj-methods'>Methods Available for Objects of Class <code>TypedFitObj</code></h2><span id='topic+TypedFitObj-methods'></span><span id='topic+coef+2CTypedFitObj-method'></span><span id='topic+fitObject+2CTypedFitObj-method'></span><span id='topic+plot+2CTypedFitObj+2CANY-method'></span><span id='topic+predict+2CTypedFitObj-method'></span><span id='topic+print+2CTypedFitObj-method'></span><span id='topic+show+2CTypedFitObj-method'></span><span id='topic+summary+2CTypedFitObj-method'></span>

<h3>Description</h3>

<p>Methods call equivalently named methods defined for <code>TypedFit</code>,
<code>TypedFit_fSet</code>, <code>TypedFit_SubsetList</code> or
<code>DecisionPointList</code> objects.
The methods dispatched and objects returned depend on the class of @fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TypedFitObj'
coef(object, ...)

## S4 method for signature 'TypedFitObj'
fitObject(object, ...)

## S4 method for signature 'TypedFitObj,ANY'
plot(x, suppress = FALSE, ...)

## S4 method for signature 'TypedFitObj'
predict(object, ...)

## S4 method for signature 'TypedFitObj'
print(x, ...)

## S4 method for signature 'TypedFitObj'
show(object)

## S4 method for signature 'TypedFitObj'
summary(object, ...)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
