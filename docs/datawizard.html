<!DOCTYPE html><html><head><title>Help for package datawizard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datawizard}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.is_deprecated'><p>Print a message saying that an argument is deprecated and that the user</p>
should use its replacement instead.</a></li>
<li><a href='#adjust'><p>Adjust data for the effect of other variable(s)</p></a></li>
<li><a href='#assign_labels'><p>Assign variable and value labels</p></a></li>
<li><a href='#categorize'><p>Recode (or &quot;cut&quot; / &quot;bin&quot;) data into groups of values.</p></a></li>
<li><a href='#center'><p>Centering (Grand-Mean Centering)</p></a></li>
<li><a href='#coef_var'><p>Compute the coefficient of variation</p></a></li>
<li><a href='#coerce_to_numeric'><p>Convert to Numeric (if possible)</p></a></li>
<li><a href='#contr.deviation'><p>Deviation Contrast Matrix</p></a></li>
<li><a href='#convert_na_to'><p>Replace missing values in a variable or a data frame.</p></a></li>
<li><a href='#convert_to_na'><p>Convert non-missing values in a variable into missing values.</p></a></li>
<li><a href='#data_addprefix'><p>Rename columns and variable names</p></a></li>
<li><a href='#data_arrange'><p>Arrange rows by column values</p></a></li>
<li><a href='#data_codebook'><p>Generate a codebook of a data frame.</p></a></li>
<li><a href='#data_duplicated'><p>Extract all duplicates</p></a></li>
<li><a href='#data_extract'><p>Extract one or more columns or elements from an object</p></a></li>
<li><a href='#data_group'><p>Create a grouped data frame</p></a></li>
<li><a href='#data_match'><p>Return filtered or sliced data frame, or row indices</p></a></li>
<li><a href='#data_merge'><p>Merge (join) two data frames, or a list of data frames</p></a></li>
<li><a href='#data_modify'><p>Create new variables in a data frame</p></a></li>
<li><a href='#data_partition'><p>Partition data</p></a></li>
<li><a href='#data_peek'><p>Peek at values and type of variables in a data frame</p></a></li>
<li><a href='#data_read'><p>Read (import) data files from various sources</p></a></li>
<li><a href='#data_relocate'><p>Relocate (reorder) columns of a data frame</p></a></li>
<li><a href='#data_replicate'><p>Expand (i.e. replicate rows) a data frame</p></a></li>
<li><a href='#data_restoretype'><p>Restore the type of columns according to a reference data frame</p></a></li>
<li><a href='#data_rotate'><p>Rotate a data frame</p></a></li>
<li><a href='#data_seek'><p>Find variables by their names, variable or value labels</p></a></li>
<li><a href='#data_separate'><p>Separate single variable into multiple variables</p></a></li>
<li><a href='#data_summary'><p>Summarize data</p></a></li>
<li><a href='#data_tabulate'><p>Create frequency and crosstables of variables</p></a></li>
<li><a href='#data_to_long'><p>Reshape (pivot) data from wide to long</p></a></li>
<li><a href='#data_to_wide'><p>Reshape (pivot) data from long to wide</p></a></li>
<li><a href='#data_unique'><p>Keep only one row from all with duplicated IDs</p></a></li>
<li><a href='#data_unite'><p>Unite (&quot;merge&quot;) multiple variables</p></a></li>
<li><a href='#datawizard-package'><p>datawizard: Easy Data Wrangling and Statistical Transformations</p></a></li>
<li><a href='#demean'><p>Compute group-meaned and de-meaned variables</p></a></li>
<li><a href='#describe_distribution'><p>Describe a distribution</p></a></li>
<li><a href='#distribution_mode'><p>Compute mode for a statistical distribution</p></a></li>
<li><a href='#efc'><p>Sample dataset from the EFC Survey</p></a></li>
<li><a href='#find_columns'><p>Find or get columns in a data frame based on search patterns</p></a></li>
<li><a href='#labels_to_levels'><p>Convert value labels into factor levels</p></a></li>
<li><a href='#makepredictcall.dw_transformer'><p>Utility Function for Safe Prediction with <code>datawizard</code> transformers</p></a></li>
<li><a href='#mean_sd'><p>Summary Helpers</p></a></li>
<li><a href='#means_by_group'><p>Summary of mean values by group</p></a></li>
<li><a href='#nhanes_sample'><p>Sample dataset from the National Health and Nutrition Examination Survey</p></a></li>
<li><a href='#normalize'><p>Normalize numeric variable to 0-1 range</p></a></li>
<li><a href='#ranktransform'><p>(Signed) rank transformation</p></a></li>
<li><a href='#recode_into'><p>Recode values from one or more variables into a new variable</p></a></li>
<li><a href='#recode_values'><p>Recode old values of variables into new values</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_empty'><p>Return or remove variables or observations that are completely missing</p></a></li>
<li><a href='#replace_nan_inf'><p>Convert infinite or <code>NaN</code> values into <code>NA</code></p></a></li>
<li><a href='#rescale'><p>Rescale Variables to a New Range</p></a></li>
<li><a href='#rescale_weights'><p>Rescale design weights for multilevel analysis</p></a></li>
<li><a href='#reshape_ci'><p>Reshape CI between wide/long formats</p></a></li>
<li><a href='#reverse'><p>Reverse-Score Variables</p></a></li>
<li><a href='#row_means'><p>Row means (optionally with minimum amount of valid values)</p></a></li>
<li><a href='#row_to_colnames'><p>Tools for working with column names</p></a></li>
<li><a href='#rownames_as_column'><p>Tools for working with row names or row ids</p></a></li>
<li><a href='#skewness'><p>Compute Skewness and (Excess) Kurtosis</p></a></li>
<li><a href='#slide'><p>Shift numeric value range</p></a></li>
<li><a href='#smoothness'><p>Quantify the smoothness of a vector</p></a></li>
<li><a href='#standardize'><p>Standardization (Z-scoring)</p></a></li>
<li><a href='#standardize.default'><p>Re-fit a model with standardized data</p></a></li>
<li><a href='#text_format'><p>Convenient text formatting functionalities</p></a></li>
<li><a href='#to_factor'><p>Convert data to factors</p></a></li>
<li><a href='#to_numeric'><p>Convert data to numeric</p></a></li>
<li><a href='#visualisation_recipe'><p>Prepare objects for visualisation</p></a></li>
<li><a href='#weighted_mean'><p>Weighted Mean, Median, SD, and MAD</p></a></li>
<li><a href='#winsorize'><p>Winsorize data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Data Wrangling and Statistical Transformations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Etienne Bacher &lt;etienne.bacher@protonmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A lightweight package to assist in key steps involved in any data 
    analysis workflow: (1) wrangling the raw data to get it in the needed form, 
    (2) applying preprocessing steps and statistical transformations, and 
    (3) compute statistical summaries of data properties and distributions. 
    It is also the data wrangling backend for packages in 'easystats' ecosystem.
    References: Patil et al. (2022) &lt;<a href="https://doi.org/10.21105%2Fjoss.04684">doi:10.21105/joss.04684</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://easystats.github.io/datawizard/">https://easystats.github.io/datawizard/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/easystats/datawizard/issues">https://github.com/easystats/datawizard/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>insight (&ge; 0.19.8), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayestestR, boot, brms, curl, data.table, dplyr (&ge; 1.0),
effectsize, emmeans, gamm4, ggplot2, gt, haven, htmltools,
httr, knitr, lme4, mediation, parameters (&ge; 0.20.3), poorman
(&ge; 0.2.6), psych, readxl, readr, rio, rmarkdown, rstanarm,
see, testthat (&ge; 3.2.0), tibble, tidyr, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rstudio/bslib, r-lib/pkgdown,
easystats/easystatstemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 13:44:01 UTC; etienne</td>
</tr>
<tr>
<td>Author:</td>
<td>Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@patilindrajeets),
  Etienne Bacher <a href="https://orcid.org/0000-0002-9271-5075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dominique Makowski
    <a href="https://orcid.org/0000-0001-5375-9967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (@Dom_Makowski),
  Daniel Lüdecke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@strengejacke),
  Mattan S. Ben-Shachar
    <a href="https://orcid.org/0000-0002-4287-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Brenton M. Wiernik
    <a href="https://orcid.org/0000-0001-9560-6336"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (@bmwiernik),
  Rémi Thériault <a href="https://orcid.org/0000-0003-4315-6788"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (@rempsyc),
  Thomas J. Faulkenberry [rev],
  Robert Garrett [rev]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.is_deprecated'>Print a message saying that an argument is deprecated and that the user
should use its replacement instead.</h2><span id='topic+.is_deprecated'></span>

<h3>Description</h3>

<p>Print a message saying that an argument is deprecated and that the user
should use its replacement instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_deprecated(arg, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".is_deprecated_+3A_arg">arg</code></td>
<td>
<p>Argument that is deprecated</p>
</td></tr>
<tr><td><code id=".is_deprecated_+3A_replacement">replacement</code></td>
<td>
<p>Argument that replaces the deprecated argument</p>
</td></tr>
</table>

<hr>
<h2 id='adjust'>Adjust data for the effect of other variable(s)</h2><span id='topic+adjust'></span><span id='topic+data_adjust'></span>

<h3>Description</h3>

<p>This function can be used to adjust the data for the effect of other
variables present in the dataset. It is based on an underlying fitting of
regressions models, allowing for quite some flexibility, such as including
factors as random effects in mixed models (multilevel partialization),
continuous variables as smooth terms in general additive models (non-linear
partialization) and/or fitting these models under a Bayesian framework. The
values returned by this function are the residuals of the regression models.
Note that a regular correlation between two &quot;adjusted&quot; variables is
equivalent to the partial correlation between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(
  data,
  effect = NULL,
  select = is.numeric,
  exclude = NULL,
  multilevel = FALSE,
  additive = FALSE,
  bayesian = FALSE,
  keep_intercept = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = FALSE
)

data_adjust(
  data,
  effect = NULL,
  select = is.numeric,
  exclude = NULL,
  multilevel = FALSE,
  additive = FALSE,
  bayesian = FALSE,
  keep_intercept = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="adjust_+3A_effect">effect</code></td>
<td>
<p>Character vector of column names to be adjusted for (regressed
out). If <code>NULL</code> (the default), all variables will be selected.</p>
</td></tr>
<tr><td><code id="adjust_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="adjust_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="adjust_+3A_multilevel">multilevel</code></td>
<td>
<p>If <code>TRUE</code>, the factors are included as random factors.
Else, if <code>FALSE</code> (default), they are included as fixed effects in the
simple regression model.</p>
</td></tr>
<tr><td><code id="adjust_+3A_additive">additive</code></td>
<td>
<p>If <code>TRUE</code>, continuous variables as included as smooth terms
in additive models. The goal is to regress-out potential non-linear
effects.</p>
</td></tr>
<tr><td><code id="adjust_+3A_bayesian">bayesian</code></td>
<td>
<p>If <code>TRUE</code>, the models are fitted under the Bayesian framework
using <code>rstanarm</code>.</p>
</td></tr>
<tr><td><code id="adjust_+3A_keep_intercept">keep_intercept</code></td>
<td>
<p>If <code>FALSE</code> (default), the intercept of the model is
re-added. This avoids the centering around 0 that happens by default
when regressing out another variable (see the examples below for a
visual representation of this).</p>
</td></tr>
<tr><td><code id="adjust_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="adjust_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="adjust_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame comparable to <code>data</code>, with adjusted variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
adjusted_all &lt;- adjust(attitude)
head(adjusted_all)
adjusted_one &lt;- adjust(attitude, effect = "complaints", select = "rating")
head(adjusted_one)

adjust(attitude, effect = "complaints", select = "rating", bayesian = TRUE)
adjust(attitude, effect = "complaints", select = "rating", additive = TRUE)
attitude$complaints_LMH &lt;- cut(attitude$complaints, 3)
adjust(attitude, effect = "complaints_LMH", select = "rating", multilevel = TRUE)


# Generate data
data &lt;- simulate_correlation(n = 100, r = 0.7)
data$V2 &lt;- (5 * data$V2) + 20 # Add intercept

# Adjust
adjusted &lt;- adjust(data, effect = "V1", select = "V2")
adjusted_icpt &lt;- adjust(data, effect = "V1", select = "V2", keep_intercept = TRUE)

# Visualize
plot(data$V1, data$V2,
  pch = 19, col = "blue",
  ylim = c(min(adjusted$V2), max(data$V2)),
  main = "Original (blue), adjusted (green), and adjusted - intercept kept (red) data"
)
abline(lm(V2 ~ V1, data = data), col = "blue")
points(adjusted$V1, adjusted$V2, pch = 19, col = "green")
abline(lm(V2 ~ V1, data = adjusted), col = "green")
points(adjusted_icpt$V1, adjusted_icpt$V2, pch = 19, col = "red")
abline(lm(V2 ~ V1, data = adjusted_icpt), col = "red")

</code></pre>

<hr>
<h2 id='assign_labels'>Assign variable and value labels</h2><span id='topic+assign_labels'></span><span id='topic+assign_labels.numeric'></span><span id='topic+assign_labels.data.frame'></span>

<h3>Description</h3>

<p>Assign variable and values labels to a variable or variables in a data frame.
Labels are stored as attributes (<code>"label"</code> for variable labels and <code>"labels"</code>)
for value labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_labels(x, ...)

## S3 method for class 'numeric'
assign_labels(x, variable = NULL, values = NULL, ...)

## S3 method for class 'data.frame'
assign_labels(
  x,
  select = NULL,
  exclude = NULL,
  values = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_labels_+3A_x">x</code></td>
<td>
<p>A data frame, factor or vector.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_variable">variable</code></td>
<td>
<p>The variable label as string.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_values">values</code></td>
<td>
<p>The value labels as (named) character vector. If <code>values</code> is
<em>not</em> a named vector, the length of labels must be equal to the length of
unique values. For a named vector, the left-hand side (LHS) is the value in
<code>x</code>, the right-hand side (RHS) the associated value label. Non-matching
labels are omitted.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="assign_labels_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A labelled variable, or a data frame of labelled variables.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
# labelling by providing required number of labels
assign_labels(
  x,
  variable = "My x",
  values = c("one", "two", "three")
)

# labelling using named vectors
data(iris)
out &lt;- assign_labels(
  iris$Species,
  variable = "Labelled Species",
  values = c(`setosa` = "Spec1", `versicolor` = "Spec2", `virginica` = "Spec3")
)
str(out)

# data frame example
out &lt;- assign_labels(
  iris,
  select = "Species",
  variable = "Labelled Species",
  values = c(`setosa` = "Spec1", `versicolor` = "Spec2", `virginica` = "Spec3")
)
str(out$Species)

# Partial labelling
x &lt;- 1:5
assign_labels(
  x,
  variable = "My x",
  values = c(`1` = "lowest", `5` = "highest")
)
</code></pre>

<hr>
<h2 id='categorize'>Recode (or &quot;cut&quot; / &quot;bin&quot;) data into groups of values.</h2><span id='topic+categorize'></span><span id='topic+categorize.numeric'></span><span id='topic+categorize.data.frame'></span>

<h3>Description</h3>

<p>This functions divides the range of variables into intervals and recodes
the values inside these intervals according to their related interval.
It is basically a wrapper around base R's <code>cut()</code>, providing a simplified
and more accessible way to define the interval breaks (cut-off values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize(x, ...)

## S3 method for class 'numeric'
categorize(
  x,
  split = "median",
  n_groups = NULL,
  range = NULL,
  lowest = 1,
  labels = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
categorize(
  x,
  select = NULL,
  exclude = NULL,
  split = "median",
  n_groups = NULL,
  range = NULL,
  lowest = 1,
  labels = NULL,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorize_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, numeric vector or factor.</p>
</td></tr>
<tr><td><code id="categorize_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="categorize_+3A_split">split</code></td>
<td>
<p>Character vector, indicating at which breaks to split variables,
or numeric values with values indicating breaks. If character, may be one
of <code>"median"</code>, <code>"mean"</code>, <code>"quantile"</code>, <code>"equal_length"</code>, or <code>"equal_range"</code>.
<code>"median"</code> or <code>"mean"</code> will return dichotomous variables, split at their
mean or median, respectively. <code>"quantile"</code> and <code>"equal_length"</code> will split
the variable into <code>n_groups</code> groups, where each group refers to an interval
of a specific range of values. Thus, the length of each interval will be
based on the number of groups. <code>"equal_range"</code> also splits the variable
into multiple groups, however, the length of the interval is given, and
the number of resulting groups (and hence, the number of breaks) will be
determined by how many intervals can be generated, based on the full range
of the variable.</p>
</td></tr>
<tr><td><code id="categorize_+3A_n_groups">n_groups</code></td>
<td>
<p>If <code>split</code> is <code>"quantile"</code> or <code>"equal_length"</code>, this defines
the number of requested groups (i.e. resulting number of levels or values)
for the recoded variable(s). <code>"quantile"</code> will define intervals based
on the distribution of the variable, while <code>"equal_length"</code> tries to
divide the range of the variable into pieces of equal length.</p>
</td></tr>
<tr><td><code id="categorize_+3A_range">range</code></td>
<td>
<p>If <code>split = "equal_range"</code>, this defines the range of values
that are recoded into a new value.</p>
</td></tr>
<tr><td><code id="categorize_+3A_lowest">lowest</code></td>
<td>
<p>Minimum value of the recoded variable(s). If <code>NULL</code> (the default),
for numeric variables, the minimum of the original input is preserved. For
factors, the default minimum is <code>1</code>. For <code>split = "equal_range"</code>, the
default minimum is always <code>1</code>, unless specified otherwise in <code>lowest</code>.</p>
</td></tr>
<tr><td><code id="categorize_+3A_labels">labels</code></td>
<td>
<p>Character vector of value labels. If not <code>NULL</code>, <code>categorize()</code>
will returns factors instead of numeric variables, with <code>labels</code> used
for labelling the factor levels. Can also be <code>"mean"</code> or <code>"median"</code> for a
factor with labels as the mean/median of each groups.</p>
</td></tr>
<tr><td><code id="categorize_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="categorize_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="categorize_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="categorize_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="categorize_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="categorize_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, recoded into groups. By default <code>x</code> is numeric, unless <code>labels</code>
is specified. In this case, a factor is returned, where the factor levels
(i.e. recoded groups are labelled accordingly.
</p>


<h3>Splits and breaks (cut-off values)</h3>

<p>Breaks are in general <em>exclusive</em>, this means that these values indicate
the lower bound of the next group or interval to begin. Take a simple
example, a numeric variable with values from 1 to 9. The median would be 5,
thus the first interval ranges from 1-4 and is recoded into 1, while 5-9
would turn into 2 (compare <code>cbind(1:9, categorize(1:9))</code>). The same variable,
using <code>split = "quantile"</code> and <code>n_groups = 3</code> would define breaks at 3.67
and 6.33 (see <code>quantile(1:9, probs = c(1/3, 2/3))</code>), which means that values
from 1 to 3 belong to the first interval and are recoded into 1 (because
the next interval starts at 3.67), 4 to 6 into 2 and 7 to 9 into 3.
</p>


<h3>Recoding into groups with equal size or range</h3>

<p><code>split = "equal_length"</code> and <code>split = "equal_range"</code> try to divide the
range of <code>x</code> into intervals of similar (or same) length. The difference is
that <code>split = "equal_length"</code> will divide the range of <code>x</code> into <code>n_groups</code>
pieces and thereby defining the intervals used as breaks (hence, it is
equivalent to <code>cut(x, breaks = n_groups)</code>), while  <code>split = "equal_range"</code>
will cut <code>x</code> into intervals that all have the length of <code>range</code>, where the
first interval by defaults starts at <code>1</code>. The lowest (or starting) value
of that interval can be defined using the <code>lowest</code> argument.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- sample(1:10, size = 50, replace = TRUE)

table(x)

# by default, at median
table(categorize(x))

# into 3 groups, based on distribution (quantiles)
table(categorize(x, split = "quantile", n_groups = 3))

# into 3 groups, user-defined break
table(categorize(x, split = c(3, 5)))

set.seed(123)
x &lt;- sample(1:100, size = 500, replace = TRUE)

# into 5 groups, try to recode into intervals of similar length,
# i.e. the range within groups is the same for all groups
table(categorize(x, split = "equal_length", n_groups = 5))

# into 5 groups, try to return same range within groups
# i.e. 1-20, 21-40, 41-60, etc. Since the range of "x" is
# 1-100, and we have a range of 20, this results into 5
# groups, and thus is for this particular case identical
# to the previous result.
table(categorize(x, split = "equal_range", range = 20))

# return factor with value labels instead of numeric value
set.seed(123)
x &lt;- sample(1:10, size = 30, replace = TRUE)
categorize(x, "equal_length", n_groups = 3)
categorize(x, "equal_length", n_groups = 3, labels = c("low", "mid", "high"))

# cut numeric into groups with the mean or median as a label name
x &lt;- sample(1:10, size = 30, replace = TRUE)
categorize(x, "equal_length", n_groups = 3, labels = "mean")
categorize(x, "equal_length", n_groups = 3, labels = "median")
</code></pre>

<hr>
<h2 id='center'>Centering (Grand-Mean Centering)</h2><span id='topic+center'></span><span id='topic+centre'></span><span id='topic+center.numeric'></span><span id='topic+center.data.frame'></span>

<h3>Description</h3>

<p>Performs a grand-mean centering of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(x, ...)

centre(x, ...)

## S3 method for class 'numeric'
center(
  x,
  robust = FALSE,
  weights = NULL,
  reference = NULL,
  center = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
center(
  x,
  select = NULL,
  exclude = NULL,
  robust = FALSE,
  weights = NULL,
  reference = NULL,
  center = NULL,
  force = FALSE,
  remove_na = c("none", "selected", "all"),
  append = FALSE,
  ignore_case = FALSE,
  verbose = TRUE,
  regex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, a (numeric or character) vector or a factor.</p>
</td></tr>
<tr><td><code id="center_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="center_+3A_robust">robust</code></td>
<td>
<p>Logical, if <code>TRUE</code>, centering is done by subtracting the
median from the variables. If <code>FALSE</code>, variables are centered by
subtracting the mean.</p>
</td></tr>
<tr><td><code id="center_+3A_weights">weights</code></td>
<td>
<p>Can be <code>NULL</code> (for no weighting), or:
</p>

<ul>
<li><p> For data frames: a numeric vector of weights, or a character of the
name of a column in the <code>data.frame</code> that contains the weights.
</p>
</li>
<li><p> For numeric vectors: a numeric vector of weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="center_+3A_reference">reference</code></td>
<td>
<p>A data frame or variable from which the centrality and
deviation will be computed instead of from the input variable. Useful for
standardizing a subset or new data according to another data frame.</p>
</td></tr>
<tr><td><code id="center_+3A_center">center</code></td>
<td>
<p>Numeric value, which can be used as alternative to
<code>reference</code> to define a reference centrality. If <code>center</code> is of length 1,
it will be recycled to match the length of selected variables for centering.
Else, <code>center</code> must be of same length as the number of selected variables.
Values in <code>center</code> will be matched to selected variables in the provided
order, unless a named vector is given. In this case, names are matched
against the names of the selected variables.</p>
</td></tr>
<tr><td><code id="center_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="center_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="center_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="center_+3A_force">force</code></td>
<td>
<p>Logical, if <code>TRUE</code>, forces centering of factors as
well. Factors are converted to numerical values, with the lowest level
being the value <code>1</code> (unless the factor has numeric levels, which are
converted to the corresponding numeric value).</p>
</td></tr>
<tr><td><code id="center_+3A_remove_na">remove_na</code></td>
<td>
<p>How should missing values (<code>NA</code>) be treated: if <code>"none"</code>
(default): each column's standardization is done separately, ignoring
<code>NA</code>s. Else, rows with <code>NA</code> in the columns selected with <code>select</code> /
<code>exclude</code> (<code>"selected"</code>) or in all columns (<code>"all"</code>) are dropped before
standardization, and the resulting data frame does not include these cases.</p>
</td></tr>
<tr><td><code id="center_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, centered variables get new
column names (with the suffix <code>"_c"</code>) and are appended (column bind) to <code>x</code>,
thus returning both the original and the centered variables. If <code>FALSE</code>,
original variables in <code>x</code> will be overwritten by their centered versions.
If a character value, centered variables are appended with new column
names (using the defined suffix) to the original data frame.</p>
</td></tr>
<tr><td><code id="center_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="center_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centered variables.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Note</h3>

<p><strong>Difference between centering and standardizing</strong>: Standardized variables
are computed by subtracting the mean of the variable and then dividing it by
the standard deviation, while centering variables involves only the
subtraction.
</p>


<h3>See Also</h3>

<p>If centering within-clusters (instead of grand-mean centering)
is required, see <code><a href="#topic+demean">demean()</a></code>. For standardizing, see <code><a href="#topic+standardize">standardize()</a></code>, and
<code><a href="#topic+makepredictcall.dw_transformer">makepredictcall.dw_transformer()</a></code> for use in model formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

# entire data frame or a vector
head(iris$Sepal.Width)
head(center(iris$Sepal.Width))
head(center(iris))
head(center(iris, force = TRUE))

# only the selected columns from a data frame
center(anscombe, select = c("x1", "x3"))
center(anscombe, exclude = c("x1", "x3"))

# centering with reference center and scale
d &lt;- data.frame(
  a = c(-2, -1, 0, 1, 2),
  b = c(3, 4, 5, 6, 7)
)

# default centering at mean
center(d)

# centering, using 0 as mean
center(d, center = 0)

# centering, using -5 as mean
center(d, center = -5)
</code></pre>

<hr>
<h2 id='coef_var'>Compute the coefficient of variation</h2><span id='topic+coef_var'></span><span id='topic+distribution_cv'></span><span id='topic+distribution_coef_var'></span><span id='topic+coef_var.numeric'></span>

<h3>Description</h3>

<p>Compute the coefficient of variation (CV, ratio of the standard deviation to
the mean, <code class="reqn">\sigma/\mu</code>) for a set of numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_var(x, ...)

distribution_coef_var(x, ...)

## S3 method for class 'numeric'
coef_var(
  x,
  mu = NULL,
  sigma = NULL,
  method = c("standard", "unbiased", "median_mad", "qcd"),
  trim = 0,
  remove_na = FALSE,
  n = NULL,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_var_+3A_x">x</code></td>
<td>
<p>A numeric vector of ratio scale (see details), or vector of values than can be coerced to one.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_...">...</code></td>
<td>
<p>Further arguments passed to computation functions.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of mean values to use to compute the coefficient
of variation. If supplied, <code>x</code> is not used to compute the mean.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_sigma">sigma</code></td>
<td>
<p>A numeric vector of standard deviation values to use to compute the coefficient
of variation. If supplied, <code>x</code> is not used to compute the SD.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_method">method</code></td>
<td>
<p>Method to use to compute the CV. Can be <code>"standard"</code> to compute
by dividing the standard deviation by the mean, <code>"unbiased"</code> for the
unbiased estimator for normally distributed data, or one of two robust
alternatives: <code>"median_mad"</code> to divide the median by the <code><a href="stats.html#topic+mad">stats::mad()</a></code>,
or <code>"qcd"</code> (quartile coefficient of dispersion, interquartile range divided
by the sum of the quartiles [twice the midhinge]: <code class="reqn">(Q_3 - Q_1)/(Q_3 + Q_1)</code>.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_trim">trim</code></td>
<td>
<p>the fraction (0 to 0.5) of values to be trimmed from
each end of <code>x</code> before the mean and standard deviation (or other measures)
are computed. Values of <code>trim</code> outside the range of (0 to 0.5) are taken
as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="coef_var_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical. Should <code>NA</code> values be removed before computing (<code>TRUE</code>)
or not (<code>FALSE</code>, default)?</p>
</td></tr>
<tr><td><code id="coef_var_+3A_n">n</code></td>
<td>
<p>If <code>method = "unbiased"</code> and both <code>mu</code> and <code>sigma</code> are provided (not
computed from <code>x</code>), what sample size to use to adjust the computed CV
for small-sample bias?</p>
</td></tr>
<tr><td><code id="coef_var_+3A_na.rm">na.rm</code></td>
<td>
<p>Deprecated. Please use <code>remove_na</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CV is only applicable of values taken on a ratio scale: values that have a
<em>fixed</em> meaningfully defined 0 (which is either the lowest or highest
possible value), and that ratios between them are interpretable For example,
how many sandwiches have I eaten this week? 0 means &quot;none&quot; and 20 sandwiches
is 4 times more than 5 sandwiches. If I were to center the number of
sandwiches, it will no longer be on a ratio scale (0 is no &quot;none&quot; it is the
mean, and the ratio between 4 and -2 is not meaningful). Scaling a ratio
scale still results in a ratio scale. So I can re define &quot;how many half
sandwiches did I eat this week ( = sandwiches * 0.5) and 0 would still mean
&quot;none&quot;, and 20 half-sandwiches is still 4 times more than 5 half-sandwiches.
</p>
<p>This means that CV is <strong>NOT</strong> invariant to shifting, but it is to scaling:
</p>
<div class="sourceCode r"><pre>sandwiches &lt;- c(0, 4, 15, 0, 0, 5, 2, 7)
coef_var(sandwiches)
#&gt; [1] 1.239094

coef_var(sandwiches / 2) # same
#&gt; [1] 1.239094

coef_var(sandwiches + 4) # different! 0 is no longer meaningful!
#&gt; [1] 0.6290784
</pre></div>


<h3>Value</h3>

<p>The computed coefficient of variation for <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coef_var(1:10)
coef_var(c(1:10, 100), method = "median_mad")
coef_var(c(1:10, 100), method = "qcd")
coef_var(mu = 10, sigma = 20)
coef_var(mu = 10, sigma = 20, method = "unbiased", n = 30)
</code></pre>

<hr>
<h2 id='coerce_to_numeric'>Convert to Numeric (if possible)</h2><span id='topic+coerce_to_numeric'></span>

<h3>Description</h3>

<p>Tries to convert vector to numeric if possible (if no warnings or errors).
Otherwise, leaves it as is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coerce_to_numeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_to_numeric_+3A_x">x</code></td>
<td>
<p>A vector to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector (if possible)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coerce_to_numeric(c("1", "2"))
coerce_to_numeric(c("1", "2", "A"))
</code></pre>

<hr>
<h2 id='contr.deviation'>Deviation Contrast Matrix</h2><span id='topic+contr.deviation'></span>

<h3>Description</h3>

<p>Build a deviation contrast matrix, a type of <em>effects contrast</em> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.deviation(n, base = 1, contrasts = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.deviation_+3A_n">n</code></td>
<td>
<p>a vector of levels for a factor, or the number of levels.</p>
</td></tr>
<tr><td><code id="contr.deviation_+3A_base">base</code></td>
<td>
<p>an integer specifying which group is considered the
baseline group. Ignored if <code>contrasts</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="contr.deviation_+3A_contrasts">contrasts</code></td>
<td>
<p>a logical indicating whether contrasts should be
computed.</p>
</td></tr>
<tr><td><code id="contr.deviation_+3A_sparse">sparse</code></td>
<td>
<p>logical indicating if the result should be sparse
(of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>), using
package <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In effects coding, unlike treatment/dummy coding
(<code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>), each contrast sums to 0. In regressions models,
this results in an intercept that represents the (unweighted) average of the
group means. In ANOVA settings, this also guarantees that lower order effects
represent <em>main</em> effects (and not <em>simple</em> or <em>conditional</em> effects, as is
the case when using R's default <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code>).
<br /><br />
Deviation coding (<code>contr.deviation</code>) is a type of effects coding. With
deviation coding, the coefficients for factor variables are interpreted as
the difference of each factor level from the base level (this is the same
interpretation as with treatment/dummy coding). For example, for a factor
<code>group</code> with levels &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;, with <code>contr.devation</code>, the intercept
represents the overall mean (average of the group means for the 3 groups),
and the coefficients <code>groupB</code> and <code>groupC</code> represent the differences between
the A group mean and the B and C group means, respectively.
<br /><br />
Sum coding (<code><a href="stats.html#topic+contrast">stats::contr.sum()</a></code>) is another type of effects coding. With sum
coding, the coefficients for factor variables are interpreted as the
difference of each factor level from <strong>the grand (across-groups) mean</strong>. For
example, for a factor <code>group</code> with levels &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;, with
<code>contr.sum</code>, the intercept represents the overall mean (average of the group
means for the 3 groups), and the coefficients <code>group1</code> and <code>group2</code> represent
the differences the
<strong>A</strong> and <strong>B</strong> group means from the overall mean, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contrast">stats::contr.sum()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("mtcars")

mtcars &lt;- data_modify(mtcars, cyl = factor(cyl))

c.treatment &lt;- cbind(Intercept = 1, contrasts(mtcars$cyl))
solve(c.treatment)
#&gt;            4 6 8
#&gt; Intercept  1 0 0  # mean of the 1st level
#&gt; 6         -1 1 0  # 2nd level - 1st level
#&gt; 8         -1 0 1  # 3rd level - 1st level

contrasts(mtcars$cyl) &lt;- contr.sum
c.sum &lt;- cbind(Intercept = 1, contrasts(mtcars$cyl))
solve(c.sum)
#&gt;                4      6      8
#&gt; Intercept  0.333  0.333  0.333   # overall mean
#&gt;            0.667 -0.333 -0.333   # deviation of 1st from overall mean
#&gt;           -0.333  0.667 -0.333   # deviation of 2nd from overall mean


contrasts(mtcars$cyl) &lt;- contr.deviation
c.deviation &lt;- cbind(Intercept = 1, contrasts(mtcars$cyl))
solve(c.deviation)
#&gt;                4     6     8
#&gt; Intercept  0.333 0.333 0.333   # overall mean
#&gt; 6         -1.000 1.000 0.000   # 2nd level - 1st level
#&gt; 8         -1.000 0.000 1.000   # 3rd level - 1st level

## With Interactions -----------------------------------------
mtcars &lt;- data_modify(mtcars, am = C(am, contr = contr.deviation))
mtcars &lt;- data_arrange(mtcars, select = c("cyl", "am"))

mm &lt;- unique(model.matrix(~ cyl * am, data = mtcars))
rownames(mm) &lt;- c(
  "cyl4.am0", "cyl4.am1", "cyl6.am0",
  "cyl6.am1", "cyl8.am0", "cyl8.am1"
)

solve(mm)
#&gt;             cyl4.am0 cyl4.am1 cyl6.am0 cyl6.am1 cyl8.am0 cyl8.am1
#&gt; (Intercept)    0.167    0.167    0.167    0.167    0.167    0.167  # overall mean
#&gt; cyl6          -0.500   -0.500    0.500    0.500    0.000    0.000  # cyl MAIN eff: 2nd - 1st
#&gt; cyl8          -0.500   -0.500    0.000    0.000    0.500    0.500  # cyl MAIN eff: 2nd - 1st
#&gt; am1           -0.333    0.333   -0.333    0.333   -0.333    0.333  # am MAIN eff
#&gt; cyl6:am1       1.000   -1.000   -1.000    1.000    0.000    0.000
#&gt; cyl8:am1       1.000   -1.000    0.000    0.000   -1.000    1.000


</code></pre>

<hr>
<h2 id='convert_na_to'>Replace missing values in a variable or a data frame.</h2><span id='topic+convert_na_to'></span><span id='topic+convert_na_to.numeric'></span><span id='topic+convert_na_to.character'></span><span id='topic+convert_na_to.data.frame'></span>

<h3>Description</h3>

<p>Replace missing values in a variable or a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_na_to(x, ...)

## S3 method for class 'numeric'
convert_na_to(x, replacement = NULL, verbose = TRUE, ...)

## S3 method for class 'character'
convert_na_to(x, replacement = NULL, verbose = TRUE, ...)

## S3 method for class 'data.frame'
convert_na_to(
  x,
  select = NULL,
  exclude = NULL,
  replacement = NULL,
  replace_num = replacement,
  replace_char = replacement,
  replace_fac = replacement,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_na_to_+3A_x">x</code></td>
<td>
<p>A numeric, factor, or character vector, or a data frame.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_replacement">replacement</code></td>
<td>
<p>Numeric or character value that will be used to
replace <code>NA</code>.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_replace_num">replace_num</code></td>
<td>
<p>Value to replace <code>NA</code> when variable is of type numeric.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_replace_char">replace_char</code></td>
<td>
<p>Value to replace <code>NA</code> when variable is of type character.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_replace_fac">replace_fac</code></td>
<td>
<p>Value to replace <code>NA</code> when variable is of type factor.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="convert_na_to_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, where <code>NA</code> values are replaced by <code>replacement</code>.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert NA to 0 in a numeric vector
convert_na_to(
  c(9, 3, NA, 2, 3, 1, NA, 8),
  replacement = 0
)

# Convert NA to "missing" in a character vector
convert_na_to(
  c("a", NA, "d", "z", NA, "t"),
  replacement = "missing"
)

### For data frames

test_df &lt;- data.frame(
  x = c(1, 2, NA),
  x2 = c(4, 5, NA),
  y = c("a", "b", NA)
)

# Convert all NA to 0 in numeric variables, and all NA to "missing" in
# character variables
convert_na_to(
  test_df,
  replace_num = 0,
  replace_char = "missing"
)

# Convert a specific variable in the data frame
convert_na_to(
  test_df,
  replace_num = 0,
  replace_char = "missing",
  select = "x"
)

# Convert all variables starting with "x"
convert_na_to(
  test_df,
  replace_num = 0,
  replace_char = "missing",
  select = starts_with("x")
)

# Convert NA to 1 in variable 'x2' and to 0 in all other numeric
# variables
convert_na_to(
  test_df,
  replace_num = 0,
  select = list(x2 = 1)
)

</code></pre>

<hr>
<h2 id='convert_to_na'>Convert non-missing values in a variable into missing values.</h2><span id='topic+convert_to_na'></span><span id='topic+convert_to_na.numeric'></span><span id='topic+convert_to_na.factor'></span><span id='topic+convert_to_na.data.frame'></span>

<h3>Description</h3>

<p>Convert non-missing values in a variable into missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_na(x, ...)

## S3 method for class 'numeric'
convert_to_na(x, na = NULL, verbose = TRUE, ...)

## S3 method for class 'factor'
convert_to_na(x, na = NULL, drop_levels = FALSE, verbose = TRUE, ...)

## S3 method for class 'data.frame'
convert_to_na(
  x,
  select = NULL,
  exclude = NULL,
  na = NULL,
  drop_levels = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_na_+3A_x">x</code></td>
<td>
<p>A vector, factor or a data frame.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_na">na</code></td>
<td>
<p>Numeric, character vector or logical (or a list of numeric, character
vectors or logicals) with values that should be converted to <code>NA</code>. Numeric
values applied to numeric vectors, character values are used for factors,
character vectors or date variables, and logical values for logical vectors.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_drop_levels">drop_levels</code></td>
<td>
<p>Logical, for factors, when specific levels are replaced
by <code>NA</code>, should unused levels be dropped?</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="convert_to_na_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, where all values in <code>na</code> are converted to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:6, size = 30, replace = TRUE)
x
# values 4 and 5 to NA
convert_to_na(x, na = 4:5)

# data frames
set.seed(123)
x &lt;- data.frame(
  a = sample(1:6, size = 20, replace = TRUE),
  b = sample(letters[1:6], size = 20, replace = TRUE),
  c = sample(c(30:33, 99), size = 20, replace = TRUE)
)
# for all numerics, convert 5 to NA. Character/factor will be ignored.
convert_to_na(x, na = 5)

# for numerics, 5 to NA, for character/factor, "f" to NA
convert_to_na(x, na = list(6, "f"))

# select specific variables
convert_to_na(x, select = c("a", "b"), na = list(6, "f"))
</code></pre>

<hr>
<h2 id='data_addprefix'>Rename columns and variable names</h2><span id='topic+data_addprefix'></span><span id='topic+data_addsuffix'></span><span id='topic+data_rename'></span><span id='topic+data_rename_rows'></span>

<h3>Description</h3>

<p>Safe and intuitive functions to rename variables or rows in
data frames. <code>data_rename()</code> will rename column names, i.e. it facilitates
renaming variables <code>data_addprefix()</code> or <code>data_addsuffix()</code> add prefixes
or suffixes to column names. <code>data_rename_rows()</code> is a convenient shortcut
to add or rename row names of a data frame, but unlike <code>row.names()</code>, its
input and output is a data frame, thus, integrating smoothly into a possible
pipe-workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_addprefix(
  data,
  pattern,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_addsuffix(
  data,
  pattern,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_rename(
  data,
  pattern = NULL,
  replacement = NULL,
  safe = TRUE,
  verbose = TRUE,
  ...
)

data_rename_rows(data, rows = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_addprefix_+3A_data">data</code></td>
<td>
<p>A data frame, or an object that can be coerced to a data frame.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_pattern">pattern</code></td>
<td>
<p>Character vector. For <code>data_rename()</code>, indicates columns that
should be selected for renaming. Can be <code>NULL</code> (in which case all columns
are selected). For <code>data_addprefix()</code> or <code>data_addsuffix()</code>, a character
string, which will be added as prefix or suffix to the column names.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_...">...</code></td>
<td>
<p>Other arguments passed to or from other functions.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_replacement">replacement</code></td>
<td>
<p>Character vector. Indicates the new name of the columns
selected in <code>pattern</code>. Can be <code>NULL</code> (in which case column are numbered
in sequential order). If not <code>NULL</code>, <code>pattern</code> and <code>replacement</code> must be
of the same length.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_safe">safe</code></td>
<td>
<p>Do not throw error if for instance the variable to be
renamed/removed doesn't exist.</p>
</td></tr>
<tr><td><code id="data_addprefix_+3A_rows">rows</code></td>
<td>
<p>Vector of row names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Add prefix / suffix to all columns
head(data_addprefix(iris, "NEW_"))
head(data_addsuffix(iris, "_OLD"))

# Rename columns
head(data_rename(iris, "Sepal.Length", "length"))
# data_rename(iris, "FakeCol", "length", safe=FALSE)  # This fails
head(data_rename(iris, "FakeCol", "length")) # This doesn't
head(data_rename(iris, c("Sepal.Length", "Sepal.Width"), c("length", "width")))

# Reset names
head(data_rename(iris, NULL))

# Change all
head(data_rename(iris, replacement = paste0("Var", 1:5)))

</code></pre>

<hr>
<h2 id='data_arrange'>Arrange rows by column values</h2><span id='topic+data_arrange'></span>

<h3>Description</h3>

<p><code>data_arrange()</code> orders the rows of a data frame by the values of selected
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_arrange(data, select = NULL, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_arrange_+3A_data">data</code></td>
<td>
<p>A data frame, or an object that can be coerced to a data frame.</p>
</td></tr>
<tr><td><code id="data_arrange_+3A_select">select</code></td>
<td>
<p>Character vector of column names. Use a dash just before column
name to arrange in decreasing order, for example <code>"-x1"</code>.</p>
</td></tr>
<tr><td><code id="data_arrange_+3A_safe">safe</code></td>
<td>
<p>Do not throw an error if one of the variables specified doesn't
exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Arrange using several variables
data_arrange(head(mtcars), c("gear", "carb"))

# Arrange in decreasing order
data_arrange(head(mtcars), "-carb")

# Throw an error if one of the variables specified doesn't exist
try(data_arrange(head(mtcars), c("gear", "foo"), safe = FALSE))
</code></pre>

<hr>
<h2 id='data_codebook'>Generate a codebook of a data frame.</h2><span id='topic+data_codebook'></span><span id='topic+print_html.data_codebook'></span>

<h3>Description</h3>

<p><code>data_codebook()</code> generates codebooks from data frames, i.e. overviews
of all variables and some more information about each variable (like
labels, values or value range, frequencies, amount of missing values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_codebook(
  data,
  select = NULL,
  exclude = NULL,
  variable_label_width = NULL,
  value_label_width = NULL,
  max_values = 10,
  range_at = 6,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'data_codebook'
print_html(
  x,
  font_size = "100%",
  line_padding = 3,
  row_color = "#eeeeee",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_codebook_+3A_data">data</code></td>
<td>
<p>A data frame, or an object that can be coerced to a data frame.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_variable_label_width">variable_label_width</code></td>
<td>
<p>Length of variable labels. Longer labels will be
wrapped at <code>variable_label_width</code> chars. If <code>NULL</code>, longer labels will not
be split into multiple lines. Only applies to <em>labelled data</em>.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_value_label_width">value_label_width</code></td>
<td>
<p>Length of value labels. Longer labels will be
shortened, where the remaining part is truncated. Only applies to
<em>labelled data</em> or factor levels.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_max_values">max_values</code></td>
<td>
<p>Number of maximum values that should be displayed. Can be
used to avoid too many rows when variables have lots of unique values.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_range_at">range_at</code></td>
<td>
<p>Indicates how many unique values in a numeric vector are
needed in order to print a range for that variable instead of a frequency
table for all numeric values. Can be useful if the data contains numeric
variables with only a few unique values and where full frequency tables
instead of value ranges should be displayed.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages on or off.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, a vector or a statistical model (for
<code>unstandardize()</code> cannot be a model).</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_font_size">font_size</code></td>
<td>
<p>For HTML tables, the font size.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_line_padding">line_padding</code></td>
<td>
<p>For HTML tables, the distance (in pixel) between lines.</p>
</td></tr>
<tr><td><code id="data_codebook_+3A_row_color">row_color</code></td>
<td>
<p>For HTML tables, the fill color for odd rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted data frame, summarizing the content of the data frame.
Returned columns include the column index of the variables in the original
data frame (<code>ID</code>), column name, variable label (if data is labelled), type
of variable, number of missing values, unique values (or value range),
value labels (for labelled data), and a frequency table (N for each value).
Most columns are formatted as character vectors.
</p>


<h3>Note</h3>

<p>There are methods to <code>print()</code> the data frame in a nicer output, as
well methods for printing in markdown or HTML format (<code>print_md()</code> and
<code>print_html()</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
data_codebook(iris, select = starts_with("Sepal"))

data(efc)
data_codebook(efc)

# shorten labels
data_codebook(efc, variable_label_width = 20, value_label_width = 15)

# automatic range for numerics at more than 5 unique values
data(mtcars)
data_codebook(mtcars, select = starts_with("c"))

# force all values to be displayed
data_codebook(mtcars, select = starts_with("c"), range_at = 100)
</code></pre>

<hr>
<h2 id='data_duplicated'>Extract all duplicates</h2><span id='topic+data_duplicated'></span>

<h3>Description</h3>

<p>Extract all duplicates, for visual inspection.
Note that it also contains the first occurrence of future
duplicates, unlike <code><a href="base.html#topic+duplicated">duplicated()</a></code> or <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>). Also
contains an additional column reporting the number of missing
values for that row, to help in the decision-making when
selecting which duplicates to keep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_duplicated(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_duplicated_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_duplicated_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_duplicated_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_duplicated_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_duplicated_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_duplicated_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe, containing all duplicates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_unique">data_unique()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  id = c(1, 2, 3, 1, 3),
  year = c(2022, 2022, 2022, 2022, 2000),
  item1 = c(NA, 1, 1, 2, 3),
  item2 = c(NA, 1, 1, 2, 3),
  item3 = c(NA, 1, 1, 2, 3)
)

data_duplicated(df1, select = "id")

data_duplicated(df1, select = c("id", "year"))

# Filter to exclude duplicates
df2 &lt;- df1[-c(1, 5), ]
df2

</code></pre>

<hr>
<h2 id='data_extract'>Extract one or more columns or elements from an object</h2><span id='topic+data_extract'></span><span id='topic+data_extract.data.frame'></span>

<h3>Description</h3>

<p><code>data_extract()</code> (or its alias <code>extract()</code>) is similar to <code>$</code>. It extracts
either a single column or element from an object (e.g., a data frame, list),
or multiple columns resp. elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_extract(data, select, ...)

## S3 method for class 'data.frame'
data_extract(
  data,
  select,
  name = NULL,
  extract = "all",
  as_data_frame = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_extract_+3A_data">data</code></td>
<td>
<p>The object to subset. Methods are currently available for data frames
and data frame extensions (e.g., tibbles).</p>
</td></tr>
<tr><td><code id="data_extract_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_...">...</code></td>
<td>
<p>For use by future methods.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_name">name</code></td>
<td>
<p>An optional argument that specifies the column to be used as
names for the vector elements after extraction. Must be specified either
as literal variable name (e.g., <code>column_name</code>) or as string
(<code>"column_name"</code>). <code>name</code> will be ignored when a data frame is returned.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_extract">extract</code></td>
<td>
<p>String, indicating which element will be extracted when <code>select</code>
matches multiple variables. Can be <code>"all"</code> (the default) to return all
matched variables, <code>"first"</code> or <code>"last"</code> to return the first or last match,
or <code>"odd"</code> and <code>"even"</code> to return all odd-numbered or even-numbered
matches. Note that <code>"first"</code> or <code>"last"</code> return a vector (unless
<code>as_data_frame = TRUE</code>), while <code>"all"</code> can return a vector (if only one
match was found) <em>or</em> a data frame (for more than one match). Type safe
return values are only possible when <code>extract</code> is <code>"first"</code> or <code>"last"</code> (will
always return a vector) or when <code>as_data_frame = TRUE</code> (always returns a
data frame).</p>
</td></tr>
<tr><td><code id="data_extract_+3A_as_data_frame">as_data_frame</code></td>
<td>
<p>Logical, if <code>TRUE</code>, will always return a data frame,
even if only one variable was matched. If <code>FALSE</code>, either returns a vector
or a data frame. See <code>extract</code> for details.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_extract_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data_extract()</code> can be used to select multiple variables or pull a
single variable from a data frame. Thus, the return value is by default not
type safe - <code>data_extract()</code> either returns a vector or a data frame.
</p>


<h4>Extracting single variables (vectors)</h4>

<p>When <code>select</code> is the name of a single column, or when select only matches
one column, a vector is returned. A single variable is also returned when
<code>extract</code> is either <code style="white-space: pre;">&#8288;"first&#8288;</code> or <code>"last"</code>. Setting <code>as_data_frame</code> to <code>TRUE</code>
overrides this behaviour and <em>always</em> returns a data frame.
</p>



<h4>Extracting a data frame of variables</h4>

<p>When <code>select</code> is a character vector containing more than one column name (or
a numeric vector with more than one valid column indices), or when <code>select</code>
uses one of the supported select-helpers that match multiple columns, a
data frame is returned. Setting <code>as_data_frame</code> to <code>TRUE</code> <em>always</em> returns
a data frame.
</p>



<h3>Value</h3>

<p>A vector (or a data frame) containing the extracted element, or
<code>NULL</code> if no matching variable was found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single variable
data_extract(mtcars, cyl, name = gear)
data_extract(mtcars, "cyl", name = gear)
data_extract(mtcars, -1, name = gear)
data_extract(mtcars, cyl, name = 0)
data_extract(mtcars, cyl, name = "row.names")

# selecting multiple variables
head(data_extract(iris, starts_with("Sepal")))
head(data_extract(iris, ends_with("Width")))
head(data_extract(iris, 2:4))

# select first of multiple variables
data_extract(iris, starts_with("Sepal"), extract = "first")

# select first of multiple variables, return as data frame
head(data_extract(iris, starts_with("Sepal"), extract = "first", as_data_frame = TRUE))
</code></pre>

<hr>
<h2 id='data_group'>Create a grouped data frame</h2><span id='topic+data_group'></span><span id='topic+data_ungroup'></span>

<h3>Description</h3>

<p>This function is comparable to <code>dplyr::group_by()</code>, but just
following the <strong>datawizard</strong> function design. <code>data_ungroup()</code> removes the
grouping information from a grouped data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_group(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_ungroup(data, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_group_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="data_group_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_group_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_group_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_group_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_group_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_group_+3A_...">...</code></td>
<td>
<p>Arguments passed down to other functions. Mostly not used yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped data frame, i.e. a data frame with additional information
about the grouping structure saved as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(efc)
suppressPackageStartupMessages(library(poorman, quietly = TRUE))

# total mean
efc %&gt;%
  summarize(mean_hours = mean(c12hour, na.rm = TRUE))

# mean by educational level
efc %&gt;%
  data_group(c172code) %&gt;%
  summarize(mean_hours = mean(c12hour, na.rm = TRUE))

</code></pre>

<hr>
<h2 id='data_match'>Return filtered or sliced data frame, or row indices</h2><span id='topic+data_match'></span><span id='topic+data_filter'></span>

<h3>Description</h3>

<p>Return a filtered (or sliced) data frame or row indices of a data frame that
match a specific condition. <code>data_filter()</code> works like <code>data_match()</code>, but works
with logical expressions or row indices of a data frame to specify matching
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_match(x, to, match = "and", return_indices = FALSE, drop_na = TRUE, ...)

data_filter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_match_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_match_+3A_to">to</code></td>
<td>
<p>A data frame matching the specified conditions. Note that if
<code>match</code> is a value other than <code>"and"</code>, the original row order might be
changed. See 'Details'.</p>
</td></tr>
<tr><td><code id="data_match_+3A_match">match</code></td>
<td>
<p>String, indicating with which logical operation matching
conditions should be combined. Can be <code>"and"</code> (or <code>"&amp;"</code>), <code>"or"</code> (or <code>"|"</code>)
or <code>"not"</code> (or <code>"!"</code>).</p>
</td></tr>
<tr><td><code id="data_match_+3A_return_indices">return_indices</code></td>
<td>
<p>Logical, if <code>FALSE</code>, return the vector of rows that
can be used to filter the original data frame. If <code>FALSE</code> (default),
returns directly the filtered data frame instead of the row indices.</p>
</td></tr>
<tr><td><code id="data_match_+3A_drop_na">drop_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values (<code>NA</code>s) are removed before
filtering the data. This is the default behaviour, however, sometimes when
row indices are requested (i.e. <code>return_indices=TRUE</code>), it might be useful
to preserve <code>NA</code> values, so returned row indices match the row indices of
the original data frame.</p>
</td></tr>
<tr><td><code id="data_match_+3A_...">...</code></td>
<td>
<p>A sequence of logical expressions indicating which rows to keep,
or a numeric vector indicating the row indices of rows to keep. Can also be
a string representation of a logical expression (e.g. <code>"x &gt; 4"</code>), a
character vector (e.g. <code>c("x &gt; 4", "y == 2")</code>) or a variable that contains
the string representation of a logical expression. These might be useful
when used in packages to avoid defining undefined global variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>data_match()</code>, if <code>match</code> is either <code>"or"</code> or <code>"not"</code>, the
original row order from <code>x</code> might be changed. If preserving row order is
required, use <code>data_filter()</code> instead.
</p>
<div class="sourceCode"><pre># mimics subset() behaviour, preserving original row order
head(data_filter(mtcars[c("mpg", "vs", "am")], vs == 0 | am == 1))
#&gt;                    mpg vs am
#&gt; Mazda RX4         21.0  0  1
#&gt; Mazda RX4 Wag     21.0  0  1
#&gt; Datsun 710        22.8  1  1
#&gt; Hornet Sportabout 18.7  0  0
#&gt; Duster 360        14.3  0  0
#&gt; Merc 450SE        16.4  0  0

# re-sorting rows
head(data_match(mtcars[c("mpg", "vs", "am")],
                data.frame(vs = 0, am = 1),
                match = "or"))
#&gt;                    mpg vs am
#&gt; Mazda RX4         21.0  0  1
#&gt; Mazda RX4 Wag     21.0  0  1
#&gt; Hornet Sportabout 18.7  0  0
#&gt; Duster 360        14.3  0  0
#&gt; Merc 450SE        16.4  0  0
#&gt; Merc 450SL        17.3  0  0
</pre></div>
<p>While <code>data_match()</code> works with data frames to match conditions against,
<code>data_filter()</code> is basically a wrapper around <code style="white-space: pre;">&#8288;subset(subset = &lt;filter&gt;)&#8288;</code>.
However, unlike <code>subset()</code>, it preserves label attributes and is useful when
working with labelled data.
</p>


<h3>Value</h3>

<p>A filtered data frame, or the row indices that match the specified
configuration.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data_match(mtcars, data.frame(vs = 0, am = 1))
data_match(mtcars, data.frame(vs = 0, am = c(0, 1)))

# observations where "vs" is NOT 0 AND "am" is NOT 1
data_match(mtcars, data.frame(vs = 0, am = 1), match = "not")
# equivalent to
data_filter(mtcars, vs != 0 &amp; am != 1)

# observations where EITHER "vs" is 0 OR "am" is 1
data_match(mtcars, data.frame(vs = 0, am = 1), match = "or")
# equivalent to
data_filter(mtcars, vs == 0 | am == 1)

# slice data frame by row indices
data_filter(mtcars, 5:10)

# Define a custom function containing data_filter()
my_filter &lt;- function(data, variable) {
  data_filter(data, variable)
}
my_filter(mtcars, "cyl == 6")

# Pass complete filter-condition as string.
my_filter &lt;- function(data, condition) {
  data_filter(data, condition)
}
my_filter(mtcars, "am != 0")

# string can also be used directly as argument
data_filter(mtcars, "am != 0")

# or as variable
fl &lt;- "am != 0"
data_filter(mtcars, fl)
</code></pre>

<hr>
<h2 id='data_merge'>Merge (join) two data frames, or a list of data frames</h2><span id='topic+data_merge'></span><span id='topic+data_join'></span><span id='topic+data_merge.data.frame'></span><span id='topic+data_merge.list'></span>

<h3>Description</h3>

<p>Merge (join) two data frames, or a list of data frames. However, unlike
base R's <code>merge()</code>, <code>data_merge()</code> offers a few more methods to join data
frames, and it does not drop data frame nor column attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_merge(x, ...)

data_join(x, ...)

## S3 method for class 'data.frame'
data_merge(x, y, join = "left", by = NULL, id = NULL, verbose = TRUE, ...)

## S3 method for class 'list'
data_merge(x, join = "left", by = NULL, id = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_merge_+3A_x">x</code>, <code id="data_merge_+3A_y">y</code></td>
<td>
<p>A data frame to merge. <code>x</code> may also be a list of data frames
that will be merged. Note that the list-method has no <code>y</code> argument.</p>
</td></tr>
<tr><td><code id="data_merge_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="data_merge_+3A_join">join</code></td>
<td>
<p>Character vector, indicating the method of joining the data frames.
Can be <code>"full"</code>, <code>"left"</code> (default), <code>"right"</code>, <code>"inner"</code>, <code>"anti"</code>, <code>"semi"</code>
or <code>"bind"</code>. See details below.</p>
</td></tr>
<tr><td><code id="data_merge_+3A_by">by</code></td>
<td>
<p>Specifications of the columns used for merging.</p>
</td></tr>
<tr><td><code id="data_merge_+3A_id">id</code></td>
<td>
<p>Optional name for ID column that will be created to indicate the
source data frames for appended rows. Only applies if <code>join = "bind"</code>.</p>
</td></tr>
<tr><td><code id="data_merge_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Merging data frames</h4>

<p>Merging data frames is performed by adding rows (cases), columns
(variables) or both from the source data frame (<code>y</code>) to the target
data frame (<code>x</code>). This usually requires one or more variables which
are included in both data frames and that are used for merging, typically
indicated with the <code>by</code> argument. When <code>by</code> contains a variable present
in both data frames, cases are matched and filtered by identical values
of <code>by</code> in <code>x</code> and <code>y</code>.
</p>



<h4>Left- and right-joins</h4>

<p>Left- and right joins usually don't add new rows (cases), but only new
columns (variables) for existing cases in <code>x</code>. For <code>join = "left"</code> or
<code>join = "right"</code> to work, <code>by</code> <em>must</em> indicate one or more columns that
are included in both data frames. For <code>join = "left"</code>, if <code>by</code> is an
identifier variable, which is included in both <code>x</code> and <code>y</code>, all variables
from <code>y</code> are copied to <code>x</code>, but only those cases from <code>y</code> that have
matching values in their identifier variable in <code>x</code> (i.e. all cases
in <code>x</code> that are also found in <code>y</code> get the related values from the new
columns in <code>y</code>). If there is no match between identifiers in <code>x</code> and <code>y</code>,
the copied variable from <code>y</code> will get a <code>NA</code> value for this particular
case. Other variables that occur both in <code>x</code> and <code>y</code>, but are not used
as identifiers (with <code>by</code>), will be renamed to avoid multiple identical
variable names. Cases in <code>y</code> where values from the identifier have no
match in <code>x</code>'s identifier are removed. <code>join = "right"</code> works in
a similar way as <code>join = "left"</code>, just that only cases from <code>x</code> that
have matching values in their identifier variable in <code>y</code> are chosen.
<br /> <br />
In base R, these are equivalent to <code>merge(x, y, all.x = TRUE)</code> and
<code>merge(x, y, all.y = TRUE)</code>.
</p>



<h4>Full joins</h4>

<p>Full joins copy all cases from <code>y</code> to <code>x</code>. For matching cases in both
data frames, values for new variables are copied from <code>y</code> to <code>x</code>. For
cases in <code>y</code> not present in <code>x</code>, these will be added as new rows to <code>x</code>.
Thus, full joins not only add new columns (variables), but also might
add new rows (cases).
<br /> <br />
In base R, this is equivalent to <code>merge(x, y, all = TRUE)</code>.
</p>



<h4>Inner joins</h4>

<p>Inner joins merge two data frames, however, only those rows (cases) are
kept that are present in both data frames. Thus, inner joins usually
add new columns (variables), but also remove rows (cases) that only
occur in one data frame.
<br /> <br />
In base R, this is equivalent to <code>merge(x, y)</code>.
</p>



<h4>Binds</h4>

<p><code>join = "bind"</code> row-binds the complete second data frame <code>y</code> to <code>x</code>.
Unlike simple <code>rbind()</code>, which requires the same columns for both data
frames, <code>join = "bind"</code> will bind shared columns from <code>y</code> to <code>x</code>, and
add new columns from <code>y</code> to <code>x</code>.
</p>



<h3>Value</h3>

<p>A merged data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(a = 1:3, b = c("a", "b", "c"), c = 5:7, id = 1:3)
y &lt;- data.frame(c = 6:8, d = c("f", "g", "h"), e = 100:102, id = 2:4)

x
y

# "by" will default to all shared columns, i.e. "c" and "id". new columns
# "d" and "e" will be copied from "y" to "x", but there are only two cases
# in "x" that have the same values for "c" and "id" in "y". only those cases
# have values in the copied columns, the other case gets "NA".
data_merge(x, y, join = "left")

# we change the id-value here
x &lt;- data.frame(a = 1:3, b = c("a", "b", "c"), c = 5:7, id = 1:3)
y &lt;- data.frame(c = 6:8, d = c("f", "g", "h"), e = 100:102, id = 3:5)

x
y

# no cases in "y" have the same matching "c" and "id" as in "x", thus
# copied variables from "y" to "x" copy no values, all get NA.
data_merge(x, y, join = "left")

# one case in "y" has a match in "id" with "x", thus values for this
# case from the remaining variables in "y" are copied to "x", all other
# values (cases) in those remaining variables get NA
data_merge(x, y, join = "left", by = "id")

data(mtcars)
x &lt;- mtcars[1:5, 1:3]
y &lt;- mtcars[28:32, 4:6]

# add ID common column
x$id &lt;- 1:5
y$id &lt;- 3:7

# left-join, add new variables and copy values from y to x,
# where "id" values match
data_merge(x, y)

# right-join, add new variables and copy values from x to y,
# where "id" values match
data_merge(x, y, join = "right")

# full-join
data_merge(x, y, join = "full")


data(mtcars)
x &lt;- mtcars[1:5, 1:3]
y &lt;- mtcars[28:32, c(1, 4:5)]

# add ID common column
x$id &lt;- 1:5
y$id &lt;- 3:7

# left-join, no matching rows (because columns "id" and "disp" are used)
# new variables get all NA values
data_merge(x, y)

# one common value in "mpg", so one row from y is copied to x
data_merge(x, y, by = "mpg")

# only keep rows with matching values in by-column
data_merge(x, y, join = "semi", by = "mpg")

# only keep rows with non-matching values in by-column
data_merge(x, y, join = "anti", by = "mpg")

# merge list of data frames. can be of different rows
x &lt;- mtcars[1:5, 1:3]
y &lt;- mtcars[28:31, 3:5]
z &lt;- mtcars[11:18, c(1, 3:4, 6:8)]
x$id &lt;- 1:5
y$id &lt;- 4:7
z$id &lt;- 3:10
data_merge(list(x, y, z), join = "bind", by = "id", id = "source")
</code></pre>

<hr>
<h2 id='data_modify'>Create new variables in a data frame</h2><span id='topic+data_modify'></span><span id='topic+data_modify.data.frame'></span>

<h3>Description</h3>

<p>Create new variables or modify existing variables in a data frame. Unlike <code>base::transform()</code>, <code>data_modify()</code>
can be used on grouped data frames, and newly created variables can be directly
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_modify(data, ...)

## S3 method for class 'data.frame'
data_modify(data, ..., .if = NULL, .at = NULL, .modify = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_modify_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="data_modify_+3A_...">...</code></td>
<td>
<p>One or more expressions that define the new variable name and the
values or recoding of those new variables. These expressions can be one of:
</p>

<ul>
<li><p> A sequence of named, literal expressions, where the left-hand side refers
to the name of the new variable, while the right-hand side represent the
values of the new variable. Example: <code>Sepal.Width = center(Sepal.Width)</code>.
</p>
</li>
<li><p> A sequence of string values, representing expressions.
</p>
</li>
<li><p> A variable that contains a string representation of the expression. Example:
</p>
<div class="sourceCode r"><pre>a &lt;- "2 * Sepal.Width"
data_modify(iris, a)
</pre></div>
</li>
<li><p> A character vector of expressions. Example:
<code>c("SW_double = 2 * Sepal.Width", "SW_fraction = SW_double / 10")</code>. This
type of expression cannot be mixed with other expressions, i.e. if a
character vector is provided, you may not add further elements to <code>...</code>.
</p>
</li>
<li><p> Using <code>NULL</code> as right-hand side removes a variable from the data frame.
Example: <code>Petal.Width = NULL</code>.
</p>
</li></ul>

<p>Note that newly created variables can be used in subsequent expressions,
including <code>.at</code> or <code>.if</code>. See also 'Examples'.</p>
</td></tr>
<tr><td><code id="data_modify_+3A_.if">.if</code></td>
<td>
<p>A function that returns <code>TRUE</code> for columns in the data frame where
<code>.if</code> applies. This argument is used in combination with the <code>.modify</code> argument.
Note that only one of <code>.at</code> or <code>.if</code> can be provided, but not both at the same
time. Newly created variables in <code>...</code> can also be selected, see 'Examples'.</p>
</td></tr>
<tr><td><code id="data_modify_+3A_.at">.at</code></td>
<td>
<p>A character vector of variable names that should be modified. This
argument is used in combination with the <code>.modify</code> argument. Note that only one
of <code>.at</code> or <code>.if</code> can be provided, but not both at the same time. Newly created
variables in <code>...</code> can also be selected, see 'Examples'.</p>
</td></tr>
<tr><td><code id="data_modify_+3A_.modify">.modify</code></td>
<td>
<p>A function that modifies the variables defined in <code>.at</code> or <code>.if</code>.
This argument is used in combination with either the <code>.at</code> or the <code>.if</code> argument.
Note that the modified variable (i.e. the result from <code>.modify</code>) must be either
of length 1 or of same length as the input variable.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>data_modify()</code> can also be used inside functions. However, it is
recommended to pass the recode-expression as character vector or list of
characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
new_efc &lt;- data_modify(
  efc,
  c12hour_c = center(c12hour),
  c12hour_z = c12hour_c / sd(c12hour, na.rm = TRUE),
  c12hour_z2 = standardize(c12hour)
)
head(new_efc)

# using strings instead of literal expressions
new_efc &lt;- data_modify(
  efc,
  "c12hour_c = center(c12hour)",
  "c12hour_z = c12hour_c / sd(c12hour, na.rm = TRUE)",
  "c12hour_z2 = standardize(c12hour)"
)
head(new_efc)

# using character strings, provided as variable
stand &lt;- "c12hour_c / sd(c12hour, na.rm = TRUE)"
new_efc &lt;- data_modify(
  efc,
  c12hour_c = center(c12hour),
  c12hour_z = stand
)
head(new_efc)

# providing expressions as character vector
new_exp &lt;- c(
  "c12hour_c = center(c12hour)",
  "c12hour_z = c12hour_c / sd(c12hour, na.rm = TRUE)"
)
new_efc &lt;- data_modify(efc, new_exp)
head(new_efc)

# attributes - in this case, value and variable labels - are preserved
str(new_efc)

# overwrite existing variable, remove old variable
out &lt;- data_modify(iris, Petal.Length = 1 / Sepal.Length, Sepal.Length = NULL)
head(out)

# works on grouped data
grouped_efc &lt;- data_group(efc, "c172code")
new_efc &lt;- data_modify(
  grouped_efc,
  c12hour_c = center(c12hour),
  c12hour_z = c12hour_c / sd(c12hour, na.rm = TRUE),
  c12hour_z2 = standardize(c12hour)
)
head(new_efc)

# works from inside functions
foo &lt;- function(data, z) {
  head(data_modify(data, z))
}
foo(iris, "var_a = Sepal.Width / 10")

new_exp &lt;- c("SW_double = 2 * Sepal.Width", "SW_fraction = SW_double / 10")
foo(iris, new_exp)

# modify at specific positions or if condition is met
d &lt;- iris[1:5, ]
data_modify(d, .at = "Species", .modify = as.numeric)
data_modify(d, .if = is.factor, .modify = as.numeric)

# can be combined with dots
data_modify(d, new_length = Petal.Length * 2, .at = "Species", .modify = as.numeric)

# new variables used in `.at` or `.if`
data_modify(
  d,
  new_length = Petal.Length * 2,
  .at = c("Petal.Length", "new_length"),
  .modify = round
)

# combine "data_find()" and ".at" argument
out &lt;- data_modify(
  d,
  .at = data_find(d, select = starts_with("Sepal")),
  .modify = as.factor
)
# "Sepal.Length" and "Sepal.Width" are now factors
str(out)

</code></pre>

<hr>
<h2 id='data_partition'>Partition data</h2><span id='topic+data_partition'></span>

<h3>Description</h3>

<p>Creates data partitions (for instance, a training and a test set) based on a
data frame that can also be stratified (i.e., evenly spread a given factor)
using the <code>group</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_partition(
  data,
  proportion = 0.7,
  group = NULL,
  seed = NULL,
  row_id = ".row_id",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_partition_+3A_data">data</code></td>
<td>
<p>A data frame, or an object that can be coerced to a data frame.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_proportion">proportion</code></td>
<td>
<p>Scalar (between 0 and 1) or numeric vector, indicating the
proportion(s) of the training set(s). The sum of <code>proportion</code> must not be
greater than 1. The remaining part will be used for the test set.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_group">group</code></td>
<td>
<p>A character vector indicating the name(s) of the column(s) used
for stratified partitioning.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_seed">seed</code></td>
<td>
<p>A random number generator seed. Enter an integer (e.g. 123) so
that the random sampling will be the same each time you run the function.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_row_id">row_id</code></td>
<td>
<p>Character string, indicating the name of the column that
contains the row-id's.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="data_partition_+3A_...">...</code></td>
<td>
<p>Other arguments passed to or from other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames. The list includes one training set per given
proportion and the remaining data as test set. List elements of training
sets are named after the given proportions (e.g., <code style="white-space: pre;">&#8288;$p_0.7&#8288;</code>), the test set
is named <code style="white-space: pre;">&#8288;$test&#8288;</code>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
out &lt;- data_partition(iris, proportion = 0.9)
out$test
nrow(out$p_0.9)

# Stratify by group (equal proportions of each species)
out &lt;- data_partition(iris, proportion = 0.9, group = "Species")
out$test

# Create multiple partitions
out &lt;- data_partition(iris, proportion = c(0.3, 0.3))
lapply(out, head)

# Create multiple partitions, stratified by group - 30% equally sampled
# from species in first training set, 50% in second training set and
# remaining 20% equally sampled from each species in test set.
out &lt;- data_partition(iris, proportion = c(0.3, 0.5), group = "Species")
lapply(out, function(i) table(i$Species))

</code></pre>

<hr>
<h2 id='data_peek'>Peek at values and type of variables in a data frame</h2><span id='topic+data_peek'></span><span id='topic+data_peek.data.frame'></span>

<h3>Description</h3>

<p>This function creates a table a data frame, showing all
column names, variable types and the first values (as many as fit into
the screen).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_peek(x, ...)

## S3 method for class 'data.frame'
data_peek(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  width = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_peek_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_width">width</code></td>
<td>
<p>Maximum width of line length to display. If <code>NULL</code>, width will
be determined using <code>options()$width</code>.</p>
</td></tr>
<tr><td><code id="data_peek_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns, containing information about
the name, type and first values of the input data frame.
</p>


<h3>Note</h3>

<p>To show only specific or a limited number of variables, use the
<code>select</code> argument, e.g. <code>select = 1:5</code> to show only the first five variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
data_peek(efc)
# show variables two to four
data_peek(efc, select = 2:4)
</code></pre>

<hr>
<h2 id='data_read'>Read (import) data files from various sources</h2><span id='topic+data_read'></span><span id='topic+data_write'></span>

<h3>Description</h3>

<p>This functions imports data from various file types. It is a small wrapper
around <code>haven::read_spss()</code>, <code>haven::read_stata()</code>, <code>haven::read_sas()</code>,
<code>readxl::read_excel()</code> and <code>data.table::fread()</code> resp. <code>readr::read_delim()</code>
(the latter if package <strong>data.table</strong> is not installed). Thus, supported file
types for importing data are data files from SPSS, SAS or Stata, Excel files
or text files (like '.csv' files). All other file types are passed to
<code>rio::import()</code>. <code>data_write()</code> works in a similar way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_read(
  path,
  path_catalog = NULL,
  encoding = NULL,
  convert_factors = TRUE,
  verbose = TRUE,
  ...
)

data_write(
  data,
  path,
  delimiter = ",",
  convert_factors = FALSE,
  save_labels = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_read_+3A_path">path</code></td>
<td>
<p>Character string, the file path to the data file.</p>
</td></tr>
<tr><td><code id="data_read_+3A_path_catalog">path_catalog</code></td>
<td>
<p>Character string, path to the catalog file. Only relevant
for SAS data files.</p>
</td></tr>
<tr><td><code id="data_read_+3A_encoding">encoding</code></td>
<td>
<p>The character encoding used for the file. Usually not needed.</p>
</td></tr>
<tr><td><code id="data_read_+3A_convert_factors">convert_factors</code></td>
<td>
<p>If <code>TRUE</code> (default), numeric variables, where all
values have a value label, are assumed to be categorical and converted
into factors. If <code>FALSE</code>, no variable types are guessed and no conversion
of numeric variables into factors will be performed. See also section
'Differences to other packages'. For <code>data_write()</code>, this argument only
applies to the text (e.g. <code>.txt</code> or <code>.csv</code>) or spreadsheet file formats (like
<code>.xlsx</code>). Converting to factors might be useful for these formats because
labelled numeric variables are then converted into factors and exported as
character columns - else, value labels would be lost and only numeric values
are written to the file.</p>
</td></tr>
<tr><td><code id="data_read_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="data_read_+3A_...">...</code></td>
<td>
<p>Arguments passed to the related <code style="white-space: pre;">&#8288;read_*()&#8288;</code> or <code style="white-space: pre;">&#8288;write_*()&#8288;</code> functions.</p>
</td></tr>
<tr><td><code id="data_read_+3A_data">data</code></td>
<td>
<p>The data frame that should be written to a file.</p>
</td></tr>
<tr><td><code id="data_read_+3A_delimiter">delimiter</code></td>
<td>
<p>For CSV-files, specifies the delimiter. Defaults to <code>","</code>,
but in particular in European regions, <code>";"</code> might be a useful alternative,
especially when exported CSV-files should be opened in Excel.</p>
</td></tr>
<tr><td><code id="data_read_+3A_save_labels">save_labels</code></td>
<td>
<p>Only applies to CSV files. If <code>TRUE</code>, value and variable
labels (if any) will be saved as additional CSV file. This file has the same
file name as the exported CSV file, but includes a <code>"_labels"</code> suffix (i.e.
when the file name is <code>"mydat.csv"</code>, the additional file with value and
variable labels is named <code>"mydat_labels.csv"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Supported file types</h3>


<ul>
<li> <p><code>data_read()</code> is a wrapper around the <strong>haven</strong>, <strong>data.table</strong>, <strong>readr</strong>
<strong>readxl</strong> and <strong>rio</strong> packages. Currently supported file types are <code>.txt</code>,
<code>.csv</code>, <code>.xls</code>, <code>.xlsx</code>, <code>.sav</code>, <code>.por</code>, <code>.dta</code> and <code>.sas</code> (and related
files). All other file types are passed to <code>rio::import()</code>.
</p>
</li>
<li> <p><code>data_write()</code> is a wrapper around <strong>haven</strong>, <strong>readr</strong> and <strong>rio</strong>
packages, and supports writing files into all formats supported by these
packages.
</p>
</li></ul>



<h3>Compressed files (zip) and URLs</h3>

<p><code>data_read()</code> can also read the above mentioned files from URLs or from
inside zip-compressed files. Thus, <code>path</code> can also be a URL to a file like
<code>"http://www.url.com/file.csv"</code>. When <code>path</code> points to a zip-compressed file,
and there are multiple files inside the zip-archive, then the first supported
file is extracted and loaded.
</p>


<h3>General behaviour</h3>

<p><code>data_read()</code> detects the appropriate <code style="white-space: pre;">&#8288;read_*()&#8288;</code> function based on the
file-extension of the data file. Thus, in most cases it should be enough to
only specify the <code>path</code> argument. However, if more control is needed, all
arguments in <code>...</code> are passed down to the related <code style="white-space: pre;">&#8288;read_*()&#8288;</code> function. The
same applies to <code>data_write()</code>, i.e. based on the file extension provided in
<code>path</code>, the appropriate <code style="white-space: pre;">&#8288;write_*()&#8288;</code> function is used automatically.
</p>


<h3>SPSS specific behaviour</h3>

<p><code>data_read()</code> does <em>not</em> import user-defined (&quot;tagged&quot;) <code>NA</code> values from
SPSS, i.e. argument <code>user_na</code> is always set to <code>FALSE</code> when importing SPSS
data with the <strong>haven</strong> package. Use <code>convert_to_na()</code> to define missing
values in the imported data, if necessary. Furthermore, <code>data_write()</code>
compresses SPSS files by default. If this causes problems with (older) SPSS
versions, use <code>compress = "none"</code>, for example
<code>data_write(data, "myfile.sav", compress = "none")</code>.
</p>


<h3>Differences to other packages that read foreign data formats</h3>

<p><code>data_read()</code> is most comparable to <code>rio::import()</code>. For data files from
SPSS, SAS or Stata, which support labelled data, variables are converted into
their most appropriate type. The major difference to <code>rio::import()</code> is that
<code>data_read()</code> automatically converts fully labelled numeric variables into
factors, where imported value labels will be set as factor levels. If a
numeric variable has <em>no</em> value labels or less value labels than values, it
is not converted to factor. In this case, value labels are preserved as
<code>"labels"</code> attribute. Character vectors are preserved.  Use
<code>convert_factors = FALSE</code> to remove the automatic conversion of numeric
variables to factors.
</p>

<hr>
<h2 id='data_relocate'>Relocate (reorder) columns of a data frame</h2><span id='topic+data_relocate'></span><span id='topic+data_reorder'></span><span id='topic+data_remove'></span>

<h3>Description</h3>

<p><code>data_relocate()</code> will reorder columns to specific positions, indicated by
<code>before</code> or <code>after</code>. <code>data_reorder()</code> will instead move selected columns to
the beginning of a data frame. Finally, <code>data_remove()</code> removes columns
from a data frame. All functions support select-helpers that allow flexible
specification of a search pattern to find matching columns, which should
be reordered or removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_relocate(
  data,
  select,
  before = NULL,
  after = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_reorder(
  data,
  select,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_remove(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_relocate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_before">before</code>, <code id="data_relocate_+3A_after">after</code></td>
<td>
<p>Destination of columns. Supplying neither will move
columns to the left-hand side; specifying both is an error. Can be a
character vector, indicating the name of the destination column, or a
numeric value, indicating the index number of the destination column.
If <code>-1</code>, will be added before or after the last column.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_...">...</code></td>
<td>
<p>Arguments passed down to other functions. Mostly not used yet.</p>
</td></tr>
<tr><td><code id="data_relocate_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with reordered columns.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reorder columns
head(data_relocate(iris, select = "Species", before = "Sepal.Length"))
head(data_relocate(iris, select = "Species", before = "Sepal.Width"))
head(data_relocate(iris, select = "Sepal.Width", after = "Species"))
# which is same as
head(data_relocate(iris, select = "Sepal.Width", after = -1))

# Reorder multiple columns
head(data_relocate(iris, select = c("Species", "Petal.Length"), after = "Sepal.Width"))
# which is same as
head(data_relocate(iris, select = c("Species", "Petal.Length"), after = 2))

# Reorder columns
head(data_reorder(iris, c("Species", "Sepal.Length")))

# Remove columns
head(data_remove(iris, "Sepal.Length"))
head(data_remove(iris, starts_with("Sepal")))
</code></pre>

<hr>
<h2 id='data_replicate'>Expand (i.e. replicate rows) a data frame</h2><span id='topic+data_replicate'></span>

<h3>Description</h3>

<p>Expand a data frame by replicating rows based on another variable that
contains the counts of replications per row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_replicate(
  data,
  expand = NULL,
  select = NULL,
  exclude = NULL,
  remove_na = FALSE,
  ignore_case = FALSE,
  verbose = TRUE,
  regex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_replicate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_expand">expand</code></td>
<td>
<p>The name of the column that contains the counts of replications
for each row. Can also be a numeric value, indicating the position of that
column. Note that the variable indicated by <code>expand</code> must be an integer vector.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical. If <code>TRUE</code>, missing values in the column
provided in <code>expand</code> are removed from the data frame. If <code>FALSE</code> and <code>expand</code>
contains missing values, the function will throw an error.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_replicate_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with each row replicated as many times as defined in <code>expand</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
data_replicate(head(mtcars), "carb")
</code></pre>

<hr>
<h2 id='data_restoretype'>Restore the type of columns according to a reference data frame</h2><span id='topic+data_restoretype'></span>

<h3>Description</h3>

<p>Restore the type of columns according to a reference data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_restoretype(data, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_restoretype_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="data_restoretype_+3A_reference">reference</code></td>
<td>
<p>A reference data frame from which to find the correct
column types. If <code>NULL</code>, each column is converted to numeric if it doesn't
generate <code>NA</code>s. For example, <code>c("1", "2")</code> can be converted to numeric but not
<code>c("Sepal.Length")</code>.</p>
</td></tr>
<tr><td><code id="data_restoretype_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns whose types have been restored based on the
reference data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  Sepal.Length = c("1", "3", "2"),
  Species = c("setosa", "versicolor", "setosa"),
  New = c("1", "3", "4")
)

fixed &lt;- data_restoretype(data, reference = iris)
summary(fixed)
</code></pre>

<hr>
<h2 id='data_rotate'>Rotate a data frame</h2><span id='topic+data_rotate'></span><span id='topic+data_transpose'></span>

<h3>Description</h3>

<p>This function rotates a data frame, i.e. columns become rows and vice versa.
It's the equivalent of using <code>t()</code> but restores the <code>data.frame</code> class,
preserves attributes and prints a warning if the data type is
modified (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rotate(data, rownames = NULL, colnames = FALSE, verbose = TRUE)

data_transpose(data, rownames = NULL, colnames = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_rotate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_rotate_+3A_rownames">rownames</code></td>
<td>
<p>Character vector (optional). If not <code>NULL</code>, the data frame's
rownames will be added as (first) column to the output, with <code>rownames</code>
being the name of this column.</p>
</td></tr>
<tr><td><code id="data_rotate_+3A_colnames">colnames</code></td>
<td>
<p>Logical or character vector (optional). If <code>TRUE</code>, the values
of the first column in <code>x</code> will be used as column names in the rotated data
frame. If a character vector, values from that column are used as column
names.</p>
</td></tr>
<tr><td><code id="data_rotate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (rotated) data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mtcars[1:3, 1:4]

x

data_rotate(x)
data_rotate(x, rownames = "property")

# use values in 1. column as column name
data_rotate(x, colnames = TRUE)
data_rotate(x, rownames = "property", colnames = TRUE)

# use either first column or specific column for column names
x &lt;- data.frame(a = 1:5, b = 11:15, c = 21:25)
data_rotate(x, colnames = TRUE)
data_rotate(x, colnames = "c")

</code></pre>

<hr>
<h2 id='data_seek'>Find variables by their names, variable or value labels</h2><span id='topic+data_seek'></span>

<h3>Description</h3>

<p>This functions seeks variables in a data frame, based on patterns
that either match the variable name (column name), variable labels, value labels
or factor levels. Matching variable and value labels only works for &quot;labelled&quot;
data, i.e. when the variables either have a <code>label</code> attribute or <code>labels</code>
attribute.
</p>
<p><code>data_seek()</code> is particular useful for larger data frames with labelled
data - finding the correct variable name can be a challenge. This function
helps to find the required variables, when only certain patterns of variable
names or labels are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_seek(data, pattern, seek = c("names", "labels"), fuzzy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_seek_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_seek_+3A_pattern">pattern</code></td>
<td>
<p>Character string (regular expression) to be matched in <code>data</code>.
May also be a character vector of length &gt; 1. <code>pattern</code> is searched for in
column names, variable label and value labels attributes, or factor levels of
variables in <code>data</code>.</p>
</td></tr>
<tr><td><code id="data_seek_+3A_seek">seek</code></td>
<td>
<p>Character vector, indicating where <code>pattern</code> is sought. Use one
or more of the following options:
</p>

<ul>
<li> <p><code>"names"</code>: Searches in column names. <code>"column_names"</code> and <code>"columns"</code> are
aliases for <code>"names"</code>.
</p>
</li>
<li> <p><code>"labels"</code>: Searches in variable labels. Only applies when a <code>label</code> attribute
is set for a variable.
</p>
</li>
<li> <p><code>"values"</code>: Searches in value labels or factor levels. Only applies when a
<code>labels</code> attribute is set for a variable, or if a variable is a factor.
<code>"levels"</code> is an alias for <code>"values"</code>.
</p>
</li>
<li> <p><code>"all"</code>: Searches in all of the above.
</p>
</li></ul>
</td></tr>
<tr><td><code id="data_seek_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Logical. If <code>TRUE</code>, &quot;fuzzy matching&quot; (partial and close distance
matching) will be used to find <code>pattern</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: the column index, the column name
and - if available - the variable label of all matched variables in <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># seek variables with "Length" in variable name or labels
data_seek(iris, "Length")

# seek variables with "dependency" in names or labels
# column "e42dep" has a label-attribute "elder's dependency"
data(efc)
data_seek(efc, "dependency")

# "female" only appears as value label attribute - default search is in
# variable names and labels only, so no match
data_seek(efc, "female")
# when we seek in all sources, we find the variable "e16sex"
data_seek(efc, "female", seek = "all")

# typo, no match
data_seek(iris, "Lenght")
# typo, fuzzy match
data_seek(iris, "Lenght", fuzzy = TRUE)
</code></pre>

<hr>
<h2 id='data_separate'>Separate single variable into multiple variables</h2><span id='topic+data_separate'></span>

<h3>Description</h3>

<p>Separates a single variable into multiple new variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_separate(
  data,
  select = NULL,
  new_columns = NULL,
  separator = "[^[:alnum:]]+",
  guess_columns = NULL,
  merge_multiple = FALSE,
  merge_separator = "",
  fill = "right",
  extra = "drop_right",
  convert_na = TRUE,
  exclude = NULL,
  append = FALSE,
  ignore_case = FALSE,
  verbose = TRUE,
  regex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_separate_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_new_columns">new_columns</code></td>
<td>
<p>The names of the new columns, as character vector. If
more than one variable was selected (in <code>select</code>), the new names are prefixed
with the name of the original column. <code>new_columns</code> can also be a list of
(named) character vectors when multiple variables should be separated. See
'Examples'.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_separator">separator</code></td>
<td>
<p>Separator between columns. Can be a character vector, which
is then treated as regular expression, or a numeric vector that indicates at
which positions the string values will be split.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_guess_columns">guess_columns</code></td>
<td>
<p>If <code>new_columns</code> is not given, the required number of
new columns is guessed based on the results of value splitting. For example,
if a variable is split into three new columns, this will be considered as
the required number of new columns, and columns are named <code>"split_1"</code>,
<code>"split_2"</code> and <code>"split_3"</code>. When values from a variable are split into
different amount of new columns, the <code>guess_column</code> can be either <code>"mode"</code>
(number of new columns is based on the most common number of splits), <code>"min"</code>
or <code>"max"</code> to use the minimum resp. maximum number of possible splits as
required number of columns.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_merge_multiple">merge_multiple</code></td>
<td>
<p>Logical, if <code>TRUE</code> and more than one variable is selected
for separating, new columns can be merged. Value pairs of all split variables
are merged.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_merge_separator">merge_separator</code></td>
<td>
<p>Separator string when <code>merge_multiple = TRUE</code>. Defines
the string that is used to merge values together.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_fill">fill</code></td>
<td>
<p>How to deal with values that return fewer new columns after
splitting? Can be <code>"left"</code> (fill missing columns from the left with <code>NA</code>),
<code>"right"</code> (fill missing columns from the right with <code>NA</code>) or <code>"value_left"</code>
or <code>"value_right"</code> to fill missing columns from left or right with the
left-most or right-most values.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_extra">extra</code></td>
<td>
<p>How to deal with values that return too many new columns after
splitting? Can be <code>"drop_left"</code> or <code>"drop_right"</code> to drop the left-most or
right-most values, or <code>"merge_left"</code> or <code>"merge_right"</code> to merge the left-
or right-most value together, and keeping all remaining values as is.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_convert_na">convert_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, character <code>"NA"</code> values are converted
into real <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_append">append</code></td>
<td>
<p>Logical, if <code>FALSE</code> (default), removes original columns that
were separated. If <code>TRUE</code>, all columns are preserved and the new columns are
appended to the data frame.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_separate_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the newly created variable(s), or - when <code>append = TRUE</code> -
<code>data</code> including new variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_unite">data_unite()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple case
d &lt;- data.frame(
  x = c("1.a.6", "2.b.7", "3.c.8"),
  stringsAsFactors = FALSE
)
d
data_separate(d, new_columns = c("a", "b", "c"))

# guess number of columns
d &lt;- data.frame(
  x = c("1.a.6", NA, "2.b.6.7", "3.c", "x.y.z"),
  stringsAsFactors = FALSE
)
d
data_separate(d, guess_columns = "mode")

data_separate(d, guess_columns = "max")

# drop left-most column
data_separate(d, guess_columns = "mode", extra = "drop_left")

# merge right-most column
data_separate(d, guess_columns = "mode", extra = "merge_right")

# fill columns with fewer values with left-most values
data_separate(d, guess_columns = "mode", fill = "value_left")

# fill and merge
data_separate(
  d,
  guess_columns = "mode",
  fill = "value_left",
  extra = "merge_right"
)

# multiple columns to split
d &lt;- data.frame(
  x = c("1.a.6", "2.b.7", "3.c.8"),
  y = c("x.y.z", "10.11.12", "m.n.o"),
  stringsAsFactors = FALSE
)
d
# split two columns, default column names
data_separate(d, guess_columns = "mode")

# split into new named columns, repeating column names
data_separate(d, new_columns = c("a", "b", "c"))

# split selected variable new columns
data_separate(d, select = "y", new_columns = c("a", "b", "c"))

# merge multiple split columns
data_separate(
  d,
  new_columns = c("a", "b", "c"),
  merge_multiple = TRUE
)

# merge multiple split columns
data_separate(
  d,
  new_columns = c("a", "b", "c"),
  merge_multiple = TRUE,
  merge_separator = "-"
)

# separate multiple columns, give proper column names
d_sep &lt;- data.frame(
  x = c("1.a.6", "2.b.7.d", "3.c.8", "5.j"),
  y = c("m.n.99.22", "77.f.g.34", "44.9", NA),
  stringsAsFactors = FALSE
)

data_separate(
  d_sep,
  select = c("x", "y"),
  new_columns = list(
    x = c("A", "B", "C"), # separate "x" into three columns
    y = c("EE", "FF", "GG", "HH") # separate "y" into four columns
  ),
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='data_summary'>Summarize data</h2><span id='topic+data_summary'></span><span id='topic+data_summary.data.frame'></span>

<h3>Description</h3>

<p>This function can be used to compute summary statistics for a
data frame or a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_summary(x, ...)

## S3 method for class 'data.frame'
data_summary(x, ..., by = NULL, include_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_summary_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame.</p>
</td></tr>
<tr><td><code id="data_summary_+3A_...">...</code></td>
<td>
<p>One or more named expressions that define the new variable name
and the function to compute the summary statistic. Example:
<code>mean_sepal_width = mean(Sepal.Width)</code>. The expression can also be provided
as a character string, e.g. <code>"mean_sepal_width = mean(Sepal.Width)"</code>. The
summary function <code>n()</code> can be used to count the number of observations.</p>
</td></tr>
<tr><td><code id="data_summary_+3A_by">by</code></td>
<td>
<p>Optional character string, indicating the name of a variable in <code>x</code>.
If supplied, the data will be split by this variable and summary statistics
will be computed for each group.</p>
</td></tr>
<tr><td><code id="data_summary_+3A_include_na">include_na</code></td>
<td>
<p>Logical. If <code>TRUE</code>, missing values are included as a level
in the grouping variable. If <code>FALSE</code>, missing values are omitted from the
grouping variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the requested summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
data_summary(iris, MW = mean(Sepal.Width), SD = sd(Sepal.Width))
data_summary(
  iris,
  MW = mean(Sepal.Width),
  SD = sd(Sepal.Width),
  by = "Species"
)

# same as
d &lt;- data_group(iris, "Species")
data_summary(d, MW = mean(Sepal.Width), SD = sd(Sepal.Width))

# multiple groups
data(mtcars)
data_summary(mtcars, MW = mean(mpg), SD = sd(mpg), by = c("am", "gear"))

# expressions can also be supplied as character strings
data_summary(mtcars, "MW = mean(mpg)", "SD = sd(mpg)", by = c("am", "gear"))

# count observations within groups
data_summary(mtcars, observations = n(), by = c("am", "gear"))

# first and last observations of "mpg" within groups
data_summary(
  mtcars,
  first = mpg[1],
  last = mpg[length(mpg)],
  by = c("am", "gear")
)
</code></pre>

<hr>
<h2 id='data_tabulate'>Create frequency and crosstables of variables</h2><span id='topic+data_tabulate'></span><span id='topic+data_tabulate.default'></span><span id='topic+data_tabulate.data.frame'></span>

<h3>Description</h3>

<p>This function creates frequency or crosstables of variables,
including the number of levels/values as well as the distribution of raw,
valid and cumulative percentages. For crosstables, row, column  and cell
percentages can be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_tabulate(x, ...)

## Default S3 method:
data_tabulate(
  x,
  by = NULL,
  drop_levels = FALSE,
  weights = NULL,
  include_na = TRUE,
  proportions = NULL,
  name = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
data_tabulate(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  by = NULL,
  drop_levels = FALSE,
  weights = NULL,
  include_na = TRUE,
  proportions = NULL,
  collapse = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_tabulate_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, a vector or factor.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_by">by</code></td>
<td>
<p>Optional vector or factor. If supplied, a crosstable is created.
If <code>x</code> is a data frame, <code>by</code> can also be a character string indicating the
name of a variable in <code>x</code>.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_drop_levels">drop_levels</code></td>
<td>
<p>Logical, if <code>FALSE</code>, factor levels that do not occur in
the data are included in the table (with frequency of zero), else unused
factor levels are dropped from the frequency table.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_weights">weights</code></td>
<td>
<p>Optional numeric vector of weights. Must be of the same length
as <code>x</code>. If <code>weights</code> is supplied, weighted frequencies are calculated.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_include_na">include_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values are included in the
frequency or crosstable, else missing values are omitted.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_proportions">proportions</code></td>
<td>
<p>Optional character string, indicating the type of
percentages to be calculated. Only applies to crosstables, i.e. when <code>by</code> is
not <code>NULL</code>. Can be <code>"row"</code> (row percentages), <code>"column"</code> (column percentages)
or <code>"full"</code> (to calculate relative frequencies for the full table).</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_name">name</code></td>
<td>
<p>Optional character string, which includes the name that is used
for printing.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_tabulate_+3A_collapse">collapse</code></td>
<td>
<p>Logical, if <code>TRUE</code> collapses multiple tables into one larger
table for printing. This affects only printing, not the returned object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, or a list of data frames, with one frequency table
as data frame per variable.
</p>


<h3>Crosstables</h3>

<p>If <code>by</code> is supplied, a crosstable is created. The crosstable includes <code style="white-space: pre;">&#8288;&lt;NA&gt;&#8288;</code>
(missing) values by default. The first column indicates values of <code>x</code>, the
first row indicates values of <code>by</code> (including missing values). The last row
and column contain the total frequencies for each row and column, respectively.
Setting <code>include_na = FALSE</code> will omit missing values from the crosstable.
Setting <code>proportions</code> to <code>"row"</code> or <code>"column"</code> will add row or column
percentages. Setting <code>proportions</code> to <code>"full"</code> will add relative frequencies
for the full table.
</p>


<h3>Note</h3>

<p>There are <code>print_html()</code> and <code>print_md()</code> methods available for printing
frequency or crosstables in HTML and markdown format, e.g.
<code>print_html(data_tabulate(x))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# frequency tables -------
# ------------------------
data(efc)

# vector/factor
data_tabulate(efc$c172code)

# drop missing values
data_tabulate(efc$c172code, include_na = FALSE)

# data frame
data_tabulate(efc, c("e42dep", "c172code"))

# grouped data frame
suppressPackageStartupMessages(library(poorman, quietly = TRUE))
efc %&gt;%
  group_by(c172code) %&gt;%
  data_tabulate("e16sex")

# collapse tables
efc %&gt;%
  group_by(c172code) %&gt;%
  data_tabulate("e16sex", collapse = TRUE)

# for larger N's (&gt; 100000), a big mark is automatically added
set.seed(123)
x &lt;- sample(1:3, 1e6, TRUE)
data_tabulate(x, name = "Large Number")

# to remove the big mark, use "print(..., big_mark = "")"
print(data_tabulate(x), big_mark = "")

# weighted frequencies
set.seed(123)
efc$weights &lt;- abs(rnorm(n = nrow(efc), mean = 1, sd = 0.5))
data_tabulate(efc$e42dep, weights = efc$weights)

# crosstables ------
# ------------------

# add some missing values
set.seed(123)
efc$e16sex[sample.int(nrow(efc), 5)] &lt;- NA

data_tabulate(efc, "c172code", by = "e16sex")

# add row and column percentages
data_tabulate(efc, "c172code", by = "e16sex", proportions = "row")
data_tabulate(efc, "c172code", by = "e16sex", proportions = "column")

# omit missing values
data_tabulate(
  efc$c172code,
  by = efc$e16sex,
  proportions = "column",
  include_na = FALSE
)

# round percentages
out &lt;- data_tabulate(efc, "c172code", by = "e16sex", proportions = "column")
print(out, digits = 0)

</code></pre>

<hr>
<h2 id='data_to_long'>Reshape (pivot) data from wide to long</h2><span id='topic+data_to_long'></span><span id='topic+reshape_longer'></span>

<h3>Description</h3>

<p>This function &quot;lengthens&quot; data, increasing the number of rows and decreasing
the number of columns. This is a dependency-free base-R equivalent of
<code>tidyr::pivot_longer()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_long(
  data,
  select = "all",
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  values_to = "value",
  values_drop_na = FALSE,
  rows_to = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  ...,
  cols
)

reshape_longer(
  data,
  select = "all",
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  values_to = "value",
  values_drop_na = FALSE,
  rows_to = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  ...,
  cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_long_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_names_to">names_to</code></td>
<td>
<p>The name of the new column that will contain the column
names.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text from
the start of each variable name.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_names_sep">names_sep</code>, <code id="data_to_long_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values, this
argument controls how the column name is broken up.
<code>names_pattern</code> takes a regular expression containing matching groups, i.e. &quot;()&quot;.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_values_to">values_to</code></td>
<td>
<p>The name of the new column that will contain the values of
the pivoted variables.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code> in the
<code>values_to</code> column. This effectively converts explicit missing values to
implicit missing values, and should generally be used only when missing values
in data were created by its structure.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_rows_to">rows_to</code></td>
<td>
<p>The name of the column that will contain the row names or row
numbers from the original data. If <code>NULL</code>, will be removed.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="data_to_long_+3A_cols">cols</code></td>
<td>
<p>Identical to <code>select</code>. This argument is here to ensure compatibility
with <code>tidyr::pivot_longer()</code>. If both <code>select</code> and <code>cols</code> are provided, <code>cols</code>
is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a tibble was provided as input, <code>reshape_longer()</code> also returns a
tibble. Otherwise, it returns a data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
wide_data &lt;- data.frame(replicate(5, rnorm(10)))

# Default behaviour (equivalent to tidyr::pivot_longer(wide_data, cols = 1:5))
data_to_long(wide_data)

# Customizing the names
data_to_long(wide_data,
  select = c(1, 2),
  names_to = "Column",
  values_to = "Numbers",
  rows_to = "Row"
)

# Full example
# ------------------
data &lt;- psych::bfi # Wide format with one row per participant's personality test

# Pivot long format
data_to_long(data,
  select = regex("\\d"), # Select all columns that contain a digit
  names_to = "Item",
  values_to = "Score",
  rows_to = "Participant"
)

data_to_long(
  tidyr::who,
  select = new_sp_m014:newrel_f65,
  names_to = c("diagnosis", "gender", "age"),
  names_pattern = "new_?(.*)_(.)(.*)",
  values_to = "count"
)

</code></pre>

<hr>
<h2 id='data_to_wide'>Reshape (pivot) data from long to wide</h2><span id='topic+data_to_wide'></span><span id='topic+reshape_wider'></span>

<h3>Description</h3>

<p>This function &quot;widens&quot; data, increasing the number of columns and decreasing
the number of rows. This is a dependency-free base-R equivalent of
<code>tidyr::pivot_wider()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_wide(
  data,
  id_cols = NULL,
  values_from = "Value",
  names_from = "Name",
  names_sep = "_",
  names_prefix = "",
  names_glue = NULL,
  values_fill = NULL,
  verbose = TRUE,
  ...
)

reshape_wider(
  data,
  id_cols = NULL,
  values_from = "Value",
  names_from = "Name",
  names_sep = "_",
  names_prefix = "",
  names_glue = NULL,
  values_fill = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_wide_+3A_data">data</code></td>
<td>
<p>A data frame to pivot.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_id_cols">id_cols</code></td>
<td>
<p>The name of the column that identifies the rows. If <code>NULL</code>,
it will use all the unique rows.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_values_from">values_from</code></td>
<td>
<p>The name of the column that contains the values to be used
as future variable values.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_names_from">names_from</code></td>
<td>
<p>The name of the column that contains the levels to be
used as future column names.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple variables,
this will be used to join their values together into a single string to use
as a column name.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to create
syntactic variable names.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply a
<a href="https://glue.tidyverse.org/index.html">glue specification</a> that uses the
<code>names_from</code> columns to create custom column names. Note that the only
delimiters supported by <code>names_glue</code> are curly brackets, <code style="white-space: pre;">&#8288;{&#8288;</code> and <code style="white-space: pre;">&#8288;}&#8288;</code>.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that will be used to replace
missing values in the new columns created.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_to_wide_+3A_...">...</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a tibble was provided as input, <code>reshape_wider()</code> also returns a
tibble. Otherwise, it returns a data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data_long &lt;- read.table(header = TRUE, text = "
 subject sex condition measurement
       1   M   control         7.9
       1   M     cond1        12.3
       1   M     cond2        10.7
       2   F   control         6.3
       2   F     cond1        10.6
       2   F     cond2        11.1
       3   F   control         9.5
       3   F     cond1        13.1
       3   F     cond2        13.8
       4   M   control        11.5
       4   M     cond1        13.4
       4   M     cond2        12.9")


data_to_wide(
  data_long,
  id_cols = "subject",
  names_from = "condition",
  values_from = "measurement"
)

data_to_wide(
  data_long,
  id_cols = "subject",
  names_from = "condition",
  values_from = "measurement",
  names_prefix = "Var.",
  names_sep = "."
)

production &lt;- expand.grid(
  product = c("A", "B"),
  country = c("AI", "EI"),
  year = 2000:2014
)
production &lt;- data_filter(production, (product == "A" &amp; country == "AI") | product == "B")

production$production &lt;- rnorm(nrow(production))

data_to_wide(
  production,
  names_from = c("product", "country"),
  values_from = "production",
  names_glue = "prod_{product}_{country}"
)

</code></pre>

<hr>
<h2 id='data_unique'>Keep only one row from all with duplicated IDs</h2><span id='topic+data_unique'></span>

<h3>Description</h3>

<p>From all rows with at least one duplicated ID,
keep only one. Methods for selecting the duplicated row are
either the first duplicate, the last duplicate, or the &quot;best&quot;
duplicate (default), based on the duplicate with the smallest
number of <code>NA</code>. In case of ties, it picks the first
duplicate, as it is the one most likely to be valid and
authentic, given practice effects.
</p>
<p>Contrarily to <code>dplyr::distinct()</code>, <code>data_unique()</code> keeps all columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_unique(
  data,
  select = NULL,
  keep = "best",
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_unique_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_keep">keep</code></td>
<td>
<p>The method to be used for duplicate selection, either &quot;best&quot;
(the default), &quot;first&quot;, or &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_unique_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, containing only the chosen duplicates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_duplicated">data_duplicated()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  id = c(1, 2, 3, 1, 3),
  item1 = c(NA, 1, 1, 2, 3),
  item2 = c(NA, 1, 1, 2, 3),
  item3 = c(NA, 1, 1, 2, 3)
)

data_unique(df1, select = "id")
</code></pre>

<hr>
<h2 id='data_unite'>Unite (&quot;merge&quot;) multiple variables</h2><span id='topic+data_unite'></span>

<h3>Description</h3>

<p>Merge values of multiple variables per observation into one new variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_unite(
  data,
  new_column = NULL,
  select = NULL,
  exclude = NULL,
  separator = "_",
  append = FALSE,
  remove_na = FALSE,
  ignore_case = FALSE,
  verbose = TRUE,
  regex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_unite_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_new_column">new_column</code></td>
<td>
<p>The name of the new column, as a string.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_separator">separator</code></td>
<td>
<p>A character to use between values.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_append">append</code></td>
<td>
<p>Logical, if <code>FALSE</code> (default), removes original columns that
were united. If <code>TRUE</code>, all columns are preserved and the new column is
appended to the data frame.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, missing values (<code>NA</code>) are not included
in the united values. If <code>FALSE</code>, missing values are represented as <code>"NA"</code>
in the united values.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="data_unite_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code>, with a newly created variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data_separate">data_separate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  x = 1:3,
  y = letters[1:3],
  z = 6:8
)
d
data_unite(d, new_column = "xyz")
data_unite(d, new_column = "xyz", remove = FALSE)
data_unite(d, new_column = "xyz", select = c("x", "z"))
data_unite(d, new_column = "xyz", select = c("x", "z"), append = TRUE)
</code></pre>

<hr>
<h2 id='datawizard-package'>datawizard: Easy Data Wrangling and Statistical Transformations</h2><span id='topic+datawizard-package'></span><span id='topic+datawizard'></span>

<h3>Description</h3>

<p>A lightweight package to assist in key steps involved in any data analysis
workflow:
</p>

<ul>
<li><p> wrangling the raw data to get it in the needed form,
</p>
</li>
<li><p> applying preprocessing steps and statistical transformations, and
</p>
</li>
<li><p> compute statistical summaries of data properties and distributions.
</p>
</li></ul>

<p>It is also the data wrangling backend for packages in 'easystats' ecosystem.
References: Patil et al. (2022) <a href="https://doi.org/10.21105/joss.04684">doi:10.21105/joss.04684</a>.
</p>


<h3>Details</h3>

<p><code>datawizard</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Etienne Bacher <a href="mailto:etienne.bacher@protonmail.com">etienne.bacher@protonmail.com</a> (<a href="https://orcid.org/0000-0002-9271-5075">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets)
</p>
</li>
<li><p> Dominique Makowski <a href="mailto:dom.makowski@gmail.com">dom.makowski@gmail.com</a> (<a href="https://orcid.org/0000-0001-5375-9967">ORCID</a>) (@Dom_Makowski)
</p>
</li>
<li><p> Daniel Lüdecke <a href="mailto:d.luedecke@uke.de">d.luedecke@uke.de</a> (<a href="https://orcid.org/0000-0002-8895-3206">ORCID</a>) (@strengejacke)
</p>
</li>
<li><p> Mattan S. Ben-Shachar <a href="mailto:matanshm@post.bgu.ac.il">matanshm@post.bgu.ac.il</a> (<a href="https://orcid.org/0000-0002-4287-4801">ORCID</a>)
</p>
</li>
<li><p> Brenton M. Wiernik <a href="mailto:brenton@wiernik.org">brenton@wiernik.org</a> (<a href="https://orcid.org/0000-0001-9560-6336">ORCID</a>) (@bmwiernik)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Rémi Thériault <a href="mailto:remi.theriault@mail.mcgill.ca">remi.theriault@mail.mcgill.ca</a> (<a href="https://orcid.org/0000-0003-4315-6788">ORCID</a>) (@rempsyc) [contributor]
</p>
</li>
<li><p> Thomas J. Faulkenberry <a href="mailto:faulkenberry@tarleton.edu">faulkenberry@tarleton.edu</a> [reviewer]
</p>
</li>
<li><p> Robert Garrett <a href="mailto:rcg4@illinois.edu">rcg4@illinois.edu</a> [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://easystats.github.io/datawizard/">https://easystats.github.io/datawizard/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/easystats/datawizard/issues">https://github.com/easystats/datawizard/issues</a>
</p>
</li></ul>


<hr>
<h2 id='demean'>Compute group-meaned and de-meaned variables</h2><span id='topic+demean'></span><span id='topic+degroup'></span><span id='topic+detrend'></span>

<h3>Description</h3>

<p><code>demean()</code> computes group- and de-meaned versions of a variable that can be
used in regression analysis to model the between- and within-subject effect.
<code>degroup()</code> is more generic in terms of the centering-operation. While
<code>demean()</code> always uses mean-centering, <code>degroup()</code> can also use the mode or
median for centering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demean(
  x,
  select,
  group,
  suffix_demean = "_within",
  suffix_groupmean = "_between",
  add_attributes = TRUE,
  verbose = TRUE
)

degroup(
  x,
  select,
  group,
  center = "mean",
  suffix_demean = "_within",
  suffix_groupmean = "_between",
  add_attributes = TRUE,
  verbose = TRUE
)

detrend(
  x,
  select,
  group,
  center = "mean",
  suffix_demean = "_within",
  suffix_groupmean = "_between",
  add_attributes = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demean_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="demean_+3A_select">select</code></td>
<td>
<p>Character vector (or formula) with names of variables to select
that should be group- and de-meaned.</p>
</td></tr>
<tr><td><code id="demean_+3A_group">group</code></td>
<td>
<p>Character vector (or formula) with the name of the variable that
indicates the group- or cluster-ID.</p>
</td></tr>
<tr><td><code id="demean_+3A_suffix_demean">suffix_demean</code>, <code id="demean_+3A_suffix_groupmean">suffix_groupmean</code></td>
<td>
<p>String value, will be appended to the
names of the group-meaned and de-meaned variables of <code>x</code>. By default,
de-meaned variables will be suffixed with <code>"_within"</code> and
grouped-meaned variables with <code>"_between"</code>.</p>
</td></tr>
<tr><td><code id="demean_+3A_add_attributes">add_attributes</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the returned variables gain
attributes to indicate the within- and between-effects. This is only
relevant when printing <code>model_parameters()</code> - in such cases, the
within- and between-effects are printed in separated blocks.</p>
</td></tr>
<tr><td><code id="demean_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="demean_+3A_center">center</code></td>
<td>
<p>Method for centering. <code>demean()</code> always performs
mean-centering, while <code>degroup()</code> can use <code>center = "median"</code> or
<code>center = "mode"</code> for median- or mode-centering, and also <code>"min"</code>
or <code>"max"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Heterogeneity Bias</h4>

<p>Mixed models include different levels of sources of variability, i.e.
error terms at each level. When macro-indicators (or level-2 predictors,
or higher-level units, or more general: <em>group-level predictors that
<strong>vary</strong> within and across groups</em>) are included as fixed effects (i.e.
treated as covariate at level-1), the variance that is left unaccounted for
this covariate will be absorbed into the error terms of level-1 and level-2
(<cite>Bafumi and Gelman 2006; Gelman and Hill 2007, Chapter 12.6.</cite>):
&ldquo;Such covariates contain two parts: one that is specific to the
higher-level entity that does not vary between occasions, and one that
represents the difference between occasions, within higher-level entities&rdquo;
(<cite>Bell et al. 2015</cite>). Hence, the error terms will be correlated with
the covariate, which violates one of the assumptions of mixed models
(iid, independent and identically distributed error terms). This bias is
also called the <em>heterogeneity bias</em> (<cite>Bell et al. 2015</cite>). To
resolve this problem, level-2 predictors used as (level-1) covariates should
be separated into their &quot;within&quot; and &quot;between&quot; effects by &quot;de-meaning&quot; and
&quot;group-meaning&quot;: After demeaning time-varying predictors, &ldquo;at the
higher level, the mean term is no longer constrained by Level 1 effects,
so it is free to account for all the higher-level variance associated
with that variable&rdquo; (<cite>Bell et al. 2015</cite>).
</p>



<h4>Panel data and correlating fixed and group effects</h4>

<p><code>demean()</code> is intended to create group- and de-meaned variables
for panel regression models (fixed effects models), or for complex
random-effect-within-between models (see <cite>Bell et al. 2015, 2018</cite>),
where group-effects (random effects) and fixed effects correlate (see
<cite>Bafumi and Gelman 2006</cite>). This can happen, for instance, when
analyzing panel data, which can lead to <em>Heterogeneity Bias</em>. To
control for correlating predictors and group effects, it is recommended
to include the group-meaned and de-meaned version of <em>time-varying covariates</em>
(and group-meaned version of <em>time-invariant covariates</em> that are on
a higher level, e.g. level-2 predictors) in the model. By this, one can
fit complex multilevel models for panel data, including time-varying
predictors, time-invariant predictors and random effects.
</p>



<h4>Why mixed models are preferred over fixed effects models</h4>

<p>A mixed models approach can model the causes of endogeneity explicitly
by including the (separated) within- and between-effects of time-varying
fixed effects and including time-constant fixed effects. Furthermore,
mixed models also include random effects, thus a mixed models approach
is superior to classic fixed-effects models, which lack information of
variation in the group-effects or between-subject effects. Furthermore,
fixed effects regression cannot include random slopes, which means that
fixed effects regressions are neglecting &ldquo;cross-cluster differences
in the effects of lower-level controls (which) reduces the precision of
estimated context effects, resulting in unnecessarily wide confidence
intervals and low statistical power&rdquo; (<cite>Heisig et al. 2017</cite>).
</p>



<h4>Terminology</h4>

<p>The group-meaned variable is simply the mean of an independent variable
within each group (or id-level or cluster) represented by <code>group</code>.
It represents the cluster-mean of an independent variable. The regression
coefficient of a group-meaned variable is the <em>between-subject-effect</em>.
The de-meaned variable is then the centered version of the group-meaned
variable. De-meaning is sometimes also called person-mean centering or
centering within clusters. The regression coefficient of a de-meaned
variable represents the <em>within-subject-effect</em>.
</p>



<h4>De-meaning with continuous predictors</h4>

<p>For continuous time-varying predictors, the recommendation is to include
both their de-meaned and group-meaned versions as fixed effects, but not
the raw (untransformed) time-varying predictors themselves. The de-meaned
predictor should also be included as random effect (random slope). In
regression models, the coefficient of the de-meaned predictors indicates
the within-subject effect, while the coefficient of the group-meaned
predictor indicates the between-subject effect.
</p>



<h4>De-meaning with binary predictors</h4>

<p>For binary time-varying predictors, there are two recommendations. First
is to include the raw (untransformed) binary predictor as fixed effect
only and the <em>de-meaned</em> variable as random effect (random slope).
The alternative would be to add the de-meaned version(s) of binary
time-varying covariates as additional fixed effect as well (instead of
adding it as random slope). Centering time-varying binary variables to
obtain within-effects (level 1) isn't necessary. They have a sensible
interpretation when left in the typical 0/1 format (<cite>Hoffmann 2015,
chapter 8-2.I</cite>). <code>demean()</code> will thus coerce categorical time-varying
predictors to numeric to compute the de- and group-meaned versions for
these variables, where the raw (untransformed) binary predictor and the
de-meaned version should be added to the model.
</p>



<h4>De-meaning of factors with more than 2 levels</h4>

<p>Factors with more than two levels are demeaned in two ways: first, these
are also converted to numeric and de-meaned; second, dummy variables
are created (binary, with 0/1 coding for each level) and these binary
dummy-variables are de-meaned in the same way (as described above).
Packages like <span class="pkg">panelr</span> internally convert factors to dummies before
demeaning, so this behaviour can be mimicked here.
</p>



<h4>De-meaning interaction terms</h4>

<p> There are multiple ways to deal
with interaction terms of within- and between-effects. A classical approach
is to simply use the product term of the de-meaned variables (i.e.
introducing the de-meaned variables as interaction term in the model
formula, e.g. <code>y ~ x_within * time_within</code>). This approach, however,
might be subject to bias (see <cite>Giesselmann &amp; Schmidt-Catran 2020</cite>).
<br /> <br />
Another option is to first calculate the product term and then apply the
de-meaning to it. This approach produces an estimator &ldquo;that reflects
unit-level differences of interacted variables whose moderators vary
within units&rdquo;, which is desirable if <em>no</em> within interaction of
two time-dependent variables is required. <br /> <br />
A third option, when the interaction should result in a genuine within
estimator, is to &quot;double de-mean&quot; the interaction terms
(<cite>Giesselmann &amp; Schmidt-Catran 2018</cite>), however, this is currently
not supported by <code>demean()</code>. If this is required, the <code>wmb()</code>
function from the <span class="pkg">panelr</span> package should be used. <br /> <br />
To de-mean interaction terms for within-between models, simply specify
the term as interaction for the <code>select</code>-argument, e.g.
<code>select = "a*b"</code> (see 'Examples').
</p>



<h4>Analysing panel data with mixed models using lme4</h4>

<p>A description of how to translate the
formulas described in <em>Bell et al. 2018</em> into R using <code>lmer()</code>
from <span class="pkg">lme4</span> can be found in
<a href="https://easystats.github.io/parameters/articles/demean.html">this vignette</a>.
</p>



<h3>Value</h3>

<p>A data frame with the group-/de-meaned variables, which get the suffix
<code>"_between"</code> (for the group-meaned variable) and <code>"_within"</code> (for the
de-meaned variable) by default.
</p>


<h3>References</h3>


<ul>
<li><p> Bafumi J, Gelman A. 2006. Fitting Multilevel Models When Predictors
and Group Effects Correlate. In. Philadelphia, PA: Annual meeting of the
American Political Science Association.
</p>
</li>
<li><p> Bell A, Fairbrother M, Jones K. 2019. Fixed and Random Effects
Models: Making an Informed Choice. Quality &amp; Quantity (53); 1051-1074
</p>
</li>
<li><p> Bell A, Jones K. 2015. Explaining Fixed Effects: Random Effects
Modeling of Time-Series Cross-Sectional and Panel Data. Political Science
Research and Methods, 3(1), 133–153.
</p>
</li>
<li><p> Gelman A, Hill J. 2007. Data Analysis Using Regression and
Multilevel/Hierarchical Models. Analytical Methods for Social Research.
Cambridge, New York: Cambridge University Press
</p>
</li>
<li><p> Giesselmann M, Schmidt-Catran, AW. 2020. Interactions in fixed
effects regression models. Sociological Methods &amp; Research, 1–28.
https://doi.org/10.1177/0049124120914934
</p>
</li>
<li><p> Heisig JP, Schaeffer M, Giesecke J. 2017. The Costs of Simplicity:
Why Multilevel Models May Benefit from Accounting for Cross-Cluster
Differences in the Effects of Controls. American Sociological Review 82
(4): 796–827.
</p>
</li>
<li><p> Hoffman L. 2015. Longitudinal analysis: modeling within-person
fluctuation and change. New York: Routledge
</p>
</li></ul>



<h3>See Also</h3>

<p>If grand-mean centering (instead of centering within-clusters)
is required, see <code><a href="#topic+center">center()</a></code>. See <code><a href="performance.html#topic+check_heterogeneity_bias">performance::check_heterogeneity_bias()</a></code>
to check for heterogeneity bias.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris$ID &lt;- sample(1:4, nrow(iris), replace = TRUE) # fake-ID
iris$binary &lt;- as.factor(rbinom(150, 1, .35)) # binary variable

x &lt;- demean(iris, select = c("Sepal.Length", "Petal.Length"), group = "ID")
head(x)

x &lt;- demean(iris, select = c("Sepal.Length", "binary", "Species"), group = "ID")
head(x)


# demean interaction term x*y
dat &lt;- data.frame(
  a = c(1, 2, 3, 4, 1, 2, 3, 4),
  x = c(4, 3, 3, 4, 1, 2, 1, 2),
  y = c(1, 2, 1, 2, 4, 3, 2, 1),
  ID = c(1, 2, 3, 1, 2, 3, 1, 2)
)
demean(dat, select = c("a", "x*y"), group = "ID")

# or in formula-notation
demean(dat, select = ~ a + x * y, group = ~ID)

</code></pre>

<hr>
<h2 id='describe_distribution'>Describe a distribution</h2><span id='topic+describe_distribution'></span><span id='topic+describe_distribution.numeric'></span><span id='topic+describe_distribution.factor'></span><span id='topic+describe_distribution.data.frame'></span>

<h3>Description</h3>

<p>This function describes a distribution by a set of indices (e.g., measures of
centrality, dispersion, range, skewness, kurtosis).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_distribution(x, ...)

## S3 method for class 'numeric'
describe_distribution(
  x,
  centrality = "mean",
  dispersion = TRUE,
  iqr = TRUE,
  range = TRUE,
  quartiles = FALSE,
  ci = NULL,
  iterations = 100,
  threshold = 0.1,
  verbose = TRUE,
  ...
)

## S3 method for class 'factor'
describe_distribution(x, dispersion = TRUE, range = TRUE, verbose = TRUE, ...)

## S3 method for class 'data.frame'
describe_distribution(
  x,
  select = NULL,
  exclude = NULL,
  centrality = "mean",
  dispersion = TRUE,
  iqr = TRUE,
  range = TRUE,
  quartiles = FALSE,
  include_factors = FALSE,
  ci = NULL,
  iterations = 100,
  threshold = 0.1,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_distribution_+3A_x">x</code></td>
<td>
<p>A numeric vector, a character vector, a data frame, or a list. See
<code>Details</code>.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_centrality">centrality</code></td>
<td>
<p>The point-estimates (centrality indices) to compute. Character
(vector) or list with one or more of these options: <code>"median"</code>, <code>"mean"</code>, <code>"MAP"</code>
(see <code><a href="bayestestR.html#topic+map_estimate">map_estimate()</a></code>), <code>"trimmed"</code> (which is just <code>mean(x, trim = threshold)</code>),
<code>"mode"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_dispersion">dispersion</code></td>
<td>
<p>Logical, if <code>TRUE</code>, computes indices of dispersion related
to the estimate(s) (<code>SD</code> and <code>MAD</code> for <code>mean</code> and <code>median</code>, respectively).
Dispersion is not available for <code>"MAP"</code> or <code>"mode"</code> centrality indices.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_iqr">iqr</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the interquartile range is calculated
(based on <code><a href="stats.html#topic+IQR">stats::IQR()</a></code>, using <code>type = 6</code>).</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_range">range</code></td>
<td>
<p>Return the range (min and max).</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_quartiles">quartiles</code></td>
<td>
<p>Return the first and third quartiles (25th and 75pth
percentiles).</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default is <code>NULL</code>, i.e. no
confidence intervals are computed. If not <code>NULL</code>, confidence intervals
are based on bootstrap replicates (see <code>iterations</code>). If
<code>centrality = "all"</code>, the bootstrapped confidence interval refers to
the first centrality index (which is typically the median).</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_iterations">iterations</code></td>
<td>
<p>The number of bootstrap replicates for computing confidence
intervals. Only applies when <code>ci</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_threshold">threshold</code></td>
<td>
<p>For <code>centrality = "trimmed"</code> (i.e. trimmed mean), indicates
the fraction (0 to 0.5) of observations to be trimmed from each end of the
vector before the mean is computed.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_include_factors">include_factors</code></td>
<td>
<p>Logical, if <code>TRUE</code>, factors are included in the
output, however, only columns for range (first and last factor levels) as
well as n and missing will contain information.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="describe_distribution_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a data frame, only numeric variables are kept and will be
displayed in the summary.
</p>
<p>If <code>x</code> is a list, the behavior is different whether <code>x</code> is a stored list. If
<code>x</code> is stored (for example, <code>describe_distribution(mylist)</code> where <code>mylist</code>
was created before), artificial variable names are used in the summary
(<code>Var_1</code>, <code>Var_2</code>, etc.). If <code>x</code> is an unstored list (for example,
<code>describe_distribution(list(mtcars$mpg))</code>), then <code>"mtcars$mpg"</code> is used as
variable name.
</p>


<h3>Value</h3>

<p>A data frame with columns that describe the properties of the variables.
</p>


<h3>Note</h3>

<p>There is also a
<a href="https://easystats.github.io/see/articles/parameters.html"><code>plot()</code>-method</a>
implemented in the
<a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
describe_distribution(rnorm(100))

data(iris)
describe_distribution(iris)
describe_distribution(iris, include_factors = TRUE, quartiles = TRUE)
describe_distribution(list(mtcars$mpg, mtcars$cyl))

</code></pre>

<hr>
<h2 id='distribution_mode'>Compute mode for a statistical distribution</h2><span id='topic+distribution_mode'></span>

<h3>Description</h3>

<p>Compute mode for a statistical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution_mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_mode_+3A_x">x</code></td>
<td>
<p>An atomic vector, a list, or a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value that appears most frequently in the provided data.
The returned data structure will be the same as the entered one.
</p>


<h3>See Also</h3>

<p>For continuous variables, the
<strong>Highest Maximum a Posteriori probability estimate (MAP)</strong> may be
a more useful way to estimate the most commonly-observed value
than the mode. See <code><a href="bayestestR.html#topic+map_estimate">bayestestR::map_estimate()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
distribution_mode(c(1, 2, 3, 3, 4, 5))
distribution_mode(c(1.5, 2.3, 3.7, 3.7, 4.0, 5))

</code></pre>

<hr>
<h2 id='efc'>Sample dataset from the EFC Survey</h2><span id='topic+efc'></span>

<h3>Description</h3>

<p>Selected variables from the EUROFAMCARE survey. Useful when
testing on &quot;real-life&quot; data sets, including random missing values. This
data set also has value and variable label attributes.
</p>

<hr>
<h2 id='find_columns'>Find or get columns in a data frame based on search patterns</h2><span id='topic+find_columns'></span><span id='topic+data_find'></span><span id='topic+get_columns'></span><span id='topic+data_select'></span>

<h3>Description</h3>

<p><code>find_columns()</code> returns column names from a data set that
match a certain search pattern, while <code>get_columns()</code> returns the found data.
<code>data_select()</code> is an alias for <code>get_columns()</code>, and <code>data_find()</code> is an alias
for <code>find_columns()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_columns(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_find(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

get_columns(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

data_select(
  data,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_columns_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="find_columns_+3A_...">...</code></td>
<td>
<p>Arguments passed down to other functions. Mostly not used yet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it is possible to either pass an entire select helper or only the
pattern inside a select helper as a function argument:
</p>
<div class="sourceCode r"><pre>foo &lt;- function(data, pattern) {
  find_columns(data, select = starts_with(pattern))
}
foo(iris, pattern = "Sep")

foo2 &lt;- function(data, pattern) {
  find_columns(data, select = pattern)
}
foo2(iris, pattern = starts_with("Sep"))
</pre></div>
<p>This means that it is also possible to use loop values as arguments or patterns:
</p>
<div class="sourceCode r"><pre>for (i in c("Sepal", "Sp")) {
  head(iris) |&gt;
    find_columns(select = starts_with(i)) |&gt;
    print()
}
</pre></div>
<p>However, this behavior is limited to a &quot;single-level function&quot;. It will not
work in nested functions, like below:
</p>
<div class="sourceCode r"><pre>inner &lt;- function(data, arg) {
  find_columns(data, select = arg)
}
outer &lt;- function(data, arg) {
  inner(data, starts_with(arg))
}
outer(iris, "Sep")
</pre></div>
<p>In this case, it is better to pass the whole select helper as the argument of
<code>outer()</code>:
</p>
<div class="sourceCode r"><pre>outer &lt;- function(data, arg) {
  inner(data, arg)
}
outer(iris, starts_with("Sep"))
</pre></div>


<h3>Value</h3>

<p><code>find_columns()</code> returns a character vector with column names that matched
the pattern in <code>select</code> and <code>exclude</code>, or <code>NULL</code> if no matching column name
was found. <code>get_columns()</code> returns a data frame with matching columns.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Find columns names by pattern
find_columns(iris, starts_with("Sepal"))
find_columns(iris, ends_with("Width"))
find_columns(iris, regex("\\."))
find_columns(iris, c("Petal.Width", "Sepal.Length"))

# starts with "Sepal", but not allowed to end with "width"
find_columns(iris, starts_with("Sepal"), exclude = contains("Width"))

# find numeric with mean &gt; 3.5
numeric_mean_35 &lt;- function(x) is.numeric(x) &amp;&amp; mean(x, na.rm = TRUE) &gt; 3.5
find_columns(iris, numeric_mean_35)
</code></pre>

<hr>
<h2 id='labels_to_levels'>Convert value labels into factor levels</h2><span id='topic+labels_to_levels'></span><span id='topic+labels_to_levels.factor'></span><span id='topic+labels_to_levels.data.frame'></span>

<h3>Description</h3>

<p>Convert value labels into factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_to_levels(x, ...)

## S3 method for class 'factor'
labels_to_levels(x, verbose = TRUE, ...)

## S3 method for class 'data.frame'
labels_to_levels(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  append = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_to_levels_+3A_x">x</code></td>
<td>
<p>A data frame or factor. Other variable types (e.g. numerics) are not
allowed.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="labels_to_levels_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>labels_to_levels()</code> allows to use value labels of factors as their levels.
</p>


<h3>Value</h3>

<p><code>x</code>, where for all factors former levels are replaced by their value
labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
# create factor
x &lt;- as.factor(efc$c172code)
# add value labels - these are not factor levels yet
x &lt;- assign_labels(x, values = c(`1` = "low", `2` = "mid", `3` = "high"))
levels(x)
data_tabulate(x)

x &lt;- labels_to_levels(x)
levels(x)
data_tabulate(x)
</code></pre>

<hr>
<h2 id='makepredictcall.dw_transformer'>Utility Function for Safe Prediction with <code>datawizard</code> transformers</h2><span id='topic+makepredictcall.dw_transformer'></span>

<h3>Description</h3>

<p>This function allows for the use of (some of) <code>datawizard</code>'s transformers
inside a model formula. See examples below.
<br /><br />
Currently, <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, &amp; <code><a href="#topic+rescale">rescale()</a></code> are
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dw_transformer'
makepredictcall(var, call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makepredictcall.dw_transformer_+3A_var">var</code></td>
<td>
<p>A variable.</p>
</td></tr>
<tr><td><code id="makepredictcall.dw_transformer_+3A_call">call</code></td>
<td>
<p>The term in the formula, as a call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A replacement for <code>call</code> for the <code>predvars</code> attribute of
the terms.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+makepredictcall">stats::makepredictcall()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")
train &lt;- mtcars[1:30, ]
test &lt;- mtcars[31:32, ]

m1 &lt;- lm(mpg ~ center(hp), data = train)
predict(m1, newdata = test) # Data is "centered" before the prediction is made,
# according to the center of the old data

m2 &lt;- lm(mpg ~ standardize(hp), data = train)
m3 &lt;- lm(mpg ~ scale(hp), data = train) # same as above
predict(m2, newdata = test) # Data is "standardized" before the prediction is made.
predict(m3, newdata = test) # Data is "standardized" before the prediction is made.


m4 &lt;- lm(mpg ~ normalize(hp), data = mtcars)
m5 &lt;- lm(mpg ~ rescale(hp, to = c(-3, 3)), data = mtcars)

(newdata &lt;- data.frame(hp = c(range(mtcars$hp), 400))) # 400 is outside original range!

model.frame(delete.response(terms(m4)), data = newdata)
model.frame(delete.response(terms(m5)), data = newdata)

</code></pre>

<hr>
<h2 id='mean_sd'>Summary Helpers</h2><span id='topic+mean_sd'></span><span id='topic+median_mad'></span>

<h3>Description</h3>

<p>Summary Helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_sd(x, times = 1L, remove_na = TRUE, named = TRUE, na.rm = TRUE, ...)

median_mad(
  x,
  times = 1L,
  remove_na = TRUE,
  constant = 1.4826,
  named = TRUE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_sd_+3A_x">x</code></td>
<td>
<p>A numeric vector (or one that can be coerced to one via
<code>as.numeric()</code>) to be summarized.</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_times">times</code></td>
<td>
<p>How many SDs above and below the Mean (or MADs around the Median)</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical. Should <code>NA</code> values be removed before computing (<code>TRUE</code>)
or not (<code>FALSE</code>, default)?</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_named">named</code></td>
<td>
<p>Should the vector be named?
(E.g., <code>c("-SD" = -1, Mean = 1, "+SD" = 2)</code>.)</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_na.rm">na.rm</code></td>
<td>
<p>Deprecated. Please use <code>remove_na</code> instead.</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mean_sd_+3A_constant">constant</code></td>
<td>
<p>scale factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (possibly named) numeric vector of length <code>2*times + 1</code> of SDs
below the mean, the mean, and SDs above the mean (or median and MAD).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_sd(mtcars$mpg)

mean_sd(mtcars$mpg, times = 2L)

median_mad(mtcars$mpg)

</code></pre>

<hr>
<h2 id='means_by_group'>Summary of mean values by group</h2><span id='topic+means_by_group'></span><span id='topic+means_by_group.numeric'></span><span id='topic+means_by_group.data.frame'></span>

<h3>Description</h3>

<p>Computes summary table of means by groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means_by_group(x, ...)

## S3 method for class 'numeric'
means_by_group(x, group = NULL, ci = 0.95, weights = NULL, digits = NULL, ...)

## S3 method for class 'data.frame'
means_by_group(
  x,
  select = NULL,
  group = NULL,
  ci = 0.95,
  weights = NULL,
  digits = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="means_by_group_+3A_x">x</code></td>
<td>
<p>A vector or a data frame.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_group">group</code></td>
<td>
<p>If <code>x</code> is a numeric vector, <code>group</code> should be a factor that
indicates the group-classifying categories. If <code>x</code> is a data frame, <code>group</code>
should be a character string, naming the variable in <code>x</code> that is used for
grouping. Numeric vectors are coerced to factors. Not that <code>group</code> should
only refer to a single variable.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_ci">ci</code></td>
<td>
<p>Level of confidence interval for mean estimates. Default is <code>0.95</code>.
Use <code>ci = NA</code> to suppress confidence intervals.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_weights">weights</code></td>
<td>
<p>If <code>x</code> is a numeric vector, <code>weights</code> should be a vector of
weights that will be applied to weight all observations. If <code>x</code> is a data
frame, <code>weights</code> can also be a character string indicating the name of the
variable in <code>x</code> that should be used for weighting. Default is <code>NULL</code>, so no
weights are used.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_digits">digits</code></td>
<td>
<p>Optional scalar, indicating the amount of digits after decimal
point when rounding estimates and values.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="means_by_group_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is comparable to <code>aggregate(x, group, mean)</code>, but provides
some further information, including summary statistics from a One-Way-ANOVA
using <code>x</code> as dependent and <code>group</code> as independent variable. <code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>
is used to get p-values for each sub-group. P-values indicate whether each
group-mean is significantly different from the total mean.
</p>


<h3>Value</h3>

<p>A data frame with information on mean and further summary statistics
for each sub-group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(efc)
means_by_group(efc, "c12hour", "e42dep")

data(iris)
means_by_group(iris, "Sepal.Width", "Species")

# weighting
efc$weight &lt;- abs(rnorm(n = nrow(efc), mean = 1, sd = .5))
means_by_group(efc, "c12hour", "e42dep", weights = "weight")
</code></pre>

<hr>
<h2 id='nhanes_sample'>Sample dataset from the National Health and Nutrition Examination Survey</h2><span id='topic+nhanes_sample'></span>

<h3>Description</h3>

<p>Selected variables from the National Health and Nutrition Examination
Survey that are used in the example from Lumley (2010), Appendix E.
</p>


<h3>References</h3>

<p>Lumley T (2010). Complex Surveys: a guide to analysis using R. Wiley
</p>

<hr>
<h2 id='normalize'>Normalize numeric variable to 0-1 range</h2><span id='topic+normalize'></span><span id='topic+normalize.numeric'></span><span id='topic+normalize.data.frame'></span><span id='topic+unnormalize'></span><span id='topic+unnormalize.numeric'></span><span id='topic+unnormalize.data.frame'></span><span id='topic+unnormalize.grouped_df'></span>

<h3>Description</h3>

<p>Performs a normalization of data, i.e., it scales variables in the range
0 - 1. This is a special case of <code><a href="#topic+rescale">rescale()</a></code>. <code>unnormalize()</code> is the
counterpart, but only works for variables that have been normalized with
<code>normalize()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)

## S3 method for class 'numeric'
normalize(x, include_bounds = TRUE, verbose = TRUE, ...)

## S3 method for class 'data.frame'
normalize(
  x,
  select = NULL,
  exclude = NULL,
  include_bounds = TRUE,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

unnormalize(x, ...)

## S3 method for class 'numeric'
unnormalize(x, verbose = TRUE, ...)

## S3 method for class 'data.frame'
unnormalize(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'grouped_df'
unnormalize(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>A numeric vector, (grouped) data frame, or matrix. See 'Details'.</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="normalize_+3A_include_bounds">include_bounds</code></td>
<td>
<p>Numeric or logical. Using this can be useful in case of
beta-regression, where the response variable is not allowed to include
zeros and ones. If <code>TRUE</code>, the input is normalized to a range that includes
zero and one. If <code>FALSE</code>, the return value is compressed, using
Smithson and Verkuilen's (2006) formula <code>(x * (n - 1) + 0.5) / n</code>, to avoid
zeros and ones in the normalized variables. Else, if numeric (e.g., <code>0.001</code>),
<code>include_bounds</code> defines the &quot;distance&quot; to the lower and upper bound, i.e.
the normalized vectors are rescaled to a range from <code>0 + include_bounds</code> to
<code>1 - include_bounds</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages on or off.</p>
</td></tr>
<tr><td><code id="normalize_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="normalize_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, standardized variables get new
column names (with the suffix <code>"_z"</code>) and are appended (column bind) to <code>x</code>,
thus returning both the original and the standardized variables. If <code>FALSE</code>,
original variables in <code>x</code> will be overwritten by their standardized versions.
If a character value, standardized variables are appended with new column
names (using the defined suffix) to the original data frame.</p>
</td></tr>
<tr><td><code id="normalize_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="normalize_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If <code>x</code> is a matrix, normalization is performed across all values (not
column- or row-wise). For column-wise normalization, convert the matrix to a
data.frame.
</p>
</li>
<li><p> If <code>x</code> is a grouped data frame (<code>grouped_df</code>), normalization is performed
separately for each group.
</p>
</li></ul>



<h3>Value</h3>

<p>A normalized object.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>References</h3>

<p>Smithson M, Verkuilen J (2006). A Better Lemon Squeezer? Maximum-Likelihood
Regression with Beta-Distributed Dependent Variables. Psychological Methods,
11(1), 54–71.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+makepredictcall.dw_transformer">makepredictcall.dw_transformer()</a></code> for use in model formulas.
</p>
<p>Other transform utilities: 
<code><a href="#topic+ranktransform">ranktransform</a>()</code>,
<code><a href="#topic+rescale">rescale</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
normalize(c(0, 1, 5, -5, -2))
normalize(c(0, 1, 5, -5, -2), include_bounds = FALSE)
# use a value defining the bounds
normalize(c(0, 1, 5, -5, -2), include_bounds = .001)

head(normalize(trees))

</code></pre>

<hr>
<h2 id='ranktransform'>(Signed) rank transformation</h2><span id='topic+ranktransform'></span><span id='topic+ranktransform.numeric'></span><span id='topic+ranktransform.data.frame'></span>

<h3>Description</h3>

<p>Transform numeric values with the integers of their rank (i.e., 1st smallest,
2nd smallest, 3rd smallest, etc.). Setting the <code>sign</code> argument to <code>TRUE</code> will
give you signed ranks, where the ranking is done according to absolute size
but where the sign is preserved (i.e., 2, 1, -3, 4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranktransform(x, ...)

## S3 method for class 'numeric'
ranktransform(x, sign = FALSE, method = "average", verbose = TRUE, ...)

## S3 method for class 'data.frame'
ranktransform(
  x,
  select = NULL,
  exclude = NULL,
  sign = FALSE,
  method = "average",
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranktransform_+3A_x">x</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_sign">sign</code></td>
<td>
<p>Logical, if <code>TRUE</code>, return signed ranks.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_method">method</code></td>
<td>
<p>Treatment of ties. Can be one of <code>"average"</code> (default),
<code>"first"</code>, <code>"last"</code>, <code>"random"</code>, <code>"max"</code> or <code>"min"</code>. See <code><a href="base.html#topic+rank">rank()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="ranktransform_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rank-transformed object.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>See Also</h3>

<p>Other transform utilities: 
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+rescale">rescale</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranktransform(c(0, 1, 5, -5, -2))

# Won't work
# ranktransform(c(0, 1, 5, -5, -2), sign = TRUE)

head(ranktransform(trees))
</code></pre>

<hr>
<h2 id='recode_into'>Recode values from one or more variables into a new variable</h2><span id='topic+recode_into'></span>

<h3>Description</h3>

<p>This functions recodes values from one or more variables into a new variable.
It is a convenient function to avoid nested <code><a href="base.html#topic+ifelse">ifelse()</a></code> statements, which
is similar to <code>dplyr::case_when()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_into(
  ...,
  data = NULL,
  default = NA,
  overwrite = TRUE,
  preserve_na = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_into_+3A_...">...</code></td>
<td>
<p>A sequence of two-sided formulas, where the left hand side (LHS)
is a logical matching condition that determines which values match this case.
The LHS of this formula is also called &quot;recode pattern&quot; (e.g., in messages).
The right hand side (RHS) indicates the replacement value.</p>
</td></tr>
<tr><td><code id="recode_into_+3A_data">data</code></td>
<td>
<p>Optional, name of a data frame. This can be used to avoid writing
the data name multiple times in <code>...</code>. See 'Examples'.</p>
</td></tr>
<tr><td><code id="recode_into_+3A_default">default</code></td>
<td>
<p>Indicates the default value that is chosen when no match in
the formulas in <code>...</code> is found. If not provided, <code>NA</code> is used as default
value.</p>
</td></tr>
<tr><td><code id="recode_into_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) and more than one recode pattern
apply to the same case, already recoded values will be overwritten by subsequent
recode patterns. If <code>FALSE</code>, former recoded cases will not be altered by later
recode patterns that would apply to those cases again. A warning message is
printed to alert such situations and to avoid unintentional recodings.</p>
</td></tr>
<tr><td><code id="recode_into_+3A_preserve_na">preserve_na</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>default</code> is not <code>NA</code>, missing
values in the original variable will be set back to <code>NA</code> in the recoded
variable (unless overwritten by other recode patterns). If <code>FALSE</code>, missing
values in the original variable will be recoded to <code>default</code>. Setting
<code>preserve_na = TRUE</code> prevents unintentional overwriting of missing values
with <code>default</code>, which means that you won't find valid values where the
original data only had missing values. See 'Examples'.</p>
</td></tr>
<tr><td><code id="recode_into_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with recoded values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:30
recode_into(
  x &gt; 15 ~ "a",
  x &gt; 10 &amp; x &lt;= 15 ~ "b",
  default = "c"
)

x &lt;- 1:10
# default behaviour: second recode pattern "x &gt; 5" overwrites
# some of the formerly recoded cases from pattern "x &gt;= 3 &amp; x &lt;= 7"
recode_into(
  x &gt;= 3 &amp; x &lt;= 7 ~ 1,
  x &gt; 5 ~ 2,
  default = 0,
  verbose = FALSE
)

# setting "overwrite = FALSE" will not alter formerly recoded cases
recode_into(
  x &gt;= 3 &amp; x &lt;= 7 ~ 1,
  x &gt; 5 ~ 2,
  default = 0,
  overwrite = FALSE,
  verbose = FALSE
)

set.seed(123)
d &lt;- data.frame(
  x = sample(1:5, 30, TRUE),
  y = sample(letters[1:5], 30, TRUE),
  stringsAsFactors = FALSE
)

# from different variables into new vector
recode_into(
  d$x %in% 1:3 &amp; d$y %in% c("a", "b") ~ 1,
  d$x &gt; 3 ~ 2,
  default = 0
)

# no need to write name of data frame each time
recode_into(
  x %in% 1:3 &amp; y %in% c("a", "b") ~ 1,
  x &gt; 3 ~ 2,
  data = d,
  default = 0
)

# handling of missing values
d &lt;- data.frame(
  x = c(1, NA, 2, NA, 3, 4),
  y = c(1, 11, 3, NA, 5, 6)
)
# first NA in x is overwritten by valid value from y
# we have no known value for second NA in x and y,
# thus we get one NA in the result
recode_into(
  x &lt;= 3 ~ 1,
  y &gt; 5 ~ 2,
  data = d,
  default = 0,
  preserve_na = TRUE
)
# first NA in x is overwritten by valid value from y
# default value is used for second NA
recode_into(
  x &lt;= 3 ~ 1,
  y &gt; 5 ~ 2,
  data = d,
  default = 0,
  preserve_na = FALSE
)
</code></pre>

<hr>
<h2 id='recode_values'>Recode old values of variables into new values</h2><span id='topic+recode_values'></span><span id='topic+recode_values.numeric'></span><span id='topic+recode_values.data.frame'></span><span id='topic+change_code'></span>

<h3>Description</h3>

<p>This functions recodes old values into new values and can be used to to
recode numeric or character vectors, or factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_values(x, ...)

## S3 method for class 'numeric'
recode_values(
  x,
  recode = NULL,
  default = NULL,
  preserve_na = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
recode_values(
  x,
  select = NULL,
  exclude = NULL,
  recode = NULL,
  default = NULL,
  preserve_na = TRUE,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

change_code(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_values_+3A_x">x</code></td>
<td>
<p>A data frame, numeric or character vector, or factor.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_recode">recode</code></td>
<td>
<p>A list of named vectors, which indicate the recode pairs.
The <em>names</em> of the list-elements (i.e. the left-hand side) represent the
<em>new</em> values, while the values of the list-elements indicate the original
(old) values that should be replaced. When recoding numeric vectors,
element names have to be surrounded in backticks. For example,
<code>recode=list(`0`=1)</code> would recode all <code>1</code> into <code>0</code> in a numeric
vector. See also 'Examples' and 'Details'.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_default">default</code></td>
<td>
<p>Defines the default value for all values that have
no match in the recode-pairs. Note that, if <code>preserve_na=FALSE</code>, missing
values (<code>NA</code>) are also captured by the <code>default</code> argument, and thus will
also be recoded into the specified value. See 'Examples' and 'Details'.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_preserve_na">preserve_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, <code>NA</code> (missing values) are preserved.
This overrides any other arguments, including <code>default</code>. Hence, if
<code>preserve_na=TRUE</code>, <code>default</code> will no longer convert <code>NA</code> into the specified
default value.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="recode_values_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section describes the pattern of the <code>recode</code> arguments, which also
provides some shortcuts, in particular when recoding numeric values.
</p>

<ul>
<li><p> Single values
</p>
<p>Single values either need to be wrapped in backticks (in case of numeric
values) or &quot;as is&quot; (for character or factor levels). Example:
<code>recode=list(`0`=1,`1`=2)</code> would recode 1 into 0, and 2 into 1.
For factors or character vectors, an example is:
<code>recode=list(x="a",y="b")</code> (recode &quot;a&quot; into &quot;x&quot; and &quot;b&quot; into &quot;y&quot;).
</p>
</li>
<li><p> Multiple values
</p>
<p>Multiple values that should be recoded into a new value can be separated
with comma. Example: <code>recode=list(`1`=c(1,4),`2`=c(2,3))</code> would recode the
values 1 and 4 into 1, and 2 and 3 into 2. It is also possible to define  the
old values as a character string, like:  <code>recode=list(`1`="1,4",`2`="2,3")</code>
For factors or character vectors, an example is:
<code>recode=list(x=c("a","b"),y=c("c","d"))</code>.
</p>
</li>
<li><p> Value range
</p>
<p>Numeric value ranges can be defined using the <code>:</code>. Example:
<code>recode=list(`1`=1:3,`2`=4:6)</code> would recode all values from 1 to 3 into
1, and 4 to 6 into 2.
</p>
</li>
<li> <p><code>min</code> and <code>max</code>
</p>
<p>placeholder to use the minimum or maximum value of the
(numeric) variable. Useful, e.g., when recoding ranges of values.
Example: <code>recode=list(`1`="min:10",`2`="11:max")</code>.
</p>
</li>
<li> <p><code>default</code> values
</p>
<p>The <code>default</code> argument defines the default value for all values that have
no match in the recode-pairs. For example,
<code style="white-space: pre;">&#8288;recode=list(`1`=c(1,2),`2`=c(3,4)), default=9&#8288;</code> would
recode values 1 and 2 into 1, 3 and 4 into 2, and all other values into 9.
If <code>preserve_na</code> is set to <code>FALSE</code>, <code>NA</code> (missing values) will also be
recoded into the specified default value.
</p>
</li>
<li><p> Reversing and rescaling
</p>
<p>See <code><a href="#topic+reverse">reverse()</a></code> and <code><a href="#topic+rescale">rescale()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>x</code>, where old values are replaced by new values.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Note</h3>

<p>You can use <code>options(data_recode_pattern = "old=new")</code> to switch the
behaviour of the <code>recode</code>-argument, i.e. recode-pairs are now following the
pattern <code style="white-space: pre;">&#8288;old values = new values&#8288;</code>, e.g. if <code>getOption("data_recode_pattern")</code>
is set to <code>"old=new"</code>, then <code>recode(`1`=0)</code> would recode all 1 into 0.
The default for <code>recode(`1`=0)</code> is to recode all 0 into 1.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># numeric ----------
set.seed(123)
x &lt;- sample(c(1:4, NA), 15, TRUE)
table(x, useNA = "always")

out &lt;- recode_values(x, list(`0` = 1, `1` = 2:3, `2` = 4))
out
table(out, useNA = "always")

# to recode NA values, set preserve_na to FALSE
out &lt;- recode_values(
  x,
  list(`0` = 1, `1` = 2:3, `2` = 4, `9` = NA),
  preserve_na = FALSE
)
out
table(out, useNA = "always")

# preserve na ----------
out &lt;- recode_values(x, list(`0` = 1, `1` = 2:3), default = 77)
out
table(out, useNA = "always")

# recode na into default ----------
out &lt;- recode_values(
  x,
  list(`0` = 1, `1` = 2:3),
  default = 77,
  preserve_na = FALSE
)
out
table(out, useNA = "always")


# factors (character vectors are similar) ----------
set.seed(123)
x &lt;- as.factor(sample(c("a", "b", "c"), 15, TRUE))
table(x)

out &lt;- recode_values(x, list(x = "a", y = c("b", "c")))
out
table(out)

out &lt;- recode_values(x, list(x = "a", y = "b", z = "c"))
out
table(out)

out &lt;- recode_values(x, list(y = "b,c"), default = 77)
# same as
# recode_values(x, list(y = c("b", "c")), default = 77)
out
table(out)


# data frames ----------
set.seed(123)
d &lt;- data.frame(
  x = sample(c(1:4, NA), 12, TRUE),
  y = as.factor(sample(c("a", "b", "c"), 12, TRUE)),
  stringsAsFactors = FALSE
)

recode_values(
  d,
  recode = list(`0` = 1, `1` = 2:3, `2` = 4, x = "a", y = c("b", "c")),
  append = TRUE
)


# switch recode pattern to "old=new" ----------
options(data_recode_pattern = "old=new")

# numeric
set.seed(123)
x &lt;- sample(c(1:4, NA), 15, TRUE)
table(x, useNA = "always")

out &lt;- recode_values(x, list(`1` = 0, `2:3` = 1, `4` = 2))
table(out, useNA = "always")

# factors (character vectors are similar)
set.seed(123)
x &lt;- as.factor(sample(c("a", "b", "c"), 15, TRUE))
table(x)

out &lt;- recode_values(x, list(a = "x", `b, c` = "y"))
table(out)

# reset options
options(data_recode_pattern = NULL)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+print_html'></span><span id='topic+print_md'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+display">print_html</a></code>, <code><a href="insight.html#topic+display">print_md</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_empty'>Return or remove variables or observations that are completely missing</h2><span id='topic+remove_empty'></span><span id='topic+empty_columns'></span><span id='topic+empty_rows'></span><span id='topic+remove_empty_columns'></span><span id='topic+remove_empty_rows'></span>

<h3>Description</h3>

<p>These functions check which rows or columns of a data frame completely
contain missing values, i.e. which observations or variables completely have
missing values, and either (1) returns their indices; or (2) removes them
from the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_columns(x)

empty_rows(x)

remove_empty_columns(x)

remove_empty_rows(x)

remove_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_empty_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For character vectors, empty string values (i.e. <code>""</code>) are also
considered as missing value. Thus, if a character vector only contains <code>NA</code>
and <code style="white-space: pre;">&#8288;""``, it is considered as empty variable and will be removed. Same applies to observations (rows) that only contain &#8288;</code>NA<code>or</code>&quot;&quot;'.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>empty_columns()</code> and <code>empty_rows()</code>, a numeric (named) vector with row
or column indices of those variables that completely have missing values.
</p>
</li>
<li><p> For <code>remove_empty_columns()</code> and <code>remove_empty_rows()</code>, a data frame with
&quot;empty&quot; columns or rows removed, respectively.
</p>
</li>
<li><p> For <code>remove_empty()</code>, <strong>both</strong> empty rows and columns will be removed.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- data.frame(
  a = c(1, 2, 3, NA, 5),
  b = c(1, NA, 3, NA, 5),
  c = c(NA, NA, NA, NA, NA),
  d = c(1, NA, 3, NA, 5)
)

tmp

# indices of empty columns or rows
empty_columns(tmp)
empty_rows(tmp)

# remove empty columns or rows
remove_empty_columns(tmp)
remove_empty_rows(tmp)

# remove empty columns and rows
remove_empty(tmp)

# also remove "empty" character vectors
tmp &lt;- data.frame(
  a = c(1, 2, 3, NA, 5),
  b = c(1, NA, 3, NA, 5),
  c = c("", "", "", "", ""),
  stringsAsFactors = FALSE
)
empty_columns(tmp)

</code></pre>

<hr>
<h2 id='replace_nan_inf'>Convert infinite or <code>NaN</code> values into <code>NA</code></h2><span id='topic+replace_nan_inf'></span>

<h3>Description</h3>

<p>Replaces all infinite (<code>Inf</code> and <code>-Inf</code>) or <code>NaN</code> values with <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_nan_inf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_nan_inf_+3A_x">x</code></td>
<td>
<p>A vector or a dataframe</p>
</td></tr>
<tr><td><code id="replace_nan_inf_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data with <code>Inf</code>, <code>-Inf</code>, and <code>NaN</code> converted to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector
x &lt;- c(1, 2, NA, 3, NaN, 4, NA, 5, Inf, -Inf, 6, 7)
replace_nan_inf(x)

# a data frame
df &lt;- data.frame(
  x = c(1, NA, 5, Inf, 2, NA),
  y = c(3, NaN, 4, -Inf, 6, 7),
  stringsAsFactors = FALSE
)
replace_nan_inf(df)
</code></pre>

<hr>
<h2 id='rescale'>Rescale Variables to a New Range</h2><span id='topic+rescale'></span><span id='topic+change_scale'></span><span id='topic+rescale.numeric'></span><span id='topic+rescale.data.frame'></span>

<h3>Description</h3>

<p>Rescale variables to a new range. Can also be used to reverse-score variables
(change the keying/scoring direction), or to expand a range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x, ...)

change_scale(x, ...)

## S3 method for class 'numeric'
rescale(
  x,
  to = c(0, 100),
  multiply = NULL,
  add = NULL,
  range = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
rescale(
  x,
  select = NULL,
  exclude = NULL,
  to = c(0, 100),
  multiply = NULL,
  add = NULL,
  range = NULL,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, numeric vector or factor.</p>
</td></tr>
<tr><td><code id="rescale_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="rescale_+3A_to">to</code></td>
<td>
<p>Numeric vector of length 2 giving the new range that the variable
will have after rescaling. To reverse-score a variable, the range should
be given with the maximum value first. See examples.</p>
</td></tr>
<tr><td><code id="rescale_+3A_multiply">multiply</code></td>
<td>
<p>If not <code>NULL</code>, <code>to</code> is ignored and <code>multiply</code> will be used,
giving the factor by which the actual range of <code>x</code> should be expanded.
For example, if a vector ranges from 5 to 15 and <code>multiply = 1.1</code>, the current
range of 10 will be expanded by the factor of 1.1, giving a new range of
11. Thus, the rescaled vector would range from 4.5 to 15.5.</p>
</td></tr>
<tr><td><code id="rescale_+3A_add">add</code></td>
<td>
<p>A vector of length 1 or 2. If not <code>NULL</code>, <code>to</code> is ignored and <code>add</code>
will be used, giving the amount by which the minimum and maximum of the
actual range of <code>x</code> should be expanded. For example, if a vector ranges from
5 to 15 and <code>add = 1</code>, the range will be expanded from 4 to 16. If <code>add</code> is
of length 2, then the first value is used for the lower bound and the second
value for the upper bound.</p>
</td></tr>
<tr><td><code id="rescale_+3A_range">range</code></td>
<td>
<p>Initial (old) range of values. If <code>NULL</code>, will take the range of
the input vector (<code>range(x)</code>).</p>
</td></tr>
<tr><td><code id="rescale_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="rescale_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="rescale_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="rescale_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="rescale_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="rescale_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rescaled object.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+makepredictcall.dw_transformer">makepredictcall.dw_transformer()</a></code> for use in model formulas.
</p>
<p>Other transform utilities: 
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+ranktransform">ranktransform</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rescale(c(0, 1, 5, -5, -2))
rescale(c(0, 1, 5, -5, -2), to = c(-5, 5))
rescale(c(1, 2, 3, 4, 5), to = c(-2, 2))

# Specify the "theoretical" range of the input vector
rescale(c(1, 3, 4), to = c(0, 40), range = c(0, 4))

# Reverse-score a variable
rescale(c(1, 2, 3, 4, 5), to = c(5, 1))
rescale(c(1, 2, 3, 4, 5), to = c(2, -2))

# Data frames
head(rescale(iris, to = c(0, 1)))
head(rescale(iris, to = c(0, 1), select = "Sepal.Length"))

# One can specify a list of ranges
head(rescale(iris, to = list(
  "Sepal.Length" = c(0, 1),
  "Petal.Length" = c(-1, 0)
)))

# "expand" ranges by a factor or a given value
x &lt;- 5:15
x
# both will expand the range by 10%
rescale(x, multiply = 1.1)
rescale(x, add = 0.5)

# expand range by different values
rescale(x, add = c(1, 3))

# Specify list of multipliers
d &lt;- data.frame(x = 5:15, y = 5:15)
rescale(d, multiply = list(x = 1.1, y = 0.5))

</code></pre>

<hr>
<h2 id='rescale_weights'>Rescale design weights for multilevel analysis</h2><span id='topic+rescale_weights'></span>

<h3>Description</h3>

<p>Most functions to fit multilevel and mixed effects models only
allow to specify frequency weights, but not design (i.e. sampling or
probability) weights, which should be used when analyzing complex samples
and survey data. <code>rescale_weights()</code> implements an algorithm proposed
by <cite>Asparouhov (2006)</cite> and <cite>Carle (2009)</cite> to rescale design
weights in survey data to account for the grouping structure of multilevel
models, which then can be used for multilevel modelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_weights(data, group, probability_weights, nest = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_weights_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="rescale_weights_+3A_group">group</code></td>
<td>
<p>Variable names (as character vector, or as formula), indicating
the grouping structure (strata) of the survey data (level-2-cluster
variable). It is also possible to create weights for multiple group
variables; in such cases, each created weighting variable will be suffixed
by the name of the group variable.</p>
</td></tr>
<tr><td><code id="rescale_weights_+3A_probability_weights">probability_weights</code></td>
<td>
<p>Variable indicating the probability (design or
sampling) weights of the survey data (level-1-weight).</p>
</td></tr>
<tr><td><code id="rescale_weights_+3A_nest">nest</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>group</code> indicates at least two
group variables, then groups are &quot;nested&quot;, i.e. groups are now a
combination from each group level of the variables in <code>group</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rescaling is based on two methods: For <code>pweights_a</code>, the sample weights
<code>probability_weights</code> are adjusted by a factor that represents the proportion
of group size divided by the sum of sampling weights within each group. The
adjustment factor for <code>pweights_b</code> is the sum of sample weights within each
group divided by the sum of squared sample weights within each group (see
Carle (2009), Appendix B). In other words, <code>pweights_a</code> &quot;scales the weights
so that the new weights sum to the cluster sample size&quot; while <code>pweights_b</code>
&quot;scales the weights so that the new weights sum to the effective cluster
size&quot;.
</p>
<p>Regarding the choice between scaling methods A and B, Carle suggests that
&quot;analysts who wish to discuss point estimates should report results based on
weighting method A. For analysts more interested in residual between-group
variance, method B may generally provide the least biased estimates&quot;. In
general, it is recommended to fit a non-weighted model and weighted models
with both scaling methods and when comparing the models, see whether the
&quot;inferential decisions converge&quot;, to gain confidence in the results.
</p>
<p>Though the bias of scaled weights decreases with increasing group size,
method A is preferred when insufficient or low group size is a concern.
</p>
<p>The group ID and probably PSU may be used as random effects (e.g. nested
design, or group and PSU as varying intercepts), depending on the survey
design that should be mimicked.
</p>


<h3>Value</h3>

<p><code>data</code>, including the new weighting variables: <code>pweights_a</code>
and <code>pweights_b</code>, which represent the rescaled design weights to use
in multilevel models (use these variables for the <code>weights</code> argument).
</p>


<h3>References</h3>


<ul>
<li><p> Carle A.C. (2009). Fitting multilevel models in complex survey data
with design weights: Recommendations. BMC Medical Research Methodology
9(49): 1-13
</p>
</li>
<li><p> Asparouhov T. (2006). General Multi-Level Modeling with Sampling
Weights. Communications in Statistics - Theory and Methods 35: 439-460
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (require("lme4")) {
  data(nhanes_sample)
  head(rescale_weights(nhanes_sample, "SDMVSTRA", "WTINT2YR"))

  # also works with multiple group-variables
  head(rescale_weights(nhanes_sample, c("SDMVSTRA", "SDMVPSU"), "WTINT2YR"))

  # or nested structures.
  x &lt;- rescale_weights(
    data = nhanes_sample,
    group = c("SDMVSTRA", "SDMVPSU"),
    probability_weights = "WTINT2YR",
    nest = TRUE
  )
  head(x)

  nhanes_sample &lt;- rescale_weights(nhanes_sample, "SDMVSTRA", "WTINT2YR")

  glmer(
    total ~ factor(RIAGENDR) * (log(age) + factor(RIDRETH1)) + (1 | SDMVPSU),
    family = poisson(),
    data = nhanes_sample,
    weights = pweights_a
  )
}
</code></pre>

<hr>
<h2 id='reshape_ci'>Reshape CI between wide/long formats</h2><span id='topic+reshape_ci'></span>

<h3>Description</h3>

<p>Reshape CI between wide/long formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_ci(x, ci_type = "CI")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_ci_+3A_x">x</code></td>
<td>
<p>A data frame containing columns named <code>CI_low</code> and <code>CI_high</code> (or
similar, see <code>ci_type</code>).</p>
</td></tr>
<tr><td><code id="reshape_ci_+3A_ci_type">ci_type</code></td>
<td>
<p>String indicating the &quot;type&quot; (i.e. prefix) of the interval
columns. Per <em>easystats</em> convention, confidence or credible intervals are
named <code>CI_low</code> and <code>CI_high</code>, and the related <code>ci_type</code> would be <code>"CI"</code>.
If column names for other intervals differ, <code>ci_type</code> can be used to
indicate the name, e.g. <code>ci_type = "SI"</code> can be used for support intervals,
where the column names in the data frame would be <code>SI_low</code> and <code>SI_high</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns corresponding to confidence intervals reshaped
either to wide or long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  Parameter = c("Term 1", "Term 2", "Term 1", "Term 2"),
  CI = c(.8, .8, .9, .9),
  CI_low = c(.2, .3, .1, .15),
  CI_high = c(.5, .6, .8, .85),
  stringsAsFactors = FALSE
)

reshape_ci(x)
reshape_ci(reshape_ci(x))
</code></pre>

<hr>
<h2 id='reverse'>Reverse-Score Variables</h2><span id='topic+reverse'></span><span id='topic+reverse_scale'></span><span id='topic+reverse.numeric'></span><span id='topic+reverse.data.frame'></span>

<h3>Description</h3>

<p>Reverse-score variables (change the keying/scoring direction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse(x, ...)

reverse_scale(x, ...)

## S3 method for class 'numeric'
reverse(x, range = NULL, verbose = TRUE, ...)

## S3 method for class 'data.frame'
reverse(
  x,
  select = NULL,
  exclude = NULL,
  range = NULL,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, numeric vector or factor.</p>
</td></tr>
<tr><td><code id="reverse_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="reverse_+3A_range">range</code></td>
<td>
<p>Range of values that is used as reference for reversing the
scale. For numeric variables, can be <code>NULL</code> or a numeric vector of length
two, indicating the lowest and highest value of the reference range. If
<code>NULL</code>, will take the range of the input vector (<code>range(x)</code>). For factors,
<code>range</code> can be <code>NULL</code>, a numeric vector of length two, or a (numeric)
vector of at least the same length as factor levels (i.e. must be equal
to or larger than <code>nlevels(x)</code>). Note that providing a <code>range</code> for factors
usually only makes sense when factor levels are numeric, not characters.</p>
</td></tr>
<tr><td><code id="reverse_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="reverse_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="reverse_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="reverse_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="reverse_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="reverse_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reverse-scored object.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>See Also</h3>

<p>Other transform utilities: 
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+ranktransform">ranktransform</a>()</code>,
<code><a href="#topic+rescale">rescale</a>()</code>,
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reverse(c(1, 2, 3, 4, 5))
reverse(c(-2, -1, 0, 2, 1))

# Specify the "theoretical" range of the input vector
reverse(c(1, 3, 4), range = c(0, 4))

# Factor variables
reverse(factor(c(1, 2, 3, 4, 5)))
reverse(factor(c(1, 2, 3, 4, 5)), range = 0:10)

# Data frames
head(reverse(iris))
head(reverse(iris, select = "Sepal.Length"))

</code></pre>

<hr>
<h2 id='row_means'>Row means (optionally with minimum amount of valid values)</h2><span id='topic+row_means'></span>

<h3>Description</h3>

<p>This function is similar to the SPSS <code>MEAN.n</code> function and computes
row means from a data frame or matrix if at least <code>min_valid</code> values of a row are
valid (and not <code>NA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_means(
  data,
  select = NULL,
  exclude = NULL,
  min_valid = NULL,
  digits = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  remove_na = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_means_+3A_data">data</code></td>
<td>
<p>A data frame with at least two columns, where row means are applied.</p>
</td></tr>
<tr><td><code id="row_means_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="row_means_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="row_means_+3A_min_valid">min_valid</code></td>
<td>
<p>Optional, a numeric value of length 1. May either be
</p>

<ul>
<li><p> a numeric value that indicates the amount of valid values per row to
calculate the row mean;
</p>
</li>
<li><p> or a value between 0 and 1, indicating a proportion of valid values per
row to calculate the row mean (see 'Details').
</p>
</li>
<li> <p><code>NULL</code> (default), in which all cases are considered.
</p>
</li></ul>

<p>If a row's sum of valid values is less than <code>min_valid</code>, <code>NA</code> will be returned.</p>
</td></tr>
<tr><td><code id="row_means_+3A_digits">digits</code></td>
<td>
<p>Numeric value indicating the number of decimal places to be
used for rounding mean values. Negative values are allowed (see 'Details').
By default, <code>digits = NULL</code> and no rounding is used.</p>
</td></tr>
<tr><td><code id="row_means_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="row_means_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="row_means_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), removes missing (<code>NA</code>) values
before calculating row means. Only applies if <code>min_valuid</code> is not specified.</p>
</td></tr>
<tr><td><code id="row_means_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rounding to a negative number of <code>digits</code> means rounding to a power of
ten, for example <code>row_means(df, 3, digits = -2)</code> rounds to the nearest hundred.
For <code>min_valid</code>, if not <code>NULL</code>, <code>min_valid</code> must be a numeric value from <code>0</code>
to <code>ncol(data)</code>. If a row in the data frame has at least <code>min_valid</code>
non-missing values, the row mean is returned. If <code>min_valid</code> is a non-integer
value from 0 to 1, <code>min_valid</code> is considered to indicate the proportion of
required non-missing values per row. E.g., if <code>min_valid = 0.75</code>, a row must
have at least <code>ncol(data) * min_valid</code> non-missing values for the row mean
to be calculated. See 'Examples'.
</p>


<h3>Value</h3>

<p>A vector with row means for those rows with at least <code>n</code> valid values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
  c1 = c(1, 2, NA, 4),
  c2 = c(NA, 2, NA, 5),
  c3 = c(NA, 4, NA, NA),
  c4 = c(2, 3, 7, 8)
)

# default, all means are shown, if no NA values are present
row_means(dat)

# remove all NA before computing row means
row_means(dat, remove_na = TRUE)

# needs at least 4 non-missing values per row
row_means(dat, min_valid = 4) # 1 valid return value

# needs at least 3 non-missing values per row
row_means(dat, min_valid = 3) # 2 valid return values

# needs at least 2 non-missing values per row
row_means(dat, min_valid = 2)

# needs at least 1 non-missing value per row, for two selected variables
row_means(dat, select = c("c1", "c3"), min_valid = 1)

# needs at least 50% of non-missing values per row
row_means(dat, min_valid = 0.5) # 3 valid return values

# needs at least 75% of non-missing values per row
row_means(dat, min_valid = 0.75) # 2 valid return values

</code></pre>

<hr>
<h2 id='row_to_colnames'>Tools for working with column names</h2><span id='topic+row_to_colnames'></span><span id='topic+colnames_to_row'></span>

<h3>Description</h3>

<p>Tools for working with column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_to_colnames(x, row = 1, na_prefix = "x", verbose = TRUE)

colnames_to_row(x, prefix = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_to_colnames_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="row_to_colnames_+3A_row">row</code></td>
<td>
<p>Row to use as column names.</p>
</td></tr>
<tr><td><code id="row_to_colnames_+3A_na_prefix">na_prefix</code></td>
<td>
<p>Prefix to give to the column name if the row has an <code>NA</code>.
Default is 'x', and it will be incremented at each <code>NA</code> (<code>x1</code>, <code>x2</code>, etc.).</p>
</td></tr>
<tr><td><code id="row_to_colnames_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="row_to_colnames_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to give to the column name. Default is 'x', and it will
be incremented at each column (<code>x1</code>, <code>x2</code>, etc.).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>row_to_colnames()</code> and <code>colnames_to_row()</code> both return a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a row to column names --------------------------------
test &lt;- data.frame(
  a = c("iso", 2, 5),
  b = c("year", 3, 6),
  c = c("value", 5, 7)
)
test
row_to_colnames(test)

# Convert column names to row --------------------------------
test &lt;- data.frame(
  ARG = c("BRA", "FRA"),
  `1960` = c(1960, 1960),
  `2000` = c(2000, 2000)
)
test
colnames_to_row(test)

</code></pre>

<hr>
<h2 id='rownames_as_column'>Tools for working with row names or row ids</h2><span id='topic+rownames_as_column'></span><span id='topic+column_as_rownames'></span><span id='topic+rowid_as_column'></span>

<h3>Description</h3>

<p>Tools for working with row names or row ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rownames_as_column(x, var = "rowname")

column_as_rownames(x, var = "rowname")

rowid_as_column(x, var = "rowid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rownames_as_column_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="rownames_as_column_+3A_var">var</code></td>
<td>
<p>Name of column to use for row names/ids. For <code>column_as_rownames()</code>,
this argument can be the variable name or the column number. For
<code>rownames_as_column()</code> and <code>rowid_as_column()</code>, the column name must not
already exist in the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are similar to <code>tibble</code>'s functions <code>column_to_rownames()</code>,
<code>rownames_to_column()</code> and <code>rowid_to_column()</code>. Note that the behavior of
<code>rowid_as_column()</code> is different for grouped dataframe: instead of making
the rowid unique across the full dataframe, it creates rowid per group.
Therefore, there can be several rows with the same rowid if they belong to
different groups.
</p>
<p>If you are familiar with <code>dplyr</code>, this is similar to doing the following:
</p>
<div class="sourceCode r"><pre>data |&gt;
  group_by(grp) |&gt;
  mutate(id = row_number()) |&gt;
  ungroup()
</pre></div>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert between row names and column --------------------------------
test &lt;- rownames_as_column(mtcars, var = "car")
test
head(column_as_rownames(test, var = "car"))

test_data &lt;- head(iris)

rowid_as_column(test_data)
rowid_as_column(test_data, var = "my_id")
</code></pre>

<hr>
<h2 id='skewness'>Compute Skewness and (Excess) Kurtosis</h2><span id='topic+skewness'></span><span id='topic+skewness.numeric'></span><span id='topic+kurtosis'></span><span id='topic+kurtosis.numeric'></span><span id='topic+print.parameters_kurtosis'></span><span id='topic+print.parameters_skewness'></span><span id='topic+summary.parameters_skewness'></span><span id='topic+summary.parameters_kurtosis'></span>

<h3>Description</h3>

<p>Compute Skewness and (Excess) Kurtosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, ...)

## S3 method for class 'numeric'
skewness(
  x,
  remove_na = TRUE,
  type = "2",
  iterations = NULL,
  verbose = TRUE,
  na.rm = TRUE,
  ...
)

kurtosis(x, ...)

## S3 method for class 'numeric'
kurtosis(
  x,
  remove_na = TRUE,
  type = "2",
  iterations = NULL,
  verbose = TRUE,
  na.rm = TRUE,
  ...
)

## S3 method for class 'parameters_kurtosis'
print(x, digits = 3, test = FALSE, ...)

## S3 method for class 'parameters_skewness'
print(x, digits = 3, test = FALSE, ...)

## S3 method for class 'parameters_skewness'
summary(object, test = FALSE, ...)

## S3 method for class 'parameters_kurtosis'
summary(object, test = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewness_+3A_x">x</code></td>
<td>
<p>A numeric vector or data.frame.</p>
</td></tr>
<tr><td><code id="skewness_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="skewness_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical. Should <code>NA</code> values be removed before computing (<code>TRUE</code>)
or not (<code>FALSE</code>, default)?</p>
</td></tr>
<tr><td><code id="skewness_+3A_type">type</code></td>
<td>
<p>Type of algorithm for computing skewness. May be one of <code>1</code>
(or <code>"1"</code>, <code>"I"</code> or <code>"classic"</code>), <code>2</code> (or <code>"2"</code>,
<code>"II"</code> or <code>"SPSS"</code> or <code>"SAS"</code>) or <code>3</code> (or  <code>"3"</code>,
<code>"III"</code> or <code>"Minitab"</code>). See 'Details'.</p>
</td></tr>
<tr><td><code id="skewness_+3A_iterations">iterations</code></td>
<td>
<p>The number of bootstrap replicates for computing standard
errors. If <code>NULL</code> (default), parametric standard errors are computed.</p>
</td></tr>
<tr><td><code id="skewness_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages.</p>
</td></tr>
<tr><td><code id="skewness_+3A_na.rm">na.rm</code></td>
<td>
<p>Deprecated. Please use <code>remove_na</code> instead.</p>
</td></tr>
<tr><td><code id="skewness_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places.</p>
</td></tr>
<tr><td><code id="skewness_+3A_test">test</code></td>
<td>
<p>Logical, if <code>TRUE</code>, tests if skewness or kurtosis is
significantly different from zero.</p>
</td></tr>
<tr><td><code id="skewness_+3A_object">object</code></td>
<td>
<p>An object returned by <code>skewness()</code> or <code>kurtosis()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Skewness</h4>

<p>Symmetric distributions have a <code>skewness</code> around zero, while
a negative skewness values indicates a &quot;left-skewed&quot; distribution, and a
positive skewness values indicates a &quot;right-skewed&quot; distribution. Examples
for the relationship of skewness and distributions are:
</p>

<ul>
<li><p> Normal distribution (and other symmetric distribution) has a skewness
of 0
</p>
</li>
<li><p> Half-normal distribution has a skewness just below 1
</p>
</li>
<li><p> Exponential distribution has a skewness of 2
</p>
</li>
<li><p> Lognormal distribution can have a skewness of any positive value,
depending on its parameters
</p>
</li></ul>

<p>(<cite>https://en.wikipedia.org/wiki/Skewness</cite>)
</p>



<h4>Types of Skewness</h4>

<p><code>skewness()</code> supports three different methods for estimating skewness,
as discussed in <cite>Joanes and Gill (1988)</cite>:
</p>

<ul>
<li><p> Type &quot;1&quot; is the &quot;classical&quot; method, which is <code>g1 = (sum((x - mean(x))^3) / n) / (sum((x - mean(x))^2) / n)^1.5</code>
</p>
</li>
<li><p> Type &quot;2&quot; first calculates the type-1 skewness, then adjusts the result:
<code>G1 = g1 * sqrt(n * (n - 1)) / (n - 2)</code>. This is what SAS and SPSS
usually return.
</p>
</li>
<li><p> Type &quot;3&quot; first calculates the type-1 skewness, then adjusts the result:
<code>b1 = g1 * ((1 - 1 / n))^1.5</code>. This is what Minitab usually returns.
</p>
</li></ul>




<h4>Kurtosis</h4>

<p>The <code>kurtosis</code> is a measure of &quot;tailedness&quot; of a distribution. A
distribution with a kurtosis values of about zero is called &quot;mesokurtic&quot;. A
kurtosis value larger than zero indicates a &quot;leptokurtic&quot; distribution with
<em>fatter</em> tails. A kurtosis value below zero indicates a &quot;platykurtic&quot;
distribution with <em>thinner</em> tails
(<cite>https://en.wikipedia.org/wiki/Kurtosis</cite>).
</p>



<h4>Types of Kurtosis</h4>

<p><code>kurtosis()</code> supports three different methods for estimating kurtosis,
as discussed in <cite>Joanes and Gill (1988)</cite>:
</p>

<ul>
<li><p> Type &quot;1&quot; is the &quot;classical&quot; method, which is <code>g2 = n * sum((x - mean(x))^4) / (sum((x - mean(x))^2)^2) - 3</code>.
</p>
</li>
<li><p> Type &quot;2&quot; first calculates the type-1 kurtosis, then adjusts the result:
<code>G2 = ((n + 1) * g2 + 6) * (n - 1)/((n - 2) * (n - 3))</code>. This is what
SAS and SPSS usually return
</p>
</li>
<li><p> Type &quot;3&quot; first calculates the type-1 kurtosis, then adjusts the result:
<code>b2 = (g2 + 3) * (1 - 1 / n)^2 - 3</code>. This is what Minitab usually
returns.
</p>
</li></ul>




<h4>Standard Errors</h4>

<p>It is recommended to compute empirical (bootstrapped) standard errors (via
the <code>iterations</code> argument) than relying on analytic standard errors
(<cite>Wright &amp; Herrington, 2011</cite>).
</p>



<h3>Value</h3>

<p>Values of skewness or kurtosis.
</p>


<h3>References</h3>


<ul>
<li><p> D. N. Joanes and C. A. Gill (1998). Comparing measures of sample
skewness and kurtosis. The Statistician, 47, 183–189.
</p>
</li>
<li><p> Wright, D. B., &amp; Herrington, J. A. (2011). Problematic standard
errors and confidence intervals for skewness and kurtosis. Behavior
research methods, 43(1), 8-17.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>skewness(rnorm(1000))
kurtosis(rnorm(1000))
</code></pre>

<hr>
<h2 id='slide'>Shift numeric value range</h2><span id='topic+slide'></span><span id='topic+slide.numeric'></span><span id='topic+slide.data.frame'></span>

<h3>Description</h3>

<p>This functions shifts the value range of a numeric variable, so that the
new range starts at a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slide(x, ...)

## S3 method for class 'numeric'
slide(x, lowest = 0, ...)

## S3 method for class 'data.frame'
slide(
  x,
  select = NULL,
  exclude = NULL,
  lowest = 0,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slide_+3A_x">x</code></td>
<td>
<p>A data frame or numeric vector.</p>
</td></tr>
<tr><td><code id="slide_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="slide_+3A_lowest">lowest</code></td>
<td>
<p>Numeric, indicating the lowest (minimum) value when converting
factors or character vectors to numeric values.</p>
</td></tr>
<tr><td><code id="slide_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="slide_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="slide_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="slide_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="slide_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="slide_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, where the range of numeric variables starts at a new value.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># numeric
head(mtcars$gear)
head(slide(mtcars$gear))
head(slide(mtcars$gear, lowest = 10))

# data frame
sapply(slide(mtcars, lowest = 1), min)
sapply(mtcars, min)
</code></pre>

<hr>
<h2 id='smoothness'>Quantify the smoothness of a vector</h2><span id='topic+smoothness'></span>

<h3>Description</h3>

<p>Quantify the smoothness of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothness(x, method = "cor", lag = 1, iterations = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothness_+3A_x">x</code></td>
<td>
<p>Numeric vector (similar to a time series).</p>
</td></tr>
<tr><td><code id="smoothness_+3A_method">method</code></td>
<td>
<p>Can be &quot;diff&quot; (the standard deviation of the standardized
differences) or &quot;cor&quot; (default, lag-one autocorrelation).</p>
</td></tr>
<tr><td><code id="smoothness_+3A_lag">lag</code></td>
<td>
<p>An integer indicating which lag to use. If less than 1, will be
interpreted as expressed in percentage of the length of the vector.</p>
</td></tr>
<tr><td><code id="smoothness_+3A_iterations">iterations</code></td>
<td>
<p>The number of bootstrap replicates for computing standard
errors. If <code>NULL</code> (default), parametric standard errors are computed.</p>
</td></tr>
<tr><td><code id="smoothness_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of smoothness.
</p>


<h3>References</h3>

<p>https://stats.stackexchange.com/questions/24607/how-to-measure-smoothness-of-a-time-series-in-r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (-10:10)^3 + rnorm(21, 0, 100)
plot(x)
smoothness(x, method = "cor")
smoothness(x, method = "diff")
</code></pre>

<hr>
<h2 id='standardize'>Standardization (Z-scoring)</h2><span id='topic+standardize'></span><span id='topic+standardise'></span><span id='topic+standardize.numeric'></span><span id='topic+standardize.factor'></span><span id='topic+standardize.data.frame'></span><span id='topic+unstandardize'></span><span id='topic+unstandardise'></span><span id='topic+unstandardize.numeric'></span><span id='topic+unstandardize.data.frame'></span>

<h3>Description</h3>

<p>Performs a standardization of data (z-scoring), i.e., centering and scaling,
so that the data is expressed in terms of standard deviation (i.e., mean = 0,
SD = 1) or Median Absolute Deviance (median = 0, MAD = 1). When applied to a
statistical model, this function extracts the dataset, standardizes it, and
refits the model with this standardized version of the dataset. The
<code><a href="#topic+normalize">normalize()</a></code> function can also be used to scale all numeric variables within
the 0 - 1 range.
<br /><br />
For model standardization, see <code><a href="#topic+standardize.default">standardize.default()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(x, ...)

standardise(x, ...)

## S3 method for class 'numeric'
standardize(
  x,
  robust = FALSE,
  two_sd = FALSE,
  weights = NULL,
  reference = NULL,
  center = NULL,
  scale = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'factor'
standardize(
  x,
  robust = FALSE,
  two_sd = FALSE,
  weights = NULL,
  force = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
standardize(
  x,
  select = NULL,
  exclude = NULL,
  robust = FALSE,
  two_sd = FALSE,
  weights = NULL,
  reference = NULL,
  center = NULL,
  scale = NULL,
  remove_na = c("none", "selected", "all"),
  force = FALSE,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)

unstandardize(x, ...)

unstandardise(x, ...)

## S3 method for class 'numeric'
unstandardize(
  x,
  center = NULL,
  scale = NULL,
  reference = NULL,
  robust = FALSE,
  two_sd = FALSE,
  ...
)

## S3 method for class 'data.frame'
unstandardize(
  x,
  center = NULL,
  scale = NULL,
  reference = NULL,
  robust = FALSE,
  two_sd = FALSE,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_x">x</code></td>
<td>
<p>A (grouped) data frame, a vector or a statistical model (for
<code>unstandardize()</code> cannot be a model).</p>
</td></tr>
<tr><td><code id="standardize_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="standardize_+3A_robust">robust</code></td>
<td>
<p>Logical, if <code>TRUE</code>, centering is done by subtracting the
median from the variables and dividing it by the median absolute deviation
(MAD). If <code>FALSE</code>, variables are standardized by subtracting the
mean and dividing it by the standard deviation (SD).</p>
</td></tr>
<tr><td><code id="standardize_+3A_two_sd">two_sd</code></td>
<td>
<p>If <code>TRUE</code>, the variables are scaled by two times the deviation
(SD or MAD depending on <code>robust</code>). This method can be useful to obtain
model coefficients of continuous parameters comparable to coefficients
related to binary predictors, when applied to <strong>the predictors</strong> (not the
outcome) (Gelman, 2008).</p>
</td></tr>
<tr><td><code id="standardize_+3A_weights">weights</code></td>
<td>
<p>Can be <code>NULL</code> (for no weighting), or:
</p>

<ul>
<li><p> For model: if <code>TRUE</code> (default), a weighted-standardization is carried out.
</p>
</li>
<li><p> For <code>data.frame</code>s: a numeric vector of weights, or a character of the
name of a column in the <code>data.frame</code> that contains the weights.
</p>
</li>
<li><p> For numeric vectors: a numeric vector of weights.
</p>
</li></ul>
</td></tr>
<tr><td><code id="standardize_+3A_reference">reference</code></td>
<td>
<p>A data frame or variable from which the centrality and
deviation will be computed instead of from the input variable. Useful for
standardizing a subset or new data according to another data frame.</p>
</td></tr>
<tr><td><code id="standardize_+3A_center">center</code>, <code id="standardize_+3A_scale">scale</code></td>
<td>

<ul>
<li><p> For <code>standardize()</code>: <br />
Numeric values, which can be used as alternative to <code>reference</code> to define
a reference centrality and deviation. If <code>scale</code> and <code>center</code> are of
length 1, they will be recycled to match the length of selected variables
for standardization. Else, <code>center</code> and <code>scale</code> must be of same length as
the number of selected variables. Values in <code>center</code> and <code>scale</code> will be
matched to selected variables in the provided order, unless a named vector
is given. In this case, names are matched against the names of the selected
variables.
</p>
</li>
<li><p> For <code>unstandardize()</code>: <br />
<code>center</code> and <code>scale</code> correspond to the center (the mean / median) and the scale (SD / MAD) of
the original non-standardized data (for data frames, should be named, or
have column order correspond to the numeric column). However, one can also
directly provide the original data through <code>reference</code>, from which the
center and the scale will be computed (according to <code>robust</code> and <code>two_sd</code>).
Alternatively, if the input contains the attributes <code>center</code> and <code>scale</code>
(as does the output of <code>standardize()</code>), it will take it from there if the
rest of the arguments are absent.
</p>
</li></ul>
</td></tr>
<tr><td><code id="standardize_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages on or off.</p>
</td></tr>
<tr><td><code id="standardize_+3A_force">force</code></td>
<td>
<p>Logical, if <code>TRUE</code>, forces recoding of factors and character
vectors as well.</p>
</td></tr>
<tr><td><code id="standardize_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="standardize_+3A_remove_na">remove_na</code></td>
<td>
<p>How should missing values (<code>NA</code>) be treated: if <code>"none"</code>
(default): each column's standardization is done separately, ignoring
<code>NA</code>s. Else, rows with <code>NA</code> in the columns selected with <code>select</code> /
<code>exclude</code> (<code>"selected"</code>) or in all columns (<code>"all"</code>) are dropped before
standardization, and the resulting data frame does not include these cases.</p>
</td></tr>
<tr><td><code id="standardize_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, standardized variables get new
column names (with the suffix <code>"_z"</code>) and are appended (column bind) to <code>x</code>,
thus returning both the original and the standardized variables. If <code>FALSE</code>,
original variables in <code>x</code> will be overwritten by their standardized versions.
If a character value, standardized variables are appended with new column
names (using the defined suffix) to the original data frame.</p>
</td></tr>
<tr><td><code id="standardize_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="standardize_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The standardized object (either a standardize data frame or a
statistical model fitted on standardized data).
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Note</h3>

<p>When <code>x</code> is a vector or a data frame with <code style="white-space: pre;">&#8288;remove_na = "none")&#8288;</code>,
missing values are preserved, so the return value has the same length /
number of rows as the original input.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+center">center()</a></code> for grand-mean centering of variables, and
<code><a href="#topic+makepredictcall.dw_transformer">makepredictcall.dw_transformer()</a></code> for use in model formulas.
</p>
<p>Other transform utilities: 
<code><a href="#topic+normalize">normalize</a>()</code>,
<code><a href="#topic+ranktransform">ranktransform</a>()</code>,
<code><a href="#topic+rescale">rescale</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>
<p>Other standardize: 
<code><a href="#topic+standardize.default">standardize.default</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- iris[1:4, ]

# vectors
standardise(d$Petal.Length)

# Data frames
# overwrite
standardise(d, select = c("Sepal.Length", "Sepal.Width"))

# append
standardise(d, select = c("Sepal.Length", "Sepal.Width"), append = TRUE)

# append, suffix
standardise(d, select = c("Sepal.Length", "Sepal.Width"), append = "_std")

# standardizing with reference center and scale
d &lt;- data.frame(
  a = c(-2, -1, 0, 1, 2),
  b = c(3, 4, 5, 6, 7)
)

# default standardization, based on mean and sd of each variable
standardize(d) # means are 0 and 5, sd ~ 1.581139

# standardization, based on mean and sd set to the same values
standardize(d, center = c(0, 5), scale = c(1.581, 1.581))

# standardization, mean and sd for each variable newly defined
standardize(d, center = c(3, 4), scale = c(2, 4))

# standardization, taking same mean and sd for each variable
standardize(d, center = 1, scale = 3)
</code></pre>

<hr>
<h2 id='standardize.default'>Re-fit a model with standardized data</h2><span id='topic+standardize.default'></span><span id='topic+standardize_models'></span>

<h3>Description</h3>

<p>Performs a standardization of data (z-scoring) using
<code><a href="#topic+standardize">standardize()</a></code> and then re-fits the model to the standardized data.
<br /><br />
Standardization is done by completely refitting the model on the standardized
data. Hence, this approach is equal to standardizing the variables <em>before</em>
fitting the model and will return a new model object. This method is
particularly recommended for complex models that include interactions or
transformations (e.g., polynomial or spline terms). The <code>robust</code> (default to
<code>FALSE</code>) argument enables a robust standardization of data, based on the
<code>median</code> and the <code>MAD</code> instead of the <code>mean</code> and the <code>SD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
standardize(
  x,
  robust = FALSE,
  two_sd = FALSE,
  weights = TRUE,
  verbose = TRUE,
  include_response = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize.default_+3A_x">x</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="standardize.default_+3A_robust">robust</code></td>
<td>
<p>Logical, if <code>TRUE</code>, centering is done by subtracting the
median from the variables and dividing it by the median absolute deviation
(MAD). If <code>FALSE</code>, variables are standardized by subtracting the
mean and dividing it by the standard deviation (SD).</p>
</td></tr>
<tr><td><code id="standardize.default_+3A_two_sd">two_sd</code></td>
<td>
<p>If <code>TRUE</code>, the variables are scaled by two times the deviation
(SD or MAD depending on <code>robust</code>). This method can be useful to obtain
model coefficients of continuous parameters comparable to coefficients
related to binary predictors, when applied to <strong>the predictors</strong> (not the
outcome) (Gelman, 2008).</p>
</td></tr>
<tr><td><code id="standardize.default_+3A_weights">weights</code></td>
<td>
<p>If <code>TRUE</code> (default), a weighted-standardization is carried out.</p>
</td></tr>
<tr><td><code id="standardize.default_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings and messages on or off.</p>
</td></tr>
<tr><td><code id="standardize.default_+3A_include_response">include_response</code></td>
<td>
<p>If <code>TRUE</code> (default), the response value will also be
standardized. If <code>FALSE</code>, only the predictors will be standardized.
</p>

<ul>
<li><p> Note that for GLMs and models with non-linear link functions, the
response value will not be standardized, to make re-fitting the model work.
</p>
</li>
<li><p> If the model contains an <code><a href="stats.html#topic+offset">stats::offset()</a></code>, the offset variable(s) will
be standardized only if the response is standardized. If <code>two_sd = TRUE</code>,
offsets are standardized by one-sd (similar to the response).
</p>
</li>
<li><p> (For <code>mediate</code> models, the <code>include_response</code> refers to the outcome in
the y model; m model's response will always be standardized when possible).
</p>
</li></ul>
</td></tr>
<tr><td><code id="standardize.default_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A statistical model fitted on standardized data
</p>


<h3>Generalized Linear Models</h3>

<p>Standardization for generalized linear models (GLM, GLMM, etc) is done only
with respect to the predictors (while the outcome remains as-is,
unstandardized) - maintaining the interpretability of the coefficients (e.g.,
in a binomial model: the exponent of the standardized parameter is the OR of
a change of 1 SD in the predictor, etc.)
</p>


<h3>Dealing with Factors</h3>

<p><code>standardize(model)</code> or <code>standardize_parameters(model, method = "refit")</code> do
<em>not</em> standardize categorical predictors (i.e. factors) / their
dummy-variables, which may be a different behaviour compared to other R
packages (such as <strong>lm.beta</strong>) or other software packages (like SPSS). To
mimic such behaviours, either use <code>standardize_parameters(model, method = "basic")</code> to obtain post-hoc standardized parameters, or standardize the data
with <code>standardize(data, force = TRUE)</code> <em>before</em> fitting the
model.
</p>


<h3>Transformed Variables</h3>

<p>When the model's formula contains transformations (e.g. <code>y ~ exp(X)</code>) the
transformation effectively takes place after standardization (e.g.,
<code>exp(scale(X))</code>). Since some transformations are undefined for none positive
values, such as <code>log()</code> and <code>sqrt()</code>, the relevel variables are shifted (post
standardization) by <code>Z - min(Z) + 1</code> or <code>Z - min(Z)</code> (respectively).
</p>


<h3>See Also</h3>

<p>Other standardize: 
<code><a href="#topic+standardize">standardize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(Infant.Mortality ~ Education * Fertility, data = swiss)
coef(standardize(model))

</code></pre>

<hr>
<h2 id='text_format'>Convenient text formatting functionalities</h2><span id='topic+text_format'></span><span id='topic+format_text'></span><span id='topic+text_fullstop'></span><span id='topic+text_lastchar'></span><span id='topic+text_concatenate'></span><span id='topic+text_paste'></span><span id='topic+text_remove'></span><span id='topic+text_wrap'></span>

<h3>Description</h3>

<p>Convenience functions to manipulate and format text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_format(
  text,
  sep = ", ",
  last = " and ",
  width = NULL,
  enclose = NULL,
  ...
)

format_text(
  text,
  sep = ", ",
  last = " and ",
  width = NULL,
  enclose = NULL,
  ...
)

text_fullstop(text)

text_lastchar(text, n = 1)

text_concatenate(text, sep = ", ", last = " and ", enclose = NULL)

text_paste(text, text2 = NULL, sep = ", ", enclose = NULL, ...)

text_remove(text, pattern = "", ...)

text_wrap(text, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_format_+3A_text">text</code>, <code id="text_format_+3A_text2">text2</code></td>
<td>
<p>A character string.</p>
</td></tr>
<tr><td><code id="text_format_+3A_sep">sep</code></td>
<td>
<p>Separator.</p>
</td></tr>
<tr><td><code id="text_format_+3A_last">last</code></td>
<td>
<p>Last separator.</p>
</td></tr>
<tr><td><code id="text_format_+3A_width">width</code></td>
<td>
<p>Positive integer giving the target column width for wrapping
lines in the output. Can be &quot;auto&quot;, in which case it will select 90\
default width.</p>
</td></tr>
<tr><td><code id="text_format_+3A_enclose">enclose</code></td>
<td>
<p>Character that will be used to wrap elements of <code>text</code>, so
these can be, e.g., enclosed with quotes or backticks. If <code>NULL</code> (default),
text elements will not be enclosed.</p>
</td></tr>
<tr><td><code id="text_format_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to or from other functions.</p>
</td></tr>
<tr><td><code id="text_format_+3A_n">n</code></td>
<td>
<p>The number of characters to find.</p>
</td></tr>
<tr><td><code id="text_format_+3A_pattern">pattern</code></td>
<td>
<p>Character vector. For <code>data_rename()</code>, indicates columns that
should be selected for renaming. Can be <code>NULL</code> (in which case all columns
are selected). For <code>data_addprefix()</code> or <code>data_addsuffix()</code>, a character
string, which will be added as prefix or suffix to the column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add full stop if missing
text_fullstop(c("something", "something else."))

# Find last characters
text_lastchar(c("ABC", "DEF"), n = 2)

# Smart concatenation
text_concatenate(c("First", "Second", "Last"))
text_concatenate(c("First", "Second", "Last"), last = " or ", enclose = "`")

# Remove parts of string
text_remove(c("one!", "two", "three!"), "!")

# Wrap text
long_text &lt;- paste(rep("abc ", 100), collapse = "")
cat(text_wrap(long_text, width = 50))

# Paste with optional separator
text_paste(c("A", "", "B"), c("42", "42", "42"))
</code></pre>

<hr>
<h2 id='to_factor'>Convert data to factors</h2><span id='topic+to_factor'></span><span id='topic+to_factor.numeric'></span><span id='topic+to_factor.data.frame'></span>

<h3>Description</h3>

<p>Convert data to factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_factor(x, ...)

## S3 method for class 'numeric'
to_factor(x, labels_to_levels = TRUE, verbose = TRUE, ...)

## S3 method for class 'data.frame'
to_factor(
  x,
  select = NULL,
  exclude = NULL,
  ignore_case = FALSE,
  append = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_factor_+3A_x">x</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_labels_to_levels">labels_to_levels</code></td>
<td>
<p>Logical, if <code>TRUE</code>, value labels are used as factor
levels after <code>x</code> was converted to factor. Else, factor levels are based on
the values of <code>x</code> (i.e. as if using <code>as.factor()</code>).</p>
</td></tr>
<tr><td><code id="to_factor_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert variables or data into factors. If the data is labelled, value labels
will be used as factor levels. The counterpart to convert variables into
numeric is <code>to_numeric()</code>.
</p>


<h3>Value</h3>

<p>A factor, or a data frame of factors.
</p>


<h3>Selection of variables - the <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument (including this function),
the complete input data frame is returned, even when <code>select</code> only selects
a range of variables. That is, the function is only applied to those variables
that have a match in <code>select</code>, while all other variables remain unchanged.
In other words: for this function, <code>select</code> will not omit any non-included
variables, so that the returned data frame will include all variables
from the input data frame.
</p>


<h3>Note</h3>

<p>Factors are ignored and returned as is. If you want to use value labels
as levels for factors, use <code><a href="#topic+labels_to_levels">labels_to_levels()</a></code> instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(to_factor(iris))

# use labels as levels
data(efc)
str(efc$c172code)
head(to_factor(efc$c172code))
</code></pre>

<hr>
<h2 id='to_numeric'>Convert data to numeric</h2><span id='topic+to_numeric'></span><span id='topic+to_numeric.data.frame'></span>

<h3>Description</h3>

<p>Convert data to numeric by converting characters to factors and factors to
either numeric levels or dummy variables. The &quot;counterpart&quot; to convert
variables into factors is <code>to_factor()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_numeric(x, ...)

## S3 method for class 'data.frame'
to_numeric(
  x,
  select = NULL,
  exclude = NULL,
  dummy_factors = TRUE,
  preserve_levels = FALSE,
  lowest = NULL,
  append = FALSE,
  ignore_case = FALSE,
  regex = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_numeric_+3A_x">x</code></td>
<td>
<p>A data frame, factor or vector.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_select">select</code></td>
<td>
<p>Variables that will be included when performing the required
tasks. Can be either
</p>

<ul>
<li><p> a variable specified as a literal variable name (e.g., <code>column_name</code>),
</p>
</li>
<li><p> a string with the variable name (e.g., <code>"column_name"</code>), or a character
vector of variable names (e.g., <code>c("col1", "col2", "col3")</code>),
</p>
</li>
<li><p> a formula with variable names (e.g., <code>~column_1 + column_2</code>),
</p>
</li>
<li><p> a vector of positive integers, giving the positions counting from the left
(e.g. <code>1</code> or <code>c(1, 3, 5)</code>),
</p>
</li>
<li><p> a vector of negative integers, giving the positions counting from the
right (e.g., <code>-1</code> or <code>-1:-3</code>),
</p>
</li>
<li><p> one of the following select-helpers: <code>starts_with()</code>, <code>ends_with()</code>,
<code>contains()</code>, a range using <code>:</code> or <code>regex("")</code>. <code>starts_with()</code>,
<code>ends_with()</code>, and  <code>contains()</code> accept several patterns, e.g
<code>starts_with("Sep", "Petal")</code>.
</p>
</li>
<li><p> or a function testing for logical conditions, e.g. <code>is.numeric()</code> (or
<code>is.numeric</code>), or any user-defined function that selects the variables
for which the function returns <code>TRUE</code> (like: <code>foo &lt;- function(x) mean(x) &gt; 3</code>),
</p>
</li>
<li><p> ranges specified via literal variable names, select-helpers (except
<code>regex()</code>) and (user-defined) functions can be negated, i.e. return
non-matching elements, when prefixed with a <code>-</code>, e.g. <code>-ends_with("")</code>,
<code>-is.numeric</code> or <code>-(Sepal.Width:Petal.Length)</code>. <strong>Note:</strong> Negation means
that matches are <em>excluded</em>, and thus, the <code>exclude</code> argument can be
used alternatively. For instance, <code>select=-ends_with("Length")</code> (with
<code>-</code>) is equivalent to <code>exclude=ends_with("Length")</code> (no <code>-</code>). In case
negation should not work as expected, use the <code>exclude</code> argument instead.
</p>
</li></ul>

<p>If <code>NULL</code>, selects all columns. Patterns that found no matches are silently
ignored, e.g. <code>find_columns(iris, select = c("Species", "Test"))</code> will just
return <code>"Species"</code>.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_exclude">exclude</code></td>
<td>
<p>See <code>select</code>, however, column names matched by the pattern
from <code>exclude</code> will be excluded instead of selected. If <code>NULL</code> (the default),
excludes no columns.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_dummy_factors">dummy_factors</code></td>
<td>
<p>Transform factors to dummy factors (all factor levels as
different columns filled with a binary 0-1 value).</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_preserve_levels">preserve_levels</code></td>
<td>
<p>Logical, only applies if <code>x</code> is a factor. If <code>TRUE</code>,
and <code>x</code> has numeric factor levels, these will be converted into the related
numeric values. If this is not possible, the converted numeric values will
start from 1 to number of levels.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_lowest">lowest</code></td>
<td>
<p>Numeric, indicating the lowest (minimum) value when converting
factors or character vectors to numeric values.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_append">append</code></td>
<td>
<p>Logical or string. If <code>TRUE</code>, recoded or converted variables
get new column names and are appended (column bind) to <code>x</code>, thus returning
both the original and the recoded variables. The new columns get a suffix,
based on the calling function: <code>"_r"</code> for recode functions, <code>"_n"</code> for
<code>to_numeric()</code>, <code>"_f"</code> for <code>to_factor()</code>, or <code>"_s"</code> for
<code>slide()</code>. If <code>append=FALSE</code>, original variables in <code>x</code> will be
overwritten by their recoded versions. If a character value, recoded
variables are appended with new column names (using the defined suffix) to
the original data frame.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Logical, if <code>TRUE</code> and when one of the select-helpers or
a regular expression is used in <code>select</code>, ignores lower/upper case in the
search pattern when matching against variable names.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_regex">regex</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the search pattern from <code>select</code> will be
treated as regular expression. When <code>regex = TRUE</code>, select <em>must</em> be a
character string (or a variable containing a character string) and is not
allowed to be one of the supported select-helpers or a character vector
of length &gt; 1. <code>regex = TRUE</code> is comparable to using one of the two
select-helpers, <code>select = contains("")</code> or <code>select = regex("")</code>, however,
since the select-helpers may not work when called from inside other
functions (see 'Details'), this argument may be used as workaround.</p>
</td></tr>
<tr><td><code id="to_numeric_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of numeric variables.
</p>


<h3>Selection of variables - <code>select</code> argument</h3>

<p>For most functions that have a <code>select</code> argument the complete input data
frame is returned, even when <code>select</code> only selects a range of variables.
However, for <code>to_numeric()</code>, factors might be converted into dummies,
thus, the number of variables of the returned data frame no longer match
the input data frame. Hence, when <code>select</code> is used, <em>only</em> those variables
(or their dummies) specified in <code>select</code> will be returned. Use <code>append=TRUE</code>
to also include the original variables in the returned data frame.
</p>


<h3>Note</h3>

<p>By default, <code>to_numeric()</code> converts factors into &quot;binary&quot; dummies, i.e.
each factor level is converted into a separate column filled with a binary
0-1 value. If only one column is required, use <code>dummy_factors = FALSE</code>. If
you want to preserve the original factor levels (in case these represent
numeric values), use <code>preserve_levels = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to_numeric(head(ToothGrowth))
to_numeric(head(ToothGrowth), dummy_factors = FALSE)

# factors
x &lt;- as.factor(mtcars$gear)
to_numeric(x, dummy_factors = FALSE)
to_numeric(x, dummy_factors = FALSE, preserve_levels = TRUE)
# same as:
coerce_to_numeric(x)

</code></pre>

<hr>
<h2 id='visualisation_recipe'>Prepare objects for visualisation</h2><span id='topic+visualisation_recipe'></span>

<h3>Description</h3>

<p>This function prepares objects for visualisation by returning a list of
layers with data and geoms that can be easily plotted using for instance
<code>ggplot2</code>.
</p>
<p>If the <code>see</code> package is installed, the call to <code>visualization_recipe()</code> can be
replaced by <code>plot()</code>, which will internally call the former and then plot it
using <code>ggplot</code>. The resulting plot can be customized ad-hoc (by adding
ggplot's geoms, theme or specifications), or via some of the arguments
of <code>visualisation_recipe()</code> that control the aesthetic parameters.
</p>
<p>See the specific documentation page for your object's class:
</p>

<ul>
<li> <p>modelbased: <a href="https://easystats.github.io/modelbased/reference/visualisation_recipe.estimate_predicted.html">https://easystats.github.io/modelbased/reference/visualisation_recipe.estimate_predicted.html</a>
</p>
</li>
<li> <p>correlation: <a href="https://easystats.github.io/correlation/reference/visualisation_recipe.easycormatrix.html">https://easystats.github.io/correlation/reference/visualisation_recipe.easycormatrix.html</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>visualisation_recipe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualisation_recipe_+3A_x">x</code></td>
<td>
<p>An <code>easystats</code> object.</p>
</td></tr>
<tr><td><code id="visualisation_recipe_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other functions.</p>
</td></tr>
</table>

<hr>
<h2 id='weighted_mean'>Weighted Mean, Median, SD, and MAD</h2><span id='topic+weighted_mean'></span><span id='topic+weighted_median'></span><span id='topic+weighted_sd'></span><span id='topic+weighted_mad'></span>

<h3>Description</h3>

<p>Weighted Mean, Median, SD, and MAD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)

weighted_median(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)

weighted_sd(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)

weighted_mad(
  x,
  weights = NULL,
  constant = 1.4826,
  remove_na = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_+3A_x">x</code></td>
<td>
<p>an object containing the values whose weighted mean is to be
computed.</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_weights">weights</code></td>
<td>
<p>A numerical vector of weights the same length as <code>x</code> giving
the weights to use for elements of <code>x</code>. If <code>weights = NULL</code>, <code>x</code> is passed
to the non-weighted function.</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_remove_na">remove_na</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), removes missing (<code>NA</code>) and infinite
values from <code>x</code> and <code>weights</code>.</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_verbose">verbose</code></td>
<td>
<p>Show warning when <code>weights</code> are negative?</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_constant">constant</code></td>
<td>
<p>scale factor.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## GPA from Siegel 1994
x &lt;- c(3.7, 3.3, 3.5, 2.8)
wt &lt;- c(5, 5, 4, 1) / 15

weighted_mean(x, wt)
weighted_median(x, wt)

weighted_sd(x, wt)
weighted_mad(x, wt)

</code></pre>

<hr>
<h2 id='winsorize'>Winsorize data</h2><span id='topic+winsorize'></span><span id='topic+winsorize.numeric'></span>

<h3>Description</h3>

<p>Winsorize data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorize(data, ...)

## S3 method for class 'numeric'
winsorize(
  data,
  threshold = 0.2,
  method = "percentile",
  robust = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsorize_+3A_data">data</code></td>
<td>
<p>data frame or vector.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_threshold">threshold</code></td>
<td>
<p>The amount of winsorization, depends on the value of <code>method</code>:
</p>

<ul>
<li><p> For <code>method = "percentile"</code>: the amount to winsorize from <em>each</em> tail.
The value of <code>threshold</code> must be between 0 and 0.5 and of length 1.
</p>
</li>
<li><p> For <code>method = "zscore"</code>: the number of <em>SD</em>/<em>MAD</em>-deviations from the
<em>mean</em>/<em>median</em> (see <code>robust</code>). The value of <code>threshold</code> must be greater
than 0 and of length 1.
</p>
</li>
<li><p> For <code>method = "raw"</code>: a vector of length 2 with the lower and upper bound
for winsorization.
</p>
</li></ul>
</td></tr>
<tr><td><code id="winsorize_+3A_method">method</code></td>
<td>
<p>One of &quot;percentile&quot; (default), &quot;zscore&quot;, or &quot;raw&quot;.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_robust">robust</code></td>
<td>
<p>Logical, if TRUE, winsorizing through the &quot;zscore&quot; method is
done via the median and the median absolute deviation (MAD); if FALSE, via
the mean and the standard deviation.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_verbose">verbose</code></td>
<td>
<p>Not used anymore since <code>datawizard</code> 0.6.6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Winsorizing or winsorization is the transformation of statistics by limiting
extreme values in the statistical data to reduce the effect of possibly
spurious outliers. The distribution of many statistics can be heavily
influenced by outliers. A typical strategy is to set all outliers (values
beyond a certain threshold) to a specified percentile of the data; for
example, a <code style="white-space: pre;">&#8288;90%&#8288;</code> winsorization would see all data below the 5th percentile set
to the 5th percentile, and data above the 95th percentile set to the 95th
percentile. Winsorized estimators are usually more robust to outliers than
their more standard forms.
</p>


<h3>Value</h3>

<p>A data frame with winsorized columns or a winsorized vector.
</p>


<h3>See Also</h3>


<ul>
<li><p> Functions to rename stuff: <code><a href="#topic+data_rename">data_rename()</a></code>, <code><a href="#topic+data_rename_rows">data_rename_rows()</a></code>, <code><a href="#topic+data_addprefix">data_addprefix()</a></code>, <code><a href="#topic+data_addsuffix">data_addsuffix()</a></code>
</p>
</li>
<li><p> Functions to reorder or remove columns: <code><a href="#topic+data_reorder">data_reorder()</a></code>, <code><a href="#topic+data_relocate">data_relocate()</a></code>, <code><a href="#topic+data_remove">data_remove()</a></code>
</p>
</li>
<li><p> Functions to reshape, pivot or rotate data frames: <code><a href="#topic+data_to_long">data_to_long()</a></code>, <code><a href="#topic+data_to_wide">data_to_wide()</a></code>, <code><a href="#topic+data_rotate">data_rotate()</a></code>
</p>
</li>
<li><p> Functions to recode data: <code><a href="#topic+rescale">rescale()</a></code>, <code><a href="#topic+reverse">reverse()</a></code>, <code><a href="#topic+categorize">categorize()</a></code>, <code><a href="#topic+recode_values">recode_values()</a></code>, <code><a href="#topic+slide">slide()</a></code>
</p>
</li>
<li><p> Functions to standardize, normalize, rank-transform: <code><a href="#topic+center">center()</a></code>, <code><a href="#topic+standardize">standardize()</a></code>, <code><a href="#topic+normalize">normalize()</a></code>, <code><a href="#topic+ranktransform">ranktransform()</a></code>, <code><a href="#topic+winsorize">winsorize()</a></code>
</p>
</li>
<li><p> Split and merge data frames: <code><a href="#topic+data_partition">data_partition()</a></code>, <code><a href="#topic+data_merge">data_merge()</a></code>
</p>
</li>
<li><p> Functions to find or select columns: <code><a href="#topic+data_select">data_select()</a></code>, <code><a href="#topic+data_find">data_find()</a></code>
</p>
</li>
<li><p> Functions to filter rows: <code><a href="#topic+data_match">data_match()</a></code>, <code><a href="#topic+data_filter">data_filter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>hist(iris$Sepal.Length, main = "Original data")

hist(winsorize(iris$Sepal.Length, threshold = 0.2),
  xlim = c(4, 8), main = "Percentile Winsorization"
)

hist(winsorize(iris$Sepal.Length, threshold = 1.5, method = "zscore"),
  xlim = c(4, 8), main = "Mean (+/- SD) Winsorization"
)

hist(winsorize(iris$Sepal.Length, threshold = 1.5, method = "zscore", robust = TRUE),
  xlim = c(4, 8), main = "Median (+/- MAD) Winsorization"
)

hist(winsorize(iris$Sepal.Length, threshold = c(5, 7.5), method = "raw"),
  xlim = c(4, 8), main = "Raw Thresholds"
)

# Also works on a data frame:
winsorize(iris, threshold = 0.2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
