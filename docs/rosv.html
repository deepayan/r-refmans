<!DOCTYPE html><html><head><title>Help for package rosv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rosv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rosv-package'><p>rosv: Client to Access and Operate on the 'Open Source Vulnerability' API</p></a></li>
<li><a href='#check_ecosystem'><p>Check input against possible ecosystems available</p></a></li>
<li><a href='#clear_osv_cache'><p>Reset cached results of OSV calls</p></a></li>
<li><a href='#copy_rosv'><p>Copy a {rosv} object</p></a></li>
<li><a href='#create_osv_list'><p>List packages identified in the OSV database</p></a></li>
<li><a href='#create_ppm_blacklist'><p>Create blacklist commands for Posit Package Manager</p></a></li>
<li><a href='#create_xref_whitelist'><p>Cross reference a whitelist of packages to a vulnerability database</p></a></li>
<li><a href='#fetch_ecosystems'><p>Fetch all available ecosystems</p></a></li>
<li><a href='#get_content'><p>Retrieve contents field from {rosv} R6 object</p></a></li>
<li><a href='#is_pkg_vulnerable'><p>Detect if package within ecosystem has reported vulnerabilities</p></a></li>
<li><a href='#is_rosv'><p>Is object made from {rosv} R6 class</p></a></li>
<li><a href='#normalize_pypi_pkg'><p>Normalize package name to PyPI expectation</p></a></li>
<li><a href='#osv_count_vulns'><p>Count the number of reported vulnerabilities</p></a></li>
<li><a href='#osv_download'><p>Download vulnerabilities from the OSV database</p></a></li>
<li><a href='#osv_query'><p>Query OSV API for individual package vulnerabilities</p></a></li>
<li><a href='#osv_query_1'><p>Query OSV API for vulnerabilities based upon an individual package</p></a></li>
<li><a href='#osv_querybatch'><p>Query OSV API for vulnerabilities given a vector of packages</p></a></li>
<li><a href='#osv_scan'><p>Use OSV database to scan for vulnerabilities</p></a></li>
<li><a href='#osv_vulns'><p>Query OSV API for vulnerability information based on ID</p></a></li>
<li><a href='#RosvDownload'><p>R6 Class for OSV Database Downloads</p></a></li>
<li><a href='#RosvQuery1'><p>R6 Class for OSV Query Endpoint</p></a></li>
<li><a href='#RosvQueryBatch'><p>R6 Class for OSV Querybatch Endpoint</p></a></li>
<li><a href='#RosvVulns'><p>R6 Class for OSV Vulns Endpoint</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Client to Access and Operate on the 'Open Source Vulnerability'
API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Connect, query, and operate on information available from the 
    'Open Source Vulnerability' database <a href="https://osv.dev/">https://osv.dev/</a>. Although 'CRAN' 
    has vulnerabilities listed, these are few compared to projects such as 
    'PyPI'. With tighter integration between 'R' and 'Python', having an 
    'R' specific package to access details about vulnerabilities from 
    various sources is a worthwhile enterprise.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httptest2 (&ge; 1.0.0), knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest (&ge; 0.6.0), furrr (&ge; 0.3.0), httr2 (&ge; 1.0.0),
jsonlite (&ge; 0.9.16), memoise (&ge; 2.0.0), purrr (&ge; 1.0.0), R6
(&ge; 2.0.0), utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://al-obrien.github.io/rosv/">https://al-obrien.github.io/rosv/</a>,
<a href="https://github.com/al-obrien/rosv">https://github.com/al-obrien/rosv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/al-obrien/rosv/issues">https://github.com/al-obrien/rosv/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 17:24:26 UTC; allen</td>
</tr>
<tr>
<td>Author:</td>
<td>Allen OBrien [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Allen OBrien &lt;allen.g.obrien@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rosv-package'>rosv: Client to Access and Operate on the 'Open Source Vulnerability' API</h2><span id='topic+rosv'></span><span id='topic+rosv-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Connect, query, and operate on information available from the 'Open Source Vulnerability' database <a href="https://osv.dev/">https://osv.dev/</a>. Although 'CRAN' has vulnerabilities listed, these are few compared to projects such as 'PyPI'. With tighter integration between 'R' and 'Python', having an 'R' specific package to access details about vulnerabilities from various sources is a worthwhile enterprise.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Allen OBrien <a href="mailto:allen.g.obrien@gmail.com">allen.g.obrien@gmail.com</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://al-obrien.github.io/rosv/">https://al-obrien.github.io/rosv/</a>
</p>
</li>
<li> <p><a href="https://github.com/al-obrien/rosv">https://github.com/al-obrien/rosv</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/al-obrien/rosv/issues">https://github.com/al-obrien/rosv/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_ecosystem'>Check input against possible ecosystems available</h2><span id='topic+check_ecosystem'></span>

<h3>Description</h3>

<p>Internal function that ensures inputs for ecosystem are valid based upon what
is available in the OSV database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ecosystem(ecosystem, suppressMessages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ecosystem_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Character value for ecosystem(s) to check.</p>
</td></tr>
<tr><td><code id="check_ecosystem_+3A_suppressmessages">suppressMessages</code></td>
<td>
<p>Boolean value whether or not to suppress any messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will attempt to grab latest file and cache for the current R session. If session
cannot access the online version, it will use a local copy shipped with the package.
</p>


<h3>Value</h3>

<p>A character vector, the same as input if all are valid ecosystem names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fetch_ecosystems">fetch_ecosystems</a></code>
</p>

<hr>
<h2 id='clear_osv_cache'>Reset cached results of OSV calls</h2><span id='topic+clear_osv_cache'></span>

<h3>Description</h3>

<p>A thin wrapper around <code><a href="memoise.html#topic+forget">forget</a></code> to clear cached results and
deletes all cached files under the <code>ROSV_CACHE_GLOBAL</code> environment variable location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_osv_cache()
</code></pre>


<h3>Value</h3>

<p>Invisibly returns a logical value of <code>TRUE</code> if cache cleared without error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clear_osv_cache()
</code></pre>

<hr>
<h2 id='copy_rosv'>Copy a {rosv} object</h2><span id='topic+copy_rosv'></span>

<h3>Description</h3>

<p>Create a copy of {rosv} R6 class objects to ensure original is not also updated with
future changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_rosv(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_rosv_+3A_x">x</code></td>
<td>
<p>Object to copy.</p>
</td></tr>
<tr><td><code id="copy_rosv_+3A_...">...</code></td>
<td>
<p>Additional parameters sent to R6's clone method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since R6 classes have reference semantics, to escape updating original objects
a clone can be made with this function.
</p>


<h3>Value</h3>

<p>An R6 class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>original_obj &lt;- RosvQuery1$new(name = 'readxl', ecosystem = 'CRAN')
new_obj &lt;- copy_rosv(original_obj)
</code></pre>

<hr>
<h2 id='create_osv_list'>List packages identified in the OSV database</h2><span id='topic+create_osv_list'></span>

<h3>Description</h3>

<p>Create a list of package names and versions based upon vulnerabilities discovered in the OSV database
using <code><a href="#topic+osv_query">osv_query</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_osv_list(
  rosv_query = NULL,
  as.data.frame = TRUE,
  sort = TRUE,
  delim = "\t",
  NA_value = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_osv_list_+3A_rosv_query">rosv_query</code></td>
<td>
<p>A table of vulnerabilities (created via <code>osv_query()</code>).</p>
</td></tr>
<tr><td><code id="create_osv_list_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>Boolean value to determine if a data.frame should be returned.</p>
</td></tr>
<tr><td><code id="create_osv_list_+3A_sort">sort</code></td>
<td>
<p>Boolean value to determine if results should be sorted by name and version.</p>
</td></tr>
<tr><td><code id="create_osv_list_+3A_delim">delim</code></td>
<td>
<p>The deliminator to separate the package and version details (ignored if <code>as.data.frame</code> set to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="create_osv_list_+3A_na_value">NA_value</code></td>
<td>
<p>Character value to replace missing versions (typically means all versions impacted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires an object of type <code>rosv_query</code> created by <code><a href="#topic+osv_query">osv_query</a></code>. This can be
a selection of packages or all vulnerabilities for an ecosystem. Depending on use-case, users may
prefer the vector based output with pairs of package names and versions separated by a provided value.
Since only name and versions are returned, only one ecosystem can be operated on at a time.
</p>
<p>Please note, the default behaviour of <code>osv_query()</code> is to return all packages (and versions) across ecosystems
associated with discovered vulnerabilities. If a package is discovered across several vulnerabilities it will
be listed multiple times, by default, in the returned content. Unlike <code>osv_query()</code>, <code>create_osv_list()</code> will
further sort and return a unique set of packages. In most circumstances, users will create the
<code>rosv_query</code> (via <code>osv_query()</code>) with the <code>all_affected</code> parameter set to <code>FALSE</code>
so that only the package names of interest are returned.
</p>


<h3>Value</h3>

<p>A <code>data.frame()</code> or vector object containing the package and version details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+osv_query">osv_query</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# List of a few PyPI packages in data.frame output
pypi_query &lt;- osv_query(c('dask', 'dash', 'aaiohttp'),
                        ecosystem = rep('PyPI', 3),
                        all_affected = FALSE)
pypi_vul &lt;- create_osv_list(pypi_query)
file_name1 &lt;- file.path(tempdir(), 'pypi_vul.csv')
writeLines(pypi_vul, file_name1)

# All CRAN vulns in vector output
cran_query &lt;- osv_query(ecosystem = 'CRAN', all_affected = FALSE)
cran_vul &lt;- create_osv_list(cran_query, as.data.frame = FALSE, delim = ',')
file_name2 &lt;- file.path(tempdir(), 'cran_vul.csv')
writeLines(cran_vul, file_name2)

# Clean up
try(unlink(c(file_name1, file_name2)))

</code></pre>

<hr>
<h2 id='create_ppm_blacklist'>Create blacklist commands for Posit Package Manager</h2><span id='topic+create_ppm_blacklist'></span>

<h3>Description</h3>

<p>Use OSV data accessed via <code><a href="#topic+osv_query">osv_query</a></code> to create blacklist (i.e. blocklist)
commands for the Posit Package Manager product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ppm_blacklist(rosv_query, flags = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_ppm_blacklist_+3A_rosv_query">rosv_query</code></td>
<td>
<p>A table of vulnerabilities (created via <code>osv_query()</code>).</p>
</td></tr>
<tr><td><code id="create_ppm_blacklist_+3A_flags">flags</code></td>
<td>
<p>Global flag to append to commands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although OSV has many databases for open source software, this function is
only relevant for CRAN/Bioconductor and PyPI. To ensure the blacklist is applied to the
appropriate target, it is encouraged to specify the name of the source used in your configuration
as an additional flag parameter (see examples). Only one ecosystem can be used at a time to ensure
there is not a mix of packages across ecosystems applied to incompatible sources.
</p>


<h3>Value</h3>

<p>Character vector containing blacklist commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Blacklist all CRAN package versions with a listed vulnerability
cran_vul &lt;- osv_query(ecosystem = 'CRAN', all_affected = FALSE)
cmd_blist &lt;- create_ppm_blacklist(cran_vul, flags = '--source=cran')

</code></pre>

<hr>
<h2 id='create_xref_whitelist'>Cross reference a whitelist of packages to a vulnerability database</h2><span id='topic+create_xref_whitelist'></span>

<h3>Description</h3>

<p>Search for package names for vulnerability information and selectively drop packages
or define specific versions that should not be used in a curated repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_xref_whitelist(packages, ecosystem, output_format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_xref_whitelist_+3A_packages">packages</code></td>
<td>
<p>Character vector of package names.</p>
</td></tr>
<tr><td><code id="create_xref_whitelist_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Character vector of ecosystem(s) within which the package(s) exist.</p>
</td></tr>
<tr><td><code id="create_xref_whitelist_+3A_output_format">output_format</code></td>
<td>
<p>Type of output to create (default is <code>NULL</code> for a <code><a href="base.html#topic+data.frame">data.frame</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that some version suffixes may have compatibility issues. For example, the use of
*-git as a suffix may not be recognized and may need to be dropped. For more details on
PyPI package version naming see <a href="https://peps.python.org/pep-0440/">https://peps.python.org/pep-0440/</a>.
</p>
<p>Due to variations in formatting from the OSV API, not all responses have versions associated and
are not directly compatible with this function.
</p>
<p>Although the default output is a <code><a href="base.html#topic+data.frame">data.frame</a></code>, for PyPI packages a <code>requirements.txt</code> format can be
created that defines which versions should not be allowed based upon the cross-referencing performed. This can be
useful when curating repositories in Posit Package Manager.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or character vector containing cross-referenced packages.
</p>


<h3>See Also</h3>

<p><a href="https://packaging.python.org/en/latest/specifications/name-normalization/">PyPI package normalization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Return xref dataset for CRAN package selection
cran_pkg &lt;- c('readxl', 'dplyr')
cran_xref &lt;- create_xref_whitelist(cran_pkg, ecosystem = 'CRAN')

# Create a requirements.txt with excluded versions
python_pkgs &lt;- c('dask', 'aaiohttp', 'keras')
xref_pkg_list &lt;- create_xref_whitelist(python_pkgs,
                                       ecosystem = 'PyPI',
                                       output_format = 'requirements.txt')
file_name &lt;- file.path(tempdir(), 'requirements.txt')
writeLines(xref_pkg_list, file_name)

# Clean up
try(unlink(file_name))

</code></pre>

<hr>
<h2 id='fetch_ecosystems'>Fetch all available ecosystems</h2><span id='topic+fetch_ecosystems'></span>

<h3>Description</h3>

<p>Internal function used to fetch the available ecosystems in the OSV API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_ecosystems(offline = FALSE, refresh = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_ecosystems_+3A_offline">offline</code></td>
<td>
<p>Boolean, determine if using list bundled with package.</p>
</td></tr>
<tr><td><code id="fetch_ecosystems_+3A_refresh">refresh</code></td>
<td>
<p>Boolean, force refresh of cache when using online list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>refresh</code> parameter can be used to force the data to be pulled again
even if one is available in the cached location. Since a fresh pull is performed
for each R session, it is unlikely that this parameter is required and is primarily
reserved for future use if functionality necessitates.
</p>


<h3>Value</h3>

<p>A data.frame containing all the ecosystem names available in the OSV database.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_ecosystem">check_ecosystem</a></code>
</p>

<hr>
<h2 id='get_content'>Retrieve contents field from {rosv} R6 object</h2><span id='topic+get_content'></span>

<h3>Description</h3>

<p>Retrieve contents field from {rosv} R6 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_content(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_content_+3A_x">x</code></td>
<td>
<p>An object made by {rosv}.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values contained in the content field of the object (data.frame or list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- RosvQuery1$new(name = 'readxl', ecosystem = 'CRAN')
get_content(test)

</code></pre>

<hr>
<h2 id='is_pkg_vulnerable'>Detect if package within ecosystem has reported vulnerabilities</h2><span id='topic+is_pkg_vulnerable'></span>

<h3>Description</h3>

<p>Search the OSV database, by package name and its respective ecosystem, to determine
if a vulnerability has ever been listed. If a package has been listed as impacted by
a vulnerability this may warrant further queries to investigate specific versions
that have been affected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pkg_vulnerable(name, ecosystem, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_pkg_vulnerable_+3A_name">name</code></td>
<td>
<p>Character vector of package names.</p>
</td></tr>
<tr><td><code id="is_pkg_vulnerable_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Character vector of ecosystem(s) within which the package(s) exist.</p>
</td></tr>
<tr><td><code id="is_pkg_vulnerable_+3A_...">...</code></td>
<td>
<p>Any other parameters to pass to nested functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of logical values indicating vulnerabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is_pkg_vulnerable(c('dask', 'dplyr'), c('PyPI', 'CRAN'))

</code></pre>

<hr>
<h2 id='is_rosv'>Is object made from {rosv} R6 class</h2><span id='topic+is_rosv'></span>

<h3>Description</h3>

<p>Determine if object is an {rosv} type R6 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rosv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rosv_+3A_x">x</code></td>
<td>
<p>Object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean value based on if <code>x</code> is an R6 class made by {rosv}.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_rosv(RosvQuery1$new(name = 'readxl', ecosystem = 'CRAN'))

</code></pre>

<hr>
<h2 id='normalize_pypi_pkg'>Normalize package name to PyPI expectation</h2><span id='topic+normalize_pypi_pkg'></span>

<h3>Description</h3>

<p>Perform package name formatting as PyPI is case insensitive and long runs
of underscore, period, and hyphens are not recognized (- is same as &ndash;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_pypi_pkg(pkg_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_pypi_pkg_+3A_pkg_name">pkg_name</code></td>
<td>
<p>Character vector of package names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of normalized PyPI package names
</p>


<h3>See Also</h3>

<p><a href="https://packaging.python.org/en/latest/specifications/name-normalization/">PyPI Package Normalization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalize_pypi_pkg(c('Dask', 'TenSorFlow'))

</code></pre>

<hr>
<h2 id='osv_count_vulns'>Count the number of reported vulnerabilities</h2><span id='topic+osv_count_vulns'></span>

<h3>Description</h3>

<p>Search the OSV database, by package name and its respective ecosystem, and count the number
of discovered vulnerabilities listed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_count_vulns(name, ecosystem, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_count_vulns_+3A_name">name</code></td>
<td>
<p>Character vector of package names.</p>
</td></tr>
<tr><td><code id="osv_count_vulns_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Character vector of ecosystem(s) within which the package(s) exist.</p>
</td></tr>
<tr><td><code id="osv_count_vulns_+3A_...">...</code></td>
<td>
<p>Any other parameters to pass to nested functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of numeric values indicating vulnerabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
osv_count_vulns(c('dask', 'dplyr'), c('PyPI', 'CRAN'))

</code></pre>

<hr>
<h2 id='osv_download'>Download vulnerabilities from the OSV database</h2><span id='topic+osv_download'></span><span id='topic+.osv_download'></span><span id='topic+.osv_download_cache'></span>

<h3>Description</h3>

<p>Use vulnerability IDs and/or an ecosystem name to download vulnerability files from OSV GCS buckets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_download(
  vuln_ids = NULL,
  ecosystem,
  parse = TRUE,
  cache = TRUE,
  download_only = FALSE
)

.osv_download(vuln_ids = NULL, ecosystem, parse = TRUE, download_only = FALSE)

.osv_download_cache(
  vuln_ids = NULL,
  ecosystem,
  parse = TRUE,
  download_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_download_+3A_vuln_ids">vuln_ids</code></td>
<td>
<p>Vector of vulnerability IDs (optional).</p>
</td></tr>
<tr><td><code id="osv_download_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Ecosystem package lives within (must be set).</p>
</td></tr>
<tr><td><code id="osv_download_+3A_parse">parse</code></td>
<td>
<p>Boolean value to set if the content field should be parsed from JSON list format.</p>
</td></tr>
<tr><td><code id="osv_download_+3A_cache">cache</code></td>
<td>
<p>Boolean value to determine if should use a cached version of the function and API results.</p>
</td></tr>
<tr><td><code id="osv_download_+3A_download_only">download_only</code></td>
<td>
<p>Boolean value to determine if only the JSON files should be downloaded to disk.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the end-result will be similar to the other API functions, this one specifically downloads .zip or
.json files from the OSV GCS buckets. As a result, it has two main benefits. First, it can download the entire set
of vulnerabilities listed for an ecosystem. Second, it has options to save the vulnerability files to disk. The
files are saved to the R session's temp space, as defined by the environment variable <code>ROSV_CACHE_GLOBAL</code>.
</p>
<p>Any ecosystems listed <a href="https://osv-vulnerabilities.storage.googleapis.com/ecosystems.txt">here</a> can be downloaded.
Only one ecosystem can be provided at a time.
</p>


<h3>Value</h3>

<p>An R6 object containing API query contents.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.osv_download()</code>: Internal function to run <code>osv_download</code> without caching.
</p>
</li>
<li> <p><code>.osv_download_cache()</code>: Internal function to run a memoise and cached version of <code>osv_download</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
vulns &lt;- osv_download("RSEC-2023-8", "CRAN")
get_content(vulns)

# Clean up
try(clear_osv_cache())

</code></pre>

<hr>
<h2 id='osv_query'>Query OSV API for individual package vulnerabilities</h2><span id='topic+osv_query'></span>

<h3>Description</h3>

<p>Will connect to OSV API and query vulnerabilities from the specified packages.
Unlike the other query functions, <code>osv_query</code> will only return content and not
the response object. By default all vulnerabilities are returned for any versions of the package flagged
in OSV. This can be subset manually or via the parameter <code>all_affected</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_query(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  all_affected = TRUE,
  cache = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_query_+3A_name">name</code></td>
<td>
<p>Character vector of package names.</p>
</td></tr>
<tr><td><code id="osv_query_+3A_version">version</code></td>
<td>
<p>Character vector of package versions, <code>NA</code> if ignoring versions.</p>
</td></tr>
<tr><td><code id="osv_query_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Character vector of ecosystem(s) within which the package(s) exist.</p>
</td></tr>
<tr><td><code id="osv_query_+3A_all_affected">all_affected</code></td>
<td>
<p>Boolean value, if <code>TRUE</code> return all package results found per vulnerability discovered.</p>
</td></tr>
<tr><td><code id="osv_query_+3A_cache">cache</code></td>
<td>
<p>Boolean value to determine if should use a cached version of the function and API results.</p>
</td></tr>
<tr><td><code id="osv_query_+3A_...">...</code></td>
<td>
<p>Any other parameters to pass to nested functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the <a href="https://google.github.io/osv.dev/post-v1-query/">query</a> and
<a href="https://google.github.io/osv.dev/post-v1-querybatch/">batchquery</a> API endpoints have different outputs, this
function will align their contents to be a list of vulnerabilities. For 'query' this
meant flattening the returned list once; for 'batchquery' the returned IDs are used to fetch additional
vulnerability information and then flattened to a list.
</p>
<p>If only an <code>ecosystem</code> parameter is provided, all vulnerabilities for that selection
will be downloaded from the OSV database and parsed into a tidied table. Since some
vulnerabilities can exist across ecosystems, <code>all_affected</code> may need to be set to <code>FALSE</code>.
</p>
<p>Since the OSV database is organized by vulnerability, the returned content may have duplicate
package details as the same package, and possibly its version, may occur within several different
reported vulnerabilities. To avoid this behaviour, set the <code>all_affected</code> parameter to <code>FALSE</code>.
</p>
<p>Due to variations in formatting from the OSV API, not all responses have versions associated in
the response but instead use ranges. Filtering currently does not apply to this field and may return
all versions affected within the ranges. If you suspect ranges are used instead of specific version codes,
examine the response object using lower-level functions like <code>osv_query_1()</code>.
</p>
<p>To speed up the process for large ecosystems you can set <code>future::plan()</code>
for parallelization; this will be respected via the <code>furrr</code> package. The default will be to run sequentially.
There are performance impacts to allow for mixed ecosystems to be queried. For packages with many vulnerabilities,
it can be faster to perform those separately so all vulnerabilities can be pulled at once and not individually. Alternative
approaches may be implemented in future versions.
</p>


<h3>Value</h3>

<p>A data.frame with query results parsed.
</p>


<h3>See Also</h3>

<p><a href="https://ossf.github.io/osv-schema/#affectedpackage-field">Ecosystem list</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Single package
pkg_vul &lt;- osv_query('dask', ecosystem = 'PyPI')

# Batch query
name_vec &lt;- c('dask', 'dash')
ecosystem_vec &lt;- rep('PyPI', length(name_vec))
pkg_vul &lt;- osv_query(name_vec, ecosystem = ecosystem_vec)

</code></pre>

<hr>
<h2 id='osv_query_1'>Query OSV API for vulnerabilities based upon an individual package</h2><span id='topic+osv_query_1'></span><span id='topic+.osv_query_1'></span><span id='topic+.osv_query_1_cache'></span>

<h3>Description</h3>

<p>Query the OSV API for vulnerabilities that include the individual package of interest.
The request is automatically constructed from the provided elements and the returned
values are parsed into a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_query_1(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)

.osv_query_1(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)

.osv_query_1_cache(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_query_1_+3A_name">name</code></td>
<td>
<p>Name of package.</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_version">version</code></td>
<td>
<p>Version of package.</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Ecosystem package lives within (must be set if using <code>name</code>).</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_commit">commit</code></td>
<td>
<p>Commit hash to query against (do not use when version set).</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_purl">purl</code></td>
<td>
<p>URL for package (do not use if name or ecosystem set).</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_parse">parse</code></td>
<td>
<p>Boolean value to set if the content field should be parsed from JSON list format.</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_cache">cache</code></td>
<td>
<p>Boolean value to determine if should use a cached version of the function and API results.</p>
</td></tr>
<tr><td><code id="osv_query_1_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to nested functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R6 object containing API query contents.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.osv_query_1()</code>: Internal function to run <code>osv_query_1</code> without caching.
</p>
</li>
<li> <p><code>.osv_query_1_cache()</code>: Internal function to run a memoise and cached version of <code>osv_query_1</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="https://ossf.github.io/osv-schema/#affectedpackage-field">Ecosystem list</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
osv_query_1(commit = '6879efc2c1596d11a6a6ad296f80063b558d5e0f')

</code></pre>

<hr>
<h2 id='osv_querybatch'>Query OSV API for vulnerabilities given a vector of packages</h2><span id='topic+osv_querybatch'></span><span id='topic+.osv_querybatch'></span><span id='topic+.osv_querybatch_cache'></span>

<h3>Description</h3>

<p>Using a vector of input information, query the OSV API for any associated
vulnerability ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_querybatch(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)

.osv_querybatch(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)

.osv_querybatch_cache(
  name = NULL,
  version = NULL,
  ecosystem = NULL,
  commit = NULL,
  purl = NULL,
  parse = TRUE,
  cache = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_querybatch_+3A_name">name</code></td>
<td>
<p>Name of package.</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_version">version</code></td>
<td>
<p>Version of package.</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_ecosystem">ecosystem</code></td>
<td>
<p>Ecosystem package lives within (must be set if using <code>name</code>).</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_commit">commit</code></td>
<td>
<p>Commit hash to query against (do not use when version set).</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_purl">purl</code></td>
<td>
<p>URL for package (do not use if name or ecosystem set).</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_parse">parse</code></td>
<td>
<p>Boolean value to set if the content field should be parsed from JSON list format.</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_cache">cache</code></td>
<td>
<p>Boolean value to determine if should use a cached version of the function and API results.</p>
</td></tr>
<tr><td><code id="osv_querybatch_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to nested functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query is constructed from the provided set of vectors. Default
will be <code>NULL</code> and thereby empty/null in the JSON request. If some values in the vector
are missing, use <code>NA</code>. For many queries, the conversion to a formatted JSON
request can be parallelized via {future}.
</p>
<p>The returned information are vulnerability IDs and modified fields only, as per API instruction.
</p>


<h3>Value</h3>

<p>An R6 object containing API query contents.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.osv_querybatch()</code>: Internal function to run <code>osv_querybatch</code> without caching.
</p>
</li>
<li> <p><code>.osv_querybatch_cache()</code>: Internal function to run a memoise and cached version of <code>osv_querybatch</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="https://ossf.github.io/osv-schema/#affectedpackage-field">Ecosystem list</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
osv_querybatch(c("commonmark", "dask"), ecosystem = c('CRAN', 'PyPI'))

</code></pre>

<hr>
<h2 id='osv_scan'>Use OSV database to scan for vulnerabilities</h2><span id='topic+osv_scan'></span>

<h3>Description</h3>

<p>Scan project based upon specified mode to determine if any vulnerable packages are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_scan(mode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_scan_+3A_mode">mode</code></td>
<td>
<p>The kind of scan to perform.</p>
</td></tr>
<tr><td><code id="osv_scan_+3A_...">...</code></td>
<td>
<p>Parameters passed to specific underlying functions for mode selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available scanning modes are: 'r_project', 'renv', and 'r_libath'. The 'r_libpath' mode
simply performs all R project related scans at once. Emphasis is placed on scans of R related content.
Additional parsing and scanning modes will be added over time as needed. If a mode does not exist for
a particular purpose, alternate functions such as <code>is_pkg_vulnerable()</code> can be used with any list of
package names for ecosystems available in the OSV database.
</p>


<h3>Value</h3>

<p>A data.frame specifying which packages are vulnerable or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_pkg_vulnerable">is_pkg_vulnerable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
osv_scan('r_libpath')

</code></pre>

<hr>
<h2 id='osv_vulns'>Query OSV API for vulnerability information based on ID</h2><span id='topic+osv_vulns'></span><span id='topic+.osv_vulns'></span><span id='topic+.osv_vulns_cache'></span>

<h3>Description</h3>

<p>Use vulnerability IDs to extract more detailed information, usually paired with <code>osv_querybatch()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osv_vulns(vuln_ids, parse = TRUE, cache = TRUE)

.osv_vulns(vuln_ids, parse = TRUE)

.osv_vulns_cache(vuln_ids, parse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osv_vulns_+3A_vuln_ids">vuln_ids</code></td>
<td>
<p>Vector of vulnerability IDs.</p>
</td></tr>
<tr><td><code id="osv_vulns_+3A_parse">parse</code></td>
<td>
<p>Boolean value to set if the content field should be parsed from JSON list format.</p>
</td></tr>
<tr><td><code id="osv_vulns_+3A_cache">cache</code></td>
<td>
<p>Boolean value to determine if should use a cached version of the function and API results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R6 object containing API query contents.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.osv_vulns()</code>: Internal function to run <code>osv_vulns</code> without caching.
</p>
</li>
<li> <p><code>.osv_vulns_cache()</code>: Internal function to run a memoise and cached version of <code>osv_vulns</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
vulns &lt;- osv_vulns("RSEC-2023-8")
get_content(vulns)

</code></pre>

<hr>
<h2 id='RosvDownload'>R6 Class for OSV Database Downloads</h2><span id='topic+RosvDownload'></span>

<h3>Description</h3>

<p>An R6 class to provide a lower-level interface to download from the OSV database GCS buckets.
</p>


<h3>Details</h3>

<p>If no vulnerability IDs are provided, the entire set is downloaded from the ecosystem's all.zip file.
JSON files are downloaded to the R session's temporary folder as dictated by the environment
variable <code>ROSV_CACHE_GLOBAL</code>. Due to its similarity in parsing process, it simply inherits
the method from the parent class <code>RosvQuery1</code>.
</p>
<p>Any ecosystems listed <a href="https://osv-vulnerabilities.storage.googleapis.com/ecosystems.txt">here</a> can be downloaded.
</p>


<h3>Value</h3>

<p>An R6 object to operate with data downloaded from the OSV GCS buckets.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+RosvQuery1">rosv::RosvQuery1</a></code> -&gt; <code>RosvDownload</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>osv_cache_dir</code></dt><dd><p>Location of cached vulnerability JSON files.</p>
</dd>
<dt><code>content</code></dt><dd><p>Content from downloading the vulnerabilities.</p>
</dd>
<dt><code>time_stamp</code></dt><dd><p>Time stamp associated with run.</p>
</dd>
<dt><code>date_stamp_hash</code></dt><dd><p>Hashed date from time stamp.</p>
</dd>
<dt><code>ecosystem</code></dt><dd><p>The ecosystem used upon creation.</p>
</dd>
<dt><code>vuln_ids</code></dt><dd><p>The vulnerability IDs, if provided.</p>
</dd>
<dt><code>request</code></dt><dd><p>The URLs to request downloaded files.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RosvDownload-new"><code>RosvDownload$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvDownload-download"><code>RosvDownload$download()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvDownload-run"><code>RosvDownload$run()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvDownload-print"><code>RosvDownload$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvDownload-clone"><code>RosvDownload$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rosv" data-topic="RosvQuery1" data-id="parse"><a href='../../rosv/html/RosvQuery1.html#method-RosvQuery1-parse'><code>rosv::RosvQuery1$parse()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RosvDownload-new"></a>



<h4>Method <code>new()</code></h4>

<p>Set the core request details for subsequent use when called in <code>run()</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvDownload$new(vuln_ids = NULL, ecosystem)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vuln_ids</code></dt><dd><p>Character vector of vulnerability IDs.</p>
</dd>
<dt><code>ecosystem</code></dt><dd><p>Ecosystem package lives within (must be set).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvDownload-download"></a>



<h4>Method <code>download()</code></h4>

<p>Download vulnerabilities from provided <code>ecosystem</code> to disk, the location
is recorded under the <code>osv_cache_dir</code> field. Will overwrite any existing files
in the cache.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvDownload$download()</pre></div>


<hr>
<a id="method-RosvDownload-run"></a>



<h4>Method <code>run()</code></h4>

<p>Load vulnerabilities to the R session. The entire contents of
each vulnerability file will be loaded. Subsequent use of the <code>parse()</code> method
will shrink the memory footprint as not all contents will be carried across.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvDownload$run()</pre></div>


<hr>
<a id="method-RosvDownload-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print basic details of query object to screen.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvDownload$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Reserved for possible future use.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvDownload-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvDownload$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="https://google.github.io/osv.dev/data/#data-dumps">https://google.github.io/osv.dev/data/#data-dumps</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>query &lt;- RosvDownload$new(ecosystem = 'CRAN')
query
</code></pre>

<hr>
<h2 id='RosvQuery1'>R6 Class for OSV Query Endpoint</h2><span id='topic+RosvQuery1'></span>

<h3>Description</h3>

<p>An R6 class to provide a lower-level interface to the query endpoint of the OSV API.
</p>


<h3>Details</h3>

<p>Pageination is implemented via <code>httr2::req_perform_iterative()</code> and a private method for
extracting tokens automatically. When initialized, the page_token is set to <code>NULL</code>;
if a token is generated for large results the process is handled internally. The response object
will contain a list of all returned responses before any formatting occurred. The content field will
contain the list of vulnerabilities which may be further parsed into a table format.
</p>


<h3>Value</h3>

<p>An R6 object to operate with OSV query endpoint.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request</code></dt><dd><p>Request object made by <code>httr2</code>.</p>
</dd>
<dt><code>content</code></dt><dd><p>Body contents of response from OSV API.</p>
</dd>
<dt><code>response</code></dt><dd><p>Response object returned from OSV API.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RosvQuery1-new"><code>RosvQuery1$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQuery1-run"><code>RosvQuery1$run()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQuery1-parse"><code>RosvQuery1$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQuery1-print"><code>RosvQuery1$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQuery1-clone"><code>RosvQuery1$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RosvQuery1-new"></a>



<h4>Method <code>new()</code></h4>

<p>Set the core request details for subsequent use when called in <code>run()</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQuery1$new(
  commit = NULL,
  version = NULL,
  name = NULL,
  ecosystem = NULL,
  purl = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>commit</code></dt><dd><p>Commit hash to query against (do not use when version set).</p>
</dd>
<dt><code>version</code></dt><dd><p>Version of package.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of package.</p>
</dd>
<dt><code>ecosystem</code></dt><dd><p>Ecosystem package lives within (must be set if using <code>name</code>).</p>
</dd>
<dt><code>purl</code></dt><dd><p>URL for package (do not use if <code>name</code> or <code>ecosystem</code> is set).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvQuery1-run"></a>



<h4>Method <code>run()</code></h4>

<p>Perform the request and return response for OSV API call.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQuery1$run()</pre></div>


<hr>
<a id="method-RosvQuery1-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>Parse the contents returned into a tidier format. Can
use <code>future</code> plans to help parallelize. Not all contents are parsed.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQuery1$parse()</pre></div>


<hr>
<a id="method-RosvQuery1-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print basic details of query object to screen.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQuery1$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Reserved for possible future use.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvQuery1-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQuery1$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="https://google.github.io/osv.dev/post-v1-query/">https://google.github.io/osv.dev/post-v1-query/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>query &lt;- RosvQuery1$new(commit = '6879efc2c1596d11a6a6ad296f80063b558d5e0f')
query
</code></pre>

<hr>
<h2 id='RosvQueryBatch'>R6 Class for OSV Querybatch Endpoint</h2><span id='topic+RosvQueryBatch'></span>

<h3>Description</h3>

<p>An R6 class to provide a lower-level interface to the querybatch
endpoint of the OSV API. Batches are enforced to only process by commit hash, purl, or name+ecosystem.
This avoids some confusion as to which is taken preferentially and simplifies query creation.
</p>


<h3>Details</h3>

<p>Pageination is implemented via <code>httr2::req_perform_iterative()</code> and a private method for
extracting tokens automatically. When initialized, the page_token is set to <code>NULL</code>;
if a token is generated for large results the process is handled internally. The response object
will contain a list of all returned responses before any formatting occurred. The content field will
contain the list of results with vulnerabilities which may be further parsed into a table format.
</p>


<h3>Value</h3>

<p>An R6 object to operate with OSV querybatch endpoint.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+RosvQuery1">rosv::RosvQuery1</a></code> -&gt; <code>RosvQueryBatch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RosvQueryBatch-new"><code>RosvQueryBatch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQueryBatch-run"><code>RosvQueryBatch$run()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQueryBatch-parse"><code>RosvQueryBatch$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvQueryBatch-clone"><code>RosvQueryBatch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rosv" data-topic="RosvQuery1" data-id="print"><a href='../../rosv/html/RosvQuery1.html#method-RosvQuery1-print'><code>rosv::RosvQuery1$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RosvQueryBatch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Set the core request details for subsequent use when called in <code>run()</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQueryBatch$new(
  commit = NULL,
  version = NULL,
  name = NULL,
  ecosystem = NULL,
  purl = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>commit</code></dt><dd><p>Commit hash to query against (do not use when version set).</p>
</dd>
<dt><code>version</code></dt><dd><p>Version of package.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of package.</p>
</dd>
<dt><code>ecosystem</code></dt><dd><p>Ecosystem package lives within (must be set if using <code>name</code>).</p>
</dd>
<dt><code>purl</code></dt><dd><p>URL for package (do not use if <code>name</code> or <code>ecosystem</code> is set).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvQueryBatch-run"></a>



<h4>Method <code>run()</code></h4>

<p>Perform the request and return response for OSV API call.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQueryBatch$run()</pre></div>


<hr>
<a id="method-RosvQueryBatch-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>Parse the contents returned into a tidier format.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQueryBatch$parse()</pre></div>



<h5>Details</h5>

<p>When no result is found, any empty list is returned by the API, which
during parsing will be dropped as the list is flattened. However, the
index of the list is still accessible and the dropped items can easily
be identified from the results column. Not all contents are parsed.
</p>


<hr>
<a id="method-RosvQueryBatch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvQueryBatch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="https://google.github.io/osv.dev/post-v1-querybatch/">https://google.github.io/osv.dev/post-v1-querybatch/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pkgs &lt;- c('jinja2', 'dask')
ecosystem &lt;- rep('PyPI', length(pkgs))
batchquery &lt;- RosvQueryBatch$new(name = pkgs, ecosystem = ecosystem)
batchquery

</code></pre>

<hr>
<h2 id='RosvVulns'>R6 Class for OSV Vulns Endpoint</h2><span id='topic+RosvVulns'></span>

<h3>Description</h3>

<p>An R6 class to provide a lower-level interface to the vulnerability
endpoint of the OSV API.
</p>


<h3>Value</h3>

<p>An R6 object to operate with OSV vulns endpoint.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+RosvQuery1">rosv::RosvQuery1</a></code> -&gt; <code>RosvVulns</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RosvVulns-new"><code>RosvVulns$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvVulns-run"><code>RosvVulns$run()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvVulns-print"><code>RosvVulns$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RosvVulns-clone"><code>RosvVulns$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rosv" data-topic="RosvQuery1" data-id="parse"><a href='../../rosv/html/RosvQuery1.html#method-RosvQuery1-parse'><code>rosv::RosvQuery1$parse()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RosvVulns-new"></a>



<h4>Method <code>new()</code></h4>

<p>Set the core request details for subsequent use when called in <code>run()</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvVulns$new(vuln_ids)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vuln_ids</code></dt><dd><p>Character vector of vulnerability IDs.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvVulns-run"></a>



<h4>Method <code>run()</code></h4>

<p>Perform the request and return response for OSV API call.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvVulns$run()</pre></div>


<hr>
<a id="method-RosvVulns-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print basic details of query object to screen.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvVulns$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Reserved for possible future use.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RosvVulns-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RosvVulns$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="https://google.github.io/osv.dev/get-v1-vulns/">https://google.github.io/osv.dev/get-v1-vulns/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vulns &lt;- RosvVulns$new(c('RSEC-2023-6', 'GHSA-jq35-85cj-fj4p'))
vulns

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
