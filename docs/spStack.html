<!DOCTYPE html><html lang="en-US"><head><title>Help for package spStack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spStack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spStack-package'><p>spStack: Bayesian Geostatistics Using Predictive Stacking</p></a></li>
<li><a href='#cholUpdate'><p>Different Cholesky factor updates</p></a></li>
<li><a href='#get_stacking_weights'><p>Optimal stacking weights</p></a></li>
<li><a href='#iDist'><p>Calculate distance matrix</p></a></li>
<li><a href='#sim_spData'><p>Simulate spatial data on unit square</p></a></li>
<li><a href='#simBinary'><p>Synthetic point-referenced binary data</p></a></li>
<li><a href='#simBinom'><p>Synthetic point-referenced binomial count data</p></a></li>
<li><a href='#simGaussian'><p>Synthetic point-referenced Gaussian data</p></a></li>
<li><a href='#simPoisson'><p>Synthetic point-referenced Poisson count data</p></a></li>
<li><a href='#spGLMexact'><p>Univariate Bayesian spatial generalized linear model</p></a></li>
<li><a href='#spGLMstack'><p>Bayesian spatial generalized linear model using predictive stacking</p></a></li>
<li><a href='#spLMexact'><p>Univariate Bayesian spatial linear model</p></a></li>
<li><a href='#spLMstack'><p>Bayesian spatial linear model using predictive stacking</p></a></li>
<li><a href='#stackedSampler'><p>Sample from the stacked posterior distribution</p></a></li>
<li><a href='#surfaceplot'><p>Make a surface plot</p></a></li>
<li><a href='#surfaceplot2'><p>Make two side-by-side surface plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Geostatistics Using Predictive Stacking</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits Bayesian hierarchical spatial process models for
    point-referenced Gaussian, Poisson, binomial, and binary data using stacking
    of predictive densities. It involves sampling from analytically available
    posterior distributions conditional upon some candidate values of the
    spatial process parameters and, subsequently assimilate inference from these
    individual posterior distributions using Bayesian predictive stacking. Our
    algorithm is highly parallelizable and hence, much faster than traditional
    Markov chain Monte Carlo algorithms while delivering competitive predictive
    performance. See Zhang, Tang, and Banerjee (2024)
    &lt;<a href="https://doi.org/10.48550%2FarXiv.2304.12414">doi:10.48550/arXiv.2304.12414</a>&gt;, and, Pan, Zhang, Bradley, and Banerjee
    (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2406.04655">doi:10.48550/arXiv.2406.04655</a>&gt; for details.</td>
</tr>
<tr>
<td>Imports:</td>
<td>CVXR, future, future.apply, ggplot2, MBA, rstudioapi</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggpubr, knitr, rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SPan-18/spStack-dev">https://github.com/SPan-18/spStack-dev</a>,
<a href="https://span-18.github.io/spStack-dev/">https://span-18.github.io/spStack-dev/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SPan-18/spStack-dev/issues">https://github.com/SPan-18/spStack-dev/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-08 00:02:26 UTC; soumyakantipan</td>
</tr>
<tr>
<td>Author:</td>
<td>Soumyakanti Pan <a href="https://orcid.org/0009-0005-9889-7112"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sudipto Banerjee [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Soumyakanti Pan &lt;span18@ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-08 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spStack-package'>spStack: Bayesian Geostatistics Using Predictive Stacking</h2><span id='topic+spStack'></span><span id='topic+spStack-package'></span>

<h3>Description</h3>

<p>This package delivers functions to fit Bayesian hierarchical spatial process
models for point-referenced Gaussian, Poisson, binomial, and binary data
using stacking of predictive densities. It involves sampling from
analytically available posterior distributions conditional upon some
candidate values of the spatial process parameters for both Gaussian response
model as well as non-Gaussian responses, and, subsequently assimilate
inference from these individual posterior distributions using Bayesian
predictive stacking. Our algorithm is highly parallelizable and hence, much
faster than traditional Markov chain Monte Carlo algorithms while
delivering competitive predictive performance.
</p>
<p>In context of inference for spatial point-referenced data,
Bayesian hierarchical models involve latent spatial processes characterized
by spatial process parameters, which besides lacking substantive relevance in
scientific contexts, are also weakly identified and hence, impedes
convergence of MCMC algorithms. This motivates us to build methodology that
involves fast sampling from posterior distributions conditioned on a grid of
the weakly identified model parameters and combine the inference by stacking
of predictive densities (Yao <em>et. al</em> 2018). We exploit the Bayesian
conjugate linear modeling framework for the Gaussian case (Zhang, Tang and
Banerjee 2024) and the generalized conjugate multivariate distribution theory
(Pan, Zhang, Bradley and Banerjee 2024) to analytically derive the individual
posterior distributions.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> spStack</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Accepts a formula, e.g., <code>y~x1+x2</code>, for most regression models
accompanied by candidate values of spatial process parameters, and returns
posterior samples of the regression coefficients and the latent spatial
random effects. Posterior inference or prediction of any quantity of interest
proceed from these samples. Main functions are - <br /> <code><a href="#topic+spLMexact">spLMexact()</a></code><br />
<code><a href="#topic+spGLMexact">spGLMexact()</a></code><br /> <code><a href="#topic+spLMstack">spLMstack()</a></code><br /> <code><a href="#topic+spGLMstack">spGLMstack()</a></code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a> (<a href="https://orcid.org/0009-0005-9889-7112">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>
</li></ul>



<h3>References</h3>

<p>Zhang L, Tang W, Banerjee S (2024). &quot;Bayesian Geostatistics Using
Predictive Stacking.&quot; <br />
<a href="https://doi.org/10.48550/arXiv.2304.12414">doi:10.48550/arXiv.2304.12414</a>.
</p>
<p>Pan S, Zhang L, Bradley JR, Banerjee S (2024). &quot;Bayesian
Inference for Spatial-temporal Non-Gaussian Data Using Predictive Stacking.&quot;
<a href="https://doi.org/10.48550/arXiv.2406.04655">doi:10.48550/arXiv.2406.04655</a>.
</p>
<p>Yao Y, Vehtari A, Simpson D, Gelman A (2018). &quot;Using Stacking to
Average Bayesian Predictive Distributions (with Discussion).&quot; <em>Bayesian
Analysis</em>, <strong>13</strong>(3), 917-1007. <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SPan-18/spStack-dev">https://github.com/SPan-18/spStack-dev</a>
</p>
</li>
<li> <p><a href="https://span-18.github.io/spStack-dev/">https://span-18.github.io/spStack-dev/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SPan-18/spStack-dev/issues">https://github.com/SPan-18/spStack-dev/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cholUpdate'>Different Cholesky factor updates</h2><span id='topic+cholUpdate'></span><span id='topic+cholUpdateRankOne'></span><span id='topic+cholUpdateDel'></span><span id='topic+cholUpdateDelBlock'></span>

<h3>Description</h3>

<p>Provides functions that implements different types of updates of
a Cholesky factor that includes rank-one update, single row/column deletion
update and a block deletion update.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholUpdateRankOne(A, v, alpha, beta, lower = TRUE)

cholUpdateDel(A, del.index, lower = TRUE)

cholUpdateDelBlock(A, del.start, del.end, lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cholUpdate_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">n\times n</code> triangular matrix</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_v">v</code></td>
<td>
<p>an <code class="reqn">n\times 1</code> matrix/vector</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_alpha">alpha</code></td>
<td>
<p>scalar; if not supplied, default is 1</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_beta">beta</code></td>
<td>
<p>scalar; if not supplied, default is 1</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_lower">lower</code></td>
<td>
<p>logical; if <code>A</code> is lower-triangular or not</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_del.index">del.index</code></td>
<td>
<p>an integer from 1 to <code class="reqn">n</code> indicating the row/column to be
deleted</p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_del.start">del.start</code></td>
<td>
<p>an integer from 1 to <code class="reqn">n</code> indicating the first row/column
of a block to be deleted, must be at least 1 less than <code>del.end</code></p>
</td></tr>
<tr><td><code id="cholUpdate_+3A_del.end">del.end</code></td>
<td>
<p>an integer from 1 to <code class="reqn">n</code> indicating the last row/column
of a block to be deleted, must be at least 1 more than <code>del.start</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">B = AA^\top</code> is a <code class="reqn">n \times n</code> matrix with <code class="reqn">A</code>
being its lower-triangular Cholesky factor. Then rank-one update corresponds
to finding the Cholesky factor of the matrix
<code class="reqn">C = \alpha B + \beta vv^\top</code> for some <code class="reqn">\alpha,\beta\in\mathbb{R}</code>
given <code class="reqn">A</code> (see, Krause and Igel 2015). Similarly, single row/column
deletion update corresponds to finding the Cholesky factor of the
<code class="reqn">(n-1)\times(n-1)</code> matrix <code class="reqn">B_i</code> which is obtained by removing the
<code class="reqn">i</code>-th row and column of <code class="reqn">B</code>, given <code class="reqn">A</code> for some
<code class="reqn">i - 1, \ldots, n</code>. Lastly, block deletion corresponds to finding the
Cholesky factor of the <code class="reqn">(n-n_k)\times(n-n_k)</code> matrix <code class="reqn">B_{I}</code> for a
subset <code class="reqn">I</code> of <code class="reqn">\{1, \ldots, n\}</code> containing <code class="reqn">n_k</code> consecutive
indices, given the factor <code class="reqn">A</code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">m \times m</code> lower-triangular <code>matrix</code> with <code class="reqn">m = n</code> in
case of <code>cholUpdateRankOne()</code>, <code class="reqn">m = n - 1</code> in case of <code>cholUpdateDel()</code>,
and, <code class="reqn">m = n - n_k</code> in case of <code>cholUpdateDelBlock()</code> where <code class="reqn">n_k</code> is
the size of the block removed.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Oswin Krause and Christian Igel. 2015. &quot;A More Efficient Rank-one
Covariance Matrix Update for Evolution Strategies&quot;. In <em>Proceedings of the
2015 ACM Conference on Foundations of Genetic Algorithms XIII</em> (FOGA '15).
Association for Computing Machinery, New York, NY, USA, 129-136.
<a href="https://doi.org/10.1145/2725494.2725496">doi:10.1145/2725494.2725496</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
A &lt;- matrix(rnorm(n^2), n, n)
A &lt;- crossprod(A)
cholA &lt;- chol(A)

## Rank-1 update
v &lt;- 1:n
APlusvvT &lt;- A + tcrossprod(v)
cholA1 &lt;- t(chol(APlusvvT))
cholA2 &lt;- cholUpdateRankOne(cholA, v, lower = FALSE)
print(all(abs(cholA1 - cholA2) &lt; 1E-9))

## Single Row-deletion update
ind &lt;- 2
A1 &lt;- A[-ind, -ind]
cholA1 &lt;- t(chol(A1))
cholA2 &lt;- cholUpdateDel(cholA, del.index = ind, lower = FALSE)
print(all(abs(cholA1 - cholA2) &lt; 1E-9))

## Block-deletion update
start_ind &lt;- 2
end_ind &lt;- 6
del_ind &lt;- c(start_ind:end_ind)
A1 &lt;- A[-del_ind, -del_ind]
cholA1 &lt;- t(chol(A1))
cholA2 &lt;- cholUpdateDelBlock(cholA, start_ind, end_ind, lower = FALSE)
print(all(abs(cholA1 - cholA2) &lt; 1E-9))
</code></pre>

<hr>
<h2 id='get_stacking_weights'>Optimal stacking weights</h2><span id='topic+get_stacking_weights'></span>

<h3>Description</h3>

<p>Obtains optimal stacking weights given leave-one-out predictive densities for
each candidate model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stacking_weights(log_loopd, solver = "ECOS")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stacking_weights_+3A_log_loopd">log_loopd</code></td>
<td>
<p>an <code class="reqn">n \times M</code> matrix with <code class="reqn">i</code>-th row
containing the leave-one-out predictive densities for the <code class="reqn">i</code>-th
data point for the <code class="reqn">M</code> candidate models.</p>
</td></tr>
<tr><td><code id="get_stacking_weights_+3A_solver">solver</code></td>
<td>
<p>specifies the solver to use for obtaining optimal weights.
Default is <code>"ECOS"</code>. Internally calls
<code><a href="CVXR.html#topic+psolve">CVXR::psolve()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2.
</p>

<dl>
<dt><code>weights</code></dt><dd><p>optimal stacking weights as a numeric vector of
length <code class="reqn">M</code></p>
</dd>
<dt><code>status</code></dt><dd><p>solver status, returns <code>"optimal"</code> if solver
succeeded.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Yao Y, Vehtari A, Simpson D, Gelman A (2018). &quot;Using Stacking to
Average Bayesian Predictive Distributions (with Discussion).&quot; <em>Bayesian
Analysis</em>, <strong>13</strong>(3), 917-1007. <a href="https://doi.org/10.1214/17-BA1091">doi:10.1214/17-BA1091</a>.
</p>


<h3>See Also</h3>

<p><code><a href="CVXR.html#topic+psolve">CVXR::psolve()</a></code>, <code><a href="#topic+spLMstack">spLMstack()</a></code>, <code><a href="#topic+spGLMstack">spGLMstack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
dat &lt;- simGaussian[1:100, ]

mod1 &lt;- spLMstack(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  params.list = list(phi = c(1.5, 3),
                                     nu = c(0.5, 1),
                                     noise_sp_ratio = c(1)),
                  n.samples = 1000, loopd.method = "exact",
                  parallel = FALSE, solver = "ECOS", verbose = TRUE)

loopd_mat &lt;- do.call('cbind', mod1$loopd)
w_hat &lt;- get_stacking_weights(loopd_mat)
print(round(w_hat$weights, 4))
print(w_hat$status)
</code></pre>

<hr>
<h2 id='iDist'>Calculate distance matrix</h2><span id='topic+iDist'></span>

<h3>Description</h3>

<p>Computes the inter-site Euclidean distance matrix for one or two sets of
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iDist(coords.1, coords.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iDist_+3A_coords.1">coords.1</code></td>
<td>
<p>an <code class="reqn">n\times p</code> matrix with each row corresponding to
a point in <code class="reqn">p</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="iDist_+3A_coords.2">coords.2</code></td>
<td>
<p>an <code class="reqn">m\times p</code> matrix with each row corresponding to
a point in <code class="reqn">p</code> dimensional space. If this is missing then
<code>coords.1</code> is used.</p>
</td></tr>
<tr><td><code id="iDist_+3A_...">...</code></td>
<td>
<p>currently no additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">n\times n</code> or <code class="reqn">n\times m</code> inter-site Euclidean
distance matrix.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
p1 &lt;- cbind(runif(n),runif(n))
m &lt;- 5
p2 &lt;- cbind(runif(m),runif(m))
D &lt;- iDist(p1, p2)
</code></pre>

<hr>
<h2 id='sim_spData'>Simulate spatial data on unit square</h2><span id='topic+sim_spData'></span>

<h3>Description</h3>

<p>Generates synthetic spatial data of different types where the
spatial co-ordinates are sampled uniformly on an unit square. Different types
include point-referenced Gaussian, Poisson, binomial and binary data. The
design includes an intercept and fixed covariates sampled from a standard
normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_spData(n, beta, cor.fn, spParams, spvar, deltasq, family, n_binom)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_spData_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_beta">beta</code></td>
<td>
<p>a <code class="reqn">p</code>-dimensional vector of fixed effects.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_cor.fn">cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_spparams">spParams</code></td>
<td>
<p>a numeric vector containing spatial process parameters -
e.g., spatial decay and smoothness.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_spvar">spvar</code></td>
<td>
<p>value of spatial variance parameter.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_deltasq">deltasq</code></td>
<td>
<p>value of noise-to-spatial variance ratio.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_family">family</code></td>
<td>
<p>a character specifying the distribution of the response as a
member of the exponential family. Valid inputs are <code>'gaussian'</code>, <code>'poisson'</code>,
<code>'binary'</code>, and <code>'binomial'</code>.</p>
</td></tr>
<tr><td><code id="sim_spData_+3A_n_binom">n_binom</code></td>
<td>
<p>necessary only when <code>family = 'binomial'</code>. Must be a
vector of length <code>n</code> that will specify the number of trials for each
observation. If it is of length 1, then that value is considered to be the
common value for the number of trials for all <code>n</code> observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> object containing the columns -
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;s1, s2&#8288;</code></dt><dd><p>2D-coordinates in unit square</p>
</dd>
<dt><code style="white-space: pre;">&#8288;x1, x2, ...&#8288;</code></dt><dd><p>covariates, not including intercept</p>
</dd>
<dt><code>y</code></dt><dd><p>response</p>
</dd>
<dt><code>n_trials</code></dt><dd><p>present only when binomial data is generated</p>
</dd>
<dt><code>z_true</code></dt><dd><p>true spatial effects with which the data is generated</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1729)
n &lt;- 10
beta &lt;- c(2, 5)
phi0 &lt;- 2
nu0 &lt;- 0.5
spParams &lt;- c(phi0, nu0)
spvar &lt;- 0.4
deltasq &lt;- 1
sim1 &lt;- sim_spData(n = n, beta = beta, cor.fn = "matern",
                   spParams = spParams, spvar = spvar, deltasq = deltasq,
                   family = "gaussian")
</code></pre>

<hr>
<h2 id='simBinary'>Synthetic point-referenced binary data</h2><span id='topic+simBinary'></span>

<h3>Description</h3>

<p>Dataset of size 500, with a binary response variable indexed by
spatial coordinates sampled uniformly from the unit square. The model
includes one covariate and spatial random effects induced by a Matérn
covariogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simBinary)
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> object.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;s1, s2&#8288;</code></dt><dd><p>2-D coordinates; latitude and longitude.</p>
</dd>
<dt><code>x1</code></dt><dd><p>a covariate sampled from the standard normal distribution.</p>
</dd>
<dt><code>y</code></dt><dd><p>response vector (0/1).</p>
</dd>
<dt><code>z_true</code></dt><dd><p>true spatial random effects that generated the data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>With <code class="reqn">n = 500</code>, the binary data is simulated using
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
y(s_i) &amp;\sim \mathrm{Bernoulli}(\pi(s_i)), i = 1, \ldots, n,\\
\pi(s_i) &amp;= \mathrm{ilogit}(x(s_i)^\top \beta + z(s_i))
\end{aligned}
</code>
</p>

<p>where the function <code class="reqn">\mathrm{ilogit}</code> refers to the inverse-logit
function, the spatial effects <code class="reqn">z \sim N(0, \sigma^2 R)</code> with <code class="reqn">R</code> being
a <code class="reqn">n \times n</code> correlation matrix given by the Matérn covariogram
</p>
<p style="text-align: center;"><code class="reqn">
R(s, s') = \frac{(\phi |s-s'|)^\nu}{\Gamma(\nu) 2^{\nu - 1}}
K_\nu(\phi |s-s'|),
</code>
</p>

<p>where <code class="reqn">\phi</code> is the spatial decay parameter and <code class="reqn">\nu</code> the spatial
smoothness parameter. We have sampled the data with
<code class="reqn">\beta = (0.5, -0.5)</code>, <code class="reqn">\phi = 5</code>, <code class="reqn">\nu = 0.5</code>, and
<code class="reqn">\sigma^2 = 0.4</code>. This data can be generated with the code as given in
the example below.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+simGaussian">simGaussian</a>, <a href="#topic+simPoisson">simPoisson</a>, <a href="#topic+simBinom">simBinom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1729)
n &lt;- 500
beta &lt;- c(0.5, -0.5)
phi0 &lt;- 5
nu0 &lt;- 0.5
spParams &lt;- c(phi0, nu0)
spvar &lt;- 0.4
sim1 &lt;- sim_spData(n = n, beta = beta, cor.fn = "matern",
                   spParams = spParams, spvar = spvar, deltasq = deltasq,
                   family = "binary")
plot1 &lt;- surfaceplot(sim1, coords_name = c("s1", "s2"), var_name = "z_true")

library(ggplot2)
plot2 &lt;- ggplot(sim1, aes(x = s1, y = s2)) +
  geom_point(aes(color = factor(y)), alpha = 0.75) +
  scale_color_manual(values = c("red", "blue"), labels = c("0", "1")) +
  guides(alpha = 'none') +
  theme_bw() +
  theme(axis.ticks = element_line(linewidth = 0.25),
        panel.background = element_blank(),
        panel.grid = element_blank(),
        legend.title = element_text(size = 10, hjust = 0.25),
        legend.box.just = "center", aspect.ratio = 1)
</code></pre>

<hr>
<h2 id='simBinom'>Synthetic point-referenced binomial count data</h2><span id='topic+simBinom'></span>

<h3>Description</h3>

<p>Dataset of size 500, with a binomial response variable indexed
by spatial coordinates sampled uniformly from the unit square. The model
includes one covariate and spatial random effects induced by a Matérn
covariogram. The number of trials at each location is sampled from a Poisson
distribution with mean 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simBinom)
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> object.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;s1, s2&#8288;</code></dt><dd><p>2-D coordinates; latitude and longitude.</p>
</dd>
<dt><code>x1</code></dt><dd><p>a covariate sampled from the standard normal distribution.</p>
</dd>
<dt><code>y</code></dt><dd><p>response vector.</p>
</dd>
<dt><code>n_trials</code></dt><dd><p>Number of trials at that location.</p>
</dd>
<dt><code>z_true</code></dt><dd><p>true spatial random effects that generated the data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>With <code class="reqn">n = 500</code>, the count data is simulated using
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
y(s_i) &amp;\sim \mathrm{Binomial}(m(s_i), \pi(s_i)), i = 1, \ldots, n,\\
\pi(s_i) &amp;= \mathrm{ilogit}(x(s_i)^\top \beta + z(s_i))
\end{aligned}
</code>
</p>

<p>where the function <code class="reqn">\mathrm{ilogit}</code> refers to the inverse-logit
function, the number of trials <code class="reqn">m(s_i)</code> is sampled from a Poisson
distribution with mean 20, the spatial effects <code class="reqn">z \sim N(0, \sigma^2 R)</code>
with <code class="reqn">R</code> being a <code class="reqn">n \times n</code> correlation matrix given by the Matérn
covariogram
</p>
<p style="text-align: center;"><code class="reqn">
R(s, s') = \frac{(\phi |s-s'|)^\nu}{\Gamma(\nu) 2^{\nu - 1}}
K_\nu(\phi |s-s'|),
</code>
</p>

<p>where <code class="reqn">\phi</code> is the spatial decay parameter and <code class="reqn">\nu</code> the spatial
smoothness parameter. We have sampled the data with
<code class="reqn">\beta = (0.5, -0.5)</code>, <code class="reqn">\phi = 3</code>, <code class="reqn">\nu = 0.5</code>, and
<code class="reqn">\sigma^2 = 0.4</code>. This data can be generated with the code as given in
the example below.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+simGaussian">simGaussian</a>, <a href="#topic+simPoisson">simPoisson</a>, <a href="#topic+simBinary">simBinary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1729)
n &lt;- 500
beta &lt;- c(0.5, -0.5)
phi0 &lt;- 3
nu0 &lt;- 0.5
spParams &lt;- c(phi0, nu0)
spvar &lt;- 0.4
sim1 &lt;- sim_spData(n = n, beta = beta, cor.fn = "matern",
                   spParams = spParams, spvar = spvar, deltasq = deltasq,
                   n_binom = rpois(n, 20),
                   family = "binomial")
plot1 &lt;- surfaceplot(sim1, coords_name = c("s1", "s2"), var_name = "z_true")

library(ggplot2)
plot2 &lt;- ggplot(sim1, aes(x = s1, y = s2)) +
  geom_point(aes(color = y), alpha = 0.75) +
  scale_color_distiller(palette = "RdYlGn", direction = -1,
                        label = function(x) sprintf("%.0f", x)) +
  guides(alpha = 'none') +
  theme_bw() +
  theme(axis.ticks = element_line(linewidth = 0.25),
        panel.background = element_blank(),
        panel.grid = element_blank(),
        legend.title = element_text(size = 10, hjust = 0.25),
        legend.box.just = "center", aspect.ratio = 1)
</code></pre>

<hr>
<h2 id='simGaussian'>Synthetic point-referenced Gaussian data</h2><span id='topic+simGaussian'></span>

<h3>Description</h3>

<p>Dataset of size 500 with a Gaussian response variable, simulated
with spatial coordinates sampled uniformly from the unit square. The model
includes one covariate and spatial random effects induced by a Matérn
covariogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simGaussian)
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> object.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;s1, s2&#8288;</code></dt><dd><p>2-D coordinates; latitude and longitude.</p>
</dd>
<dt><code>x1</code></dt><dd><p>a covariate sampled from the standard normal distribution.</p>
</dd>
<dt><code>y</code></dt><dd><p>response vector.</p>
</dd>
<dt><code>z_true</code></dt><dd><p>true spatial random effects that generated the data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is generated using the model
</p>
<p style="text-align: center;"><code class="reqn">
y = X \beta + z + \epsilon,
</code>
</p>

<p>where the spatial effects <code class="reqn">z \sim N(0, \sigma^2 R)</code> is independent of the
measurement error <code class="reqn">\epsilon \sim N(0, \delta^2 \sigma^2 I_n)</code> with
<code class="reqn">\delta^2</code> being the noise-to-spatial variance ratio and <code class="reqn">R</code> being a
<code class="reqn">n \times n</code> correlation matrix given by the Matérn covariogram
</p>
<p style="text-align: center;"><code class="reqn">
R(s, s') = \frac{(\phi |s-s'|)^\nu}{\Gamma(\nu) 2^{\nu - 1}}
K_\nu(\phi |s-s'|),
</code>
</p>

<p>where <code class="reqn">\phi</code> is the spatial decay parameter and <code class="reqn">\nu</code> the spatial
smoothness parameter. We have sampled the data with <code class="reqn">\beta = (2, 5)</code>,
<code class="reqn">\phi = 2</code>, <code class="reqn">\nu = 0.5</code>, <code class="reqn">\delta^2 = 1</code> and
<code class="reqn">\sigma^2 = 0.4</code>. This data can be generated with the code as given in
the example.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+simPoisson">simPoisson</a>, <a href="#topic+simBinom">simBinom</a>, <a href="#topic+simBinary">simBinary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1729)
n &lt;- 500
beta &lt;- c(2, 5)
phi0 &lt;- 2
nu0 &lt;- 0.5
spParams &lt;- c(phi0, nu0)
spvar &lt;- 0.4
deltasq &lt;- 1
sim1 &lt;- sim_spData(n = n, beta = beta, cor.fn = "matern",
                   spParams = spParams, spvar = spvar, deltasq = deltasq,
                   family = "gaussian")
plot1 &lt;- surfaceplot(sim1, coords_name = c("s1", "s2"), var_name = "z_true",
                     mark_points = TRUE)
plot1

library(ggplot2)
plot2 &lt;- ggplot(sim1, aes(x = s1, y = s2)) +
  geom_point(aes(color = y), alpha = 0.75) +
  scale_color_distiller(palette = "RdYlGn", direction = -1,
                        label = function(x) sprintf("%.0f", x)) +
  guides(alpha = 'none') + theme_bw() +
  theme(axis.ticks = element_line(linewidth = 0.25),
        panel.background = element_blank(), panel.grid = element_blank(),
        legend.title = element_text(size = 10, hjust = 0.25),
        legend.box.just = "center", aspect.ratio = 1)
plot2
</code></pre>

<hr>
<h2 id='simPoisson'>Synthetic point-referenced Poisson count data</h2><span id='topic+simPoisson'></span>

<h3>Description</h3>

<p>Dataset of size 500, with a Poisson distributed response
variable indexed by spatial coordinates sampled uniformly from the unit
square. The model includes one covariate and spatial random effects induced
by a Matérn covariogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simPoisson)
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> object.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;s1, s2&#8288;</code></dt><dd><p>2-D coordinates; latitude and longitude.</p>
</dd>
<dt><code>x1</code></dt><dd><p>a covariate sampled from the standard normal distribution.</p>
</dd>
<dt><code>y</code></dt><dd><p>response vector.</p>
</dd>
<dt><code>z_true</code></dt><dd><p>true spatial random effects that generated the data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>With <code class="reqn">n = 500</code>, the count data is simulated using
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
y(s_i) &amp;\sim \mathrm{Poisson}(\lambda(s_i)),
i = 1, \ldots, n,\\
\log \lambda(s_i) &amp;= x(s_i)^\top \beta + z(s_i)
\end{aligned}
</code>
</p>

<p>where the spatial effects <code class="reqn">z \sim N(0, \sigma^2 R)</code> with <code class="reqn">R</code> being a
<code class="reqn">n \times n</code> correlation matrix given by the Matérn covariogram
</p>
<p style="text-align: center;"><code class="reqn">
R(s, s') = \frac{(\phi |s-s'|)^\nu}{\Gamma(\nu) 2^{\nu - 1}}
K_\nu(\phi |s-s'|),
</code>
</p>

<p>where <code class="reqn">\phi</code> is the spatial decay parameter and <code class="reqn">\nu</code> the spatial
smoothness parameter. We have sampled the data with <code class="reqn">\beta = (2, -0.5)</code>,
<code class="reqn">\phi = 5</code>, <code class="reqn">\nu = 0.5</code>, and <code class="reqn">\sigma^2 = 0.4</code>. This data can be
generated with the code as given in the example below.
</p>


<h3>See Also</h3>

<p><a href="#topic+simGaussian">simGaussian</a>, <a href="#topic+simBinom">simBinom</a>, <a href="#topic+simBinary">simBinary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1729)
n &lt;- 500
beta &lt;- c(2, -0.5)
phi0 &lt;- 5
nu0 &lt;- 0.5
spParams &lt;- c(phi0, nu0)
spvar &lt;- 0.4
sim1 &lt;- sim_spData(n = n, beta = beta, cor.fn = "matern",
                   spParams = spParams, spvar = spvar, deltasq = deltasq,
                   family = "poisson")

# Plot an interpolated spatial surface of the true random spatial effects
plot1 &lt;- surfaceplot(sim1, coords_name = c("s1", "s2"), var_name = "z_true")

# Plot the simulated count data
library(ggplot2)
plot2 &lt;- ggplot(sim1, aes(x = s1, y = s2)) +
  geom_point(aes(color = y), alpha = 0.75) +
  scale_color_distiller(palette = "RdYlGn", direction = -1,
                        label = function(x) sprintf("%.0f", x)) +
  guides(alpha = 'none') + theme_bw() +
  theme(axis.ticks = element_line(linewidth = 0.25),
        panel.background = element_blank(), panel.grid = element_blank(),
        legend.title = element_text(size = 10, hjust = 0.25),
        legend.box.just = "center", aspect.ratio = 1)
</code></pre>

<hr>
<h2 id='spGLMexact'>Univariate Bayesian spatial generalized linear model</h2><span id='topic+spGLMexact'></span>

<h3>Description</h3>

<p>Fits a Bayesian spatial generalized linear model with fixed
values of spatial process parameters and some auxiliary model parameters. The
output contains posterior samples of the fixed effects, spatial random
effects and, if required, finds leave-one-out predictive densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spGLMexact(
  formula,
  data = parent.frame(),
  family,
  coords,
  cor.fn,
  priors,
  spParams,
  boundary = 0.5,
  n.samples,
  loopd = FALSE,
  loopd.method = "exact",
  CV.K = 10,
  loopd.nMC = 500,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spGLMexact_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be fit.
See example below.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spGLMexact</code> is called.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_family">family</code></td>
<td>
<p>Specifies the distribution of the response as a member of the
exponential family. Supported options are <code>'poisson'</code>, <code>'binomial'</code> and
<code>'binary'</code>.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">\mathbb{R}^2</code> (e.g., easting and northing).</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_cor.fn">cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.
See below for details.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_priors">priors</code></td>
<td>
<p>(optional) a list with each tag corresponding to a
hyperparameter name and containing hyperprior details. Valid tags include
<code>V.beta</code>, <code>nu.beta</code>, <code>nu.z</code> and <code>sigmaSq.xi</code>. Values of <code>nu.beta</code> and <code>nu.z</code>
must be at least 2.1. If not supplied, uses defaults.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_spparams">spParams</code></td>
<td>
<p>fixed values of spatial process parameters.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_boundary">boundary</code></td>
<td>
<p>Specifies the boundary adjustment parameter. Must be a real
number between 0 and 1. Default is 0.5.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_n.samples">n.samples</code></td>
<td>
<p>number of posterior samples to be generated.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_loopd">loopd</code></td>
<td>
<p>logical. If <code>loopd=TRUE</code>, returns leave-one-out predictive
densities, using method as given by <code>loopd.method</code>. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_loopd.method">loopd.method</code></td>
<td>
<p>character. Ignored if <code>loopd=FALSE</code>. If <code>loopd=TRUE</code>,
valid inputs are <code>'exact'</code>, <code>'CV'</code> and <code>'PSIS'</code>. The option <code>'exact'</code>
corresponds to exact leave-one-out predictive densities which requires
computation almost equivalent to fitting the model <code class="reqn">n</code> times. The
options <code>'CV'</code> and <code>'PSIS'</code> are faster and they implement <code class="reqn">K</code>-fold
cross validation and Pareto-smoothed importance sampling to find approximate
leave-one-out predictive densities (Vehtari <em>et al.</em> 2017).</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_cv.k">CV.K</code></td>
<td>
<p>An integer between 10 and 20. Considered only if
<code>loopd.method='CV'</code>. Default is 10 (as recommended in Vehtari <em>et. al</em> 2017).</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_loopd.nmc">loopd.nMC</code></td>
<td>
<p>Number of Monte Carlo samples to be used to evaluate
leave-one-out predictive densities when <code>loopd.method</code> is set to either
'exact' or 'CV'.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>verbose = TRUE</code>, prints model description.</p>
</td></tr>
<tr><td><code id="spGLMexact_+3A_...">...</code></td>
<td>
<p>currently no additional argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function, we fit a Bayesian hierarchical spatial
generalized linear model by sampling exactly from the joint posterior
distribution utilizing the generalized conjugate multivariate distribution
theory (Bradley and Clinch 2024). Suppose <code class="reqn">\chi = (s_1, \ldots, s_n)</code>
denotes the <code class="reqn">n</code> spatial locations the response <code class="reqn">y</code> is observed. Let
<code class="reqn">y(s)</code> be the outcome at location <code class="reqn">s</code> endowed with a probability law
from the natural exponential family, which we denote by
</p>
<p style="text-align: center;"><code class="reqn">
y(s) \sim \mathrm{EF}(x(s)^\top \beta + z(s); b, \psi)
</code>
</p>

<p>for some positive parameter <code class="reqn">b &gt; 0</code> and unit log partition function
<code class="reqn">\psi</code>. We consider the following response models based on the input
supplied to the argument <code>family</code>.
</p>

<dl>
<dt><code>'poisson'</code></dt><dd><p>It considers point-referenced Poisson responses
<code class="reqn">y(s) \sim \mathrm{Poisson}(e^{x(s)^\top \beta + z(s)})</code>. Here,
<code class="reqn">b = 1</code> and <code class="reqn">\psi(t) = e^t</code>.</p>
</dd>
<dt><code>'binomial'</code></dt><dd><p>It considers point-referenced binomial counts
<code class="reqn">y(s) \sim \mathrm{Binomial}(m(s), \pi(s))</code> where, <code class="reqn">m(s)</code> denotes
the total number of trials and probability of success
<code class="reqn">\pi(s) = \mathrm{ilogit}(x(s)^\top \beta + z(s))</code> at location <code class="reqn">s</code>.
Here, <code class="reqn">b = m(s)</code> and <code class="reqn">\psi(t) = \log(1+e^t)</code>.</p>
</dd>
<dt><code>'binary'</code></dt><dd><p>It considers point-referenced binary data (0 or, 1) i.e.,
<code class="reqn">y(s) \sim \mathrm{Bernoulli}(\pi(s))</code>, where probability of success
<code class="reqn">\pi(s) = \mathrm{ilogit}(x(s)^\top \beta + z(s))</code> at location <code class="reqn">s</code>.
Here, <code class="reqn">b = 1</code> and <code class="reqn">\psi(t) = \log(1 + e^t)</code>.</p>
</dd>
</dl>

<p>The hierarchical model is given as
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
y(s_i) &amp;\mid \beta, z, \xi \sim EF(x(s_i)^\top \beta + z(s_i) +
\xi_i - \mu_i; b_i, \psi_y), i = 1, \ldots, n\\
\xi &amp;\mid \beta, z, \sigma^2_\xi, \alpha_\epsilon \sim
\mathrm{GCM_c}(\cdots),\\
\beta &amp;\mid \sigma^2_\beta \sim N(0, \sigma^2_\beta V_\beta), \quad
\sigma^2_\beta \sim \mathrm{IG}(\nu_\beta/2, \nu_\beta/2)\\
z &amp;\mid \sigma^2_z \sim N(0, \sigma^2_z R(\chi; \phi, \nu)), \quad
\sigma^2_z \sim \mathrm{IG}(\nu_z/2, \nu_z/2),
\end{aligned}
</code>
</p>

<p>where <code class="reqn">\mu = (\mu_1, \ldots, \mu_n)^\top</code> denotes the discrepancy
parameter. We fix the spatial process parameters <code class="reqn">\phi</code> and <code class="reqn">\nu</code> and
the hyperparameters <code class="reqn">V_\beta</code>, <code class="reqn">\nu_\beta</code>, <code class="reqn">\nu_z</code> and
<code class="reqn">\sigma^2_\xi</code>. The term <code class="reqn">\xi</code> is known as the fine-scale variation
term which is given a conditional generalized conjugate multivariate
distribution as prior. For more details, see Pan <em>et al.</em> 2024. Default
values for <code class="reqn">V_\beta</code>, <code class="reqn">\nu_\beta</code>, <code class="reqn">\nu_z</code>, <code class="reqn">\sigma^2_\xi</code>
are diagonal with each diagonal element 100, 2.1, 2.1 and 0.1 respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>spGLMexact</code>, which is a list with the
following tags -
</p>

<dl>
<dt>priors</dt><dd><p>details of the priors used, containing the values of the
boundary adjustment parameter (<code>boundary</code>), the variance parameter of the
fine-scale variation term (<code>simasq.xi</code>) and others.</p>
</dd>
<dt>samples</dt><dd><p>a list of length 3, containing posterior samples of fixed
effects (<code>beta</code>), spatial effects (<code>z</code>) and the fine-scale
variation term (<code>xi</code>).</p>
</dd>
<dt>loopd</dt><dd><p>If <code>loopd=TRUE</code>, contains leave-one-out predictive
densities.</p>
</dd>
<dt>model.params</dt><dd><p>Values of the fixed parameters that includes
<code>phi</code> (spatial decay), <code>nu</code> (spatial smoothness).</p>
</dd>
</dl>

<p>The return object might include additional data that can be used for
subsequent prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>
</p>


<h3>References</h3>

<p>Bradley JR, Clinch M (2024). &quot;Generating Independent Replicates
Directly from the Posterior Distribution for a Class of Spatial Hierarchical
Models.&quot; <em>Journal of Computational and Graphical Statistics</em>, <strong>0</strong>(0), 1-17.
<a href="https://doi.org/10.1080/10618600.2024.2365728">doi:10.1080/10618600.2024.2365728</a>.
</p>
<p>Pan S, Zhang L, Bradley JR, Banerjee S (2024). &quot;Bayesian
Inference for Spatial-temporal Non-Gaussian Data Using Predictive Stacking.&quot;
<a href="https://doi.org/10.48550/arXiv.2406.04655">doi:10.48550/arXiv.2406.04655</a>.
</p>
<p>Vehtari A, Gelman A, Gabry J (2017). &quot;Practical Bayesian Model
Evaluation Using Leave-One-out Cross-Validation and WAIC.&quot;
<em>Statistics and Computing</em>, <strong>27</strong>(5), 1413-1432. ISSN 0960-3174.
<a href="https://doi.org/10.1007/s11222-016-9696-4">doi:10.1007/s11222-016-9696-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLMexact">spLMexact()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Analyze spatial poisson count data
data(simPoisson)
dat &lt;- simPoisson[1:10, ]
mod1 &lt;- spGLMexact(y ~ x1, data = dat, family = "poisson",
                   coords = as.matrix(dat[, c("s1", "s2")]),
                   cor.fn = "matern",
                   spParams = list(phi = 4, nu = 0.4),
                   n.samples = 100, verbose = TRUE)

# summarize posterior samples
post_beta &lt;- mod1$samples$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))

# Example 2: Analyze spatial binomial count data
data(simBinom)
dat &lt;- simBinom[1:10, ]
mod2 &lt;- spGLMexact(cbind(y, n_trials) ~ x1, data = dat, family = "binomial",
                   coords = as.matrix(dat[, c("s1", "s2")]),
                   cor.fn = "matern",
                   spParams = list(phi = 3, nu = 0.4),
                   n.samples = 100, verbose = TRUE)

# summarize posterior samples
post_beta &lt;- mod2$samples$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))

# Example 3: Analyze spatial binary data
data(simBinary)
dat &lt;- simBinary[1:10, ]
mod3 &lt;- spGLMexact(y ~ x1, data = dat, family = "binary",
                   coords = as.matrix(dat[, c("s1", "s2")]),
                   cor.fn = "matern",
                   spParams = list(phi = 4, nu = 0.4),
                   n.samples = 100, verbose = TRUE)

# summarize posterior samples
post_beta &lt;- mod3$samples$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))
</code></pre>

<hr>
<h2 id='spGLMstack'>Bayesian spatial generalized linear model using predictive stacking</h2><span id='topic+spGLMstack'></span>

<h3>Description</h3>

<p>Fits Bayesian spatial generalized linear model on a collection
of candidate models constructed based on some candidate values of some model
parameters specified by the user and subsequently combines inference by
stacking predictive densities. See Pan, Zhang, Bradley, and Banerjee (2024)
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spGLMstack(
  formula,
  data = parent.frame(),
  family,
  coords,
  cor.fn,
  priors,
  params.list,
  n.samples,
  loopd.controls,
  parallel = FALSE,
  solver = "ECOS",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spGLMstack_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be fit.
See example below.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spLMstack</code> is called.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_family">family</code></td>
<td>
<p>Specifies the distribution of the response as a member of the
exponential family. Supported options are <code>'poisson'</code>, <code>'binomial'</code> and
<code>'binary'</code>.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">\mathbb{R}^2</code> (e.g., easting and northing).</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_cor.fn">cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.
See below for details.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_priors">priors</code></td>
<td>
<p>(optional) a list with each tag corresponding to a parameter
name and containing prior details. Valid tags include <code>V.beta</code>, <code>nu.beta</code>,
<code>nu.z</code> and <code>sigmaSq.xi</code>.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_params.list">params.list</code></td>
<td>
<p>a list containing candidate values of spatial process
parameters for the <code>cor.fn</code> used, and, the boundary parameter.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_n.samples">n.samples</code></td>
<td>
<p>number of posterior samples to be generated.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_loopd.controls">loopd.controls</code></td>
<td>
<p>a list with details on how leave-one-out predictive
densities (LOO-PD) are to be calculated. Valid tags include <code>method</code>, <code>CV.K</code>
and <code>nMC</code>. The tag <code>method</code> can be either <code>'exact'</code> or <code>'CV'</code>. If sample size
is more than 100, then the default is <code>'CV'</code> with <code>CV.K</code> equal to its default
value 10 (Gelman <em>et al.</em> 2024). The tag <code>nMC</code> decides how many Monte Carlo
samples will be used to evaluate the leave-one-out predictive densities,
which must be at least 500 (default).</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>parallel=FALSE</code>, the parallelization plan,
if set up by the user, is ignored. If <code>parallel=TRUE</code>, the function
inherits the parallelization plan that is set by the user via the function
<code><a href="future.html#topic+plan">future::plan()</a></code> only. Depending on the parallel backend available, users
may choose their own plan. More details are available at
<a href="https://cran.R-project.org/package=future">https://cran.R-project.org/package=future</a>.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_solver">solver</code></td>
<td>
<p>(optional) Specifies the name of the solver that will be used
to obtain optimal stacking weights for each candidate model. Default is
<code>'ECOS'</code>. Users can use other solvers supported by the
<a href="CVXR.html#topic+CVXR-package">CVXR-package</a> package.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints model-specific optimal
stacking weights.</p>
</td></tr>
<tr><td><code id="spGLMstack_+3A_...">...</code></td>
<td>
<p>currently no additional argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of assigning a prior on the process parameters <code class="reqn">\phi</code>
and <code class="reqn">\nu</code>, the boundary adjustment parameter <code class="reqn">\epsilon</code>, we consider
a set of candidate models based on some candidate values of these parameters
supplied by the user. Suppose the set of candidate models is
<code class="reqn">\mathcal{M} = \{M_1, \ldots, M_G\}</code>. Then for each
<code class="reqn">g = 1, \ldots, G</code>, we sample from the posterior distribution
<code class="reqn">p(\sigma^2, \beta, z \mid y, M_g)</code> under the model <code class="reqn">M_g</code> and find
leave-one-out predictive densities <code class="reqn">p(y_i \mid y_{-i}, M_g)</code>. Then we
solve the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
\max_{w_1, \ldots, w_G}&amp; \, \frac{1}{n} \sum_{i = 1}^n \log \sum_{g = 1}^G
w_g p(y_i \mid y_{-i}, M_g) \\
\text{subject to} &amp; \quad w_g \geq 0, \sum_{g = 1}^G w_g = 1
\end{aligned}
</code>
</p>

<p>to find the optimal stacking weights <code class="reqn">\hat{w}_1, \ldots, \hat{w}_G</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>spGLMstack</code>, which is a list including the
following tags -
</p>

<dl>
<dt><code>family</code></dt><dd><p>the distribution of the responses as indicated in the
function call</p>
</dd>
<dt><code>samples</code></dt><dd><p>a list of length equal to total number of candidate models
with each entry corresponding to a list of length 3, containing posterior
samples of fixed effects (<code>beta</code>), spatial effects (<code>z</code>) and
fine-scale variation term (<code>xi</code>) for that particular model.</p>
</dd>
<dt><code>loopd</code></dt><dd><p>a list of length equal to total number of candidate models with
each entry containing leave-one-out predictive densities under that
particular model.</p>
</dd>
<dt><code>loopd.method</code></dt><dd><p>a list containing details of the algorithm used for
calculation of leave-one-out predictive densities.</p>
</dd>
<dt><code>n.models</code></dt><dd><p>number of candidate models that are fit.</p>
</dd>
<dt><code>candidate.models</code></dt><dd><p>a matrix with <code>n_model</code> rows with each row
containing details of the model parameters and its optimal weight.</p>
</dd>
<dt><code>stacking.weights</code></dt><dd><p>a numeric vector of length equal to the number of
candidate models storing the optimal stacking weights.</p>
</dd>
<dt><code>run.time</code></dt><dd><p>a <code>proc_time</code> object with runtime details.</p>
</dd>
<dt><code>solver.status</code></dt><dd><p>solver status as returned by the optimization
routine.</p>
</dd>
</dl>

<p>The return object might include additional data that is useful for subsequent
prediction, model fit evaluation and other utilities.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Pan S, Zhang L, Bradley JR, Banerjee S (2024). &quot;Bayesian
Inference for Spatial-temporal Non-Gaussian Data Using Predictive Stacking.&quot;
<a href="https://doi.org/10.48550/arXiv.2406.04655">doi:10.48550/arXiv.2406.04655</a>.
</p>
<p>Vehtari A, Simpson D, Gelman A, Yao Y, Gabry J (2024). &quot;Pareto
Smoothed Importance Sampling.&quot; <em>Journal of Machine Learning Research</em>,
<strong>25</strong>(72), 1-58. URL <a href="https://jmlr.org/papers/v25/19-556.html">https://jmlr.org/papers/v25/19-556.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spGLMexact">spGLMexact()</a></code>, <code><a href="#topic+spLMstack">spLMstack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("simPoisson")
dat &lt;- simPoisson[1:100,]
mod1 &lt;- spGLMstack(y ~ x1, data = dat, family = "poisson",
                   coords = as.matrix(dat[, c("s1", "s2")]), cor.fn = "matern",
                  params.list = list(phi = c(3, 7, 10), nu = c(0.25, 0.5, 1.5),
                                     boundary = c(0.5, 0.6)),
                  n.samples = 1000,
                  loopd.controls = list(method = "CV", CV.K = 10, nMC = 1000),
                  parallel = TRUE, solver = "ECOS", verbose = TRUE)

# print(mod1$solver.status)
# print(mod1$run.time)

post_samps &lt;- stackedSampler(mod1)
post_beta &lt;- post_samps$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))

post_z &lt;- post_samps$z
post_z_summ &lt;- t(apply(post_z, 1, function(x) quantile(x, c(0.025, 0.5, 0.975))))

z_combn &lt;- data.frame(z = dat$z_true,
                      zL = post_z_summ[, 1],
                      zM = post_z_summ[, 2],
                      zU = post_z_summ[, 3])

library(ggplot2)
plot_z &lt;- ggplot(data = z_combn, aes(x = z)) +
 geom_errorbar(aes(ymin = zL, ymax = zU),
               width = 0.05, alpha = 0.15,
               color = "skyblue") +
 geom_point(aes(y = zM), size = 0.25,
            color = "darkblue", alpha = 0.5) +
 geom_abline(slope = 1, intercept = 0,
             color = "red", linetype = "solid") +
 xlab("True z") + ylab("Posterior of z") +
 theme_bw() +
 theme(panel.background = element_blank(),
       aspect.ratio = 1)

</code></pre>

<hr>
<h2 id='spLMexact'>Univariate Bayesian spatial linear model</h2><span id='topic+spLMexact'></span>

<h3>Description</h3>

<p>Fits a Bayesian spatial linear model with spatial process
parameters and the noise-to-spatial variance ratio fixed to a value supplied
by the user. The output contains posterior samples of the fixed effects,
variance parameter, spatial random effects and, if required, leave-one-out
predictive densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spLMexact(
  formula,
  data = parent.frame(),
  coords,
  cor.fn,
  priors,
  spParams,
  noise_sp_ratio,
  n.samples,
  loopd = FALSE,
  loopd.method = "exact",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spLMexact_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be fit.
See example below.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spLMexact</code> is called.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">\mathbb{R}^2</code> (e.g., easting and northing).</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_cor.fn">cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.
See below for details.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name and
containing prior details.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_spparams">spParams</code></td>
<td>
<p>fixed value of spatial process parameters.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_noise_sp_ratio">noise_sp_ratio</code></td>
<td>
<p>noise-to-spatial variance ratio.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_n.samples">n.samples</code></td>
<td>
<p>number of posterior samples to be generated.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_loopd">loopd</code></td>
<td>
<p>logical. If <code>loopd=TRUE</code>, returns leave-one-out predictive
densities, using method as given by <code>loopd.method</code>. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_loopd.method">loopd.method</code></td>
<td>
<p>character. Ignored if <code>loopd=FALSE</code>. If <code>loopd=TRUE</code>,
valid inputs are <code>'exact'</code> and <code>'PSIS'</code>. The option <code>'exact'</code> corresponds to
exact leave-one-out predictive densities which requires computation almost
equivalent to fitting the model <code class="reqn">n</code> times. The option <code>'PSIS'</code> is
faster and finds approximate leave-one-out predictive densities using
Pareto-smoothed importance sampling (Gelman <em>et al.</em> 2024).</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>verbose = TRUE</code>, prints model description.</p>
</td></tr>
<tr><td><code id="spLMexact_+3A_...">...</code></td>
<td>
<p>currently no additional argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">\chi = (s_1, \ldots, s_n)</code> denotes the <code class="reqn">n</code>
spatial locations the response <code class="reqn">y</code> is observed. With this function, we
fit a conjugate Bayesian hierarchical spatial model
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
y \mid z, \beta, \sigma^2 &amp;\sim N(X\beta + z, \delta^2 \sigma^2 I_n), \quad
z \mid \sigma^2 \sim N(0, \sigma^2 R(\chi; \phi, \nu)), \\
\beta \mid \sigma^2 &amp;\sim N(\mu_\beta, \sigma^2 V_\beta), \quad
\sigma^2 \sim \mathrm{IG}(a_\sigma, b_\sigma)
\end{aligned}
</code>
</p>

<p>where we fix the spatial process parameters <code class="reqn">\phi</code> and <code class="reqn">\nu</code>, the
noise-to-spatial variance ratio <code class="reqn">\delta^2</code> and the hyperparameters
<code class="reqn">\mu_\beta</code>, <code class="reqn">V_\beta</code>, <code class="reqn">a_\sigma</code> and <code class="reqn">b_\sigma</code>. We utilize
a composition sampling strategy to sample the model parameters from their
joint posterior distribution which can be written as
</p>
<p style="text-align: center;"><code class="reqn">
p(\sigma^2, \beta, z \mid y) = p(\sigma^2 \mid y) \times
p(\beta \mid \sigma^2, y) \times p(z \mid \beta, \sigma^2, y).
</code>
</p>

<p>We proceed by first sampling <code class="reqn">\sigma^2</code> from its marginal posterior,
then given the samples of <code class="reqn">\sigma^2</code>, we sample <code class="reqn">\beta</code> and
subsequently, we sample <code class="reqn">z</code> conditioned on the posterior samples of
<code class="reqn">\beta</code> and <code class="reqn">\sigma^2</code> (Banerjee 2020).
</p>


<h3>Value</h3>

<p>An object of class <code>spLMexact</code>, which is a list with the
following tags -
</p>

<dl>
<dt>samples</dt><dd><p>a list of length 3, containing posterior samples of fixed
effects (<code>beta</code>), variance parameter (<code>sigmaSq</code>), spatial effects
(<code>z</code>).</p>
</dd>
<dt>loopd</dt><dd><p>If <code>loopd=TRUE</code>, contains leave-one-out predictive
densities.</p>
</dd>
<dt>model.params</dt><dd><p>Values of the fixed parameters that includes
<code>phi</code> (spatial decay), <code>nu</code> (spatial smoothness) and
<code>noise_sp_ratio</code> (noise-to-spatial variance ratio).</p>
</dd>
</dl>

<p>The return object might include additional data used for subsequent
prediction and/or model fit evaluation.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Banerjee S (2020). &quot;Modeling massive spatial datasets using a
conjugate Bayesian linear modeling framework.&quot; <em>Spatial Statistics</em>, <strong>37</strong>,
100417. ISSN 2211-6753. <a href="https://doi.org/10.1016/j.spasta.2020.100417">doi:10.1016/j.spasta.2020.100417</a>.
</p>
<p>Vehtari A, Simpson D, Gelman A, Yao Y, Gabry J (2024). &quot;Pareto
Smoothed Importance Sampling.&quot; <em>Journal of Machine Learning Research</em>,
<strong>25</strong>(72), 1-58. URL <a href="https://jmlr.org/papers/v25/19-556.html">https://jmlr.org/papers/v25/19-556.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLMstack">spLMstack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(simGaussian)
dat &lt;- simGaussian[1:100, ]

# setup prior list
muBeta &lt;- c(0, 0)
VBeta &lt;- cbind(c(1.0, 0.0), c(0.0, 1.0))
sigmaSqIGa &lt;- 2
sigmaSqIGb &lt;- 0.1
prior_list &lt;- list(beta.norm = list(muBeta, VBeta),
                   sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))

# supply fixed values of model parameters
phi0 &lt;- 3
nu0 &lt;- 0.75
noise.sp.ratio &lt;- 0.8

mod1 &lt;- spLMexact(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  priors = prior_list,
                  spParams = list(phi = phi0, nu = nu0),
                  noise_sp_ratio = noise.sp.ratio,
                  n.samples = 100,
                  loopd = TRUE, loopd.method = "exact")

beta.post &lt;- mod1$samples$beta
z.post.median &lt;- apply(mod1$samples$z, 1, median)
dat$z.post.median &lt;- z.post.median
plot1 &lt;- surfaceplot(dat, coords_name = c("s1", "s2"),
                     var_name = "z_true")
plot2 &lt;- surfaceplot(dat, coords_name = c("s1", "s2"),
                     var_name = "z.post.median")
plot1
plot2
</code></pre>

<hr>
<h2 id='spLMstack'>Bayesian spatial linear model using predictive stacking</h2><span id='topic+spLMstack'></span>

<h3>Description</h3>

<p>Fits Bayesian spatial linear model on a collection of candidate
models constructed based on some candidate values of some model parameters
specified by the user and subsequently combines inference by stacking
predictive densities. See Zhang, Tang and Banerjee (2024) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spLMstack(
  formula,
  data = parent.frame(),
  coords,
  cor.fn,
  priors,
  params.list,
  n.samples,
  loopd.method,
  parallel = FALSE,
  solver = "ECOS",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spLMstack_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model to be fit.
See example below.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>spLMstack</code> is called.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">\mathbb{R}^2</code> (e.g., easting and northing).</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_cor.fn">cor.fn</code></td>
<td>
<p>a quoted keyword that specifies the correlation function used
to model the spatial dependence structure among the observations. Supported
covariance model key words are: <code>'exponential'</code> and <code>'matern'</code>.
See below for details.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_priors">priors</code></td>
<td>
<p>a list with each tag corresponding to a parameter name and
containing prior details. If not supplied, uses defaults.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_params.list">params.list</code></td>
<td>
<p>a list containing candidate values of spatial process
parameters for the <code>cor.fn</code> used, and, noise-to-spatial variance ratio.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_n.samples">n.samples</code></td>
<td>
<p>number of posterior samples to be generated.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_loopd.method">loopd.method</code></td>
<td>
<p>character. Valid inputs are <code>'exact'</code> and <code>'PSIS'</code>. The
option <code>'exact'</code> corresponds to exact leave-one-out predictive densities.
The option <code>'PSIS'</code> is faster, as it finds approximate leave-one-out
predictive densities using Pareto-smoothed importance sampling
(Gelman <em>et al.</em> 2024).</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>parallel=FALSE</code>, the parallelization plan,
if set up by the user, is ignored. If <code>parallel=TRUE</code>, the function
inherits the parallelization plan that is set by the user via the function
<code><a href="future.html#topic+plan">future::plan()</a></code> only. Depending on the parallel backend available, users
may choose their own plan. More details are available at
<a href="https://cran.R-project.org/package=future">https://cran.R-project.org/package=future</a>.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_solver">solver</code></td>
<td>
<p>(optional) Specifies the name of the solver that will be used
to obtain optimal stacking weights for each candidate model. Default is
<code>"ECOS"</code>. Users can use other solvers supported by the
<a href="CVXR.html#topic+CVXR-package">CVXR-package</a> package.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, prints model-specific optimal
stacking weights.</p>
</td></tr>
<tr><td><code id="spLMstack_+3A_...">...</code></td>
<td>
<p>currently no additional argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of assigning a prior on the process parameters <code class="reqn">\phi</code>
and <code class="reqn">\nu</code>, noise-to-spatial variance ratio <code class="reqn">\delta^2</code>, we consider
a set of candidate models based on some candidate values of these parameters
supplied by the user. Suppose the set of candidate models is
<code class="reqn">\mathcal{M} = \{M_1, \ldots, M_G\}</code>. Then for each
<code class="reqn">g = 1, \ldots, G</code>, we sample from the posterior distribution
<code class="reqn">p(\sigma^2, \beta, z \mid y, M_g)</code> under the model <code class="reqn">M_g</code> and find
leave-one-out predictive densities <code class="reqn">p(y_i \mid y_{-i}, M_g)</code>. Then we
solve the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">
 \begin{aligned}
 \max_{w_1, \ldots, w_G}&amp; \, \frac{1}{n} \sum_{i = 1}^n \log \sum_{g = 1}^G
 w_g p(y_i \mid y_{-i}, M_g) \\
 \text{subject to} &amp; \quad w_g \geq 0, \sum_{g = 1}^G w_g = 1
 \end{aligned}
 </code>
</p>

<p>to find the optimal stacking weights <code class="reqn">\hat{w}_1, \ldots, \hat{w}_G</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>spLMstack</code>, which is a list including the
following tags -
</p>

<dl>
<dt><code>samples</code></dt><dd><p>a list of length equal to total number of candidate models
with each entry corresponding to a list of length 3, containing posterior
samples of fixed effects (<code>beta</code>), variance parameter
(<code>sigmaSq</code>), spatial effects (<code>z</code>) for that model.</p>
</dd>
<dt><code>loopd</code></dt><dd><p>a list of length equal to total number of candidate models with
each entry containing leave-one-out predictive densities under that
particular model.</p>
</dd>
<dt><code>n.models</code></dt><dd><p>number of candidate models that are fit.</p>
</dd>
<dt><code>candidate.models</code></dt><dd><p>a matrix with <code>n_model</code> rows with each row
containing details of the model parameters and its optimal weight.</p>
</dd>
<dt><code>stacking.weights</code></dt><dd><p>a numeric vector of length equal to the number of
candidate models storing the optimal stacking weights.</p>
</dd>
<dt><code>run.time</code></dt><dd><p>a <code>proc_time</code> object with runtime details.</p>
</dd>
<dt><code>solver.status</code></dt><dd><p>solver status as returned by the optimization
routine.</p>
</dd>
</dl>

<p>The return object might include additional data that is useful for subsequent
prediction, model fit evaluation and other utilities.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>References</h3>

<p>Vehtari A, Simpson D, Gelman A, Yao Y, Gabry J (2024). &quot;Pareto
Smoothed Importance Sampling.&quot; <em>Journal of Machine Learning Research</em>,
<strong>25</strong>(72), 1-58. URL <a href="https://jmlr.org/papers/v25/19-556.html">https://jmlr.org/papers/v25/19-556.html</a>.
</p>
<p>Zhang L, Tang W, Banerjee S (2024). &quot;Bayesian Geostatistics Using
Predictive Stacking.&quot; <br />
<a href="https://doi.org/10.48550/arXiv.2304.12414">doi:10.48550/arXiv.2304.12414</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLMexact">spLMexact()</a></code>, <code><a href="#topic+spGLMstack">spGLMstack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data and work with first 100 rows
data(simGaussian)
dat &lt;- simGaussian[1:100, ]

# setup prior list
muBeta &lt;- c(0, 0)
VBeta &lt;- cbind(c(1.0, 0.0), c(0.0, 1.0))
sigmaSqIGa &lt;- 2
sigmaSqIGb &lt;- 2
prior_list &lt;- list(beta.norm = list(muBeta, VBeta),
                   sigma.sq.ig = c(sigmaSqIGa, sigmaSqIGb))

mod1 &lt;- spLMstack(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  priors = prior_list,
                  params.list = list(phi = c(1.5, 3),
                                     nu = c(0.5, 1),
                                     noise_sp_ratio = c(1)),
                  n.samples = 1000, loopd.method = "exact",
                  parallel = FALSE, solver = "ECOS", verbose = TRUE)

post_samps &lt;- stackedSampler(mod1)
post_beta &lt;- post_samps$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))

post_z &lt;- post_samps$z
post_z_summ &lt;- t(apply(post_z, 1,
                       function(x) quantile(x, c(0.025, 0.5, 0.975))))

z_combn &lt;- data.frame(z = dat$z_true,
                      zL = post_z_summ[, 1],
                      zM = post_z_summ[, 2],
                      zU = post_z_summ[, 3])

library(ggplot2)
plot1 &lt;- ggplot(data = z_combn, aes(x = z)) +
  geom_point(aes(y = zM), size = 0.25,
             color = "darkblue", alpha = 0.5) +
  geom_errorbar(aes(ymin = zL, ymax = zU),
                width = 0.05, alpha = 0.15) +
  geom_abline(slope = 1, intercept = 0,
              color = "red", linetype = "solid") +
  xlab("True z") + ylab("Stacked posterior of z") +
  theme_bw() +
  theme(panel.background = element_blank(),
        aspect.ratio = 1)
</code></pre>

<hr>
<h2 id='stackedSampler'>Sample from the stacked posterior distribution</h2><span id='topic+stackedSampler'></span>

<h3>Description</h3>

<p>A helper function to sample from the stacked posterior
distribution to obtain final posterior samples that can be used for
subsequent analysis. This function applies on outputs of functions
<code><a href="#topic+spLMstack">spLMstack()</a></code> and <code><a href="#topic+spGLMstack">spGLMstack()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackedSampler(mod_out, n.samples)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackedSampler_+3A_mod_out">mod_out</code></td>
<td>
<p>an object of class <code>spLMstack</code> or <code>spGLMstack</code>.</p>
</td></tr>
<tr><td><code id="stackedSampler_+3A_n.samples">n.samples</code></td>
<td>
<p>(optional) If missing, inherits the number
of posterior samples from the original output. Otherwise, it specifies
number of posterior samples to draw from the stacked posterior. If it exceeds
the number of posterior draws used in the original function, then a warning
is thrown and the samples are obtained by resampling. It is recommended, to
run the original function with enough samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After obtaining the optimal stacking weights
<code class="reqn">\hat{w}_1, \ldots, \hat{w}_G</code>, posterior inference of quantities of
interest subsequently proceed from the <em>stacked</em> posterior,
</p>
<p style="text-align: center;"><code class="reqn">
\tilde{p}(\cdot \mid y) = \sum_{g = 1}^G \hat{w}_g p(\cdot \mid y, M_g),
</code>
</p>

<p>where <code class="reqn">\mathcal{M} = \{M_1, \ldots, M_g\}</code> is the collection of candidate
models.
</p>


<h3>Value</h3>

<p>An object of class <code>stacked_posterior</code>, which is a list that
includes the following tags -
</p>

<dl>
<dt>beta</dt><dd><p>samples of the fixed effect from the stacked joint posterior.</p>
</dd>
<dt>z</dt><dd><p>samples of the spatial random effects from the stacked joint
posterior.</p>
</dd>
</dl>

<p>In case of model output of class <code>spLMstack</code>, the list additionally contains
<code>sigmaSq</code> which are the samples of the variance parameter from the stacked
joint posterior of the spatial linear model. For model output of class
<code>spGLMstack</code>, the list also contains <code>xi</code> which are the samples of the
fine-scale variation term from the stacked joint posterior of the spatial
generalized linear model.
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spLMstack">spLMstack()</a></code>, <code><a href="#topic+spGLMstack">spGLMstack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
dat &lt;- simGaussian[1:100, ]

mod1 &lt;- spLMstack(y ~ x1, data = dat,
                  coords = as.matrix(dat[, c("s1", "s2")]),
                  cor.fn = "matern",
                  params.list = list(phi = c(1.5, 3),
                                     nu = c(0.5, 1),
                                     noise_sp_ratio = c(1)),
                  n.samples = 1000, loopd.method = "exact",
                  parallel = FALSE, solver = "ECOS", verbose = TRUE)
print(mod1$solver.status)
print(mod1$run.time)

post_samps &lt;- stackedSampler(mod1)
post_beta &lt;- post_samps$beta
print(t(apply(post_beta, 1, function(x) quantile(x, c(0.025, 0.5, 0.975)))))
</code></pre>

<hr>
<h2 id='surfaceplot'>Make a surface plot</h2><span id='topic+surfaceplot'></span>

<h3>Description</h3>

<p>Make a surface plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceplot(tab, coords_name, var_name, h = 8, col.pal, mark_points = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaceplot_+3A_tab">tab</code></td>
<td>
<p>a data-frame containing spatial co-ordinates and the variable to
plot</p>
</td></tr>
<tr><td><code id="surfaceplot_+3A_coords_name">coords_name</code></td>
<td>
<p>name of the two columns that contains the co-ordinates of
the points</p>
</td></tr>
<tr><td><code id="surfaceplot_+3A_var_name">var_name</code></td>
<td>
<p>name of the column containing the variable to be plotted</p>
</td></tr>
<tr><td><code id="surfaceplot_+3A_h">h</code></td>
<td>
<p>integer; (optional) controls smoothness of the spatial interpolation
as appearing in the <code><a href="MBA.html#topic+mba.surf">MBA::mba.surf()</a></code> function. Default is 8.</p>
</td></tr>
<tr><td><code id="surfaceplot_+3A_col.pal">col.pal</code></td>
<td>
<p>Optional; color palette, preferably divergent, use
<code>colorRampPalette</code> function from <code>grDevices</code>. Default is 'RdYlBu'.</p>
</td></tr>
<tr><td><code id="surfaceplot_+3A_mark_points">mark_points</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the input points are marked.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object containing the surface plot
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
plot1 &lt;- surfaceplot(simGaussian, coords_name = c("s1", "s2"),
                     var_name = "z_true")
plot1

# try your favourite color palette
col.br &lt;- colorRampPalette(c("blue", "white", "red"))
col.br.pal &lt;- col.br(100)
plot2 &lt;- surfaceplot(simGaussian, coords_name = c("s1", "s2"),
                     var_name = "z_true", col.pal = col.br.pal)
plot2
</code></pre>

<hr>
<h2 id='surfaceplot2'>Make two side-by-side surface plots</h2><span id='topic+surfaceplot2'></span>

<h3>Description</h3>

<p>Make two side-by-side surface plots, particularly useful towards
a comparative study of two spatial surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceplot2(
  tab,
  coords_name,
  var1_name,
  var2_name,
  h = 8,
  col.pal,
  mark_points = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaceplot2_+3A_tab">tab</code></td>
<td>
<p>a data-frame containing spatial co-ordinates and the variables to
plot</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_coords_name">coords_name</code></td>
<td>
<p>name of the two columns that contains the co-ordinates of
the points</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_var1_name">var1_name</code></td>
<td>
<p>name of the column containing the first variable to be
plotted</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_var2_name">var2_name</code></td>
<td>
<p>name of the column containing the second variable to be
plotted</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_h">h</code></td>
<td>
<p>integer; (optional) controls smoothness of the spatial interpolation
as appearing in the <code><a href="MBA.html#topic+mba.surf">MBA::mba.surf()</a></code> function. Default is 8.</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_col.pal">col.pal</code></td>
<td>
<p>Optional; color palette, preferably divergent, use
<code>colorRampPalette</code> function from <code>grDevices</code>. Default is 'RdYlBu'.</p>
</td></tr>
<tr><td><code id="surfaceplot2_+3A_mark_points">mark_points</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the input points are marked.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing two <code>ggplot</code> objects
</p>


<h3>Author(s)</h3>

<p>Soumyakanti Pan <a href="mailto:span18@ucla.edu">span18@ucla.edu</a>,<br />
Sudipto Banerjee <a href="mailto:sudipto@ucla.edu">sudipto@ucla.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
plots_2 &lt;- surfaceplot2(simGaussian, coords_name = c("s1", "s2"),
                        var1_name = "z_true", var2_name = "y")
plots_2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
