<!DOCTYPE html><html><head><title>Help for package polyCub</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polyCub}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkintrfr'><p>Check the Integral of <code class="reqn">r f_r(r)</code></p></a></li>
<li><a href='#circleCub.Gauss'><p>Integration of the Isotropic Gaussian Density over Circular Domains</p></a></li>
<li><a href='#coerce-gpc-methods'><p>Conversion between polygonal <code>"owin"</code> and <code>"gpc.poly"</code></p></a></li>
<li><a href='#coerce-sp-methods'><p>Coerce <code>"SpatialPolygons"</code> to <code>"owin"</code></p></a></li>
<li><a href='#dotprod'><p>Dot/Scalar Product of Two Vectors</p></a></li>
<li><a href='#gpclibPermit'><p><span class="pkg">gpclib</span> License Acceptance (OBSOLETE)</p></a></li>
<li><a href='#isClosed'><p>Check if Polygon is Closed</p></a></li>
<li><a href='#isScalar'><p>Checks if Argument is Scalar</p></a></li>
<li><a href='#plot_polyregion'><p>Plots a Polygonal Domain (of Various Classes)</p></a></li>
<li><a href='#plotpolyf'><p>Plot Polygonal Domain on Image of Bivariate Function</p></a></li>
<li><a href='#polyCub'><p>Wrapper Function for the Various Cubature Methods</p></a></li>
<li><a href='#polyCub-package'><p>Cubature over Polygonal Domains</p></a></li>
<li><a href='#polyCub.exact.Gauss'><p>Quasi-Exact Cubature of the Bivariate Normal Density (DEFUNCT)</p></a></li>
<li><a href='#polyCub.iso'><p>Cubature of Isotropic Functions over Polygonal Domains</p></a></li>
<li><a href='#polyCub.midpoint'><p>Two-Dimensional Midpoint Rule</p></a></li>
<li><a href='#polyCub.SV'><p>Product Gauss Cubature over Polygonal Domains</p></a></li>
<li><a href='#polygauss'><p>Calculate 2D Nodes and Weights of the Product Gauss Cubature</p></a></li>
<li><a href='#sfg2gpc'><p>Convert polygonal <code>"sfg"</code> to <code>"gpc.poly"</code></p></a></li>
<li><a href='#vecnorm'><p>Euclidean Vector Norm (Length)</p></a></li>
<li><a href='#xylist'><p>Convert Various Polygon Classes to a Simple List of Vertices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cubature over Polygonal Domains</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Numerical integration of continuously differentiable
    functions f(x,y) over simple closed polygonal domains.
    The following cubature methods are implemented:
    product Gauss cubature (Sommariva and Vianello, 2007,
    &lt;<a href="https://doi.org/10.1007%2Fs10543-007-0131-2">doi:10.1007/s10543-007-0131-2</a>&gt;),
    the simple two-dimensional midpoint rule
    (wrapping 'spatstat.geom' functions), and
    adaptive cubature for radially symmetric functions via line
    integrate() along the polygon boundary (Meyer and Held, 2014,
    &lt;<a href="https://doi.org/10.1214%2F14-AOAS743">doi:10.1214/14-AOAS743</a>&gt;, Supplement B).
    For simple integration along the axes, the 'cubature' package
    is more appropriate.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bastistician/polyCub">https://github.com/bastistician/polyCub</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bastistician/polyCub/issues">https://github.com/bastistician/polyCub/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, sp (&ge; 1.0-11)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spatstat.geom, lattice, mvtnorm, statmod, sf, cubature,
knitr, rmarkdown, microbenchmark</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-25 10:27:24 UTC; smeyer</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Meyer <a href="https://orcid.org/0000-0002-1791-9449"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, trl],
  Leonhard Held [ths],
  Michael Hoehle [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Meyer &lt;seb.meyer@fau.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkintrfr'>Check the Integral of <code class="reqn">r f_r(r)</code></h2><span id='topic+checkintrfr'></span>

<h3>Description</h3>

<p>This function is auxiliary to <code><a href="#topic+polyCub.iso">polyCub.iso</a></code>.
The (analytical) integral of <code class="reqn">r f_r(r)</code> from 0 to <code class="reqn">R</code> is checked
against a numeric approximation using <code><a href="stats.html#topic+integrate">integrate</a></code> for various
values of the upper bound <code class="reqn">R</code>. A warning is issued if inconsistencies
are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkintrfr(intrfr, f, ..., center, control = list(), rs = numeric(0L),
  tolerance = control$rel.tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkintrfr_+3A_intrfr">intrfr</code></td>
<td>
<p>a <code>function(R, ...)</code>, which implements the (analytical)
antiderivative of <code class="reqn">r f_r(r)</code> from 0 to <code>R</code>. The first argument
must be vectorized but not necessarily named <code>R</code>.<br />
If <code>intrfr</code> is missing, it will be approximated numerically via
<code><a href="stats.html#topic+integrate">integrate</a>(function(r, ...)
r * f(cbind(x0 + r, y0), ...), 0, R, ..., control=control)</code>,
where <code>c(x0, y0)</code> is the <code>center</code> of isotropy.
Note that <code>f</code> will <em>not</em> be checked for isotropy.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function.
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_...">...</code></td>
<td>
<p>further arguments for <code>f</code> or <code>intrfr</code>.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_center">center</code></td>
<td>
<p>numeric vector of length 2, the center of isotropy.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_control">control</code></td>
<td>
<p>list of arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code>, the
quadrature rule used for the line integral along the polygon boundary.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_rs">rs</code></td>
<td>
<p>numeric vector of upper bounds for which to check the validity of
<code>intrfr</code>. If it has length 0 (default), no checks are performed.</p>
</td></tr>
<tr><td><code id="checkintrfr_+3A_tolerance">tolerance</code></td>
<td>
<p>of <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric</a></code> when comparing
<code>intrfr</code> results with numerical integration. Defaults to the
relative tolerance used for <code>integrate</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>intrfr</code> function. If it was not supplied, its quadrature
version using <code>integrate</code> is returned.
</p>

<hr>
<h2 id='circleCub.Gauss'>Integration of the Isotropic Gaussian Density over Circular Domains</h2><span id='topic+circleCub.Gauss'></span>

<h3>Description</h3>

<p>This function calculates the integral of the bivariate, isotropic Gaussian
density (i.e., <code class="reqn">\Sigma</code> = <code>sd^2*diag(2)</code>) over a circular domain
via the cumulative distribution function <code>pchisq</code> of the (non-central)
Chi-Squared distribution (Abramowitz and Stegun, 1972, Formula 26.3.24).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleCub.Gauss(center, r, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleCub.Gauss_+3A_center">center</code></td>
<td>
<p>numeric vector of length 2 (center of the circle).</p>
</td></tr>
<tr><td><code id="circleCub.Gauss_+3A_r">r</code></td>
<td>
<p>numeric (radius of the circle). Several radii may be supplied.</p>
</td></tr>
<tr><td><code id="circleCub.Gauss_+3A_mean">mean</code></td>
<td>
<p>numeric vector of length 2
(mean of the bivariate Gaussian density).</p>
</td></tr>
<tr><td><code id="circleCub.Gauss_+3A_sd">sd</code></td>
<td>
<p>numeric (common standard deviation of the isotropic
Gaussian density in both dimensions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integral value (one for each supplied radius).
</p>


<h3>Note</h3>

<p>The non-centrality parameter of the evaluated chi-squared distribution
equals the squared distance between the <code>mean</code> and the
<code>center</code>. If this becomes too large, the result becomes inaccurate, see
<code><a href="stats.html#topic+pchisq">pchisq</a></code>.
</p>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A. (1972).
Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical
Tables. New York: Dover Publications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circleCub.Gauss(center=c(1,2), r=3, mean=c(4,5), sd=6)

## compare with cubature over a polygonal approximation of a circle
## Not run: ## (this example requires gpclib)
disc.poly &lt;- spatstat.geom::disc(radius=3, centre=c(1,2), npoly=32)
polyCub.exact.Gauss(disc.poly, mean=c(4,5), Sigma=6^2*diag(2))

## End(Not run)
</code></pre>

<hr>
<h2 id='coerce-gpc-methods'>Conversion between polygonal <code>"owin"</code> and <code>"gpc.poly"</code></h2><span id='topic+coerce-gpc-methods'></span><span id='topic+owin2gpc'></span><span id='topic+gpc2owin'></span><span id='topic+as.owin.gpc.poly'></span>

<h3>Description</h3>

<p>Package <span class="pkg">polyCub</span> implements converters between the classes
<code>"<a href="spatstat.geom.html#topic+owin.object">owin</a>"</code> of package <a href="https://CRAN.R-project.org/package=spatstat.geom"><span class="pkg">spatstat.geom</span></a>
and <code>"gpc.poly"</code> of package <a href="https://CRAN.R-project.org/package=gpclib"><span class="pkg">gpclib</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>owin2gpc(object)

gpc2owin(object, ...)

as.owin.gpc.poly(W, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce-gpc-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gpc.poly"</code> or <code>"owin"</code>,
respectively.</p>
</td></tr>
<tr><td><code id="coerce-gpc-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.</p>
</td></tr>
<tr><td><code id="coerce-gpc-methods_+3A_w">W</code></td>
<td>
<p>an object of class <code>"gpc.poly"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted polygon of class <code>"gpc.poly"</code> or <code>"owin"</code>,
respectively. If package <span class="pkg">gpclib</span> is not available,
<code>owin2gpc</code> will just return the <code>pts</code> slot of the
<code>"gpc.poly"</code> (no formal class) with a warning.
</p>


<h3>Note</h3>

<p>The converter <code>owin2gpc</code> requires the package
<span class="pkg">gpclib</span> for the formal class definition of a <code>"gpc.poly"</code>.
It will produce vertices ordered according to the <span class="pkg">sp</span> convention,
i.e. clockwise for normal boundaries and anticlockwise for holes, where,
however, the first vertex is <em>not</em> repeated!
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xylist">xylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use example polygons from
example(plotpolyf, ask = FALSE)
letterR  # a simple "xylist"

letterR.owin &lt;- spatstat.geom::owin(poly = letterR)
letterR.gpc_from_owin &lt;- owin2gpc(letterR.owin)
## warns if "gpclib" is unavailable

if (is(letterR.gpc_from_owin, "gpc.poly")) {
  letterR.xylist_from_gpc &lt;- xylist(letterR.gpc_from_owin)
  stopifnot(all.equal(letterR, lapply(letterR.xylist_from_gpc, `[`, 1:2)))
  letterR.owin_from_gpc &lt;- gpc2owin(letterR.gpc_from_owin)
  stopifnot(all.equal(letterR.owin, letterR.owin_from_gpc))
}

</code></pre>

<hr>
<h2 id='coerce-sp-methods'>Coerce <code>"SpatialPolygons"</code> to <code>"owin"</code></h2><span id='topic+coerce-sp-methods'></span><span id='topic+as.owin.SpatialPolygons'></span><span id='topic+as.owin.Polygons'></span><span id='topic+as.owin.Polygon'></span><span id='topic+coerce+2CSpatialPolygons+2Cowin-method'></span><span id='topic+coerce+2CPolygons+2Cowin-method'></span><span id='topic+coerce+2CPolygon+2Cowin-method'></span><span id='topic+coerce+2CPolygon+2CPolygons-method'></span>

<h3>Description</h3>

<p>Package <span class="pkg">polyCub</span> implements <code>coerce</code>-methods
(<code>as(object, Class)</code>) to convert <code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>
(or <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code> or <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code>)
of package <a href="https://CRAN.R-project.org/package=sp"><span class="pkg">sp</span></a>
to <code>"<a href="spatstat.geom.html#topic+owin.object">owin</a>"</code>
of package <a href="https://CRAN.R-project.org/package=spatstat.geom"><span class="pkg">spatstat.geom</span></a>.
They are also available as <code>as.owin.*</code> functions to support
<code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.owin.SpatialPolygons(W, ...)

as.owin.Polygons(W, ...)

as.owin.Polygon(W, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce-sp-methods_+3A_w">W</code></td>
<td>
<p>an object of class <code>"SpatialPolygons"</code>,
<code>"Polygons"</code>, or <code>"Polygon"</code>.</p>
</td></tr>
<tr><td><code id="coerce-sp-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="spatstat.geom.html#topic+owin">owin</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xylist">xylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("spatstat.geom") &amp;&amp; require("sp")) {
    diamond &lt;- list(x = c(1,2,1,0), y = c(1,2,3,2))  # anti-clockwise
    diamond.owin &lt;- owin(poly = diamond)
    diamond.sp &lt;- Polygon(lapply(diamond, rev))      # clockwise
    stopifnot(identical(xylist(diamond.sp), list(diamond)))
    diamond.owin_from_sp &lt;- as.owin(diamond.sp)
    stopifnot(all.equal(diamond.owin, diamond.owin_from_sp))

    ## similarly works for Polygons and SpatialPolygons
    diamond.Ps &lt;- as(diamond.sp, "Polygons")
    stopifnot(identical(diamond.owin, as.owin(diamond.Ps)))
    diamond.SpPs &lt;- SpatialPolygons(list(diamond.Ps))
    stopifnot(identical(xylist(diamond.SpPs), list(diamond)))
    stopifnot(identical(diamond.owin, as.owin(diamond.SpPs)))
}
</code></pre>

<hr>
<h2 id='dotprod'>Dot/Scalar Product of Two Vectors</h2><span id='topic+dotprod'></span>

<h3>Description</h3>

<p>This is nothing else than <code>sum(x*y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotprod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotprod_+3A_x">x</code>, <code id="dotprod_+3A_y">y</code></td>
<td>
<p>numeric vectors (of compatible lengths).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sum(x*y)</code>
</p>

<hr>
<h2 id='gpclibPermit'><span class="pkg">gpclib</span> License Acceptance (OBSOLETE)</h2><span id='topic+gpclibPermit'></span><span id='topic+gpclibPermitStatus'></span>

<h3>Description</h3>

<p>Previous versions of package <a href="https://CRAN.R-project.org/package=gpclib"><span class="pkg">gpclib</span></a> had a restricted license
(commercial use prohibited) and these functions were used as a blocker.
They now always return <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpclibPermit()

gpclibPermitStatus()
</code></pre>


<h3>Details</h3>

<p><span class="pkg">gpclib</span> functionality is only required for
<code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a></code>.
</p>

<hr>
<h2 id='isClosed'>Check if Polygon is Closed</h2><span id='topic+isClosed'></span>

<h3>Description</h3>

<p>Check if the first and last coordinates of a coordinate matrix are
identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isClosed(coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isClosed_+3A_coords">coords</code></td>
<td>
<p>numeric coordinate matrix. It is interpreted by
<code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='isScalar'>Checks if Argument is Scalar</h2><span id='topic+isScalar'></span>

<h3>Description</h3>

<p>Check if the argument is scalar, i.e. a numeric vector of length 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isScalar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isScalar_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='plot_polyregion'>Plots a Polygonal Domain (of Various Classes)</h2><span id='topic+plot_polyregion'></span>

<h3>Description</h3>

<p>Plots a Polygonal Domain (of Various Classes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_polyregion(polyregion, lwd = 2, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_polyregion_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal domain.
The following classes are supported:
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>,
<code>"gpc.poly"</code> from <span class="pkg">gpclib</span>,
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code>,
and <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> from package <span class="pkg">sp</span>, as well as
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>.
(For these classes, <span class="pkg">polyCub</span> knows how to get an <code><a href="#topic+xylist">xylist</a></code>.)</p>
</td></tr>
<tr><td><code id="plot_polyregion_+3A_lwd">lwd</code></td>
<td>
<p>line width of the polygon edges.</p>
</td></tr>
<tr><td><code id="plot_polyregion_+3A_add">add</code></td>
<td>
<p>logical. Add to existing plot?</p>
</td></tr>
</table>

<hr>
<h2 id='plotpolyf'>Plot Polygonal Domain on Image of Bivariate Function</h2><span id='topic+plotpolyf'></span>

<h3>Description</h3>

<p>Produces a combined plot of a polygonal domain and an image of a bivariate
function, using either <code><a href="lattice.html#topic+levelplot">lattice::levelplot</a></code>
or <code><a href="Matrix.html#topic+image">image</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpolyf(polyregion, f, ..., npixel = 100, cuts = 15,
  col = rev(heat.colors(cuts + 1)), lwd = 3, xlim = NULL, ylim = NULL,
  use.lattice = TRUE, print.args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpolyf_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal domain.
The following classes are supported:
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>,
<code>"gpc.poly"</code> from <span class="pkg">gpclib</span>,
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code>,
and <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> from package <span class="pkg">sp</span>, as well as
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>.
(For these classes, <span class="pkg">polyCub</span> knows how to get an <code><a href="#topic+xylist">xylist</a></code>.)</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function.
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_...">...</code></td>
<td>
<p>further arguments for <code>f</code>.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_npixel">npixel</code></td>
<td>
<p>numeric vector of length 1 or 2 setting the number of pixels
in each dimension.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_cuts">cuts</code></td>
<td>
<p>number of cut points in the <code class="reqn">z</code> dimension.
The range of function values will be divided into <code>cuts+1</code> levels.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_col">col</code></td>
<td>
<p>color vector used for the function levels.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_lwd">lwd</code></td>
<td>
<p>line width of the polygon edges.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_xlim">xlim</code>, <code id="plotpolyf_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2 setting the axis limits.
<code>NULL</code> means using the bounding box of <code>polyregion</code>.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_use.lattice">use.lattice</code></td>
<td>
<p>logical indicating if <span class="pkg">lattice</span> graphics
(<code><a href="lattice.html#topic+levelplot">levelplot</a></code>) should be used.</p>
</td></tr>
<tr><td><code id="plotpolyf_+3A_print.args">print.args</code></td>
<td>
<p>a list of arguments passed to <code><a href="lattice.html#topic+print.trellis">print.trellis</a></code>
for plotting the produced <code><a href="lattice.html#topic+trellis.object">&quot;trellis&quot;</a></code> object
(given <code>use.lattice = TRUE</code>). The latter will be returned without
explicit <code>print</code>ing if <code>print.args</code> is not a list.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a polygonal domain (a simplified version of spatstat.data::letterR$bdry)
letterR &lt;- list(
    list(x = c(2.7, 3, 3.3, 3.9, 3.7, 3.4, 3.8, 3.7, 3.4, 2, 2, 2.7),
         y = c(1.7, 1.6, 0.7, 0.7, 1.3, 1.8, 2.2, 2.9, 3.3, 3.3, 0.7, 0.7)),
    list(x = c(2.6, 2.6, 3, 3.2, 3),
         y = c(2.2, 2.7, 2.7, 2.5, 2.2))
)

### f: isotropic exponential decay
fr &lt;- function(r, rate = 1) dexp(r, rate = rate)
fcenter &lt;- c(2,3)
f &lt;- function (s, rate = 1) fr(sqrt(rowSums(t(t(s)-fcenter)^2)), rate = rate)

### plot
plotpolyf(letterR, f, use.lattice = FALSE)
plotpolyf(letterR, f, use.lattice = TRUE)
</code></pre>

<hr>
<h2 id='polyCub'>Wrapper Function for the Various Cubature Methods</h2><span id='topic+polyCub'></span>

<h3>Description</h3>

<p>The wrapper function <code>polyCub</code> can be used to call specific cubature
methods via its <code>method</code> argument. It calls <code><a href="#topic+polyCub.SV">polyCub.SV</a></code>
by default, which implements general-purpose product Gauss cubature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyCub(polyregion, f, method = c("SV", "midpoint", "iso", "exact.Gauss"),
  ..., plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyCub_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal domain.
The following classes are supported:
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>,
<code>"gpc.poly"</code> from <span class="pkg">gpclib</span>,
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code>,
and <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> from package <span class="pkg">sp</span>, as well as
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>.
(For these classes, <span class="pkg">polyCub</span> knows how to get an <code><a href="#topic+xylist">xylist</a></code>.)</p>
</td></tr>
<tr><td><code id="polyCub_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function to be integrated over
<code>polyregion</code>. As its first argument it must take a coordinate matrix,
i.e., a numeric matrix with two columns, and it must return a numeric vector
of length the number of coordinates.<br />
For the <code>"exact.Gauss"</code> <code>method</code>,
<code>f</code> is ignored since it is specific to the bivariate normal density.</p>
</td></tr>
<tr><td><code id="polyCub_+3A_method">method</code></td>
<td>
<p>choose one of the implemented cubature methods (partial
argument matching is applied), see <code>help("<a href="#topic+polyCub-package">polyCub-package</a>")</code>
for an overview. Defaults to using product Gauss cubature
implemented in <code><a href="#topic+polyCub.SV">polyCub.SV</a></code>.</p>
</td></tr>
<tr><td><code id="polyCub_+3A_...">...</code></td>
<td>
<p>arguments of <code>f</code> or of the specific <code>method</code>.</p>
</td></tr>
<tr><td><code id="polyCub_+3A_plot">plot</code></td>
<td>
<p>logical indicating if an illustrative plot of the numerical
integration should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximated integral of <code>f</code> over <code>polyregion</code>.
</p>


<h3>See Also</h3>

<p>Details and examples in the <code>vignette("polyCub")</code>
and on the method-specific help pages.
</p>
<p>Other polyCub-methods: 
<code><a href="#topic+polyCub.SV">polyCub.SV</a>()</code>,
<code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a>()</code>,
<code><a href="#topic+polyCub.iso">polyCub.iso</a>()</code>,
<code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a>()</code>
</p>

<hr>
<h2 id='polyCub-package'>Cubature over Polygonal Domains</h2><span id='topic+polyCub-package'></span>

<h3>Description</h3>

<p>The <span class="rlang"><b>R</b></span> package <span class="pkg">polyCub</span> implements <em>cubature</em>
(numerical integration) over <em>polygonal</em> domains.
It solves the problem of integrating a continuously differentiable
function <code class="reqn">f(x,y)</code> over simple closed polygons.
</p>


<h3>Details</h3>

<p><span class="pkg">polyCub</span> provides the following cubature methods,
which can either be called explicitly or via the generic
<code><a href="#topic+polyCub">polyCub</a></code> function:
</p>

<dl>
<dt><code><a href="#topic+polyCub.SV">polyCub.SV</a></code>:</dt><dd>
<p>General-purpose <em>product Gauss cubature</em> (Sommariva and Vianello, 2007)
</p>
</dd>
<dt><code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a></code>:</dt><dd>
<p>Simple <em>two-dimensional midpoint rule</em> based on
<code><a href="spatstat.geom.html#topic+as.im.function">as.im.function</a></code> from <span class="pkg">spatstat.geom</span>
(Baddeley et al., 2015)
</p>
</dd>
<dt><code><a href="#topic+polyCub.iso">polyCub.iso</a></code>:</dt><dd>
<p>Adaptive cubature for <em>radially symmetric functions</em>
via line <code><a href="stats.html#topic+integrate">integrate</a>()</code> along the polygon boundary
(Meyer and Held, 2014, Supplement B, Section 2.4).
</p>
</dd>
</dl>

<p>A brief description and benchmark experiment of the above cubature
methods can be found in the <code>vignette("polyCub")</code>.
</p>
<p>There is also <code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a></code>, intended to
accurately (but slowly) integrate the <em>bivariate Gaussian density</em>;
however, this implementation is disabled as of <span class="pkg">polyCub</span> 0.9.0:
it needs a reliable implementation of polygon triangulation.
Meyer (2010, Section 3.2) discusses and compares some of these methods.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015).
<em>Spatial Point Patterns: Methodology and Applications with R</em>.
Chapman and Hall/CRC Press, London.
</p>
<p>Meyer, S. (2010).
<em>Spatio-Temporal Infectious Disease Epidemiology based on Point
Processes</em>. Master's Thesis, LMU Munich.
Available as <a href="https://epub.ub.uni-muenchen.de/11703/">https://epub.ub.uni-muenchen.de/11703/</a>.
</p>
<p>Meyer, S. and Held, L. (2014).
Power-law models for infectious disease spread.
<em>The Annals of Applied Statistics</em>, <b>8</b> (3), 1612-1639.
<a href="https://doi.org/10.1214/14-AOAS743">doi:10.1214/14-AOAS743</a>
</p>
<p>Sommariva, A. and Vianello, M. (2007).
Product Gauss cubature over polygons based on Green's integration formula.
<em>BIT Numerical Mathematics</em>, <b>47</b> (2), 441-453.
<a href="https://doi.org/10.1007/s10543-007-0131-2">doi:10.1007/s10543-007-0131-2</a>
</p>


<h3>See Also</h3>

<p><code>vignette("polyCub")</code>
</p>
<p>For the special case of a rectangular domain along the axes
(e.g., a bounding box), the <a href="https://CRAN.R-project.org/package=cubature"><span class="pkg">cubature</span></a> package is more appropriate.
</p>

<hr>
<h2 id='polyCub.exact.Gauss'>Quasi-Exact Cubature of the Bivariate Normal Density (DEFUNCT)</h2><span id='topic+polyCub.exact.Gauss'></span>

<h3>Description</h3>

<p>This cubature method is <strong>defunct</strong> as of <span class="pkg">polyCub</span> version 0.9.0.
It relied on <code>tristrip()</code> from package <a href="https://CRAN.R-project.org/package=gpclib"><span class="pkg">gpclib</span></a> for polygon
triangulation, but that package did not have a <abbr><span class="acronym">FOSS</span></abbr> license and
was no longer maintained on a mainstream repository.<br />
Contributions to resurrect this cubature method are welcome: an alternative
implementation for constrained polygon triangulation is needed, see
<a href="https://github.com/bastistician/polyCub/issues/2">https://github.com/bastistician/polyCub/issues/2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyCub.exact.Gauss(polyregion, mean = c(0, 0), Sigma = diag(2),
  plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyCub.exact.Gauss_+3A_polyregion">polyregion</code></td>
<td>
<p>a <code>"gpc.poly"</code> polygon or
something that can be coerced to this class, e.g., an <code>"owin"</code> polygon
(via <code><a href="#topic+owin2gpc">owin2gpc</a></code>), or an <code>"sfg"</code> polygon (via
<code><a href="#topic+sfg2gpc">sfg2gpc</a></code>).</p>
</td></tr>
<tr><td><code id="polyCub.exact.Gauss_+3A_mean">mean</code>, <code id="polyCub.exact.Gauss_+3A_sigma">Sigma</code></td>
<td>
<p>mean and covariance matrix of the bivariate normal density
to be integrated.</p>
</td></tr>
<tr><td><code id="polyCub.exact.Gauss_+3A_plot">plot</code></td>
<td>
<p>logical indicating if an illustrative plot of the numerical
integration should be produced. Note that the <code>polyregion</code> will be
transformed (shifted and scaled).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate Gaussian density can be integrated based on a triangulation of
the (transformed) polygonal domain, using formulae from the
Abramowitz and Stegun (1972) handbook (Section 26.9, Example 9, pp. 956f.).
This method is quite cumbersome because the A&amp;S formula is only for triangles
where one vertex is the origin (0,0). For each triangle
we have to check in which of the 6 outer
regions of the triangle the origin (0,0) lies and adapt the signs in the
formula appropriately: <code class="reqn">(AOB+BOC-AOC)</code> or <code class="reqn">(AOB-AOC-BOC)</code> or
<code class="reqn">(AOB+AOC-BOC)</code> or <code class="reqn">(AOC+BOC-AOB)</code> or ....
However, the most time consuming step is the
evaluation of <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.
</p>


<h3>Value</h3>

<p>The integral of the bivariate normal density over <code>polyregion</code>.
Two attributes are appended to the integral value:
</p>
<table>
<tr><td><code>nEval</code></td>
<td>

<p>number of triangles over which the standard bivariate normal density had to
be integrated, i.e. number of calls to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> and
<code><a href="stats.html#topic+pnorm">pnorm</a></code>, the former of which being the most time-consuming
operation.
</p>
</td></tr>
<tr><td><code>error</code></td>
<td>

<p>Approximate absolute integration error stemming from the error introduced by
the <code>nEval</code> <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> evaluations.
For this reason, the cubature method is in fact only
quasi-exact (as is the <code>pmvnorm</code> function).
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A. (1972).
Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical
Tables. New York: Dover Publications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleCub.Gauss">circleCub.Gauss</a></code> for quasi-exact cubature of the
isotropic Gaussian density over a circular domain.
</p>
<p>Other polyCub-methods: 
<code><a href="#topic+polyCub.SV">polyCub.SV</a>()</code>,
<code><a href="#topic+polyCub.iso">polyCub.iso</a>()</code>,
<code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a>()</code>,
<code><a href="#topic+polyCub">polyCub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a function to integrate (here: isotropic zero-mean Gaussian density)
f &lt;- function (s, sigma = 5)
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)

## a simple polygon as integration domain
hexagon &lt;- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)

## quasi-exact integration based on gpclib::tristrip() and mvtnorm::pmvnorm()
## Not run: ## (this example requires gpclib)
hexagon.gpc &lt;- new("gpc.poly", pts = lapply(hexagon, c, list(hole = FALSE)))
plotpolyf(hexagon.gpc, f, xlim = c(-8,8), ylim = c(-8,8))
print(polyCub.exact.Gauss(hexagon.gpc, mean = c(0,0), Sigma = 5^2*diag(2),
                          plot = TRUE), digits = 16)

## End(Not run)
</code></pre>

<hr>
<h2 id='polyCub.iso'>Cubature of Isotropic Functions over Polygonal Domains</h2><span id='topic+polyCub.iso'></span><span id='topic+.polyCub.iso'></span>

<h3>Description</h3>

<p><code>polyCub.iso</code> numerically integrates a radially symmetric function
<code class="reqn">f(x,y) = f_r(||(x,y)-\boldsymbol{\mu}||)</code>,
with <code class="reqn">\mu</code> being the center of isotropy, over a polygonal domain.
It internally approximates a line integral along the polygon boundary using
<code><a href="stats.html#topic+integrate">integrate</a></code>. The integrand requires the antiderivative of
<code class="reqn">r f_r(r)</code>), which should be supplied as argument <code>intrfr</code>
(<code>f</code> itself is only required if <code>check.intrfr=TRUE</code>).
The two-dimensional integration problem thereby reduces to an efficient
adaptive quadrature in one dimension.
If <code>intrfr</code> is not available analytically, <code>polyCub.iso</code> can use a
numerical approximation (meaning <code>integrate</code> within <code>integrate</code>),
but the general-purpose cubature method <code><a href="#topic+polyCub.SV">polyCub.SV</a></code> might be
more efficient in this case.
See Meyer and Held (2014, Supplement B, Section 2.4) for mathematical
details.
</p>
<p><code>.polyCub.iso</code> is a &ldquo;bare-bone&rdquo; version of <code>polyCub.iso</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyCub.iso(polyregion, f, intrfr, ..., center, control = list(),
  check.intrfr = FALSE, plot = FALSE)

.polyCub.iso(polys, intrfr, ..., center, control = list(),
  .witherror = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyCub.iso_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal domain.
The following classes are supported:
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>,
<code>"gpc.poly"</code> from <span class="pkg">gpclib</span>,
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code>,
and <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> from package <span class="pkg">sp</span>, as well as
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>.
(For these classes, <span class="pkg">polyCub</span> knows how to get an <code><a href="#topic+xylist">xylist</a></code>.)</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function.
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_intrfr">intrfr</code></td>
<td>
<p>a <code>function(R, ...)</code>, which implements the (analytical)
antiderivative of <code class="reqn">r f_r(r)</code> from 0 to <code>R</code>. The first argument
must be vectorized but not necessarily named <code>R</code>.<br />
If <code>intrfr</code> is missing, it will be approximated numerically via
<code><a href="stats.html#topic+integrate">integrate</a>(function(r, ...)
r * f(cbind(x0 + r, y0), ...), 0, R, ..., control=control)</code>,
where <code>c(x0, y0)</code> is the <code>center</code> of isotropy.
Note that <code>f</code> will <em>not</em> be checked for isotropy.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_...">...</code></td>
<td>
<p>further arguments for <code>f</code> or <code>intrfr</code>.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_center">center</code></td>
<td>
<p>numeric vector of length 2, the center of isotropy.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_control">control</code></td>
<td>
<p>list of arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code>, the
quadrature rule used for the line integral along the polygon boundary.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_check.intrfr">check.intrfr</code></td>
<td>
<p>logical (or numeric vector) indicating if
(for which <code>r</code>'s) the supplied <code>intrfr</code> function should be
checked against a numeric approximation. This check requires <code>f</code>
to be specified. If <code>TRUE</code>, the set of test
<code>r</code>'s defaults to a <code><a href="base.html#topic+seq">seq</a></code> of length 20 from 1 to
the maximum absolute x or y coordinate of any edge of the <code>polyregion</code>.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_plot">plot</code></td>
<td>
<p>logical indicating if an image of the function should be plotted
together with the polygonal domain, i.e.,
<code><a href="#topic+plotpolyf">plotpolyf</a>(polyregion, f, ...)</code>.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_polys">polys</code></td>
<td>
<p>something like <code>owin$bdry</code>, but see <code><a href="#topic+xylist">xylist</a></code>.</p>
</td></tr>
<tr><td><code id="polyCub.iso_+3A_.witherror">.witherror</code></td>
<td>
<p>logical indicating if an upper bound for the absolute
integration error should be attached as an attribute to the result?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximate integral of the isotropic function
<code>f</code> over <code>polyregion</code>.<br />
If the <code>intrfr</code> function is provided (which is assumed to be exact), an
upper bound for the absolute integration error is appended to the result as
attribute <code>"abs.error"</code>. It equals the sum of the absolute errors
reported by all <code><a href="stats.html#topic+integrate">integrate</a></code> calls
(there is one for each edge of <code>polyregion</code>).
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>
<p>The basic mathematical formulation of this efficient integration for radially
symmetric functions was ascertained with great support by
Emil Hedevang (2013), Dept. of Mathematics, Aarhus University, Denmark.
</p>


<h3>References</h3>

<p>Hedevang, E. (2013). Personal communication at the Summer School on Topics in
Space-Time Modeling and Inference (May 2013, Aalborg, Denmark).
</p>
<p>Meyer, S. and Held, L. (2014).
Power-law models for infectious disease spread.
<em>The Annals of Applied Statistics</em>, <b>8</b> (3), 1612-1639.
<a href="https://doi.org/10.1214/14-AOAS743">doi:10.1214/14-AOAS743</a>
</p>


<h3>See Also</h3>

<p><code>system.file("include", "polyCubAPI.h", package = "polyCub")</code>
for a full C-implementation of this cubature method (for a <em>single</em>
polygon). The corresponding C-routine <code>polyCub_iso</code> can be used by
other <span class="rlang"><b>R</b></span> packages, notably <a href="https://CRAN.R-project.org/package=surveillance"><span class="pkg">surveillance</span></a>, via &lsquo;<span class="samp">&#8288;LinkingTo: polyCub&#8288;</span>&rsquo;
(in the &lsquo;<span class="file">DESCRIPTION</span>&rsquo;) and &lsquo;<span class="samp">&#8288;#include &lt;polyCubAPI.h&gt;&#8288;</span>&rsquo; (in suitable
&lsquo;<span class="file">/src</span>&rsquo; files). Note that the <code>intrfr</code> function must then also be
supplied as a C-routine. An example can be found in the package tests.
</p>
<p>Other polyCub-methods: 
<code><a href="#topic+polyCub.SV">polyCub.SV</a>()</code>,
<code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a>()</code>,
<code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a>()</code>,
<code><a href="#topic+polyCub">polyCub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we use the example polygon and f (exponential decay) from
example(plotpolyf)

## numerical approximation of 'intrfr' (not recommended)
(intISOnum &lt;- polyCub.iso(letterR, f, center = fcenter))

## analytical 'intrfr'
## intrfr(R) = int_0^R r*f(r) dr, for f(r) = dexp(r), gives
intrfr &lt;- function (R, rate = 1) pgamma(R, 2, rate) / rate
(intISOana &lt;- polyCub.iso(letterR, f, intrfr = intrfr, center = fcenter,
                          check.intrfr = TRUE))
## f is only used to check 'intrfr' against a numerical approximation

stopifnot(all.equal(intISOana, intISOnum, check.attributes = FALSE))


### polygon area: f(r) = 1, f(x,y) = 1, center does not really matter

## intrfr(R) = int_0^R r*f(r) dr = int_0^R r dr = R^2/2
intrfr.const &lt;- function (R) R^2/2
(area.ISO &lt;- polyCub.iso(letterR, intrfr = intrfr.const, center = c(0,0)))

if (require("spatstat.geom")) { # check against area.owin()
    stopifnot(all.equal(area.owin(owin(poly = letterR)),
                        area.ISO, check.attributes = FALSE))
}
</code></pre>

<hr>
<h2 id='polyCub.midpoint'>Two-Dimensional Midpoint Rule</h2><span id='topic+polyCub.midpoint'></span>

<h3>Description</h3>

<p>The surface is converted to a binary pixel image
using the <code><a href="spatstat.geom.html#topic+as.im.function">as.im.function</a></code> method from package
<a href="https://CRAN.R-project.org/package=spatstat.geom"><span class="pkg">spatstat.geom</span></a> (Baddeley et al., 2015).
The integral under the surface is then approximated as the
sum over (pixel area * f(pixel midpoint)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyCub.midpoint(polyregion, f, ..., eps = NULL, dimyx = NULL,
  plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyCub.midpoint_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal integration domain.
It can be any object coercible to the <span class="pkg">spatstat.geom</span> class
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> via a corresponding
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>-method.
Note that this includes polygons of the classes <code>"gpc.poly"</code> and
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, because <span class="pkg">polyCub</span> defines
methods <code><a href="#topic+as.owin.gpc.poly">as.owin.gpc.poly</a></code> and
<code><a href="#topic+as.owin.SpatialPolygons">as.owin.SpatialPolygons</a></code>, respectively.
<span class="pkg">sf</span> also registers suitable <code>as.owin</code> methods for its
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> classes.</p>
</td></tr>
<tr><td><code id="polyCub.midpoint_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function.
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td></tr>
<tr><td><code id="polyCub.midpoint_+3A_...">...</code></td>
<td>
<p>further arguments for <code>f</code>.</p>
</td></tr>
<tr><td><code id="polyCub.midpoint_+3A_eps">eps</code></td>
<td>
<p>width and height of the pixels (squares),
see <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.</p>
</td></tr>
<tr><td><code id="polyCub.midpoint_+3A_dimyx">dimyx</code></td>
<td>
<p>number of subdivisions in each dimension,
see <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.</p>
</td></tr>
<tr><td><code id="polyCub.midpoint_+3A_plot">plot</code></td>
<td>
<p>logical indicating if an illustrative plot of the numerical
integration should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximated value of the integral of <code>f</code> over
<code>polyregion</code>.
</p>


<h3>References</h3>

<p>Baddeley A, Rubak E, Turner R (2015).
<em>Spatial Point Patterns: Methodology and Applications with R</em>.
Chapman and Hall/CRC Press, London.
</p>


<h3>See Also</h3>

<p>Other polyCub-methods: 
<code><a href="#topic+polyCub.SV">polyCub.SV</a>()</code>,
<code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a>()</code>,
<code><a href="#topic+polyCub.iso">polyCub.iso</a>()</code>,
<code><a href="#topic+polyCub">polyCub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a function to integrate (here: isotropic zero-mean Gaussian density)
f &lt;- function (s, sigma = 5)
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)

## a simple polygon as integration domain
hexagon &lt;- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)

if (require("spatstat.geom")) {
    hexagon.owin &lt;- owin(poly = hexagon)

    show_midpoint &lt;- function (eps)
    {
        plotpolyf(hexagon.owin, f, xlim = c(-8,8), ylim = c(-8,8),
                  use.lattice = FALSE)
        ## add evaluation points to plot
        with(as.mask(hexagon.owin, eps = eps),
             points(expand.grid(xcol, yrow), col = t(m), pch = 20))
        title(main = paste("2D midpoint rule with eps =", eps))
    }

    ## show nodes (eps = 0.5)
    show_midpoint(0.5)

    ## show pixel image (eps = 0.5)
    polyCub.midpoint(hexagon.owin, f, eps = 0.5, plot = TRUE)

    ## use a decreasing pixel size (increasing number of nodes)
    for (eps in c(5, 3, 1, 0.5, 0.3, 0.1))
        cat(sprintf("eps = %.1f: %.7f\n", eps,
                    polyCub.midpoint(hexagon.owin, f, eps = eps)))
}
</code></pre>

<hr>
<h2 id='polyCub.SV'>Product Gauss Cubature over Polygonal Domains</h2><span id='topic+polyCub.SV'></span>

<h3>Description</h3>

<p>Product Gauss cubature over polygons as proposed by
Sommariva and Vianello (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyCub.SV(polyregion, f, ..., nGQ = 20, alpha = NULL, rotation = FALSE,
  engine = "C", plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyCub.SV_+3A_polyregion">polyregion</code></td>
<td>
<p>a polygonal domain.
The following classes are supported:
<code>"<a href="spatstat.geom.html#topic+owin">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>,
<code>"gpc.poly"</code> from <span class="pkg">gpclib</span>,
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>, <code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code>,
and <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> from package <span class="pkg">sp</span>, as well as
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>.
(For these classes, <span class="pkg">polyCub</span> knows how to get an <code><a href="#topic+xylist">xylist</a></code>.)</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_f">f</code></td>
<td>
<p>a two-dimensional real-valued function to be integrated over
<code>polyregion</code> (or <code>NULL</code> to only compute nodes and weights).
As its first argument it must take a coordinate matrix, i.e., a
numeric matrix with two columns, and it must return a numeric vector of
length the number of coordinates.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_...">...</code></td>
<td>
<p>further arguments for <code>f</code>.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_ngq">nGQ</code></td>
<td>
<p>degree of the one-dimensional Gauss-Legendre quadrature rule
(default: 20) as implemented in function <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code>
of package <a href="https://CRAN.R-project.org/package=statmod"><span class="pkg">statmod</span></a>. Nodes and weights up to <code>nGQ=60</code> are cached
in <span class="pkg">polyCub</span>, for larger degrees <span class="pkg">statmod</span> is required.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_alpha">alpha</code></td>
<td>
<p>base-line of the (rotated) polygon at <code class="reqn">x = \alpha</code> (see
Sommariva and Vianello (2007) for an explication). If <code>NULL</code> (default),
the midpoint of the x-range of each polygon is chosen if no <code>rotation</code>
is performed, and otherwise the <code class="reqn">x</code>-coordinate of the rotated point
<code>"P"</code> (see <code>rotation</code>). If <code>f</code> has its maximum value at the
origin <code class="reqn">(0,0)</code>, e.g., the bivariate Gaussian density with zero mean,
<code>alpha = 0</code> is a reasonable choice.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_rotation">rotation</code></td>
<td>
<p>logical (default: <code>FALSE</code>) or a list of points
<code>"P"</code> and <code>"Q"</code> describing the preferred direction. If
<code>TRUE</code>, the polygon is rotated according to the vertices <code>"P"</code> and
<code>"Q"</code>, which are farthest apart (see Sommariva and Vianello, 2007). For
convex polygons, this rotation guarantees that all nodes fall inside the
polygon.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_engine">engine</code></td>
<td>
<p>character string specifying the implementation to use.
Up to <span class="pkg">polyCub</span> version 0.4-3, the two-dimensional nodes and weights
were computed by <span class="rlang"><b>R</b></span> functions and these are still available by setting
<code>engine = "R"</code>.
The new C-implementation is now the default (<code>engine = "C"</code>) and
requires approximately 30% less computation time.<br />
The special setting <code>engine = "C+reduce"</code> will discard redundant nodes
at (0,0) with zero weight resulting from edges on the base-line
<code class="reqn">x = \alpha</code> or orthogonal to it.
This extra cleaning is only worth its cost for computationally intensive
functions <code>f</code> over polygons which really have some edges on the
baseline or parallel to the x-axis.  Note that the old <span class="rlang"><b>R</b></span>
implementation does not have such unset zero nodes and weights.</p>
</td></tr>
<tr><td><code id="polyCub.SV_+3A_plot">plot</code></td>
<td>
<p>logical indicating if an illustrative plot of the numerical
integration should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximated value of the integral of <code>f</code> over
<code>polyregion</code>.<br />
In the case <code>f = NULL</code>, only the computed nodes and weights are
returned in a list of length the number of polygons of <code>polyregion</code>,
where each component is a list with <code>nodes</code> (a numeric matrix with
two columns), <code>weights</code> (a numeric vector of length
<code>nrow(nodes)</code>), the rotation <code>angle</code>, and <code>alpha</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer<br />
These R and C implementations of product Gauss cubature are based on the
original <abbr><span class="acronym">MATLAB</span></abbr> implementation <code>polygauss</code> by Sommariva and
Vianello (2007), which is available under the GNU GPL (&gt;=2) license from
<a href="https://www.math.unipd.it/~alvise/software.html">https://www.math.unipd.it/~alvise/software.html</a>.
</p>


<h3>References</h3>

<p>Sommariva, A. and Vianello, M. (2007):
Product Gauss cubature over polygons based on Green's integration formula.
<em>BIT Numerical Mathematics</em>, <b>47</b> (2), 441-453.
<a href="https://doi.org/10.1007/s10543-007-0131-2">doi:10.1007/s10543-007-0131-2</a>
</p>


<h3>See Also</h3>

<p>Other polyCub-methods: 
<code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a>()</code>,
<code><a href="#topic+polyCub.iso">polyCub.iso</a>()</code>,
<code><a href="#topic+polyCub.midpoint">polyCub.midpoint</a>()</code>,
<code><a href="#topic+polyCub">polyCub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a function to integrate (here: isotropic zero-mean Gaussian density)
f &lt;- function (s, sigma = 5)
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)

## a simple polygon as integration domain
hexagon &lt;- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)

## image of the function and integration domain
plotpolyf(hexagon, f)

## use a degree of nGQ = 3 and show the corresponding nodes
polyCub.SV(hexagon, f, nGQ = 3, plot = TRUE)

## extract nodes and weights
nw &lt;- polyCub.SV(hexagon, f = NULL, nGQ = 3)[[1]]
nrow(nw$nodes)

## manually apply the cubature rule
sum(nw$weights * f(nw$nodes))

## use an increasing number of nodes
for (nGQ in c(1:5, 10, 20, 60))
    cat(sprintf("nGQ = %2i: %.16f\n", nGQ,
                polyCub.SV(hexagon, f, nGQ = nGQ)))

## polyCub.SV() is the default method used by the polyCub() wrapper
polyCub(hexagon, f, nGQ = 3)  # calls polyCub.SV()


### now using a simple *rectangular* integration domain

rectangle &lt;- list(list(x = c(-1, 7, 7, -1), y = c(-3, -3, 7, 7)))
polyCub.SV(rectangle, f, plot = TRUE)

## effect of rotation given a very low nGQ
opar &lt;- par(mfrow = c(1,3))
polyCub.SV(rectangle, f, nGQ = 4, rotation = FALSE, plot = TRUE)
           title(main = "without rotation (default)")
polyCub.SV(rectangle, f, nGQ = 4, rotation = TRUE,  plot = TRUE)
           title(main = "standard rotation")
polyCub.SV(rectangle, f, nGQ = 4,
           rotation = list(P = c(0,0), Q = c(2,-3)), plot = TRUE)
           title(main = "custom rotation")
par(opar)

## comparison with the "cubature" package
if (requireNamespace("cubature")) {
    fc &lt;- function (s, sigma = 5)  # non-vectorized version of f
        exp(-sum(s^2)/2/sigma^2) / (2*pi*sigma^2)
    cubature::hcubature(fc, lowerLimit = c(-1, -3), upperLimit = c(7, 7))
}
</code></pre>

<hr>
<h2 id='polygauss'>Calculate 2D Nodes and Weights of the Product Gauss Cubature</h2><span id='topic+polygauss'></span>

<h3>Description</h3>

<p>Calculate 2D Nodes and Weights of the Product Gauss Cubature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygauss(xy, nw_MN, alpha = NULL, rotation = FALSE, engine = "C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygauss_+3A_xy">xy</code></td>
<td>
<p>list with elements <code>"x"</code> and <code>"y"</code> containing the
polygon vertices in <em>anticlockwise</em> order (otherwise the result of the
cubature will have a negative sign) with first vertex not repeated at the
end (like <code>owin.object$bdry</code>).</p>
</td></tr>
<tr><td><code id="polygauss_+3A_nw_mn">nw_MN</code></td>
<td>
<p>unnamed list of nodes and weights of one-dimensional Gauss
quadrature rules of degrees <code class="reqn">N</code> and <code class="reqn">M=N+1</code> (as returned by
<code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code>): <code>list(s_M, w_M, s_N, w_N)</code>.</p>
</td></tr>
<tr><td><code id="polygauss_+3A_alpha">alpha</code></td>
<td>
<p>base-line of the (rotated) polygon at <code class="reqn">x = \alpha</code> (see
Sommariva and Vianello (2007) for an explication). If <code>NULL</code> (default),
the midpoint of the x-range of each polygon is chosen if no <code>rotation</code>
is performed, and otherwise the <code class="reqn">x</code>-coordinate of the rotated point
<code>"P"</code> (see <code>rotation</code>). If <code>f</code> has its maximum value at the
origin <code class="reqn">(0,0)</code>, e.g., the bivariate Gaussian density with zero mean,
<code>alpha = 0</code> is a reasonable choice.</p>
</td></tr>
<tr><td><code id="polygauss_+3A_rotation">rotation</code></td>
<td>
<p>logical (default: <code>FALSE</code>) or a list of points
<code>"P"</code> and <code>"Q"</code> describing the preferred direction. If
<code>TRUE</code>, the polygon is rotated according to the vertices <code>"P"</code> and
<code>"Q"</code>, which are farthest apart (see Sommariva and Vianello, 2007). For
convex polygons, this rotation guarantees that all nodes fall inside the
polygon.</p>
</td></tr>
<tr><td><code id="polygauss_+3A_engine">engine</code></td>
<td>
<p>character string specifying the implementation to use.
Up to <span class="pkg">polyCub</span> version 0.4-3, the two-dimensional nodes and weights
were computed by <span class="rlang"><b>R</b></span> functions and these are still available by setting
<code>engine = "R"</code>.
The new C-implementation is now the default (<code>engine = "C"</code>) and
requires approximately 30% less computation time.<br />
The special setting <code>engine = "C+reduce"</code> will discard redundant nodes
at (0,0) with zero weight resulting from edges on the base-line
<code class="reqn">x = \alpha</code> or orthogonal to it.
This extra cleaning is only worth its cost for computationally intensive
functions <code>f</code> over polygons which really have some edges on the
baseline or parallel to the x-axis.  Note that the old <span class="rlang"><b>R</b></span>
implementation does not have such unset zero nodes and weights.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sommariva, A. and Vianello, M. (2007):
Product Gauss cubature over polygons based on Green's integration formula.
<em>BIT Numerical Mathematics</em>, <b>47</b> (2), 441-453.
<a href="https://doi.org/10.1007/s10543-007-0131-2">doi:10.1007/s10543-007-0131-2</a>
</p>

<hr>
<h2 id='sfg2gpc'>Convert polygonal <code>"sfg"</code> to <code>"gpc.poly"</code></h2><span id='topic+sfg2gpc'></span>

<h3>Description</h3>

<p>Package <span class="pkg">polyCub</span> implements a converter from class
<code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> of package <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a>
to <code>"gpc.poly"</code> of package <a href="https://CRAN.R-project.org/package=gpclib"><span class="pkg">gpclib</span></a>
such that <code><a href="#topic+polyCub.exact.Gauss">polyCub.exact.Gauss</a></code>
can be used with simple feature polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfg2gpc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfg2gpc_+3A_object">object</code></td>
<td>
<p>a <code>"POLYGON"</code> or <code>"MULTIPOLYGON"</code> <code>"sfg"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The converted polygon of class <code>"gpc.poly"</code>.
If package <span class="pkg">gpclib</span> is not available,
<code>sfg2gpc</code> will just return the <code>pts</code> slot of the
<code>"gpc.poly"</code> (no formal class) with a warning.
</p>


<h3>Note</h3>

<p>Package <span class="pkg">gpclib</span> is required for the formal class
definition of a <code>"gpc.poly"</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xylist">xylist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use example polygons from
example(plotpolyf, ask = FALSE)
letterR  # a simple "xylist"

letterR.sfg &lt;- sf::st_polygon(lapply(letterR, function(xy)
    rbind(cbind(xy$x, xy$y), c(xy$x[1], xy$y[1]))))
letterR.sfg
stopifnot(identical(letterR, xylist(letterR.sfg)))

## convert sf "POLYGON" to a "gpc.poly"
letterR.gpc_from_sfg &lt;- sfg2gpc(letterR.sfg)
letterR.gpc_from_sfg


</code></pre>

<hr>
<h2 id='vecnorm'>Euclidean Vector Norm (Length)</h2><span id='topic+vecnorm'></span>

<h3>Description</h3>

<p>This is nothing else than <code>sqrt(sum(x^2))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecnorm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecnorm_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sqrt(sum(x^2))</code>
</p>

<hr>
<h2 id='xylist'>Convert Various Polygon Classes to a Simple List of Vertices</h2><span id='topic+xylist'></span><span id='topic+xylist.owin'></span><span id='topic+xylist.sfg'></span><span id='topic+xylist.gpc.poly'></span><span id='topic+xylist.SpatialPolygons'></span><span id='topic+xylist.Polygons'></span><span id='topic+xylist.Polygon'></span><span id='topic+xylist.default'></span>

<h3>Description</h3>

<p>Different packages concerned with spatial data use different polygon
specifications, which sometimes becomes very confusing (see Details below).
To be compatible with the various polygon classes, package <span class="pkg">polyCub</span>
uses an S3 class <code>"xylist"</code>, which represents a polygonal domain
(of potentially multiple polygons) by its core feature only: a list of lists
of vertex coordinates (see the &quot;Value&quot; section below).
The generic function <code>xylist</code> can deal with the
following polygon classes:
</p>

<ul>
<li> <p><code>"<a href="spatstat.geom.html#topic+owin.object">owin</a>"</code> from package <span class="pkg">spatstat.geom</span>
</p>
</li>
<li> <p><code>"gpc.poly"</code> from package <span class="pkg">gpclib</span>
</p>
</li>
<li> <p><code>"<a href="sp.html#topic+Polygons-class">Polygons</a>"</code> from package <span class="pkg">sp</span>
(as well as <code>"<a href="sp.html#topic+Polygon-class">Polygon</a>"</code> and
<code>"<a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons</a>"</code>)
</p>
</li>
<li> <p><code>"<a href="sf.html#topic+st_polygon">(MULTI)POLYGON</a>"</code> from package <span class="pkg">sf</span>
</p>
</li></ul>

<p>The (somehow useless) default <code>xylist</code>-method
does not perform any transformation but only ensures that the polygons are
not closed (first vertex not repeated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xylist(object, ...)

## S3 method for class 'owin'
xylist(object, ...)

## S3 method for class 'sfg'
xylist(object, ...)

## S3 method for class 'gpc.poly'
xylist(object, ...)

## S3 method for class 'SpatialPolygons'
xylist(object, reverse = TRUE, ...)

## S3 method for class 'Polygons'
xylist(object, reverse = TRUE, ...)

## S3 method for class 'Polygon'
xylist(object, reverse = TRUE, ...)

## Default S3 method:
xylist(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xylist_+3A_object">object</code></td>
<td>
<p>an object of one of the supported spatial classes.</p>
</td></tr>
<tr><td><code id="xylist_+3A_...">...</code></td>
<td>
<p>(unused) argument of the generic.</p>
</td></tr>
<tr><td><code id="xylist_+3A_reverse">reverse</code></td>
<td>
<p>logical (<code>TRUE</code>) indicating if the vertex order of the
<span class="pkg">sp</span> classes should be reversed to get the <code>xylist</code>/<code>owin</code>
convention.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polygon specifications differ with respect to:
</p>

<ul>
<li><p> is the first vertex repeated?
</p>
</li>
<li><p> which ring direction represents holes?
</p>
</li></ul>

<p>Package overview:
</p>

<dl>
<dt><span class="pkg">spatstat.geom</span>:</dt><dd><p><code>"owin"</code> does <em>not repeat</em> the
first vertex, and anticlockwise = normal boundary, clockwise = hole.
This convention is also used for the return value of <code>xylist</code>.</p>
</dd>
<dt><span class="pkg">sp</span>:</dt><dd><p><em>Repeat</em> first vertex at the end (closed),
anticlockwise = hole, clockwise = normal boundary</p>
</dd>
<dt><span class="pkg">sf</span>:</dt><dd><p><em>Repeat</em> first vertex at the end (closed),
clockwise = hole, anticlockwise = normal boundary;
<em>however</em>, <span class="pkg">sf</span> does not check the ring direction by default, so
it cannot be relied upon.</p>
</dd>
<dt><span class="pkg">gpclib</span>:</dt><dd><p>There seem to be no such conventions
for polygons of class <code>"gpc.poly"</code>.</p>
</dd>
</dl>

<p>Thus, for polygons from <span class="pkg">sf</span> and <span class="pkg">gpclib</span>, <code>xylist</code> needs
to check the ring direction, which makes these two formats the least
efficient for integration domains in <span class="pkg">polyCub</span>.
</p>


<h3>Value</h3>

<p>Applying <code>xylist</code> to a polygon object, one gets a simple list,
where each component (polygon) is a list of <code>"x"</code> and <code>"y"</code>
coordinates. These represent vertex coordinates following <span class="pkg">spatstat.geom</span>'s
<code>"owin"</code> convention (anticlockwise order for exterior boundaries,
without repeating any vertex).
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
