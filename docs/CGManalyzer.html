<!DOCTYPE html><html><head><title>Help for package CGManalyzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CGManalyzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#antennaPlot.fn'><p>draw an antenna plot</p></a></li>
<li><a href='#boxplotCGM.fn'><p>Draw a boxplot for continuous glucose monitoring data sensor by sensor</p></a></li>
<li><a href='#CGManalyzer-package'>
<p>Continuous Glucose Monitoring Data Analyzer</p></a></li>
<li><a href='#CONGA.fn'>
<p>Function to calculate the continuous overlapping net glycemic action (CONGA)</p></a></li>
<li><a href='#equalInterval.fn'>
<p>Function to derive the data with equal interval</p></a></li>
<li><a href='#fac2char.fn'>
<p>function to convert a factor to a vector</p></a></li>
<li><a href='#fixMissing.fn'>
<p>Function to fix missing values in a vector</p></a></li>
<li><a href='#MODD.fn'>
<p>Function to calculate the mean of daily differences (MODD)</p></a></li>
<li><a href='#MSEbyC.fn'>
<p>call a C function to calculate multiscale entropy</p></a></li>
<li><a href='#MSEplot.fn'>
<p>Plot the mean and standard error or standard deviation of multiscale entropy by group</p></a></li>
<li><a href='#pairwiseComparison.fn'>
<p>function to calculate mean difference and its confidence interval, SSMD, p-value of t.test for pairwise comparison</p></a></li>
<li><a href='#plotTseries.fn'>
<p>function to plot time series data</p></a></li>
<li><a href='#setSPEC.fn'>
<p>Load settings for the selected SPEC parameter.</p></a></li>
<li><a href='#ssmdEffect.fn'>
<p>function to derive the type of effect size based on SSMD values</p></a></li>
<li><a href='#summaryCGM.fn'>
<p>Function to calculate the summary statistics for each subject or sensor:  number of subjects or sensors, minimum, 1st quartile, median, mean, 2nd quartile, maximum, standard deviation, MAD</p></a></li>
<li><a href='#timeSeqConversion.fn'>
<p>function to convert a matrix (with columns for year, month, day, minute and/or second)</p>
to a time sequence in a unit of minute or second</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous Glucose Monitoring Data Analyzer</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-7-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaohua Douglas Zhang [aut, cph],
  Dandan Wang [aut],
  Zhaozhi Zhang [aut],
  Madalena Costa [ctb],
  Xinzheng Dong [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xinzheng Dong &lt;dong.xinzheng@foxmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains all of the functions necessary for the complete analysis of a continuous glucose monitoring study and can be applied to data measured by various existing 'CGM' devices such as 'FreeStyle Libre', 'Glutalor', 'Dexcom' and 'Medtronic CGM'. It reads a series of data files, is able to convert various formats of time stamps, can deal with missing values, calculates both regular statistics and nonlinear statistics, and conducts group comparison. It also displays results in a concise format. Also contains two unique features new to 'CGM' analysis: one is the implementation of strictly standard mean difference and the class of effect size; the other is the development of a new type of plot called antenna plot. It corresponds to 'Zhang XD'(2018)&lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx826">doi:10.1093/bioinformatics/btx826</a>&gt;'s article 'CGManalyzer: an R package for analyzing continuous glucose monitoring studies'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-11 01:50:56 UTC; 11547</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-11 12:00:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='antennaPlot.fn'>draw an antenna plot</h2><span id='topic+antennaPlot.fn'></span>

<h3>Description</h3>

<p>function to draw an antenna plot </p>


<h3>Usage</h3>

<pre><code class='language-R'>antennaPlot.fn(Mean, SSMD, Name, CIlower, CIupper, xRange = NA, yRange = NA,
col = 1:length(Mean), pch = 1:length(Mean), cex = 1, Position = "topleft", main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antennaPlot.fn_+3A_mean">Mean</code></td>
<td>
<p>vector for mean difference in a comparison</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_ssmd">SSMD</code></td>
<td>
<p>vector for strictly standardized mean difference (ssmd) in a comparison</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_name">Name</code></td>
<td>
<p>vector for name of pairs in a comparison</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_cilower">CIlower</code></td>
<td>
<p>vector for the lower bound of confidence interval</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_ciupper">CIupper</code></td>
<td>
<p>vector for the upper bound of confidence interval</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_xrange">xRange</code></td>
<td>
<p>pre-defined range for the x-axis if needed</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_yrange">yRange</code></td>
<td>
<p>pre-defined range for the y-axis if needed</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_col">col</code></td>
<td>
<p>vector of colors for pairs in a comparison</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_pch">pch</code></td>
<td>
<p>vector of point types for pairs in a comparison</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_cex">cex</code></td>
<td>
<p>cex for the legend</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_position">Position</code></td>
<td>
<p>position indicating where to put the legend, such as 'topleft'</p>
</td></tr>
<tr><td><code id="antennaPlot.fn_+3A_main">main</code></td>
<td>
<p>title name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a function to draw an antenna plot, namely, plot ssmd vs. mean difference with confidence interval.
</p>


<h3>Value</h3>

<p> no return value </p>


<h3>Author(s)</h3>

<p> Xiaohua Douglas Zhang </p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
scalesInTime &lt;- Scales*equal.interval
pvalSSMD.mat &lt;- read.csv(file=system.file("SPEC", "pvalSSMD.csv", package = package.name),
              row.names=1)
outNames &lt;- dimnames(pvalSSMD.mat)[[2]]
SSMD.mat &lt;- as.matrix( pvalSSMD.mat[, substring(outNames, 1, 4) == "SSMD"] )
mDiff.mat &lt;- as.matrix(pvalSSMD.mat[, substring(outNames, 1, 5) == "mDiff"])
CIlower.mat &lt;- as.matrix(pvalSSMD.mat[, substring(outNames, 1, 7) == "CIlower"])
CIupper.mat &lt;- as.matrix(pvalSSMD.mat[, substring(outNames, 1, 7) == "CIupper"])
pairNames &lt;- gsub("mDiff_", "", dimnames(mDiff.mat)[[2]], fixed=TRUE)
idx = 1:4
xRange &lt;- range( c( range( CIlower.mat[idx,], na.rm=TRUE), 0,
      range( CIupper.mat[idx,], na.rm=TRUE) )  )
yRange &lt;- range( c(0, range( SSMD.mat[idx,], na.rm=TRUE ) ) )
par(mfrow=c(2,2))
for( i in idx ) {
    Main &lt;- paste0("Sample entropy at a scale of ", scalesInTime[i], " ", timeUnit, "s")
    condt &lt;- !is.na(mDiff.mat[i,]) &amp; !is.na(SSMD.mat[i,])
	antennaPlot.fn(Mean=mDiff.mat[i,condt], SSMD=SSMD.mat[i, condt], Name = pairNames[condt],
	            CIlower=CIlower.mat[i,condt], CIupper=CIupper.mat[i,condt], xRange=xRange,
	            yRange=yRange, col=1:length(pairNames[condt]), pch=1:length(pairNames[condt]),
	            cex=0.8, Position = "topleft", main = Main)
}
</code></pre>

<hr>
<h2 id='boxplotCGM.fn'>Draw a boxplot for continuous glucose monitoring data sensor by sensor</h2><span id='topic+boxplotCGM.fn'></span>

<h3>Description</h3>

<p>a function to draw a boxplot for continuous glucose monitoring data sensor by sensor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplotCGM.fn(dataFolder, dataFiles, idxNA = NA, responseName, sensorIDs,
columnNames = NULL, yRange, skip = 0, header = TRUE, comment.char = "", sep = ",",
cex.axis1 = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplotCGM.fn_+3A_datafolder">dataFolder</code></td>
<td>
<p>name for the folder for holding data</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_datafiles">dataFiles</code></td>
<td>
<p>names of the data files to be read in R</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_idxna">idxNA</code></td>
<td>
<p>symbol to represent a missing value, such as NA</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_responsename">responseName</code></td>
<td>
<p>name to represent the response to be analyzed, such as 'glucose'</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_sensorids">sensorIDs</code></td>
<td>
<p>names of sensors or subjects</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_columnnames">columnNames</code></td>
<td>
<p>names of columns of the data after reading in R</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_yrange">yRange</code></td>
<td>
<p>range of y-axis to be drawn in the boxplot</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_skip">skip</code></td>
<td>

<p>number of lines to be skipped in each data file when the data is read in R
</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_header">header</code></td>
<td>

<p>the same meaning as in read.table()
</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_comment.char">comment.char</code></td>
<td>

<p>the same meaning as in read.table()
</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_sep">sep</code></td>
<td>

<p>the same meaning as in read.table()
</p>
</td></tr>
<tr><td><code id="boxplotCGM.fn_+3A_cex.axis1">cex.axis1</code></td>
<td>
<p>cex for the x-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a box plot for the data by each sensor or subject
</p>


<h3>Value</h3>

<p>No value return; draw a boxplot</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
summary.arr &lt;- summaryCGM.fn(dataFolder, dataFiles, responseName, sensorIDs, columnNames,
            skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
yRange &lt;- c( min(summary.arr[, "Min",responseName], na.rm=TRUE),
      max(summary.arr[, "Max",responseName], na.rm=TRUE))
boxplotCGM.fn(dataFolder, dataFiles, idxNA, responseName, sensorIDs, columnNames, yRange,
            skip=Skip, header=Header, comment.char=Comment.char, sep=Sep, cex.axis1=1)
</code></pre>

<hr>
<h2 id='CGManalyzer-package'>
Continuous Glucose Monitoring Data Analyzer
</h2><span id='topic+CGManalyzer-package'></span><span id='topic+CGManalyzer'></span>

<h3>Description</h3>

<p>Contains all of the functions necessary for the complete analysis of a continuous glucose monitoring study and can be applied to data measured by various existing 'CGM' devices such as 'FreeStyle Libre', 'Glutalor', 'Dexcom' and 'Medtronic CGM'. It reads a series of data files, is able to convert various formats of time stamps, can deal with missing values, calculates both regular statistics and nonlinear statistics, and conducts group comparison. It also displays results in a concise format. Also contains two unique features new to 'CGM' analysis: one is the implementation of strictly standard mean difference and the class of effect size; the other is the development of a new type of plot called antenna plot. It corresponds to 'Zhang XD'(2018)&lt;doi:10.1093/bioinformatics/btx826&gt;'s article 'CGManalyzer: an R package for analyzing continuous glucose monitoring studies'.
</p>


<h3>Details</h3>

<p>The R package CGManalyzer contains functions for analyzing data from a continuous glucose monitoring (CGM) study. It covers a complete flow of data analysis including reading a series of datasets, obtaining summary statistics of glucose levels, plotting data, transforming time stamp format, fixing missing values, calculating multiscale sample entropy (MSE), conducting pairwise comparison, displaying results using various plots including a new type of plots called an antenna plot, etc.. This package has been developed from our work in directly analyzing data from various CGM devices such as FreeStyle Libre, Glutalor, Dexcom, Medtronic CGM. Thus, this package will greatly facilitate the analysis of various CGM studies.
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang [aut, cph], Dandan Wang [aut], Zhaozhi Zhang [aut], Madalena Costa [ctb], Xinzheng Dong [aut, cre]
</p>
<p>Maintainer: Xinzheng Dong &lt;dong.xinzheng@foxmail.com&gt;
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>
<p>Costa M., Goldberger A.L., Peng C.-K. Multiscale entropy analysis of physiologic time series. Phys Rev Lett 2002; 89:062102.
</p>
<p>Goldberger AL, Amaral LAN, Glass L, Hausdorff JM, Ivanov PCh, Mark RG, Mietus JE, Moody GB, Peng C-K, Stanley HE. PhysioBank, PhysioToolkit, and PhysioNet: Components of a New Research Resource for Complex Physiologic Signals (2003). Circulation. 101(23):e215-e220.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################################################
# The following are the example in the help file for CGManalyzer, which is also
# the main file for using the Package
###################################################################################

# install from local source pacage
# install.packages(paste0(getwd(), "/CGManalyzer_1.2.tar.gz"), repos = NULL)
# or install from CRAN
# install.packages("CGManalyzer")

library(CGManalyzer)

rm(list = ls())
package.name &lt;- "CGManalyzer"
options(scipen = 999)
mainFolder &lt;- getwd()

###################################################################################
# use example data or your own data
###################################################################################
useExampleData &lt;- TRUE

if (useExampleData) {
  SPEC.name &lt;- "SPECexample.R"
} else{
  ###################################################################################
  # TODOs before creating file "00filelist.csv":
  # Create a folder named "data" in working directory
  # and copy files into it manually.
  ###################################################################################


  ###################################################################################
  # Create a file named "00filelist.csv" in "data" folder with two columns,
  # one for file name and one for group type.
  ###################################################################################
  dataFolder &lt;-  file.path(mainFolder, "data")
  listFile &lt;- file.path(dataFolder, "00filelist.csv")
  # create a empty file
  if(!file.exists(listFile)){
    file.create(listFile)
    # list all files and their types
    dataFiles &lt;- list.files(dataFolder)
    if(length(dataFiles)&gt;1){
      dataType &lt;- rep("H",length(dataFiles))
      fileFrame &lt;- data.frame(dataFiles, dataType)
      # save to 00filelist.csv file
      write.csv(fileFrame,listFile,row.names = FALSE,quote = F)
    }else{
      stop("No data files found in the \"data\" folder!")
    }
  }

  ###################################################################################
  # TODOS after creating file "00filelist.csv":
  # Specify the group type for each subject by changing the second
  # column of 00filelist.csv manually. The default type is "H",
  # which needs to be changed to the actual type manually.
  ###################################################################################

  ###################################################################################
  # specify parameters for different CGM devices
  ###################################################################################
  # Choose one of the SPEC file that fits the CGM device that you are using for your study
  # to use the example data in the package "CGManalyzer", you have to choose "SPECexample.R"
  # if you want to run your own data, you cannot choose "SPECexample.R", instead, you need to choose
  # one of "SPEC.FreestyleLibre.R", "SPEC.Glutalor.R" and "SPEC.Medtronic.R".
  # You may also write your own file following the format in one of them.

  SPEC.name &lt;- "SPEC.FreestyleLibre.R"
  # SPEC.name &lt;- "SPEC.Glutalor.R"
  # SPEC.name &lt;- "SPEC.Medtronic.R"
}

setSPEC.fn(SPEC.name)

###################################################################################
## get summary statistics: number of subjects, minimum, 1st quartile, median, mean,
##             mean, 2nd quartile, maximum, number of NA's, standard deviation, MAD
###################################################################################
if (Summary) {
  summary.arr &lt;-
    summaryCGM.fn(
      dataFolder,
      dataFiles,
      responseName,
      sensorIDs,
      columnNames,
      skip = Skip,
      header = Header,
      comment.char = Comment.char,
      sep = Sep
    )
  # write.csv(file = "summaryStatistics.sensor.csv",
  #           summary.arr[, , 1])
  print(summary.arr[,,1])
}

########################################################################
## boxplot the data
########################################################################
if (Boxplot) {
  # filename &lt;- paste("boxplot.rawData", responseName, "pdf",sep=".")
  # pdf(filename)
  yRange &lt;- c(min(summary.arr[, "Min", responseName], na.rm = TRUE),
              max(summary.arr[, "Max", responseName], na.rm = TRUE))
  boxplotCGM.fn(
    dataFolder,
    dataFiles,
    idxNA,
    responseName,
    sensorIDs,
    columnNames,
    yRange,
    skip = Skip,
    header = Header,
    comment.char = Comment.char,
    sep = Sep,
    cex.axis1 = 1
  )
  # dev.off()
}

##########################################################################################
## main analytic process including quality control, interval adjustment, MODD, CONGA, MSE
## calculation
##########################################################################################

fixMissing &lt;- TRUE
fixMethod &lt;- "skip"
calculateMODD &lt;- TRUE
calculateCONGA &lt;- TRUE
n.CONGA &lt;- 2

# filename &lt;- paste("timeSeriesPlot", responseName, "pdf", sep = ".")
# pdf(filename)
par(mfrow = c(3, 2))
for (iFile in 1:nFile) {
  # iFile &lt;- 1 #iFile &lt;- 2 # iFile &lt;- 19
  print(paste0("Process the ", iFile, "th file: ", dataFiles[iFile]))
  data.df0 &lt;-
    read.table(
      paste(dataFolder, dataFiles[iFile], sep = "/"),
      skip = Skip,
      header = Header,
      comment.char = Comment.char,
      sep = Sep
    )
  if (!Header) {
    data.df0 &lt;- data.df0[, 1:length(columnNames)]
    dimnames(data.df0)[[2]] &lt;- columnNames
  }

  if (!is.na(idxNA))
    data.df0[data.df0[, responseName] == idxNA, responseName] &lt;- NA
  ########################################################################
  ## convert time :  timeSeqConversion.fn
  ########################################################################
  for (i in 1:length(timeStamp.column)) {
    if (i == 1) {
      timeStamp.vec &lt;- data.df0[, timeStamp.column[i]]
    } else {
      timeStamp.vec &lt;-
        paste0(timeStamp.vec, " ", data.df0[, timeStamp.column[i]])
    }
  }
  Time.mat &lt;-
    timeSeqConversion.fn(time.stamp = timeStamp.vec,
                         time.format = time.format,
                         timeUnit = timeUnit)
  data.df &lt;-
    data.frame(timeStamp.vec, Time.mat[, 1], data.df0[, responseName])
  # This needs to be changed if multiple responses
  dimnames(data.df)[[2]] &lt;-
    c("timeStamp", "timeSeries", responseName)
  data.df &lt;- data.df[order(data.df[, "timeSeries"]),]

  ########################################################################
  ## derive the data with equal interval:  equalInterval.fn
  ########################################################################
  xx0 &lt;- data.df[, "timeSeries"]
  yy0 &lt;- data.df[, responseName]
  a &lt;- table(diff(xx0))
  if (length(a) &gt; 1)
  {
    print("the time interval is not fixed and thus may need to be adjusted.")
  }

  dataEqualSpace.mat &lt;-
    equalInterval.fn(x = xx0, y = yy0, Interval = equal.interval)

  ########################################################################
  ## fix missing value:  fixMissing.fn
  ########################################################################
  #fixMissing = TRUE; fixMethod = "linearInterpolation"
  if (fixMissing == TRUE) {
    dataFixNA.mat &lt;- fixMissing.fn(y = dataEqualSpace.mat[, "signal"],
                                   x = dataEqualSpace.mat[, "timeSeries"],
                                   Method = fixMethod)
  }

  ########################################################################
  ## calculate MODD:  MODD.fn
  ########################################################################
  if (calculateMODD == TRUE) {
    theMODD &lt;-
      MODD.fn(y = dataEqualSpace.mat[, "signal"], Interval = equal.interval)
  } else {
    theMODD &lt;- NA
  }

  ########################################################################
  ## calculate CONGA:  CONGA.fn
  ########################################################################
  if (calculateCONGA == TRUE) {
    theCONGA &lt;-
      CONGA.fn(y = dataEqualSpace.mat[, "signal"],
               Interval = equal.interval,
               n = n.CONGA)
  } else {
    theCONGA &lt;- NA
  }

  ########################################################################
  # calculate multiscale entropy
  ########################################################################
  xx1 &lt;- dataFixNA.mat[, 1]
  yy1 &lt;- dataFixNA.mat[, 2]
  theMSE.mat &lt;-
    MSEbyC.fn(
      yy1,
      scaleMax,
      scaleStep,
      mMin = m,
      mMax = m,
      mStep = 1,
      rMin = r,
      rMax = r,
      I = I
    )

  summaryAdj.vec &lt;-
    c(
      "N.total" = length(yy0),
      "N.missing" = sum(is.na(yy0)),
      "Mean" = mean(yy1),
      "SD" = sd(yy1),
      "Median" = median(yy1),
      "MAD" = mad(yy1)
    )
  if (iFile == 1) {
    summaryAdj.mat &lt;- summaryAdj.vec
    MSE.mat &lt;- theMSE.mat[, "SampleEntropy"]
    MODD.CONGA.mat &lt;- c(theMODD,  theCONGA)
  } else {
    summaryAdj.mat &lt;- rbind(summaryAdj.mat, summaryAdj.vec)
    MSE.mat &lt;- rbind(MSE.mat, theMSE.mat[, "SampleEntropy"])
    MODD.CONGA.mat &lt;-
      rbind(MODD.CONGA.mat, c(theMODD, theCONGA))
  }

  ########################################################################
  ## plot data :  plotTseries.fn
  ########################################################################
  meanY &lt;- mean(yy0, na.rm = TRUE)
  plotTseries.fn(
    x = xx0,
    y = yy0,
    xAt = NA,
    xLab = NA,
    yRange = NA,
    Frame = TRUE,
    xlab = paste("Time in", timeUnit),
    ylab = responseName,
    pch = 1,
    lty = 1,
    col.point = 1,
    col.line = 1,
    cex.point = 0.5,
    lwd = 1
  )
  lines(range(xx0, na.rm = TRUE), rep(meanY, 2), col = "grey")
  title(
    main = paste0(iFile, ":", sensorIDs[iFile], ":", subjectTypes[iFile],
                  " - Raw Data"),
    sub = paste0(
      "N.total=",
      length(yy0),
      ", N.noNA=",
      sum(!is.na(yy0)),
      ", Mean=",
      round(meanY, 3),
      ", SD=",
      round(sd(yy0, na.rm =
                 TRUE), 3)
    )
  )

  plotTseries.fn(
    x = xx1,
    y = yy1,
    xAt = NA,
    xLab = NA,
    yRange = NA,
    Frame = TRUE,
    xlab = paste("Time in", timeUnit),
    ylab = responseName,
    pch = 1,
    lty = 1,
    col.point = 1,
    col.line = 1,
    cex.point = 0.5,
    lwd = 1
  )
  lines(range(data.df[, "timeSeries"], na.rm = TRUE), rep(mean(yy1, na.rm =
                                                                 TRUE), 2),
        col = "grey")
  title(
    main = paste0(iFile, ":", sensorIDs[iFile], ":", subjectTypes[iFile],
                  " - Adjusted Data"),
    sub = paste0(
      "N.total=",
      round(summaryAdj.vec["N.total"], 0),
      ", Entropy=",
      theMSE.mat[1, "SampleEntropy"],
      ", Mean=",
      round(summaryAdj.vec["Mean"], 3),
      ", SD=",
      round(summaryAdj.vec["SD"], 3)
    )
  )
}
dimnames(MSE.mat) &lt;- list(sensorIDs, Scales)
dimnames(MODD.CONGA.mat) &lt;- list(sensorIDs, c("MODD", "CONGA"))
dimnames(summaryAdj.mat)[[1]] &lt;- sensorIDs
# dev.off()

######################################################################################
# compare mean, median, sample entropy et al by group
# there must be at least 2 different types
# in file "00filelist.csv" by modifying manually
######################################################################################
# Calculate the major results for group comparison among different disease statuses

Types &lt;- unique(subjectTypes)
Types &lt;- Types[order(Types)]
nType &lt;- length(Types)
nPair &lt;- nType * (nType - 1) / 2

# for average value in each type
resultMean.vec &lt;-
  pairwiseComparison.fn(y = summaryAdj.mat[, "Mean"],
                        INDEX = subjectTypes, na.rm =
                          TRUE)

# for MSE in each scale and each type
for (i in 1:dim(MSE.mat)[2]) {
  theResult.vec &lt;-
    pairwiseComparison.fn(y = MSE.mat[, i],
                          INDEX = subjectTypes,
                          na.rm = TRUE)
  if (i == 1) {
    pvalSSMD.mat &lt;- theResult.vec
  } else {
    pvalSSMD.mat &lt;- rbind(pvalSSMD.mat, theResult.vec)
  }
}
dimnames(pvalSSMD.mat)[1] &lt;- list(Scales)

# write.csv(file = "MSE.csv", MSE.mat)
# write.csv(file = "pvalSSMD.csv", pvalSSMD.mat)
# write.csv(file = "groupComp.mean.csv", round(resultMean.vec, 5))
# write.csv(file = "groupMeanSD.MSE.csv", round(pvalSSMD.mat[,-(1:(nPair *5))], 5))
# write.csv(file = "groupSSMDpvalue.MSE.csv", pvalSSMD.mat[, 1:(nPair *5)])
print(MSE.mat)
print(pvalSSMD.mat)
print(round(resultMean.vec, 5))
print(round(pvalSSMD.mat[,-(1:(nPair *5))], 5))
print(pvalSSMD.mat[, 1:(nPair *5)])


outNames &lt;- dimnames(pvalSSMD.mat)[[2]]
isSSMD &lt;- substring(outNames, 1, 4) == "SSMD"
SSMD.mean.vec &lt;- resultMean.vec[isSSMD]
SSMD.mat &lt;- as.matrix(pvalSSMD.mat[, isSSMD])
ssmdEffect.mat &lt;-
  matrix(
    NA,
    nrow = nrow(SSMD.mat),
    ncol = ncol(SSMD.mat),
    dimnames = dimnames(SSMD.mat)
  )
for (i in 1:ncol(ssmdEffect.mat)) {
  ssmdEffect.mat[, i] &lt;-
    ssmdEffect.fn(SSMD.mat[, i], criterion = "subType")
}
dimnames(ssmdEffect.mat)[1] &lt;-
  list(paste0("sampleEntropy", substring(Scales + 100, 2, 3)))
# write.csv(file = "groupEffect.csv", data.frame(t(ssmdEffect.mat),
#                                               "glucose" = ssmdEffect.fn(SSMD.mean.vec, criterion =
#                                                                           "subType")
#                        ))
print(data.frame(t(ssmdEffect.mat),
                  "glucose" = ssmdEffect.fn(SSMD.mean.vec, criterion =
                                            "subType")
                       ))

######################################################################################
# plot sample entropy by individual and by group
######################################################################################
scalesInTime &lt;- Scales * equal.interval
# filename &lt;- "MSEplot.pdf"
# pdf(filename)
par(mfrow = c(1, 1))
col.vec &lt;- rep(NA, length(subjectTypes))
for (i in 1:nType) {
  col.vec[subjectTypes == Types[i]] &lt;- i
}
MSEplot.fn(
  scalesInTime,
  MSE = t(MSE.mat),
  Name = Types,
  responseName = "glucose",
  timeUnit = "minute",
  byGroup = FALSE,
  MSEsd = NA,
  N = NA,
  stdError = TRUE,
  xRange = NA,
  yRange = NA,
  pch = 1,
  las = 2,
  col = col.vec,
  Position = "topleft",
  cex.legend = 0.0005,
  main = "A: MSE by individual"
)
legend(
  "topleft",
  legend = paste0(Types, "(N=", table(subjectTypes), ")"),
  col = 1:nType,
  cex = 1,
  lty = 1,
  pch = 1
)

outNames &lt;- dimnames(pvalSSMD.mat)[[2]]
MSEmean.mat &lt;- pvalSSMD.mat[, substring(outNames, 1, 4) == "mean"]
MSEsd.mat &lt;- pvalSSMD.mat[, substring(outNames, 1, 2) == "SD"]
N.mat &lt;- pvalSSMD.mat[, substring(outNames, 1, 1) == "N"]
MSEplot.fn(
  scalesInTime,
  MSE = MSEmean.mat,
  Name = Types,
  responseName = "glucose",
  timeUnit = "minute",
  byGroup = TRUE,
  MSEsd = MSEsd.mat,
  N = N.mat,
  stdError = TRUE,
  xRange = NA,
  yRange = NA,
  las = 2,
  col = NA,
  pch = 1:length(Types),
  Position = "topleft",
  cex.legend = 0.75,
  main = "B: MSE by group"
)
# dev.off()

######################################################################################
# plot results by pairwise comparison of groups : antenna plot
######################################################################################

# filename &lt;- "antennaPlot.pdf"
# pdf(filename)
par(mfrow = c(1, 1))
# antenna plot for average glucose level
mDiff.vec &lt;- resultMean.vec[substring(outNames, 1, 5) == "mDiff"]
CIlower.vec &lt;-
  resultMean.vec[substring(outNames, 1, 7) == "CIlower"]
CIupper.vec &lt;-
  resultMean.vec[substring(outNames, 1, 7) == "CIupper"]
pairNames &lt;- gsub("mDiff_", "", names(mDiff.vec), fixed = TRUE)
xRange &lt;-
  range(c(
    range(CIlower.vec, na.rm = TRUE),
    0,
    range(CIupper.vec, na.rm = TRUE)
  ))
yRange &lt;- range(c(0, SSMD.mean.vec), na.rm = TRUE)
condt &lt;- !is.na(mDiff.vec) &amp; !is.na(SSMD.mean.vec)
antennaPlot.fn(
  Mean = mDiff.vec[condt],
  SSMD = SSMD.mean.vec[condt],
  Name = pairNames[condt],
  CIlower = CIlower.vec[condt],
  CIupper = CIupper.vec[condt],
  xRange = xRange,
  yRange = yRange,
  col = 1:length(pairNames[condt]),
  pch = 1:length(pairNames[condt]),
  cex = 0.6,
  Position = "bottomright",
  main = "Average Glucose Level"
)

#antenna plots for MSE at each scale
mDiff.mat &lt;-
  as.matrix(pvalSSMD.mat[, substring(outNames, 1, 5) == "mDiff"])
CIlower.mat &lt;-
  as.matrix(pvalSSMD.mat[, substring(outNames, 1, 7) == "CIlower"])
CIupper.mat &lt;-
  as.matrix(pvalSSMD.mat[, substring(outNames, 1, 7) == "CIupper"])
xRange &lt;-
  range(c(
    range(CIlower.mat, na.rm = TRUE),
    0,
    range(CIupper.mat, na.rm = TRUE)
  ))
yRange &lt;- range(c(0, range(SSMD.mat, na.rm = TRUE)))
for (i in 1:length(Scales)) {
  Main &lt;-
    paste0("Sample entropy at Scale = ",
           Scales[i],
           " (i.e., in ",
           scalesInTime[i],
           " ",
           timeUnit,
           "s)")
  condt &lt;- !is.na(mDiff.mat[i, ]) &amp; !is.na(SSMD.mat[i, ])
  antennaPlot.fn(
    Mean = mDiff.mat[i, condt],
    SSMD = SSMD.mat[i, condt],
    Name = pairNames[condt],
    CIlower = CIlower.mat[i, condt],
    CIupper = CIupper.mat[i, condt],
    xRange = xRange,
    yRange = yRange,
    col = 1:length(pairNames[condt]),
    pch = 1:length(pairNames[condt]),
    cex = 0.6,
    Position = "bottomright",
    main = Main
  )
}
# dev.off()
</code></pre>

<hr>
<h2 id='CONGA.fn'>
Function to calculate the continuous overlapping net glycemic action (CONGA)
</h2><span id='topic+CONGA.fn'></span>

<h3>Description</h3>

<p>For each observation after the first n hours of observations, the difference between the current observation and the observation n hours previous was calculated. CONGA is defined as the standard deviation of the differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CONGA.fn(y, Interval = 5, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CONGA.fn_+3A_y">y</code></td>
<td>

<p>measured response, must be evenly spaced in measured time
</p>
</td></tr>
<tr><td><code id="CONGA.fn_+3A_interval">Interval</code></td>
<td>

<p>number of minutes between two consecutive time points
</p>
</td></tr>
<tr><td><code id="CONGA.fn_+3A_n">n</code></td>
<td>

<p>the length of a segment in CONGA
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of CONGA
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang, Dandan Wang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
y = rnorm( 3*24*60/5, mean=5, sd=0.1)
CONGA.fn(y, Interval = 5, n=2)
</code></pre>

<hr>
<h2 id='equalInterval.fn'>
Function to derive the data with equal interval
</h2><span id='topic+equalInterval.fn'></span>

<h3>Description</h3>

<p>Function to derive the data with equal interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equalInterval.fn(x, y, Interval = NA, minGap = 4 * Interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equalInterval.fn_+3A_x">x</code></td>
<td>

<p>time sequence
</p>
</td></tr>
<tr><td><code id="equalInterval.fn_+3A_y">y</code></td>
<td>

<p>measured response
</p>
</td></tr>
<tr><td><code id="equalInterval.fn_+3A_interval">Interval</code></td>
<td>

<p>interval indicating equal space between two consecutive points
</p>
</td></tr>
<tr><td><code id="equalInterval.fn_+3A_mingap">minGap</code></td>
<td>

<p>the length of a chain of continuous missing values in which the missing values will not be derived from the neighbor points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to derive the data with equal interval for a timeseries
</p>


<h3>Value</h3>

<p>a matrix with equally spaced time sequence and corresponding signal value
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.mat &lt;-
   cbind( "timeSeries"=c(0,  3,  6, 9, 11, 21, 24, 27, 33, 38, 39, 42),
          "signal"=c(3.930, 3.973, 4.005, 4.110, 4.164, 4.165, 4.186,
          4.265, 4.266, 4.357, 4.503, 4.690) )
dataEqualSpace.mat &lt;- equalInterval.fn(x=data.mat[,1], y=data.mat[,2], Interval=3)
data.mat
dataEqualSpace.mat
</code></pre>

<hr>
<h2 id='fac2char.fn'>
function to convert a factor to a vector
</h2><span id='topic+fac2char.fn'></span>

<h3>Description</h3>

<p>function to convert a factor to a vector of characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2char.fn(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2char.fn_+3A_x">x</code></td>
<td>

<p>a factor
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to convert a factor to a vector
</p>


<h3>Value</h3>

<p>a vector of characters
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
fac2char.fn(dataFileType.df[,1])
</code></pre>

<hr>
<h2 id='fixMissing.fn'>
Function to fix missing values in a vector
</h2><span id='topic+fixMissing.fn'></span>

<h3>Description</h3>

<p>Function to fix missing values in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixMissing.fn(y, x, Method = c("skip", "linearInterpolation", "loess", "dayCycle"),
OBScycle = 24 * 60 * 60/10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixMissing.fn_+3A_y">y</code></td>
<td>

<p>a vector of data with missing values
</p>
</td></tr>
<tr><td><code id="fixMissing.fn_+3A_x">x</code></td>
<td>

<p>a vector for a series of consecutive time indices
</p>
</td></tr>
<tr><td><code id="fixMissing.fn_+3A_method">Method</code></td>
<td>

<p>method options for fixing missing value. &quot;skip&quot;: skip all missing values; &quot;loess&quot;: use local fitting by loess(); &quot;dayCycle&quot;:a missing value is replaced by the mean of the two values one day ahead and one day behind plus the mean of the differences between the two edge points and their corresponding means of the two values one day head and one day behind in a segment with missing values in which the missing value belongs to.
</p>
</td></tr>
<tr><td><code id="fixMissing.fn_+3A_obscycle">OBScycle</code></td>
<td>

<p>number of observations in a full cycle
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of data from 'y'  but with missing values fixed
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.mat &lt;-
   cbind( "x"=c(0,  3,  6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42),
          "signal"=c(3.930, 3.973, 4.005, NA, 4.164, 4.190, 4.205, NA, 4.186,
          4.265, NA, 4.266, 4.357, 4.503, 4.690) )
dataFixNA.mat &lt;- fixMissing.fn( y=data.mat[,2], x=data.mat[,1], Method="linearInterpolation")
data.mat
dataFixNA.mat
</code></pre>

<hr>
<h2 id='MODD.fn'>
Function to calculate the mean of daily differences (MODD)
</h2><span id='topic+MODD.fn'></span>

<h3>Description</h3>

<p>Calculates MODD which is the absolute value of the difference between glucose values taken on two consecutive days at the same time was calculated; the MODD is the mean of these differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MODD.fn(y, Interval = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MODD.fn_+3A_y">y</code></td>
<td>

<p>measured response, must be evenly spaced in measured time
</p>
</td></tr>
<tr><td><code id="MODD.fn_+3A_interval">Interval</code></td>
<td>

<p>number of minutes between two consecutive time points
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of MODD
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
y = rnorm( 3*24*60/5, mean=5, sd=0.1)
MODD.fn(y, Interval = 5)
</code></pre>

<hr>
<h2 id='MSEbyC.fn'>
call a C function to calculate multiscale entropy
</h2><span id='topic+MSEbyC.fn'></span>

<h3>Description</h3>

<p>Function to call a C function to calculate multiscale entropy (MSE)
of an equally spaced time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSEbyC.fn(x, scaleMax = 10, scaleStep = 1, mMin = 2, mMax = 2, mStep = 1, rMin = 0.15,
rMax = 0.15, I = 400000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSEbyC.fn_+3A_x">x</code></td>
<td>

<p>A numeric vector, with data for a regularly spaced time series. No missing value is allowed because the C program is not set up to handle missing value.
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_scalemax">scaleMax</code></td>
<td>

<p>maximal value of scale factors for coarse graining in the MSE algorithm. The scale factors are a sequence from 1 to a value no more than 'scaleMax' with equal space 'scaleStep'.  Scale factors are positive integers that specify bin size for coarse graining: the number of consecutive observations in 'x' that form a bin and are averaged in the first step of the algorithm.
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_scalestep">scaleStep</code></td>
<td>

<p>see 'scaleMax'
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_mmin">mMin</code></td>
<td>

<p>A sequence from 'mMin' to 'mMax' with equal space of 'mStep' that defines the vector of positive integers that give the window size for the entropy calculations in the second step of the algorithm:  the number of consecutive _bins_ over which similarity between subsequences is of interest.  Typical values in the sequence are 1, 2, or 3.
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_mmax">mMax</code></td>
<td>

<p>See 'Min'
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_mstep">mStep</code></td>
<td>

<p>See 'Min'
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_rmin">rMin</code></td>
<td>

<p>A sequence from 'rMin' to 'rMax' with equal space of 0.05 that defines  coefficients for similarity thresholds. Typical values in the sequence are 0.15, 0.2.  r*sd(x) must be in the same units as 'x'. Averages in two bins are defined to be similar if they differ by 'r*sd(x)' or less.
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_rmax">rMax</code></td>
<td>

<p>See 'rMin'
</p>
</td></tr>
<tr><td><code id="MSEbyC.fn_+3A_i">I</code></td>
<td>

<p>the maximal number of points to be used for calculating MSE cFolder: The directory in which .c is held as well as in which temporary files associated with running C are created/removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to call a C function to calculate multiscale entropy (MSE)
of an equally spaced time series.
</p>


<h3>Value</h3>

<p>A data frame with with one row for each combination of 'Scale', 'm' and 'rSD'.  Columns are &quot;Scale&quot;, &quot;m&quot;, &quot;rSD&quot;, and &quot;SampEn&quot; (the calculated sample entropy). The data frame will also have an attribute &quot;SD&quot;, the standard deviation of 'x'. rSD = r*sd(x)
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
data.df0 &lt;- read.table(paste(dataFolder, dataFiles[1], sep="/"),
        skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
if( !Header ) {
	data.df0 &lt;- data.df0[, 1:length(columnNames)]
    dimnames(data.df0)[[2]] &lt;-  columnNames
}
if( !is.na(idxNA) ) data.df0[ data.df0[, responseName] == idxNA, responseName] &lt;- NA
for( i in 1:length(timeStamp.column) ) {
	if(i==1) { timeStamp.vec &lt;- data.df0[, timeStamp.column[i] ] } else {
		 timeStamp.vec &lt;- paste0(timeStamp.vec, " ", data.df0[, timeStamp.column[i] ])
	}
}
Time.mat &lt;- timeSeqConversion.fn(time.stamp=timeStamp.vec, time.format=time.format,
            timeUnit=timeUnit)
data.df &lt;- data.frame( timeStamp.vec, Time.mat[,1], data.df0[,responseName] )
dimnames(data.df)[[2]] &lt;- c("timeStamp", "timeSeries", responseName)
data.df &lt;- data.df[ order(data.df[, "timeSeries"]), ]
data.mat &lt;- data.df[, c("timeSeries", responseName)]
data.mat &lt;- data.mat[!is.na(data.mat[,2]), ]
MSE.mat &lt;- MSEbyC.fn(data.mat[,2], scaleMax, scaleStep, mMin=m, mMax=m, mStep=1,
          rMin=r, rMax=r, I=I)
MSE.mat
</code></pre>

<hr>
<h2 id='MSEplot.fn'>
Plot the mean and standard error or standard deviation of multiscale entropy by group
</h2><span id='topic+MSEplot.fn'></span>

<h3>Description</h3>

<p>function to plot the mean and standard error or standard deviation of multiscale entropy by group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSEplot.fn(Scale, MSE, Name, responseName = NA, timeUnit = "", byGroup = TRUE,
MSEsd = NA, N = NA, stdError = TRUE, xRange = NA, yRange = NA, las = 2, col = NA,
pch = NA, Position = "topleft", cex.legend = 0.75, main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSEplot.fn_+3A_scale">Scale</code></td>
<td>

<p>a vector for scale
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_mse">MSE</code></td>
<td>

<p>matrix for entropy if byGroup=FALSE, and otherwise for average entropy value in a group   at a scale. In the matrix, the row is for scale and column for individuals or groups.
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_name">Name</code></td>
<td>

<p>vector of names for groups
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_responsename">responseName</code></td>
<td>

<p>name to represent the response to be analyzed, such as 'glucose'
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_timeunit">timeUnit</code></td>
<td>

<p>the time unit for scale
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_bygroup">byGroup</code></td>
<td>

<p>If byGroup = TRUE, multiscale entropy is plotted by groups; otherwise, by individuals
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_msesd">MSEsd</code></td>
<td>

<p>matrix for standard deviation of entropy value in a group at a scale
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_n">N</code></td>
<td>

<p>matrix for number of subjects in a group at a scale
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_stderror">stdError</code></td>
<td>

<p>if it is true, the length of a vertical bar represent 2*standard error;  otherwise, the length of a vertical bar represent 2*standard deviation
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_xrange">xRange</code></td>
<td>

<p>range for the x-axis
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_yrange">yRange</code></td>
<td>

<p>range for the y-axis
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_las">las</code></td>
<td>

<p>las for the y-axis
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_col">col</code></td>
<td>

<p>vector for the colors to indicate groups or individuals
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_pch">pch</code></td>
<td>

<p>vector for the point types to indicate groups or individuals
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_position">Position</code></td>
<td>

<p>position for the legend
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_cex.legend">cex.legend</code></td>
<td>

<p>cex for the legend
</p>
</td></tr>
<tr><td><code id="MSEplot.fn_+3A_main">main</code></td>
<td>

<p>main title for title()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to plot the mean and standard error or standard deviation of multiscale entropy by group
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
scalesInTime &lt;- Scales*equal.interval
MSE.mat &lt;- read.csv(file=system.file("SPEC", "MSE.csv", package = package.name), row.names=1)
Types &lt;- unique( subjectTypes )
Types &lt;- Types[order(Types)]
nType &lt;-length(Types)
col.vec &lt;- rep(NA, length(subjectTypes) )
for( i in 1:nType ) { col.vec[ subjectTypes == Types[i] ] &lt;- i }
MSEplot.fn(scalesInTime, MSE=t(MSE.mat), Name=Types, responseName="glucose", timeUnit="minute",
          byGroup=FALSE, MSEsd=NA, N=NA, stdError=TRUE, xRange=NA, yRange=NA,
          pch=rep(1, dim(MSE.mat)[1]),las=2, col=col.vec, Position="topleft",
          cex.legend=0.0005, main="A: MSE by individual")
legend("topleft", legend=paste0(Types, "(N=", table( subjectTypes ), ")"),
      col=1:nType, cex=1, lty=1, pch=1)

</code></pre>

<hr>
<h2 id='pairwiseComparison.fn'>
function to calculate mean difference and its confidence interval, SSMD, p-value of t.test for pairwise comparison
</h2><span id='topic+pairwiseComparison.fn'></span>

<h3>Description</h3>

<p>function to calculate mean difference and its confidence interval, SSMD, p-value of t.test for pairwise comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseComparison.fn(y, INDEX, na.rm = TRUE, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseComparison.fn_+3A_y">y</code></td>
<td>

<p>response value
</p>
</td></tr>
<tr><td><code id="pairwiseComparison.fn_+3A_index">INDEX</code></td>
<td>

<p>vector for group names
</p>
</td></tr>
<tr><td><code id="pairwiseComparison.fn_+3A_na.rm">na.rm</code></td>
<td>

<p>whether to remove value for calculation
</p>
</td></tr>
<tr><td><code id="pairwiseComparison.fn_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level for two-sided t-test
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to calculate mean difference and its confidence interval, SSMD, p-value of t.test for pairwise comparison
</p>


<h3>Value</h3>

<p>a vector for calculated mean difference, its upper and lower bounds of CI, SSMD and pvalue in each pairs of group comparison, along with mean, standard deviation, and sample size in each group
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
MSE.mat &lt;- read.csv(file=system.file("SPEC", "MSE.csv", package = package.name), row.names=1)
pairwiseComparison.fn(y=MSE.mat[, 1], INDEX=subjectTypes, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='plotTseries.fn'>
function to plot time series data
</h2><span id='topic+plotTseries.fn'></span>

<h3>Description</h3>

<p>function to plot time series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTseries.fn(x, y, xAt = NA, xLab = NA, yRange = NA, Frame = TRUE, xlab = "",
ylab = "", pch = 1, lty = 1, col.point = 1, col.line = 1, cex.point = 1, lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTseries.fn_+3A_x">x</code></td>
<td>

<p>time in continuous value such as in seconds or minutes, (e.g. the return from timeSeqConversion.fn)
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_y">y</code></td>
<td>

<p>measured response value
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_xat">xAt</code></td>
<td>

<p>a vector to indicate where the labels in the x-axis are
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_xlab">xLab</code></td>
<td>

<p>a vector to indicate what the labels in the x-axis are
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_yrange">yRange</code></td>
<td>

<p>range for y in the plot
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_frame">Frame</code></td>
<td>

<p>whether the plot frame should be drawn
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_xlab">xlab</code></td>
<td>

<p>as in plot()
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_ylab">ylab</code></td>
<td>

<p>as in plot()
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_pch">pch</code></td>
<td>

<p>as in plot()
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_lty">lty</code></td>
<td>

<p>as in plot()
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_col.point">col.point</code></td>
<td>

<p>the color for the points
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_col.line">col.line</code></td>
<td>

<p>the color for the line
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_cex.point">cex.point</code></td>
<td>

<p>cex for the points
</p>
</td></tr>
<tr><td><code id="plotTseries.fn_+3A_lwd">lwd</code></td>
<td>

<p>as in plot()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to plot time series data
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
data.df0 &lt;- read.table(paste(dataFolder, dataFiles[1], sep="/"),
            skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
if( !Header ) {
	data.df0 &lt;- data.df0[, 1:length(columnNames)]
    dimnames(data.df0)[[2]] &lt;-  columnNames
}
if( !is.na(idxNA) ) data.df0[ data.df0[, responseName] == idxNA, responseName] &lt;- NA
for( i in 1:length(timeStamp.column) ) {
	if(i==1) { timeStamp.vec &lt;- data.df0[, timeStamp.column[i] ] } else {
		 timeStamp.vec &lt;- paste0(timeStamp.vec, " ", data.df0[, timeStamp.column[i] ])
	}
}
Time.mat &lt;- timeSeqConversion.fn(time.stamp=timeStamp.vec, time.format=time.format,
            timeUnit=timeUnit)
data.df &lt;- data.frame( timeStamp.vec, Time.mat[,1], data.df0[,responseName] )
dimnames(data.df)[[2]] &lt;- c("timeStamp", "timeSeries", responseName)
data.df &lt;- data.df[ order(data.df[, "timeSeries"]), ]
plotTseries.fn(	x=data.df[, "timeSeries"], y=data.df[, responseName],
				xAt=0:14*720, xLab=0:14/2, yRange=NA, Frame=TRUE,
				xlab="Time in Days", ylab=responseName, pch=1, lty=1,
				col.point=1, col.line=1, cex.point=0.5, lwd=1 )
</code></pre>

<hr>
<h2 id='setSPEC.fn'>
Load settings for the selected SPEC parameter.
</h2><span id='topic+setSPEC.fn'></span>

<h3>Description</h3>

<p>A function to load settings for the selected SPEC parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSPEC.fn(SPEC.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSPEC.fn_+3A_spec.name">SPEC.name</code></td>
<td>

<p>the SPEC name to load, which is a R script name. one of &quot;SPEC.FreestyleLibre.R&quot;, &quot;SPEC.Glutalor.R&quot; and &quot;SPEC.Medtronic.R&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to load settings for the selected SPEC parameter.
If you want to use the example data in the package &quot;CGManalyzer&quot;, you have to choose &quot;SPECexample.R&quot;. If you want to run your own data, you cannot choose &quot;SPECexample.R&quot;, instead, you need to choose one of &quot;SPEC.FreestyleLibre.R&quot;, &quot;SPEC.Glutalor.R&quot; and &quot;SPEC.Medtronic.R&quot;.
</p>


<h3>Value</h3>

<p>no value returned
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set SPEC for reading data
package.name &lt;- "CGManalyzer"
options(scipen = 999)
mainFolder &lt;- getwd()
SPEC.name &lt;- "SPECexample.R"
setSPEC.fn(SPEC.name)
</code></pre>

<hr>
<h2 id='ssmdEffect.fn'>
function to derive the type of effect size based on SSMD values
</h2><span id='topic+ssmdEffect.fn'></span>

<h3>Description</h3>

<p>function to derive the type of effect size based on SSMD values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssmdEffect.fn(ssmd.vec, criterion = c("mainType", "subType"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssmdEffect.fn_+3A_ssmd.vec">ssmd.vec</code></td>
<td>

<p>a vector for SSMD value
</p>
</td></tr>
<tr><td><code id="ssmdEffect.fn_+3A_criterion">criterion</code></td>
<td>

<p>whether use the criterion for deriving the main effect type or the sub-type
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to derive the type of effect size based on SSMD values
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>
<p>Zhang XHD, 2011. Optimal High-Throughput Screening: Practical  Experimental Design and Data Analysis for Genome-scale RNAi Research.  Cambridge University Press, Cambridge, UK
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SSMD.vec = c(-3.4, -5, 0.198, 0.055, 0.181, 2, 3, 1.5, 6, 0.25)
ssmdEffect.fn(SSMD.vec, criterion="subType")
</code></pre>

<hr>
<h2 id='summaryCGM.fn'>
Function to calculate the summary statistics for each subject or sensor:  number of subjects or sensors, minimum, 1st quartile, median, mean, 2nd quartile, maximum, standard deviation, MAD
</h2><span id='topic+summaryCGM.fn'></span>

<h3>Description</h3>

<p>Function to calculate the summary statistics for each subject or sensor:  number of subjects or sensors, minimum, 1st quartile, median, mean, 2nd quartile, maximum, standard deviation, MAD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryCGM.fn(dataFolder, dataFiles, responseNames, sensorIDs, columnNames = NULL,
skip = 0, header = TRUE, comment.char = "", sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryCGM.fn_+3A_datafolder">dataFolder</code></td>
<td>

<p>folder directory for holding raw CGM data
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_datafiles">dataFiles</code></td>
<td>

<p>file names for holding raw CGM data, usually one file for one sensor
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_responsenames">responseNames</code></td>
<td>

<p>name for the response
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_sensorids">sensorIDs</code></td>
<td>

<p>ID's for sensors
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_columnnames">columnNames</code></td>
<td>

<p>column names for the raw data
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_skip">skip</code></td>
<td>

<p>number of lines to be skip in data file when using read.table
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_header">header</code></td>
<td>

<p>the same as in read.table()
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_comment.char">comment.char</code></td>
<td>

<p>the same as in read.table()
</p>
</td></tr>
<tr><td><code id="summaryCGM.fn_+3A_sep">sep</code></td>
<td>

<p>the same as in read.table()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to calculate the summary statistics for each subject or sensor:  number of subjects or sensors, minimum, 1st quartile, median, mean, 2nd quartile, maximum, standard deviation, MAD
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
summary.arr &lt;- summaryCGM.fn(dataFolder, dataFiles, responseName, sensorIDs, columnNames,
              skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
summary.arr[1:6, ,1]
</code></pre>

<hr>
<h2 id='timeSeqConversion.fn'>
function to convert a matrix (with columns for year, month, day, minute and/or second)
to a time sequence in a unit of minute or second
</h2><span id='topic+timeSeqConversion.fn'></span>

<h3>Description</h3>

<p>function to convert a matrix (with columns for year, month, day, minute and/or second)
to a time sequence in a unit of minute or second
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSeqConversion.fn(time.stamp, time.format = "yyyy:mm:dd:hh:nn", timeUnit = "minute")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeSeqConversion.fn_+3A_time.stamp">time.stamp</code></td>
<td>

<p>a vector for the time stamp. It can have any format such as &quot;2016:08:11:09:14:00&quot;,  &quot;11/08/2016 09:14:00&quot; and others. The requirement is simply that the positions for year, month, day, hour, minute, second are fixed and consistent in all data files and &quot;0&quot; before a non-zero number cannot be skipped.
</p>
</td></tr>
<tr><td><code id="timeSeqConversion.fn_+3A_time.format">time.format</code></td>
<td>

<p>a string to specify the format in time.stamp in a study, such as &quot;yyyy:mm:dd:hh:nn:ss:ii&quot;, &quot;dd/mm/yyyy hh:nn:ss:ii&quot; and others which must have 'y' for year, 'm' for month, 'd' for day, 'h' for hour, 'n' for minute, 's' for second, 'i' for millisecond(one thousandth of a second), each uniquely
</p>
</td></tr>
<tr><td><code id="timeSeqConversion.fn_+3A_timeunit">timeUnit</code></td>
<td>

<p>minimal time unit in time.stamp. can be 'minute' or 'second'
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to convert a matrix (with columns for year, month, day, minute and/or second)
to a time sequence in a unit of minute or second
</p>


<h3>Value</h3>

<p>a matrix with 6 columns for timeseries, year, month, day, hour and minute, respectively
</p>


<h3>Author(s)</h3>

<p>Xiaohua Douglas Zhang
</p>


<h3>References</h3>

<p>Zhang XD, Zhang Z, Wang D. 2018. CGManalyzer: an R package for analyzing continuous glucose monitoring studies. Bioinformatics 34(9): 1609-1611 (DOI: 10.1093/bioinformatics/btx826).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CGManalyzer)
package.name &lt;- "CGManalyzer"
source( system.file("SPEC", "SPECexample.R", package = package.name) )
data.df0 &lt;- read.table(paste(dataFolder, dataFiles[1], sep="/"),
            skip=Skip, header=Header, comment.char=Comment.char, sep=Sep)
if( !Header ) {
	data.df0 &lt;- data.df0[, 1:length(columnNames)]
    dimnames(data.df0)[[2]] &lt;-  columnNames
}
if( !is.na(idxNA) ) data.df0[ data.df0[, responseName] == idxNA, responseName] &lt;- NA
for( i in 1:length(timeStamp.column) ) {
	if(i==1) { timeStamp.vec &lt;- data.df0[, timeStamp.column[i] ] } else {
		 timeStamp.vec &lt;- paste0(timeStamp.vec, " ", data.df0[, timeStamp.column[i] ])
	}
}
Time.mat &lt;- timeSeqConversion.fn(time.stamp=timeStamp.vec, time.format=time.format,
            timeUnit=timeUnit)
Time.mat[1:6,]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
