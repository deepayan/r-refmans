<!DOCTYPE html><html><head><title>Help for package ppsbm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ppsbm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARI'><p>Adjusted Rand Index (ARI)</p></a></li>
<li><a href='#bootstrap_and_CI'><p>Bootstrap and Confidence Interval</p></a></li>
<li><a href='#classInd'><p>Function for k-means</p></a></li>
<li><a href='#confidenceInterval'><p>Confidence Interval</p></a></li>
<li><a href='#convertGroupPair'><p>Convert group pair <code class="reqn">(q,l)</code></p></a></li>
<li><a href='#convertNodePair'><p>Convert node pair <code class="reqn">(i,j)</code></p></a></li>
<li><a href='#correctTau'><p>Handling of values of <code class="reqn">\tau</code></p></a></li>
<li><a href='#find_ql'><p>Convert index into group pair</p></a></li>
<li><a href='#find_ql_diff'><p>Convert index into group pair in tauDown_Q</p></a></li>
<li><a href='#generated_Q3'><p>Generated graph with 50 individuals and 3 clusters</p></a></li>
<li><a href='#generated_Q3_n20'><p>Generated graph with 20 individuals and 3 clusters</p></a></li>
<li><a href='#generated_sol_hist'><p>Generated solution with histogram method</p></a></li>
<li><a href='#generated_sol_kernel'><p>Generated solution with kernel method</p></a></li>
<li><a href='#generateDynppsbm'><p>Data under dynppsbm</p></a></li>
<li><a href='#generateDynppsbmConst'><p>Data under dynppsbm with piecewise constant intensities</p></a></li>
<li><a href='#generatePP'><p>Poisson process</p></a></li>
<li><a href='#generatePPConst'><p>Poisson process  with piecewise constant intensities</p></a></li>
<li><a href='#JEvalMstep'><p>Evaluation of criterion J</p></a></li>
<li><a href='#kernelIntensities'><p>Direct kernel estimator intensities</p></a></li>
<li><a href='#listNodePairs'><p>List node pairs</p></a></li>
<li><a href='#mainVEM'><p>Adaptative VEM algorithm</p></a></li>
<li><a href='#mainVEMPar'><p>VEM step for parallel version</p></a></li>
<li><a href='#modelSelec_QPlot'><p>Plots for model selection</p></a></li>
<li><a href='#modelSelection_Q'><p>Selects the number of groups with ICL</p></a></li>
<li><a href='#Mstep_hist'><p>M step for histograms</p></a></li>
<li><a href='#Mstep_kernel'><p>M step for kernel</p></a></li>
<li><a href='#permuteZEst'><p>Optimal matching between 2 clusterings</p></a></li>
<li><a href='#sortIntensities'><p>Sort intensities</p></a></li>
<li><a href='#statistics'><p>Compute statistics</p></a></li>
<li><a href='#tauDown_Q'><p>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q+1</code></p></a></li>
<li><a href='#tauInitial'><p>List of initial values for <code class="reqn">\tau</code></p></a></li>
<li><a href='#tauKmeansSbm'><p>k-means for SBM</p></a></li>
<li><a href='#taurhoInitial'><p>Sparse setup - <code class="reqn">\rho</code> parameter</p></a></li>
<li><a href='#tauUp_Q'><p>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q-1</code></p></a></li>
<li><a href='#tauUpdate'><p>Update <code class="reqn">\tau</code></p></a></li>
<li><a href='#VEstep'><p>VE step</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering in Longitudinal Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>D. Giorgi, C. Matias, T. Rebafka, F. Villers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daphné Giorgi &lt;daphne.giorgi@sorbonne-universite.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Stochastic block model used for dynamic graphs represented by Poisson processes.
    To model recurrent interaction events in continuous time, an extension of the stochastic block model is proposed where every individual belongs to a latent group and interactions between two individuals follow a conditional inhomogeneous Poisson process with intensity driven by the individuals’ latent groups. The model is shown to be identifiable and its estimation is based on a semiparametric variational expectation-maximization algorithm. Two versions of the method are developed, using either a nonparametric histogram approach (with an adaptive choice of the partition size) or kernel intensity estimators. The number of latent groups can be selected by an integrated classification likelihood criterion.
    Y. Baraud and L. Birgé (2009). &lt;<a href="https://doi.org/10.1007%2Fs00440-007-0126-6">doi:10.1007/s00440-007-0126-6</a>&gt;.
    C. Biernacki, G. Celeux and G. Govaert (2000). &lt;<a href="https://doi.org/10.1109%2F34.865189">doi:10.1109/34.865189</a>&gt;.
    M. Corneli, P. Latouche and F. Rossi (2016). &lt;<a href="https://doi.org/10.1016%2Fj.neucom.2016.02.031">doi:10.1016/j.neucom.2016.02.031</a>&gt;.
    J.-J. Daudin, F. Picard and S. Robin (2008). &lt;<a href="https://doi.org/10.1007%2Fs11222-007-9046-7">doi:10.1007/s11222-007-9046-7</a>&gt;.
    A. P. Dempster, N. M. Laird and D. B. Rubin (1977). <a href="http://www.jstor.org/stable/2984875">http://www.jstor.org/stable/2984875</a>.
    G. Grégoire (1993). <a href="http://www.jstor.org/stable/4616289">http://www.jstor.org/stable/4616289</a>.
    L. Hubert and P. Arabie (1985). &lt;<a href="https://doi.org/10.1007%2FBF01908075">doi:10.1007/BF01908075</a>&gt;.
    M. Jordan, Z. Ghahramani, T. Jaakkola and L. Saul (1999). &lt;<a href="https://doi.org/10.1023%2FA%3A1007665907178">doi:10.1023/A:1007665907178</a>&gt;.
    C. Matias, T. Rebafka and F. Villers (2018). &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasy016">doi:10.1093/biomet/asy016</a>&gt;.
    C. Matias and S. Robin (2014). &lt;<a href="https://doi.org/10.1051%2Fproc%2F201447004">doi:10.1051/proc/201447004</a>&gt;.
    H. Ramlau-Hansen (1983). &lt;<a href="https://doi.org/10.1214%2Faos%2F1176346152">doi:10.1214/aos/1176346152</a>&gt;.
    P. Reynaud-Bouret (2006). &lt;<a href="https://doi.org/10.3150%2Fbj%2F1155735930">doi:10.3150/bj/1155735930</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rfast, clue, gtools, parallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org">https://cran.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-19 16:13:13 UTC; giorgi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-19 16:37:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARI'>Adjusted Rand Index (ARI)</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Compute the Adjusted Rand Index (ARI) between the true latent variables and the estimated latent variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(z, hat.z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARI_+3A_z">z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code> with entries = 0 or 1 : 'true' latent variables</p>
</td></tr>
<tr><td><code id="ARI_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrix of <code class="reqn">Q \times n</code>  with 0&lt;entries&lt;1 : estimated latent variables</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- matrix(c(1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)
hat.z &lt;- matrix(c(0,0,1,1,0,0, 1,1,0,0,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)

ARI(z, hat.z)

</code></pre>

<hr>
<h2 id='bootstrap_and_CI'>Bootstrap and Confidence Interval</h2><span id='topic+bootstrap_and_CI'></span>

<h3>Description</h3>

<p>Not for sparse models and only for histograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_and_CI(sol, Time, R, alpha = 0.05, nbcores = 1, d_part = 5,
  n_perturb = 10, perc_perturb = 0.2, directed, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_and_CI_+3A_sol">sol</code></td>
<td>
<p>sol</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_time">Time</code></td>
<td>
<p>time</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_r">R</code></td>
<td>
<p>Number of bootstrap samples</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_alpha">alpha</code></td>
<td>
<p>Level of confidence : <code class="reqn">1- \alpha</code></p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_nbcores">nbcores</code></td>
<td>
<p>Number of cores for parallel execution
</p>
<p>If set to 1 it does sequential execution
</p>
<p>Beware: parallelization with fork (multicore) : doesn't work on Windows!</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partitions of time interval [0,T], used for kmeans initializations.
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_{part} +1)} - 1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_filename">filename</code></td>
<td>
<p>filename</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# data of a synthetic graph with 50 individuals and 3 clusters

n &lt;- 50
Q &lt;- 3

Time &lt;- generated_Q3$data$Time
data &lt;- generated_Q3$data
z &lt;- generated_Q3$z

Dmax &lt;- 2^3

# VEM-algo hist
sol.hist &lt;- mainVEM(list(Nijk=statistics(data,n,Dmax,directed=FALSE),Time=Time),
     n,Qmin=3,directed=FALSE,method='hist',d_part=1,n_perturb=0)[[1]]

# compute bootstrap confidence bands
boot &lt;- bootstrap_and_CI(sol.hist,Time,R=10,alpha=0.1,nbcores=1,d_part=1,n_perturb=0,
     directed=FALSE)

# plot confidence bands
alpha.hat &lt;- exp(sol.hist$logintensities.ql)
vec.x &lt;- (0:Dmax)*Time/Dmax
ind.ql &lt;- 0
par(mfrow=c(2,3))
for (q in 1:Q){
  for (l in q:Q){
    ind.ql &lt;- ind.ql+1
    ymax &lt;- max(c(boot$CI.limits[ind.ql,2,],alpha.hat[ind.ql,]))
    plot(vec.x,c(alpha.hat[ind.ql,],alpha.hat[ind.ql,Dmax]),type='s',col='black',
        ylab='Intensity',xaxt='n',xlab= paste('(',q,',',l,')',sep=""),
        cex.axis=1.5,cex.lab=1.5,ylim=c(0,ymax),main='Confidence bands')
    lines(vec.x,c(boot$CI.limits[ind.ql,1,],boot$CI.limits[ind.ql,1,Dmax]),col='blue',
        type='s',lty=3)
    lines(vec.x,c(boot$CI.limits[ind.ql,2,],boot$CI.limits[ind.ql,2,Dmax]),col='blue',
        type='s',lty=3)
  }
}

</code></pre>

<hr>
<h2 id='classInd'>Function for k-means</h2><span id='topic+classInd'></span>

<h3>Description</h3>

<p>Function for k-means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classInd(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classInd_+3A_cl">cl</code></td>
<td>
<p>Label list of nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x    : class indicator matrix
</p>

<hr>
<h2 id='confidenceInterval'>Confidence Interval</h2><span id='topic+confidenceInterval'></span>

<h3>Description</h3>

<p>Compute confidence bands for all pair of groups <code class="reqn">(q,l)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidenceInterval(boot.sol, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidenceInterval_+3A_boot.sol">boot.sol</code></td>
<td>
<p>Bootstrap list of estimators</p>
</td></tr>
<tr><td><code id="confidenceInterval_+3A_alpha">alpha</code></td>
<td>
<p>Level of confidence : 1 - <code class="reqn">\alpha</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# data of a synthetic graph with 50 individuals and 3 clusters

n &lt;- 50
Q &lt;- 3

Time &lt;- generated_Q3$data$Time
data &lt;- generated_Q3$data
z &lt;- generated_Q3$z

Dmax &lt;- 2^3

# VEM-algo hist
sol.hist &lt;- mainVEM(list(Nijk=statistics(data,n,Dmax,directed=FALSE),Time=Time),
     n,Qmin=3,directed=FALSE,method='hist',d_part=1,n_perturb=0)[[1]]

# compute bootstrap confidence bands
boot &lt;- bootstrap_and_CI(sol.hist,Time,R=5,alpha=0.1,nbcores=1,d_part=1,n_perturb=0,
     directed=FALSE)

boot.sol &lt;- boot$boot.sol

confidenceInterval(boot.sol)

</code></pre>

<hr>
<h2 id='convertGroupPair'>Convert group pair <code class="reqn">(q,l)</code></h2><span id='topic+convertGroupPair'></span>

<h3>Description</h3>

<p>Gives the index in <code class="reqn">1, \ldots, Q^2</code> (directed) or <code class="reqn">1, \ldots, Q*(Q+1)/2</code> (undirected) that corresponds to group pair <code class="reqn">(q,l)</code>. Works also for vectors of indices <code class="reqn">q</code> and <code class="reqn">l</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertGroupPair(q, l, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertGroupPair_+3A_q">q</code></td>
<td>
<p>Group index <code class="reqn">q</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_l">l</code></td>
<td>
<p>Group index <code class="reqn">l</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Relations between groups <code class="reqn">(q,l)</code> are stored in vectors, whose indexes depend on whether the graph is directed or undirected.
</p>

<dl>
<dt><strong>Directed case :</strong></dt><dd>

<ul>
<li><p> The <code class="reqn">(q,l)</code> group pair is converted into the index <code class="reqn">(q-1)*Q+l</code>
</p>
</li></ul>

</dd>
<dt><strong>Undirected case :</strong></dt><dd>

<ul>
<li><p> The <code class="reqn">(q,l)</code> group pair with <code class="reqn">q&lt;=l</code> is converted into the index <code class="reqn">(2*Q-q+2)*(q-1)/2 +l-q+1</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>Index corresponding to the group pair <code class="reqn">(q,l)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the group pair (3,2) into an index, where the total number of group is 3,
# for directed and undirected graph

q &lt;- 3
l &lt;- 2
Q &lt;- 3

directedIndex &lt;- convertGroupPair(q,l,Q)
undirectedIndex &lt;- convertGroupPair(q,l,Q, FALSE)

</code></pre>

<hr>
<h2 id='convertNodePair'>Convert node pair <code class="reqn">(i,j)</code></h2><span id='topic+convertNodePair'></span>

<h3>Description</h3>

<p>Convert node pair <code class="reqn">(i,j)</code> into an index
</p>

<dl>
<dt><strong>Directed case :</strong></dt><dd>

<ul>
<li><p> The node pair <code class="reqn">(i,j)</code> with <code class="reqn">(i\neq j)</code> is converted into the index <code class="reqn">(i-1)*(n-1)+j-(i&lt;j)</code>
</p>
</li></ul>

</dd>
<dt><strong>Undirected case :</strong></dt><dd>

<ul>
<li><p> The node pair <code class="reqn">(i,j)</code> with <code class="reqn">(i\neq j)</code> is converted into the index <code class="reqn">(2*n-i)*(i-1)/2 +j-i</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>convertNodePair(i, j, n, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertNodePair_+3A_i">i</code></td>
<td>
<p>Node <code class="reqn">i</code> : <code class="reqn">i\in {1, \ldots, n} </code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_j">j</code></td>
<td>
<p>Node <code class="reqn">j</code> : <code class="reqn">j\in {1, \ldots, n} </code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_n">n</code></td>
<td>
<p>Total number of nodes : <code class="reqn">i,j\in {1, \ldots, n} </code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of possible node pairs is
</p>

<ul>
<li> <p><code class="reqn">N = n*(n-1)</code> for the directed case
</p>
</li>
<li> <p><code class="reqn">N = n*(n-1)/2</code>  for the undirected case
</p>
</li></ul>

<p>which corresponds to the cardinality of data$type.seq
</p>


<h3>Value</h3>

<p>Index corresponding to the node pair
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the node pair (3,7) into an index, where the total number of nodes is 10,
# for directed and undirected graph

i &lt;- 3
j &lt;- 7
n &lt;- 10

directedIndex &lt;- convertNodePair(i,j,n,TRUE)
undirectedIndex &lt;- convertNodePair(i,j,n,FALSE)

</code></pre>

<hr>
<h2 id='correctTau'>Handling of values of <code class="reqn">\tau</code></h2><span id='topic+correctTau'></span>

<h3>Description</h3>

<p>Avoid values of <code class="reqn">\tau</code> to be exactly 0 and exactly 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctTau(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctTau_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
</table>

<hr>
<h2 id='find_ql'>Convert index into group pair</h2><span id='topic+find_ql'></span>

<h3>Description</h3>

<p>This function is the inverse of the conversion <code class="reqn">{(q,l), q,l} </code> into <code class="reqn">{1,...,Q^2}</code> for the directed case <code class="reqn">{(q,l), q&lt;= l}</code> into <code class="reqn">{1,...,Q*(Q+1)/2}</code> for the undirected case.
It takes the integer index corresponding to <code class="reqn">(q,l)</code> and returns <code class="reqn">(q,l)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ql(ind_ql, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ql_+3A_ind_ql">ind_ql</code></td>
<td>
<p>Converted <code class="reqn">(q,l)</code> index</p>
</td></tr>
<tr><td><code id="find_ql_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="find_ql_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Group pair <code class="reqn">(q,l)</code> corresponding to the given index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the index 5 into a group pair for undirected graph
# and the index 8 into a group pair for directed graph
# where the total number of group is 3

ind_ql_dir &lt;- 8
ind_ql_undir &lt;- 5

Q &lt;- 3

directedIndex &lt;- find_ql(ind_ql_dir,Q)
undirectedIndex &lt;- find_ql(ind_ql_undir,Q, FALSE)

</code></pre>

<hr>
<h2 id='find_ql_diff'>Convert index into group pair in tauDown_Q</h2><span id='topic+find_ql_diff'></span>

<h3>Description</h3>

<p>This function is the inverse of the conversion <code class="reqn">{(q,l), q&lt;l}</code> into <code class="reqn">{1,...,Q*(Q-1)/2}</code>. Used only in tauDown_Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ql_diff(ind_ql, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ql_diff_+3A_ind_ql">ind_ql</code></td>
<td>
<p>Converted <code class="reqn">(q,l)</code> index</p>
</td></tr>
<tr><td><code id="find_ql_diff_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Group pair <code class="reqn">(q,l)</code> corresponding to the given index
</p>

<hr>
<h2 id='generated_Q3'>Generated graph with 50 individuals and 3 clusters</h2><span id='topic+generated_Q3'></span>

<h3>Description</h3>

<p>Generated graph with 50 individuals and 3 clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_Q3
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<dl>
<dt>data</dt><dd><p>List of 3</p>
</dd>
<dt>z</dt><dd><p>Latent variables</p>
</dd>
<dt>intens</dt><dd><p>Intensities</p>
</dd>
</dl>

<hr>
<h2 id='generated_Q3_n20'>Generated graph with 20 individuals and 3 clusters</h2><span id='topic+generated_Q3_n20'></span>

<h3>Description</h3>

<p>Generated graph with 20 individuals and 3 clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_Q3_n20
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<dl>
<dt>data</dt><dd><p>List of 3</p>
</dd>
<dt>z</dt><dd><p>Latent variables</p>
</dd>
<dt>intens</dt><dd><p>Intensities</p>
</dd>
</dl>

<hr>
<h2 id='generated_sol_hist'>Generated solution with histogram method</h2><span id='topic+generated_sol_hist'></span>

<h3>Description</h3>

<p>Generated solution with histogram method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_sol_hist
</code></pre>


<h3>Format</h3>

<p>List of 5 iterations of the algorithm, each one containing
</p>

<dl>
<dt>List of 8</dt><dd><p>tau, rho, beta, logintensities.ql, best.d, J, run, converged</p>
</dd>
</dl>

<hr>
<h2 id='generated_sol_kernel'>Generated solution with kernel method</h2><span id='topic+generated_sol_kernel'></span>

<h3>Description</h3>

<p>Generated solution with kernel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_sol_kernel
</code></pre>


<h3>Format</h3>

<p>Solution containing
</p>

<dl>
<dt>List of 8</dt><dd><p>tau, logintensities.ql.ij, J, run, converged</p>
</dd>
</dl>

<hr>
<h2 id='generateDynppsbm'>Data under dynppsbm</h2><span id='topic+generateDynppsbm'></span>

<h3>Description</h3>

<p>Generate data under dynppsbm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateDynppsbm(intens, Time, n, prop.groups, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateDynppsbm_+3A_intens">intens</code></td>
<td>
<p>List containing intensity functions <code class="reqn">\alpha^{(q,l)}</code> and upper bounds of intensities</p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_time">Time</code></td>
<td>
<p>Final time</p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_prop.groups">prop.groups</code></td>
<td>
<p>Vector of group proportions (probability to belong to a group), should be of length <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case. If directed=TRUE then intens should be of length <code class="reqn">Q^2</code> and if directed =FALSE then length <code class="reqn">Q*(Q+1)/2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated data, latent group variables and intensities <code class="reqn">\alpha^{(q,l)}</code>
</p>


<h3>References</h3>

<p>ANDERSEN, P. K., BORGAN, Ø., GILL, R. D. &amp; KEIDING, N. (1993). Statistical models based on counting processes. Springer Series in Statistics. Springer-Verlag, New York.
</p>
<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>
<p>MATIAS, C. &amp; ROBIN, S. (2014). Modeling heterogeneity in random graphs through latent space models: a selective review. Esaim Proc. &amp; Surveys 47, 55–74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from an undirected graph with n=10 individuals and Q=2 clusters

# equal cluster proportions
prop.groups &lt;- c(0.5,0.5)

# 3 different intensity functions :
intens &lt;- list(NULL)
intens[[1]] &lt;- list(intens= function(x) 100*x*exp(-8*x),max=5)
    # (q,l) = (1,1)
intens[[2]] &lt;- list(intens= function(x) exp(3*x)*(sin(6*pi*x-pi/2)+1)/2,max=13)
    # (q,l) = (1,2)
intens[[3]] &lt;- list(intens= function(x) 8.1*(exp(-6*abs(x-1/2))-.049),max=8)
    # (q,l) = (2,2)

# generate data :
obs &lt;- generateDynppsbm(intens,Time=1,n=10,prop.groups,directed=FALSE)

# latent variables (true clustering of the individuals)
obs$z

# number of time events :
length(obs$data$time.seq)

# number of interactions between each pair of individuals:
table(obs$data$type.seq)

</code></pre>

<hr>
<h2 id='generateDynppsbmConst'>Data under dynppsbm with piecewise constant intensities</h2><span id='topic+generateDynppsbmConst'></span>

<h3>Description</h3>

<p>Generate data under dynppsbm with piecewise constant intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateDynppsbmConst(intens, Time, n, prop.groups, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateDynppsbmConst_+3A_intens">intens</code></td>
<td>
<p>Matrix with piecewise constant intensities <code class="reqn">\alpha^{(q,l)}</code> (each row gives the constants of the piecewise constant intensity for a group pair <code class="reqn">(q,l)</code>)</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_time">Time</code></td>
<td>
<p>Time</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_prop.groups">prop.groups</code></td>
<td>
<p>Vector of group proportions, should be of length <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case
</p>
<p>If directed then intens should be of length <code class="reqn">Q^2</code> and if undirected then length <code class="reqn">Q*(Q+1)/2</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>intens1 &lt;- c(1,3,8)
intens2 &lt;- c(2,3,6)

intens &lt;- matrix(c(intens1,intens2,intens1,intens2),4,3)

Time &lt;- 10
n &lt;- 20
prop.groups &lt;- c(0.2,0.3)
dynppsbm &lt;- generateDynppsbmConst(intens,Time,n,prop.groups,directed=TRUE)

</code></pre>

<hr>
<h2 id='generatePP'>Poisson process</h2><span id='topic+generatePP'></span>

<h3>Description</h3>

<p>Generate realizations of an inhomogeneous Poisson process with an intensity function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePP(intens, Time, max.intens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePP_+3A_intens">intens</code></td>
<td>
<p>Intensity function defined on [0,Time] (needs to be positive)</p>
</td></tr>
<tr><td><code id="generatePP_+3A_time">Time</code></td>
<td>
<p>Final time</p>
</td></tr>
<tr><td><code id="generatePP_+3A_max.intens">max.intens</code></td>
<td>
<p>Upper bound of intensity on [0,Time]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of realizations of the PP
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a Poisson Process with intensity function
# intens= function(x) 100*x*exp(-8*x)
# and max.intens = 5

intens &lt;- function(x) 100*x*exp(-8*x)

poissonProcess &lt;- generatePP(intens, Time=30, max.intens=1)

</code></pre>

<hr>
<h2 id='generatePPConst'>Poisson process  with piecewise constant intensities</h2><span id='topic+generatePPConst'></span>

<h3>Description</h3>

<p>Generate realizations of a Poisson process with piecewise constant intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePPConst(intens, Time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePPConst_+3A_intens">intens</code></td>
<td>
<p>Vector with the constants of the intensities (defined on a regular partition of interval [0,Time])</p>
</td></tr>
<tr><td><code id="generatePPConst_+3A_time">Time</code></td>
<td>
<p>Time</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>intens &lt;- c(1,3,8)
constpp &lt;- generatePPConst(intens, 10)

</code></pre>

<hr>
<h2 id='JEvalMstep'>Evaluation of criterion J</h2><span id='topic+JEvalMstep'></span>

<h3>Description</h3>

<p>Evaluation of the criterion J to verify the convergence of the VEM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JEvalMstep(VE, mstep, data, directed, sparse, method = "hist")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JEvalMstep_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation
</p>

<ul>
<li><p> mstep$sum_rhotau : N_Q vector (not needed in the function)
</p>
</li>
<li><p> mstep$sum_rhotau_obs : N_Q vector
</p>
</li>
<li><p> mstep$logintensities.ql :  N_Q x Dmax matrix
</p>
</li>
<li><p> m.step$beta : N_Q vector
</p>
</li></ul>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
</table>

<hr>
<h2 id='kernelIntensities'>Direct kernel estimator intensities</h2><span id='topic+kernelIntensities'></span>

<h3>Description</h3>

<p>Compute smooth intensities with direct kernel estimation of intensities relying on a classification tau.
This can be used with the values <code class="reqn">\tau</code> obtained on a dataset with mainVEM function run with 'hist' method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelIntensities(data, tau, Q, n, directed, rho = 1, sparse = FALSE,
  nb.points = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelIntensities_+3A_data">data</code></td>
<td>
<p>List with 3 components:
</p>

<ul>
<li><p> data$time.seq : sequence of observed time points of the m-th event (M-vector)
</p>
</li>
<li><p> data$type.seq : sequence of observed values convertNodePair(i,j,n,directed) (auxiliary.R)
of process that produced the mth event (M-vector)
</p>
</li>
<li><p> $Time - [0,data$Time] is the total time interval of observation
</p>
</li></ul>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_rho">rho</code></td>
<td>
<p><code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_nb.points">nb.points</code></td>
<td>
<p>Number of points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning : sparse case not implemented !!!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The generated_sol_kernel was generated calling mainVEM with kernel method on the generated_Q3 data
# (50 individuals and 3 clusters)

data &lt;- generated_Q3$data

n &lt;- 50
Q &lt;- 3


# compute smooth intensity estimators
sol.kernel.intensities &lt;- kernelIntensities(data,generated_sol_kernel$tau,Q,n,directed=FALSE)

</code></pre>

<hr>
<h2 id='listNodePairs'>List node pairs</h2><span id='topic+listNodePairs'></span>

<h3>Description</h3>

<p>Create the list of all node pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listNodePairs(n, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listNodePairs_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="listNodePairs_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with two columns which lists all the possible node pairs. Each row is a node pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all the node pairs with 10 nodes, for directed and undirected graphs

n &lt;- 10
listNodePairs(n, TRUE)
listNodePairs(n, FALSE)

</code></pre>

<hr>
<h2 id='mainVEM'>Adaptative VEM algorithm</h2><span id='topic+mainVEM'></span>

<h3>Description</h3>

<p>Principal adaptative VEM algorithm for histogram with model selection or for kernel method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainVEM(data, n, Qmin, Qmax = Qmin, directed = TRUE, sparse = FALSE,
  method = c("hist", "kernel"), init.tau = NULL, cores = 1, d_part = 5,
  n_perturb = 10, perc_perturb = 0.2, n_random = 0, nb.iter = 50,
  fix.iter = 10, epsilon = 1e-06, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mainVEM_+3A_data">data</code></td>
<td>
<p>Data format depends on the estimation method used!!
</p>

<ol>
<li><p> Data with <strong>hist</strong> method - list with 2 components:
</p>

<dl>
<dt>data$Time</dt><dd><p>[0,data$Time] is the total time interval of observation</p>
</dd>
<dt>data$Nijk</dt><dd><p>Data matrix with counts per process <code class="reqn">N_{ij}</code> and sub-intervals ; matrix of size <code class="reqn">N*Dmax</code>  where <code class="reqn">N = n(n-1)</code> or <code class="reqn">n(n-1)/2</code> is the number of possible node pairs in the graph and <code class="reqn">Dmax = 2^{dmax}</code> is the size of the finest partition in the  histrogram approach
</p>
<p>Counts are pre-computed - Obtained through function 'statistics' (auxiliary.R) on data with second format</p>
</dd>
</dl>

</li>
<li><p> Data with <strong>kernel</strong> method - list with 3 components:
</p>

<dl>
<dt>data$time.seq</dt><dd><p>Sequence of observed time points of the m-th event (M-vector)</p>
</dd>
<dt>data$type.seq</dt><dd><p>Sequence of observed values convertNodePair(i,j,n,directed) (auxiliary.R) of process that produced the mth event (M-vector).</p>
</dd>
<dt>data$Time</dt><dd><p>[0,data$Time] is the total time interval of observation</p>
</dd>
</dl>

</li></ol>
</td></tr>
<tr><td><code id="mainVEM_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_qmin">Qmin</code></td>
<td>
<p>Minimum number of groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_qmax">Qmax</code></td>
<td>
<p>Maximum number of groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_init.tau">init.tau</code></td>
<td>
<p>List of initial values of <code class="reqn">\tau</code> - all tau's are matrices with size <code class="reqn">Q\times n</code> (might be with different values of Q)</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_cores">cores</code></td>
<td>
<p>Number of cores for parallel execution
</p>
<p>If set to 1 it does sequential execution
</p>
<p>Beware: parallelization with fork (multicore) : doesn't work on Windows!</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partition of time interval [0,T] used for k-means initializations.
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_{part} +1)} -1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mainVEM_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result
</p>
<p>When <code class="reqn">Qmin &lt; Qmax</code>, number of perturbations on the result with <code class="reqn">Q-1</code> or <code class="reqn">Q+1</code> groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_n_random">n_random</code></td>
<td>
<p>Number of completely random initial points. The total number of initializations for the VEM is <code class="reqn">npart*(1+n_{perturb}) +n_{random}</code></p>
</td></tr>
<tr><td><code id="mainVEM_+3A_nb.iter">nb.iter</code></td>
<td>
<p>Number of iterations of the VEM algorithm</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point into the VE step</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_filename">filename</code></td>
<td>
<p>Name of the file where to save the results along the computation (increasing steps for <code class="reqn">Q</code>, these are the longest).
</p>
<p>The file will contain a list of 'best' results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sparse version works only for the histogram approach.
</p>


<h3>References</h3>

<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>DEMPSTER, A. P., LAIRD, N. M. &amp; RUBIN, D. B. (1977). Maximum likelihood from incomplete data via the EM algorithm. J. Roy. Statist. Soc. Ser. B 39, 1–38.
</p>
<p>JORDAN, M., GHAHRAMANI, Z., JAAKKOLA, T. &amp; SAUL, L. (1999). An introduction to variational methods for graphical models. Mach. Learn. 37, 183–233.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>
<p>MATIAS, C. &amp; ROBIN, S. (2014). Modeling heterogeneity in random graphs through latent space models: a selective review. Esaim Proc. &amp; Surveys 47, 55–74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 20
Q &lt;- 3

Time &lt;- generated_Q3_n20$data$Time
data &lt;- generated_Q3_n20$data
z &lt;- generated_Q3_n20$z

step &lt;- .001
x0 &lt;- seq(0,Time,by=step)
intens &lt;-  generated_Q3_n20$intens

# VEM-algo kernel
sol.kernel &lt;- mainVEM(data,n,Q,directed=FALSE,method='kernel', d_part=0,
    n_perturb=0)[[1]]
# compute smooth intensity estimators
sol.kernel.intensities &lt;- kernelIntensities(data,sol.kernel$tau,Q,n,directed=FALSE)
# eliminate label switching
intensities.kernel &lt;- sortIntensities(sol.kernel.intensities,z,sol.kernel$tau,
    directed=FALSE)

# VEM-algo hist
# compute data matrix with precision d_max=3
Dmax &lt;- 2^3
Nijk &lt;- statistics(data,n,Dmax,directed=FALSE)
sol.hist &lt;- mainVEM(list(Nijk=Nijk,Time=Time),n,Q,directed=FALSE, method='hist',
    d_part=0,n_perturb=0,n_random=0)[[1]]
log.intensities.hist &lt;- sortIntensities(sol.hist$logintensities.ql,z,sol.hist$tau,
     directed=FALSE)

# plot estimators
par(mfrow=c(2,3))
ind.ql &lt;- 0
for (q in 1:Q){
  for (l in q:Q){
    ind.ql &lt;- ind.ql + 1
    true.val &lt;- intens[[ind.ql]]$intens(x0)
    values &lt;- c(intensities.kernel[ind.ql,],exp(log.intensities.hist[ind.ql,]),true.val)
    plot(x0,true.val,type='l',xlab=paste0("(q,l)=(",q,",",l,")"),ylab='',
        ylim=c(0,max(values)+.1))
    lines(seq(0,1,by=1/Dmax),c(exp(log.intensities.hist[ind.ql,]),
        exp(log.intensities.hist[ind.ql,Dmax])),type='s',col=2,lty=2)
    lines(seq(0,1,by=.001),intensities.kernel[ind.ql,],col=4,lty=3)
  }
}

</code></pre>

<hr>
<h2 id='mainVEMPar'>VEM step for parallel version</h2><span id='topic+mainVEMPar'></span>

<h3>Description</h3>

<p>VEM step for parallel version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainVEMPar(init.point, n, Q, data, directed, sparse, method, nb.iter, fix.iter,
  epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mainVEMPar_+3A_init.point">init.point</code></td>
<td>
<p>Initial point</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_nb.iter">nb.iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
</table>

<hr>
<h2 id='modelSelec_QPlot'>Plots for model selection</h2><span id='topic+modelSelec_QPlot'></span>

<h3>Description</h3>

<p>Plots for model selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSelec_QPlot(model.selec_Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelSelec_QPlot_+3A_model.selec_q">model.selec_Q</code></td>
<td>
<p>Output from modelSelection_Q()</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 50

# compute data matrix with precision d_max=3
Dmax &lt;- 2^3
data &lt;- list(Nijk=statistics(generated_Q3$data,n,Dmax,directed=FALSE),
    Time=generated_Q3$data$Time)

# ICL-model selection
sol.selec_Q &lt;- modelSelection_Q(data,n,Qmin=1,Qmax=4,directed=FALSE,
    sparse=FALSE,generated_sol_hist)

# plot ICL
modelSelec_QPlot(sol.selec_Q)

</code></pre>

<hr>
<h2 id='modelSelection_Q'>Selects the number of groups with ICL</h2><span id='topic+modelSelection_Q'></span>

<h3>Description</h3>

<p>Selects the number of groups with Integrated Classification Likelihood Criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSelection_Q(data, n, Qmin = 1, Qmax, directed = TRUE, sparse = FALSE,
  sol.hist.sauv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelSelection_Q_+3A_data">data</code></td>
<td>
<p>List with 2 components:
</p>

<ul>
<li><p> $Time - [0,data$Time] is the total time interval of observation
</p>
</li>
<li><p> $Nijk - data matrix with the statistics per process <code class="reqn">N_{ij}</code> and sub-intervals <code class="reqn">k</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_n">n</code></td>
<td>
<p>Total number of nodes <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_qmin">Qmin</code></td>
<td>
<p>Minimum number of groups</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_qmax">Qmax</code></td>
<td>
<p>Maximum number of groups</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_sol.hist.sauv">sol.hist.sauv</code></td>
<td>
<p>List of size Qmax-Qmin+1 obtained from running mainVEM(data,n,Qmin,Qmax,method='hist')</p>
</td></tr>
</table>


<h3>References</h3>

<p>BIERNACKI, C., CELEUX, G. &amp; GOVAERT, G. (2000). Assessing a mixture model for clustering with the integrated completed likelihood. IEEE Trans. Pattern Anal. Machine Intel. 22, 719–725.
</p>
<p>CORNELI, M., LATOUCHE, P. &amp; ROSSI, F. (2016). Exact ICL maximization in a non-stationary temporal extension of the stochastic block model for dynamic networks. Neurocomputing 192, 81 – 91.
</p>
<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 50

# compute data matrix with precision d_max=3
Dmax &lt;- 2^3
data &lt;- list(Nijk=statistics(generated_Q3$data,n,Dmax,directed=FALSE),
    Time=generated_Q3$data$Time)

# ICL-model selection
sol.selec_Q &lt;- modelSelection_Q(data,n,Qmin=1,Qmax=4,directed=FALSE,
    sparse=FALSE,generated_sol_hist)

# best number Q of clusters:
sol.selec_Q$Qbest

</code></pre>

<hr>
<h2 id='Mstep_hist'>M step for histograms</h2><span id='topic+Mstep_hist'></span>

<h3>Description</h3>

<p>M step for histograms estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_hist(data, VE, directed, sparse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep_hist_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
</table>


<h3>References</h3>

<p>BARAUD, Y. &amp; BIRGÉ, L. (2009). Estimating the intensity of a random measure by histogram type estimators. Probab. Theory Related Fields 143, 239–284.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>
<p>REYNAUD -BOURET, P. (2006). Penalized projection estimators of the Aalen multiplicative intensity. Bernoulli 12, 633–661.
</p>

<hr>
<h2 id='Mstep_kernel'>M step for kernel</h2><span id='topic+Mstep_kernel'></span>

<h3>Description</h3>

<p>M step for kernel estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_kernel(data, VE, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep_kernel_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="Mstep_kernel_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="Mstep_kernel_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>References</h3>

<p>GRÉGOIRE , G. (1993). Least squares cross-validation for counting process intensities. Scand. J. Statist. 20, pp. 343–360.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>
<p>RAMLAU-HANSEN, H. (1983). Smoothing counting process intensities by means of kernel functions. Ann. Statist. 11, pp. 453–466.
</p>

<hr>
<h2 id='permuteZEst'>Optimal matching between 2 clusterings</h2><span id='topic+permuteZEst'></span>

<h3>Description</h3>

<p>Compute the permutation of the rows of hat.z that has to be applied to obtain the &quot;same order&quot; as z.
Compute optimal matching between 2 clusterings using Hungarian algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteZEst(z, hat.z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteZEst_+3A_z">z</code></td>
<td>
<p>Matrice of size  <code class="reqn">Q \times n</code></p>
</td></tr>
<tr><td><code id="permuteZEst_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrice of size  <code class="reqn">Q \times n</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>HUBERT, L. &amp; ARABIE, P. (1985). Comparing partitions. J. Classif. 2, 193–218.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- matrix(c(1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)
hat.z &lt;- matrix(c(0,0,1,1,0,0, 1,1,0,0,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)

perm &lt;- permuteZEst(z,hat.z)

</code></pre>

<hr>
<h2 id='sortIntensities'>Sort intensities</h2><span id='topic+sortIntensities'></span>

<h3>Description</h3>

<p>Sort intensities associated with hat.z &quot;in the same way&quot; as the original intensities associated with z by permutation of rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortIntensities(intensities, z, hat.z, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortIntensities_+3A_intensities">intensities</code></td>
<td>
<p>Intensities <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_z">z</code></td>
<td>
<p>Matrice of size  <code class="reqn">Q \times n</code></p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrice of size  <code class="reqn">Q \times n</code></p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>References</h3>

<p>HUBERT, L. &amp; ARABIE, P. (1985). Comparing partitions. J. Classif. 2, 193–218.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- matrix(c(1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)
hat.z &lt;- matrix(c(0,0,1,1,0,0, 1,1,0,0,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)

intens &lt;- matrix(c(1,1,1,2,2,2,3,3,3),9)

sortIntensities(intens,z,hat.z, TRUE)

</code></pre>

<hr>
<h2 id='statistics'>Compute statistics</h2><span id='topic+statistics'></span>

<h3>Description</h3>

<p>Convert the initial data into the statistics matrix <code class="reqn">N_{ijk}</code>, by counting the number of events for the nodes during the subintervals of a particular partition of the time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistics(data, n, K, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistics_+3A_data">data</code></td>
<td>
<p>List with $type.seq, $time.seq</p>
</td></tr>
<tr><td><code id="statistics_+3A_n">n</code></td>
<td>
<p>Total number of nodes : <code class="reqn">i,j\in {1, \ldots, n} </code></p>
</td></tr>
<tr><td><code id="statistics_+3A_k">K</code></td>
<td>
<p>Size of the regular partition, i.e. number of subintervals</p>
</td></tr>
<tr><td><code id="statistics_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N(i,j)k = number of events for the node (i,j) during the k-th subinterval
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the generated data into the statistics matrix N_ijk with 8 columns

n &lt;- 50
Dmax &lt;- 2^3

obs &lt;- statistics(generated_Q3$data,n,Dmax,directed=FALSE)

</code></pre>

<hr>
<h2 id='tauDown_Q'>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q+1</code></h2><span id='topic+tauDown_Q'></span>

<h3>Description</h3>

<p>Construct initial <code class="reqn">\tau</code> with <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q+1</code> groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauDown_Q(tau, n_perturb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauDown_Q_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauDown_Q_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code> for <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q+1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate first initial tau for generated_Q3 data

n &lt;- 50
Dmax &lt;- 2^3
Q &lt;- 3
d_part &lt;- 1 # less than 3 (owing to Dmax)
n_perturb &lt;- 2
perc_perturb &lt;- 0.2
n_random &lt;- 1
directed &lt;- FALSE

data &lt;- list(Nijk = statistics(generated_Q3$data, n, Dmax, directed = FALSE))

tau &lt;- tauInitial(data,n,Q,d_part,n_perturb,perc_perturb,n_random,directed)

tau.list &lt;- tauDown_Q(tau[[1]],1)

</code></pre>

<hr>
<h2 id='tauInitial'>List of initial values for <code class="reqn">\tau</code></h2><span id='topic+tauInitial'></span>

<h3>Description</h3>

<p>Same function whatever directed or undirected case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauInitial(data, n, Q, d_part, n_perturb, perc_perturb, n_random, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauInitial_+3A_data">data</code></td>
<td>
<p>Data : only needs the <code class="reqn">N_{ijk}</code> field of data</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partitions of time interval [0,T], used for kmeans initializations.
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_part +1)} - 1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="tauInitial_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_n_random">n_random</code></td>
<td>
<p>Number of completely random initial points. If not zero there will be n_random taus uniformly sampled in the initialization.</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (maximal) total number of initializations is <code class="reqn">d_{part}*(1+n_{perturb}) + n_{random}</code>
</p>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate initial tau for generated_Q3 data

n &lt;- 50
Dmax &lt;- 2^3
Q &lt;- 3
d_part &lt;- 1 # less than 3 (owing to Dmax)
n_perturb &lt;- 2
perc_perturb &lt;- 0.2
n_random &lt;- 1
directed &lt;- FALSE

data &lt;- list(Nijk = statistics(generated_Q3$data, n, Dmax, directed = FALSE))

tau &lt;- tauInitial(data,n,Q,d_part,n_perturb,perc_perturb,n_random,directed)

</code></pre>

<hr>
<h2 id='tauKmeansSbm'>k-means for SBM</h2><span id='topic+tauKmeansSbm'></span>

<h3>Description</h3>

<p>k-means for SBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauKmeansSbm(statistics, n, Q, directed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauKmeansSbm_+3A_statistics">statistics</code></td>
<td>
<p>Statistics matrix <code class="reqn">N_{ijk}</code>, counting the events for the nodes pair <code class="reqn">(i,j)</code> during the subinterval <code class="reqn">k</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_n">n</code></td>
<td>
<p>Total number of nodes <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial values for <code class="reqn">\tau</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 50
Q &lt;- 3

Dmax &lt;- 2^3

Nijk &lt;- statistics(generated_Q3$data,n,Dmax,directed=FALSE)

tau &lt;- tauKmeansSbm(Nijk,n,Q,FALSE)

</code></pre>

<hr>
<h2 id='taurhoInitial'>Sparse setup - <code class="reqn">\rho</code> parameter</h2><span id='topic+taurhoInitial'></span>

<h3>Description</h3>

<p>Sparse setup - <code class="reqn">\rho</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taurhoInitial(tau, data, n, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taurhoInitial_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_data">data</code></td>
<td>
<p>Data : only needs the <code class="reqn">N_{ijk}</code> field of data</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both <code class="reqn">\tau</code> and <code class="reqn">\rho</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate first initial tau for generated_Q3 data

n &lt;- 50
Dmax &lt;- 2^3
Q &lt;- 3
d_part &lt;- 1 # less than 3 (owing to Dmax)
n_perturb &lt;- 2
perc_perturb &lt;- 0.2
n_random &lt;- 1
directed &lt;- FALSE

data &lt;- list(Nijk = statistics(generated_Q3$data, n, Dmax, directed = FALSE))

tau &lt;- tauInitial(data,n,Q,d_part,n_perturb,perc_perturb,n_random,directed)

taurho &lt;- taurhoInitial(tau[[1]],data,n,Q,directed=FALSE)

</code></pre>

<hr>
<h2 id='tauUp_Q'>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q-1</code></h2><span id='topic+tauUp_Q'></span>

<h3>Description</h3>

<p>Construct initial <code class="reqn">\tau</code> with <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q-1</code> groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauUp_Q(tau, n_perturb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauUp_Q_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauUp_Q_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code> for <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q-1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate first initial tau for generated_Q3 data

n &lt;- 50
Dmax &lt;- 2^3
Q &lt;- 3
d_part &lt;- 1 # less than 3 (owing to Dmax)
n_perturb &lt;- 2
perc_perturb &lt;- 0.2
n_random &lt;- 1
directed &lt;- FALSE

data &lt;- list(Nijk = statistics(generated_Q3$data, n, Dmax, directed = FALSE))

tau &lt;- tauInitial(data,n,Q,d_part,n_perturb,perc_perturb,n_random,directed)

tau.list &lt;- tauUp_Q(tau[[1]],1)

</code></pre>

<hr>
<h2 id='tauUpdate'>Update <code class="reqn">\tau</code></h2><span id='topic+tauUpdate'></span>

<h3>Description</h3>

<p>One update of <code class="reqn">\tau</code> by the fixed point equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauUpdate(tau, pi, mstep, data, directed, sparse, method, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauUpdate_+3A_tau">tau</code></td>
<td>
<p>Old <code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_pi">pi</code></td>
<td>
<p>Estimator of group probabilities <code class="reqn">\pi</code></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_rho">rho</code></td>
<td>
<p>Old <code class="reqn">\rho</code> (only for sparse model, set to 0 otherwise)</p>
</td></tr>
</table>

<hr>
<h2 id='VEstep'>VE step</h2><span id='topic+VEstep'></span>

<h3>Description</h3>

<p>VE step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VEstep(VE, mstep, directed, sparse, method, epsilon, fix.iter, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VEstep_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE step for iterative computation</p>
</td></tr>
<tr><td><code id="VEstep_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation</p>
</td></tr>
<tr><td><code id="VEstep_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="VEstep_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="VEstep_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="VEstep_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
<tr><td><code id="VEstep_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point</p>
</td></tr>
<tr><td><code id="VEstep_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
