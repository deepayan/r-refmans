<!DOCTYPE html><html lang="en"><head><title>Help for package ppsbm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ppsbm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARI'><p>Adjusted Rand Index (ARI)</p></a></li>
<li><a href='#bootstrap_and_CI'><p>Bootstrap and Confidence Bands</p></a></li>
<li><a href='#classInd'><p>Function for k-means</p></a></li>
<li><a href='#confidenceInterval'><p>Confidence Interval</p></a></li>
<li><a href='#convertGroupPair'><p>Convert group pair <code class="reqn">(q,l)</code></p></a></li>
<li><a href='#convertNodePair'><p>Convert node pair <code class="reqn">(i,j)</code></p></a></li>
<li><a href='#correctTau'><p>Handling of values of <code class="reqn">\tau</code></p></a></li>
<li><a href='#find_ql'><p>Convert index into group pair</p></a></li>
<li><a href='#find_ql_diff'><p>Convert index into group pair in tauDown_Q</p></a></li>
<li><a href='#generated_Q3'><p>Example dataset</p></a></li>
<li><a href='#generated_Q3_n20'><p>Example dataset</p></a></li>
<li><a href='#generated_sol_hist'><p>Output example of mainVEM</p></a></li>
<li><a href='#generated_sol_kernel'><p>Output example of mainVEM</p></a></li>
<li><a href='#generateDynppsbm'><p>Dynppsbm data generator</p></a></li>
<li><a href='#generateDynppsbmConst'><p>Data under dynppsbm with piecewise constant intensities</p></a></li>
<li><a href='#generatePP'><p>Poisson process generator</p></a></li>
<li><a href='#generatePPConst'><p>Poisson process with piecewise constant intensity</p></a></li>
<li><a href='#JEvalMstep'><p>Evaluation of criterion J</p></a></li>
<li><a href='#kernelIntensities'><p>Direct kernel estimator intensities</p></a></li>
<li><a href='#listNodePairs'><p>List node pairs</p></a></li>
<li><a href='#mainVEM'><p>Adaptive VEM algorithm</p></a></li>
<li><a href='#mainVEMPar'><p>VEM step for parallel version</p></a></li>
<li><a href='#modelSelec_QPlot'><p>Plots for model selection</p></a></li>
<li><a href='#modelSelection_Q'><p>Selects the number of groups with ICL criterion</p></a></li>
<li><a href='#Mstep_hist'><p>M step for histograms</p></a></li>
<li><a href='#Mstep_kernel'><p>M step for kernel</p></a></li>
<li><a href='#permuteZEst'><p>Optimal matching between 2 clusterings</p></a></li>
<li><a href='#sortIntensities'><p>Sort intensities</p></a></li>
<li><a href='#statistics'><p>Compute statistics</p></a></li>
<li><a href='#tauDown_Q'><p>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q+1</code></p></a></li>
<li><a href='#tauInitial'><p>List of initial values for <code class="reqn">\tau</code></p></a></li>
<li><a href='#tauKmeansSbm'><p>k-means for SBM</p></a></li>
<li><a href='#taurhoInitial'><p>Sparse setup - <code class="reqn">\rho</code> parameter</p></a></li>
<li><a href='#tauUp_Q'><p>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q-1</code></p></a></li>
<li><a href='#tauUpdate'><p>Update <code class="reqn">\tau</code></p></a></li>
<li><a href='#VEstep'><p>VE step</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering in Longitudinal Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daphné Giorgi &lt;daphne.giorgi@sorbonne-universite.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Stochastic block model used for dynamic graphs represented by Poisson processes.
    To model recurrent interaction events in continuous time, an extension of the stochastic block model is proposed where every individual belongs to a latent group and interactions between two individuals follow a conditional inhomogeneous Poisson process with intensity driven by the individuals’ latent groups. The model is shown to be identifiable and its estimation is based on a semiparametric variational expectation-maximization algorithm. Two versions of the method are developed, using either a nonparametric histogram approach (with an adaptive choice of the partition size) or kernel intensity estimators. The number of latent groups can be selected by an integrated classification likelihood criterion.
    Y. Baraud and L. Birgé (2009). &lt;<a href="https://doi.org/10.1007%2Fs00440-007-0126-6">doi:10.1007/s00440-007-0126-6</a>&gt;.
    C. Biernacki, G. Celeux and G. Govaert (2000). &lt;<a href="https://doi.org/10.1109%2F34.865189">doi:10.1109/34.865189</a>&gt;.
    M. Corneli, P. Latouche and F. Rossi (2016). &lt;<a href="https://doi.org/10.1016%2Fj.neucom.2016.02.031">doi:10.1016/j.neucom.2016.02.031</a>&gt;.
    J.-J. Daudin, F. Picard and S. Robin (2008). &lt;<a href="https://doi.org/10.1007%2Fs11222-007-9046-7">doi:10.1007/s11222-007-9046-7</a>&gt;.
    A. P. Dempster, N. M. Laird and D. B. Rubin (1977). <a href="http://www.jstor.org/stable/2984875">http://www.jstor.org/stable/2984875</a>.
    G. Grégoire (1993). <a href="http://www.jstor.org/stable/4616289">http://www.jstor.org/stable/4616289</a>.
    L. Hubert and P. Arabie (1985). &lt;<a href="https://doi.org/10.1007%2FBF01908075">doi:10.1007/BF01908075</a>&gt;.
    M. Jordan, Z. Ghahramani, T. Jaakkola and L. Saul (1999). &lt;<a href="https://doi.org/10.1023%2FA%3A1007665907178">doi:10.1023/A:1007665907178</a>&gt;.
    C. Matias, T. Rebafka and F. Villers (2018). &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasy016">doi:10.1093/biomet/asy016</a>&gt;.
    C. Matias and S. Robin (2014). &lt;<a href="https://doi.org/10.1051%2Fproc%2F201447004">doi:10.1051/proc/201447004</a>&gt;.
    H. Ramlau-Hansen (1983). &lt;<a href="https://doi.org/10.1214%2Faos%2F1176346152">doi:10.1214/aos/1176346152</a>&gt;.
    P. Reynaud-Bouret (2006). &lt;<a href="https://doi.org/10.3150%2Fbj%2F1155735930">doi:10.3150/bj/1155735930</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rfast, clue, gtools, parallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org">https://cran.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-15 21:14:12 UTC; giorgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Daphné Giorgi [aut, cre],
  Catherine Matias [aut],
  Tabea Rebafka [aut],
  Fanny Villers [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-15 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARI'>Adjusted Rand Index (ARI)</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Compute the Adjusted Rand Index (ARI) between the true latent variables and the estimated latent variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(z, hat.z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARI_+3A_z">z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code> with entries = 0 or 1: 'true' latent variables</p>
</td></tr>
<tr><td><code id="ARI_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrix of <code class="reqn">Q \times n</code>  with 0&lt;entries&lt;1: estimated latent variables</p>
</td></tr>
</table>


<h3>References</h3>

<p>HUBERT, L. &amp; ARABIE, P. (1985). Comparing partitions. J. Classif. 2, 193–218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- matrix(c(1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)
hat.z &lt;- matrix(c(0,0,1,1,0,0, 1,1,0,0,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)

ARI(z, hat.z)

</code></pre>

<hr>
<h2 id='bootstrap_and_CI'>Bootstrap and Confidence Bands</h2><span id='topic+bootstrap_and_CI'></span>

<h3>Description</h3>

<p>Plots confidence bands for estimated intensities between pairs of groups obtained by bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_and_CI(
  sol,
  Time,
  R,
  alpha = 0.05,
  nbcores = 1,
  d_part = 5,
  n_perturb = 10,
  perc_perturb = 0.2,
  directed,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_and_CI_+3A_sol">sol</code></td>
<td>
<p>One list (for one value of <code class="reqn">Q</code>) output by <a href="#topic+mainVEM">mainVEM</a> with <code>hist</code> method.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_time">Time</code></td>
<td>
<p>Positive real number. [0,Time] is the total time interval of observation.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_r">R</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_alpha">alpha</code></td>
<td>
<p>Level of confidence: <code class="reqn">1- \alpha</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_nbcores">nbcores</code></td>
<td>
<p>Number of cores for parallel execution.
</p>
<p>If set to 1 it does sequential execution.
</p>
<p>Beware: parallelization with fork (multicore): doesn't work on Windows!</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partitions of time interval [0,T], used for kmeans initializations on the bootstrap samples
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_{part} +1)} - 1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result on the bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)  on the bootstrap samples.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.</p>
</td></tr>
<tr><td><code id="bootstrap_and_CI_+3A_filename">filename</code></td>
<td>
<p>Name of the file where to save the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not for sparse models and only for histogram method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data of a synthetic graph with 50 individuals and 3 clusters

n &lt;- 50
Q &lt;- 3

Time &lt;- generated_Q3$data$Time
data &lt;- generated_Q3$data
z &lt;- generated_Q3$z

K &lt;- 2^3

# VEM-algo hist:
sol.hist &lt;- mainVEM(list(Nijk=statistics(data,n,K,directed=FALSE),Time=Time),
n,Qmin=3,directed=FALSE,method='hist',d_part=1,n_perturb=0)[[1]]

# compute bootstrap confidence bands
boot &lt;- bootstrap_and_CI(sol.hist,Time,R=10,alpha=0.1,nbcores=1,d_part=1,n_perturb=0,
     directed=FALSE)

# plot confidence bands
alpha.hat &lt;- exp(sol.hist$logintensities.ql)
vec.x &lt;- (0:K)*Time/K
ind.ql &lt;- 0
par(mfrow=c(2,3))
for (q in 1:Q){
  for (l in q:Q){
    ind.ql &lt;- ind.ql+1
    ymax &lt;- max(c(boot$CI.limits[ind.ql,2,],alpha.hat[ind.ql,]))
    plot(vec.x,c(alpha.hat[ind.ql,],alpha.hat[ind.ql,K]),type='s',col='black',
        ylab='Intensity',xaxt='n',xlab= paste('(',q,',',l,')',sep=""),
        cex.axis=1.5,cex.lab=1.5,ylim=c(0,ymax),main='Confidence bands')
    lines(vec.x,c(boot$CI.limits[ind.ql,1,],boot$CI.limits[ind.ql,1,K]),col='blue',
        type='s',lty=3)
    lines(vec.x,c(boot$CI.limits[ind.ql,2,],boot$CI.limits[ind.ql,2,K]),col='blue',
        type='s',lty=3)
  }
}

</code></pre>

<hr>
<h2 id='classInd'>Function for k-means</h2><span id='topic+classInd'></span>

<h3>Description</h3>

<p>Function for k-means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classInd(cl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classInd_+3A_cl">cl</code></td>
<td>
<p>Label list of nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x    : class indicator matrix
</p>

<hr>
<h2 id='confidenceInterval'>Confidence Interval</h2><span id='topic+confidenceInterval'></span>

<h3>Description</h3>

<p>Compute confidence bands for all pair of groups <code class="reqn">(q,l)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidenceInterval(boot.sol, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confidenceInterval_+3A_boot.sol">boot.sol</code></td>
<td>
<p>Bootstrap list of estimators</p>
</td></tr>
<tr><td><code id="confidenceInterval_+3A_alpha">alpha</code></td>
<td>
<p>Level of confidence : 1 - <code class="reqn">\alpha</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with 3 dimensions and size <code class="reqn">Q(Q+1)/2\times 3\times K</code> (if undirected) or <code class="reqn">Q^2\times 3\times K</code> (when undirected)
containing for each pair of groups <code class="reqn">(q,l)</code> (first dimension) and each <code class="reqn">k</code>-th subinterval (third dimension) the 3 quantiles at levels <code class="reqn">(\alpha/2,1-\alpha/2,.5)</code> (second dimension).
</p>

<hr>
<h2 id='convertGroupPair'>Convert group pair <code class="reqn">(q,l)</code></h2><span id='topic+convertGroupPair'></span>

<h3>Description</h3>

<p>Gives the index in <code class="reqn">1, \ldots, Q^2</code> (directed) or <code class="reqn">1, \ldots, Q(Q+1)/2</code> (undirected) that corresponds to group pair <code class="reqn">(q,l)</code>. Works also for vectors of indices <code class="reqn">q</code> and <code class="reqn">l</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertGroupPair(q, l, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertGroupPair_+3A_q">q</code></td>
<td>
<p>Group index <code class="reqn">q</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_l">l</code></td>
<td>
<p>Group index <code class="reqn">l</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="convertGroupPair_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Relations between groups <code class="reqn">(q,l)</code> are stored in vectors, whose indexes depend on whether the graph is directed or undirected.
</p>

<dl>
<dt><strong>Directed case :</strong></dt><dd>

<ul>
<li><p> The <code class="reqn">(q,l)</code> group pair is converted into the index <code class="reqn">(q-1)Q+l</code>
</p>
</li></ul>

</dd>
<dt><strong>Undirected case :</strong></dt><dd>

<ul>
<li><p> The <code class="reqn">(q,l)</code> group pair with <code class="reqn">q\leq l</code> is converted into the index <code class="reqn">(2Q-q+2)*(q-1)/2 +l-q+1</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>Index corresponding to the group pair <code class="reqn">(q,l)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the group pair (3,2) into an index, where the total number of groups is 3,
# for directed and undirected graph

q &lt;- 3
l &lt;- 2
Q &lt;- 3

directedIndex &lt;- convertGroupPair(q,l,Q)
undirectedIndex &lt;- convertGroupPair(q,l,Q, FALSE)

</code></pre>

<hr>
<h2 id='convertNodePair'>Convert node pair <code class="reqn">(i,j)</code></h2><span id='topic+convertNodePair'></span>

<h3>Description</h3>

<p>Convert node pair <code class="reqn">(i,j)</code> into an index in <code class="reqn">\{1,\dots,N\}</code> where <code class="reqn">N=n(n-1)</code> (directed case) or <code class="reqn">N=n(n-1)/2</code> (undirected case).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertNodePair(i, j, n, directed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertNodePair_+3A_i">i</code></td>
<td>
<p>Node <code class="reqn">i</code> : <code class="reqn">i\in \{1, \ldots, n\} </code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_j">j</code></td>
<td>
<p>Node <code class="reqn">j</code> : <code class="reqn">j\in \{1, \ldots, n\} </code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code></p>
</td></tr>
<tr><td><code id="convertNodePair_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interacting individuals <code class="reqn">(i,j)</code> must be encoded into integer values in  <code class="reqn">\{1,\dots,N\}</code> in describing the data. 
</p>

<dl>
<dt><strong>Directed case :</strong></dt><dd>

<ul>
<li><p> The node pair <code class="reqn">(i,j)</code> with <code class="reqn">(i\neq j)</code> is converted into the index <code class="reqn">(i-1)*(n-1)+j-(i&lt;j)</code>
</p>
</li></ul>

</dd>
<dt><strong>Undirected case :</strong></dt><dd>

<ul>
<li><p> The node pair <code class="reqn">(i,j)</code> with <code class="reqn">(i\neq j)</code> is converted into the index <code class="reqn">(2*n-i)*(i-1)/2 +j-i</code>
</p>
</li></ul>

</dd>
</dl>

<p>The number of possible node pairs is
</p>

<ul>
<li> <p><code class="reqn">N = n*(n-1)</code> for the directed case
</p>
</li>
<li> <p><code class="reqn">N = n*(n-1)/2</code>  for the undirected case
</p>
</li></ul>

<p>which corresponds to the range of values for <code>data$type.seq</code>
</p>


<h3>Value</h3>

<p>Index corresponding to the node pair
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the node pair (3,7) into an index, where the total number of nodes is 10,
# for directed and undirected interactions

i &lt;- 3
j &lt;- 7
n &lt;- 10

directedIndex &lt;- convertNodePair(i,j,n,TRUE)
undirectedIndex &lt;- convertNodePair(i,j,n,FALSE)

</code></pre>

<hr>
<h2 id='correctTau'>Handling of values of <code class="reqn">\tau</code></h2><span id='topic+correctTau'></span>

<h3>Description</h3>

<p>Avoid values of <code class="reqn">\tau</code> to be exactly 0 and exactly 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctTau(tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctTau_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
</table>

<hr>
<h2 id='find_ql'>Convert index into group pair</h2><span id='topic+find_ql'></span>

<h3>Description</h3>

<p>This function is the inverse of the conversion <code class="reqn">\{(q,l), 1 \le q,l\le Q \} </code> into <code class="reqn">\{1,...,Q^2\}</code> for the directed case and of <code class="reqn">\{(q,l), 1 \le q \le  l \le Q \}</code> into <code class="reqn">\{1,...,Q(Q+1)/2\}</code> for the undirected case.
It takes the integer index corresponding to <code class="reqn">(q,l)</code> and returns the pair <code class="reqn">(q,l)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ql(ind_ql, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_ql_+3A_ind_ql">ind_ql</code></td>
<td>
<p>Converted <code class="reqn">(q,l)</code> index</p>
</td></tr>
<tr><td><code id="find_ql_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="find_ql_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Group pair <code class="reqn">(q,l)</code> corresponding to the given index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the index 5 into a group pair for undirected graph
# and the index 8 into a group pair for directed graph
# where the total number of groups is 3

ind_ql_dir &lt;- 8
ind_ql_undir &lt;- 5

Q &lt;- 3

directedIndex &lt;- find_ql(ind_ql_dir,Q)
undirectedIndex &lt;- find_ql(ind_ql_undir,Q, FALSE)

</code></pre>

<hr>
<h2 id='find_ql_diff'>Convert index into group pair in tauDown_Q</h2><span id='topic+find_ql_diff'></span>

<h3>Description</h3>

<p>This function is the inverse of the conversion <code class="reqn">{(q,l), q&lt;l}</code> into <code class="reqn">{1,...,Q*(Q-1)/2}</code>. Used only in tauDown_Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ql_diff(ind_ql, Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_ql_diff_+3A_ind_ql">ind_ql</code></td>
<td>
<p>Converted <code class="reqn">(q,l)</code> index</p>
</td></tr>
<tr><td><code id="find_ql_diff_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Group pair <code class="reqn">(q,l)</code> corresponding to the given index
</p>

<hr>
<h2 id='generated_Q3'>Example dataset</h2><span id='topic+generated_Q3'></span>

<h3>Description</h3>

<p>Example of undirected dataset with <code class="reqn">n=50</code> individuals in <code class="reqn">Q=3</code> clusters and final observation Time=1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_Q3
</code></pre>


<h3>Format</h3>

<p>A list of 3 components:
</p>

<dl>
<dt><code>data</code></dt><dd><p>Observed data is itself a list of 3 components:
</p>

<ul>
<li> <p><code>time.seq</code> - Vector containing the times (in [0,1]) of the events (length M).
</p>
</li>
<li> <p><code>type.seq</code> - Vector containing the types in <code class="reqn">\{1,\dots, N\}</code> of the events (length M). Here, <code class="reqn">N=n(n-1)/2</code> (undirected). 
</p>
</li>
<li> <p><code>Time</code> - Positive real number. [0,Time] is the total time interval of observation.
</p>
</li></ul>

</dd>
<dt><code>z</code></dt><dd><p>Latent variables. A matrix with size <code class="reqn">Q\times n</code> and entries 1 (cluster q contains node i) or 0 (else).</p>
</dd>
<dt><code>intens</code></dt><dd><p>Intensities used to simulate data. A list of <code class="reqn">Q(Q+1)/2</code> intensity functions. Each one is given as a list of 2 components:
</p>

<ul>
<li> <p><code>intens</code> - a positive function. The intensity function  <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li>
<li> <p><code>max</code> - positive real number. An upper bound on function <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Details</h3>

<p>This random datatset was obtained using the following code
</p>
<pre>

intens &lt;- list(NULL)
intens[[1]] &lt;- list(intens=function(x) return (rep(4,length(x))), max=4.1)
intens[[2]] &lt;- list(intens=function(x){
   y &lt;- rep(0,length(x))
   y[x&lt;.25] &lt;- 4
   y[x&gt;.75] &lt;- 10
   return(y)
 }, max=10.1)
intens[[3]] &lt;- list(intens=function(x) return(8*(1/2-abs(x-1/2))), max=4.1)
intens[[4]] &lt;- list(intens=function(x) return(100*x*exp(-8*x)), max=4.698493)
intens[[5]] &lt;- list(intens=function(x) return(exp(3*x)*(sin(6*pi*x-pi/2)+1)/2), max=12.59369)
intens[[6]] &lt;- list(intens=function(x) return(8.1*(exp(-6*abs(x-1/2))-.049)), max=7.8031)

generated_Q3 &lt;- generateDynppsbm(intens,Time=1,n=50,prop.groups=rep(1/3,3),directed=F)
</pre>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>

<hr>
<h2 id='generated_Q3_n20'>Example dataset</h2><span id='topic+generated_Q3_n20'></span>

<h3>Description</h3>

<p>Example of undirected dataset with <code class="reqn">n=20</code> individuals in <code class="reqn">Q=3</code> clusters and observation Time=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_Q3_n20
</code></pre>


<h3>Format</h3>

<p>A list of 3 components:
</p>

<dl>
<dt><code>data</code></dt><dd><p>Observed data is itself a list of 3 components:
</p>

<ul>
<li> <p><code>time.seq</code> - Vector containing the times of the events (length M)
</p>
</li>
<li> <p><code>type.seq</code> - Vector containing the types of the events (length M) 
</p>
</li>
<li> <p><code>Time</code> - Positive real number. [0,Time] is the total time interval of observation
</p>
</li></ul>

</dd>
<dt><code>z</code></dt><dd><p>Latent variables. A matrix with size <code class="reqn">Q\times n</code> and entries 1 (cluster q contains node i) or 0 (else).</p>
</dd>
<dt><code>intens</code></dt><dd><p>Intensities used to simulate data. A list of <code class="reqn">Q(Q+1)/2</code> intensity functions. Each one is given as a list of 2 components:
</p>

<ul>
<li> <p><code>intens</code> - a positive function. The intensity function  <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li>
<li> <p><code>max</code> - positive real number. An upper bound on function <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li></ul>

</dd>
</dl>



<h3>Details</h3>

<p>This random datatset was obtained using the following code
</p>
<pre>
intens &lt;- list(NULL)
intens[[1]] &lt;- list(intens=function(x) return (rep(4,length(x))), max=4.1)
intens[[2]] &lt;- list(intens=function(x){
   y &lt;- rep(0,length(x))
   y[x&lt;.25] &lt;- 4
   y[x&gt;.75] &lt;- 10
   return(y)
 }, max=10.1)
intens[[3]] &lt;- list(intens=function(x) return(8*(1/2-abs(x-1/2))), max=4.1)
intens[[4]] &lt;- list(intens=function(x) return(100*x*exp(-8*x)), max=4.698493)
intens[[5]] &lt;- list(intens=function(x) return(exp(3*x)*(sin(6*pi*x-pi/2)+1)/2), max=12.59369)
intens[[6]] &lt;- list(intens=function(x) return(8.1*(exp(-6*abs(x-1/2))-.049)), max=7.8031)

generated_Q3_n20 &lt;- generateDynppsbm(intens,Time=1,n=20,prop.groups=rep(1/3,3),directed=F)
</pre>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>

<hr>
<h2 id='generated_sol_hist'>Output example of <a href="#topic+mainVEM">mainVEM</a></h2><span id='topic+generated_sol_hist'></span>

<h3>Description</h3>

<p>Output of <a href="#topic+mainVEM">mainVEM</a> obtained on dataset <code>generated_Q3</code> with <code>hist</code> method and Qmin=1, Qmax=5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_sol_hist
</code></pre>


<h3>Format</h3>

<p>List of 5 components. 
Each one is the output of the algorithm with a different value of the number of clusters <code class="reqn">Q</code> for <code class="reqn">1\le Q \le 5</code> and given as a list of 8 components:  
</p>

<dl>
<dt><code>tau</code></dt><dd><p>Matrix with size <code class="reqn">Q\times n</code> containing the estimated probability in <code class="reqn">(0,1)</code> that cluster <code class="reqn">q</code> contains node <code class="reqn">i</code>.</p>
</dd>
<dt><code>rho</code></dt><dd><p>Sparsity parameter - 1 in this case (non sparse method).</p>
</dd>
<dt><code>beta</code></dt><dd><p>Sparsity parameter - 1 in this case (non sparse method).</p>
</dd>   
<dt><code>logintensities.ql</code></dt><dd><p>Matrix with size <code class="reqn">Q(Q+1)/2\times K</code>. Each row contains estimated values of the log of the intensity function <code class="reqn">\log(\alpha^{(q,l)})</code> on a regular partition (in <code class="reqn">K</code> parts) of the time interval [0,Time].</p>
</dd>  
<dt><code>best.d</code></dt><dd><p>Vector with length <code class="reqn">Q(Q+1)/2</code> (undirected case) with estimated value for the exponent of the best partition to estimate intensity <code class="reqn">\alpha^{(q,l)}</code>. The best number of parts is <code class="reqn">K=2^d</code>.</p>
</dd>
<dt><code>J</code></dt><dd><p>Estimated value of the ELBO</p>
</dd>
<dt><code>run</code></dt><dd><p>Which run of the algorithm gave the best solution. A run relies on a specific initialization of the algorithm. A negative value maybe obtained in the decreasing phase (for Q) of the algorithm.</p>
</dd>  
<dt><code>converged</code></dt><dd><p>Boolean. If TRUE, the algorithm stopped at convergence. Otherwise it stopped at the maximal number of iterations.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>This solution was (randomly) obtained using the following code
</p>
<pre>
Nijk &lt;- statistics(generated_Q3$data,n=50,K=8,directed=FALSE)
generated_sol_hist &lt;- mainVEM(list(Nijk=Nijk,Time=1),n=50,Qmin=1,Qmax=5,directed=FALSE,method='hist')
</pre>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>

<hr>
<h2 id='generated_sol_kernel'>Output example of <a href="#topic+mainVEM">mainVEM</a></h2><span id='topic+generated_sol_kernel'></span>

<h3>Description</h3>

<p>Output of <a href="#topic+mainVEM">mainVEM</a> obtained on dataset <code>generated_Q3</code> with <code>kernel</code> method and Qmin=Qmax=5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_sol_kernel
</code></pre>


<h3>Format</h3>

<p>Solution for Q=5 clusters, containing 5 components:
</p>

<dl>
<dt><code>tau</code></dt><dd><p>Matrix with size <code class="reqn">Q\times n</code> containing the estimated probability in <code class="reqn">(0,1)</code> that cluster <code class="reqn">q</code> contains node <code class="reqn">i</code>.</p>
</dd>
<dt><code>J</code></dt><dd><p>Estimated value of the ELBO</p>
</dd>
<dt><code>run</code></dt><dd><p>Which run of the algorithm gave the best solution. A run relies on a specific initialization of the algorithm. A negative value maybe obtained in the decreasing phase (for Q) of the algorithm.</p>
</dd>  
<dt><code>converged</code></dt><dd><p>Boolean. If TRUE, the algorithm stopped at convergence. Otherwise it stopped at the maximal number of iterations.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>This solution was (randomly) obtained using the following code
</p>
<pre>
# WARNING - This is very long
generated_sol_kernel &lt;- mainVEM(generated_Q3$data,n=50,Qmin=5,directed=FALSE,method='kernel')[[1]]
</pre>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>

<hr>
<h2 id='generateDynppsbm'>Dynppsbm data generator</h2><span id='topic+generateDynppsbm'></span>

<h3>Description</h3>

<p>Generates data under the Dynamic Poisson Process Stochastic Blockmodel (dynppsbm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateDynppsbm(intens, Time, n, prop.groups, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateDynppsbm_+3A_intens">intens</code></td>
<td>
<p>List of intensity functions <code class="reqn">\alpha^{(q,l)}</code>, each one is a list of 2 components:
</p>

<ul>
<li> <p><code>intens</code> : a positive function. The intensity function  <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li>
<li> <p><code>max</code> : positive real number. An upper bound on <code class="reqn">\alpha^{(q,l)}</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_time">Time</code></td>
<td>
<p>Positive real number. [0,Time] is the total time interval of observation.</p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code>.</p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_prop.groups">prop.groups</code></td>
<td>
<p>Vector of group proportions (probability to belong to a group), should be of length <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="generateDynppsbm_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.
</p>
<p>If directed then <code>intens</code> should be of length <code class="reqn">Q^2</code>, else of length <code class="reqn">Q*(Q+1)/2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated data, latent group variables and intensities <code class="reqn">\alpha^{(q,l)}</code>.
</p>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from an undirected graph with n=10 individuals and Q=2 clusters

# equal cluster proportions
prop.groups &lt;- c(0.5,0.5)

# 3 different intensity functions:
intens &lt;- list(NULL)
intens[[1]] &lt;- list(intens= function(x) 100*x*exp(-8*x),max=5)
    # (q,l) = (1,1)
intens[[2]] &lt;- list(intens= function(x) exp(3*x)*(sin(6*pi*x-pi/2)+1)/2,max=13)
    # (q,l) = (1,2)
intens[[3]] &lt;- list(intens= function(x) 8.1*(exp(-6*abs(x-1/2))-.049),max=8)
    # (q,l) = (2,2)

# generate data:
obs &lt;- generateDynppsbm(intens,Time=1,n=10,prop.groups,directed=FALSE)

# latent variables (true clustering of the individuals)
obs$z

# number of time events:
length(obs$data$time.seq)

# number of interactions between each pair of individuals:
table(obs$data$type.seq)

</code></pre>

<hr>
<h2 id='generateDynppsbmConst'>Data under dynppsbm with piecewise constant intensities</h2><span id='topic+generateDynppsbmConst'></span>

<h3>Description</h3>

<p>Generate data under the Dynamic Poisson Process Stochastic Blockmodel (dynppsbm) with piecewise constant intensity functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateDynppsbmConst(intens, Time, n, prop.groups, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateDynppsbmConst_+3A_intens">intens</code></td>
<td>
<p>Matrix with piecewise constant intensities <code class="reqn">\alpha^{(q,l)}</code>. Each row gives the constant values of the piecewise constant intensity for a group pair <code class="reqn">(q,l)</code> on a regular partition of the time interval [0,Time].</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_time">Time</code></td>
<td>
<p>Positive real number. [0,Time] is the total time interval of observation.</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code>.</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_prop.groups">prop.groups</code></td>
<td>
<p>Vector of group proportions, should be of length <code class="reqn">Q</code>.</p>
</td></tr>
<tr><td><code id="generateDynppsbmConst_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.
</p>
<p>If directed then <code>intens</code> should be of length <code class="reqn">Q^2</code>, else of length <code class="reqn">Q*(Q+1)/2</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define 2 different piecewise constant intensity functions
# on a 3 parts regular partition of time interval [0,Time]
intens1 &lt;- c(1,3,8)
intens2 &lt;- c(2,3,6)

intens &lt;- matrix(c(intens1,intens2,intens1,intens2),4,3)

Time &lt;- 10
n &lt;- 20
prop.groups &lt;- c(0.2,0.8)
obs &lt;- generateDynppsbmConst(intens,Time,n,prop.groups,directed=TRUE)

</code></pre>

<hr>
<h2 id='generatePP'>Poisson process generator</h2><span id='topic+generatePP'></span>

<h3>Description</h3>

<p>Generates one realization of an inhomogeneous Poisson process (PP) with given intensity function (using the thinning method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePP(intens, Time, max.intens)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generatePP_+3A_intens">intens</code></td>
<td>
<p>Intensity function defined on [0,Time] (needs to be positive).</p>
</td></tr>
<tr><td><code id="generatePP_+3A_time">Time</code></td>
<td>
<p>Positive real number. [0,Time] is the total time interval of observation.</p>
</td></tr>
<tr><td><code id="generatePP_+3A_max.intens">max.intens</code></td>
<td>
<p>Positive real number. Upper bound of intensity on [0,Time].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the values of one realization of the PP.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a Poisson Process on time interval [0,30] with intensity function
# intens= function(x) 100*x*exp(-8*x)
# using max.intens = 5

intens &lt;- function(x) 100*x*exp(-8*x)

generatePP(intens, Time=30, max.intens=5)

</code></pre>

<hr>
<h2 id='generatePPConst'>Poisson process with piecewise constant intensity</h2><span id='topic+generatePPConst'></span>

<h3>Description</h3>

<p>Generates one realization of a Poisson process (PP) with a piecewise constant intensity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePPConst(intens, Time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generatePPConst_+3A_intens">intens</code></td>
<td>
<p>Vector with the constant values of the intensity, defined on a regular partition of the time interval [0,Time].</p>
</td></tr>
<tr><td><code id="generatePPConst_+3A_time">Time</code></td>
<td>
<p>Positive real number. [0,Time] is the total time interval of observation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># On time interval [0,T], partitioned into 3 regular parts: [0,T/3], [T/3,2T/3] and [2T/3,T],
# define a piecewise constant intensity function
intens &lt;- c(1,2,8)

# generate a PP with total observation time T=10
generatePPConst(intens, 10)

</code></pre>

<hr>
<h2 id='JEvalMstep'>Evaluation of criterion J</h2><span id='topic+JEvalMstep'></span>

<h3>Description</h3>

<p>Evaluation of the criterion J to verify the convergence of the VEM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JEvalMstep(VE, mstep, data, directed, sparse, method = "hist")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JEvalMstep_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation
</p>

<ul>
<li><p> mstep$sum_rhotau : N_Q vector (not needed in the function)
</p>
</li>
<li><p> mstep$sum_rhotau_obs : N_Q vector
</p>
</li>
<li><p> mstep$logintensities.ql :  N_Q x Dmax matrix
</p>
</li>
<li><p> m.step$beta : N_Q vector
</p>
</li></ul>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="JEvalMstep_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
</table>

<hr>
<h2 id='kernelIntensities'>Direct kernel estimator intensities</h2><span id='topic+kernelIntensities'></span>

<h3>Description</h3>

<p>Compute smooth intensities with direct kernel estimation of intensities relying on a classification <code class="reqn">\tau</code>.
This can be used with the values <code class="reqn">\tau</code> obtained on a dataset with <a href="#topic+mainVEM">mainVEM</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelIntensities(
  data,
  tau,
  Q,
  n,
  directed,
  rho = 1,
  sparse = FALSE,
  nb.points = 1000 * data$Time
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelIntensities_+3A_data">data</code></td>
<td>
<p>List with 3 components:
</p>

<ul>
<li> <p><code>time.seq</code> - Vector of observed time points of the events (length <code class="reqn">M</code>).
</p>
</li>
<li> <p><code>type.seq</code> - Vector of observed types of node pairs (as encoded through <a href="#topic+convertNodePair">convertNodePair</a> of the events (length <code class="reqn">M</code>)).
</p>
</li>
<li> <p><code>Time</code> - [0,Time] is the total time interval of observation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_tau">tau</code></td>
<td>
<p>Matrix with size <code class="reqn">Q\times n</code> and values in <code class="reqn">(0,1)</code>, containing the (estimated) probability that cluster <code class="reqn">q</code> contains node <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_q">Q</code></td>
<td>
<p>Total number of groups.</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code>.</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_rho">rho</code></td>
<td>
<p>Either 1 (non sparse case) or vector with length <code class="reqn">Q(Q+1)/2</code> (undirected case) or <code class="reqn">Q^2</code> (directed case) with (estimated) values for the sparsity parameters <code class="reqn">\rho^{(q,l)}</code>. See Section S6 in the supplementary material paper of Matias et al. (Biometrika, 2018) for more details.</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case.</p>
</td></tr>
<tr><td><code id="kernelIntensities_+3A_nb.points">nb.points</code></td>
<td>
<p>Number of points for the kernel estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning: sparse case not implemented !!!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The generated_sol_kernel solution was generated calling mainVEM
# with kernel method on the generated_Q3$data dataset.
# (50 individuals and 3 clusters)

data &lt;- generated_Q3$data

n &lt;- 50
Q &lt;- 3


# Compute smooth intensity estimators
sol.kernel.intensities &lt;- kernelIntensities(data,generated_sol_kernel$tau,Q,n,directed=FALSE)

</code></pre>

<hr>
<h2 id='listNodePairs'>List node pairs</h2><span id='topic+listNodePairs'></span>

<h3>Description</h3>

<p>Create the list of all node pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listNodePairs(n, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listNodePairs_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1 \le i \le n</code></p>
</td></tr>
<tr><td><code id="listNodePairs_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with two columns which lists all the possible node pairs. Each row is a node pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all the node pairs with 10 nodes, for directed and undirected graphs

n &lt;- 10
listNodePairs(n, TRUE)
listNodePairs(n, FALSE)

</code></pre>

<hr>
<h2 id='mainVEM'>Adaptive VEM algorithm</h2><span id='topic+mainVEM'></span>

<h3>Description</h3>

<p>Principal adaptive VEM algorithm for histogram (with model selection) or for kernel method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainVEM(
  data,
  n,
  Qmin,
  Qmax = Qmin,
  directed = TRUE,
  sparse = FALSE,
  method = c("hist", "kernel"),
  init.tau = NULL,
  cores = 1,
  d_part = 5,
  n_perturb = 10,
  perc_perturb = 0.2,
  n_random = 0,
  nb.iter = 50,
  fix.iter = 10,
  epsilon = 1e-06,
  filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mainVEM_+3A_data">data</code></td>
<td>
<p>Data format depends on the estimation method used!!
</p>

<ol>
<li><p> Data with <strong>hist</strong> method - List with 2 components:
</p>

<dl>
<dt>data$Time</dt><dd><p>Positive real number. [0,data$Time] is the total time interval of observation</p>
</dd>
<dt>data$Nijk</dt><dd><p>Data matrix with counts per process <code class="reqn">N_{ij}</code> and sub-intervals ; matrix of size <code class="reqn">N*K</code>  where <code class="reqn">N = n(n-1)</code> or <code class="reqn">n(n-1)/2</code> is the number of possible node pairs in the graph and <code class="reqn">K = 2^{dmax}</code> is the size of the finest partition in the  histogram approach.
</p>
<p>Counts are pre-computed - Obtained through function <a href="#topic+statistics">statistics</a> on data with second format and using a number of subintervals K as a power of 2.</p>
</dd>
</dl>

</li>
<li><p> Data with <strong>kernel</strong> method - List with 3 components:
</p>

<dl>
<dt>data$time.seq</dt><dd><p>Vector of the time points of the events (size M).</p>
</dd>
<dt>data$type.seq</dt><dd><p>Vector of the corresponding node pair indexes in format output by <a href="#topic+convertNodePair">convertNodePair</a> of the events (same size M).</p>
</dd>
<dt>data$Time</dt><dd><p>[0,data$Time] is the total time interval of observation</p>
</dd>
</dl>

</li></ol>
</td></tr>
<tr><td><code id="mainVEM_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code></p>
</td></tr>
<tr><td><code id="mainVEM_+3A_qmin">Qmin</code></td>
<td>
<p>Minimum number of groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_qmax">Qmax</code></td>
<td>
<p>Maximum number of groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_method">method</code></td>
<td>
<p>Either <code>hist</code> for histogram method or <code>kernel</code> for kernel method
</p>
<p>Beware: <code>hist</code> is recommended (much faster). You can obtain smooth estimated intensities by using <a href="#topic+kernelIntensities">kernelIntensities</a> on the output of the <code>hist</code> method.</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_init.tau">init.tau</code></td>
<td>
<p>List of initial values of <code class="reqn">\tau</code> - all tau's are matrices with size <code class="reqn">Q\times n</code> (might be with different values of Q)</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_cores">cores</code></td>
<td>
<p>Number of cores for parallel execution
</p>
<p>If set to 1 it does sequential execution
</p>
<p>Beware: parallelization with fork (multicore) : doesn't work on Windows!</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partition of time interval [0,T] used for k-means initializations.
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_{part} +1)} -1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mainVEM_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result
</p>
<p>When <code class="reqn">Qmin &lt; Qmax</code>, number of perturbations on the result with <code class="reqn">Q-1</code> or <code class="reqn">Q+1</code> groups</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_n_random">n_random</code></td>
<td>
<p>Number of completely random initial points. The total number of initializations for the VEM is <code class="reqn">npart*(1+n_{perturb}) +n_{random}</code></p>
</td></tr>
<tr><td><code id="mainVEM_+3A_nb.iter">nb.iter</code></td>
<td>
<p>Number of iterations of the VEM algorithm</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point into the VE step</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
<tr><td><code id="mainVEM_+3A_filename">filename</code></td>
<td>
<p>Name of the file where to save the results along the computation (increasing steps for <code class="reqn">Q</code>, these are the longest).
</p>
<p>The file will contain a list of 'best' results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sparse version works only for the histogram approach.
</p>


<h3>Value</h3>

<p>The function outputs a list of Qmax-Qmin+1 components. Each component is the solution obtained for a number of clusters Q, with <code class="reqn">Qmin\le Q \le Qmax</code> and is a list of 8 elements:
</p>

<ul>
<li> <p><code>tau</code> - Matrix with size <code class="reqn">Q\times n</code> containing the estimated values in <code class="reqn">(0,1)</code> that cluster q contains node i.
</p>
</li>
<li> <p><code>rho</code> - When method=<code>hist</code> only. Either 1 (non sparse method) or a vector with length <code class="reqn">Q(Q+1)/2</code> (undirected case) or <code class="reqn">Q^2</code> (directed case) with estimated values for the sparsity parameters <code class="reqn">\rho^{(q,l)}</code>. See Section S6 in the supplementary material paper of Matias et al. (Biometrika, 2018) for more details.
</p>
</li>
<li> <p><code>beta</code> - When method=<code>hist</code> only. Vector with length <code class="reqn">Q(Q+1)/2</code> (undirected case) or <code class="reqn">Q^2</code> (directed case) with estimated values for the sparsity parameters <code class="reqn">\beta^{(q,l)}</code>. See Section S6 in the supplementary material paper Matias et al. (Biometrika, 2018) for more details.
</p>
</li>
<li> <p><code>logintensities.ql</code> - When method=<code>hist</code> only. Matrix with size <code class="reqn">Q(Q+1)/2\times K</code> (undirected case) or <code class="reqn">Q^2\times K</code> (directed case). Each row contains estimated values of the log intensity function <code class="reqn">\log(\alpha^{(q,l)})</code> on a regular partition with K parts of the time interval [0,Time].
</p>
</li>
<li> <p><code>best.d</code> - When method=<code>hist</code> only. Vector with length <code class="reqn">Q(Q+1)/2</code> (undirected case) or <code class="reqn">Q^2</code> (directed case) with estimated value for the exponent of the best partition to estimate intensity <code class="reqn">\alpha^{(q,l)}</code>. The best number of parts is <code class="reqn">K=2^d</code>.
</p>
</li>
<li> <p><code>J</code> - Estimated value of the ELBO.
</p>
</li>
<li> <p><code>run</code> - Which run of the algorithm gave the best solution. A run relies on a specific initialization of the algorithm. A negative value maybe obtained in the decreasing phase (for Q) of the algorithm.
</p>
</li>
<li> <p><code>converged</code> - Boolean. If TRUE, the algorithm stopped at convergence. Otherwise it stopped at the maximal number of iterations.
</p>
</li></ul>



<h3>References</h3>

<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>DEMPSTER, A. P., LAIRD, N. M. &amp; RUBIN, D. B. (1977). Maximum likelihood from incomplete data via the EM algorithm. J. Roy. Statist. Soc. Ser. B 39, 1–38.
</p>
<p>JORDAN, M., GHAHRAMANI, Z., JAAKKOLA, T. &amp; SAUL, L. (1999). An introduction to variational methods for graphical models. Mach. Learn. 37, 183–233.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>
<p>MATIAS, C. &amp; ROBIN, S. (2014). Modeling heterogeneity in random graphs through latent space models: a selective review. Esaim Proc. &amp; Surveys 47, 55–74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 20
Q &lt;- 3

Time &lt;- generated_Q3_n20$data$Time
data &lt;- generated_Q3_n20$data
z &lt;- generated_Q3_n20$z

step &lt;- .001
x0 &lt;- seq(0,Time,by=step)
intens &lt;-  generated_Q3_n20$intens

# VEM-algo kernel
sol.kernel &lt;- mainVEM(data,n,Q,directed=FALSE,method='kernel', d_part=0,
    n_perturb=0)[[1]]
# compute smooth intensity estimators
sol.kernel.intensities &lt;- kernelIntensities(data,sol.kernel$tau,Q,n,directed=FALSE)
# eliminate label switching
intensities.kernel &lt;- sortIntensities(sol.kernel.intensities,z,sol.kernel$tau,
    directed=FALSE)

# VEM-algo hist
# compute data matrix with precision d_max=3 (ie nb of parts K=2^{d_max}=8).
K &lt;- 2^3
Nijk &lt;- statistics(data,n,K,directed=FALSE)
sol.hist &lt;- mainVEM(list(Nijk=Nijk,Time=Time),n,Q,directed=FALSE, method='hist',
    d_part=0,n_perturb=0,n_random=0)[[1]]
log.intensities.hist &lt;- sortIntensities(sol.hist$logintensities.ql,z,sol.hist$tau,
     directed=FALSE)

# plot estimators
par(mfrow=c(2,3))
ind.ql &lt;- 0
for (q in 1:Q){
  for (l in q:Q){
    ind.ql &lt;- ind.ql + 1
    true.val &lt;- intens[[ind.ql]]$intens(x0)
    values &lt;- c(intensities.kernel[ind.ql,],exp(log.intensities.hist[ind.ql,]),true.val)
    plot(x0,true.val,type='l',xlab=paste0("(q,l)=(",q,",",l,")"),ylab='',
        ylim=c(0,max(values)+.1))
    lines(seq(0,1,by=1/K),c(exp(log.intensities.hist[ind.ql,]),
        exp(log.intensities.hist[ind.ql,K])),type='s',col=2,lty=2)
    lines(seq(0,1,by=.001),intensities.kernel[ind.ql,],col=4,lty=3)
  }
}

</code></pre>

<hr>
<h2 id='mainVEMPar'>VEM step for parallel version</h2><span id='topic+mainVEMPar'></span>

<h3>Description</h3>

<p>VEM step for parallel version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mainVEMPar(
  init.point,
  n,
  Q,
  data,
  directed,
  sparse,
  method,
  nb.iter,
  fix.iter,
  epsilon
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mainVEMPar_+3A_init.point">init.point</code></td>
<td>
<p>Initial point</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code></p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_nb.iter">nb.iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point</p>
</td></tr>
<tr><td><code id="mainVEMPar_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
</table>

<hr>
<h2 id='modelSelec_QPlot'>Plots for model selection</h2><span id='topic+modelSelec_QPlot'></span>

<h3>Description</h3>

<p>Plots the Integrated Classification Likelihood (ICL) criterion, the Complete Log-Likelihood (CLL) and the ELBO (J criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSelec_QPlot(model.selec_Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSelec_QPlot_+3A_model.selec_q">model.selec_Q</code></td>
<td>
<p>Output from <a href="#topic+modelSelection_Q">modelSelection_Q</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 50

# compute data matrix of counts per subinterval with precision d_max=3 :
# (ie nb of parts K=2^{d_max}=8).
K &lt;- 2^3
data &lt;- list(Nijk=statistics(generated_Q3$data,n,K,directed=FALSE),
    Time=generated_Q3$data$Time)

# ICL-model selection
sol.selec_Q &lt;- modelSelection_Q(data,n,Qmin=1,Qmax=4,directed=FALSE,
    sparse=FALSE,generated_sol_hist)

# plot ICL
modelSelec_QPlot(sol.selec_Q)

</code></pre>

<hr>
<h2 id='modelSelection_Q'>Selects the number of groups with ICL criterion</h2><span id='topic+modelSelection_Q'></span>

<h3>Description</h3>

<p>Selects the number of groups with Integrated Classification Likelihood (ICL) criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSelection_Q(
  data,
  n,
  Qmin = 1,
  Qmax,
  directed = TRUE,
  sparse = FALSE,
  sol.hist.sauv
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSelection_Q_+3A_data">data</code></td>
<td>
<p>List with 2 components:
</p>

<ul>
<li> <p><code>Time</code> - Positive real number. [0,Time] is the total time interval of observation.
</p>
</li>
<li> <p><code>Nijk</code> - Data matrix with the statistics per process <code class="reqn">N_{ij}</code> and sub-intervals <code class="reqn">1\le k\le K</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code>.</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_qmin">Qmin</code></td>
<td>
<p>Minimum number of groups.</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_qmax">Qmax</code></td>
<td>
<p>Maximum number of groups.</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case.</p>
</td></tr>
<tr><td><code id="modelSelection_Q_+3A_sol.hist.sauv">sol.hist.sauv</code></td>
<td>
<p>List of size Qmax-Qmin+1 obtained from running <a href="#topic+mainVEM">mainVEM</a> on the data with method='hist'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function outputs a list of 7 components:
</p>

<ul>
<li> <p><code>Qbest</code> Selected value of the number of groups in [Qmin, Qmax].
</p>
</li>
<li> <p><code>sol.Qbest</code> Solution of the <a href="#topic+mainVEM">mainVEM</a> function for the number of groups Qbest.
</p>
</li>
<li> <p><code>Qmin</code> Minimum number of groups used.
</p>
</li>
<li> <p><code>all.J</code> Vector of length Qmax-Qmin+1. Each value is the estimated ELBO function <code class="reqn">J</code> for estimation with <code class="reqn">Q</code> groups, <code class="reqn">Qmin \le Q \le Qmax</code>.
</p>
</li>
<li> <p><code>all.ICL</code> Vector of length Qmax-Qmin+1. Each value is the ICL value for estimation with <code class="reqn">Q</code> groups, <code class="reqn">Qmin \le Q \le Qmax</code>.
</p>
</li>
<li> <p><code>all.compl.log.likelihood</code> Vector of length Qmax-Qmin+1. Each value is the estimated complete log-likelihood value for estimation with <code class="reqn">Q</code> groups, <code class="reqn">Qmin \le Q \le Qmax</code>.
</p>
</li>
<li> <p><code>all.pen</code> Vector of length Qmax-Qmin+1. Each value is the penalty term in ICL for estimation with <code class="reqn">Q</code> groups, <code class="reqn">Qmin \le Q \le Qmax</code>.
</p>
</li></ul>



<h3>References</h3>

<p>BIERNACKI, C., CELEUX, G. &amp; GOVAERT, G. (2000). Assessing a mixture model for clustering with the integrated completed likelihood. IEEE Trans. Pattern Anal. Machine Intel. 22, 719–725.
</p>
<p>CORNELI, M., LATOUCHE, P. &amp; ROSSI, F. (2016). Exact ICL maximization in a non-stationary temporal extension of the stochastic block model for dynamic networks. Neurocomputing 192, 81 – 91.
</p>
<p>DAUDIN, J.-J., PICARD, F. &amp; ROBIN, S. (2008). A mixture model for random graphs. Statist. Comput. 18, 173–183.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data of a synthetic graph with 50 individuals and 3 clusters
n &lt;- 50

# compute data matrix of counts per subinterval with precision d_max=3
# (ie nb of parts K=2^{d_max}=8).
K &lt;- 2^3
data &lt;- list(Nijk=statistics(generated_Q3$data,n,K,directed=FALSE),
    Time=generated_Q3$data$Time)

# ICL-model selection with groups ranging from 1 to 4
sol.selec_Q &lt;- modelSelection_Q(data,n,Qmin=1,Qmax=4,directed=FALSE,
    sparse=FALSE,generated_sol_hist)

# best number Q of clusters:
sol.selec_Q$Qbest

</code></pre>

<hr>
<h2 id='Mstep_hist'>M step for histograms</h2><span id='topic+Mstep_hist'></span>

<h3>Description</h3>

<p>M step for histograms estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_hist(data, VE, directed, sparse)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mstep_hist_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="Mstep_hist_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
</table>


<h3>References</h3>

<p>BARAUD, Y. &amp; BIRGÉ, L. (2009). Estimating the intensity of a random measure by histogram type estimators. Probab. Theory Related Fields 143, 239–284.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>
<p>REYNAUD -BOURET, P. (2006). Penalized projection estimators of the Aalen multiplicative intensity. Bernoulli 12, 633–661.
</p>

<hr>
<h2 id='Mstep_kernel'>M step for kernel</h2><span id='topic+Mstep_kernel'></span>

<h3>Description</h3>

<p>M step for kernel estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep_kernel(data, VE, directed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mstep_kernel_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="Mstep_kernel_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE for iterative computation</p>
</td></tr>
<tr><td><code id="Mstep_kernel_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>References</h3>

<p>GRÉGOIRE , G. (1993). Least squares cross-validation for counting process intensities. Scand. J. Statist. 20, pp. 343–360.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>
<p>RAMLAU-HANSEN, H. (1983). Smoothing counting process intensities by means of kernel functions. Ann. Statist. 11, pp. 453–466.
</p>

<hr>
<h2 id='permuteZEst'>Optimal matching between 2 clusterings</h2><span id='topic+permuteZEst'></span>

<h3>Description</h3>

<p>Compute the permutation of the rows of hat.z that has to be applied to obtain the &quot;same order&quot; as z.
Compute optimal matching between 2 clusterings using Hungarian algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteZEst(z, hat.z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permuteZEst_+3A_z">z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code></p>
</td></tr>
<tr><td><code id="permuteZEst_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>HUBERT, L. &amp; ARABIE, P. (1985). Comparing partitions. J. Classif. 2, 193–218.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>

<hr>
<h2 id='sortIntensities'>Sort intensities</h2><span id='topic+sortIntensities'></span>

<h3>Description</h3>

<p>Sort intensities associated with the estimated clustering <code class="reqn">\hat z</code> &quot;in the same way&quot; as the original intensities associated with true clustering <code class="reqn">z</code> by permutation of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortIntensities(intensities, z, hat.z, directed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortIntensities_+3A_intensities">intensities</code></td>
<td>
<p>Matrix whose rows contain piecewise constant intensities <code class="reqn">\alpha^{(q,l)}</code>, given as a vector of values on a regular partition of the time interval.</p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_z">z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code>.</p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_hat.z">hat.z</code></td>
<td>
<p>Matrix of size  <code class="reqn">Q \times n</code>.</p>
</td></tr>
<tr><td><code id="sortIntensities_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.</p>
</td></tr>
</table>


<h3>References</h3>

<p>HUBERT, L. &amp; ARABIE, P. (1985). Comparing partitions. J. Classif. 2, 193–218.
</p>
<p>MATIAS, C., REBAFKA, T. &amp; VILLERS, F. (2018).  A semiparametric extension of the stochastic block model for longitudinal networks. Biometrika. 105(3): 665-680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># True and estimated clusters for n=6 nodes clustered into Q=3 groups
z &lt;- matrix(c(1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)
hat.z &lt;- matrix(c(0,0,1,1,0,0, 1,1,0,0,0,0, 0,0,0,0,1,1), nrow = 3, byrow = TRUE)

# Set constant intensities for each directed pair (q,l)
intens &lt;- matrix(c(1,1,1,2,2,2,3,3,3),9)

# Permute the rows according to the permutation that "matches" hat.z with z
sortIntensities(intens,z,hat.z, TRUE)

</code></pre>

<hr>
<h2 id='statistics'>Compute statistics</h2><span id='topic+statistics'></span>

<h3>Description</h3>

<p>Convert the initial data into the statistics matrix <code class="reqn">N_{(ij),k}</code>, by counting the number of events for the nodes pair types <code class="reqn">(i,j)</code> during the <code class="reqn">k</code>-th subinterval of a regular partition (in <code class="reqn">K</code> parts) of the time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistics(data, n, K, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statistics_+3A_data">data</code></td>
<td>
<p>List with 3 components <code>$type.seq, $time.seq, $Time</code> (see <a href="#topic+mainVEM">mainVEM</a> for more details).</p>
</td></tr>
<tr><td><code id="statistics_+3A_n">n</code></td>
<td>
<p>Total number of nodes,  <code class="reqn">1\le i \le n</code>.</p>
</td></tr>
<tr><td><code id="statistics_+3A_k">K</code></td>
<td>
<p>Size of the regular partition, i.e. number of subintervals of the time interval. When used as input in the VEM algorithm (with <code>hist</code> method), <code class="reqn">K</code> must be a power of 2.</p>
</td></tr>
<tr><td><code id="statistics_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N[(i,j),k] = matrix with <code class="reqn">K</code> columns, each row contains the number of events for the node pair <code class="reqn">(i,j)</code> during the k-th subinterval
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert the generated data into the statistics matrix N_ijk with 8 subintervals

n &lt;- 50
K &lt;- 2^3

obs &lt;- statistics(generated_Q3$data,n,K,directed=FALSE)

</code></pre>

<hr>
<h2 id='tauDown_Q'>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q+1</code></h2><span id='topic+tauDown_Q'></span>

<h3>Description</h3>

<p>Construct initial <code class="reqn">\tau</code> with <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q+1</code> groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauDown_Q(tau, n_perturb = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauDown_Q_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauDown_Q_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code> for <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q+1</code>
</p>

<hr>
<h2 id='tauInitial'>List of initial values for <code class="reqn">\tau</code></h2><span id='topic+tauInitial'></span>

<h3>Description</h3>

<p>Same function whatever directed or undirected case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauInitial(data, n, Q, d_part, n_perturb, perc_perturb, n_random, directed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauInitial_+3A_data">data</code></td>
<td>
<p>Data : only needs the <code class="reqn">N_{ijk}</code> field of data</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_d_part">d_part</code></td>
<td>
<p>Maximal level for finest partitions of time interval [0,T], used for kmeans initializations.
</p>

<ul>
<li><p> Algorithm takes partition up to depth <code class="reqn">2^d</code> with <code class="reqn">d=1,...,d_{part}</code>
</p>
</li>
<li><p> Explore partitions <code class="reqn">[0,T], [0,T/2], [T/2,T], ... [0,T/2^d], ...[(2^d-1)T/2^d,T]</code>
</p>
</li>
<li><p> Total number of partitions <code class="reqn">npart= 2^{(d_part +1)} - 1</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="tauInitial_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_perc_perturb">perc_perturb</code></td>
<td>
<p>Percentage of labels that are to be perturbed (= randomly switched)</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_n_random">n_random</code></td>
<td>
<p>Number of completely random initial points. If not zero there will be n_random taus uniformly sampled in the initialization.</p>
</td></tr>
<tr><td><code id="tauInitial_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (maximal) total number of initializations is <code class="reqn">d_{part}*(1+n_{perturb}) + n_{random}</code>
</p>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code>
</p>

<hr>
<h2 id='tauKmeansSbm'>k-means for SBM</h2><span id='topic+tauKmeansSbm'></span>

<h3>Description</h3>

<p>k-means for SBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauKmeansSbm(statistics, n, Q, directed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauKmeansSbm_+3A_statistics">statistics</code></td>
<td>
<p>Statistics matrix <code class="reqn">N_{ijk}</code>, counting the events for the nodes pair <code class="reqn">(i,j)</code> during the subinterval <code class="reqn">k</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_n">n</code></td>
<td>
<p>Total number of nodes <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_q">Q</code></td>
<td>
<p>Total number of groups <code class="reqn">Q</code></p>
</td></tr>
<tr><td><code id="tauKmeansSbm_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial values for <code class="reqn">\tau</code>
</p>

<hr>
<h2 id='taurhoInitial'>Sparse setup - <code class="reqn">\rho</code> parameter</h2><span id='topic+taurhoInitial'></span>

<h3>Description</h3>

<p>Sparse setup - <code class="reqn">\rho</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taurhoInitial(tau, data, n, Q, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taurhoInitial_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_data">data</code></td>
<td>
<p>Data : only needs the <code class="reqn">N_{ijk}</code> field of data</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_n">n</code></td>
<td>
<p>Total number of nodes</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_q">Q</code></td>
<td>
<p>Total number of groups</p>
</td></tr>
<tr><td><code id="taurhoInitial_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both <code class="reqn">\tau</code> and <code class="reqn">\rho</code>.
</p>

<hr>
<h2 id='tauUp_Q'>Construct initial <code class="reqn">\tau</code> from <code class="reqn">Q-1</code></h2><span id='topic+tauUp_Q'></span>

<h3>Description</h3>

<p>Construct initial <code class="reqn">\tau</code> with <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q-1</code> groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauUp_Q(tau, n_perturb = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauUp_Q_+3A_tau">tau</code></td>
<td>
<p><code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauUp_Q_+3A_n_perturb">n_perturb</code></td>
<td>
<p>Number of different perturbations on k-means result</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrixes of initial values for <code class="reqn">\tau</code> for <code class="reqn">Q</code> groups from value obtained at <code class="reqn">Q-1</code>
</p>

<hr>
<h2 id='tauUpdate'>Update <code class="reqn">\tau</code></h2><span id='topic+tauUpdate'></span>

<h3>Description</h3>

<p>One update of <code class="reqn">\tau</code> by the fixed point equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauUpdate(tau, pi, mstep, data, directed, sparse, method, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauUpdate_+3A_tau">tau</code></td>
<td>
<p>Old <code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_pi">pi</code></td>
<td>
<p>Estimator of group probabilities <code class="reqn">\pi</code></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_method">method</code></td>
<td>
<p>List of string. Can be <code>hist</code> for histogram method or <code>kernel</code> for kernel method</p>
</td></tr>
<tr><td><code id="tauUpdate_+3A_rho">rho</code></td>
<td>
<p>Old <code class="reqn">\rho</code> (only for <code>sparse</code> model, set to 1 otherwise)</p>
</td></tr>
</table>

<hr>
<h2 id='VEstep'>VE step</h2><span id='topic+VEstep'></span>

<h3>Description</h3>

<p>VE step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VEstep(VE, mstep, directed, sparse, method, epsilon, fix.iter, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VEstep_+3A_ve">VE</code></td>
<td>
<p>Results of the previous VE step for iterative computation</p>
</td></tr>
<tr><td><code id="VEstep_+3A_mstep">mstep</code></td>
<td>
<p>Results of the previous mstep for iterative computation</p>
</td></tr>
<tr><td><code id="VEstep_+3A_directed">directed</code></td>
<td>
<p>Boolean for directed (TRUE) or undirected (FALSE) case</p>
</td></tr>
<tr><td><code id="VEstep_+3A_sparse">sparse</code></td>
<td>
<p>Boolean for sparse (TRUE) or not sparse (FALSE) case</p>
</td></tr>
<tr><td><code id="VEstep_+3A_method">method</code></td>
<td>
<p>List of string. Can be &quot;hist&quot; for histogram method or &quot;kernel&quot; for kernel method</p>
</td></tr>
<tr><td><code id="VEstep_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for the stopping criterion of VEM and fixed point iterations</p>
</td></tr>
<tr><td><code id="VEstep_+3A_fix.iter">fix.iter</code></td>
<td>
<p>Maximum number of iterations of the fixed point</p>
</td></tr>
<tr><td><code id="VEstep_+3A_data">data</code></td>
<td>
<p>Data same of <a href="#topic+mainVEM">mainVEM</a></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
