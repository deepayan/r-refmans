<!DOCTYPE html><html><head><title>Help for package purrrlyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {purrrlyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#by_row'><p>Apply a function to each row of a data frame</p></a></li>
<li><a href='#by_slice'><p>Apply a function to slices of a data frame</p></a></li>
<li><a href='#dmap'><p>Map over the columns of a data frame</p></a></li>
<li><a href='#slice_rows'><p>Slice a data frame into groups of rows</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools at the Intersection of 'purrr' and 'dplyr'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Some functions at the intersection of 'dplyr' and
    'purrr' that formerly lived in 'purrr'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hadley/purrrlyr">https://github.com/hadley/purrrlyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hadley/purrrlyr/issues">https://github.com/hadley/purrrlyr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.0), magrittr (&ge; 1.5), purrr (&ge; 0.2.2), Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-29 09:51:57 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Lionel Henry [aut, cre],
  Hadley Wickham [ctb],
  RStudio [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Henry &lt;lionel@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-29 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='by_row'>Apply a function to each row of a data frame</h2><span id='topic+by_row'></span><span id='topic+invoke_rows'></span><span id='topic+map_rows'></span>

<h3>Description</h3>

<p><code>by_row()</code> and <code>invoke_rows()</code> apply <code>..f</code> to each row
of <code>.d</code>. If <code>..f</code>'s output is not a data frame nor an
atomic vector, a list-column is created. In all cases,
<code>by_row()</code> and <code>invoke_rows()</code> create a data frame in tidy
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_row(
  .d,
  ..f,
  ...,
  .collate = c("list", "rows", "cols"),
  .to = ".out",
  .labels = TRUE
)

invoke_rows(
  .f,
  .d,
  ...,
  .collate = c("list", "rows", "cols"),
  .to = ".out",
  .labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_row_+3A_.d">.d</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="by_row_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>..f</code>.</p>
</td></tr>
<tr><td><code id="by_row_+3A_.collate">.collate</code></td>
<td>
<p>If &quot;list&quot;, the results are returned as a list-
column. Alternatively, if the results are data frames or atomic
vectors, you can collate on &quot;cols&quot; or on &quot;rows&quot;. Column collation
require vector of equal length or data frames with same number of
rows.</p>
</td></tr>
<tr><td><code id="by_row_+3A_.to">.to</code></td>
<td>
<p>Name of output column.</p>
</td></tr>
<tr><td><code id="by_row_+3A_.labels">.labels</code></td>
<td>
<p>If <code>TRUE</code>, the returned data frame is prepended
with the labels of the slices (the columns in <code>.d</code> used to
define the slices). They are recycled to match the output size in
each slice if necessary.</p>
</td></tr>
<tr><td><code id="by_row_+3A_.f">.f</code>, <code id="by_row_+3A_..f">..f</code></td>
<td>
<p>A function to apply to each row. If <code>..f</code> does
not return a data frame or an atomic vector, a list-column is
created under the name <code>.out</code>. If it returns a data frame, it
should have the same number of rows within groups and the same
number of columns between groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the whole row is appended to the result to serve as
identifier (set <code>.labels</code> to <code>FALSE</code> to prevent this). In
addition, if <code>..f</code> returns a multi-rows data frame or a
non-scalar atomic vector, a <code>.row</code> column is appended to
identify the row number in the original data frame.
</p>
<p><code>invoke_rows()</code> is intended to provide a version of
<code>pmap()</code> for data frames. Its default collation method is
<code>"cols"</code>, which makes it equivalent to
<code>mdply()</code> from the plyr package. Note that
<code>invoke_rows()</code> follows the signature pattern of the
<code>invoke</code> family of functions and takes <code>.f</code> as its first
argument.
</p>
<p>The distinction between <code>by_row()</code> and <code>invoke_rows()</code> is
that the former passes a data frame to <code>..f</code> while the latter
maps the columns to its function call. This is essentially like
using <code><a href="purrr.html#topic+invoke">invoke()</a></code> with each row. Another way to view
this is that <code>invoke_rows()</code> is equivalent to using
<code>by_row()</code> with a function lifted to accept dots (see
<code><a href="purrr.html#topic+lift">lift()</a></code>).
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by_slice">by_slice()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ..f should be able to work with a list or a data frame. As it
# happens, sum() handles data frame so the following works:
mtcars %&gt;% by_row(sum)

# Other functions such as mean() may need to be adjusted with one
# of the lift_xy() helpers:
mtcars %&gt;% by_row(purrr::lift_vl(mean))

# To run a function with invoke_rows(), make sure it is variadic (that
# it accepts dots) or that .f's signature is compatible with the
# column names
mtcars %&gt;% invoke_rows(.f = sum)
mtcars %&gt;% invoke_rows(.f = purrr::lift_vd(mean))

# invoke_rows() with cols collation is equivalent to plyr::mdply()
p &lt;- expand.grid(mean = 1:5, sd = seq(0, 1, length = 10))
p %&gt;% invoke_rows(.f = rnorm, n = 5, .collate = "cols")
## Not run: 
p %&gt;% plyr::mdply(rnorm, n = 5) %&gt;% dplyr::tbl_df()

## End(Not run)

# To integrate the result as part of the data frame, use rows or
# cols collation:
mtcars[1:2] %&gt;% by_row(function(x) 1:5)
mtcars[1:2] %&gt;% by_row(function(x) 1:5, .collate = "rows")
mtcars[1:2] %&gt;% by_row(function(x) 1:5, .collate = "cols")
</code></pre>

<hr>
<h2 id='by_slice'>Apply a function to slices of a data frame</h2><span id='topic+by_slice'></span>

<h3>Description</h3>

<p><code>by_slice()</code> applies <code>..f</code> on each group of a data
frame. Groups should be set with <code>slice_rows()</code> or
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_slice(
  .d,
  ..f,
  ...,
  .collate = c("list", "rows", "cols"),
  .to = ".out",
  .labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_slice_+3A_.d">.d</code></td>
<td>
<p>A sliced data frame.</p>
</td></tr>
<tr><td><code id="by_slice_+3A_..f">..f</code></td>
<td>
<p>A function to apply to each slice. If <code>..f</code> does
not return a data frame or an atomic vector, a list-column is
created under the name <code>.out</code>. If it returns a data frame, it
should have the same number of rows within groups and the same
number of columns between groups.</p>
</td></tr>
<tr><td><code id="by_slice_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>..f</code>.</p>
</td></tr>
<tr><td><code id="by_slice_+3A_.collate">.collate</code></td>
<td>
<p>If &quot;list&quot;, the results are returned as a list-
column. Alternatively, if the results are data frames or atomic
vectors, you can collate on &quot;cols&quot; or on &quot;rows&quot;. Column collation
require vector of equal length or data frames with same number of
rows.</p>
</td></tr>
<tr><td><code id="by_slice_+3A_.to">.to</code></td>
<td>
<p>Name of output column.</p>
</td></tr>
<tr><td><code id="by_slice_+3A_.labels">.labels</code></td>
<td>
<p>If <code>TRUE</code>, the returned data frame is prepended
with the labels of the slices (the columns in <code>.d</code> used to
define the slices). They are recycled to match the output size in
each slice if necessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>by_slice()</code> provides equivalent functionality to dplyr's
<code><a href="dplyr.html#topic+do">dplyr::do()</a></code> function. In combination with
<code>map()</code>, <code>by_slice()</code> is equivalent to
<code><a href="dplyr.html#topic+summarise_each">dplyr::summarise_each()</a></code> and
<code><a href="dplyr.html#topic+summarise_each">dplyr::mutate_each()</a></code>. The distinction between
mutating and summarising operations is not as important as in dplyr
because we do not act on the columns separately. The only
constraint is that the mapped function must return the same number
of rows for each variable mapped on.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by_row">by_row()</a></code>, <code><a href="#topic+slice_rows">slice_rows()</a></code>,
<code><a href="#topic+dmap">dmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here we fit a regression model inside each slice defined by the
# unique values of the column "cyl". The fitted models are returned
# in a list-column.
mtcars %&gt;%
  slice_rows("cyl") %&gt;%
  by_slice(purrr::partial(lm, mpg ~ disp))

# by_slice() is especially useful in combination with map().

# To modify the contents of a data frame, use rows collation. Note
# that unlike dplyr, Mutating and summarising operations can be
# used indistinctly.

# Mutating operation:
df &lt;- mtcars %&gt;% slice_rows(c("cyl", "am"))
df %&gt;% by_slice(dmap, ~ .x / sum(.x), .collate = "rows")

# Summarising operation:
df %&gt;% by_slice(dmap, mean, .collate = "rows")

# Note that mapping columns within slices is best handled by dmap():
df %&gt;% dmap(~ .x / sum(.x))
df %&gt;% dmap(mean)

# If you don't need the slicing variables as identifiers, switch
# .labels to FALSE:
mtcars %&gt;%
  slice_rows("cyl") %&gt;%
  by_slice(purrr::partial(lm, mpg ~ disp), .labels = FALSE) %&gt;%
  purrr::flatten() %&gt;%
  purrr::map(coef)
</code></pre>

<hr>
<h2 id='dmap'>Map over the columns of a data frame</h2><span id='topic+dmap'></span><span id='topic+dmap_at'></span><span id='topic+dmap_if'></span>

<h3>Description</h3>

<p><code>dmap()</code> is just like <code><a href="purrr.html#topic+map">purrr::map()</a></code> but always returns a
data frame. In addition, it handles grouped or sliced data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmap(.d, .f, ...)

dmap_at(.d, .at, .f, ...)

dmap_if(.d, .p, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmap_+3A_.d">.d</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="dmap_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="dmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td></tr>
<tr><td><code id="dmap_+3A_.at">.at</code></td>
<td>
<p>A character vector of names, positive numeric vector of
positions to include, or a negative numeric vector of positions to
exlude. Only those elements corresponding to <code>.at</code> will be modified.
If the <code>tidyselect</code> package is installed, you can use <code>vars()</code> and
the <code>tidyselect</code> helpers to select elements.</p>
</td></tr>
<tr><td><code id="dmap_+3A_.p">.p</code></td>
<td>
<p>A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as <code>.x</code>.
Alternatively, if the elements of <code>.x</code> are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where <code>.p</code> evaluates to
<code>TRUE</code> will be modified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmap_at()</code> and <code>dmap_if()</code> recycle length 1 vectors to
the group sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dmap() always returns a data frame:
dmap(mtcars, summary)

# dmap() also supports sliced data frames:
sliced_df &lt;- mtcars[1:5] %&gt;% slice_rows("cyl")
sliced_df %&gt;% dmap(mean)
sliced_df %&gt;% dmap(~ .x / max(.x))

# This is equivalent to the combination of by_slice() and dmap()
# with 'rows' collation of results:
sliced_df %&gt;% by_slice(dmap, mean, .collate = "rows")
</code></pre>

<hr>
<h2 id='slice_rows'>Slice a data frame into groups of rows</h2><span id='topic+slice_rows'></span><span id='topic+unslice'></span>

<h3>Description</h3>

<p><code>slice_rows()</code> is equivalent to dplyr's
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> command but it takes a vector of
column names or positions instead of capturing column names with
special evaluation. <code>unslice()</code> removes the slicing
attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_rows(.d, .cols = NULL)

unslice(.d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_rows_+3A_.d">.d</code></td>
<td>
<p>A data frame to slice or unslice.</p>
</td></tr>
<tr><td><code id="slice_rows_+3A_.cols">.cols</code></td>
<td>
<p>A character vector of column names or a numeric vector
of column positions. If <code>NULL</code>, the slicing attributes are
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sliced or unsliced data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+by_slice">by_slice()</a></code> and <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
