<!DOCTYPE html><html><head><title>Help for package RSAGA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSAGA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#centervalue'><p>Pick Center Value from Matrix</p></a></li>
<li><a href='#create.variable.name'><p>Convert file name to variable name</p></a></li>
<li><a href='#focal.function'><p>Local and Focal Grid Functions</p></a></li>
<li><a href='#grid.predict'><p>Helper function for applying predict methods to stacks of grids.</p></a></li>
<li><a href='#grid.to.xyz'><p>Convert Grid Matrix to (x,y,z) data.frame</p></a></li>
<li><a href='#landslides'><p>Landslide inventory, study area mask and DEM</p></a></li>
<li><a href='#match.arg.ext'><p>Extended Argument Matching</p></a></li>
<li><a href='#multi.focal.function'><p>Local and Focal Grid Function with Multiple Grids as Inputs</p></a></li>
<li><a href='#pick.from.points'><p>Pick Variable from Spatial Dataset</p></a></li>
<li><a href='#read.ascii.grid'><p>Read/write ASCII, SAGA and Rd Grid Files</p></a></li>
<li><a href='#relative.position'><p>Relative Topographic Position</p></a></li>
<li><a href='#resid.median'><p>Residual Median and Quantile Filters for Grids</p></a></li>
<li><a href='#RSAGA-package'><p>RSAGA: SAGA Geoprocessing and Terrain Analysis in R</p></a></li>
<li><a href='#rsaga.add.grid.values.to.points'><p>Add Grid Values to Point Shapefile</p></a></li>
<li><a href='#rsaga.close.gaps'><p>SAGA Modules Close Gaps and Close One Cell Gaps</p></a></li>
<li><a href='#rsaga.contour'><p>Contour Lines from a Grid</p></a></li>
<li><a href='#rsaga.copy.sgrd'><p>Create a copy of a SAGA grid file</p></a></li>
<li><a href='#rsaga.env'><p>Function to set up RSAGA geoprocessing environment:</p>
Set up the RSAGA Geoprocessing Environment</a></li>
<li><a href='#rsaga.esri.to.sgrd'><p>Convert ESRI ASCII/binary grids to SAGA grids</p></a></li>
<li><a href='#rsaga.esri.wrapper'><p>Use RSAGA functions for ESRI grids</p></a></li>
<li><a href='#rsaga.fill.sinks'><p>Fill Sinks</p></a></li>
<li><a href='#rsaga.filter.gauss'><p>Gauss Filter</p></a></li>
<li><a href='#rsaga.filter.simple'><p>Simple Filters</p></a></li>
<li><a href='#rsaga.geoprocessor'><p>Generic R interface for SAGA modules</p></a></li>
<li><a href='#rsaga.get.modules'><p>Find SAGA libraries and modules</p></a></li>
<li><a href='#rsaga.get.modules.path'><p>Internal functions that determine OS-specific path in which modules might be located.</p></a></li>
<li><a href='#rsaga.get.usage'><p>Usage of SAGA command line modules</p></a></li>
<li><a href='#rsaga.get.version'><p>Determine SAGA GIS version</p></a></li>
<li><a href='#rsaga.grid.calculus'><p>SAGA Module Grid Calculus</p></a></li>
<li><a href='#rsaga.grid.to.points'><p>Convert SAGA grid file to point shapefile</p></a></li>
<li><a href='#rsaga.hillshade'><p>Analytical hillshading</p>
Analytical hillshading calculation.</a></li>
<li><a href='#rsaga.html.help'><p>HTML help on a SAGA module or library</p></a></li>
<li><a href='#rsaga.import.gdal'><p>Import Grid Files to SAGA grid format using GDAL</p></a></li>
<li><a href='#rsaga.insolation'><p>Incoming Solar Radiation (Insolation)</p></a></li>
<li><a href='#rsaga.intersect.polygons'><p>Spatial intersection of two polygon layers</p></a></li>
<li><a href='#rsaga.inverse.distance'><p>Spatial Interpolation Methods</p></a></li>
<li><a href='#rsaga.lib.prefix'><p>Determine prefix for SAGA GIS library names</p></a></li>
<li><a href='#rsaga.local.morphometry'><p>Local Morphometry</p></a></li>
<li><a href='#rsaga.parallel.processing'><p>Parallel Processing</p></a></li>
<li><a href='#rsaga.pisr'><p>Potential incoming solar radiation</p></a></li>
<li><a href='#rsaga.pisr2'><p>Potential incoming solar radiation SAGA 2.2.2+</p></a></li>
<li><a href='#rsaga.set.env'><p>Internal function that sets the RSAGA Geoprocessing Evironment manually</p></a></li>
<li><a href='#rsaga.sgrd.to.esri'><p>Convert SAGA grids to ESRI ASCII/binary grids</p></a></li>
<li><a href='#rsaga.sink.removal'><p>Sink Removal</p>
Remove sinks from a digital elevation model by deepening drainage routes or filling sinks.</a></li>
<li><a href='#rsaga.sink.route'><p>Sink Drainage Route Detection</p></a></li>
<li><a href='#rsaga.slope.asp.curv'><p>Slope, Aspect, Curvature</p></a></li>
<li><a href='#rsaga.solar.radiation'><p>Potential incoming solar radiation</p></a></li>
<li><a href='#rsaga.target'><p>Define target grid for interpolation</p></a></li>
<li><a href='#rsaga.topdown.processing'><p>Top-Down Processing</p></a></li>
<li><a href='#rsaga.union.polygons'><p>Spatial union of two polygon layers</p></a></li>
<li><a href='#rsaga.wetness.index'><p>SAGA Modules SAGA Wetness Index</p></a></li>
<li><a href='#set.file.extension'><p>Determine or modify file name extensions</p></a></li>
<li><a href='#wind.shelter'><p>Wind Shelter Index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>SAGA Geoprocessing and Terrain Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides access to geocomputing and terrain analysis functions
    of the geographical information system (GIS) 'SAGA' (System for Automated
    Geoscientific Analyses) from within R by running the command line version of
    SAGA. This package furthermore provides several R functions for handling ASCII
    grids, including a flexible framework for applying local functions (including
    predict methods of fitted models) and focal functions to multiple grids. SAGA
    GIS is available under GPL-2 / LGPL-2 licences from 
    <a href="https://sourceforge.net/projects/saga-gis/">https://sourceforge.net/projects/saga-gis/</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-spatial/RSAGA">https://github.com/r-spatial/RSAGA</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>SAGA GIS (2.3 LTS - 8.4.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), gstat, shapefiles, plyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, stringr, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf, sp, knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'gridtools.R' 'RSAGA-core.R' 'RSAGA-modules.R' 'RSAGA-utils.R'
'RSAGA-package.R' 'landslides.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-09 14:42:12 UTC; yo54pow</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Brenning
    <a href="https://orcid.org/0000-0001-6640-679X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Donovan Bangs [aut],
  Marc Becker [aut],
  Patrick Schratz <a href="https://orcid.org/0000-0003-0748-6624"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Fabian Polakowski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Brenning &lt;alexander.brenning@uni-jena.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-09 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='centervalue'>Pick Center Value from Matrix</h2><span id='topic+centervalue'></span>

<h3>Description</h3>

<p>Pick the value in the center of a square matrix. Auxiliary function to be used by functions called by <code><a href="#topic+focal.function">focal.function()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centervalue(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centervalue_+3A_x">x</code></td>
<td>
<p>a square matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See for example the code of <code><a href="#topic+resid.median">resid.median()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="#topic+resid.median">resid.median()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( m &lt;- matrix( round(runif(9,1,10)), ncol=3 ) )
centervalue(m)
</code></pre>

<hr>
<h2 id='create.variable.name'>Convert file name to variable name</h2><span id='topic+create.variable.name'></span>

<h3>Description</h3>

<p>Convert a file name into a variable name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.variable.name(filename, prefix = NULL, fsep = .Platform$file.sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.variable.name_+3A_filename">filename</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="create.variable.name_+3A_prefix">prefix</code></td>
<td>
<p>character string: optional prefix to be added</p>
</td></tr>
<tr><td><code id="create.variable.name_+3A_fsep">fsep</code></td>
<td>
<p>character used to separate path components</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
create.variable.name("C:/my-path/my-file-name.Rd",prefix="res")

## End(Not run)
</code></pre>

<hr>
<h2 id='focal.function'>Local and Focal Grid Functions</h2><span id='topic+focal.function'></span><span id='topic+gapply'></span><span id='topic+local.function'></span>

<h3>Description</h3>

<p><code>focal.function</code> cuts out square or circular moving windows from a grid (matrix) and applies a user-defined matrix function to calculate e.g. a terrain attribute or filter the grid. The function is suitable for large grid files as it can process them row by row. <code>local.function</code> represents the special case of a moving window of radius 1. Users can define their own functions operating on moving windows, or use simple functions such as <code>median</code> to define filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal.function(
  in.grid,
  in.factor.grid,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  varnames,
  radius = 0,
  is.pixel.radius = TRUE,
  na.strings = "NA",
  valid.range = c(-Inf, Inf),
  nodata.values = c(),
  out.nodata.value,
  search.mode = c("circle", "square"),
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  mw.to.vector = FALSE,
  mw.na.rm = FALSE,
  ...
)

gapply(in.grid, fun, varnames, mw.to.vector = TRUE, mw.na.rm = TRUE, ...)

local.function(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal.function_+3A_in.grid">in.grid</code></td>
<td>
<p>file name of input ASCII grid, relative to <code>in.path</code></p>
</td></tr>
<tr><td><code id="focal.function_+3A_in.factor.grid">in.factor.grid</code></td>
<td>
<p>optional file name giving a gridded categorical variables defining zones; zone boundaries are used as breaklines for the moving window (see Details)</p>
</td></tr>
<tr><td><code id="focal.function_+3A_out.grid.prefix">out.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the output file names; a dash (<code>-</code>) will separate the prefix and the <code>varnames</code></p>
</td></tr>
<tr><td><code id="focal.function_+3A_path">path</code></td>
<td>
<p>path in which to look for <code>in.grid</code> and write output grid files; see also <code>in.path</code> and <code>out.path</code>, which overwrite <code>path</code> if they are specified</p>
</td></tr>
<tr><td><code id="focal.function_+3A_in.path">in.path</code></td>
<td>
<p>path in which to look for <code>in.grid</code> (defaults to <code>path</code>)</p>
</td></tr>
<tr><td><code id="focal.function_+3A_out.path">out.path</code></td>
<td>
<p>path in which to write output grid files; defaults to <code>path</code></p>
</td></tr>
<tr><td><code id="focal.function_+3A_fun">fun</code></td>
<td>
<p>a function, or name of a function, to be applied on the moving window; see Details</p>
</td></tr>
<tr><td><code id="focal.function_+3A_varnames">varnames</code></td>
<td>
<p>character vector specifying the names of the variable(s) returned by <code>fun</code>; if missing, <code>focal.function</code> will try to determine the varnames from <code>fun</code> itself, or from a call to <code>fun</code> if this is a function (see Details)</p>
</td></tr>
<tr><td><code id="focal.function_+3A_radius">radius</code></td>
<td>
<p>numeric value specifying the (circular or square) radius  of the moving window; see <code>is.pixel.radius</code> and <code>search.mode</code>; note that all data within distance <code style="white-space: pre;">&#8288;&lt;=radius&#8288;</code> will be included in the moving window, not <code style="white-space: pre;">&#8288;&lt;radius&#8288;</code>.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_is.pixel.radius">is.pixel.radius</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), the <code>radius</code> will be interpreted as a (possibly non-integer) number of pixels; if <code>FALSE</code>, it is interpreted as a radius measured in the grid (map) units.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_na.strings">na.strings</code></td>
<td>
<p>passed on to <code><a href="base.html#topic+scan">scan()</a></code></p>
</td></tr>
<tr><td><code id="focal.function_+3A_valid.range">valid.range</code></td>
<td>
<p>numeric vector of length 2, specifying minimum and maximum valid values read from input file; all values <code style="white-space: pre;">&#8288;&lt;valid.range[1]&#8288;</code> or <code style="white-space: pre;">&#8288;&gt;valid.range[1]&#8288;</code> will be converted to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_nodata.values">nodata.values</code></td>
<td>
<p>numeric vector: any values from the input grid file that should be converted to <code>NA</code>, in addition to the nodata value specified in the grid header</p>
</td></tr>
<tr><td><code id="focal.function_+3A_out.nodata.value">out.nodata.value</code></td>
<td>
<p>numeric: value used for storing <code>NA</code>s in the output file(s); if missing, use the same nodata value as specified in the header of the input grid file</p>
</td></tr>
<tr><td><code id="focal.function_+3A_search.mode">search.mode</code></td>
<td>
<p>character, either <code>"circle"</code> (default) for a circular search window, or <code>"square"</code> for a squared one.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_digits">digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for output grid file.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_hdr.digits">hdr.digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for the header of the output grid file (default: 10; see <code><a href="#topic+write.ascii.grid.header">write.ascii.grid.header()</a></code>).</p>
</td></tr>
<tr><td><code id="focal.function_+3A_dec">dec</code></td>
<td>
<p>character, specifying the decimal mark to be used for input and output.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, gives some output (<code>"*"</code>) after every 10th line of the grid file and when the job is done.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_nlines">nlines</code></td>
<td>
<p>Number of lines to be processed; useful for testing purposes.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_mw.to.vector">mw.to.vector</code></td>
<td>
<p>logical: Should the content of the moving window be coerced (from a matrix) to a vector?</p>
</td></tr>
<tr><td><code id="focal.function_+3A_mw.na.rm">mw.na.rm</code></td>
<td>
<p>logical: Should <code>NA</code>s be removed from moving window prior to passing the data to <code>fun</code>? Only applicable when <code>mw.to.vector=TRUE</code>.</p>
</td></tr>
<tr><td><code id="focal.function_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>fun</code>; <code>local.function</code>: arguments to be passed to  <code>focal.function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>focal.function</code> passes a square matrix of size <code>2*radius+1</code> to the function <code>fun</code> if <code>mw.to.vector=FALSE</code> (default), or a vector of length <code style="white-space: pre;">&#8288;&lt;=(2*radius+1)^2&#8288;</code> if <code>mw.to.vector=TRUE</code>. This matrix or vector will contain the content of the moving window, which may possibly contain <code>NA</code>s even if the <code>in.grid</code> has no nodata values, e.g. due to edge effects. If <code>search.mode="circle"</code>, values more than <code>radius</code> units (pixels or grid units, depending on <code>is.pixel.radius</code>) away from the center pixel / matrix entry will be set to <code>NA</code>. In addition, <code>valid.range</code>, <code>nodata.values</code>, and the nodata values specified in the <code>in.grid</code> are checked to assign further <code>NA</code>s to pixels in the moving window. Finally, if <code>in.factor.grid</code> specifies zones, all pixels in the moving window that belong to a different zone than the center pixel are set to <code>NA</code>, or, in other words, zone boundaries are used as breaklines.
</p>
<p>The function <code>fun</code> should return a single numeric value or a numeric vector. As an example, the function <code><a href="#topic+resid.minmedmax">resid.minmedmax()</a></code> returns the minimum, median and maximum of the difference between the values in the moving window and the value in the center grid cell. In addition to the (first) argument receiving the moving window data, <code>fun</code> may have additional arguments; the <code>...</code> argument of <code>focal.function</code> is passed on to <code>fun</code>. <code><a href="#topic+resid.quantile">resid.quantile()</a></code> is a function that uses this feature.
</p>
<p>Optionally, <code>fun</code> should support the following feature: If no argument is passed to it, then it should return a character vector giving variable names to be used for naming the output grids. The call <code><a href="#topic+resid.minmedmax">resid.minmedmax()</a></code>, for example, returns <code>c("rmin","rmed","rmax")</code>; this vector must have the same length as the numeric vector returned when moving window data is passed to the function. This feature is only used if no <code>varnames</code> argument is provided. Note that the result is currently being <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>d to a length of 6 characters.
</p>
<p>Input and output file names are built according to the following schemes:
</p>
<p>Input:   <code style="white-space: pre;">&#8288;[&lt;in.path&gt;/]&lt;in.grid&gt;&#8288;</code>
</p>
<p>Zones:   <code style="white-space: pre;">&#8288;[&lt;in.path&gt;/]&lt;in.factor.grid&gt;&#8288;</code> (if specified)
</p>
<p>Output:  <code style="white-space: pre;">&#8288;[&lt;out.path&gt;/][&lt;out.grid.prefix&gt;-]&lt;varnames&gt;.asc&#8288;</code>
</p>
<p>For the input files, <code>.asc</code> is used as the default file extension, if it is not specified by the user.
</p>


<h3>Value</h3>

<p><code>focal.function</code> and <code>local.function</code> return the character vector of output file names.
</p>


<h3>Note</h3>

<p>These functions are not very efficient ways of calculating e.g. (focal) terrain attributes compared to for example the SAGA modules, but the idea is that you can easily specify your own functions without starting to mess around with C code. For example try implementing a median filter as a SAGA module... or just use the code shown in the example!
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models.  In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi.focal.function">multi.focal.function()</a></code>, <code><a href="#topic+multi.local.function">multi.local.function()</a></code>, <code><a href="#topic+resid.median">resid.median()</a></code>, <code><a href="#topic+resid.minmedmax">resid.minmedmax()</a></code>, <code><a href="#topic+relative.position">relative.position()</a></code>, <code><a href="#topic+resid.quantile">resid.quantile()</a></code>, <code><a href="#topic+resid.quartiles">resid.quartiles()</a></code>, <code><a href="#topic+relative.rank">relative.rank()</a></code>,  <code><a href="#topic+wind.shelter">wind.shelter()</a></code>, <code><a href="#topic+create.variable.name">create.variable.name()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A simple median filter applied to dem.asc:
gapply("dem","median",radius=3)
# Same:
#focal.function("dem",fun="median",radius=3,mw.to.vector=TRUE,mw.na.rm=TRUE)
# See how the filter has changed the elevation data:
d1 = as.vector(read.ascii.grid("dem")$data)
d2 = as.vector(read.ascii.grid("median")$data)
hist(d1-d2,br=50)

## End(Not run)
# Wind shelter index used by Plattner et al. (2004):
## Not run: 
ctrl = wind.shelter.prep(6,-pi/4,pi/12,10)
focal.function("dem",fun=wind.shelter,control=ctrl,
    radius=6,search.mode="circle")

## End(Not run)
# Or how about this, if "aspect" is local terrain exposure:
## Not run: 
gapply("aspect","cos") # how "northerly-exposed" is a pixel?
gapply("aspect","sin") # how "easterly-exposed" is a pixel?
# Same result, but faster:
focal.function("aspect",fun=function(x) c(cos(x),sin(x)), varnames=c("cos","sin"))

## End(Not run)
</code></pre>

<hr>
<h2 id='grid.predict'>Helper function for applying predict methods to stacks of grids.</h2><span id='topic+grid.predict'></span>

<h3>Description</h3>

<p>This function can be used to apply the predict method of hopefully any fitted predictive model pixel by pixel to a stack of grids representing the explanatory variables. It is intended to be called primarily by <code><a href="#topic+multi.local.function">multi.local.function()</a></code> or <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.predict(
  fit,
  predfun,
  trafo,
  control.predict,
  predict.column,
  trace = 0,
  location,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.predict_+3A_fit">fit</code></td>
<td>
<p>a model object for which prediction is desired</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_predfun">predfun</code></td>
<td>
<p>optional prediction function; if missing, the <code>fit</code>'s <code><a href="stats.html#topic+predict">predict()</a></code> method is called. In some cases it may be convenient to define a wrapper function for the predict method that may be passed as <code>predfun</code> argument.</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_trafo">trafo</code></td>
<td>
<p>an optional <code style="white-space: pre;">&#8288;function(x)&#8288;</code> that takes a <code>data.frame</code> <code>x</code> and returns a <code>data.frame</code> with the same number of rows; this is intended to perform transformations on the input variables, e.g. derive a log-transformed variable from the raw input read from the grids, or more complex variables such as the NDVI etc.; the <code>data.frame</code> resulting from a call to <code>trafo</code> (if provided) is passed to <code>predfun</code></p>
</td></tr>
<tr><td><code id="grid.predict_+3A_control.predict">control.predict</code></td>
<td>
<p>an optional list of arguments to be passed on to <code>predfun</code>; this may be e.g. <code>type="response"</code> to obtain probability prediction maps from a logistic regression model</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_predict.column">predict.column</code></td>
<td>
<p>optional character string: Some predict methods (e.g. <code>predict.lda</code>) return a data.frame with several columns, e.g. one column per class in a classification problem. <code>predict.column</code> is used to pick the one that is of interest</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_trace">trace</code></td>
<td>
<p>integer &gt;=0: positive values give more (=2) or less (=1) information on predictor variables and predictions</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_location">location</code></td>
<td>
<p>optional location data received from <code>multi.focal.function</code>; is added to the <code>newdata</code> object that is passed on to <code>predfun</code>.</p>
</td></tr>
<tr><td><code id="grid.predict_+3A_...">...</code></td>
<td>
<p>these arguments are provided by the calling function, usually <code><a href="#topic+multi.local.function">multi.local.function()</a></code> or <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code>.  They contain the explanatory (predictor) variables required by the <code>fit</code> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grid.predict</code> is a simple wrapper function. First it binds the arguments in <code style="white-space: pre;">&#8288;\dots&#8288;</code> together in a <code>data.frame</code> with the raw predictor variables that have been read from their grids by the caller, <code><a href="#topic+multi.local.function">multi.local.function()</a></code> (or <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code>). Then it calls the optional <code>trafo</code> function to transform or combine predictor variables (e.g. perform log transformations, ratioing, arithmetic operations such as calculating the NDVI). Finally the <code>predfun</code> (or, typically, the default <code><a href="stats.html#topic+predict">predict()</a></code> method of <code>fit</code>) is called, handing over the <code>fit</code>, the predictor <code>data.frame</code>, and the optional <code>control.predict</code> arguments.
</p>


<h3>Value</h3>

<p><code>grid.predict</code> returns the result of the call to <code>predfun</code> or the default <code><a href="stats.html#topic+predict">predict()</a></code> method.
</p>


<h3>Note</h3>

<p>Though <code>grid.predict</code> can in principle deal with <code>predict</code> methods returning factor variables, its usual caller <code><a href="#topic+multi.local.function">multi.local.function()</a></code> / <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code> cannot; classification models should be dealt with by setting a <code>type="prob"</code> (for <code>rpart</code>) or <code>type="response"</code> (for logistic regression and logistic additive model) argument, for example (see second Example below).
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models. In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="#topic+multi.local.function">multi.local.function()</a></code>, <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assume that d is a data.frame with point observations
# of a numerical response variable y and predictor variables
# a, b, and c.
# Fit a generalized additive model to y,a,b,c.
# We want to model b and c as nonlinear terms:
require(gam)
fit &lt;- gam(y ~ a + s(b) + s(c), data = d)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit )
    # Note that the 'grid.predict' uses by default the
    # predict method of 'fit'.
# Model predictions are written to a file named pred.asc

## End(Not run)

## Not run: 
# A fake example of a logistic additive model:
require(gam)
fit &lt;- gam(cl ~ a + s(b) + s(c), data = d, family = binomial)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit,
    control.predict = list(type = "response") )
    # 'control.predict' is passed on to 'grid.predict', which
    # dumps its contents into the arguments for 'fit''s
    # 'predict' method.
# Model predictions are written to a file named pred.asc

## End(Not run)
</code></pre>

<hr>
<h2 id='grid.to.xyz'>Convert Grid Matrix to (x,y,z) data.frame</h2><span id='topic+grid.to.xyz'></span>

<h3>Description</h3>

<p>Convert a grid matrix to a (x,y,z) data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.to.xyz(data, header, varname = "z", colnames = c("x", "y", varname))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.to.xyz_+3A_data">data</code></td>
<td>
<p>grid data: either a grid data matrix, or a list with components <code>data</code> (a matrix with the grid data) and <code>header</code> (the grid header information); see <code><a href="#topic+read.ascii.grid">read.ascii.grid()</a></code> for details</p>
</td></tr>
<tr><td><code id="grid.to.xyz_+3A_header">header</code></td>
<td>
<p>optional list giving grid header information; see <code><a href="#topic+read.ascii.grid">read.ascii.grid()</a></code> for details</p>
</td></tr>
<tr><td><code id="grid.to.xyz_+3A_varname">varname</code></td>
<td>
<p>character: name to be assigned to the column with the z values in the output data.frame</p>
</td></tr>
<tr><td><code id="grid.to.xyz_+3A_colnames">colnames</code></td>
<td>
<p>names to be given to the columns corresponding to the x and y coordinates and the grid variable in the output data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with three columns (names are specified in the <code>colnames</code> argument) giving the x and y coordinates and the attribute values at the locations given by the grid <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.ascii.grid">read.ascii.grid()</a></code>, <code><a href="#topic+pick.from.ascii.grid">pick.from.ascii.grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d = read.ascii.grid("dem")
xyz = grid.to.xyz(d,varname="elevation")
str(xyz)

## End(Not run)
</code></pre>

<hr>
<h2 id='landslides'>Landslide inventory, study area mask and DEM</h2><span id='topic+landslides'></span><span id='topic+dem'></span><span id='topic+study_area'></span>

<h3>Description</h3>

<p>Landslide data
</p>


<h3>Format</h3>

<p>The <code>landslides</code> dataset consists of three objects:
</p>

<ol>
<li><p><code>landslides</code> A dataframe of 1535 rows and 3 variables
representing landslide initiation points in the
<em>Reserva Biologica San Francisco</em> (RBSF) area of the tropical Andes
in Southern Ecuador. The variables are:
</p>

<ul>
<li><p><code>lslpts</code> landslide initiation point (boolean)
</p>
</li>
<li><p><code>x</code> and <code>y</code> Coordinates of coordinate reference system
UTM zone 17S (EPSG: 32717)
</p>
</li></ul>

<p>The landslide inventory was mapped by Stoyan (2000) in the field and by
the presence of landslide scars in aerial imagery.
</p>
</li>
<li> <p><code>dem</code> Digital elevation model given as a .Rd grid, i.e. a list
consisting of the elements <code>header</code> (nine properties) and <code>data</code>
(grid elevation values in m a.s.l.). The 10 m x 10 m digital elevation model
was triangulated from aerial imagery as described by Jordan <em>et al.</em>
(2005) and provided as a courtesy of Lars Ungerechts (2010).
</p>
</li>
<li> <p><code>study_area</code> An <code>sf</code>-object representing the outlines of
the natural part of the RBSF study area.
</p>
</li></ol>



<h3>Details</h3>

<p>Landslide data provided here are a subset of that used by Muenchow
<em>et al.</em> (2012) to predict spatially landslide susceptibility using
generalized additive models (GAMs). Specifically, the here provided
landslides belong to the &quot;natural&quot; part of the <em>RBSF</em> area. Please
refer also to the accompanying vignette for an introductory tutorial on the
use of the RSAGA package for terrain analysis, geoprocessing, and
model-building using these data.
</p>


<h3>Note</h3>

<p>Please note that loading <code>landslides</code> overwrites existing objects named
<code>dem</code>, <code>landslides</code> and <code>study_area</code>.
</p>


<h3>Source</h3>

<p><strong>DEM:</strong>
</p>
<p>Ungerechts, L. (2010): DEM 10m (triangulated from aerial photo - b/w).
Available online:
<a href="http://vhrz669.hrz.uni-marburg.de/tmf_respect/data_pre.do?citid=901">http://vhrz669.hrz.uni-marburg.de/tmf_respect/data_pre.do?citid=901</a>
</p>
<p>Jordan, E., Ungerechts, L., Caceres, B. Penafiel, A. and Francou, B.
(2005): Estimation by photogrammetry of the glacier recession on the
Cotopaxi Volcano (Ecuador) between 1956 and 1997. <em>Hydrological
Sciences</em> 50, 949-961.
</p>
<p><strong>Landslide Data:</strong>
</p>
<p>Muenchow, J., Brenning, A., Richter, R. (2012): Geomorphic process rates of
landslides along a humidity gradient in the tropical Andes, Geomorphology
139-140, 271-284. DOI: 10.1016/j.geomorph.2011.10.029.
</p>
<p>Stoyan, R. (2000): Aktivitaet, Ursachen und Klassifikation der Rutschungen
in San Francisco/Suedecuador. Unpublished diploma thesis, University of
Erlangen-Nuremberg, Germany.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("RSAGA")
data(landslides)

# Print the DEM header:
dem$header

# Write the DEM to a SAGA grid:
write.sgrd(data = dem, file = "dem", header = dem$header, env = env)

# Calculate slope of DEM:
rsaga.slope(in.dem = "dem", out.slope = "slope", method = "poly2zevenbergen")

# Pick slope values at landslide points,
# added to landslides data.frame as variable "slope":
landslides &lt;- pick.from.saga.grid(data = landslides,
                                  filename = "slope",
                                  varname = "slope")

## End(Not run)
</code></pre>

<hr>
<h2 id='match.arg.ext'>Extended Argument Matching</h2><span id='topic+match.arg.ext'></span>

<h3>Description</h3>

<p><code>match.arg.ext</code> matches <code>arg</code> against a set of candidate values as specified by <code>choices</code>; it extends <code><a href="base.html#topic+match.arg">match.arg()</a></code> by allowing <code>arg</code> to be a numeric identifier of the <code>choices</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.arg.ext(
  arg,
  choices,
  base = 1,
  several.ok = FALSE,
  numeric = FALSE,
  ignore.case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.arg.ext_+3A_arg">arg</code></td>
<td>
<p>a character string or numeric value</p>
</td></tr>
<tr><td><code id="match.arg.ext_+3A_choices">choices</code></td>
<td>
<p>a character vector of candidate values</p>
</td></tr>
<tr><td><code id="match.arg.ext_+3A_base">base</code></td>
<td>
<p>numeric value, specifying the numeric index assigned to the first element of <code>choices</code></p>
</td></tr>
<tr><td><code id="match.arg.ext_+3A_several.ok">several.ok</code></td>
<td>
<p>logical specifying if <code>arg</code> should be allowed to have more than one element</p>
</td></tr>
<tr><td><code id="match.arg.ext_+3A_numeric">numeric</code></td>
<td>
<p>logical specifying if the function should return the numerical index (counting from <code>base</code>) of the matched <code>arg</code>ument, or, by default, its name</p>
</td></tr>
<tr><td><code id="match.arg.ext_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical specifying if the matching should be case sensitive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>choices</code> are missing, they are obtained from a default setting for the formal argument <code>arg</code> of the function from which <code>match.arg.ext</code> was called.
</p>
<p>Matching is done using <code><a href="base.html#topic+pmatch">pmatch()</a></code> (indirectly through a call to <code><a href="base.html#topic+match.arg">match.arg()</a></code>, so <code>arg</code> may be abbreviated.
</p>
<p>If <code>arg</code> is numeric, it may take values between <code>base</code> and <code>length(choices)+base-1</code>.  <code>base=1</code> will give standard 1-based R indices, <code>base=0</code> will give indices counted from zero as used to identify SAGA modules in library RSAGA.
</p>


<h3>Value</h3>

<p>If <code>numeric</code> is false and <code>arg</code> is a character string, the function returns the unabbreviated version of the unique partial match of <code>arg</code> if there is one; otherwise, an error is signalled if <code>several.ok</code> is false, as per default. When <code>several.ok</code> is true and there is more than one match, all unabbreviated versions of matches are returned.
</p>
<p>If <code>numeric</code> is false but <code>arg</code> is numeric, <code>match.arg.ext</code> returns name of the match corresponding to this index, counting from <code>base</code>; i.e. <code>arg=base</code> corresponds to <code>choices[1]</code>.
</p>
<p>If <code>numeric</code> is true, the function returns the numeric index(es) of the partial match of <code>arg</code>, counted from <code>base</code> to <code>length(choices)+base-1</code>. If <code>arg</code> is already numeric, the function only checks whether it falls into the valid range from <code>arg</code> to <code>length(choices)+base-1</code> and returns <code>arg</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match.arg">match.arg()</a></code>, <code><a href="base.html#topic+pmatch">pmatch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Based on example from 'match.arg':
require(stats)
center &lt;- function(x, type = c("mean", "median", "trimmed")) {
  type &lt;- match.arg.ext(type,base=0)
  switch(type,
         mean = mean(x),
         median = median(x),
         trimmed = mean(x, trim = .1))
}
x &lt;- rcauchy(10)
center(x, "t")       # Works
center(x, 2)         # Same, for base=0
center(x, "med")     # Works
center(x, 1)         # Same, for base=0
try(center(x, "m"))  # Error
</code></pre>

<hr>
<h2 id='multi.focal.function'>Local and Focal Grid Function with Multiple Grids as Inputs</h2><span id='topic+multi.focal.function'></span><span id='topic+multi.local.function'></span>

<h3>Description</h3>

<p><code>multi.focal.function</code> cuts out square or circular moving windows from a stack of grids (matrices) and applies a user-defined matrix function that takes multiple arguments to this data. <code>multi.local.function</code> is a more efficiently coded special case of moving windows of size 0, i.e. functions applied to individual grid cells of a stack of grids. This is especially useful for applying <code>predict</code> methods of statistical models to a stack of grids containing the explanatory variables (see Examples and <code><a href="#topic+grid.predict">grid.predict()</a></code>). The function is suitable for large grid files as it can process them row by row; but it may be slow because one call to the focal function is generated for each grid cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.focal.function(
  in.grids,
  in.grid.prefix,
  in.factor.grid,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  in.varnames,
  out.varnames,
  radius = 0,
  is.pixel.radius = TRUE,
  na.strings = "NA",
  valid.ranges,
  nodata.values = c(),
  out.nodata.value,
  search.mode = c("circle", "square"),
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  mw.to.vector = FALSE,
  mw.na.rm = FALSE,
  pass.location = FALSE,
  ...
)

multi.local.function(
  in.grids,
  in.grid.prefix,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  in.varnames,
  out.varnames,
  na.strings = "NA",
  valid.ranges,
  nodata.values = c(),
  out.nodata.value,
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  na.action = stats::na.exclude,
  pass.location = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi.focal.function_+3A_in.grids">in.grids</code></td>
<td>
<p>character vector: file names of input ASCII grids, relative to <code>in.path</code>; <code>in.grid.prefix</code> will be used as a prefix to the file name if specified; default file extension: <code>.asc</code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_in.grid.prefix">in.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the input file names; a dash (<code>-</code>) will separate the prefix and the <code>in.varnames</code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_in.factor.grid">in.factor.grid</code></td>
<td>
<p>optional file name giving a gridded categorical variables defining zones; zone boundaries are used as breaklines for the moving window (see Details)</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_out.grid.prefix">out.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the output file names; a dash (<code>-</code>) will separate the prefix and the <code>out.varnames</code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_path">path</code></td>
<td>
<p>path in which to look for <code>in.grids</code> and write output grid files; see also <code>in.path</code> and <code>out.path</code>, which overwrite <code>path</code> if they are specified</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_in.path">in.path</code></td>
<td>
<p>path in which to look for <code>in.grids</code> (defaults to <code>path</code>)</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_out.path">out.path</code></td>
<td>
<p>path in which to write output grid files; defaults to <code>path</code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_fun">fun</code></td>
<td>
<p>a function, or name of a function, to be applied on the moving window; see Details; <code>fun</code> is expected to accept named arguments with the names given by <code>in.varnames</code>; <code><a href="#topic+grid.predict">grid.predict()</a></code> is a wrapper function that can be used for applying a model's <code>predict</code> method to a stack of grids; see Details. In <code>multi.local.function</code>, <code>fun</code> must be able to process  arguments that are vectors of equal length (e.g., a vector of 50 slope angles, another vector of 50 elevation values, etc.).</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_in.varnames">in.varnames</code></td>
<td>
<p>character vector: names of the variables corresponding to the <code>in.grids</code>; if missing, same as <code>in.grids</code>; if specified, must have the same length and order as <code>in.grids</code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_out.varnames">out.varnames</code></td>
<td>
<p>character vector specifying the name(s) of the variable(s) returned by <code>fun</code>; if missing, <code>multi.focal.function</code> will try to determine the varnames from <code>fun</code> itself, or or from a call to <code>fun</code> if this is a function (see Details)</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_radius">radius</code></td>
<td>
<p>numeric value specifying the (circular or square) radius  of the moving window; see <code>is.pixel.radius</code> and <code>search.mode</code>; note that all data within distance <code style="white-space: pre;">&#8288;&lt;=radius&#8288;</code> will be included in the moving window, not <code style="white-space: pre;">&#8288;&lt;radius&#8288;</code>.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_is.pixel.radius">is.pixel.radius</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), the <code>radius</code> will be interpreted as a (possibly non-integer) number of pixels; if <code>FALSE</code>, it is interpreted as a radius measured in the grid (map) units.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_na.strings">na.strings</code></td>
<td>
<p>passed on to <code><a href="base.html#topic+scan">scan()</a></code></p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_valid.ranges">valid.ranges</code></td>
<td>
<p>optional list of length <code>length(in.grids)</code> with numeric vector of length 2, specifying minimum and maximum valid values read from input file; all values <code style="white-space: pre;">&#8288;&lt;valid.ranges[[i]][1]&#8288;</code> or <code style="white-space: pre;">&#8288;&gt;valid.ranges[[i]][1]&#8288;</code> will be converted to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_nodata.values">nodata.values</code></td>
<td>
<p>numeric vector: any values from the input grid file that should be converted to <code>NA</code>, in addition to the nodata value specified in the grid header</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_out.nodata.value">out.nodata.value</code></td>
<td>
<p>numeric: value used for storing <code>NA</code>s in the output file(s); if missing, use the same nodata value as specified in the header of the input grid file</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_search.mode">search.mode</code></td>
<td>
<p>character, either <code>"circle"</code> (default) for a circular search window, or <code>"square"</code> for a squared one.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_digits">digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for output grid file.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_hdr.digits">hdr.digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for the header of the output grid file (default: 10; see <code><a href="#topic+write.ascii.grid.header">write.ascii.grid.header()</a></code>).</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_dec">dec</code></td>
<td>
<p>character, specifying the decimal mark to be used for input and output.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, gives some output (<code>"*"</code>) after every 10th line of the grid file and when the job is done.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_nlines">nlines</code></td>
<td>
<p>Number of lines to be processed; useful for testing purposes.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_mw.to.vector">mw.to.vector</code></td>
<td>
<p>logical: Should the content of the moving window be coerced (from a matrix) to a vector?</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_mw.na.rm">mw.na.rm</code></td>
<td>
<p>logical: Should <code>NA</code>s be removed from moving window prior to passing the data to <code>fun</code>? Only applicable when <code>mw.to.vector=TRUE</code>.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_pass.location">pass.location</code></td>
<td>
<p>logical: Should the x,y coordinates of grid points (center of grid cells) be passed to <code>fun</code>? If <code>TRUE</code>, two additional arguments named arguments <code>x</code> and <code>y</code> are passed to <code>fun</code>; NOTE: This currently only works for <code>radius=0</code>, otherwise a warning is produced and <code>pass.location</code> is reset to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>fun</code>; <code>local.function</code>: arguments to be passed to  <code>focal.function</code>.</p>
</td></tr>
<tr><td><code id="multi.focal.function_+3A_na.action">na.action</code></td>
<td>
<p>function: determines if/how <code>NA</code> values are omitted from the stack of input variables; use <code><a href="stats.html#topic+na.exclude">na.exclude()</a></code> (default) or <code><a href="stats.html#topic+na.pass">na.pass()</a></code> if <code>fun</code> can handle <code>NA</code> values correctly</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>multi.local.function</code> is probably most useful for applying the <code>predict</code> method of a fitted model to a grids representing the predictor variables. An example is given below and in more detail in Brenning (2008) (who used <code>multi.focal.function</code> for the same purpose); see also <code><a href="#topic+grid.predict">grid.predict()</a></code>.
</p>
<p><code>multi.local.function</code> is essentially the same as <code>multi.focal.function</code> for <code>radius=0</code>, but coded MUCH more efficiently. (The relevant code will eventually migrate into <code>multi.focal.function</code> as well, but requires further testing.) Applying a GAM to the data set of Brenning (2008) takes about 1/100th the time with <code>multi.local.function</code> compared to <code>multi.focal.function</code>.
</p>
<p><code>multi.focal.function</code> extends <code><a href="#topic+focal.function">focal.function()</a></code> by allowing multiple input grids to be passed to the focal function <code>fun</code> operating on moving windows. It passes square matrices of size <code>2*radius+1</code> to the function <code>fun</code> if <code>mw.to.vector=FALSE</code> (default), or a vector of length <code style="white-space: pre;">&#8288;&lt;=(2*radius+1)^2&#8288;</code> if <code>mw.to.vector=TRUE</code>; one such matrix or vector per input grid will be passed to <code>fun</code> as an argument whose name is specified by <code>in.varnames</code>.
</p>
<p>These matrices or vectors will contain the content of the moving window, which may possibly contain <code>NA</code>s even if the <code>in.grid</code> has no nodata values, e.g. due to edge effects. If <code>search.mode="circle"</code>, values more than <code>radius</code> units (pixels or grid units, depending on <code>is.pixel.radius</code>) away from the center pixel / matrix entry will be set to <code>NA</code>. In addition, <code>valid.range</code>, <code>nodata.values</code>, and the nodata values specified in the <code>in.grid</code> are checked to assign further <code>NA</code>s to pixels in the moving window. Finally, if <code>in.factor.grid</code> specifies zones, all pixels in the moving window that belong to a different zone than the center pixel are set to <code>NA</code>, or, in other words, zone boundaries are used as breaklines.
</p>
<p>The function <code>fun</code> should return a single numeric value or a numeric vector, such as a regression result or a vector of class probabilities returned by a soft classifier. In addition to the named arguments receiving the moving window data, <code>fun</code> may have additional arguments; the <code>...</code> argument of <code>focal.function</code> is passed on to <code>fun</code>. <code><a href="#topic+grid.predict">grid.predict()</a></code> uses this feature.
</p>
<p>Optionally, <code>fun</code> should support the following feature: If no argument is passed to it, then it should return a character vector giving variable names to be used for naming the output grids.
</p>
<p>For the input files, <code>.asc</code> is used as the default file extension, if it is not specified by the user.
</p>
<p>See <code><a href="#topic+focal.function">focal.function()</a></code> for details.
</p>


<h3>Value</h3>

<p><code>multi.focal.function</code> returns the character vector of output file names.
</p>


<h3>Note</h3>

<p><code>multi.focal.function</code> can do all the things <code><a href="#topic+focal.function">focal.function()</a></code> can do.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models. In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="#topic+grid.predict">grid.predict()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assume that d is a data.frame with point observations
# of a numerical response variable y and predictor variables
# a, b, and c.
# Fit a generalized additive model to y,a,b,c.
# We want to model b and c as nonlinear terms:
require(gam)
fit &lt;- gam(y ~ a + s(b) + s(c), data = d)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit )
    # Note that the 'grid.predict' uses by default the
    # predict method of 'fit'.
# Model predictions are written to a file named pred.asc

## End(Not run)

## Not run: 
# A fake example of a logistic additive model:
require(gam)
fit &lt;- gam(cl ~ a + s(b) + s(c), data = d, family = binomial)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit,
    control.predict = list(type = "response") )
    # 'control.predict' is passed on to 'grid.predict', which
    # dumps its contents into the arguments for 'fit''s
    # 'predict' method.
# Model predictions are written to a file named pred.asc

## End(Not run)
</code></pre>

<hr>
<h2 id='pick.from.points'>Pick Variable from Spatial Dataset</h2><span id='topic+pick.from.points'></span><span id='topic+pick.from.shapefile'></span><span id='topic+pick.from.ascii.grid'></span><span id='topic+pick.from.ascii.grids'></span><span id='topic+internal.pick.from.ascii.grid'></span><span id='topic+pick.from.saga.grid'></span>

<h3>Description</h3>

<p>These functions pick (i.e. interpolate without worrying too much about theory) values of a spatial variables from a data stored in a data.frame, a point shapefile, or an ASCII or SAGA grid, using nearest neighbor or kriging interpolation. <code>pick.from.points</code> and <code style="white-space: pre;">&#8288;[internal.]pick.from.ascii.grid&#8288;</code> are the core functions that are called by the different wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick.from.points(
  data,
  src,
  pick,
  method = c("nearest.neighbour", "krige"),
  set.na = FALSE,
  radius = 200,
  nmin = 0,
  nmax = 100,
  sill = 1,
  range = radius,
  nugget = 0,
  model = vgm(sill - nugget, "Sph", range = range, nugget = nugget),
  log = rep(FALSE, length(pick)),
  X.name = "x",
  Y.name = "y",
  cbind = TRUE
)

pick.from.shapefile(data, shapefile, X.name = "x", Y.name = "y", ...)

pick.from.ascii.grid(
  data,
  file,
  path = NULL,
  varname = NULL,
  prefix = NULL,
  method = c("nearest.neighbour", "krige"),
  cbind = TRUE,
  parallel = FALSE,
  nsplit,
  quiet = TRUE,
  ...
)

pick.from.ascii.grids(
  data,
  file,
  path = NULL,
  varname = NULL,
  prefix = NULL,
  cbind = TRUE,
  quiet = TRUE,
  ...
)

internal.pick.from.ascii.grid(
  data,
  file,
  path = NULL,
  varname = NULL,
  prefix = NULL,
  method = c("nearest.neighbour", "krige"),
  nodata.values = c(-9999, -99999),
  at.once,
  quiet = TRUE,
  X.name = "x",
  Y.name = "y",
  nlines = Inf,
  cbind = TRUE,
  range,
  radius,
  na.strings = "NA",
  ...
)

pick.from.saga.grid(
  data,
  filename,
  path,
  varname,
  prec = 7,
  show.output.on.console = FALSE,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick.from.points_+3A_data">data</code></td>
<td>
<p>data.frame giving the coordinates (in columns specified by <code style="white-space: pre;">&#8288;X.name, Y.name&#8288;</code>) of point locations at which to interpolate the specified variables or grid values</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_src">src</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_pick">pick</code></td>
<td>
<p>variables to be picked (interpolated) from <code>src</code>; if missing, use all available variables, except those specified by <code>X.name</code> and <code>Y.name</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_method">method</code></td>
<td>
<p>interpolation method to be used; uses a partial match to the alternatives <code>"nearest.neighbor"</code> (currently the default) and <code>"krige"</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_set.na">set.na</code></td>
<td>
<p>logical: if a column with a name specified in <code>pick</code> already exists in <code>data</code>, how should it be dealt with? <code>set.na=FALSE</code> (default) only overwrites existing data if the interpolator yields a non-<code>NA</code> result; <code>set.na=TRUE</code> passes <code>NA</code> values returned by the interpolator on to the results data.frame</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_radius">radius</code></td>
<td>
<p>numeric value specifying the radius of the local neighborhood to be used for interpolation; defaults to 200 map units (presumably meters), or, in the functions for grid files, <code>2.5*cellsize</code>.</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nmin">nmin</code></td>
<td>
<p>numeric, for <code>method="krige"</code> only: see <code><a href="gstat.html#topic+krige">gstat::krige()</a></code> function in package <span class="pkg">gstat</span></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nmax">nmax</code></td>
<td>
<p>numeric, for <code>method="krige"</code> only: see <code><a href="gstat.html#topic+krige">gstat::krige()</a></code> function in package <span class="pkg">gstat</span></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_sill">sill</code></td>
<td>
<p>numeric, for <code>method="krige"</code> only: the overall sill parameter to be used for the variogram</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_range">range</code></td>
<td>
<p>numeric, for <code>method="krige"</code> only: the variogram range</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nugget">nugget</code></td>
<td>
<p>numeric, for <code>method="krige"</code> only: the nugget effect</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_model">model</code></td>
<td>
<p>for <code>method="krige"</code> only: the variogram model to be used for interpolation; defaults to a spherical variogram with parameters specified by the <code>range</code>, <code>sill</code>, and <code>nugget</code> arguments; see <code><a href="gstat.html#topic+vgm">gstat::vgm()</a></code> in package <span class="pkg">gstat</span> for details</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_log">log</code></td>
<td>
<p>logical vector, specifying for each variable in <code>pick</code> if interpolation should take place on the logarithmic scale (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_x.name">X.name</code></td>
<td>
<p>name of the variable containing the x coordinates</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_y.name">Y.name</code></td>
<td>
<p>name of the variable containing the y coordinates</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_cbind">cbind</code></td>
<td>
<p>logical: shoud the new variables be added to the input data.frame (<code>cbind=TRUE</code>, the default), or should they be returned as a separate vector or data.frame? <code>cbind=FALSE</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_shapefile">shapefile</code></td>
<td>
<p>point shapefile</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>pick.from.points</code>, and to <code>internal.pick.from.ascii.grid</code> in the case of <code>pick.from.ascii.grid</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_file">file</code></td>
<td>
<p>file name (relative to <code>path</code>, default file extension <code>.asc</code>) of an ASCII grid from which to pick a variable, or an open connection to such a file</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_path">path</code></td>
<td>
<p>optional path to <code>file</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_varname">varname</code></td>
<td>
<p>character string: a variable name for the variable interpolated from grid file <code>file</code> in <code>pick.from.*.grid</code>; if missing, variable name will be determined from <code>file</code>name by a call to <code><a href="#topic+create.variable.name">create.variable.name()</a></code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_prefix">prefix</code></td>
<td>
<p>an optional prefix to be added to the <code>varname</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_parallel">parallel</code></td>
<td>
<p>logical (default: <code>FALSE</code>): enable parallel processing; requires additional packages such as <span class="pkg">doSNOW</span> or <span class="pkg">doMC</span>. See example below and <code><a href="plyr.html#topic+ddply">plyr::ddply()</a></code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nsplit">nsplit</code></td>
<td>
<p>split the data.frame <code>data</code> in <code>nsplit</code> disjoint subsets in order to increase efficiency by using <code><a href="plyr.html#topic+ddply">plyr::ddply()</a></code> in package <span class="pkg">plyr</span>. The default seems to perform well in many situations.</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_quiet">quiet</code></td>
<td>
<p>logical: provide information on the progress of grid processing on screen? (only relevant if <code>at.once=FALSE</code> and <code>method="nearest.neighbour"</code>)</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nodata.values">nodata.values</code></td>
<td>
<p>numeric vector specifying grid values that should be converted to <code>NA</code>; in addition to the values specified here, the nodata value given in the input grid's header will be used</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_at.once">at.once</code></td>
<td>
<p>logical: should the grid be read as a whole or line by line? <code>at.once=FALSE</code> is useful for processing large grids that do not fit into memory; the argument is currently by default <code>FALSE</code> for <code>method="nearest.neighbour"</code>, and it currently MUST be <code>TRUE</code> for all other methods (in these cases, <code>TRUE</code> is the default value); piecewise processing with <code>at.once=FALSE</code> is always faster than processing the whole grid <code>at.once</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_nlines">nlines</code></td>
<td>
<p>numeric: stop after processing <code>nlines</code> lines of the input grid; useful for testing purposes</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_na.strings">na.strings</code></td>
<td>
<p>passed on to <code><a href="base.html#topic+scan">scan()</a></code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_filename">filename</code></td>
<td>
<p>character: name of a SAGA grid file, default extension <code>.sgrd</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_prec">prec</code></td>
<td>
<p>numeric, specifying the number of digits to be used in converting a SAGA grid to an ASCII grid in <code>pick.from.saga.grid</code></p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_show.output.on.console">show.output.on.console</code></td>
<td>
<p>a logical (default: <code>FALSE</code>), indicates whether to capture the output of the command and show it on the R console (see <code><a href="base.html#topic+system">system()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>).</p>
</td></tr>
<tr><td><code id="pick.from.points_+3A_env">env</code></td>
<td>
<p>list: RSAGA geoprocessing environment created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pick.from.points</code> interpolates the variables defined by <code>pick</code> in the <code>src</code> data.frame to the locations provided by the <code>data</code> data.frame. Only nearest neighbour and ordinary kriging interpolation are currently available. This function is intended for 'data-rich' situations in which not much thought needs to be put into a geostatistical analysis of the spatial structure of a variable. In particular, this function is supposed to provide a simple, 'quick-and-dirty' interface for situations where the <code>src</code> data points are very densely distributed compared to the <code>data</code> locations.
</p>
<p><code>pick.from.shapefile</code> is a front-end of <code>pick.from.points</code> for point shapefiles.
</p>
<p><code>pick.from.ascii.grid</code> retrieves data values from an ASCII raster file using either nearest neighbour or ordinary kriging interpolation. The latter may not be possible for large raster data sets because the entire grid needs to be read into an R matrix. Split-apply-combine strategies are used to improve efficiency and allow for parallelization.
</p>
<p>The optional parallelization of <code>pick.from.ascii.grid</code> computation requires the use of a <em>parallel backend</em> package such as <span class="pkg">doSNOW</span> or <span class="pkg">doMC</span>, and the parallel backend needs to be registered before calling this function with <code>parallel=TRUE</code>. The example section provides an example using <span class="pkg">doSNOW</span> on Windows. I have seen 25-40% reduction in processing time by parallelization in some examples that I ran on a dual core Windows computer.
</p>
<p><code>pick.from.ascii.grids</code> performs multiple <code>pick.from.ascii.grid</code> calls. File <code>path</code> and <code>prefix</code> arguments may be specific to each <code>file</code> (i.e. each may be a character vector), but all interpolation settings will be the same for each <code>file</code>, limiting the flexibility a bit compared to individual <code>pick.from.ascii.grid</code> calls by the user. <code>pick.from.ascii.grids</code> currently processes the files sequentially (i.e. parallelization is limited to the <code>pick.from.ascii.grid</code> calls within this function).
</p>
<p><code>pick.from.saga.grid</code> is the equivalent to <code>pick.from.ascii.grid</code> for SAGA grid files. It simply converts the SAGA grid <code>file</code> to a (temporary) ASCII raster file and applies <code>pick.from.ascii.grid</code>.
</p>
<p><code>internal.pick.from.ascii.grid</code> is an internal 'workhorse' function that by itself would be very inefficient for large data sets <code>data</code>. This function is called by <code>pick.from.ascii.grid</code>, which uses a split-apply-combine strategy implemented in the <span class="pkg">plyr</span> package.
</p>


<h3>Value</h3>

<p>If <code>cbind=TRUE</code>, columns with the new, interpolated variables are added to the input data.frame <code>data</code>.
</p>
<p>If <code>cbind=FALSE</code>, a data.frame only containing the new variables is returned (possibly coerced to a vector if only one variable is processed).
</p>


<h3>Note</h3>

<p><code>method="krige"</code> requires the <span class="pkg">gstat</span> package.
</p>
<p><code>pick.from.shapefile</code> requires the <span class="pkg">shapefiles</span> package.
</p>
<p>The nearest neighbour interpolation currently randomly breaks ties if <code>pick.from.points</code> is used, and in a deterministic fashion (rounding towards greater grid indices, i.e. toward south and east) in the grid functions.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA:  The example of landslide susceptibility analysis with generalized additive models. In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.to.xyz">grid.to.xyz()</a></code>, %<code><a href="gstat.html#topic+vgm">vgm()</a></code>, <code><a href="gstat.html#topic+krige">krige()</a></code>, <code><a href="#topic+read.ascii.grid">read.ascii.grid()</a></code>, <code><a href="#topic+write.ascii.grid">write.ascii.grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# assume that 'dem' is an ASCII grid and d a data.frame with variables x and y
pick.from.ascii.grid(d, "dem")
# parallel processing on Windows using the doSNOW package:
require(doSNOW)
registerDoSNOW(cl &lt;- makeCluster(2, type = "SOCK")) # DualCore processor
pick.from.ascii.grid(d, "dem", parallel = TRUE)
# produces two (ignorable) warning messages when using doSNOW
# typically 25-40% faster than the above on my DualCore notebook
stopCluster(cl)

## End(Not run)

## Not run: 
# use the meuse data for some tests:
require(gstat)
data(meuse)
data(meuse.grid)
meuse.nn = pick.from.points(data=meuse.grid, src=meuse,
    pick=c("cadmium","copper","elev"), method="nearest.neighbour")
meuse.kr = pick.from.points(data=meuse.grid, src=meuse,
    pick=c("cadmium","copper","elev"), method="krige", radius=100)
# it does make a difference:
plot(meuse.kr$cadmium,meuse.nn$cadmium)
plot(meuse.kr$copper,meuse.nn$copper)
plot(meuse.kr$elev,meuse.nn$elev)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.ascii.grid'>Read/write ASCII, SAGA and Rd Grid Files</h2><span id='topic+read.ascii.grid'></span><span id='topic+read.ascii.grid.header'></span><span id='topic+read.sgrd'></span><span id='topic+read.Rd.grid'></span><span id='topic+write.ascii.grid'></span><span id='topic+write.ascii.grid.header'></span><span id='topic+write.sgrd'></span><span id='topic+write.Rd.grid'></span>

<h3>Description</h3>

<p>These functions provide simple interfaces for reading and writing grids from/to ASCII grids and Rd files. Grids are stored as matrices, their headers in lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ascii.grid(
  file,
  return.header = TRUE,
  print = 0,
  nodata.values = c(),
  at.once = TRUE,
  na.strings = "NA"
)

read.ascii.grid.header(file, ...)

read.sgrd(
  fname,
  return.header = TRUE,
  print = 0,
  nodata.values = c(),
  at.once = TRUE,
  prec = 7,
  ...
)

read.Rd.grid(fname, return.header = TRUE)

write.ascii.grid(
  data,
  file,
  header = NULL,
  write.header = TRUE,
  digits,
  hdr.digits = 10,
  dec = ".",
  georef = "corner"
)

write.ascii.grid.header(file, header, georef, dec = ".", hdr.digits = 10)

write.sgrd(
  data,
  file,
  header = NULL,
  prec = 7,
  hdr.prec = 10,
  georef = "corner",
  ...
)

write.Rd.grid(data, file, header = NULL, write.header = TRUE, compress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ascii.grid_+3A_file">file</code></td>
<td>
<p>file name of an ASCII grid (extension defaults to <code>.asc</code> if not specified), or a connection open for reading or writing, as required</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_return.header">return.header</code></td>
<td>
<p>logical: should the grid header be returned (default), or just the grid data matrix? In the former case, <code>read.ascii.grid</code> returns a list with two components named <code>data</code> and <code>header</code>.</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_print">print</code></td>
<td>
<p>numeric, specifying how detailed the output reporting the progress should be (currently 0 to 2, 0 being minimum output).</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_nodata.values">nodata.values</code></td>
<td>
<p>optional numeric vector specifying nodata values to be used in addition to the nodata value specified in the grid header; nodata values are converted to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_at.once">at.once</code></td>
<td>
<p>logical: if <code>TRUE</code>, read the whole grid with one <code>scan</code> command; if <code>FALSE</code>, read it row by row using <code>scan</code> with option <code>nlines=1</code>.</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_na.strings">na.strings</code></td>
<td>
<p>passed on to <code><a href="base.html#topic+scan">scan()</a></code>.</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_...">...</code></td>
<td>
<p><code>read.sgrd</code>, <code>write.sgrd</code>: additional arguments to be passed to <code>rsaga.geoprocessor</code></p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_fname">fname</code></td>
<td>
<p>file name of a grid stored as an R (<code>.Rd</code>) file; extension defaults to <code>.Rd</code></p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_prec">prec</code></td>
<td>
<p>integer: number of digits of temporary ASCII grid used for importing or exporting a SAGA grid</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_data">data</code></td>
<td>
<p>grid data: a data matrix, or a list with components <code>data</code> (the grid data matrix) and <code>header</code> (the grid header information).</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_header">header</code></td>
<td>
<p>optional list argument specifying the grid header information as returned by the <code>read.ascii.grid</code> or <code>read.ascii.grid.header</code> function; see Details</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_write.header">write.header</code></td>
<td>
<p>logical: should the header be written with the grid data? (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_digits">digits</code></td>
<td>
<p>numeric: if not missing, write data rounded to this many decimal places</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_hdr.digits">hdr.digits</code></td>
<td>
<p>numeric: see <code>hdr.prec</code></p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_dec">dec</code></td>
<td>
<p>character (default: <code>"."</code>): decimal mark used in input or output file</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_georef">georef</code></td>
<td>
<p>character: specifies whether the output grid should be  georeferenced by the <code>"center"</code> or <code>"corner"</code> of its lower left grid cell; defaults to <code>"corner"</code>.</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_hdr.prec">hdr.prec</code></td>
<td>
<p>numeric: write (non-integer) header data with this many decimal places; a value of 9 or higher is recommended for compatibility with SAGA GIS (default: 10)</p>
</td></tr>
<tr><td><code id="read.ascii.grid_+3A_compress">compress</code></td>
<td>
<p>logical: should the <code>.Rd</code> file written by <code>write.Rd.file</code> be compressed? (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code style="white-space: pre;">&#8288;read.*&#8288;</code> functions return either a list with components <code>data</code> (the grid data matrix) and <code>header</code> (the grid header  information, see below), if <code>return.header=TRUE</code>, or otherwise  just the grid data matrix <code>return.header=FALSE</code>.
</p>
<p>The grid data matrix is a numeric matrix whose first column corrensponds to the first (i.e. northernmost) row of the grid. Columns run from left = West to right = East.
</p>
<p>The header information returned by the <code>read.ascii.grid[.header]</code> functions (if <code>return.header=TRUE</code>) is a list with the following components:
</p>
<table>
<tr><td><code>ncols</code></td>
<td>
<p>Number of grid columns.</p>
</td></tr>
<tr><td><code>nrows</code></td>
<td>
<p>Number of grid rows.</p>
</td></tr>
<tr><td><code>xllcorner</code></td>
<td>
<p>x coordinate of the corner of the lower left grid cell.</p>
</td></tr>
<tr><td><code>yllcorner</code></td>
<td>
<p>y coordinate of the corner of the lower left grid cell.</p>
</td></tr>
<tr><td><code>cellsize</code></td>
<td>
<p>Single numeric value specifying the size of a grid cell or pixel in both x and y direction.</p>
</td></tr>
<tr><td><code>nodata_value</code></td>
<td>
<p>Single numeric value being interpreted as <code>NA</code> (typically <code>-9999</code>.</p>
</td></tr>
<tr><td><code>xllcenter</code></td>
<td>
<p>x coordinate of the center of the lower left grid cell</p>
</td></tr>
<tr><td><code>yllcenter</code></td>
<td>
<p>y coordinate of the center of the lower left grid cell</p>
</td></tr>
</table>
<p>Note: The order of the components, especially of <code>?llcorner</code> and <code>?llcenter</code>, may change, depending on the order in which they appear in the grid header and on the georeferencing method (center or corner) used for the grid. The <code>?llcorner</code> and <code>?llcenter</code> attributes differ only by <code>cellsize/2</code>.
</p>


<h3>Note</h3>

<p><code>read.sgrd</code> and <code>write.sgrd</code> import/export grids indirectly by creating temporary ASCII grid files (this explains why <code>write.sgrd</code> has <code>prec</code> and <code>hdr.prec</code> arguments). Consider using <code><a href="sf.html#topic+st_read">sf::read_sf()</a></code> in package <code>sf</code> instead, which is likely more efficient but may require coercion of your gridded data to/from an object supported by <code>sf</code>.
</p>
<p>The <code>read.Rd.grid</code> and <code>write.Rd.grid</code> functions use the <code>load</code> and <code>save</code> commands to store a grid. The variable name used is <code>data</code>, which is either a numeric matrix or a list with components <code>data</code> (the grid data matrix) and <code>header</code> (the grid header information).
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_read">sf::read_sf()</a></code> and <code><a href="sf.html#topic+st_write">sf::write_sf()</a></code> in package <code>sf</code>, and <code>readAsciiGrid</code> and <code>writeAsciiGrid</code> in package <code>maptools</code>
</p>

<hr>
<h2 id='relative.position'>Relative Topographic Position</h2><span id='topic+relative.position'></span><span id='topic+relative.rank'></span>

<h3>Description</h3>

<p><code>relative.position</code> and <code>relative.rank</code> are used with <code><a href="#topic+focal.function">focal.function()</a></code> to determine the relative value of a grid cell compared to its surroundings, either on a metric scale or based on ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative.position(x)

relative.rank(x, ties.method = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative.position_+3A_x">x</code></td>
<td>
<p>a square matrix with the grid data from the moving window, possibly containing <code>NA</code> values</p>
</td></tr>
<tr><td><code id="relative.position_+3A_ties.method">ties.method</code></td>
<td>
<p>see <code><a href="base.html#topic+rank">rank()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is provided, a numeric value in the interval [0,1] is returned.
</p>
<p>If <code>x</code> is missing, a character vector of same length giving suggested variable (or file) names, here <code>"relpos"</code> and <code>"relrank"</code>, respectively. See <code><a href="#topic+focal.function">focal.function()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="base.html#topic+rank">rank()</a></code>, <code><a href="#topic+centervalue">centervalue()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = matrix( round(runif(9,1,10)), ncol=3 )
print(m)
relative.position(m)
relative.rank(m)
## Not run: 
focal.function("dem",fun=relative.rank,radius=5)
focal.function("dem",fun=relative.position,radius=5)
relrank = as.vector(read.ascii.grid("relrank")$data)
relpos  = as.vector(read.ascii.grid("relpos")$data)
plot(relpos,relrank,pch=".")
cor(relpos,relrank,use="complete.obs",method="pearson")

## End(Not run)
</code></pre>

<hr>
<h2 id='resid.median'>Residual Median and Quantile Filters for Grids</h2><span id='topic+resid.median'></span><span id='topic+resid.minmedmax'></span><span id='topic+resid.quantile'></span><span id='topic+resid.quartiles'></span>

<h3>Description</h3>

<p>These functions use the median and other quantiles to describe the difference between a grid value and its neighborhood. They are designed for use with <code><a href="#topic+focal.function">focal.function()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'median'
resid(x)

## S3 method for class 'minmedmax'
resid(x)

## S3 method for class 'quantile'
resid(x, probs)

## S3 method for class 'quartiles'
resid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.median_+3A_x">x</code></td>
<td>
<p>a square matrix with the grid data from the moving window, possibly containing <code>NA</code> values</p>
</td></tr>
<tr><td><code id="resid.median_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities in [0,1] to be passed to <code><a href="stats.html#topic+quantile">quantile()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed for being called by <code><a href="#topic+focal.function">focal.function()</a></code>, which repeatedly passes the contents of a square or circular moving window to these functions.
</p>
<p>The <code>resid.median</code> function rests the value of the central grid cell from the median of the whole moving window. Thus, in terms of topography, a positive residual median indicates that this grid cell stands out compared to its surroundings. <code>resid.quantile</code> gives more flexibility in designing such residual attributes.
</p>


<h3>Value</h3>

<p>If <code>x</code> is provided, a numeric vector of length 1 (<code>resid.median</code>), 3 (<code>resid.minmedmax</code> and <code>resid.quartiles</code>), or <code>length(probs)</code> (<code>resid.quantile</code>).
</p>
<p>If <code>x</code> is missing, a character vector of same length giving suggested variable (or file) names, such as <code>"rmed"</code>. See <code><a href="#topic+focal.function">focal.function()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="stats.html#topic+quantile">quantile()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>, <code><a href="#topic+centervalue">centervalue()</a></code>
</p>

<hr>
<h2 id='RSAGA-package'>RSAGA: SAGA Geoprocessing and Terrain Analysis in R</h2><span id='topic+RSAGA-package'></span>

<h3>Description</h3>

<p>RSAGA provides direct access to SAGA GIS functions
including, for example, a comprehensive set
of terrain analysis algorithms for calculating local
morphometric properties (slope, aspect, curvature),
hydrographic characteristics (size, height, and
aspect of catchment areas), and other process-related
terrain attributes (potential incoming solar radiation,
topographic wetness index, and more).
In addition, (R)SAGA provides functions for importing
and exporting different grid file formats, and tools
for preprocessing grids, e.g. closing gaps or filling
sinks.
</p>


<h3>Details</h3>

<p>RSAGA adds a framework for creating custom-defined
focal functions, e.g. specialized filter and terrain
attributes such as the topographic wind shelter index,
within R.  This framework can be used to apply predict
methods of fitted statistical models to stacks of grids
representing predictor variables.  Furthermore,
functions are provided for conveniently picking
values at point locations from a grid using kriging
or nearest neighbour interpolation.
</p>
<p>RSAGA requires SAGA GIS (versions 2.3.1 LTS - 8.4.1)
are currently supported) and its user-contributed
modules to be available on your computer. These
can be downloaded under GPL from
<a href="https://sourceforge.net/projects/saga-gis/">https://sourceforge.net/projects/saga-gis/</a>.
Please check the help page for
<code><a href="#topic+rsaga.env">rsaga.env()</a></code> to make sure that RSAGA
can find your local installation of SAGA. You may
need to 'tell' RSAGA where to find SAGA GIS.
</p>
<p>Thanks to Olaf Conrad, Andre Ringeler and all the
other SAGA GIS developers and contributors of
this excellent geocomputing tool! Thanks to Rainer
Hurling, Johan van de Wauw, Massimo Di Stefano and
others for helping to adapt SAGA to and test it on
unix and Max OSX.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning, Donovan Bangs and Marc Becker
</p>


<h3>References</h3>

<p>Brenning, A., 2008. Statistical geocomputing combining R and
SAGA: The example of landslide susceptibility analysis with
generalized additive models. In J. Boehner, T. Blaschke and
L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger
Beitraege zur Physischen Geographie und
Landschaftsoekologie, vol. 19), p. 23-32.
</p>
<p>Conrad, O., Bechtel, M., Bock, M., Dietrich, H., Fischer, E., Gerlitz, L., Wichmann,
V., &amp; Boehner, J. (2015). System for Automated Geoscientific Analyses (SAGA) v. 2.1.4.
<em>Geoscientific Model Development</em>, 8, 1991-2007
</p>

<hr>
<h2 id='rsaga.add.grid.values.to.points'>Add Grid Values to Point Shapefile</h2><span id='topic+rsaga.add.grid.values.to.points'></span>

<h3>Description</h3>

<p>Pick values from SAGA grids and attach them as a new variables to a point shapefile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.add.grid.values.to.points(
  in.shapefile,
  in.grids,
  out.shapefile,
  method = c("nearest.neighbour", "bilinear", "idw", "bicubic.spline", "b.spline"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.add.grid.values.to.points_+3A_in.shapefile">in.shapefile</code></td>
<td>
<p>Input point shapefile (default extension: <code>.shp</code>).</p>
</td></tr>
<tr><td><code id="rsaga.add.grid.values.to.points_+3A_in.grids">in.grids</code></td>
<td>
<p>Input: character vector with names of (one or more) SAGA GIS grid files to be converted into a point shapefile.</p>
</td></tr>
<tr><td><code id="rsaga.add.grid.values.to.points_+3A_out.shapefile">out.shapefile</code></td>
<td>
<p>Output point shapefile (default extension: <code>.shp</code>).</p>
</td></tr>
<tr><td><code id="rsaga.add.grid.values.to.points_+3A_method">method</code></td>
<td>
<p>interpolation method to be used; choices: nearest neighbour interpolation (default), bilinear interpolation, inverse distance weighting, bicubic spline interpolation, B-splines.</p>
</td></tr>
<tr><td><code id="rsaga.add.grid.values.to.points_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retrieves information from the selected grids at the positions of the points of the selected points layer and adds it to the resulting layer.
</p>


<h3>Note</h3>

<p>This function uses module <code style="white-space: pre;">&#8288;Add Grid Values to Points&#8288;</code> in SAGA GIS library <code>shapes_grid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA modules)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pick.from.points">pick.from.points()</a></code>, <code><a href="#topic+pick.from.ascii.grid">pick.from.ascii.grid()</a></code>, <code><a href="#topic+pick.from.saga.grid">pick.from.saga.grid()</a></code>, <code><a href="#topic+rsaga.grid.to.points">rsaga.grid.to.points()</a></code>
</p>

<hr>
<h2 id='rsaga.close.gaps'>SAGA Modules Close Gaps and Close One Cell Gaps</h2><span id='topic+rsaga.close.gaps'></span><span id='topic+rsaga.close.one.cell.gaps'></span>

<h3>Description</h3>

<p>Close (Interpolate) Gaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.close.gaps(in.dem, out.dem, threshold = 0.1, ...)

rsaga.close.one.cell.gaps(in.dem, out.dem, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.close.gaps_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.close.gaps_+3A_out.dem">out.dem</code></td>
<td>
<p>output: DEM grid file without no-data values (gaps). Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.close.gaps_+3A_threshold">threshold</code></td>
<td>
<p>tension threshold for adjusting the interpolator (default: 0.1)</p>
</td></tr>
<tr><td><code id="rsaga.close.gaps_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rsaga.close.one.cell.gaps</code> only fill gaps whose neighbor grid cells have non-missing data.
</p>
<p>In <code>rsaga.close.gaps</code>, larger tension thresholds can be used to reduce overshoots and undershoots in the surfaces used to fill (interpolate) the gaps.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>This function uses modules 7 (<code>rsaga.close.gaps</code> and 6 <code>rsaga.close.one.cell.gaps</code> from the SAGA library <code>grid_tools</code>.
</p>
<p>SAGA GIS 2.0.5+ has a new additional module <code style="white-space: pre;">&#8288;Close Gaps with Spline&#8288;</code>, which
can be accessed using <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code> (currently no R wrapper
available). See <code>rsaga.get.usage("grid_tools","Close Gaps with Spline")</code>
or in version 2.1.0+ call <code>rsaga.html.help("grid_tools","Close Gaps with Spline")</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# using SAGA grids:
rsaga.close.gaps("rawdem.sgrd","dem.sgrd")
# using ASCII grids:
rsaga.esri.wrapper(rsaga.close.gaps,in.dem="rawdem",out.dem="dem")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.contour'>Contour Lines from a Grid</h2><span id='topic+rsaga.contour'></span>

<h3>Description</h3>

<p>Creates a contour lines shapefile from a grid file in SAGA grid format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.contour(
  in.grid,
  out.shapefile,
  zstep,
  zmin,
  zmax,
  vertex = "xy",
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.contour_+3A_in.grid">in.grid</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.contour_+3A_out.shapefile">out.shapefile</code></td>
<td>
<p>output: contour line shapefile. Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.contour_+3A_zstep">zstep</code>, <code id="rsaga.contour_+3A_zmin">zmin</code>, <code id="rsaga.contour_+3A_zmax">zmax</code></td>
<td>
<p>lower limit, upper limit, and equidistance of contour lines</p>
</td></tr>
<tr><td><code id="rsaga.contour_+3A_vertex">vertex</code></td>
<td>
<p>optional parameter: vertex type for resulting contours. Default <code>"xy"</code> (or 0). Only available with SAGA GIS 2.1.3+.
</p>

<ul>
<li><p> 0 <code>"xy"</code>
</p>
</li>
<li><p> 1 <code>"xyz"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.contour_+3A_env">env</code></td>
<td>
<p>A SAGA geoprocessing environment, see <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.contour_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>
</p>

<hr>
<h2 id='rsaga.copy.sgrd'>Create a copy of a SAGA grid file</h2><span id='topic+rsaga.copy.sgrd'></span>

<h3>Description</h3>

<p>Creates a copy of a SAGA grid file, optionally overwriting the target file if it already exists. Intended mainly for internal use by RSAGA functions, currently in particular <code><a href="#topic+rsaga.inverse.distance">rsaga.inverse.distance()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.copy.sgrd(in.grid, out.grid, overwrite = TRUE, env = rsaga.env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.copy.sgrd_+3A_in.grid">in.grid</code></td>
<td>
<p>name of a SAGA GIS grid file; file extension can be omitted</p>
</td></tr>
<tr><td><code id="rsaga.copy.sgrd_+3A_out.grid">out.grid</code></td>
<td>
<p>name of a SAGA GIS grid file; file extension can be omitted</p>
</td></tr>
<tr><td><code id="rsaga.copy.sgrd_+3A_overwrite">overwrite</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default), overwrite <code>out.grid</code> if it already exists; if <code>FALSE</code> and the <code>out.grid</code> already exists, copying will be skipped without causing an error.</p>
</td></tr>
<tr><td><code id="rsaga.copy.sgrd_+3A_env">env</code></td>
<td>
<p>a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>SAGA grid files consist of three (or more) individual files with file extensions <code>.mgrd</code>, <code>.sgrd</code> and <code>.sdat</code>. The files with these three file extensions are copied, any additional files (e.g. a history file) are ignored.
</p>

<hr>
<h2 id='rsaga.env'>Function to set up RSAGA geoprocessing environment:
Set up the RSAGA Geoprocessing Environment</h2><span id='topic+rsaga.env'></span>

<h3>Description</h3>

<p><code>rsaga.env</code> creates a list with system-dependent information on SAGA path, module path and data (working) directory. This kind of a list is required by most RSAGA geoprocessing functions and is referred to as the 'RSAGA geoprocessing environment.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.env(
  path = NULL,
  modules = NULL,
  workspace = ".",
  cmd = ifelse(Sys.info()["sysname"] == "Windows", "saga_cmd.exe", "saga_cmd"),
  version = NULL,
  cores,
  parallel = FALSE,
  root = NULL,
  lib.prefix
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.env_+3A_path">path</code></td>
<td>
<p>path in which to find <code>cmd</code>; <code>rsaga.env</code> is usually able to find SAGA on your system if it is installed; see Details.</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_modules">modules</code></td>
<td>
<p>path in which to find SAGA libraries; see Details</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_workspace">workspace</code></td>
<td>
<p>path of the working directory for SAGA; defaults to the current directory (<code>"."</code>).</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_cmd">cmd</code></td>
<td>
<p>name of the SAGA command line program; defaults to <code>saga_cmd.exe</code>, its name under Windows</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_version">version</code></td>
<td>
<p>optional character string: SAGA GIS (API) version, e.g. <code>"2.0.8"</code>; if missing, a call to <code><a href="#topic+rsaga.get.version">rsaga.get.version()</a></code> is used to determine version number of SAGA API</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_cores">cores</code></td>
<td>
<p>optional numeric argument, or <code>NA</code>: number of cores used by SAGA GIS; supported only by SAGA GIS 2.1.0 (and higher), ignored otherwise (with a warning). Multicore-enabled SAGA GIS modules such as the one used by <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code> seem to run in multicore mode by default when this argument is not specified, therefore <code>cores</code> should only be specified to use a smaller number of cores than available on a machine.</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_parallel">parallel</code></td>
<td>
<p>optional logical argument (default: <code>FALSE</code>): if <code>TRUE</code>, run RSAGA functions that are capable of parallel processing in parallel mode; note that this is completely independent of the behaviour of SAGA GIS (which can be controlled using the <code>cores</code> argument); currently only some RSAGA functions support parallel processing (e.g., <code><a href="#topic+pick.from.ascii.grid">pick.from.ascii.grid()</a></code> or <code><a href="#topic+rsaga.get.modules">rsaga.get.modules()</a></code>). <code>parallel=TRUE</code> requires that a parallel backend such as <span class="pkg">doSNOW</span> or <span class="pkg">doMC</span> is available and has been started prior to calling any parallelized RSAGA function, otherwise warnings may be generated</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_root">root</code></td>
<td>
<p>optional root path to SAGA GIS installation. It is used if RSAGA performce a search for the SAGA command line program (s. <code>search</code>).  If left empty, on Windoes <code style="white-space: pre;">&#8288;C:/&#8288;</code> is used, on Linux <code style="white-space: pre;">&#8288;/usr&#8288;</code> and on Mac OS  <code style="white-space: pre;">&#8288;/usr/local/Cellar&#8288;</code>.</p>
</td></tr>
<tr><td><code id="rsaga.env_+3A_lib.prefix">lib.prefix</code></td>
<td>
<p>character string: a possible (platform-dependent) prefix for SAGA GIS library names; if missing (recommended), a call to <code><a href="#topic+rsaga.lib.prefix">rsaga.lib.prefix()</a></code> tries to determine the correct prefix, e.g. <code>""</code> on Windows systems and <code>"lib"</code> on non-Windows systems with SAGA GIS pre-2.1.0. Try specifying <code>""</code> or <code>"lib"</code> manually if this causes problems, and contact the package maintainer if the detection mechanism fails on your system (indicate your <code>Sys.info()["sysname"]</code> and your SAGA GIS version)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IMPORTANT: Unlike R functions such as <code><a href="base.html#topic+options">options()</a></code>,  which changes and saves settings somewhere in a global variable, <code><a href="#topic+rsaga.env">rsaga.env()</a></code> does not actually 'save' any settings, it simply creates a list that can (and has to) be passed to other <code style="white-space: pre;">&#8288;rsaga.*&#8288;</code> functions. See example below.
</p>
<p>We strongly recommend to install SAGA GIS on Windows in <code style="white-space: pre;">&#8288;C:/Program Files/SAGA-GIS&#8288;</code>, <code style="white-space: pre;">&#8288;C:/Program Files (x86)/SAGA-GIS&#8288;</code>,<code style="white-space: pre;">&#8288;C:/SAGA-GIS&#8288;</code>, <code style="white-space: pre;">&#8288;C:/OSGeo4W64/apps/saga-lts&#8288;</code> or <code style="white-space: pre;">&#8288;C:/OSGeo4W64/apps/saga&#8288;</code>.
If you use a standalone version of SAGA GIS in a different path, please refer to section 2 bellow.
</p>
<p>There are three ways to create a RSAGA environment with <code>rsaga.env</code>:
</p>

<ol>
<li><p> No paths to the SAGA command line program and to the SAGA modules are specified by the user through the arguments <code>path</code> and <code>modules</code>.
On Windows <code>rsaga.env</code> tries to find the SAGA command line program in the following folders
<code style="white-space: pre;">&#8288;C:/Progra~1/SAGA&#8288;</code>, <code style="white-space: pre;">&#8288;C:/Progra~2/SAGA&#8288;</code>, <code style="white-space: pre;">&#8288;C:/Progra~1/SAGA-GIS&#8288;</code>, <code style="white-space: pre;">&#8288;C:/Progra~2/SAGA-GIS&#8288;</code>, <code style="white-space: pre;">&#8288;C:/SAGA-GIS&#8288;</code>, <code style="white-space: pre;">&#8288;C:/OSGeo4W64/apps/saga-lts&#8288;</code> and <code style="white-space: pre;">&#8288;C:/OSGeo4W64/apps/saga&#8288;</code>.
If this fails and attempt is being made to find the SAGA command line program with a search on <code style="white-space: pre;">&#8288;C:/&#8288;</code>
(The drive letter can be changed with the <code>root</code> argument).
The subfolder <code>tools</code> (SAGA Version &lt; 3.0.0 subfolder <code>modules</code>) is checked for the SAGA module libraries.
On Unix systems <code>rsaga.env</code> tries to find the SAGA command line program in various default paths.
Additionally, on Unix systems the PATH environment variable is checked for the path to the SAGA command line program
and the SAGA_MLB environment variable is checked for the SAGA module libraries.
If this fails, a search for the SAGA command line program and the module libraries is performed on <code style="white-space: pre;">&#8288;/usr&#8288;</code>.
If no SAGA command line program can be found, please specify the paths as described in section 2.
</p>
</li>
<li><p> The user specifies both the path to the SAGA command line program and
to the SAGA module libraries. Both paths are checked if they are valid. Use this if SAGA GIS is located in a non-standard path
or if you use more than one SAGA GIS version.
</p>
</li>
<li><p> The user specifies only the path to the SAGA command line program. A search for the SAGA modules is performed as described in section 1.
</p>
</li></ol>



<h3>Value</h3>

<p>A list with components <code>workspace</code>, <code>cmd</code>, <code>path</code>, <code>modules</code>, <code>version</code>, <code>cores</code> and <code>parallel</code> with values as passed to <code>rsaga.env</code> or default values as described in the Details section.
</p>


<h3>Note</h3>

<p>Note that the default <code>workspace</code> is <code>"."</code>, not <code>getwd()</code>; i.e. the default SAGA workspace folder is not fixed, it changes each time you change the R working directory using <code>setwd</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning and Marc Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.get.version">rsaga.get.version()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Check the default RSAGA environment on your computer:
myenv &lt;- rsaga.env()
myenv
# SAGA data in C:/sagadata, binaries in C:/SAGA-GIS, modules in C:/SAGA-GIS/modules:
myenv &lt;- rsaga.env(workspace="C:/sagadata", path="C:/SAGA-GIS")
# Unix: SAGA in /usr/bin (instead of the default /usr/local/bin),
# and modules in /use/lib/saga:
# myenv &lt;- rsaga.env(path="/usr/bin")
# Use the 'myenv' environment for SAGA geoprocessing:
rsaga.hillshade("dem","hillshade",env=myenv)
# ...creates (or overwrites) grid "C:/sagadata/hillshade.sgrd"
# derived from digital elevation model "C:/sagadata/dem.sgrd"

# Same calculation with different SAGA version:
# (I keep several versions in SAGA-GIS_x.x.x folders:)
myenv05 = rsaga.env(path = "C:/Progra~1/SAGA-GIS_2.0.5")
rsaga.hillshade("dem","hillshade205",env=myenv05)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.esri.to.sgrd'>Convert ESRI ASCII/binary grids to SAGA grids</h2><span id='topic+rsaga.esri.to.sgrd'></span>

<h3>Description</h3>

<p><code>rsaga.esri.to.sgrd</code> converts grid files from ESRI's ASCII (.asc) and binary (.flt) format to SAGA's (version 2) grid format (.sgrd).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.esri.to.sgrd(
  in.grids,
  out.sgrds = set.file.extension(in.grids, ".sgrd"),
  in.path,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.esri.to.sgrd_+3A_in.grids">in.grids</code></td>
<td>
<p>character vector of ESRI ASCII/binary grid files (default file extension: <code>.asc</code>); files should be located in folder <code>in.path</code></p>
</td></tr>
<tr><td><code id="rsaga.esri.to.sgrd_+3A_out.sgrds">out.sgrds</code></td>
<td>
<p>character vector of output SAGA grid files; defaults to <code>in.grids</code> with file extension being replaced by <code>.sgrd</code>, which is also the default extension if file names without extension are specified; files will be placed in the current SAGA workspace (default: <code><a href="#topic+rsaga.env">rsaga.env</a>()$workspace</code>, or <code>env$workspace</code> if an <code>env</code> argument is provided</p>
</td></tr>
<tr><td><code id="rsaga.esri.to.sgrd_+3A_in.path">in.path</code></td>
<td>
<p>folder with <code>in.grids</code></p>
</td></tr>
<tr><td><code id="rsaga.esri.to.sgrd_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>
<p>If multiple <code>in.grids</code> are converted, the result will be a vector of numerical error codes of the same length, or the combination of the console outputs with <code>c()</code>.
</p>


<h3>Note</h3>

<p>This function uses module 1 from the SAGA library <code>io_grid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.esri.wrapper">rsaga.esri.wrapper()</a></code> for an efficient way of applying RSAGA to ESRI ASCII/binary grids; <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>

<hr>
<h2 id='rsaga.esri.wrapper'>Use RSAGA functions for ESRI grids</h2><span id='topic+rsaga.esri.wrapper'></span>

<h3>Description</h3>

<p>This wrapper converts input grid files provided in ESRI binary (.flt) or ASCII (.asc) formats to SAGA's (version 2) grid format, calls the RSAGA geoprocessing function, and converts the output grids back to the ESRI grid format. Conversion can also be limited to either input or output grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.esri.wrapper(
  fun,
  in.esri = TRUE,
  out.esri = TRUE,
  env = rsaga.env(),
  esri.workspace = env$workspace,
  format = "ascii",
  georef = "corner",
  prec = 5,
  esri.extension,
  condensed.res = TRUE,
  clean.up = TRUE,
  intern = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.esri.wrapper_+3A_fun">fun</code></td>
<td>
<p>function: one of the RSAGA geoprocessing functions, such as <code><a href="#topic+rsaga.close.gaps">rsaga.close.gaps()</a></code> or <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code> etc.</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_in.esri">in.esri</code></td>
<td>
<p>logical: are input grids provided as ESRI grids (<code>in.esri=TRUE</code>) or as SAGA grids?</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_out.esri">out.esri</code></td>
<td>
<p>logical: should output grids be converted to ESRI grids?</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_env">env</code></td>
<td>
<p>RSAGA environment as returned by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_esri.workspace">esri.workspace</code></td>
<td>
<p>directory for the input and output ESRI ASCII/binary grids</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_format">format</code></td>
<td>
<p>output file format, either <code>"ascii"</code> (default; equivalent: <code>format=1</code>) for ASCII grids or <code>"binary"</code> (equivalent: <code>0</code>) for binary ESRI grids (<code>.flt</code>).</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_georef">georef</code></td>
<td>
<p>character: <code>"corner"</code> (equivalent numeric code: <code>0</code>) or <code>"center"</code> (default; equivalent: <code>1</code>). Determines whether the georeference will be related to the center or corner of its extreme lower left grid cell.</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_prec">prec</code></td>
<td>
<p>number of digits when writing floating point values to ASCII grid files (only relevant if <code>out.esri=TRUE</code>).</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_esri.extension">esri.extension</code></td>
<td>
<p>extension for input/output ESRI grids: defaults to <code>.asc</code> for <code>format="ascii"</code>, and to <code>.flt</code> for <code>format="binary"</code></p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_condensed.res">condensed.res</code></td>
<td>
<p>logical: return only results of the RSAGA geoprocessing function <code>fun</code> (<code>condensed.res=TRUE</code>), or include the results of the import and export operations, i.e. the calls to <code><a href="#topic+rsaga.esri.to.sgrd">rsaga.esri.to.sgrd()</a></code> and <code><a href="#topic+rsaga.sgrd.to.esri">rsaga.sgrd.to.esri()</a></code>? (see Value)</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_clean.up">clean.up</code></td>
<td>
<p>logical: delete intermediate SAGA grid files?</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_intern">intern</code></td>
<td>
<p><code>intern</code> argument to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>; see Value</p>
</td></tr>
<tr><td><code id="rsaga.esri.wrapper_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code>; NOTE: ESRI ASCII/float raster file names should NOT include the file extension (.asc, .flt); the file extension is defined by the <code>esri.extension</code> and <code>format</code> arguments!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ESRI ASCII/float raster file names should NOT include the file extension (.asc, .flt); the file extension is defined by the <code>esri.extension</code> and <code>format</code> arguments!
</p>


<h3>Value</h3>

<p>The object returned depends on the <code>condensed.res</code> arguments and the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>.
</p>
<p>If <code>condensed.res=TRUE</code> and <code>intern=FALSE</code>, a single numerical error code (0: success) is returned. If <code>condensed.res=TRUE</code> and <code>intern=TRUE</code> (default), a character vector with the module's console  output is returned (invisibly).
</p>
<p>If <code>condensed.res=FALSE</code> the result is a list with components <code>in.res</code>, <code>geoproc.res</code> and <code>out.res</code>. Each of these components is either an error code (for <code>intern=FALSE</code>) or  (for <code>intern=TRUE</code>) a character vector with the console output of the input (<code><a href="#topic+rsaga.esri.to.sgrd">rsaga.esri.to.sgrd()</a></code>), the geoprocessing (<code>fun</code>), and the output conversion (<code><a href="#topic+rsaga.sgrd.to.esri">rsaga.sgrd.to.esri()</a></code>) step, respectively. For <code>in.esri=FALSE</code> or <code>out.esri=FALSE</code>, the corresponding component is <code>NULL</code>.
</p>


<h3>Note</h3>

<p>Note that the intermediate grids as well as the output grids may overwrite existing files with the same file names without prompting the user. See example below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.esri.to.sgrd">rsaga.esri.to.sgrd()</a></code>, <code><a href="#topic+rsaga.sgrd.to.esri">rsaga.sgrd.to.esri()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rsaga.esri.wrapper(rsaga.hillshade,in.dem="dem",out.grid="hshd",condensed.res=FALSE,intern=FALSE)
# if successful, returns list(in.res=0,geoproc.res=0,out.res=0),
# and writes hshd.asc; intermediate files dem.sgrd, dem.hgrd, dem.sdat,
# hshd.sgrd, hshd.hgrd, and hshd.sdat are deleted.
# hshd.asc is overwritten if it already existed.

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.fill.sinks'>Fill Sinks</h2><span id='topic+rsaga.fill.sinks'></span>

<h3>Description</h3>

<p>Several methods for filling closed depressions in digital elevation models that would affect hydrological modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.fill.sinks(
  in.dem,
  out.dem,
  method = "planchon.darboux.2001",
  out.flowdir,
  out.wshed,
  minslope,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.fill.sinks_+3A_in.dem">in.dem</code></td>
<td>
<p>Input: digital elevation model (DEM) as SAGA grid file (default extension: <code>.sgrd</code>).</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_out.dem">out.dem</code></td>
<td>
<p>Output: filled, depression-free DEM (SAGA grid file). Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_method">method</code></td>
<td>
<p>The depression filling algorithm to be used (character). One of <code>"planchon.darboux.2001"</code> (default), <code>"wang.liu.2006"</code>, or <code>"xxl.wang.liu.2006"</code>.</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_out.flowdir">out.flowdir</code></td>
<td>
<p>(only for <code>"wang.liu.2001"</code>): Optional output grid file for computed flow directions (see Notes).</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_out.wshed">out.wshed</code></td>
<td>
<p>(only for <code>"wang.liu.2001"</code>): Optional output grid file for watershed basins.</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_minslope">minslope</code></td>
<td>
<p>Minimum slope angle (in degree) preserved between adjacent grid cells (default value of <code>0.01</code> only for <code>method="planchon.darboux.2001"</code>, otherwise no default).</p>
</td></tr>
<tr><td><code id="rsaga.fill.sinks_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function bundles three SAGA modules for filling sinks using three different algorithms (<code>method</code> argument).
</p>
<p><code>"planchon.darboux.2001"</code>: The algorithm of Planchon and Darboux (2001) consists of increasing the elevation of pixels in closed depressions until the sink disappears and a minimum slope angle of <code>minslope</code> (default: <code>0.01</code> degree) is established.
</p>
<p><code>"wang.liu.2006"</code>: This module uses an algorithm proposed by Wang and Liu (2006) to identify and fill surface depressions in DEMs. The method was enhanced to allow the creation of hydrologically sound elevation models, i.e. not only to fill the depressions but also to  preserve a downward slope along the flow path.  If desired, this  is accomplished by preserving a minimum slope gradient (and thus elevation difference) between cells. This is the fully featured version of the module creating a depression-free DEM, a flow path grid and a grid with watershed basins. If you encounter problems processing large data sets (e.g. LIDAR data) with this module try the basic version (<code>xxl.wang.lui.2006</code>).
</p>
<p><code>"xxl.wang.liu.2006"</code>: This modified algorithm after Wang and Liu (2006) is designed to work on large data sets.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>
<p>The function writes SAGA grid files containing of the depression-free preprocessed DEM, and optionally the flow directions and watershed basins.
</p>


<h3>Note</h3>

<p>The flow directions are coded as 0 = north, 1 = northeast, 2 = east, ..., 7 = northwest.
</p>
<p>If <code>minslope=0</code>, depressions will only be filled until a horizontal surface is established, which may not be helpful for hydrological modeling.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Volker Wichmann (SAGA module)
</p>


<h3>References</h3>

<p>Planchon, O., and F. Darboux (2001): A fast, simple and versatile algorithm to fill the depressions of digital elevation models. Catena 46: 159-176.
</p>
<p>Wang, L. &amp; H. Liu (2006): An efficient method for identifying and filling surface depressions in digital elevation models for hydrologic analysis and modelling. International Journal of Geographical Information Science, Vol. 20, No. 2: 193-213.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.sink.removal">rsaga.sink.removal()</a></code>, <code><a href="#topic+rsaga.sink.route">rsaga.sink.route()</a></code>.
</p>

<hr>
<h2 id='rsaga.filter.gauss'>Gauss Filter</h2><span id='topic+rsaga.filter.gauss'></span>

<h3>Description</h3>

<p>Smooth a grid using a Gauss filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.filter.gauss(
  in.grid,
  out.grid,
  sigma,
  radius = ceiling(2 * sigma),
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.filter.gauss_+3A_in.grid">in.grid</code></td>
<td>
<p>input: SAGA GIS grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.filter.gauss_+3A_out.grid">out.grid</code></td>
<td>
<p>output: SAGA GIS grid file</p>
</td></tr>
<tr><td><code id="rsaga.filter.gauss_+3A_sigma">sigma</code></td>
<td>
<p>numeric, &gt;0.0001: standard deviation parameter of Gauss filter</p>
</td></tr>
<tr><td><code id="rsaga.filter.gauss_+3A_radius">radius</code></td>
<td>
<p>positive integer: radius of moving window</p>
</td></tr>
<tr><td><code id="rsaga.filter.gauss_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.filter.gauss_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.filter.simple">rsaga.filter.simple()</a></code>
</p>

<hr>
<h2 id='rsaga.filter.simple'>Simple Filters</h2><span id='topic+rsaga.filter.simple'></span>

<h3>Description</h3>

<p>Apply a smoothing, sharpening or edge filter to a SAGA grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.filter.simple(
  in.grid,
  out.grid,
  mode = "circle",
  method = c("smooth", "sharpen", "edge"),
  radius,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.filter.simple_+3A_in.grid">in.grid</code></td>
<td>
<p>input: SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_out.grid">out.grid</code></td>
<td>
<p>output: SAGA grid file</p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_mode">mode</code></td>
<td>
<p>character or numeric: shape of moving window, either <code>"square"</code> (=0) or <code>"circle"</code> (=1, default)</p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_method">method</code></td>
<td>
<p>character or numeric: <code>"smooth"</code> (=0), <code>"sharpen"</code> (=1), or <code>"edge"</code> (=2)</p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_radius">radius</code></td>
<td>
<p>positive integer: radius of moving window</p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.filter.simple_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.filter.gauss">rsaga.filter.gauss()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: rsaga.filter.simple("dem","dem-smooth",radius=4)
</code></pre>

<hr>
<h2 id='rsaga.geoprocessor'>Generic R interface for SAGA modules</h2><span id='topic+rsaga.geoprocessor'></span>

<h3>Description</h3>

<p>This function is the workhorse of the R&ndash;SAGA interface: It calls the SAGA command line tool to run SAGA modules and pass arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.geoprocessor(
  lib,
  module = NULL,
  param = list(),
  show.output.on.console = TRUE,
  invisible = TRUE,
  intern = TRUE,
  prefix = NULL,
  flags = ifelse(show.output.on.console, "q", "s"),
  cores,
  env = rsaga.env(),
  display.command = FALSE,
  reduce.intern = TRUE,
  check.module.exists = TRUE,
  warn = options("warn")$warn,
  argsep = " ",
  check.parameters = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.geoprocessor_+3A_lib">lib</code></td>
<td>
<p>Name of the SAGA library to be called (see Details).</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_module">module</code></td>
<td>
<p>Number (<code style="white-space: pre;">&#8288;&gt;=0&#8288;</code>) or name of the module to called within the library <code>lib</code> (see Details).</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_param">param</code></td>
<td>
<p>A list of named arguments to be passed to the SAGA module (see Examples).</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_show.output.on.console">show.output.on.console</code></td>
<td>
<p>a logical (default: <code>TRUE</code>), indicates whether to capture the output of the command and show it on the R console (see <code><a href="base.html#topic+system">system()</a></code>).</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_invisible">invisible</code></td>
<td>
<p>a logical, indicates whether the command window  should be visible on the screen.</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_intern">intern</code></td>
<td>
<p>a logical, indicates whether to make the output of the command an R object</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_prefix">prefix</code></td>
<td>
<p>optional character string: prefix such as <code>"-h"</code> used in the <code>saga_cmd</code> call; mostly for internal purposes; call <code>saga_cmd -h</code> from the command line for details; see also <code>flags</code></p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_flags">flags</code></td>
<td>
<p>optional character string indicating any command line flags; supported only by SAGA GIS 2.1.0 (and higher), quietly ignored otherwise: <code>"q"</code>: no progress report (the default for <code>show.output.on.console=TRUE</code>); <code>"r"</code>: no messages report; <code>"s"</code>: silent mode, i.e. no progress and no messages report  (the default for <code>show.output.on.console=FALSE</code>); other flag options probably not relevant within RSAGA</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_cores">cores</code></td>
<td>
<p>optional numeric argument, or <code>NA</code>: number of cores used by SAGA GIS; supported only by SAGA GIS 2.1.0 (and higher), ignored otherwise (with a warning); overwrites the <code>cores</code> setting specified in the <code>env</code> argument (see <code><a href="#topic+rsaga.env">rsaga.env()</a></code>). Multicore-enabled SAGA GIS modules such as the one used by <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code> seem to run in multicore mode by default when this argument is not specified, therefore <code>cores</code> should only be specified to use a smaller number of cores than available on a machine.</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_env">env</code></td>
<td>
<p>A SAGA geoprocessing environment, i.e. a list with information on the SAGA and SAGA modules paths and the name of the working directory in which to look for input and output files. (Defaults: see <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.)</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_display.command">display.command</code></td>
<td>
<p>Display the DOS command line for executing the SAGA module (including all the arguments to be passed). Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_reduce.intern">reduce.intern</code></td>
<td>
<p>If <code>intern=TRUE</code>, reduce the text output of SAGA returned to R by eliminating redundant lines showing the progress of module execution etc. (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_check.module.exists">check.module.exists</code></td>
<td>
<p>logical (default: <code>TRUE</code>): call <code><a href="#topic+rsaga.module.exists">rsaga.module.exists()</a></code> to determine if the specified module can be called in the current SAGA installation</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_warn">warn</code></td>
<td>
<p>logical (default: <code>TRUE</code>): for internal purposes - can be used to suppress warning messages generated by failed SAGA_CMD calls; currently used by <code><a href="#topic+rsaga.get.lib.modules">rsaga.get.lib.modules()</a></code> and related functions; see <code><a href="base.html#topic+options">options()</a></code> argument <code>warn</code> for details</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_argsep">argsep</code></td>
<td>
<p>character (default: <code>" "</code>; currently for internal use): defines the character symbol used as a separator between each argument name and argument value passed to <code>saga_cmd</code>. SAGA GIS 2.1.0 (RC1) seems to move toward <code>"="</code> as a separator, but <code>" "</code> still works and some modules (e.g. the used by <code>rsaga.pisr</code>) don't seem to work with <code>argsep="="</code>. Future releases of RSAGA may change the default <code>argsep</code> value and/or delete or ignore this argument and/or move it to <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_check.parameters">check.parameters</code></td>
<td>
<p>logical(default: <code>TRUE</code>): Check if correct parameters are used.</p>
</td></tr>
<tr><td><code id="rsaga.geoprocessor_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="base.html#topic+system">base::system()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This workhorse function establishes the interface between the SAGA command line program and R by submitting a system call. This is a low-level function that may be used for directly accessing SAGA; specific functions such as <code>rsaga.hillshade</code> are intended to be more user-friendly interfaces to the most frequently used SAGA modules. These higher-level interfaces support default values for the arguments and perform some error checking; they should therefore be preferred if available.
</p>
<p>A warning is issued if the RSAGA version is not one of 2.0.4-2.0.8 or 2.1.0-2.1.4
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to <code><a href="base.html#topic+system">system()</a></code>.
</p>
<p>If <code>intern=FALSE</code>, a numerical error/success code is returned, where a value of <code>0</code> corresponds to success and a non-zero value indicates an error. Note however that the function always returns a success value of <code>0</code> if <code>wait=FALSE</code>, i.e. if it does not wait for SAGA to finish.
</p>
<p>If <code>intern=TRUE</code> (default), the console output of SAGA is returned as a character vector. This character vector lists the input file names and modules arguments, and gives a more or less detailed report of the function's progress. Redundant information can be cancelled out by setting <code>reduce.intern=TRUE</code>.
</p>


<h3>Note</h3>

<p>Existing output files will be overwritten by SAGA without prompting!
</p>
<p>If a terrain analysis function is not directly interfaced by one of the RSAGA functions, you might still find it in the growing set of SAGA libraries and modules. The names of all libraries available in your SAGA installation can be obtained using <code><a href="#topic+rsaga.get.libraries">rsaga.get.libraries()</a></code> (or by checking the directory listing of the <code>modules</code> folder in the SAGA directory). The names and numeric codes of all available modules (globally or within a specific library) are retrieved by <code><a href="#topic+rsaga.get.modules">rsaga.get.modules()</a></code>. Full-text search in library and module names is performed by <code><a href="#topic+rsaga.search.modules">rsaga.search.modules()</a></code>. For information on the usage of SAGA command line modules, see <code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>, or the RSAGA interface function if available.
</p>
<p><code>display.command=TRUE</code> is mainly intended for debugging purposes to check if all arguments are passed correctly to SAGA CMD.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface); Olaf Conrad and the SAGA development team (SAGA development)
</p>


<h3>References</h3>

<p>Brenning, A., 2008. Statistical geocomputing combining R and
SAGA: The example of landslide susceptibility analysis with
generalized additive models. In J. Boehner, T. Blaschke and
L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger
Beitraege zur Physischen Geographie und
Landschaftsoekologie, vol. 19), p. 23-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.env">rsaga.env()</a></code>, <code><a href="#topic+rsaga.get.libraries">rsaga.get.libraries()</a></code>, <code><a href="#topic+rsaga.get.modules">rsaga.get.modules()</a></code>, <code><a href="#topic+rsaga.search.modules">rsaga.search.modules()</a></code>, <code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>; <code><a href="#topic+rsaga.esri.wrapper">rsaga.esri.wrapper()</a></code> for a wrapper for ESRI ASCII/binary grids; <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code> and other higher-level functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rsaga.hillshade("dem","hillshade",exaggeration=2)
# using the RSAGA geoprocessor:
rsaga.geoprocessor("ta_lighting",0,list(ELEVATION="dem.sgrd",SHADE="hillshade",EXAGGERATION=2))
# equivalent DOS command line call:
# saga_cmd.exe ta_lighting 0 -ELEVATION dem.sgrd -SHADE hillshade -EXAGGERATION 2

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.get.modules'>Find SAGA libraries and modules</h2><span id='topic+rsaga.get.modules'></span><span id='topic+rsaga.get.libraries'></span><span id='topic+rsaga.get.lib.modules'></span><span id='topic+rsaga.module.exists'></span><span id='topic+rsaga.search.modules'></span>

<h3>Description</h3>

<p>These functions list the SAGA libraries (<code>rsaga.get.libraries</code>) and modules (<code>rsaga.get.lib.modules</code>, <code>rsaga.get.modules</code>) available in a SAGA installation, and allow to perform a full-text search among these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.get.modules(
  libs,
  env = rsaga.env(),
  interactive = FALSE,
  parallel = env$parallel
)

rsaga.get.libraries(path = rsaga.env()$modules, dll)

rsaga.get.lib.modules(lib, env = rsaga.env(), interactive = FALSE)

rsaga.module.exists(libs, module, env = rsaga.env(), ...)

rsaga.search.modules(
  text,
  modules,
  search.libs = TRUE,
  search.modules = TRUE,
  env = rsaga.env(),
  ignore.case = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.get.modules_+3A_libs">libs</code></td>
<td>
<p>character vector with the names of libraries in which to look for modules; if missing, all libraries will be processed</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_env">env</code></td>
<td>
<p>a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_interactive">interactive</code></td>
<td>
<p>logical (default <code>FALSE</code>): should modules be returned that can only be executed in interactive mode (i.e. using SAGA GUI)?</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_parallel">parallel</code></td>
<td>
<p>logical (defaults to <code>env$parallel</code>): if <code>TRUE</code>, run in parallel mode; requires a parallel backend such as <span class="pkg">doSNOW</span> or <span class="pkg">doMC</span></p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_path">path</code></td>
<td>
<p>path of SAGA library files (<code>modules</code> subfolder in the SAGA installation folder); defaults to the path determined by <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_dll">dll</code></td>
<td>
<p>file extension of dynamic link libraries</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_lib">lib</code></td>
<td>
<p>character string with the name of the library in which to look for modules</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_module">module</code></td>
<td>
<p>module name or numeric code</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_...">...</code></td>
<td>
<p>currently only <code>interactive</code> to be passed on to <code>rsaga.get.lib.modules</code></p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_text">text</code></td>
<td>
<p>character string to be searched for in the names of available libraries and/or modules</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_modules">modules</code></td>
<td>
<p>optional list: result of <code>rsaga.get.modules</code>; if missing, a list of available modules will be retrieved using that function</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_search.libs">search.libs</code></td>
<td>
<p>logical (default <code>TRUE</code>); see <code>search.modules</code></p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_search.modules">search.modules</code></td>
<td>
<p>logical (default <code>TRUE</code>): should <code>text</code> be searched for in library and/or module names?</p>
</td></tr>
<tr><td><code id="rsaga.get.modules_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical (default <code>FALSE</code>): should the text search in library/module names be case sensitive?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>rsaga.get.libraries</code> returns a character vector with the names of all SAGA libraries available in the folder <code>env$modules</code>.
</p>
<p><code>rsaga.get.lib.modules</code> returns a <code>data.frame</code> with:
</p>

<ul>
<li><p>name the names of all modules in library <code>lib</code>,
</p>
</li>
<li><p>code their numeric identifiers,
</p>
</li>
<li><p>interactive and a logical variable indicating whether a module can only be executed in interactive (SAGA GUI) mode.
</p>
</li></ul>

<p><code>rsaga.get.modules</code> returns a list with, for each SAGA library in <code>libs</code>, a <code>data.frame</code> with module information as given by <code>rsaga.get.lib.modules</code>. If <code>libs</code> is missing, all modules in all libraries will be retrieved.
</p>


<h3>Note</h3>

<p>For information on the usage of SAGA command line modules, see <code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>, or <code><a href="#topic+rsaga.html.help">rsaga.html.help()</a></code> (in SAGA GIS 2.1.0+), or the RSAGA interface function, if available.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>, <code><a href="#topic+rsaga.html.help">rsaga.html.help()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make sure that 'rsaga.env' can find 'saga_cmd.exe'
# before running this:
rsaga.get.libraries()
# list all modules in my favorite libraries:
rsaga.get.modules(c("io_grid", "grid_tools", "ta_preprocessor",
    "ta_morphometry", "ta_lighting", "ta_hydrology"))
# list *all* modules (quite a few!):
# rsaga.get.modules(interactive=TRUE)

# find modules that remove sink from DEMs:
rsaga.search.modules("sink")
# find modules that close gaps (no-data areas) in grids:
rsaga.search.modules("gap")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.get.modules.path'>Internal functions that determine OS-specific path in which modules might be located.</h2><span id='topic+rsaga.get.modules.path'></span>

<h3>Description</h3>

<p>Internal functions that determine OS-specific path in which modules might be located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.get.modules.path(sysname = Sys.info()["sysname"], saga.path, root, cmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.get.modules.path_+3A_sysname">sysname</code></td>
<td>
<p>character: name of the operating system, determined by default by <code><a href="base.html#topic+Sys.info">base::Sys.info()</a></code>: e.g., <code>"Windows"</code>, <code>"Linux"</code>, <code>"Darwin"</code> (for Mac OSX), or <code>"FreeBSD"</code></p>
</td></tr>
<tr><td><code id="rsaga.get.modules.path_+3A_saga.path">saga.path</code></td>
<td>
<p>character: path with SAGA GIS binaries, as determined (e.g.) by <code>rsaga.default.path</code></p>
</td></tr>
<tr><td><code id="rsaga.get.modules.path_+3A_root">root</code></td>
<td>
<p>root path to SAGA GIS installation</p>
</td></tr>
<tr><td><code id="rsaga.get.modules.path_+3A_cmd">cmd</code></td>
<td>
<p>name of the SAGA command line program</p>
</td></tr>
</table>

<hr>
<h2 id='rsaga.get.usage'>Usage of SAGA command line modules</h2><span id='topic+rsaga.get.usage'></span>

<h3>Description</h3>

<p><code>rsaga.get.usage</code> provides information on the usage of and arguments required by SAGA command line modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.get.usage(lib, module, env = rsaga.env(), show = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.get.usage_+3A_lib">lib</code></td>
<td>
<p>name of the SAGA library</p>
</td></tr>
<tr><td><code id="rsaga.get.usage_+3A_module">module</code></td>
<td>
<p>name or numeric identifier of SAGA module in library <code>lib</code></p>
</td></tr>
<tr><td><code id="rsaga.get.usage_+3A_env">env</code></td>
<td>
<p>a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.get.usage_+3A_show">show</code></td>
<td>
<p>logical (default: <code>TRUE</code>); display usage in the R console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to provide information required to use the
<code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code> and for writing your own high-level interface
function for SAGA modules. R&ndash;SAGA interfaces already exist for some SAGA modules,
e.g. <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code>, <code><a href="#topic+rsaga.local.morphometry">rsaga.local.morphometry()</a></code>, but there
are many more.
</p>


<h3>Value</h3>

<p>The character vector with usage information is invisibly returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.html.help">rsaga.html.help()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>, <code><a href="#topic+rsaga.get.modules">rsaga.get.modules()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rsaga.get.usage("io_grid",1)
rsaga.get.usage("ta_preprocessor",2)
rsaga.get.usage("ta_morphometry",0)
# in SAGA GIS 2.1.0+, compare:
rsaga.html.help("io_grid",1)
# etc.

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.get.version'>Determine SAGA GIS version</h2><span id='topic+rsaga.get.version'></span>

<h3>Description</h3>

<p>Determine SAGA GIS version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.get.version(env = rsaga.env(version = NA), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.get.version_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code>. Note that <code>version=NA</code> ensures that <code><a href="#topic+rsaga.env">rsaga.env()</a></code> won't call <code>rsaga.get.version</code> itself.</p>
</td></tr>
<tr><td><code id="rsaga.get.version_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first attempts to determine the SAGA version directly through a system call <code>saga_cmd --version</code>, which is supported by SAGA GIS 2.0.8+. If this fails, <code>saga_cmd -h</code> is called, and it is attempted to extract the version number of the SAGA API from the output generated, which works for 2.0.4 - 2.0.7.
</p>


<h3>Value</h3>

<p>A character string defining the SAGA GIS (API) version. E.g., <code>"2.0.8"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myenv &lt;- rsaga.env()
myenv$version
# rsaga.env actually calls rsaga.get.version:
rsaga.get.version()

# I keep several versions of SAGA GIS in SAGA-GIS_2.0.x folders:
myenv05 = rsaga.env(path = "C:/Progra~1/SAGA-GIS_2.0.5", version = NA)
# Check if it's really version 2.0.5 as suggested by the folder name:
rsaga.get.version(env = myenv05)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.grid.calculus'>SAGA Module Grid Calculus</h2><span id='topic+rsaga.grid.calculus'></span><span id='topic+rsaga.linear.combination'></span>

<h3>Description</h3>

<p>Perform Arithmetic Operations on Grids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.grid.calculus(in.grids, out.grid, formula, env = rsaga.env(), ...)

rsaga.linear.combination(
  in.grids,
  out.grid,
  coef,
  cf.digits = 16,
  remove.zeros = FALSE,
  remove.ones = TRUE,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.grid.calculus_+3A_in.grids">in.grids</code></td>
<td>
<p>input character vector: SAGA grid files (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_out.grid">out.grid</code></td>
<td>
<p>output: grid file resulting from the cell-by-cell application of 'formula' to the grids. Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_formula">formula</code></td>
<td>
<p>character string of formula specifying the arithmetic operation to be performed on the <code>in.grids</code> (see Details); if this is a formula, only the right hand side will be used.</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment, generated by a call to <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_coef">coef</code></td>
<td>
<p>numeric: coefficient vector to be used for the linear combination of the <code>in.grids</code>. If <code>coef</code> as one more element than <code>in.grids</code>, the first one will be interpreted as an intercept.</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_cf.digits">cf.digits</code></td>
<td>
<p>integer: number of digits used when converting the <code>coef</code>ficients to character strings (trailing zeros will be removed)</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_remove.zeros">remove.zeros</code></td>
<td>
<p>logical: if <code>TRUE</code>, terms (grids) with coefficient (numerically) equal to zero (after rounding to <code>cf.digits</code> digits) will be removed from the formula</p>
</td></tr>
<tr><td><code id="rsaga.grid.calculus_+3A_remove.ones">remove.ones</code></td>
<td>
<p>logical: if <code>TRUE</code> (the default), factors equal to 1 (after rounding to <code>cf.digits</code> digits) will be removed from the formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>in.grids</code> are represented in the <code>formula</code> by the letters <code>a</code> (for <code>in.grids[1]</code>), <code>b</code> etc. Thus, if <code>in.grids[1]</code> is Landsat TM channel 3 and <code>in.grids[2]</code> is channel 4, the NDVI formula (TM3-TM4)/(TM3+TM4) can be represented  by the character string <code>"(a-b)/(a+b)"</code> (any spaces are removed) or the formula <code>~(a-b)/(a+b)</code> in the <code>formula</code> argument.
</p>
<p>In addition to +, -, *, and /, the following operators and functions are available for the <code>formula</code> definition:
+ <code class="reqn">\hat{\ }</code> power
+ <code>sin(a)</code> sine
+ <code>cos(a)</code> cosine
+ <code>tan(a)</code> tangent
+ <code>asin(a)</code> arc sine
+ <code>acos(a)</code> arc cosine
+ <code>atan(a)</code> arc tangent
+ <code>atan2(a,b)</code> arc tangent of b/a
+ <code>abs(a)</code> absolute value
+ <code>int(a)</code> convert to integer
+ <code>sqr(a)</code> square
+ <code>sqrt(a)</code> square root
+ <code>ln(a)</code> natural logarithm
+ <code>log(a)</code> base 10 logarithm
+ <code>mod(a,b)</code> modulo
+ <code>gt(a, b)</code> returns 1 if a greater b
+ <code>lt(a, b)</code> returns 1 if a lower b
+ <code>eq(a, b)</code> returns 1 if a equal b
+ <code>ifelse(switch, x, y)</code> returns x if switch equals 1 else y
</p>
<p>Using <code>remove.zeros=FALSE</code> might have the side effect that no data areas in the grid with coefficient 0 are passed on to the results grid. (To be confirmed.)
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+local.function">local.function()</a></code>, <code><a href="#topic+focal.function">focal.function()</a></code>, and <code><a href="#topic+multi.focal.function">multi.focal.function()</a></code> for a more flexible framework for combining grids or applying local and focal functions; <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# using SAGA grids:
# calculate the NDVI from Landsat TM bands 3 and 4:
rsaga.grid.calculus(c("tm3.sgrd","tm4.sgrd"), "ndvi.sgrd", ~(a-b)/(a+b))
# apply a linear regression equation to grids:
coefs = c(20,-0.6)
# maybe from a linear regression of mean annual air temperature (MAAT)
# against elevation - something like:
# coefs = coef( lm( maat ~ elevation ) )
rsaga.linear.combination("elevation.sgrd", "maat.sgrd", coefs)
# equivalent:
rsaga.grid.calculus("elevation.sgrd", "maat.sgrd", "20 - 0.6*a")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.grid.to.points'>Convert SAGA grid file to point shapefile</h2><span id='topic+rsaga.grid.to.points'></span><span id='topic+rsaga.grid.to.points.randomly'></span>

<h3>Description</h3>

<p>Convert SAGA grid file to point (or polygon) shapefile - either completely or only a random sample of grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.grid.to.points(
  in.grids,
  out.shapefile,
  in.clip.polygons,
  exclude.nodata = TRUE,
  type = "nodes",
  env = rsaga.env(),
  ...
)

rsaga.grid.to.points.randomly(in.grid, out.shapefile, freq, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.grid.to.points_+3A_in.grids">in.grids</code></td>
<td>
<p>Input: names of (possibly several) SAGA GIS grid files to be converted into a point shapefile.</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_out.shapefile">out.shapefile</code></td>
<td>
<p>Output: point shapefile (default extension: <code>.shp</code>). Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_in.clip.polygons">in.clip.polygons</code></td>
<td>
<p>optional polygon shapefile to be used for clipping/masking an area</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_exclude.nodata">exclude.nodata</code></td>
<td>
<p>logical (default: <code>TRUE</code>): skip 'nodata' grid cells?</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_type">type</code></td>
<td>
<p>character string: <code>"nodes"</code>: create point shapefile of grid center points; <code>"cells"</code> (only supported by SAGA GIS 2.0.6+): create polygon shapefile with grid cell boundaries</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code>; required by <code>rsaga.grid.to.points</code> to determine version-dependent SAGA module name and arguments</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_in.grid">in.grid</code></td>
<td>
<p>Input: SAGA grid file from which to sample.</p>
</td></tr>
<tr><td><code id="rsaga.grid.to.points_+3A_freq">freq</code></td>
<td>
<p>integer &gt;=1: sampling frequency: on average 1 out of 'freq' grid cells are selected</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions use modules <code style="white-space: pre;">&#8288;Grid Values to Points&#8288;</code> (in some versions also called <code style="white-space: pre;">&#8288;Grid Values to Shapes&#8288;</code>) and <code style="white-space: pre;">&#8288;Grid Values to Points (randomly)&#8288;</code> in SAGA library <code>shapes_grid</code>.
</p>
<p>The SAGA 2.0.6+ version of this module is more flexible as it allows to create grid cell polygons instead of center points (see argument <code>type</code>).
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA modules)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.add.grid.values.to.points">rsaga.add.grid.values.to.points()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# one point per grid cell, exclude nodata areas:
rsaga.grid.to.points("dem", "dempoints")
# take only every 20th point, but to not exclude nodata areas:
rsaga.grid.to.points.randomly("dem", "dempoints20", freq = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.hillshade'>Analytical hillshading
Analytical hillshading calculation.</h2><span id='topic+rsaga.hillshade'></span>

<h3>Description</h3>

<p>Analytical hillshading
Analytical hillshading calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.hillshade(
  in.dem,
  out.grid,
  method = "standard",
  azimuth = 315,
  declination = 45,
  exaggeration = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.hillshade_+3A_in.dem">in.dem</code></td>
<td>
<p>Input digital elevation model (DEM) as SAGA grid file (default extension: <code>.sgrd</code>).</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_out.grid">out.grid</code></td>
<td>
<p>Output hillshading grid (SAGA grid file). Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_method">method</code></td>
<td>
<p>Available choices (character or numeric): <code>"standard"</code> (or <code>0</code> - default), <code>"max90deg.standard"</code> (<code>1</code>), <code>"combined.shading"</code> (<code>2</code>), <code>"ray.tracing"</code> (<code>3</code>). See Details.</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_azimuth">azimuth</code></td>
<td>
<p>Direction of the light source, measured in degree  clockwise from the north direction; default 315, i.e. northwest.</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_declination">declination</code></td>
<td>
<p>Declination of the light source, measured in degree above the horizon (default 45).</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_exaggeration">exaggeration</code></td>
<td>
<p>Vertical exaggeration of elevation (default: 4). The terrain exaggeration factor allows to increase the shading contrasts in flat areas.</p>
</td></tr>
<tr><td><code id="rsaga.hillshade_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Analytical Hillshading algorithm is based on the angle between the surface and the incoming light beams, measured in radians.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>While the default azimuth of 315 degree (northwest) is not physically meaningful on the northern hemisphere, a northwesterly light source is required to properly depict relief in hillshading images. Physically correct southerly light sources results a hillshade that would be considered by most people as inverted: hills look like depressions, mountain chains like troughs.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.solar.radiation">rsaga.solar.radiation()</a></code>, <code><a href="#topic+rsaga.insolation">rsaga.insolation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: rsaga.hillshade("dem.sgrd","hillshade")
</code></pre>

<hr>
<h2 id='rsaga.html.help'>HTML help on a SAGA module or library</h2><span id='topic+rsaga.html.help'></span>

<h3>Description</h3>

<p>This function opens SAGA's HTML documentation for the specified library or module. Works with SAGA GIS 2.1.0(+), for earlier versions a web page with the SAGA GIS wiki is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.html.help(
  lib,
  module = NULL,
  use.program.folder = TRUE,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.html.help_+3A_lib">lib</code></td>
<td>
<p>name of the SAGA library, or one of the <code>rsaga.</code> module functions such as <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.html.help_+3A_module">module</code></td>
<td>
<p>name or numeric identifier of SAGA module in library <code>lib</code>; <code>module=NULL</code> takes you to the main help page of the SAGA library <code>lib</code></p>
</td></tr>
<tr><td><code id="rsaga.html.help_+3A_use.program.folder">use.program.folder</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default), attempt to write SAGA GIS documentation to a <code>"help"</code> subfolder of <code>env$path</code>; the <code>"help"</code> folder is created if it doesn't exist. If <code>FALSE</code>, create SAGA GIS documentation files in this R session's temporary folder as obtained using <code>tempdir()</code></p>
</td></tr>
<tr><td><code id="rsaga.html.help_+3A_env">env</code></td>
<td>
<p>a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.html.help_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="utils.html#topic+browseURL">browseURL()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires SAGA GIS 2.1.0(+), with earlier versions use <code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.get.usage">rsaga.get.usage()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Requires SAGA GIS 2.1.0+:
rsaga.html.help("io_grid")
rsaga.html.help("io_grid",0)
rsaga.html.help("io_grid","Import ESRI Arc/Info Grid")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.import.gdal'>Import Grid Files to SAGA grid format using GDAL</h2><span id='topic+rsaga.import.gdal'></span>

<h3>Description</h3>

<p>These functions provide simple interfaces for reading and writing grids
from/to ASCII grids and Rd files. Grids are stored in matrices, their headers
in lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.import.gdal(in.grid, out.grid, env = rsaga.env(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.import.gdal_+3A_in.grid">in.grid</code></td>
<td>
<p>file name of a grid in a format supported by GDAL</p>
</td></tr>
<tr><td><code id="rsaga.import.gdal_+3A_out.grid">out.grid</code></td>
<td>
<p>output SAGA grid file name; defaults to <code>in.grid</code> with
the file extension being removed; file extension should not be specified,
it defaults to <code>.sgrd</code></p>
</td></tr>
<tr><td><code id="rsaga.import.gdal_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.import.gdal_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>rsaga.geoprocessor</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GDAL Raster Import module of SAGA imports grid data from various
file formats using the Geospatial Data Abstraction Library (GDAL) by Frank
Warmerdam. GDAL Versions are specific to SAGA versions:
</p>

<ul>
<li><p> SAGA 2.1.2 - 2.2.0: GDAL v.1.11.0
</p>
</li>
<li><p> SAGA 2.2.1 - 2.2.3: GDAL v.2.1.0 dev
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> SAGA 8.4.1: GDAL v3.3.0
More information is available at <a href="https://gdal.org/">https://gdal.org/</a>.
</p>
</li></ul>

<p>If <code>in.grid</code> has more than one band (e.g. RGB GEOTIFF), then output
grids with file names of the form <code class="reqn">in.grid{\_}01.sgrd</code>,
<code class="reqn">in.grid{\_}02.sgrd</code> etc. are written, one for each
band.
</p>
<p>Numerous raster formats are currently supported. For SAGA 8.4.1 see e.g.
<a href="https://saga-gis.sourceforge.io/saga_tool_doc/8.4.1/io_gdal_0.html">https://saga-gis.sourceforge.io/saga_tool_doc/8.4.1/io_gdal_0.html</a>
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad / Andre Ringeler (SAGA module), Frank Warmerdam (GDAL)
</p>


<h3>References</h3>

<p>GDAL website: <a href="https://gdal.org/">https://gdal.org/</a>
</p>


<h3>See Also</h3>

<p><code>read.ascii.grid</code>, <code>rsaga.esri.to.sgrd</code>, <code>read.sgrd</code>, <code>read.Rd.grid</code>
</p>

<hr>
<h2 id='rsaga.insolation'>Incoming Solar Radiation (Insolation)</h2><span id='topic+rsaga.insolation'></span>

<h3>Description</h3>

<p>This function calculates the amount of incoming solar radiation (insolation) depending on slope, aspect, and atmospheric properties. Module not available in SAGA GIS 2.0.6 and 2.0.7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.insolation(
  in.dem,
  in.vapour,
  in.latitude,
  in.longitude,
  out.direct,
  out.diffuse,
  out.total,
  horizontal = FALSE,
  solconst = 8.164,
  atmosphere = 12000,
  water.vapour.pressure = 10,
  type = c("moment", "day", "range.of.days", "same.moment.range.of.days"),
  time.step = 1,
  day.step = 5,
  days,
  moment,
  latitude,
  bending = FALSE,
  radius = 6366737.96,
  lat.offset = "user",
  lat.ref.user = 0,
  lon.offset = "center",
  lon.ref.user = 0,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.insolation_+3A_in.dem">in.dem</code></td>
<td>
<p>Name of input digital elevation model (DEM) grid in SAGA grid format (default extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_in.vapour">in.vapour</code></td>
<td>
<p>Optional input: SAGA grid file giving the water vapour pressure in mbar</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_in.latitude">in.latitude</code></td>
<td>
<p>Optional input: SAGA grid file giving for each pixel the latitude in degree</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_in.longitude">in.longitude</code></td>
<td>
<p>Optional input: SAGA grid file giving for each pixel the longitude in degree</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_out.direct">out.direct</code></td>
<td>
<p>Optional output grid file for direct insolation</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_out.diffuse">out.diffuse</code></td>
<td>
<p>Optional output grid file for diffuse insolation</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_out.total">out.total</code></td>
<td>
<p>Optional output grid file for total insolation, i.e. the sum of direct and diffuse insolation</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_horizontal">horizontal</code></td>
<td>
<p>logical; project radiation onto a horizontal surface? (default: <code>FALSE</code>, i.e. use the actual inclined surface as a reference area)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_solconst">solconst</code></td>
<td>
<p>solar constant in Joule; default: 8.164 J/cm2/min (=1360.7 kWh/m2; the more commonly used solar constant of 1367 kWh/m2 corresponds to 8.202 J/cm2/min)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_atmosphere">atmosphere</code></td>
<td>
<p>height of atmosphere in m; default: 12000m</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_water.vapour.pressure">water.vapour.pressure</code></td>
<td>
<p>if no water vapour grid is given, this argument specifies a constant water vapour pressure that is uniform in space; in mbar, default 10 mbar</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_type">type</code></td>
<td>
<p>type of time period: <code>"moment"</code> (equivalent: <code>0</code>) for a single instant, <code>"day"</code> (or <code>1</code>) for a single day, <code>"range.of.days"</code> (or <code>2</code>), or <code>"same.moment.range.of.days"</code> (or <code>3</code>) for the same moment in a range of days; default: <code>"moment"</code></p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_time.step">time.step</code></td>
<td>
<p>time resolution in hours for discretization within a day</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_day.step">day.step</code></td>
<td>
<p>time resolution in days for a range of days</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_days">days</code></td>
<td>
<p>numeric vector of length 2, specifying the first and last day of a range of days (for <code>type</code>s 2 and 3)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_moment">moment</code></td>
<td>
<p>if <code>type="moment"</code> or <code>"same.moment.range.of.days"</code>, <code>moment</code> specifies the time of the day (hour between 0 and 24) for which the insolation is to be calculated</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_latitude">latitude</code></td>
<td>
<p>if no <code>in.latitude</code> grid is given, this will specify a fixed geographical latitude for the entire grid</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_bending">bending</code></td>
<td>
<p>should planetary bending be modeled? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_radius">radius</code></td>
<td>
<p>planetary radius</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_lat.offset">lat.offset</code></td>
<td>
<p><code>latitude</code> relates to grids <code>"bottom"</code>(equivalent code: <code>0</code>), <code>"center"</code> (1), <code>"top"</code> (2), or <code>"user"</code>-defined reference (default: <code>"user"</code>); in the latter case, <code>lat.ref.user</code> defines the reference</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_lat.ref.user">lat.ref.user</code></td>
<td>
<p>if <code>in.latitude</code> is missing and <code>lat.offset="user"</code>, then this numeric value defines the latitudinal reference (details??)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_lon.offset">lon.offset</code></td>
<td>
<p>local time refers to grid's <code>"left"</code> edge (code 0), <code>"center"</code> (1), <code>"right"</code> edge (2), or a  <code>"user"</code>-defined reference.</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_lon.ref.user">lon.ref.user</code></td>
<td>
<p>if <code>in.longitude</code> is missing and <code>lon.offset="user"</code>, then this numeric value defines the reference of the local time (details??)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment obtained with <code><a href="#topic+rsaga.env">rsaga.env()</a></code>; this argument is required for version control (see Note)</p>
</td></tr>
<tr><td><code id="rsaga.insolation_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of incoming solar radiation (insolation). Based on the SADO (System for the Analysis of Discrete Surfaces) routines developed  by Boehner &amp; Trachinow.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>This function uses module <code>Insolation</code> (code: 3) from SAGA library <code>ta_lighting</code>. It is available in SAGA GIS 2.0.4 and 2.0.5 but not 2.0.6 and 2.0.7; see <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.solar.radiation">rsaga.solar.radiation()</a></code>, <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code>,  <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code>
</p>

<hr>
<h2 id='rsaga.intersect.polygons'>Spatial intersection of two polygon layers</h2><span id='topic+rsaga.intersect.polygons'></span>

<h3>Description</h3>

<p>The function <code>rsaga.intersect.polygons</code> calculates the
geometric intersection of two overlayed polygon layers using SAGA module
&quot;<code>Intersect</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.intersect.polygons(
  layer_a = NULL,
  layer_b = NULL,
  result = NULL,
  split = FALSE,
  load = NULL,
  env = rsaga.env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.intersect.polygons_+3A_layer_a">layer_a</code></td>
<td>
<p>A <code>character</code> string representing the path to a polygon
shapefile.</p>
</td></tr>
<tr><td><code id="rsaga.intersect.polygons_+3A_layer_b">layer_b</code></td>
<td>
<p>A <code>character</code> string representing the path to a polygon
shapefile with which to intersect layer_a.</p>
</td></tr>
<tr><td><code id="rsaga.intersect.polygons_+3A_result">result</code></td>
<td>
<p>A <code>character</code> string indicating where the resulting
shapefile should be stored.</p>
</td></tr>
<tr><td><code id="rsaga.intersect.polygons_+3A_split">split</code></td>
<td>
<p>If <code>TRUE</code>, multipart polygons become separated polygons
(default: FALSE).</p>
</td></tr>
<tr><td><code id="rsaga.intersect.polygons_+3A_load">load</code></td>
<td>
<p>Deprecated, will be removed in a future release. Ignored
if <code>FALSE</code>, and causes an error if <code>TRUE</code> (default: NULL).</p>
</td></tr>
<tr><td><code id="rsaga.intersect.polygons_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment created by
<code><a href="#topic+rsaga.env">rsaga.env()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>gIntersection</code> in <code>rgeos</code> package can also be used to
define the intersection between two polygon layers. However,
<code><a href="#topic+rsaga.intersect.polygons">rsaga.intersect.polygons()</a></code> will be usually much faster,
especially when intersecting thousands of polygons.
</p>


<h3>Value</h3>

<p>The function saves the output shapefile to the path indicated in
function argument <code>result</code>.
</p>


<h3>Author(s)</h3>

<p>Jannes Muenchow and Alexander Brenning (R interface), Olaf Conrad and Angus Johnson (SAGA
modules)
</p>

<hr>
<h2 id='rsaga.inverse.distance'>Spatial Interpolation Methods</h2><span id='topic+rsaga.inverse.distance'></span><span id='topic+rsaga.nearest.neighbour'></span><span id='topic+rsaga.modified.quadratic.shephard'></span><span id='topic+rsaga.triangulation'></span>

<h3>Description</h3>

<p>Spatial interpolation of point data using inverse distance to a power (inverse distance weighting, IDW), nearest neighbors, or modified quadratic shephard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.inverse.distance(
  in.shapefile,
  out.grid,
  field,
  power = 1,
  maxdist,
  nmax = 100,
  target,
  env = rsaga.env(),
  ...
)

rsaga.nearest.neighbour(
  in.shapefile,
  out.grid,
  field,
  target,
  env = rsaga.env(),
  ...
)

rsaga.modified.quadratic.shephard(
  in.shapefile,
  out.grid,
  field,
  quadratic.neighbors = 13,
  weighting.neighbors = 19,
  target,
  env = rsaga.env(),
  ...
)

rsaga.triangulation(
  in.shapefile,
  out.grid,
  field,
  target,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.inverse.distance_+3A_in.shapefile">in.shapefile</code></td>
<td>
<p>Input: point shapefile (default extension: <code>.shp</code>).</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_out.grid">out.grid</code></td>
<td>
<p>Output: filename for interpolated grid (SAGA grid file). Existing files will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_field">field</code></td>
<td>
<p>numeric or character: number or name of attribute in the shapefile's attribute table to be interpolated; the first attribute is represented by a zero.</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_power">power</code></td>
<td>
<p>numeric (&gt;0): exponent used in inverse distance  weighting (usually 1 or 2)</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_maxdist">maxdist</code></td>
<td>
<p>numeric: maximum distance of points to be used for inverse distance interpolation (search radius); no search radius is applied when this argument is missing or equals <code>Inf</code></p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_nmax">nmax</code></td>
<td>
<p>Maximum number of nearest points to be used for interpolation; <code>nmax=Inf</code> is a valid value (no upper limit)</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_target">target</code></td>
<td>
<p>required argument of type list: parameters identifying the target area, e.g. the x/y extent and cellsize, or name of a reference grid; see <code><a href="#topic+rsaga.target">rsaga.target()</a></code>.</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code>, required because module(s) depend(s) on SAGA version</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment.</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_quadratic.neighbors">quadratic.neighbors</code></td>
<td>
<p>integer &gt;=5; default 13.</p>
</td></tr>
<tr><td><code id="rsaga.inverse.distance_+3A_weighting.neighbors">weighting.neighbors</code></td>
<td>
<p>integer &gt;=3; default 19.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use modules from the <code>grid_gridding</code> SAGA GIS library. They do not support SAGA GIS 2.0.4, which differs in some argument names and parameterizations. Target grid parameterization by grid file name currently doesn't work with SAGA GIS 2.1.0  Release Candidate 1 (see also <code><a href="#topic+rsaga.target">rsaga.target()</a></code>); stay tuned for future updates and fixes.
</p>


<h3>Note</h3>

<p>The 'Inverse Distance Weighted' module of SAGA GIS not only support inverse-distance weighted interpolation, but also exponential and other weighting schemes (command line argument WEIGHTING); these are however not accessible through this function, but only through the <code>rsaga.geoprocessor</code>, if needed. See <code>rsaga.get.usage("grid_gridding","Inverse Distance Weighted")</code> for details.
</p>
<p>See the example section in the help file for <code><a href="shapefiles.html#topic+shapefiles">shapefiles::write.shapefile()</a></code> in package <code>shapefiles</code> to learn how to apply these interpolation functions to a shapefile exported from a data.frame.
</p>
<p>Modified Quadratic Shephard method: based on module 660 in TOMS (see references).
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Andre Ringeler and Olaf Conrad (SAGA modules)
</p>


<h3>References</h3>

<p>QSHEP2D: Fortran routines implementing the Quadratic Shepard method for bivariate interpolation of scattered data  (see R. J. Renka, ACM TOMS 14 (1988) pp.149-150). Classes: E2b. Interpolation of scattered, non-gridded  multivariate data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.target">rsaga.target()</a></code>; <code><a href="gstat.html#topic+krige">gstat::idw()</a></code> in package <code>gstat</code>.
</p>

<hr>
<h2 id='rsaga.lib.prefix'>Determine prefix for SAGA GIS library names</h2><span id='topic+rsaga.lib.prefix'></span>

<h3>Description</h3>

<p>Internal function that determines the possible prefix for SAGA GIS library names - relevant for non-Windows SAGA GIS pre-2.1.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.lib.prefix(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.lib.prefix_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some non-Windows versions of <code>saga_cmd</code> require library names with a <code>"lib"</code> prefix, e.g. <code>libio_grid</code> instead of <code>io_grid</code>. This function, which is called by <code><a href="#topic+rsaga.env">rsaga.env()</a></code> tries to guess this behaviour based on the operating system and SAGA GIS version.
</p>


<h3>Value</h3>

<p>A character string, either <code>""</code> or <code>"lib"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
env = rsaga.env()
# obtained by a call to rsaga.lib.prefix:
env$lib.prefix

# more explicitly:
rsaga.lib.prefix(env=env)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.local.morphometry'>Local Morphometry</h2><span id='topic+rsaga.local.morphometry'></span><span id='topic+rsaga.slope'></span><span id='topic+rsaga.aspect'></span><span id='topic+rsaga.curvature'></span><span id='topic+rsaga.plan.curvature'></span><span id='topic+rsaga.profile.curvature'></span>

<h3>Description</h3>

<p>Calculates local morphometric terrain attributes (i.e. slope, aspect and curvatures). Intended for use with SAGA versions 2.1.0 and older. Use <code><a href="#topic+rsaga.slope.asp.curv">rsaga.slope.asp.curv()</a></code> for SAGA 2.1.1+
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.local.morphometry(
  in.dem,
  out.slope,
  out.aspect,
  out.curv,
  out.hcurv,
  out.vcurv,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)

rsaga.slope(
  in.dem,
  out.slope,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)

rsaga.aspect(
  in.dem,
  out.aspect,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)

rsaga.curvature(
  in.dem,
  out.curv,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)

rsaga.plan.curvature(
  in.dem,
  out.hcurv,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)

rsaga.profile.curvature(
  in.dem,
  out.vcurv,
  method = "poly2zevenbergen",
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.local.morphometry_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_out.slope">out.slope</code></td>
<td>
<p>optional output: slope (in radians)</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_out.aspect">out.aspect</code></td>
<td>
<p>optional output: aspect (in radians; north=0, clockwise angles)</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_out.curv">out.curv</code></td>
<td>
<p>optional output: curvature</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_out.hcurv">out.hcurv</code></td>
<td>
<p>optional output: horizontal curvature (plan curvature)</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_out.vcurv">out.vcurv</code></td>
<td>
<p>optional output: vertical curvature (profile curvature)</p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_method">method</code></td>
<td>
<p>character (or numeric): algorithm (see References):
</p>

<ul>
<li><p> 0 Maximum Slope - Travis et al. (1975) (<code>"maxslope"</code>, or 0)
</p>
</li>
<li><p> 1 Max. Triangle Slope - Tarboton (1997) (<code>"maxtriangleslope"</code>, or 1)
</p>
</li>
<li><p> 2 Least Squares Fit Plane - Costa-Cabral and Burgess (1996) (<code>"lsqfitplane"</code>, or 2)
</p>
</li>
<li><p> 3 Fit 2nd Degree Polynomial - Bauer et al. (1985) (<code>"poly2bauer"</code>, or 3)
</p>
</li>
<li><p> 4 Fit 2nd Degree Polynomial - Heerdegen and Beran (1982) (<code>"poly2heerdegen"</code>, or 4)
</p>
</li>
<li><p> 5 default: Fit 2nd Degree Polynomial - Zevenbergen and Thorne (1987) (<code>"poly2zevenbergen"</code>, or 5)
</p>
</li>
<li><p> 6 Fit 3rd Degree Polynomial - Haralick (1983) (<code>"poly3haralick"</code>, or 6).
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.local.morphometry_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning and Donovan Bangs (R interface), Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>For references and algorithm changes in SAGA GIS 2.1.1+ see <code><a href="#topic+rsaga.slope.asp.curv">rsaga.slope.asp.curv()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.slope.asp.curv">rsaga.slope.asp.curv()</a></code>, <code><a href="#topic+rsaga.parallel.processing">rsaga.parallel.processing()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>,  <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# a simple slope algorithm:
rsaga.slope("lican.sgrd","slope","maxslope")
# same for ASCII grids (default extension .asc):
rsaga.esri.wrapper(rsaga.slope,in.dem="lican",out.slope="slope",method="maxslope")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.parallel.processing'>Parallel Processing</h2><span id='topic+rsaga.parallel.processing'></span>

<h3>Description</h3>

<p>Calculate the size of the local catchment area (contributing area), the catchment height, catchment slope and aspect, and flow path length, using parallel processing algorithms including the recommended multiple flow direction algorithm. This set of algorithms processes a digital elevation model (DEM) downwards from the highest to the lowest cell.<br /> No longer supported with SAGA GIS 2.1.3+. See <code><a href="#topic+rsaga.topdown.processing">rsaga.topdown.processing()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.parallel.processing(
  in.dem,
  in.sinkroute,
  in.weight,
  out.carea,
  out.cheight,
  out.cslope,
  out.caspect,
  out.flowpath,
  step,
  method = "mfd",
  linear.threshold = Inf,
  convergence = 1.1,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.parallel.processing_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_in.sinkroute">in.sinkroute</code></td>
<td>
<p>optional input: SAGA grid with sink routes</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_in.weight">in.weight</code></td>
<td>
<p>optional intput: SAGA grid with weights</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_out.carea">out.carea</code></td>
<td>
<p>output: catchment area grid</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_out.cheight">out.cheight</code></td>
<td>
<p>optional output: catchment height grid</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_out.cslope">out.cslope</code></td>
<td>
<p>optional output: catchment slope grid</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_out.caspect">out.caspect</code></td>
<td>
<p>optional output: catchment aspect grid</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_out.flowpath">out.flowpath</code></td>
<td>
<p>optional output: flow path length grid</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_step">step</code></td>
<td>
<p>integer &gt;=1: step parameter</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_method">method</code></td>
<td>
<p>character or numeric: choice of processing algorithm: Deterministic 8 (<code>"d8"</code> or 0), Rho 8 (<code>"rho8"</code> or 1), Braunschweiger Reliefmodell (<code>"braunschweig"</code> or 2), Deterministic Infinity (<code>"dinf"</code> or 3), Multiple Flow Direction (<code>"mfd"</code> or 4, the default), Multiple Triangular Flow Direction (<code>"mtfd"</code>, or 5).</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_linear.threshold">linear.threshold</code></td>
<td>
<p>numeric (number of grid cells): threshold above which linear flow (i.e. the Deterministic 8 algorithm) will be used; linear flow is disabled for <code>linear.threshold=Inf</code> (the default)</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_convergence">convergence</code></td>
<td>
<p>numeric &gt;=0: a parameter for tuning convergent/ divergent flow; default value of <code>1.1</code> gives realistic results and should not be changed</p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.parallel.processing_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the references for details on the available algorithms.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>This function uses module <code style="white-space: pre;">&#8288;Parallel Processing&#8288;</code> (version 2.0.7+: <code style="white-space: pre;">&#8288;Catchment Area (Parallel)&#8288;</code> from SAGA library <code>ta_hydrology</code>.
</p>
<p>The SAGA GIS 2.0.6+ version of the module adds more (optional) input and
output grids that are currently not supported by this wrapper function.
Use <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code> for access to these options,
and see <code>rsaga.get.usage("ta_hydrology","Catchment Area (Parallel)")</code>
for information on new arguments.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module), Thomas Grabs (MTFD algorithm)
</p>


<h3>References</h3>

<p>Deterministic 8:
</p>
<p>O'Callaghan, J.F., Mark, D.M. (1984): The extraction of drainage networks from digital elevation data. Computer Vision, Graphics and Image Processing, 28: 323-344.
</p>
<p>Rho 8:
</p>
<p>Fairfield, J., Leymarie, P. (1991): Drainage networks from grid digital elevation models. Water Resources Research, 27: 709-717.
</p>
<p>Braunschweiger Reliefmodell:
</p>
<p>Bauer, J., Rohdenburg, H., Bork, H.-R. (1985): Ein Digitales Reliefmodell als Vorraussetzung fuer ein deterministisches Modell der Wasser- und Stoff-Fluesse. Landschaftsgenese und Landschaftsoekologie, H. 10, Parameteraufbereitung fuer deterministische Gebiets-Wassermodelle, Grundlagenarbeiten zu Analyse von Agrar-Oekosystemen, eds.: Bork, H.-R., Rohdenburg, H., p. 1-15.
</p>
<p>Deterministic Infinity:
</p>
<p>Tarboton, D.G. (1997): A new method for the determination of flow directions and upslope areas in grid digital elevation models. Water Ressources Research, 33(2): 309-319.
</p>
<p>Multiple Flow Direction:
</p>
<p>Freeman, G.T. (1991): Calculating catchment area with divergent flow based on a regular grid. Computers and Geosciences, 17: 413-22.
</p>
<p>Quinn, P.F., Beven, K.J., Chevallier, P., Planchon, O. (1991): The prediction of hillslope flow paths for distributed hydrological modelling using digital terrain models. Hydrological Processes, 5: 59-79.
</p>
<p>Multiple Triangular Flow Direction:
</p>
<p>Seibert, J., McGlynn, B. (2007): A new triangular multiple flow direction algorithm for computing upslope areas from gridded digital elevation models. Water Ressources Research, 43, W04501.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.topdown.processing">rsaga.topdown.processing()</a></code>, <code><a href="#topic+rsaga.wetness.index">rsaga.wetness.index()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# SAGA GIS 2.0.6+:
rsaga.get.usage("ta_hydrology","Catchment Area (Parallel)")
# earlier versions of SAGA GIS:
#rsaga.get.usage("ta_hydrology","Parallel Processing")
# execute model with typical settings:
rsaga.parallel.processing(in.dem = "dem", out.carea = "carea", out.cslope = "cslope")
# cslope is in radians - convert to degree:
fac = round(180/pi, 4)
formula = paste(fac, "*a", sep = "")
rsaga.grid.calculus("cslope", "cslopedeg", formula)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.pisr'>Potential incoming solar radiation</h2><span id='topic+rsaga.pisr'></span>

<h3>Description</h3>

<p>This function calculates the potential incoming solar radiation in an area using different atmospheric models; module available in SAGA GIS 2.0.6+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.pisr(
  in.dem,
  in.svf.grid = NULL,
  in.vapour.grid = NULL,
  in.latitude.grid = NULL,
  in.longitude.grid = NULL,
  out.direct.grid,
  out.diffuse.grid,
  out.total.grid = NULL,
  out.ratio.grid = NULL,
  out.duration,
  out.sunrise,
  out.sunset,
  local.svf = TRUE,
  latitude,
  unit = c("kWh/m2", "kJ/m2", "J/cm2"),
  solconst = 1367,
  enable.bending = FALSE,
  bending.radius = 6366737.96,
  bending.lat.offset = "user",
  bending.lat.ref.user = 0,
  bending.lon.offset = "center",
  bending.lon.ref.user = 0,
  method = c("height", "components", "lumped"),
  hgt.atmosphere = 12000,
  hgt.water.vapour.pressure = 10,
  cmp.pressure = 1013,
  cmp.water.content = 1.68,
  cmp.dust = 100,
  lmp.transmittance = 70,
  time.range = c(0, 24),
  time.step = 0.5,
  start.date = list(day = 21, month = 3),
  end.date = NULL,
  day.step = 5,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.pisr_+3A_in.dem">in.dem</code></td>
<td>
<p>name of input digital elevation model (DEM) grid in SAGA grid format (default extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_in.svf.grid">in.svf.grid</code></td>
<td>
<p>Optional input grid in SAGA format:  Sky View Factor; see also <code>local.svf</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_in.vapour.grid">in.vapour.grid</code></td>
<td>
<p>Optional input grid in SAGA format:  Water vapour pressure (mbar); see also argument <code>hgt.water.vapour.pressure</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_in.latitude.grid">in.latitude.grid</code></td>
<td>
<p>Optional input grid in SAGA format: Latitude (degree) of each grid cell</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_in.longitude.grid">in.longitude.grid</code></td>
<td>
<p>see <code>in.latitude.grid</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.direct.grid">out.direct.grid</code></td>
<td>
<p>Output grid: Direct insolation (unit selected by <code>unit</code> argument)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.diffuse.grid">out.diffuse.grid</code></td>
<td>
<p>Output grid: Diffuse insolation</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.total.grid">out.total.grid</code></td>
<td>
<p>Optional output grid: Total insolation, i.e. sum of direct and diffuse incoming solar radiation</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.ratio.grid">out.ratio.grid</code></td>
<td>
<p>Optional output grid: Direct to diffuse ratio</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.duration">out.duration</code></td>
<td>
<p>Optional output grid: Duration of insolation</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.sunrise">out.sunrise</code></td>
<td>
<p>Optional output grid: time of sunrise; only calculated if time span is set to single day</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_out.sunset">out.sunset</code></td>
<td>
<p>Time of sunset; see <code>out.sunrise</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_local.svf">local.svf</code></td>
<td>
<p>logical (default: <code>TRUE</code>; if TRUE, use sky view factor based on local slope (after Oke, 1988), if no sky view factor grid is provided in <code>in.svf.grid</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_latitude">latitude</code></td>
<td>
<p>Geographical latitude in degree North (negative values indicate southern hemisphere)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_unit">unit</code></td>
<td>
<p>unit of insolation output grids: <code>"kWh/m2"</code> (default) <code>"kJ/m2"</code>, or <code>"J/cm2"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_solconst">solconst</code></td>
<td>
<p>solar constant, defaults to 1367 W/m2</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_enable.bending">enable.bending</code></td>
<td>
<p>logical (default: <code>FALSE</code>): incorporate effects of planetary bending?</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_bending.radius">bending.radius</code></td>
<td>
<p>Planetary radius, default <code>6366737.96</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_bending.lat.offset">bending.lat.offset</code></td>
<td>
<p>if bending is enabled: latitudinal reference  is <code>"user"</code>-defined (default), or relative to <code>"top"</code>, <code>"center"</code> or <code>"bottom"</code> of grid?</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_bending.lat.ref.user">bending.lat.ref.user</code></td>
<td>
<p>user-defined lat. reference for bending, see <code>bending.lat.offset</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_bending.lon.offset">bending.lon.offset</code></td>
<td>
<p>longitudinal reference, i.e. local time,  is <code>"user"</code>-defined, or relative to <code>"top"</code>, <code>"center"</code> (default) or <code>"bottom"</code> of grid?</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_bending.lon.ref.user">bending.lon.ref.user</code></td>
<td>
<p>user-defined reference for local time (Details??)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_method">method</code></td>
<td>
<p>specifies how the atmospheric components should be  accounted for: either based on the height of atmosphere and vapour pressure (<code>"height"</code>, or numeric code 0), or air pressure, water and dust content (<code>"components"</code>, code 1), or lumped atmospheric transmittance (<code>"lumped"</code>, code <code>0</code>)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_hgt.atmosphere">hgt.atmosphere</code></td>
<td>
<p>Height of atmosphere (in m); default 12000 m</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_hgt.water.vapour.pressure">hgt.water.vapour.pressure</code></td>
<td>
<p>Water vapour pressure in mbar (default 10 mbar); This value is used if no vapour pressure grid is given in  argument <code>in.vapour.grid</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_cmp.pressure">cmp.pressure</code></td>
<td>
<p>atmospheric pressure in mbar, defaults to 1013 mbar</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_cmp.water.content">cmp.water.content</code></td>
<td>
<p>water content of a vertical slice of the atmosphere in cm: between 1.5 and 1.7cm, average 1.68cm (default)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_cmp.dust">cmp.dust</code></td>
<td>
<p>dust factor in ppm; defaults to 100 ppm</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_lmp.transmittance">lmp.transmittance</code></td>
<td>
<p>transmittance of the atmosphere in percent; usually between 60 (humid areas) and 80 percent (deserts)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_time.range">time.range</code></td>
<td>
<p>numeric vector of length 2:  time span (hours of the day) for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_time.step">time.step</code></td>
<td>
<p>time step in hours for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_start.date">start.date</code></td>
<td>
<p>list of length two, giving the start date in <code>day</code> and <code>month</code> components as numbers; these numbers are one-based (SAGA_CMD uses zero-based numbers internally), i.e. Jan. 1st is <code>list(day=1,month=1)</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_end.date">end.date</code></td>
<td>
<p>see <code>start.date</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_day.step">day.step</code></td>
<td>
<p>if <code>days</code> indicates a range of days, this specifies the time step (number of days) for calculating the incoming solar radiation</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment obtained with <code><a href="#topic+rsaga.env">rsaga.env()</a></code>; this argument is required for version control (see Note)</p>
</td></tr>
<tr><td><code id="rsaga.pisr_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to SAGA GIS 2.0.7 documentation, &quot;Most options should do well, but TAPES-G based diffuse irradiance calculation (&quot;Atmospheric Effects&quot; methods 2 and 3) needs further revision!&quot; I.e. be careful with <code>method = "components"</code> and <code>method = "lumped"</code>.
</p>


<h3>Note</h3>

<p>This module is computationally very intensive (depending on the size of the grid and the time resolution, of course). The performance seems to have much improved in SAGA GIS 2.1.0, which by default runs this module in multicore mode (at the release candidate 1 for Windows does).
</p>
<p>SAGA_CMD uses zero-based days and months, but this R function uses the standard one-based days and months (e.g. day 1 is the first day of the month, month 1 is January) and translates to the SAGA system.
</p>
<p>This function uses module Potential Incoming Solar Radiation from SAGA library <code>ta_lighting</code> in SAGA version 2.0.6+.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>Boehner, J., Antonic, O. (2009): Land surface parameters specific to topo-climatology. In: Hengl, T. and Reuter, H. I. (eds.): Geomorphometry - Concepts, Software, Applications. Elsevier.
</p>
<p>Oke, T.R. (1988): Boundary layer climates. London, Taylor and Francis.
</p>
<p>Wilson, J.P., Gallant, J.C. (eds.), 2000: Terrain analysis - principles and applications. New York, John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code>; for similar modules in older SAGA versions (pre-2.0.6) see <code><a href="#topic+rsaga.solar.radiation">rsaga.solar.radiation()</a></code> and <code><a href="#topic+rsaga.insolation">rsaga.insolation()</a></code>
</p>

<hr>
<h2 id='rsaga.pisr2'>Potential incoming solar radiation SAGA 2.2.2+</h2><span id='topic+rsaga.pisr2'></span>

<h3>Description</h3>

<p>This function calculates the potential incoming solar radiation in an area using different atmospheric models; This function reflects changes to the module with SAGA 2.2.2+.
For SAGA versions 2.0.6 to 2.2.1 please see <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.pisr2(
  in.dem,
  in.svf.grid = NULL,
  in.vapour.grid = NULL,
  in.linke.grid = NULL,
  out.direct.grid,
  out.diffuse.grid,
  out.total.grid = NULL,
  out.ratio.grid = NULL,
  out.duration,
  out.sunrise,
  out.sunset,
  local.svf = TRUE,
  location = c("latitude", "grid"),
  latitude = 53,
  unit = c("kWh/m2", "kJ/m2", "J/cm2"),
  solconst = 1367,
  method = c("height", "components", "lumped", "hofierka"),
  hgt.atmosphere = 12000,
  cmp.pressure = 1013,
  cmp.water.content = 1.68,
  cmp.dust = 100,
  lmp.transmittance = 70,
  time.range = c(0, 24),
  time.step = 0.5,
  start.date = list(day = 31, month = 10, year = 2015),
  end.date = NULL,
  day.step = 5,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.pisr2_+3A_in.dem">in.dem</code></td>
<td>
<p>name of input digital elevation model (DEM) grid in SAGA grid format (default extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_in.svf.grid">in.svf.grid</code></td>
<td>
<p>Optional input grid in SAGA format:  Sky View Factor; see also <code>local.svf</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_in.vapour.grid">in.vapour.grid</code></td>
<td>
<p>Optional input grid in SAGA format:  Water vapour pressure (mbar), for use with <code>method = "height"</code>; default 10 mbar</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_in.linke.grid">in.linke.grid</code></td>
<td>
<p>Optional input grid in SAGA format: Linke turbidity coefficient, for use with <code>method = "hofierka"</code>; default 3.0</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.direct.grid">out.direct.grid</code></td>
<td>
<p>Output grid: Direct insolation (unit selected by <code>unit</code> argument)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.diffuse.grid">out.diffuse.grid</code></td>
<td>
<p>Output grid: Diffuse insolation</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.total.grid">out.total.grid</code></td>
<td>
<p>Optional output grid: Total insolation, i.e. sum of direct and diffuse incoming solar radiation</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.ratio.grid">out.ratio.grid</code></td>
<td>
<p>Optional output grid: Direct to diffuse ratio</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.duration">out.duration</code></td>
<td>
<p>Optional output grid: Duration of insolation</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.sunrise">out.sunrise</code></td>
<td>
<p>Optional output grid: time of sunrise; only calculated if time span is set to single day</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_out.sunset">out.sunset</code></td>
<td>
<p>Time of sunset; see <code>out.sunrise</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_local.svf">local.svf</code></td>
<td>
<p>logical (default: <code>TRUE</code>; if TRUE, use sky view factor based on local slope (after Oke, 1988), if no sky view factor grid is provided in <code>in.svf.grid</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_location">location</code></td>
<td>
<p>specified whether to use constant latitude supplied by <code>latitude</code> below (<code>"latitude"</code> or code <code>0</code>; default) or as calculated from the grid system (<code>"grid"</code> or code <code>1</code>)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_latitude">latitude</code></td>
<td>
<p>Geographical latitude in degree North (negative values indicate southern hemisphere)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_unit">unit</code></td>
<td>
<p>unit of insolation output grids: <code>"kWh/m2"</code> (default) <code>"kJ/m2"</code>, or <code>"J/cm2"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_solconst">solconst</code></td>
<td>
<p>solar constant, defaults to 1367 W/m2</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_method">method</code></td>
<td>
<p>specifies how the atmospheric components should be  accounted for: either based on the height of atmosphere and vapour pressure (<code>"height"</code>, or numeric code 0), or air pressure, water and dust content (<code>"components"</code>, code 1), or lumped atmospheric transmittance (<code>"lumped"</code>, code <code>2</code>), or by the method of Hofierka and Suri, 2009 (<code>"hofierka"</code>, code <code>3</code>). Default: <code>"lumped"</code>.</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_hgt.atmosphere">hgt.atmosphere</code></td>
<td>
<p>Height of atmosphere (in m); default 12000 m. For use with <code>method = "height"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_cmp.pressure">cmp.pressure</code></td>
<td>
<p>atmospheric pressure in mbar, defaults to 1013 mbar. For use with <code>method = "components"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_cmp.water.content">cmp.water.content</code></td>
<td>
<p>water content of a vertical slice of the atmosphere in cm: between 1.5 and 1.7cm, average 1.68cm (default). For use with <code>method = "components"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_cmp.dust">cmp.dust</code></td>
<td>
<p>dust factor in ppm; defaults to 100 ppm. For use with <code>method = "components"</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_lmp.transmittance">lmp.transmittance</code></td>
<td>
<p>transmittance of the atmosphere in percent; usually between 60 (humid areas) and 80 percent (deserts)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_time.range">time.range</code></td>
<td>
<p>numeric vector of length 2:  time span (hours of the day) for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_time.step">time.step</code></td>
<td>
<p>time step in hours for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_start.date">start.date</code></td>
<td>
<p>list of length three, giving the start date in <code>day</code>, <code>month</code>, and <code>year</code> components as numbers; month is one-based (SAGA_CMD uses zero-based numbers internally), i.e. Jan. 1st 2015 is <code>list(day=1,month=1,year=2015)</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_end.date">end.date</code></td>
<td>
<p>see <code>start.date</code></p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_day.step">day.step</code></td>
<td>
<p>if <code>days</code> indicates a range of days, this specifies the time step (number of days) for calculating the incoming solar radiation</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment obtained with <code><a href="#topic+rsaga.env">rsaga.env()</a></code>; this argument is required for version control (see Note)</p>
</td></tr>
<tr><td><code id="rsaga.pisr2_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to SAGA GIS 2.0.7 documentation, &quot;Most options should do well, but TAPES-G based diffuse irradiance calculation (&quot;Atmospheric Effects&quot; methods 2 and 3) needs further revision!&quot; I.e. be careful with <code>method = "components"</code> and <code>method = "lumped"</code>.
</p>


<h3>Note</h3>

<p>SAGA_CMD uses zero-based months, but this R function uses the standard one-based months (e.g. day 1 is the first day of the month, month 1 is January) and translates to the SAGA system.
</p>
<p>This function uses module Potential Incoming Solar Radiation from SAGA library <code>ta_lighting</code> in SAGA version 2.0.6+.
Changes to the module with SAGA 2.2.2+ include adding <code>year</code> to the <code style="white-space: pre;">&#8288;*.date&#8288;</code> arguments to allow calculation across years.
The method of Hofierka and Suri (2009) is added, which uses the Linke turbidity coefficient.
Duration of insolation (<code>"out.duration"</code>) is only calculated when the time period is set to a single day.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning &amp; Donovan Bangs (R interface), Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>Boehner, J., Antonic, O. (2009): Land surface parameters specific to topo-climatology. In: Hengl, T. and Reuter, H. I. (eds.): Geomorphometry - Concepts, Software, Applications. Elsevier.
</p>
<p>Oke, T.R. (1988): Boundary layer climates. London, Taylor and Francis.
</p>
<p>Wilson, J.P., Gallant, J.C. (eds.), 2000: Terrain analysis - principles and applications. New York, John Wiley and Sons.
</p>
<p>Hofierka, J., Suri, M. (2002): The solar radiation model for Open source GIS: implementation and applications. International GRASS users conference in Trento, Italy, September 2002
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code>; for similar modules in older SAGA versions (pre-2.0.6) see <code><a href="#topic+rsaga.solar.radiation">rsaga.solar.radiation()</a></code> and <code><a href="#topic+rsaga.insolation">rsaga.insolation()</a></code>; <code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code>
</p>

<hr>
<h2 id='rsaga.set.env'>Internal function that sets the RSAGA Geoprocessing Evironment manually</h2><span id='topic+rsaga.set.env'></span>

<h3>Description</h3>

<p>Internal function that sets the RSAGA Geoprocessing Evironment manually
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.set.env(
  workspace = NULL,
  cmd = NULL,
  path = NULL,
  modules = NULL,
  version = NA,
  cores = NULL,
  parallel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.set.env_+3A_workspace">workspace</code></td>
<td>
<p>path of the working directory for SAGA; defaults to the current directory (<code>"."</code>).</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_cmd">cmd</code></td>
<td>
<p>name of the SAGA command line program; defaults to <code>saga_cmd.exe</code>, its name under Windows</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_path">path</code></td>
<td>
<p>path in which to find <code>cmd</code>; <code>rsaga.env</code> is usually able to find SAGA on your system if it is installed; see Details.</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_modules">modules</code></td>
<td>
<p>path in which to find SAGA libraries; see Details</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_version">version</code></td>
<td>
<p>optional character string: SAGA GIS (API) version, e.g. <code>"2.0.8"</code>; if missing, a call to <code><a href="#topic+rsaga.get.version">rsaga.get.version()</a></code> is used to determine version number of SAGA API</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_cores">cores</code></td>
<td>
<p>optional numeric argument, or <code>NA</code>: number of cores used by SAGA GIS; supported only by SAGA GIS 2.1.0 (and higher), ignored otherwise (with a warning). Multicore-enabled SAGA GIS modules such as the one used by <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code> seem to run in multicore mode by default when this argument is not specified, therefore <code>cores</code> should only be specified to use a smaller number of cores than available on a machine.</p>
</td></tr>
<tr><td><code id="rsaga.set.env_+3A_parallel">parallel</code></td>
<td>
<p>optional logical argument (default: <code>FALSE</code>): if <code>TRUE</code>, run RSAGA functions that are capable of parallel processing in parallel mode; note that this is completely independent of the behaviour of SAGA GIS (which can be controlled using the <code>cores</code> argument); currently only some RSAGA functions support parallel processing (e.g., <code><a href="#topic+pick.from.ascii.grid">pick.from.ascii.grid()</a></code> or <code><a href="#topic+rsaga.get.modules">rsaga.get.modules()</a></code>). <code>parallel=TRUE</code> requires that a parallel backend such as <span class="pkg">doSNOW</span> or <span class="pkg">doMC</span> is available and has been started prior to calling any parallelized RSAGA function, otherwise warnings may be generated</p>
</td></tr>
</table>

<hr>
<h2 id='rsaga.sgrd.to.esri'>Convert SAGA grids to ESRI ASCII/binary grids</h2><span id='topic+rsaga.sgrd.to.esri'></span>

<h3>Description</h3>

<p><code>rsaga.sgrd.to.esri</code> converts grid files from SAGA's (version 2) grid
format (.sgrd) to ESRI's ASCII (.asc)  and binary (.flt) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.sgrd.to.esri(
  in.sgrds,
  out.grids,
  out.path,
  format = "ascii",
  georef = "corner",
  prec = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_in.sgrds">in.sgrds</code></td>
<td>
<p>character vector of SAGA grid files (<code>.sgrd</code>) to be
converted;  files are expected to be found in folder
<code><a href="#topic+rsaga.env">rsaga.env</a>()$workspace</code>, or, if an optional <code>env</code> argument
is provided, in <code>env$workspace</code></p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_out.grids">out.grids</code></td>
<td>
<p>character vector of ESRI ASCII/float output file names;
defaults to <code>in.sgrds</code> with the file extension being replaced by
<code>.asc</code> or <code>.flt</code>, depending on <code>format</code>. Files will be
placed in folder <code>out.path</code>, existing files will be overwritten</p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_out.path">out.path</code></td>
<td>
<p>folder for <code>out.grids</code></p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_format">format</code></td>
<td>
<p>output file format, either <code>"ascii"</code> (default; equivalent:
<code>format=1</code>) for ASCII grids or <code>"binary"</code> (equivalent: <code>0</code>)
for binary ESRI grids (<code>.flt</code>).</p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_georef">georef</code></td>
<td>
<p>character: <code>"corner"</code> (equivalent numeric code: <code>0</code>)
or <code>"center"</code> (default; equivalent: <code>1</code>). Determines whether the
georeference will be related to the center or corner of its extreme lower
left grid cell.</p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_prec">prec</code></td>
<td>
<p>number of digits when writing floating point values to ASCII grid
files; either a single number (to be replicated if necessary), or a numeric
vector of length <code>length(in.grids)</code></p>
</td></tr>
<tr><td><code id="rsaga.sgrd.to.esri_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to
<code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA
geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument
passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it
is a numerical error code (0: success), or otherwise (default) a character
vector with the module's console output.
</p>


<h3>Note</h3>

<p>This function uses module 0 from the SAGA library <code>io_grid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.esri.wrapper">rsaga.esri.wrapper()</a></code> for an efficient way of applying
RSAGA to ESRI ASCII/binary grids; <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>

<hr>
<h2 id='rsaga.sink.removal'>Sink Removal
Remove sinks from a digital elevation model by deepening drainage routes or filling sinks.</h2><span id='topic+rsaga.sink.removal'></span>

<h3>Description</h3>

<p>Sink Removal
Remove sinks from a digital elevation model by deepening drainage routes or filling sinks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.sink.removal(in.dem, in.sinkroute, out.dem, method = "fill", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.sink.removal_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.sink.removal_+3A_in.sinkroute">in.sinkroute</code></td>
<td>
<p>optional input: sink route grid file</p>
</td></tr>
<tr><td><code id="rsaga.sink.removal_+3A_out.dem">out.dem</code></td>
<td>
<p>output: modified DEM</p>
</td></tr>
<tr><td><code id="rsaga.sink.removal_+3A_method">method</code></td>
<td>
<p>character string or numeric value specifying the algorithm (partial string matching will be applied): <code>"deepen drainage route"</code> (or 0): reduce the elevation of pixels in order to achieve drainage out of the former sinks <code>"fill sinks"</code> (or 1): fill sinks until none are left</p>
</td></tr>
<tr><td><code id="rsaga.sink.removal_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>This function uses module 1 from SAGA library <code>ta_preprocessor</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.sink.route">rsaga.sink.route()</a></code>, <code><a href="#topic+rsaga.fill.sinks">rsaga.fill.sinks()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: rsaga.sink.route("dem","sinkroute")
rsaga.sink.removal("dem","sinkroute","dem-preproc",method="deepen")
## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.sink.route'>Sink Drainage Route Detection</h2><span id='topic+rsaga.sink.route'></span>

<h3>Description</h3>

<p>Sink drainage route detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.sink.route(in.dem, out.sinkroute, threshold, thrsheight = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.sink.route_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.sink.route_+3A_out.sinkroute">out.sinkroute</code></td>
<td>
<p>output: sink route grid file: non-sinks obtain a value of 0, sinks are assigned an integer between 0 and 8 indicating the direction to which flow from this sink should be routed</p>
</td></tr>
<tr><td><code id="rsaga.sink.route_+3A_threshold">threshold</code></td>
<td>
<p>logical: use a threshold value?</p>
</td></tr>
<tr><td><code id="rsaga.sink.route_+3A_thrsheight">thrsheight</code></td>
<td>
<p>numeric: threshold value (default: <code>100</code>)</p>
</td></tr>
<tr><td><code id="rsaga.sink.route_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, including the <code>env</code> RSAGA geoprocessing environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Note</h3>

<p>I assume that flow directions are coded as 0 = north, 1 = northeast,  2 = east, ..., 7 = northwest, as in <code><a href="#topic+rsaga.fill.sinks">rsaga.fill.sinks()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.sink.removal">rsaga.sink.removal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: rsaga.sink.route("dem","sinkroute")
rsaga.sink.removal("dem","sinkroute","dem-preproc",method="deepen")
## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.slope.asp.curv'>Slope, Aspect, Curvature</h2><span id='topic+rsaga.slope.asp.curv'></span>

<h3>Description</h3>

<p>Calculates local morphometric terrain attributes (i.e. slope, aspect, and curvatures). Intended for use with SAGA v 2.1.1+. For older versions use <code><a href="#topic+rsaga.local.morphometry">rsaga.local.morphometry()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.slope.asp.curv(
  in.dem,
  out.slope,
  out.aspect,
  out.cgene,
  out.cprof,
  out.cplan,
  out.ctang,
  out.clong,
  out.ccros,
  out.cmini,
  out.cmaxi,
  out.ctota,
  out.croto,
  method = "poly2zevenbergen",
  unit.slope = "radians",
  unit.aspect = "radians",
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.slope.asp.curv_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model as SAGA grid file (<code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.slope">out.slope</code></td>
<td>
<p>optional output: slope</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.aspect">out.aspect</code></td>
<td>
<p>optional output: aspect</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.cgene">out.cgene</code></td>
<td>
<p>optional output: general curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.cprof">out.cprof</code></td>
<td>
<p>optional output: profile curvature (vertical curvature; 1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.cplan">out.cplan</code></td>
<td>
<p>optional output: plan curvature (horizontal curvature; 1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.ctang">out.ctang</code></td>
<td>
<p>optional output: tangential curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.clong">out.clong</code></td>
<td>
<p>optional output: longitudinal curvature (1 / map units) Zevenbergen &amp; Thorne (1987) refer to this as profile curvature</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.ccros">out.ccros</code></td>
<td>
<p>optional output: cross-sectional curvature (1 / map units) Zevenbergen &amp; Thorne (1987) refer to this as the plan curvature</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.cmini">out.cmini</code></td>
<td>
<p>optional output: minimal curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.cmaxi">out.cmaxi</code></td>
<td>
<p>optional output: maximal curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.ctota">out.ctota</code></td>
<td>
<p>optional output: total curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_out.croto">out.croto</code></td>
<td>
<p>optional output: flow line curvature (1 / map units)</p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_method">method</code></td>
<td>
<p>character algorithm (see References):
</p>

<ul>
<li><p> 0 Maximum Slope - Travis et al. (1975) (<code>"maxslope"</code>)
</p>
</li>
<li><p> 1 Max. Triangle Slope - Tarboton (1997) (<code>"maxtriangleslope"</code>)
</p>
</li>
<li><p> 2 Least Squares Fit Plane - Costa-Cabral &amp; Burgess (1996) (<code>"lsqfitplane"</code>)
</p>
</li>
<li><p> 3 Fit 2nd Degree Polynomial - Evans (1979) (<code>"poly2evans"</code>)
</p>
</li>
<li><p> 4 Fit 2nd Degree Polynomial - Heerdegen and Beran (1982) (<code>"poly2heerdegen"</code>)
</p>
</li>
<li><p> 5 Fit 2nd Degree Polynomial - Bauer et al. (1985) (<code>"poly2bauer"</code>)
</p>
</li>
<li><p> 6 default: Fit 2nd Degree Polynomial - Zevenbergen &amp; Thorne (1987) (<code>"poly2zevenbergen"</code>)
</p>
</li>
<li><p> 7 Fit 3rd Degree Polynomial - Haralick (1983) (<code>"poly3haralick"</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_unit.slope">unit.slope</code></td>
<td>
<p>character or numeric (default <code>"radians"</code>):
</p>

<ul>
<li><p> 0 <code>"radians"</code>
</p>
</li>
<li><p> 1 <code>"degrees"</code>
</p>
</li>
<li><p> 2 <code>"percent"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_unit.aspect">unit.aspect</code></td>
<td>
<p>character or numeric (default is 0, or <code>"radians"</code>):
</p>

<ul>
<li><p> 0 <code>"radians"</code>
</p>
</li>
<li><p> 1 <code>"degrees"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.slope.asp.curv_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Profile and plan curvature calculation (<code>out.cprof</code>, <code>out.cplan</code>) changed in SAGA GIS 2.1.1+ compared to earlier versions. See the following thread on sourceforge.net for an ongoing discussion: <a href="https://sourceforge.net/p/saga-gis/discussion/354013/thread/e9d07075/#5727">https://sourceforge.net/p/saga-gis/discussion/354013/thread/e9d07075/#5727</a>
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning and Donovan Bangs (R interface), Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>General references:
</p>
<p>Jones KH (1998) A comparison of algorithms used to compute hill slope as a property of the DEM. Computers and Geosciences. 24 (4): 315-323.
</p>
<p>References on specific methods:
</p>
<p>Maximum Slope:
</p>
<p>Travis, M.R., Elsner, G.H., Iverson, W.D., Johnson, C.G. (1975): VIEWIT: computation of seen areas, slope, and aspect for land-use planning. USDA F.S. Gen. Tech. Rep. PSW-11/1975, 70 p. Berkeley, California, U.S.A.
</p>
<p>Maximum Triangle Slope:
</p>
<p>Tarboton, D.G. (1997): A new method for the determination of flow directions and upslope areas in grid digital elevation models. Water Ressources Research, 33(2): 309-319.
</p>
<p>Least Squares or Best Fit Plane:
</p>
<p>Beasley, D.B., Huggins, L.F. (1982): ANSWERS: User's manual. U.S. EPA-905/9-82-001, Chicago, IL, 54 pp.
</p>
<p>Costa-Cabral, M., Burges, S.J. (1994): Digital Elevation Model Networks (DEMON): a model of flow over hillslopes for computation of contributing and dispersal areas. Water Resources Research, 30(6): 1681-1692.
</p>
<p>Fit 2nd Degree Polynomial:
</p>
<p>Evans, I.S. (1979): An integrated system of terrain analysis and slope mapping. Final Report on grant DA-ERO-591-73-G0040. University of Durham, England.
</p>
<p>Bauer, J., Rohdenburg, H., Bork, H.-R. (1985): Ein Digitales Reliefmodell als Vorraussetzung fuer ein deterministisches  Modell der Wasser- und Stoff-Fluesse. Landschaftsgenese und Landschaftsoekologie, H. 10, Parameteraufbereitung fuer deterministische Gebiets-Wassermodelle, Grundlagenarbeiten zur Analyse von Agrar-Oekosystemen, eds.: Bork, H.-R., Rohdenburg, H., p. 1-15.
</p>
<p>Heerdegen, R.G., Beran, M.A. (1982): Quantifying source areas through land surface curvature. Journal of Hydrology, 57.
</p>
<p>Zevenbergen, L.W., Thorne, C.R. (1987): Quantitative analysis of land surface topography. Earth Surface Processes and Landforms, 12: 47-56.
</p>
<p>Fit 3.Degree Polynomial:
</p>
<p>Haralick, R.M. (1983): Ridge and valley detection on digital images. Computer Vision, Graphics and Image Processing, 22(1): 28-38.
</p>
<p>For a discussion on the calculation of slope by ArcGIS check these links:
</p>
<p><a href="https://community.esri.com/?c=93&amp;f=1734&amp;t=239914">https://community.esri.com/?c=93&amp;f=1734&amp;t=239914</a>
</p>
<p><a href="https://webhelp.esri.com/arcgisdesktop/9.2/index.cfm?topicname=how_slope_works">https://webhelp.esri.com/arcgisdesktop/9.2/index.cfm?topicname=how_slope_works</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.local.morphometry">rsaga.local.morphometry()</a></code>, <code><a href="#topic+rsaga.parallel.processing">rsaga.parallel.processing()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>,  <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simple slope, aspect, and general curvature in degrees:
rsaga.slope.asp.curv("lican.sgrd", "slope", "aspect", "curvature",
                     method = "maxslope", unit.slope = "degrees", unit.aspect = "degrees")
# same for ASCII grids (default extension .asc):
rsaga.esri.wrapper(rsaga.slope.asp.curv,
                   in.dem="lican", out.slope="slope",
                   out.aspect = "aspect", out.cgene = "curvature",
                   method="maxslope", unit.slope = "degrees", unit.aspect = "degrees")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.solar.radiation'>Potential incoming solar radiation</h2><span id='topic+rsaga.solar.radiation'></span>

<h3>Description</h3>

<p>This function calculates the potential incoming solar radiation in an area either using a lumped atmospheric transmittance model or estimating it based on water and dust content. Use <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code> instead with SAGA GIS 2.0.6+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.solar.radiation(
  in.dem,
  out.grid,
  out.duration,
  latitude,
  unit = c("kWh/m2", "J/m2"),
  solconst = 1367,
  method = c("lumped", "components"),
  transmittance = 70,
  pressure = 1013,
  water.content = 1.68,
  dust = 100,
  time.range = c(0, 24),
  time.step = 1,
  days = list(day = 21, month = 3),
  day.step = 5,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.solar.radiation_+3A_in.dem">in.dem</code></td>
<td>
<p>name of input digital elevation model (DEM) grid in SAGA grid format (default extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_out.grid">out.grid</code></td>
<td>
<p>output grid file for potential incoming solar radiation sums</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_out.duration">out.duration</code></td>
<td>
<p>Optional output grid file for duration of insolation</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_latitude">latitude</code></td>
<td>
<p>Geographical latitude in degree North (negative values indicate southern hemisphere)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_unit">unit</code></td>
<td>
<p>unit of the <code>out.grid</code> output: <code>"kWh/m2"</code> (default) or <code>"J/m2"</code></p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_solconst">solconst</code></td>
<td>
<p>solar constant, defaults to 1367 W/m2</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_method">method</code></td>
<td>
<p>specifies how the atmospheric components should be accounted for: either based on a lumped atmospheric transmittance as specified by argument <code>transmittance</code> (<code>"lumped"</code>, or numeric code <code>0</code>; default); or by calculating the components corresponding to water and dust (<code>"components"</code>, code <code>1</code>)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_transmittance">transmittance</code></td>
<td>
<p>transmittance of the atmosphere in percent; usually between 60 (humid areas) and 80 percent (deserts)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_pressure">pressure</code></td>
<td>
<p>atmospheric pressure in mbar</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_water.content">water.content</code></td>
<td>
<p>water content of a vertical slice of the atmosphere in cm: between 1.5 and 1.7cm, average 1.68cm (default)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_dust">dust</code></td>
<td>
<p>dust factor in ppm; defaults to 100ppm</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_time.range">time.range</code></td>
<td>
<p>numeric vector of length 2:  time span (hours of the day) for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_time.step">time.step</code></td>
<td>
<p>time step in hours for numerical integration</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_days">days</code></td>
<td>
<p>either a list with components <code>day</code> and <code>month</code> specifying a single day of the year for radiation modeling; OR a numeric vector of length 2 specifying the start and end date (see Note below)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_day.step">day.step</code></td>
<td>
<p>if <code>days</code> indicates a range of days, this specifies the time step (number of days) for calculating the incoming solar radiation</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment obtained with <code><a href="#topic+rsaga.env">rsaga.env()</a></code>; this argument is required for version control (see Note)</p>
</td></tr>
<tr><td><code id="rsaga.solar.radiation_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This module ceased to exist under SAGA GIS 2.0.6+, which has a similar (but more flexible) module Potential Solar Radiation that is interfaced by <code><a href="#topic+rsaga.pisr">rsaga.pisr()</a></code>.
</p>
<p>SAGA_CMD uses zero-based days and months, but this R function uses the standard one-based days and months (e.g. day 1 is the first day of the month, month 1 is January) and translates to the SAGA system.
</p>
<p>In SAGA 2.0.2, solar radiation sums calculated for a range of days, say <code>days=c(a,b)</code> actually calculate radiation only for days <code style="white-space: pre;">&#8288;a,...,b-1&#8288;</code> (in steps of <code>day.step</code> - I used <code>day.step=1</code> in this example).  The setting <code>a=b</code> however gives the same result as <code>b=a+1</code>, and indeed <code>b=a+2</code> gives twice the radiation sums and potential sunshine duration that <code>a=b</code> and <code>b=a+1</code> both give.
</p>
<p>The solar radiation module of SAGA 2.0.1 had a bug that made it impossible to pass a range of <code>days</code> of the year or a range of hours of the day (<code>time.range</code>) to SAGA. These options work in SAGA 2.0.1.
</p>
<p>This function uses module Incoming Solar Radiation from SAGA GIS library <code>ta_lighting</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>Wilson, J.P., Gallant, J.C. (eds.), 2000: Terrain analysis - principles and applications. New York, John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.hillshade">rsaga.hillshade()</a></code>, <code><a href="#topic+rsaga.insolation">rsaga.insolation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# potential solar radiation on Nov 7 in Southern Ontario...
rsaga.solar.radiation("dem","solrad","soldur",latitude=43,
    days=list(day=7,month=11),time.step=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.target'>Define target grid for interpolation</h2><span id='topic+rsaga.target'></span>

<h3>Description</h3>

<p>Define the resolution and extent of a target grid for interpolation by SAGA
modules based on (1) user-provided x/y coordinates, (2) an existing SAGA grid
file, or (3) the header data of an ASCII grid. Intended to be used with
RSAGA's interpolation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.target(
  target = c("user.defined", "target.grid", "header"),
  user.cellsize = 100,
  user.x.extent,
  user.y.extent,
  target.grid,
  header,
  env = rsaga.env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.target_+3A_target">target</code></td>
<td>
<p>character: method used for defining the target grid</p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_user.cellsize">user.cellsize</code></td>
<td>
<p>Only for <code>target="user.defined"</code>: raster resolution
(in the grid's map units)</p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_user.x.extent">user.x.extent</code></td>
<td>
<p>See <code>user.y.extent</code></p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_user.y.extent">user.y.extent</code></td>
<td>
<p>Only for <code>target="user.defined"</code>: numeric vectors
of length 2: minimum and maximum coordinates of grid cell center points</p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_target.grid">target.grid</code></td>
<td>
<p>Only for <code>target="target.grid"</code>: character string
giving the name of a SAGA grid file that specifies the extent and
resolution of the target grid; this target grid file may be overwritten,
depending on the specifics of the SAGA GIS module used.</p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_header">header</code></td>
<td>
<p>Only for <code>target="header"</code>: list: ASCII grid header (as
returned e.g. by <code><a href="#topic+read.ascii.grid.header">read.ascii.grid.header()</a></code>) or defined manually;
must at least have components <code>ncols</code>, <code>nrows</code>, <code>cellsize</code>,
and either <code>x/yllcorner</code> or <code>x/yllcenter</code>.</p>
</td></tr>
<tr><td><code id="rsaga.target_+3A_env">env</code></td>
<td>
<p>A SAGA geoprocessing environment, see <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is to be used with RSAGA functions
<code><a href="#topic+rsaga.inverse.distance">rsaga.inverse.distance()</a></code>, <code><a href="#topic+rsaga.nearest.neighbour">rsaga.nearest.neighbour()</a></code>
and <code><a href="#topic+rsaga.modified.quadratic.shephard">rsaga.modified.quadratic.shephard()</a></code>. Note that these are
currently only compatible with SAGA GIS 2.0.5 and higher.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.ascii.grid.header">read.ascii.grid.header()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# IDW interpolation of attribute "z" from the point shapefile
# 'points.shp' to a grid with the same extent and resolution
# as the (pre-existing) geology grid:
rsaga.inverse.distance("points", "dem", field = "z", maxdist = 1000,
    target = rsaga.target(target="target.grid",
    target.grid = "geology"))

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.topdown.processing'>Top-Down Processing</h2><span id='topic+rsaga.topdown.processing'></span>

<h3>Description</h3>

<p>Calculate the size of the local catchment area (contributing area), accumulated material, and flow path length, using top-down processing algorithms from the highest to the lowest cell. <br /> Top-Down Processing is new with SAGA GIS 2.1.3. See <code><a href="#topic+rsaga.parallel.processing">rsaga.parallel.processing()</a></code> with older versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.topdown.processing(
  in.dem,
  in.sinkroute,
  in.weight,
  in.mean,
  in.material,
  in.target,
  in.lin.val,
  in.lin.dir,
  out.carea,
  out.mean,
  out.tot.mat,
  out.acc.left,
  out.acc.right,
  out.flowpath,
  step,
  method = "mfd",
  linear.threshold = Inf,
  convergence = 1.1,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.topdown.processing_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.sinkroute">in.sinkroute</code></td>
<td>
<p>optional input: SAGA grid with sink routes</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.weight">in.weight</code></td>
<td>
<p>optional input: SAGA grid with weights</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.mean">in.mean</code></td>
<td>
<p>optional input: SAGA grid for mean over catchment calculation</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.material">in.material</code></td>
<td>
<p>optional input: SAGA grid with material</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.target">in.target</code></td>
<td>
<p>optional input: SAGA grid of accumulation target</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.lin.val">in.lin.val</code></td>
<td>
<p>optional input: SAGA grid providing values to be compared with linear flow threshold instead of catchment area</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_in.lin.dir">in.lin.dir</code></td>
<td>
<p>optional input: SAGA grid to be used for linear flow routing, if the value is a valid direction (0-7 = N, NE, E, SE, S, SW, W, NW)</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.carea">out.carea</code></td>
<td>
<p>output: catchment area grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.mean">out.mean</code></td>
<td>
<p>optional output: mean over catchment grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.tot.mat">out.tot.mat</code></td>
<td>
<p>optional output: total accumulated material grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.acc.left">out.acc.left</code></td>
<td>
<p>optional output: accumulated material from left side grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.acc.right">out.acc.right</code></td>
<td>
<p>optional output: accumulated material from right side grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_out.flowpath">out.flowpath</code></td>
<td>
<p>optional output: flow path length grid</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_step">step</code></td>
<td>
<p>integer &gt;=1: step parameter</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_method">method</code></td>
<td>
<p>character or numeric: choice of processing algorithm (default <code>"mfd"</code>, or 4):
</p>

<ul>
<li><p> 0 Deterministic 8 (<code>"d8"</code> or 0)
</p>
</li>
<li><p> 1 Rho 8 (<code>"rho8"</code>, or 1)
</p>
</li>
<li><p> 2 Braunschweiger Reliefmodell (<code>"braunschweig"</code> or 2)
</p>
</li>
<li><p> 3 Deterministic Infinity (<code>"dinf"</code> or 3)
</p>
</li>
<li><p> 4 Multiple Flow Direction (<code>"mfd"</code> or 4)
</p>
</li>
<li><p> 5 Multiple Triangular Flow Direction (<code>"mtfd"</code>, or 5)
</p>
</li>
<li><p> 6 Multiple Maximum Gradient Based Flow Direction (<code>"mdg"</code>, or 6)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_linear.threshold">linear.threshold</code></td>
<td>
<p>numeric (number of grid cells): threshold above which linear flow (i.e. the Deterministic 8 algorithm) will be used; linear flow is disabled for <code>linear.threshold=Inf</code> (the default)</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_convergence">convergence</code></td>
<td>
<p>numeric &gt;=0: a parameter for tuning convergent/ divergent flow; default value of <code>1.1</code> gives realistic results and should not be changed</p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_env">env</code></td>
<td>
<p>list, setting up a SAGA geoprocessing environment as created by <code><a href="#topic+rsaga.env">rsaga.env()</a></code></p>
</td></tr>
<tr><td><code id="rsaga.topdown.processing_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refer to the references for details on the available algorithms.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning and Donovan Bangs (R interface), Olaf Conrad (SAGA module), Thomas Grabs (MTFD algorithm)
</p>


<h3>References</h3>

<p>Deterministic 8:
</p>
<p>O'Callaghan, J.F., Mark, D.M. (1984): The extraction of drainage networks from digital elevation data. Computer Vision, Graphics and Image Processing, 28: 323-344.
</p>
<p>Rho 8:
</p>
<p>Fairfield, J., Leymarie, P. (1991): Drainage networks from grid digital elevation models. Water Resources Research, 27: 709-717.
</p>
<p>Braunschweiger Reliefmodell:
</p>
<p>Bauer, J., Rohdenburg, H., Bork, H.-R. (1985): Ein Digitales Reliefmodell als Vorraussetzung fuer ein deterministisches Modell der Wasser- und Stoff-Fluesse. Landschaftsgenese und Landschaftsoekologie, H. 10, Parameteraufbereitung fuer deterministische Gebiets-Wassermodelle, Grundlagenarbeiten zu Analyse von Agrar-Oekosystemen, eds.: Bork, H.-R., Rohdenburg, H., p. 1-15.
</p>
<p>Deterministic Infinity:
</p>
<p>Tarboton, D.G. (1997): A new method for the determination of flow directions and upslope areas in grid digital elevation models. Water Ressources Research, 33(2): 309-319.
</p>
<p>Multiple Flow Direction:
</p>
<p>Freeman, G.T. (1991): Calculating catchment area with divergent flow based on a regular grid. Computers and Geosciences, 17: 413-22.
</p>
<p>Quinn, P.F., Beven, K.J., Chevallier, P., Planchon, O. (1991): The prediction of hillslope flow paths for distributed hydrological modelling using digital terrain models. Hydrological Processes, 5: 59-79.
</p>
<p>Multiple Triangular Flow Direction:
</p>
<p>Seibert, J., McGlynn, B. (2007): A new triangular multiple flow direction algorithm for computing upslope areas from gridded digital elevation models. Water Ressources Research, 43, W04501.
</p>
<p>Multiple Flow Direction Based on Maximum Downslope Gradient:
</p>
<p>Qin, C.Z., Zhu, A-X., Pei, T., Li, B.L., Scholten, T., Zhou, C.H. (2011): An approach to computing topographic wetness index based on maximum downslope gradient. Precision Agriculture, 12(1): 32-43.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.parallel.processing">rsaga.parallel.processing()</a></code>, <code><a href="#topic+rsaga.wetness.index">rsaga.wetness.index()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculation of contributing area with default settings:
rsaga.topdown.processing(in.dem = "dem", out.carea = "carea")
# Calculation of contributing area by maximunm downslope gradient:
rsaga.topdown.processing(in.dem = "dem", out.carea = "carea",
                         method = "mdg")

## End(Not run)
</code></pre>

<hr>
<h2 id='rsaga.union.polygons'>Spatial union of two polygon layers</h2><span id='topic+rsaga.union.polygons'></span>

<h3>Description</h3>

<p>The function <code>rsaga.union.polygons</code> uses SAGA function
&quot;<code>Union</code>&quot; to calculate the geometric union of two polygon layers. This
corresponds to the intersection and the symmetrical difference of the two
layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.union.polygons(
  layer_a = NULL,
  layer_b = NULL,
  result = NULL,
  split = FALSE,
  load = NULL,
  env = rsaga.env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.union.polygons_+3A_layer_a">layer_a</code></td>
<td>
<p>A <code>character</code> string representing the path to a polygon
shapefile.</p>
</td></tr>
<tr><td><code id="rsaga.union.polygons_+3A_layer_b">layer_b</code></td>
<td>
<p>A <code>character</code> string representing the path to a polygon
shapefile with which to union layer_a.</p>
</td></tr>
<tr><td><code id="rsaga.union.polygons_+3A_result">result</code></td>
<td>
<p><code>character</code>, path indicating where to store the output
shapefile.</p>
</td></tr>
<tr><td><code id="rsaga.union.polygons_+3A_split">split</code></td>
<td>
<p>If <code>TRUE</code>, multipart polygons become separated polygons
(default: FALSE).</p>
</td></tr>
<tr><td><code id="rsaga.union.polygons_+3A_load">load</code></td>
<td>
<p>Deprecated, will be removed in a future release. Ignored
if <code>FALSE</code>, and causes an error if <code>TRUE</code>  (default: NULL)</p>
</td></tr>
<tr><td><code id="rsaga.union.polygons_+3A_env">env</code></td>
<td>
<p>RSAGA geoprocessing environment created by
<code><a href="#topic+rsaga.env">rsaga.env()</a></code>, required because module(s) depend(s) on SAGA
version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>gUnion()</code> in <code>rgeos</code> package can also be used for joining
intersecting polygon geometries. However,
<code><a href="#topic+rsaga.union.polygons">rsaga.union.polygons()</a></code> will be usually much faster,
especially when joining thousands of polygons.
</p>


<h3>Value</h3>

<p>The function saves the output shapefile to the path indicated in
function argument <code>result</code>.
</p>


<h3>Author(s)</h3>

<p>Jannes Muenchow and Alexander Brenning (R interface), Olaf Conrad and Angus Johnson (SAGA
modules)
</p>

<hr>
<h2 id='rsaga.wetness.index'>SAGA Modules SAGA Wetness Index</h2><span id='topic+rsaga.wetness.index'></span>

<h3>Description</h3>

<p>Calculate the SAGA Wetness Index (SWI), a modified topographic wetness index (TWI)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsaga.wetness.index(
  in.dem,
  out.wetness.index,
  out.carea,
  out.cslope,
  out.mod.carea,
  suction,
  area.type,
  slope.type,
  slope.min,
  slope.offset,
  slope.weight,
  t.param,
  env = rsaga.env(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsaga.wetness.index_+3A_in.dem">in.dem</code></td>
<td>
<p>input: digital elevation model (DEM) as SAGA grid file (default file extension: <code>.sgrd</code>)</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_out.wetness.index">out.wetness.index</code></td>
<td>
<p>output file (optional): wetness index grid file name. Existing files of the same name will be overwritten!</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_out.carea">out.carea</code></td>
<td>
<p>output file (optional): catchment area grid file name</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_out.cslope">out.cslope</code></td>
<td>
<p>output file (optional): catchment slope grid file name</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_out.mod.carea">out.mod.carea</code></td>
<td>
<p>output file (optional): file name of modified catchment area grid</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_suction">suction</code></td>
<td>
<p>SAGA GIS 2.1.0+: positive numeric value (optional): the lower this value is the stronger is the suction effect; defaults to a value of 10 (more detailed information is currently not available  in the SAGA GIS documentation</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_area.type">area.type</code></td>
<td>
<p>character or numeric (optional): type of area: <code>"absolute"</code> (or numeric code 0): absolute catchment area; <code>"square root"</code> (code 1; the default e.g. in SAGA 2.3.1): square root of catchment area; <code>"specific"</code> (code 2; the default e.g. in SAGA 8.4.1): specific catchment area</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_slope.type">slope.type</code></td>
<td>
<p>character or numeric (optional): type of slope: <code>"local"</code> (or numeric code 0): local slope; <code>"catchment"</code> (or code 1; the default): catchment slope.</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_slope.min">slope.min</code></td>
<td>
<p>numeric (optional): minimum slope; default: 0</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_slope.offset">slope.offset</code></td>
<td>
<p>numeric (optional): offset slope; default: 0.1</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_slope.weight">slope.weight</code></td>
<td>
<p>numeric (optional): weighting factor for slope in index calculation; default: 1</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_t.param">t.param</code></td>
<td>
<p>SAGA GIS up to version 2.0.8: positive numeric value (optional): undocumented</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_env">env</code></td>
<td>
<p>A SAGA geoprocessing environment, see <code><a href="#topic+rsaga.env">rsaga.env()</a></code>.)</p>
</td></tr>
<tr><td><code id="rsaga.wetness.index_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SAGA Wetness Index is similar to the  Topographic Wetness Index (TWI), but it is based on a modified  catchment area calculation (<code>out.mod.carea</code>), which does not treat the flow as a thin film as done in the calculation of catchment areas in conventional algorithms. As a result, the SWI tends to assign a more realistic, higher potential soil wetness than the TWI to grid cells situated in valley floors with a small vertical distance to a channel.
</p>
<p>This module and its arguments changed substantially from SAGA GIS 2.0.8 to version 2.1.0. It appears to me that the new algorithm is similar (but not identical) to the old one when using <code>area.type="absolute"</code> and <code>slope.type="local"</code> but I haven't tried out all possible options. This help file will be updated as soon as additional documentation becomes available.
</p>


<h3>Value</h3>

<p>The type of object returned depends on the <code>intern</code> argument passed to the <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>. For <code>intern=FALSE</code> it is a numerical error code (0: success), or otherwise (the default) a character vector with the module's console output.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning (R interface), Juergen Boehner and Olaf Conrad (SAGA module)
</p>


<h3>References</h3>

<p>Boehner, J., Koethe, R. Conrad, O., Gross, J.,  Ringeler, A., Selige, T. (2002): Soil Regionalisation by Means of Terrain Analysis and Process Parameterisation. In: Micheli, E., Nachtergaele, F., Montanarella, L. (ed.): Soil Classification 2001. European Soil Bureau, Research Report No. 7, EUR 20398 EN, Luxembourg. pp.213-222.
</p>
<p>Boehner, J. and Selige, T. (2006): Spatial prediction of soil attributes using terrain analysis and climate regionalisation. In: Boehner, J., McCloy, K.R., Strobl, J. [Ed.: SAGA - Analysis and Modelling Applications, Goettinger Geographische Abhandlungen, Goettingen: 13-28.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsaga.parallel.processing">rsaga.parallel.processing()</a></code>, <code><a href="#topic+rsaga.geoprocessor">rsaga.geoprocessor()</a></code>, <code><a href="#topic+rsaga.env">rsaga.env()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# using SAGA grids:
rsaga.wetness.index("dem.sgrd","swi.sgrd")

## End(Not run)
</code></pre>

<hr>
<h2 id='set.file.extension'>Determine or modify file name extensions</h2><span id='topic+set.file.extension'></span><span id='topic+get.file.extension'></span><span id='topic+default.file.extension'></span>

<h3>Description</h3>

<p>Function <code>get.file.extension</code> determines the file extension, <code>set.file.extension</code> changes it, and <code>default.file.extension</code> changes it only if it is not already specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.file.extension(filename, extension, fsep = .Platform$file.sep)

get.file.extension(filename, fsep = .Platform$file.sep)

default.file.extension(filename, extension, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.file.extension_+3A_filename">filename</code></td>
<td>
<p>character vector: file name(s), possibly including paths and extensions; a file name ending with a <code>"."</code> is interpreted as having extension <code>""</code>, while a file name that doesn't contain a <code>"."</code> is interpreted has having no extension.</p>
</td></tr>
<tr><td><code id="set.file.extension_+3A_extension">extension</code></td>
<td>
<p>character string: file extension, without the dot</p>
</td></tr>
<tr><td><code id="set.file.extension_+3A_fsep">fsep</code></td>
<td>
<p>character: separator between paths</p>
</td></tr>
<tr><td><code id="set.file.extension_+3A_force">force</code></td>
<td>
<p>logical argument to <code>default.file.extension</code>: force the file extension to be <code>extension</code> (same result as <code>set.file.extension</code>), or only set it to extension if it has not been specified?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of same length as <code>filename</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fnm = c("C:/TEMP.DIR/temp","C:/TEMP.DIR/tmp.txt","tempfile.")
get.file.extension(fnm)
set.file.extension(fnm,extension=".TMP")
default.file.extension(fnm,extension=".TMP")
</code></pre>

<hr>
<h2 id='wind.shelter'>Wind Shelter Index</h2><span id='topic+wind.shelter'></span><span id='topic+wind.shelter.prep'></span>

<h3>Description</h3>

<p><code>wind.shelter</code> is a function to be used with <code><a href="#topic+focal.function">focal.function()</a></code> to calculate a topographic wind shelter index from a digital elevation model, which is a proxy for snow accumulation on the lee side of topographic obstacles. <code>wind.shelter.prep</code> performs some preparatory calculations to speed up repeated calls to <code>wind.shelter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind.shelter(x, prob = NULL, control)

wind.shelter.prep(radius, direction, tolerance, cellsize = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wind.shelter_+3A_x">x</code></td>
<td>
<p>square matrix of elevation data</p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_prob">prob</code></td>
<td>
<p>numeric: quantile of slope values to be used in computing the wind shelter index; if <code>NULL</code>, use <code>max</code> (equivalent to <code>prob=1</code>)</p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_control">control</code></td>
<td>
<p>required argument: the result of a call to <code>wind.shelter.prep</code></p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_radius">radius</code></td>
<td>
<p>radius (&gt;1) of circle segment to be used (number of grid cells, not necessarily an integer)</p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_direction">direction</code></td>
<td>
<p>wind direction: direction from which the wind originates; North = 0 = <code>2*pi</code>, clockwise angles.</p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_tolerance">tolerance</code></td>
<td>
<p>directional tolerance</p>
</td></tr>
<tr><td><code id="wind.shelter_+3A_cellsize">cellsize</code></td>
<td>
<p>grid cellsize</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wind.shelter</code> implements a wind shelter index used by Plattner et al. (2004) for modeling snow accumulation patterns on a glacier in the Austrian Alps. It is a modified version of the algorithm of Winstral et al. (2002). The wind shelter index of Plattner et al. (2004) is defined as:
</p>
<p><code style="white-space: pre;">&#8288;Shelter index(S) = arctan( max( (z(x0)-z(x)) / |x0-x| : x in S ) ),&#8288;</code>
</p>
<p>where <code>S = S(x0,a,da,d)</code> is the set of grid nodes within a distance <code style="white-space: pre;">&#8288;&lt;=d&#8288;</code> from <code>x0</code>, only considering grid nodes in directions between <code>a-da</code> and <code>a+da</code> from <code>x0</code>.
</p>
<p>The present implementation generalizes this index by replacing <code>max</code> by the <code>quantile</code> function; the <code>max</code> function is used if <code>prob=NULL</code>, and the same result is obtained for <code>prob=1</code> using the <code>quantile</code> function.
</p>


<h3>Value</h3>

<p>The function <code>wind.shelter</code> returns the wind shelter index as described above if a numeric matrix <code>x</code> is provided. If it is missing, it returns the character string <code>"windshelter"</code>.
</p>
<p><code>wind.shelter.prep</code> returns a list with components <code>mask</code> and <code>dist</code>. Both are square matrices with <code>2*(ceiling(radius)+1)</code> columns and rows:
</p>
<table>
<tr><td><code>mask</code></td>
<td>
<p>indicates which grid cell in the moving window is within the specified circle segment (value <code>FALSE</code>) or not (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>the precomputed distances of a grid cell to the center of the moving window, in map units</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The wind shelter index only makes sense if elevation is measured in the same units as the horizontal map units used for the <code>cellsize</code> argument (i.e. usually meters).
</p>
<p><code>wind.shelter</code> and <code>wind.shelter.prep</code> do not restrict the calculation to a circular area; this is done by <code><a href="#topic+focal.function">focal.function()</a></code> when used in combination with that function (assuming <code>search.mode="circle"</code>).
</p>
<p>Note that the present definition of the wind shelter index returns negative values for surfaces that are completely exposed toward the specified direction. This may make sense if interpreted as a &quot;wind exposure index&quot;, or it might be appropriate to set negative wind shelter values to 0.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Plattner, C., Braun, L.N., Brenning, A. (2004): Spatial variability of snow accumulation on Vernagtferner, Austrian Alps, in winter 2003/2004. Zeitschrift fuer Gletscherkunde und Glazialgeologie, 39: 43-57.
</p>
<p>Winstral, A., Elder, K., Davis, R.E. (2002): Spatial snow modeling of wind-redistributed snow using terrain-based parameters. Journal of Hydrometeorology, 3: 524-538.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal.function">focal.function()</a></code>, <code><a href="stats.html#topic+quantile">quantile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Settings used by Plattner et al. (2004):
ctrl = wind.shelter.prep(6,-pi/4,pi/12,10)
## Not run: focal.function("dem.asc",fun=wind.shelter,control=ctrl,
    radius=6,search.mode="circle")
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
