<!DOCTYPE html><html><head><title>Help for package stream</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stream}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agreement'><p>Agreement-based Measures for Clustering</p></a></li>
<li><a href='#animate_cluster'><p>Animates Plots of the Clustering Process</p></a></li>
<li><a href='#animate_data'><p>Animates the Plotting of a Data Streams</p></a></li>
<li><a href='#close_stream'><p>Close a Data Stream</p></a></li>
<li><a href='#DSAggregate'><p>Data Stream Aggregator Base Classes</p></a></li>
<li><a href='#DSAggregate_Sample'><p>Sampling from a Data Stream (Data Stream Operator)</p></a></li>
<li><a href='#DSAggregate_Window'><p>Sliding Window (Data Stream Operator)</p></a></li>
<li><a href='#DSC'><p>Data Stream Clustering Base Class</p></a></li>
<li><a href='#DSC_BICO'><p>BICO - Fast computation of k-means coresets in a data stream</p></a></li>
<li><a href='#DSC_BIRCH'><p>Balanced Iterative Reducing Clustering using Hierarchies</p></a></li>
<li><a href='#DSC_DBSCAN'><p>DBSCAN Macro-clusterer</p></a></li>
<li><a href='#DSC_DBSTREAM'><p>DBSTREAM Clustering Algorithm</p></a></li>
<li><a href='#DSC_DStream'><p>D-Stream Data Stream Clustering Algorithm</p></a></li>
<li><a href='#DSC_EA'><p>Reclustering using an Evolutionary Algorithm</p></a></li>
<li><a href='#DSC_evoStream'><p>evoStream - Evolutionary Stream Clustering</p></a></li>
<li><a href='#DSC_Hierarchical'><p>Hierarchical Micro-Cluster Reclusterer</p></a></li>
<li><a href='#DSC_Kmeans'><p>Kmeans Macro-clusterer</p></a></li>
<li><a href='#DSC_Macro'><p>Abstract Class for Macro Clusterers (Offline Component)</p></a></li>
<li><a href='#DSC_Micro'><p>Abstract Class for Micro Clusterers (Online Component)</p></a></li>
<li><a href='#DSC_R'><p>Abstract Class for Implementing R-based Clusterers</p></a></li>
<li><a href='#DSC_Reachability'><p>Reachability Micro-Cluster Reclusterer</p></a></li>
<li><a href='#DSC_Sample'><p>Extract a Fixed-size Sample from a Data Stream</p></a></li>
<li><a href='#DSC_SlidingWindow'><p>DSC_SlidingWindow &ndash; Data Stream Clusterer Using a Sliding Window</p></a></li>
<li><a href='#DSC_Static'><p>Create as Static Copy of a Clustering</p></a></li>
<li><a href='#DSC_TwoStage'><p>TwoStage Clustering Process</p></a></li>
<li><a href='#DSC_Window'><p>A sliding window from a Data Stream</p></a></li>
<li><a href='#DSClassifier'><p>Abstract Class for Data Stream Classifiers</p></a></li>
<li><a href='#DSClassifier_SlidingWindow'><p>DSClassifier_SlidingWindow &ndash; Data Stream Classifier Using a Sliding Window</p></a></li>
<li><a href='#DSD'><p>Data Stream Data Generator Base Classes</p></a></li>
<li><a href='#DSD_BarsAndGaussians'><p>Data Stream Generator for Bars and Gaussians</p></a></li>
<li><a href='#DSD_Benchmark'><p>Data Stream Generator for Dynamic Data Stream Benchmarks</p></a></li>
<li><a href='#DSD_Cubes'><p>Static Cubes Data Stream Generator</p></a></li>
<li><a href='#DSD_Gaussians'><p>Mixture of Gaussians Data Stream Generator</p></a></li>
<li><a href='#DSD_Memory'><p>A Data Stream Interface for Data Stored in Memory</p></a></li>
<li><a href='#DSD_MG'><p>DSD Moving Generator</p></a></li>
<li><a href='#DSD_Mixture'><p>Mixes Data Points from Several Streams into a Single Stream</p></a></li>
<li><a href='#DSD_mlbenchData'><p>Stream Interface for Data Sets From mlbench</p></a></li>
<li><a href='#DSD_mlbenchGenerator'><p>mlbench Data Stream Generator</p></a></li>
<li><a href='#DSD_NULL'><p>Placeholder for a DSD Stream</p></a></li>
<li><a href='#DSD_ReadDB'><p>Read a Data Stream from an open DB Query</p></a></li>
<li><a href='#DSD_ReadStream'><p>Read a Data Stream from a File or a Connection</p></a></li>
<li><a href='#DSD_ScaleStream'><p>Deprecated DSD_ScaleStream</p></a></li>
<li><a href='#DSD_Target'><p>Target Data Stream Generator</p></a></li>
<li><a href='#DSD_UniformNoise'><p>Uniform Noise Data Stream Generator</p></a></li>
<li><a href='#DSF'><p>Data Stream Filter Base Classes</p></a></li>
<li><a href='#DSF_Convolve'><p>Apply a Filter to a Data Stream</p></a></li>
<li><a href='#DSF_Downsample'><p>Downsample a Data Stream</p></a></li>
<li><a href='#DSF_dplyr'><p>Apply a dplyr Transformation to a Data Stream</p></a></li>
<li><a href='#DSF_ExponentialMA'><p>Exponential Moving Average over a Data Stream</p></a></li>
<li><a href='#DSF_Func'><p>Apply a Function to Transformation to a Data Stream</p></a></li>
<li><a href='#DSF_Scale'><p>Scale a Data Stream</p></a></li>
<li><a href='#DSFP'><p>Abstract Class for Frequent Pattern Mining Algorithms for Data Streams</p></a></li>
<li><a href='#DSOutlier'><p>Abstract Class for Data Stream Outlier Detectors</p></a></li>
<li><a href='#DSRegressor'><p>Abstract Class for Data Stream Regressors</p></a></li>
<li><a href='#DSRegressor_SlidingWindow'><p>DSRegressor_SlidingWindow &ndash; Data Stream Regressor Using a Sliding Window</p></a></li>
<li><a href='#DST'><p>Conceptual Base Class for All Data Stream Mining Tasks</p></a></li>
<li><a href='#DST_Multi'><p>Apply Multiple Task to the Same Data Stream</p></a></li>
<li><a href='#DST_SlidingWindow'><p>DST_SlidingWindow &ndash; Call R Functions on a Sliding Window</p></a></li>
<li><a href='#DST_WriteStream'><p>Task to Write a Stream to a File or a Connection</p></a></li>
<li><a href='#evaluate'><p>Evaluate a Data Stream Mining Task</p></a></li>
<li><a href='#evaluate.DSC'><p>Evaluate a Stream Clustering Task</p></a></li>
<li><a href='#get_assignment'><p>Assignment Data Points to Clusters deprecated</p></a></li>
<li><a href='#get_points'><p>Get Points from a Data Stream Generator</p></a></li>
<li><a href='#MGC'><p>Moving Generator Cluster</p></a></li>
<li><a href='#plot.DSC'><p>Plot Results of a Data Stream Clustering</p></a></li>
<li><a href='#plot.DSD'><p>Plot Data Stream Data</p></a></li>
<li><a href='#predict'><p>Make a Prediction for a Data Stream Mining Task</p></a></li>
<li><a href='#prune_clusters'><p>Prune Clusters from a Clustering</p></a></li>
<li><a href='#read_saveDSC'><p>Save and Read DSC Objects</p></a></li>
<li><a href='#recluster'><p>Re-clustering micro-clusters</p></a></li>
<li><a href='#reset_stream'><p>Reset a Data Stream to its Beginning</p></a></li>
<li><a href='#stream_pipeline'><p>Create a Data Stream Pipeline</p></a></li>
<li><a href='#stream-package'><p>stream: Infrastructure for Data Stream Mining</p></a></li>
<li><a href='#update'><p>Update a Data Stream Mining Task Model with Points from a Stream</p></a></li>
<li><a href='#write_stream'><p>Write a Data Stream to a File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-28</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Infrastructure for Data Stream Mining</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for data stream modeling and associated data mining tasks such as clustering and classification. The development of this package was supported in part by NSF IIS-0948893, NSF CMMI 1728612, and NIH R21HG005912. Hahsler et al (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i14">doi:10.18637/jss.v076.i14</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods, proxy (&ge; 0.4-7), magrittr</td>
</tr>
<tr>
<td>Imports:</td>
<td>clue, cluster, clusterGeneration, dbscan (&ge; 1.0-0), fpc,
graphics, grDevices, MASS, mlbench, rpart, Rcpp (&ge; 0.11.4),
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>animation, DBI, dplyr, rJava, RSQLite, testthat, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/stream">https://github.com/mhahsler/stream</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhahsler/stream/issues">https://github.com/mhahsler/stream/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 19:46:08 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Matthew Bolaños [ctb],
  John Forrest [ctb],
  Matthias Carnein [ctb],
  Dennis Assenmacher [ctb],
  Dalibor Krleža [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-28 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agreement'>Agreement-based Measures for Clustering</h2><span id='topic+agreement'></span>

<h3>Description</h3>

<p>Calculates the agreement between two partitions, typically the known actual cluster labels
and the predicted cluster labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agreement(predicted, actual, method = "cRand", na_as_cluster = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agreement_+3A_predicted">predicted</code></td>
<td>
<p>a vector with predicted cluster labels.</p>
</td></tr>
<tr><td><code id="agreement_+3A_actual">actual</code></td>
<td>
<p>the known cluster labels (ground truth).</p>
</td></tr>
<tr><td><code id="agreement_+3A_method">method</code></td>
<td>
<p>the used method (see <code><a href="clue.html#topic+cl_agreement">clue::cl_agreement()</a></code>).</p>
</td></tr>
<tr><td><code id="agreement_+3A_na_as_cluster">na_as_cluster</code></td>
<td>
<p>logical; should <code>NA</code> labels (noise points) be considered its own cluster?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This convenience function is an interface to <code><a href="clue.html#topic+cl_agreement">clue::cl_agreement()</a></code>. See <code>methods</code> in that man page
for a list of available methods. A measure typically used for clustering is the corrected Rand index
(also called adjusted Rand index). Numbers close to 1 indicate a very good agreement.
</p>


<h3>References</h3>

<p>Hornik K (2005). A CLUE for CLUster Ensembles. <em>Journal of Statistical Software</em>, <em>14</em>(12).
<a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perfect agreement (1 and 2 are just switched)
actual &lt;- c(2, 2, 1, 3, 2, NA)
predicted &lt;- c(1, 1, 2, 3, 1, NA)
agreement(actual, predicted)

# No agreement
predicted &lt;- sample(predicted)
agreement(actual, predicted)
</code></pre>

<hr>
<h2 id='animate_cluster'>Animates Plots of the Clustering Process</h2><span id='topic+animate_cluster'></span>

<h3>Description</h3>

<p>Generates an animation of a data stream clustering process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate_cluster(
  dsc,
  dsd,
  measure = NULL,
  horizon = 100,
  n = 1000,
  type = c("auto", "micro", "macro"),
  assign = "micro",
  assignmentMethod = c("auto", "model", "nn"),
  excludeNoise = FALSE,
  wait = 0.1,
  plot.args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_cluster_+3A_dsc">dsc</code></td>
<td>
<p>a <a href="#topic+DSC">DSC</a></p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_dsd">dsd</code></td>
<td>
<p>a <a href="#topic+DSD">DSD</a></p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_measure">measure</code></td>
<td>
<p>the evaluation measure that should be graphed below the
animation (see <code><a href="#topic+evaluate_stream">evaluate_stream()</a></code>.)</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_horizon">horizon</code></td>
<td>
<p>the number of points displayed at once/used for evaluation.</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_n">n</code></td>
<td>
<p>the number of points to be plotted</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_type">type</code>, <code id="animate_cluster_+3A_assign">assign</code>, <code id="animate_cluster_+3A_assignmentmethod">assignmentMethod</code>, <code id="animate_cluster_+3A_excludenoise">excludeNoise</code></td>
<td>
<p>are passed on to <code><a href="#topic+evaluate_stream">evaluate_stream()</a></code> to calculate the
evaluation measure.</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_wait">wait</code></td>
<td>
<p>the time interval between each frame</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_plot.args">plot.args</code></td>
<td>
<p>a list with plotting parameters for the clusters.</p>
</td></tr>
<tr><td><code id="animate_cluster_+3A_...">...</code></td>
<td>
<p>extra arguments are added to <code>plot.args</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animations are recorded using the library animation and can be replayed
(which gives a smoother experience since the is no more computation done)
and saved in various formats (see Examples section below).
</p>
<p><strong>Note:</strong> You need to install package <span class="pkg">animation</span> and its system requirements.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="animation.html#topic+ani.record">animation::ani.replay()</a></code> for replaying and saving animations.
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>
<p>Other plot: 
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>
</p>
<p>Other evaluation: 
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+evaluate">evaluate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
stream &lt;- DSD_Benchmark(1)

### animate the clustering process with evaluation
### Note: we choose to exclude noise points from the evaluation
###       measure calculation, even if the algorithm would assign
###       them to a cluster.
dbstream &lt;- DSC_DBSTREAM(r = .04, lambda = .1, gaptime = 100, Cm = 3,
  shared_density = TRUE, alpha = .2)

animate_cluster(dbstream, stream, horizon = 100, n = 5000,
  measure = "crand", type = "macro", assign = "micro",
  plot.args = list(xlim = c(0, 1), ylim = c(0, 1), shared = TRUE))
}
</code></pre>

<hr>
<h2 id='animate_data'>Animates the Plotting of a Data Streams</h2><span id='topic+animate_data'></span><span id='topic+animate'></span><span id='topic+animation'></span>

<h3>Description</h3>

<p>Generates an animation of a data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate_data(dsd, horizon = 100, n = 1000, wait = 0.1, plot.args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_data_+3A_dsd">dsd</code></td>
<td>
<p>a DSD object</p>
</td></tr>
<tr><td><code id="animate_data_+3A_horizon">horizon</code></td>
<td>
<p>the number of points displayed at once/used for evaluation.</p>
</td></tr>
<tr><td><code id="animate_data_+3A_n">n</code></td>
<td>
<p>the number of points to be plotted</p>
</td></tr>
<tr><td><code id="animate_data_+3A_wait">wait</code></td>
<td>
<p>the time interval between each frame</p>
</td></tr>
<tr><td><code id="animate_data_+3A_plot.args">plot.args</code></td>
<td>
<p>a list with plotting parameters for the clusters.</p>
</td></tr>
<tr><td><code id="animate_data_+3A_...">...</code></td>
<td>
<p>extra arguments are added to <code>plot.args</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animations are recorded using the library animation and can be replayed
(which gives a smoother experience since the is no more computation done)
and saved in various formats (see Examples section below).
</p>
<p><strong>Note:</strong> You need to install package <span class="pkg">animation</span> and
its system requirements.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="animation.html#topic+ani.record">animation::ani.replay()</a></code> for replaying and saving animations.
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>
<p>Other plot: 
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {

stream &lt;- DSD_Benchmark(1)
animate_data(stream, horizon = 100, n = 5000, xlim = c(0,1), ylim = c(0,1))

### animations can be replayed with the animation package
library(animation)
animation::ani.options(interval = .1) ## change speed
ani.replay()

### animations can also be saved as HTML, animated gifs, etc.
saveHTML(ani.replay())
}
</code></pre>

<hr>
<h2 id='close_stream'>Close a Data Stream</h2><span id='topic+close_stream'></span>

<h3>Description</h3>

<p>Close a data stream that needs closing (e.g., a file or a connection).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_stream(dsd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_stream_+3A_dsd">dsd</code></td>
<td>
<p>An object of class a subclass of <a href="#topic+DSD">DSD</a> which implements a
reset function.</p>
</td></tr>
<tr><td><code id="close_stream_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>close_stream()</code> is implemented for:
</p>

<ul>
<li> <p><a href="#topic+DSD">DSD</a>
</p>
</li>
<li> <p><a href="#topic+DSD_ReadCSV">DSD_ReadCSV</a>
</p>
</li>
<li> <p><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>
</p>
</li>
<li> <p><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>
</p>
</li>
<li> <p><a href="#topic+DSF">DSF</a>
</p>
</li>
<li> <p><a href="#topic+DST_WriteStream">DST_WriteStream</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>

<hr>
<h2 id='DSAggregate'>Data Stream Aggregator Base Classes</h2><span id='topic+DSAggregate'></span><span id='topic+update.DSAggregate'></span><span id='topic+get_points.DSAggregate'></span><span id='topic+get_weights.DSAggregate'></span>

<h3>Description</h3>

<p>Abstract base classes for all DSAggregate (Data Stream Aggregator) classes to aggregate streams. DSAggreagate is a <a href="#topic+DST">DST</a> task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSAggregate(...)

## S3 method for class 'DSAggregate'
update(object, dsd, n = 1, return = c("nothing", "model"), ...)

## S3 method for class 'DSAggregate'
get_points(x, ...)

## S3 method for class 'DSAggregate'
get_weights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSAggregate_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="DSAggregate_+3A_dsd">dsd</code></td>
<td>
<p>a data stream object.</p>
</td></tr>
<tr><td><code id="DSAggregate_+3A_n">n</code></td>
<td>
<p>the number of data points used for the update.</p>
</td></tr>
<tr><td><code id="DSAggregate_+3A_return">return</code></td>
<td>
<p>a character string indicating what update returns. The default is <code>"nothing"</code>
and <code>"model"</code> returns the aggregated data.</p>
</td></tr>
<tr><td><code id="DSAggregate_+3A_x">x</code>, <code id="DSAggregate_+3A_object">object</code></td>
<td>
<p>a concrete implementation of <code>DSAggregate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSAggreagate</code> class cannot be instantiated, but it serve as a base
class from which other DSAggregate subclasses inherit.
</p>
<p>Data stream operators use <code>update.DSAggregate()</code> to process new data from the
<a href="#topic+DSD">DSD</a> stream. The result of the operator can be obtained via <code><a href="#topic+get_points">get_points()</a></code>
and <code><a href="#topic+get_weights">get_weights()</a></code> (if available).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSAggregate: 
<code><a href="#topic+DSAggregate_Sample">DSAggregate_Sample</a>()</code>,
<code><a href="#topic+DSAggregate_Window">DSAggregate_Window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSAggregate()
</code></pre>

<hr>
<h2 id='DSAggregate_Sample'>Sampling from a Data Stream (Data Stream Operator)</h2><span id='topic+DSAggregate_Sample'></span>

<h3>Description</h3>

<p>Extracts a sample form a data stream using Reservoir Sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSAggregate_Sample(k = 100, biased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSAggregate_Sample_+3A_k">k</code></td>
<td>
<p>the number of points to be sampled from the stream.</p>
</td></tr>
<tr><td><code id="DSAggregate_Sample_+3A_biased">biased</code></td>
<td>
<p>if <code>FALSE</code> then a regular (unbiased) reservoir sampling
is used. If true then the sample is biased towards keeping more recent data
points (see Details section).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>biased = FALSE</code> then the reservoir sampling algorithm by McLeod and
Bellhouse (1983) is used. This sampling makes sure that each data point has
the same chance to be sampled. All sampled points will have a weight of 1.
Note that this might not be ideal for an evolving stream since very old data
points have the same chance to be in the sample as newer points.
</p>
<p>If <code>bias = TRUE</code> then sampling prefers newer points using the modified
reservoir sampling algorithm 2.1 by Aggarwal (2006). New points are always
added. They replace a random point in thre reservoir with a probability of
reservoir size over <code>k</code>. This an exponential bias function of
<code class="reqn">2^{-lambda}</code> with <code class="reqn">lambda = 1 / k</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>DSAggregate_Sample</code> (subclass of <code>DSAggregate</code>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Vitter, J. S. (1985): Random sampling with a reservoir. ACM
Transactions on Mathematical Software, 11(1), 37-57.
</p>
<p>McLeod, A.I., Bellhouse, D.R. (1983): A Convenient Algorithm for Drawing a
Simple Random Sample. Applied Statistics, 32(2), 182-184.
</p>
<p>Aggarwal C. (2006) On Biased Reservoir Sampling in the Presence of Stream
Evolution. International Conference on Very Large Databases (VLDB'06).
607-618.
</p>


<h3>See Also</h3>

<p>Other DSAggregate: 
<code><a href="#topic+DSAggregate_Window">DSAggregate_Window</a>()</code>,
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)

stream &lt;- DSD_Gaussians(k = 3, noise = 0.05)

sample &lt;- DSAggregate_Sample(k = 50)
update(sample, stream, 500)
sample

head(get_points(sample))

# apply k-means clustering to the sample (data without info columns)
km &lt;- kmeans(get_points(sample, info = FALSE), centers = 3)
plot(get_points(sample, info = FALSE))
points(km$centers, col = "red", pch = 3, cex = 2)
</code></pre>

<hr>
<h2 id='DSAggregate_Window'>Sliding Window (Data Stream Operator)</h2><span id='topic+DSAggregate_Window'></span>

<h3>Description</h3>

<p>Implements a sliding window data stream operator which keeps a fixed amount
(window length) of the most recent data points of the stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSAggregate_Window(horizon = 100, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSAggregate_Window_+3A_horizon">horizon</code></td>
<td>
<p>the window length.</p>
</td></tr>
<tr><td><code id="DSAggregate_Window_+3A_lambda">lambda</code></td>
<td>
<p>decay factor damped window model. <code>lambda = 0</code> means no
dampening.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lambda</code> is greater than 0 then the weight uses a damped window
model (Zhu and Shasha, 2002).  The weight for points in the window follows
<code class="reqn">2^(-lambda*t)</code> where <code class="reqn">t</code> is the age of the point.
</p>


<h3>Value</h3>

<p>An object of class <code>DSAggregate_Window</code> (subclass of <a href="#topic+DSAggregate">DSAggregate</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Zhu, Y. and Shasha, D. (2002). StatStream: Statistical
Monitoring of Thousands of Data Streams in Real Time, Intl. Conference of
Very Large Data Bases (VLDB'02).
</p>


<h3>See Also</h3>

<p>Other DSAggregate: 
<code><a href="#topic+DSAggregate_Sample">DSAggregate_Sample</a>()</code>,
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)

## Example 1: Basic use
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

window &lt;- DSAggregate_Window(horizon = 10)
window

# update with only two points. The window is mostly empty (NA)
update(window, stream, 2)
get_points(window)

# get weights and window as a single data.frame
get_model(window)

# update window
update(window, stream, 100)
get_points(window)

## Example 2: Implement a classifier over a sliding window
window &lt;- DSAggregate_Window(horizon = 100)

update(window, stream, 1000)

# train the classifier on the window
library(rpart)
tree &lt;- rpart(`.class` ~ ., data = get_points(window))
tree

# predict the class for new points from the stream
new_points &lt;- get_points(stream, n = 100, info = FALSE)
pred &lt;- predict(tree, new_points)
plot(new_points, col = pred)
</code></pre>

<hr>
<h2 id='DSC'>Data Stream Clustering Base Class</h2><span id='topic+DSC'></span><span id='topic+get_centers'></span><span id='topic+get_weights'></span><span id='topic+get_copy'></span><span id='topic+nclusters'></span><span id='topic+get_microclusters'></span><span id='topic+get_microweights'></span><span id='topic+get_macroclusters'></span><span id='topic+get_macroweights'></span>

<h3>Description</h3>

<p>Abstract base classes for Data Stream Clustering (DSC).
Concrete implementations are functions starting with <code>DSC_</code> (RStudio use auto-completion with Tab to select one).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC(...)

get_centers(x, type = c("auto", "micro", "macro"), ...)

get_weights(x, type = c("auto", "micro", "macro"), scale = NULL, ...)

get_copy(x)

nclusters(x, type = c("auto", "micro", "macro"), ...)

get_microclusters(x, ...)

get_microweights(x, ...)

get_macroclusters(x, ...)

get_macroweights(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_+3A_...">...</code></td>
<td>
<p>further parameter</p>
</td></tr>
<tr><td><code id="DSC_+3A_x">x</code></td>
<td>
<p>a DSC object.</p>
</td></tr>
<tr><td><code id="DSC_+3A_type">type</code></td>
<td>
<p>Return weights of micro- or macro-clusters in x.  Auto uses the
class of x to decide.</p>
</td></tr>
<tr><td><code id="DSC_+3A_scale">scale</code></td>
<td>
<p>a range (from, to) to scale the weights.  Returns by default
the raw weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSC</code> class cannot be instantiated (calling
<code>DSC()</code> produces only a message listing the available implementations),
but they serve as a base
class from which other DSC classes inherit.
</p>
<p>Data stream clustering has typically an
</p>

<ul>
<li> <p><strong>online clustering component</strong> (see <a href="#topic+DSC_Micro">DSC_Micro</a>), and an
</p>
</li>
<li> <p><strong>offline reclustering component</strong> (see <a href="#topic+DSC_Macro">DSC_Macro</a>).
</p>
</li></ul>

<p>Class <code>DSC</code> provides several generic functions that can operate on all
DSC subclasses. See Usage and Functions sections for methods.
Additional, separately documented methods are:
</p>

<ul>
<li> <p><code><a href="#topic+update">update()</a></code> adds new data points from a stream to a clustering.
</p>
</li>
<li> <p><code><a href="#topic+predict">predict()</a></code> predicts the cluster assignment for new data points.
</p>
</li>
<li> <p><code>plot()</code> plots cluster centers (see <code><a href="#topic+plot.DSC">plot.DSC()</a></code>).
</p>
</li></ul>

<p><code>get_centers()</code> and <code>get_weights()</code> are typically overwritten by
subclasses of <code>DSC</code>.
</p>
<p>Since <code>DSC</code> objects often contain external pointers, regular saving and
reading operations will fail. Use <code><a href="#topic+saveDSC">saveDSC()</a></code> and <code><a href="#topic+readDSC">readDSC()</a></code>
which will serialize the objects first appropriately.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_centers()</code>: Gets the cluster centers (micro- or macro-clusters) from a DSC object.
</p>
</li>
<li> <p><code>get_weights()</code>: Get the weights of the clusters in the DSC (returns 1s if not implemented by the clusterer)
</p>
</li>
<li> <p><code>get_copy()</code>: Create a Deep Copy of a DSC Object that contain reference classes (e.g., Java data structures for MOA).
</p>
</li>
<li> <p><code>nclusters()</code>: Returns the number of micro-clusters from the DSC object.
</p>
</li>
<li> <p><code>get_microclusters()</code>: Used as internal interface.
</p>
</li>
<li> <p><code>get_microweights()</code>: Used as internal interface.
</p>
</li>
<li> <p><code>get_macroclusters()</code>: Used as internal interface.
</p>
</li>
<li> <p><code>get_macroweights()</code>: Used as internal interface.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSC()

set.seed(1000)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)
dstream &lt;- DSC_DStream(gridsize = .1, gaptime = 100)
update(dstream, stream, 500)
dstream

# get micro-cluster centers
get_centers(dstream)

# get the micro-cluster weights
get_weights(dstream)

# get the number of clusters
nclusters(dstream)

# get the whole model as a data.frame
get_model(dstream)

# D-Stream also has macro-clusters
get_weights(dstream, type = "macro")
get_centers(dstream, type = "macro")

# plot the clustering result
plot(dstream, stream)
plot(dstream, stream, type = "both")

# predict macro clusters for new points (see predict())
points &lt;- get_points(stream, n = 5)
points

predict(dstream, points, type = "macro")
</code></pre>

<hr>
<h2 id='DSC_BICO'>BICO - Fast computation of k-means coresets in a data stream</h2><span id='topic+DSC_BICO'></span><span id='topic+BICO'></span><span id='topic+bico'></span>

<h3>Description</h3>

<p>Micro Clusterer.
BICO maintains a tree which is inspired by the clustering tree of BIRCH.
Each node in the
tree represents a subset of these points. Instead of storing all points as
individual objects, only the number of points, the sum and the squared sum
of the subset's points are stored as key features of each subset. Points are
inserted into exactly one node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_BICO(formula = NULL, k = 5, space = 10, p = 10, iterations = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_BICO_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_BICO_+3A_k">k</code></td>
<td>
<p>number of centers</p>
</td></tr>
<tr><td><code id="DSC_BICO_+3A_space">space</code></td>
<td>
<p>coreset size</p>
</td></tr>
<tr><td><code id="DSC_BICO_+3A_p">p</code></td>
<td>
<p>number of random projections used for nearest neighbor search in
first level</p>
</td></tr>
<tr><td><code id="DSC_BICO_+3A_iterations">iterations</code></td>
<td>
<p>number of repetitions for the kmeans++ procedure in the
offline component</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this implementation, the nearest neighbor search on the first level of
the tree is sped up by projecting all points to random 1-d subspaces. The
first estimation of the optimal clustering cost is computed in a buffer
phase at the beginning of the algorithm. This implementation interfaces the
original C++ implementation available here:
<a href="http://ls2-www.cs.tu-dortmund.de/grav/de/bico">http://ls2-www.cs.tu-dortmund.de/grav/de/bico</a>. For micro-clustering,
the algorithm computes the coreset of the stream. Reclustering is performed
by using the <code>kmeans++</code> algorithm on the coreset.
</p>


<h3>Author(s)</h3>

<p>R-Interface: Matthias Carnein
(<a href="mailto:Matthias.Carnein@uni-muenster.de">Matthias.Carnein@uni-muenster.de</a>), Dennis Assenmacher.
C-Implementation: Hendrik Fichtenberger, Marc Gille, Melanie Schmidt, Chris
Schwiegelshohn, Christian Sohler.
</p>


<h3>References</h3>

<p>Hendrik Fichtenberger, Marc Gille, Melanie Schmidt, Chris
Schwiegelshohn, Christian Sohler: BICO: BIRCH Meets Coresets for k-Means
Clustering. <em>ESA 2013:</em> 481-492.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2)

BICO &lt;- DSC_BICO(k = 3, p = 10, space = 100, iterations = 10)
update(BICO, stream, n = 500)

plot(BICO,stream)
</code></pre>

<hr>
<h2 id='DSC_BIRCH'>Balanced Iterative Reducing Clustering using Hierarchies</h2><span id='topic+DSC_BIRCH'></span><span id='topic+BIRCH'></span><span id='topic+birch'></span>

<h3>Description</h3>

<p>Micro Clusterer.
BIRCH builds a balanced tree of Clustering Features (CFs) to summarize the
stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_BIRCH(
  formula = NULL,
  threshold,
  branching,
  maxLeaf,
  maxMem = 0,
  outlierThreshold = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_BIRCH_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_BIRCH_+3A_threshold">threshold</code></td>
<td>
<p>threshold used to check whether a new data point can be
absorbed or not.</p>
</td></tr>
<tr><td><code id="DSC_BIRCH_+3A_branching">branching</code></td>
<td>
<p>branching factor (maximum amount of child nodes for a
non-leaf node) of the CF-Tree.</p>
</td></tr>
<tr><td><code id="DSC_BIRCH_+3A_maxleaf">maxLeaf</code></td>
<td>
<p>maximum number of entries within a leaf node</p>
</td></tr>
<tr><td><code id="DSC_BIRCH_+3A_maxmem">maxMem</code></td>
<td>
<p>memory limitation for the whole CFTree in bytes. Default is 0,
indicating no memory restriction.</p>
</td></tr>
<tr><td><code id="DSC_BIRCH_+3A_outlierthreshold">outlierThreshold</code></td>
<td>
<p>threshold for identifying outliers when rebuilding
the CF-Tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A CF in the calanced tree is a tuple (n, LS, SS) which represents a cluster
by storing the number of elements (n), their linear sum (LS) and their
squared sum (SS). Each new observation descends the tree by following its
closest CF until a leaf node is reached. It is either merged into its
closest leaf-CF or inserted as a new one. All leaf-CFs form the
micro-clusters. Rebuilding the tree is realized by inserting all leaf-CF
nodes into a new tree structure with an increased threshold.
</p>


<h3>Author(s)</h3>

<p>Dennis Assenmacher (<a href="mailto:Dennis.Assenmacher@uni-muenster.de">Dennis.Assenmacher@uni-muenster.de</a>),
Matthias Carnein (<a href="mailto:Matthias.Carnein@uni-muenster.de">Matthias.Carnein@uni-muenster.de</a>)
</p>


<h3>References</h3>

<p>Zhang T, Ramakrishnan R and Livny M (1996), &quot;BIRCH: An Efficient
Data Clustering Method for Very Large Databases&quot;, <em>In Proceedings of
the 1996 ACM SIGMOD International Conference on Management of Data.</em>
Montreal, Quebec, Canada , pp. 103-114. ACM.
</p>
<p>Zhang T, Ramakrishnan R and Livny M (1997), &quot;BIRCH: A new data clustering
algorithm and its applications&quot;, <em>Data Mining and Knowledge Discovery.</em>
Vol. 1(2), pp. 141-182.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2)

BIRCH &lt;- DSC_BIRCH(threshold = .1, branching = 8, maxLeaf = 20)
update(BIRCH, stream, n = 500)
BIRCH

plot(BIRCH, stream)
</code></pre>

<hr>
<h2 id='DSC_DBSCAN'>DBSCAN Macro-clusterer</h2><span id='topic+DSC_DBSCAN'></span><span id='topic+DBSCAN'></span><span id='topic+dbscan'></span>

<h3>Description</h3>

<p>Macro Clusterer.
Implements the DBSCAN algorithm for reclustering micro-clusterings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_DBSCAN(
  formula = NULL,
  eps,
  MinPts = 5,
  weighted = TRUE,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_DBSCAN_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_DBSCAN_+3A_eps">eps</code></td>
<td>
<p>radius of the eps-neighborhood.</p>
</td></tr>
<tr><td><code id="DSC_DBSCAN_+3A_minpts">MinPts</code></td>
<td>
<p>minimum number of points required in the eps-neighborhood.</p>
</td></tr>
<tr><td><code id="DSC_DBSCAN_+3A_weighted">weighted</code></td>
<td>
<p>logical indicating if a weighted version of DBSCAN should be
used.</p>
</td></tr>
<tr><td><code id="DSC_DBSCAN_+3A_description">description</code></td>
<td>
<p>optional character string to describe the clustering
method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DBSCAN is a weighted extended version of the implementation in <span class="pkg">fpc</span>
where each micro-cluster center considered a pseudo point. For weighting we
use in the MinPts comparison the sum of weights of the micro-cluster instead
of the number.
</p>
<p>DBSCAN first finds core points based on the number of other points in its
eps-neighborhood. Then core points are joined into clusters using
reachability (overlapping eps-neighborhoods).
</p>
<p><code><a href="#topic+update">update()</a></code> and <code><a href="#topic+recluster">recluster()</a></code> invisibly return the assignment of the data points to clusters.
</p>
<p><strong>Note</strong> that this clustering cannot be updated iteratively and every time it is
used for (re)clustering, the old clustering is deleted.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_DBSCAN</code> (a subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Macro">DSC_Macro</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Martin Ester, Hans-Peter Kriegel, Joerg Sander, Xiaowei Xu
(1996). A density-based algorithm for discovering clusters in large spatial
databases with noise. In Evangelos Simoudis, Jiawei Han, Usama M. Fayyad.
<em>Proceedings of the Second International Conference on Knowledge
Discovery and Data Mining (KDD-96).</em> AAAI Press. pp. 226-231.
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3 clusters with 5% noise
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# Use a moving window for "micro-clusters and recluster with DBSCAN (macro-clusters)
cl &lt;- DSC_TwoStage(
  micro = DSC_Window(horizon = 100),
  macro = DSC_DBSCAN(eps = .05)
)

update(cl, stream, 500)
cl

plot(cl, stream)
</code></pre>

<hr>
<h2 id='DSC_DBSTREAM'>DBSTREAM Clustering Algorithm</h2><span id='topic+DSC_DBSTREAM'></span><span id='topic+DBSTREAM'></span><span id='topic+dbstream'></span><span id='topic+get_shared_density'></span><span id='topic+change_alpha'></span><span id='topic+plot.DSC_DBSTREAM'></span><span id='topic+DSOutlier_DBSTREAM'></span>

<h3>Description</h3>

<p>Micro Clusterer with reclustering.
Implements a simple density-based stream clustering algorithm that assigns
data points to micro-clusters with a given radius and implements
shared-density-based reclustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_DBSTREAM(
  formula = NULL,
  r,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  metric = "Euclidean",
  noise_multiplier = 1,
  shared_density = FALSE,
  alpha = 0.1,
  k = 0,
  minweight = 0
)

get_shared_density(x, use_alpha = TRUE)

change_alpha(x, alpha)

## S3 method for class 'DSC_DBSTREAM'
plot(
  x,
  dsd = NULL,
  n = 500,
  col_points = NULL,
  dim = NULL,
  method = "pairs",
  type = c("auto", "micro", "macro", "both", "none"),
  shared_density = FALSE,
  use_alpha = TRUE,
  assignment = FALSE,
  ...
)

DSOutlier_DBSTREAM(
  formula = NULL,
  r,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  metric = "Euclidean",
  outlier_multiplier = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_DBSTREAM_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_r">r</code></td>
<td>
<p>The radius of micro-clusters.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_lambda">lambda</code></td>
<td>
<p>The lambda used in the fading function.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_gaptime">gaptime</code></td>
<td>
<p>weak micro-clusters (and weak shared density entries) are
removed every <code>gaptime</code> points.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_cm">Cm</code></td>
<td>
<p>minimum weight for a micro-cluster.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_metric">metric</code></td>
<td>
<p>metric used to calculate distances.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_noise_multiplier">noise_multiplier</code>, <code id="DSC_DBSTREAM_+3A_outlier_multiplier">outlier_multiplier</code></td>
<td>
<p>multiplier for radius <code>r</code> to declare noise or outliers.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_shared_density">shared_density</code></td>
<td>
<p>Record shared density information. If set to
<code>TRUE</code> then shared density is used for reclustering, otherwise
reachability is used (overlapping clusters with less than <code class="reqn">r * (1 - alpha)</code>
distance are clustered together).</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_alpha">alpha</code></td>
<td>
<p>For shared density: The minimum proportion of shared points
between to clusters to warrant combining them (a suitable value for 2D data
is .3).  For reachability clustering it is a distance factor.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_k">k</code></td>
<td>
<p>The number of macro clusters to be returned if macro is true.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_minweight">minweight</code></td>
<td>
<p>The proportion of the total weight a macro-cluster needs to
have not to be noise (between 0 and 1).</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_x">x</code></td>
<td>
<p>A DSC_DBSTREAM object to get the shared density information from.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_use_alpha">use_alpha</code></td>
<td>
<p>only return shared density if it exceeds alpha.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_dsd">dsd</code></td>
<td>
<p>a data stream object.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_n">n</code></td>
<td>
<p>number of plots taken from the dsd to plot.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_col_points">col_points</code></td>
<td>
<p>color used for plotting.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_dim">dim</code></td>
<td>
<p>an integer vector with the dimensions to plot. If NULL then for methods &quot;pairs&quot; and &quot;pc&quot; all dimensions are used and for &quot;scatter&quot; the first two dimensions are plotted.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_method">method</code></td>
<td>
<p>plot method.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_type">type</code></td>
<td>
<p>Plot micro clusters (<code>type="micro"</code>), macro clusters (<code>type="macro"</code>), both micro and macro clusters (<code>type="both"</code>), outliers(<code>type="outliers"</code>), or everything together (<code>type="all"</code>). <code>type="auto"</code> leaves to the class of DSC to decide.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_assignment">assignment</code></td>
<td>
<p>logical; show assignment area of micro-clusters.</p>
</td></tr>
<tr><td><code id="DSC_DBSTREAM_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to plot or pairs in graphics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DBSTREAM algorithm checks for each new data point in the incoming
stream, if it is below the threshold value of dissimilarity value of any
existing micro-clusters, and if so, merges the point with the micro-cluster.
Otherwise, a new micro-cluster is created to accommodate the new data point.
</p>
<p>Although DSC_DBSTREAM is a micro clustering algorithm, macro clusters and
weights are available.
</p>
<p><code><a href="#topic+update">update()</a></code>  invisibly return the assignment of the data points to clusters.
The columns are <code>.class</code> with the index of the strong micro-cluster and <code>.mc_id</code>
with the permanent id of the strong micro-cluster.
</p>
<p><code>plot()</code> for DSC_DBSTREAM has two extra logical parameters called
<code>assignment</code> and <code>shared_density</code> which show the assignment area
and the shared density graph, respectively.
</p>
<p><code><a href="#topic+predict">predict()</a></code> can be used to assign new points to clusters. Points are assigned to a micro-cluster if
they are within its assignment area (distance is less then <code>r</code> times <code>noise_multiplier</code>).
</p>
<p><code>DSOutlier_DBSTREAM</code> classifies points as outlier/noise if they that cannot be assigned to a micro-cluster
representing a dense region as a outlier/noise. Parameter <code>outlier_multiplier</code> specifies
how far a point has to be away from a micro-cluster as a multiplyer for the radius <code>r</code>.
A larger value means that outliers have to be farther away from dense
regions and thus reduce the chance of misclassifying a regular point as an outlier.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_DBSTREAM</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Micro">DSC_Micro</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Matthew Bolanos
</p>


<h3>References</h3>

<p>Michael Hahsler and Matthew Bolanos. Clustering data streams
based on shared density between micro-clusters. <em>IEEE Transactions on
Knowledge and Data Engineering,</em> 28(6):1449&ndash;1461, June 2016
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSC_TwoStage: 
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSOutlier: 
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1000)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# create clusterer with r = .05
dbstream &lt;- DSC_DBSTREAM(r = .05)
update(dbstream, stream, 500)
dbstream

# check micro-clusters
nclusters(dbstream)
head(get_centers(dbstream))
plot(dbstream, stream)

# plot micro-clusters with assignment area
plot(dbstream, stream, type = "none", assignment = TRUE)


# DBSTREAM with shared density
dbstream &lt;- DSC_DBSTREAM(r = .05, shared_density = TRUE, Cm = 5)
update(dbstream, stream, 500)
dbstream

plot(dbstream, stream)
# plot the shared density graph (several options)
plot(dbstream, stream, type = "micro", shared_density = TRUE)
plot(dbstream, stream, type = "none", shared_density = TRUE, assignment = TRUE)

# see how micro and macro-clusters relate
# each micro-cluster has an entry with the macro-cluster id
# Note: unassigned micro-clusters (noise) have an NA
microToMacro(dbstream)

# do some evaluation
evaluate_static(dbstream, stream, measure = "purity")
evaluate_static(dbstream, stream, measure = "cRand", type = "macro")

# use DBSTREAM also returns the cluster assignment
# later retrieve the cluster assignments for each point)
data("iris")
dbstream &lt;- DSC_DBSTREAM(r = 1)
cl &lt;- update(dbstream, iris[,-5], return = "assignment")
dbstream

head(cl)

# micro-clusters
plot(iris[,-5], col = cl$.class, pch = cl$.class)

# macro-clusters (2 clusters since reachability cannot separate two of the three species)
plot(iris[,-5], col = microToMacro(dbstream, cl$.class))

# use DBSTREAM with a formula (cluster all variables but X2)
stream &lt;- DSD_Gaussians(k = 3, d = 4, noise = 0.05)
dbstream &lt;- DSC_DBSTREAM(formula = ~ . - X2, r = .2)

update(dbstream, stream, 500)
get_centers(dbstream)
</code></pre>

<hr>
<h2 id='DSC_DStream'>D-Stream Data Stream Clustering Algorithm</h2><span id='topic+DSC_DStream'></span><span id='topic+dstream'></span><span id='topic+d-stream'></span><span id='topic+D-Stream'></span><span id='topic+get_attraction'></span><span id='topic+plot.DSC_DStream'></span><span id='topic+DSOutlier_DStream'></span>

<h3>Description</h3>

<p>Micro Clusterer with reclustering.
Implements the grid-based D-Stream data stream clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_DStream(
  formula = NULL,
  gridsize,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  Cl = 0.8,
  attraction = FALSE,
  epsilon = 0.3,
  Cm2 = Cm,
  k = NULL,
  N = 0
)

get_attraction(x, relative = FALSE, grid_type = "dense", dist = FALSE)

## S3 method for class 'DSC_DStream'
plot(
  x,
  dsd = NULL,
  n = 500,
  type = c("auto", "micro", "macro", "both"),
  grid = FALSE,
  grid_type = "used",
  assignment = FALSE,
  ...
)

DSOutlier_DStream(
  formula = NULL,
  gridsize,
  lambda = 0.001,
  gaptime = 1000L,
  Cm = 3,
  Cl = 0.8,
  outlier_multiplier = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_DStream_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_gridsize">gridsize</code></td>
<td>
<p>Size of grid cells.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_lambda">lambda</code></td>
<td>
<p>Fading constant used function to calculate the decay factor
<code class="reqn">2^-lambda</code>.  (Note: in the paper the authors use lamba to denote the
decay factor and not the fading constant!)</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_gaptime">gaptime</code></td>
<td>
<p>sporadic grids are removed every gaptime number of points.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_cm">Cm</code></td>
<td>
<p>density threshold used to detect dense grids as a proportion of
the average expected density (Cm &gt; 1). The average density is given by the
total weight of the clustering over <code class="reqn">N</code>, the number of grid cells.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_cl">Cl</code></td>
<td>
<p>density threshold to detect sporadic grids (0 &gt; Cl &gt; Cm).
Transitional grids have a density between Cl and Cm.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_attraction">attraction</code></td>
<td>
<p>compute and store information about the attraction between
adjacent grids. If <code>TRUE</code> then attraction is used to create
macro-clusters, otherwise macro-clusters are created by merging adjacent
dense grids.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_epsilon">epsilon</code></td>
<td>
<p>overlap parameter for attraction as a proportion of
<code>gridsize</code>.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_cm2">Cm2</code></td>
<td>
<p>threshold on attraction to join two dense grid cells (as a
proportion on the average expected attraction).  In the original algorithm
<code>Cm2</code> is equal to <code>Cm</code>.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_k">k</code></td>
<td>
<p>alternative to Cm2 (not in the original algorithm).  Create k
clusters based on attraction. In case of more than k unconnected components,
closer groups of MCs are joined.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_n">N</code></td>
<td>
<p>Fix the number of grid cells used for the calculation of the
density thresholds with Cl and Cm. If <code>N</code> is not given (0) then the
algorithm tries to determine N from the data. Note that this means that N
potentially increases over time and outliers might produce an extremely
large value which will lead to a sudden creation of too many dense
micro-clusters. The original paper assumed that N is known a priori.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_x">x</code></td>
<td>
<p>DSC_DStream object to get attraction values from.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_relative">relative</code></td>
<td>
<p>calculates relative attraction (normalized by the cluster
weight).</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_grid_type">grid_type</code></td>
<td>
<p>the attraction between what grid types should be returned?</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_dist">dist</code></td>
<td>
<p>make attraction symmetric and transform into a distance.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_dsd">dsd</code></td>
<td>
<p>a <a href="#topic+DSD">DSD</a> data stream object.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_n">n</code></td>
<td>
<p>number of plots taken from <code>dsd</code> to plot.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_type">type</code></td>
<td>
<p>Plot micro clusters (<code>type = "micro"</code>), macro clusters (<code>type = "macro"</code>),
both micro and macro clusters (<code>type = "both"</code>), outliers(<code>type = "outliers"</code>),
or everything together (<code>type = "all"</code>). <code>type = "auto"</code> leaves to the class of DSC to decide.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_grid">grid</code></td>
<td>
<p>logical; show the D-Stream grid instead of circles for micro-clusters.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_assignment">assignment</code></td>
<td>
<p>logical; show assignment area of micro-clusters.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_...">...</code></td>
<td>
<p>further argument are passed on.</p>
</td></tr>
<tr><td><code id="DSC_DStream_+3A_outlier_multiplier">outlier_multiplier</code></td>
<td>
<p>multiplier for assignment grid width to declare outliers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D-Stream creates an equally spaced grid and estimates the density in each
grid cell using the count of points falling in the cells. Grid cells are
classified based on density into dense, transitional and sporadic cells.
The density is faded after every new point by a factor of <code class="reqn">2^{-lambda}</code>.
Every gaptime number of points sporadic grid cells are removed.
</p>
<p>For reclustering D-Stream (2007 version) merges adjacent dense grids to form
macro-clusters and then assigns adjacent transitional grids to
macro-clusters. This behavior is implemented as <code>attraction = FALSE</code>.
</p>
<p>The 2009 version of the algorithm adds the concept of attraction between
grids cells. If <code>attraction = TRUE</code> is used then the algorithm produces
macro-clusters based on attraction between dense adjacent grids (uses
<code>Cm2</code> which in the original algorithm is equal to <code>Cm</code>).
</p>
<p>For many functions (e.g., <code><a href="#topic+get_centers">get_centers()</a></code>, <code><a href="#topic+plot">plot()</a></code>), D-Stream
adds a parameter <code>grid_type</code> with possible values of <code>"dense"</code>,
<code>"transitional"</code>, <code>"sparse"</code>, <code>"all"</code> and <code>"used"</code>. This
only returns the selected type of grid cells. <code>"used"</code> includes dense
and adjacent transitional cells which are used in D-Stream for reclustering.
For <code>plot()</code> D-Stream also provides extra parameters <code>"grid"</code> and
<code>"grid_type"</code> to show micro-clusters as grid cells (density represented
by gray values).
</p>
<p><code>DSOutlier_DStream</code> classifies points that do not fall into a dense grid cell as
outlier/noise. Parameter <code>outlier_multiplier</code> specifies
how far the point needs to be away from a dense cell to be classified as an outlier by multiplying the grid
size.
</p>
<p>Note that <code>DSC_DStream</code> currently cannot be saved to disk using
save() or saveRDS(). This functionality will be added later!
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_DStream</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Micro">DSC_Micro</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Yixin Chen and Li Tu. 2007. Density-based clustering for
real-time stream data. In <em>Proceedings of the 13th ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining (KDD '07).</em>
ACM, New York, NY, USA, 133-142.
</p>
<p>Li Tu and Yixin Chen. 2009. Stream data clustering based on grid density and
attraction. <em>ACM Transactions on Knowledge Discovery from Data,</em> 3(3),
Article 12 (July 2009), 27 pages.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSC_TwoStage: 
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSOutlier: 
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_BarsAndGaussians(noise = .05)
plot(stream)

dstream1 &lt;- DSC_DStream(gridsize = 1, Cm = 1.5)
update(dstream1, stream, 1000)
dstream1

# micro-clusters (these are "used" grid cells)
nclusters(dstream1)
head(get_centers(dstream1))

# plot (DStream provides additional grid visualization)
plot(dstream1, stream)
plot(dstream1, stream, grid = TRUE)

# look only at dense grids
nclusters(dstream1, grid_type = "dense")
plot(dstream1, stream, grid = TRUE, grid_type = "dense")

# look at transitional and sparse cells
plot(dstream1, stream, grid = TRUE, grid_type = "transitional")
plot(dstream1, stream, grid = TRUE, grid_type = "sparse")

### Macro-clusters
# standard D-Stream uses reachability
nclusters(dstream1, type = "macro")
get_centers(dstream1, type = "macro")
plot(dstream1, stream, type = "macro")
evaluate_static(dstream1, stream, measure = "crand", type = "macro")

# use attraction for reclustering
dstream2 &lt;- DSC_DStream(gridsize = 1, attraction = TRUE, Cm = 1.5)
update(dstream2, stream, 1000)
dstream2

plot(dstream2, stream, grid = TRUE)
evaluate_static(dstream2, stream, measure = "crand", type = "macro")
</code></pre>

<hr>
<h2 id='DSC_EA'>Reclustering using an Evolutionary Algorithm</h2><span id='topic+DSC_EA'></span>

<h3>Description</h3>

<p>Macro Clusterer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_EA(
  formula = NULL,
  k,
  generations = 2000,
  crossoverRate = 0.8,
  mutationRate = 0.001,
  populationSize = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_EA_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_EA_+3A_k">k</code></td>
<td>
<p>number of macro-clusters</p>
</td></tr>
<tr><td><code id="DSC_EA_+3A_generations">generations</code></td>
<td>
<p>number of EA generations performed during reclustering</p>
</td></tr>
<tr><td><code id="DSC_EA_+3A_crossoverrate">crossoverRate</code></td>
<td>
<p>cross-over rate for the evolutionary algorithm</p>
</td></tr>
<tr><td><code id="DSC_EA_+3A_mutationrate">mutationRate</code></td>
<td>
<p>mutation rate for the evolutionary algorithm</p>
</td></tr>
<tr><td><code id="DSC_EA_+3A_populationsize">populationSize</code></td>
<td>
<p>number of solutions that the evolutionary algorithm
maintains</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reclustering using an evolutionary algorithm. This approach was designed for
<code>evoStream</code> (see <a href="#topic+DSC_evoStream">DSC_evoStream</a>) but can also be used for other micro-clustering algorithms.
</p>
<p>The evolutionary algorithm uses existing clustering solutions and creates
small variations of them by combining and randomly modifying them. The
modified solutions can yield better partitions and thus can improve the
clustering over time. The evolutionary algorithm is incremental, which
allows to improve existing macro-clusters instead of recomputing them every
time.
</p>


<h3>Author(s)</h3>

<p>Matthias Carnein <a href="mailto:Matthias.Carnein@uni-muenster.de">Matthias.Carnein@uni-muenster.de</a>
</p>


<h3>References</h3>

<p>Carnein M. and Trautmann H. (2018), &quot;evoStream - Evolutionary
Stream Clustering Utilizing Idle Times&quot;, Big Data Research.
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2) %&gt;% DSD_Memory(n = 1000)

## online algorithm
dbstream &lt;- DSC_DBSTREAM(r = 0.1)

## offline algorithm (note: we use a small number of generations
##                          to make this run faster.)
EA &lt;- DSC_EA(k = 3, generations = 100)

## create pipeline and insert observations
two &lt;- DSC_TwoStage(dbstream, EA)
update(two, stream, n = 1000)
two

## plot result
reset_stream(stream)
plot(two, stream)

## if we have time, evaluate additional generations. This can be
## called at any time, also between observations.
two$macro$RObj$recluster(100)

## plot improved result
reset_stream(stream)
plot(two, stream)


## alternatively: do not create twostage but apply directly
reset_stream(stream)
update(dbstream, stream, n = 1000)
recluster(EA, dbstream)
reset_stream(stream)
plot(EA, stream)
</code></pre>

<hr>
<h2 id='DSC_evoStream'>evoStream - Evolutionary Stream Clustering</h2><span id='topic+DSC_evoStream'></span>

<h3>Description</h3>

<p>Micro Clusterer with reclustering.
Stream clustering algorithm based on evolutionary optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_evoStream(
  formula = NULL,
  r,
  lambda = 0.001,
  tgap = 100,
  k = 2,
  crossoverRate = 0.8,
  mutationRate = 0.001,
  populationSize = 100,
  initializeAfter = 2 * k,
  incrementalGenerations = 1,
  reclusterGenerations = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_evoStream_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_r">r</code></td>
<td>
<p>radius threshold for micro-cluster assignment</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_lambda">lambda</code></td>
<td>
<p>decay rate</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_tgap">tgap</code></td>
<td>
<p>time-interval between outlier detection and clean-up</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_k">k</code></td>
<td>
<p>number of macro-clusters</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_crossoverrate">crossoverRate</code></td>
<td>
<p>cross-over rate for the evolutionary algorithm</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_mutationrate">mutationRate</code></td>
<td>
<p>mutation rate for the evolutionary algorithm</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_populationsize">populationSize</code></td>
<td>
<p>number of solutions that the evolutionary algorithm
maintains</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_initializeafter">initializeAfter</code></td>
<td>
<p>number of micro-cluster required for the
initialization of the evolutionary algorithm.</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_incrementalgenerations">incrementalGenerations</code></td>
<td>
<p>number of EA generations performed after each
observation</p>
</td></tr>
<tr><td><code id="DSC_evoStream_+3A_reclustergenerations">reclusterGenerations</code></td>
<td>
<p>number of EA generations performed during
reclustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The online component uses a simplified version of <a href="#topic+DBSTREAM">DBSTREAM</a> to
generate micro-clusters. The micro-clusters are then incrementally
reclustered using an evolutionary algorithm. Evolutionary algorithms create
slight variations by combining and randomly modifying existing solutions. By
iteratively selecting better solutions, an evolutionary pressure is created
which improves the clustering over time. Since the evolutionary algorithm is
incremental, it is possible to apply it between observations, e.g. in the
idle time of the stream. Whenever there is idle time, we can call the
<code><a href="#topic+recluster">recluster()</a></code> function of the reference class to improve the
macro-clusters (see example). The evolutionary algorithm can also be applied
as a traditional reclustering step, or a combination of both. In addition,
this implementation also allows to evaluate a fixed number of generations
after each observation.
</p>


<h3>Author(s)</h3>

<p>Matthias Carnein <a href="mailto:Matthias.Carnein@uni-muenster.de">Matthias.Carnein@uni-muenster.de</a>
</p>


<h3>References</h3>

<p>Carnein M. and Trautmann H. (2018), &quot;evoStream - Evolutionary
Stream Clustering Utilizing Idle Times&quot;, Big Data Research.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>
</p>
<p>Other DSC_TwoStage: 
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2) %&gt;% DSD_Memory(n = 500)

## init evoStream
evoStream &lt;- DSC_evoStream(r = 0.05, k = 3,
  incrementalGenerations = 1, reclusterGenerations = 500)

## insert observations
update(evoStream, stream, n = 500)

## micro clusters
get_centers(evoStream, type = "micro")

## micro weights
get_weights(evoStream, type = "micro")

## macro clusters
get_centers(evoStream, type = "macro")

## macro weights
get_weights(evoStream, type = "macro")

## plot result
reset_stream(stream)
plot(evoStream, stream)

## if we have time, then we can evaluate additional generations.
## This can be called at any time, also between observations.
## by default, 1 generation is evaluated after each observation and
## 1000 generations during reclustering but we set it here to 500
evoStream$RObj$recluster(500)

## plot improved result
reset_stream(stream)
plot(evoStream, stream)

## get assignment of micro to macro clusters
microToMacro(evoStream)
</code></pre>

<hr>
<h2 id='DSC_Hierarchical'>Hierarchical Micro-Cluster Reclusterer</h2><span id='topic+DSC_Hierarchical'></span>

<h3>Description</h3>

<p>Macro Clusterer.
Implementation of hierarchical clustering to recluster a set of
micro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Hierarchical(
  formula = NULL,
  k = NULL,
  h = NULL,
  method = "complete",
  min_weight = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Hierarchical_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_Hierarchical_+3A_k">k</code></td>
<td>
<p>The number of desired clusters.</p>
</td></tr>
<tr><td><code id="DSC_Hierarchical_+3A_h">h</code></td>
<td>
<p>Height where to cut the dendrogram.</p>
</td></tr>
<tr><td><code id="DSC_Hierarchical_+3A_method">method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of <code>"ward"</code>, <code>"single"</code>, <code>"complete"</code>, &quot;<code style="white-space: pre;">&#8288;average"&#8288;</code>,
<code>"mcquitty"</code>, <code>"median"</code> or <code>"centroid"</code>.</p>
</td></tr>
<tr><td><code id="DSC_Hierarchical_+3A_min_weight">min_weight</code></td>
<td>
<p>micro-clusters with a weight less than this will be
ignored for reclustering.</p>
</td></tr>
<tr><td><code id="DSC_Hierarchical_+3A_description">description</code></td>
<td>
<p>optional character string to describe the clustering method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to <code><a href="stats.html#topic+hclust">hclust()</a></code> for more details on the behavior of the
algorithm.
</p>
<p><code><a href="#topic+update">update()</a></code> and <code><a href="#topic+recluster">recluster()</a></code> invisibly return the assignment of the data points
to clusters.
</p>
<p><strong>Note</strong> that this clustering cannot be updated iteratively and every time it is
used for (re)clustering, the old clustering is deleted.
</p>


<h3>Value</h3>

<p>A list of class <a href="#topic+DSC">DSC</a>, <a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Macro">DSC_Macro</a>, and
<code>DSC_Hierarchical</code>. The list contains the following items:
</p>
<table>
<tr><td><code>description</code></td>
<td>
<p>The name of the algorithm in the DSC object.</p>
</td></tr>
<tr><td><code>RObj</code></td>
<td>
<p>The underlying R object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# Use a moving window for "micro-clusters and recluster with HC (macro-clusters)
cl &lt;- DSC_TwoStage(
  micro = DSC_Window(horizon = 100),
  macro = DSC_Hierarchical(h = .1, method = "single")
)

update(cl, stream, 500)
cl

plot(cl, stream)
</code></pre>

<hr>
<h2 id='DSC_Kmeans'>Kmeans Macro-clusterer</h2><span id='topic+DSC_Kmeans'></span>

<h3>Description</h3>

<p>Macro Clusterer.
Class implements the k-means algorithm for reclustering a set of
micro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Kmeans(
  formula = NULL,
  k,
  weighted = TRUE,
  iter.max = 10,
  nstart = 10,
  algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  min_weight = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Kmeans_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_k">k</code></td>
<td>
<p>either the number of clusters, say k, or a set of initial
(distinct) cluster centers. If a number, a random set of (distinct) rows in
x is chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_weighted">weighted</code></td>
<td>
<p>use a weighted k-means (algorithm is ignored).</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_iter.max">iter.max</code></td>
<td>
<p>the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_nstart">nstart</code></td>
<td>
<p>if centers is a number, how many random sets should be chosen?</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>character: may be abbreviated.</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_min_weight">min_weight</code></td>
<td>
<p>micro-clusters with a weight less than this will be
ignored for reclustering.</p>
</td></tr>
<tr><td><code id="DSC_Kmeans_+3A_description">description</code></td>
<td>
<p>optional character string to describe the clustering
method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+update">update()</a></code> and <code><a href="#topic+recluster">recluster()</a></code> invisibly return the assignment of the data points
to clusters.
</p>
<p>Please refer to function <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> for more details on
the algorithm.
</p>
<p><strong>Note</strong> that this clustering cannot be updated iteratively and every time it is
used for (re)clustering, the old clustering is deleted.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_Kmeans</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Macro">DSC_Macro</a>)
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3 clusters with 5% noise
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# Use a moving window for "micro-clusters and recluster with k-means (macro-clusters)
cl &lt;- DSC_TwoStage(
  micro = DSC_Window(horizon = 100),
  macro = DSC_Kmeans(k = 3)
)

update(cl, stream, 500)
cl

plot(cl, stream)
</code></pre>

<hr>
<h2 id='DSC_Macro'>Abstract Class for Macro Clusterers (Offline Component)</h2><span id='topic+DSC_Macro'></span><span id='topic+microToMacro'></span>

<h3>Description</h3>

<p>Abstract class for all DSC Macro Clusterers which recluster micro-clusters <strong>offline</strong> into final
clusters called macro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Macro(...)

microToMacro(x, micro = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Macro_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="DSC_Macro_+3A_x">x</code></td>
<td>
<p>a <code>DSC_Macro</code> object that also contains information about
micro-clusters.</p>
</td></tr>
<tr><td><code id="DSC_Macro_+3A_micro">micro</code></td>
<td>
<p>A vector with micro-cluster ids. If <code>NULL</code> then the
assignments for all micro-clusters in <code>x</code> are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data stream clustering algorithms typically consists of an <strong>online component</strong>
that creates micro-clusters (implemented as <a href="#topic+DSC_Micro">DSC_Micro</a>) and
and <strong>offline components</strong> which is used to recluster micro-clusters into
final clusters called macro-clusters.
The function <code><a href="#topic+recluster">recluster()</a></code> is used extract micro-clusters from a <a href="#topic+DSC_Micro">DSC_Micro</a> and
create macro-clusters with a <code>DSC_Macro</code>.
</p>
<p>Available clustering methods can be found in the See Also section below.
</p>
<p><code><a href="#topic+microToMacro">microToMacro()</a></code> returns the assignment of Micro-cluster IDs to Macro-cluster IDs.
</p>
<p>For convenience, a <a href="#topic+DSC_Micro">DSC_Micro</a> and <code>DSC_Macro</code> can be combined using <a href="#topic+DSC_TwoStage">DSC_TwoStage</a>.
</p>
<p><code>DSC_Macro</code> cannot be instantiated.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>micro</code> with the macro-cluster
ids.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>

<hr>
<h2 id='DSC_Micro'>Abstract Class for Micro Clusterers (Online Component)</h2><span id='topic+DSC_Micro'></span>

<h3>Description</h3>

<p>Abstract class for all clustering methods that can operate <strong>online</strong> and result in a set of
micro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Micro(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Micro_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Micro-clustering algorithms are data stream mining tasks <a href="#topic+DST">DST</a>
which implement the <strong>online component of data stream clustering.</strong>
The clustering is performed sequentially by using <code><a href="#topic+update">update()</a></code>
to add new points from a data stream to the clustering. The result is
a set of micro-clusters that can be retrieved using <code><a href="#topic+get_clusters">get_clusters()</a></code>.
</p>
<p>Available clustering methods can be found in the See Also section below.
</p>
<p>Many data stream clustering algorithms define both, the online and an offline
component to recluster micro-clusters into larger clusters called macro-clusters.
This is implemented here as class <a href="#topic+DSC_TwoStage">DSC_TwoStage</a>.
</p>
<p><code>DSC_Micro</code> cannot be instantiated.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_BarsAndGaussians(noise = .05)

# Use a DStream to create micro-clusters
dstream &lt;- DSC_DStream(gridsize = 1, Cm = 1.5)
update(dstream, stream, 1000)
dstream
nclusters(dstream)
plot(dstream, stream, main = "micro-clusters")
</code></pre>

<hr>
<h2 id='DSC_R'>Abstract Class for Implementing R-based Clusterers</h2><span id='topic+DSC_R'></span><span id='topic+update.DSC_R'></span>

<h3>Description</h3>

<p>Abstract class for implementing R-based clusterers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_R(...)

## S3 method for class 'DSC_R'
update(
  object,
  dsd,
  n = 1L,
  verbose = FALSE,
  block = 10000L,
  return = c("nothing", "assignment", "model"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_R_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_object">object</code></td>
<td>
<p>a DSC object.</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_dsd">dsd</code></td>
<td>
<p>a data stream object.</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_n">n</code></td>
<td>
<p>number of data points taken from the stream.</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_verbose">verbose</code></td>
<td>
<p>logical; show progress?</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_block">block</code></td>
<td>
<p>process blocks of data to improve speed.</p>
</td></tr>
<tr><td><code id="DSC_R_+3A_return">return</code></td>
<td>
<p>a character string indicating what update returns. The default is <code>"nothing"</code>. Other
possible values depend on the <code>DST</code>. Examples are <code>"model"</code> and <code>"assignment"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+DSC_R">DSC_R</a> cannot be instantiated.
</p>
<p><strong>Implementing new Classes</strong>
</p>
<p>To implement a new clusterer you need to create an S3 class with elements <code>description</code> and
<code>RObj</code>. <code>RObj</code> needs to be a reference class with methods:
</p>

<ul>
<li> <p><code>cluster(newdata, ...)</code>
</p>
</li>
<li> <p><code>get_microclusters(...)</code>
</p>
</li>
<li> <p><code>get_microweights(...)</code>
</p>
</li>
<li> <p><code>get_macroclusters(...)</code>
</p>
</li>
<li> <p><code>get_macroweights(...)</code>
</p>
</li>
<li> <p><code>microToMacro(micro, ...)</code>
</p>
</li></ul>

<p>See <a href="#topic+DSC">DSC</a> for details and parameters.
</p>
<p><code>DSC_R</code> cannot be instantiated.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>

<hr>
<h2 id='DSC_Reachability'>Reachability Micro-Cluster Reclusterer</h2><span id='topic+DSC_Reachability'></span>

<h3>Description</h3>

<p>Macro Clusterer.
Implementation of reachability clustering (based on DBSCAN's concept of
reachability) to recluster a set of micro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Reachability(
  formula = NULL,
  epsilon,
  min_weight = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Reachability_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_Reachability_+3A_epsilon">epsilon</code></td>
<td>
<p>radius of the epsilon-neighborhood.</p>
</td></tr>
<tr><td><code id="DSC_Reachability_+3A_min_weight">min_weight</code></td>
<td>
<p>micro-clusters with a weight less than this will be
ignored for reclustering.</p>
</td></tr>
<tr><td><code id="DSC_Reachability_+3A_description">description</code></td>
<td>
<p>optional character string to describe the clustering
method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two micro-clusters are directly reachable if they are within each other's
epsilon-neighborhood (i.e., the distance between the centers is less then
epsilon). Two micro-clusters are reachable if they are connected by a chain
of pairwise directly reachable micro-clusters.  All mutually reachable
micro-clusters are put in the same cluster.
</p>
<p>Reachability uses internally <a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a> with single link.
</p>
<p><code><a href="#topic+update">update()</a></code> and <code><a href="#topic+recluster">recluster()</a></code> invisibly return the assignment of the data points
to clusters.
</p>
<p><strong>Note</strong> that this clustering cannot be updated iteratively and every time it is
used for (re)clustering, the old clustering is deleted.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_Reachability</code>. The object contains the
following items:
</p>
<table>
<tr><td><code>description</code></td>
<td>
<p>The name of the algorithm in the DSC object.</p>
</td></tr>
<tr><td><code>RObj</code></td>
<td>
<p>The underlying R object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Martin Ester, Hans-Peter Kriegel, Joerg Sander, Xiaowei Xu
(1996). A density-based algorithm for discovering clusters in large spatial
databases with noise. In Evangelos Simoudis, Jiawei Han, Usama M. Fayyad.
<em>Proceedings of the Second International Conference on Knowledge
Discovery and Data Mining (KDD-96).</em> AAAI Press. pp. 226-231.
</p>


<h3>See Also</h3>

<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # 3 clusters with 5% noise
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# Use a moving window for "micro-clusters and recluster with DBSCAN (macro-clusters)
cl &lt;- DSC_TwoStage(
  micro = DSC_Window(horizon = 100),
  macro = DSC_Reachability(eps = .05)
)

update(cl, stream, 500)
cl

plot(cl, stream)
</code></pre>

<hr>
<h2 id='DSC_Sample'>Extract a Fixed-size Sample from a Data Stream</h2><span id='topic+DSC_Sample'></span>

<h3>Description</h3>

<p>Micro Clusterer.
Extracts a sample form a data stream using Reservoir Sampling (<a href="#topic+DSAggregate_Sample">DSAggregate_Sample</a>).  The sample
is stored as a set of micro-clusters to be compatible with other data DSC
stream clustering algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Sample(k = 100, biased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Sample_+3A_k">k</code></td>
<td>
<p>the number of points to be sampled from the stream.</p>
</td></tr>
<tr><td><code id="DSC_Sample_+3A_biased">biased</code></td>
<td>
<p>if <code>FALSE</code> then a regular (unbiased) reservoir sampling
is used. If true then the sample is biased towards keeping more recent data
points (see Details section).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>biased = FALSE</code> then the reservoir sampling algorithm by McLeod and
Bellhouse (1983) is used. This sampling makes sure that each data point has
the same chance to be sampled. All sampled points will have a weight of 1.
Note that this might not be ideal for an evolving stream since very old data
points have the same chance to be in the sample as newer points.
</p>
<p>If <code>bias = TRUE</code> then sampling prefers newer points using the modified
reservoir sampling algorithm 2.1 by Aggarwal (2006). New points are always
added. They replace a random point in the reservoir with a probability of
reservoir size over <code>k</code>. This an exponential bias function of
<code>2^{-lambda}</code> with <code>lambda = 1 / k</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_Sample</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Micro">DSC_Micro</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Vitter, J. S. (1985): Random sampling with a reservoir.
<em>ACM Transactions on Mathematical Software,</em> 11(1), 37-57.
</p>
<p>McLeod, A.I., Bellhouse, D.R. (1983): A Convenient Algorithm for Drawing a
Simple Random Sample. <em>Applied Statistics,</em> 32(2), 182-184.
</p>
<p>Aggarwal C. (2006) On Biased Reservoir Sampling in the Presence of Stream
Evolution. <em>International Conference on Very Large Databases
(VLDB'06).</em> 607-618.
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Window">DSC_Window</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

sample &lt;- DSC_Sample(k = 20)
update(sample, stream, 500)
sample

# plot micro-clusters
plot(sample, stream)

# recluster the sample with k-means
kmeans &lt;- DSC_Kmeans(k = 3)
recluster(kmeans, sample)
plot(kmeans, stream)

# sample from an evolving stream
stream &lt;- DSD_Benchmark(1)
sample &lt;- DSC_Sample(k = 20)
update(sample, stream, 1000)

plot(sample, stream)
# Note: the clusters move from left to right and the sample keeps many
# outdated points

# use a biased sample to keep more recent data points
stream &lt;- DSD_Benchmark(1)
sample &lt;- DSC_Sample(k = 20, biased = TRUE)
update(sample, stream, 1000)
plot(sample, stream)
</code></pre>

<hr>
<h2 id='DSC_SlidingWindow'>DSC_SlidingWindow &ndash; Data Stream Clusterer Using a Sliding Window</h2><span id='topic+DSC_SlidingWindow'></span>

<h3>Description</h3>

<p>The clusterer keeps a sliding window for the stream and rebuilds a DSC clustering model at regular
intervals. By default is uses <a href="#topic+DSC_Kmeans">DSC_Kmeans</a>. Other <a href="#topic+DSC_Macro">DSC_Macro</a> clusterer can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_SlidingWindow(formula = NULL, model = DSC_Kmeans, window, rebuild, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_SlidingWindow_+3A_formula">formula</code></td>
<td>
<p>a formula for the classification problem.</p>
</td></tr>
<tr><td><code id="DSC_SlidingWindow_+3A_model">model</code></td>
<td>
<p>regression model (that has a formula interface).</p>
</td></tr>
<tr><td><code id="DSC_SlidingWindow_+3A_window">window</code></td>
<td>
<p>size of the sliding window.</p>
</td></tr>
<tr><td><code id="DSC_SlidingWindow_+3A_rebuild">rebuild</code></td>
<td>
<p>interval (number of points) for rebuilding the regression. Set rebuild to
<code>Inf</code> to prevent automatic rebuilding. Rebuilding can be initiated manually when
calling <code>update()</code>.</p>
</td></tr>
<tr><td><code id="DSC_SlidingWindow_+3A_...">...</code></td>
<td>
<p>additional parameters are passed on to the clusterer (default is <a href="#topic+DSC_Kmeans">DSC_Kmeans</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructor creates a clusterer based on <code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a></code>. The clusterer has
a <code>update()</code> and <code>predict()</code> method.
</p>
<p>The difference to setting up a <a href="#topic+DSC_TwoStage">DSC_TwoStage</a> is that <code>DSC_SlidingWindow</code> rebuilds
the model in regular intervals, while <code>DSC_TwoStage</code> rebuilds the model on demand.
</p>


<h3>Value</h3>

<p>An object of class <code>DST_SlidingWindow</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>
<p>Other DSC_Macro: 
<code><a href="#topic+DSC_DBSCAN">DSC_DBSCAN</a>()</code>,
<code><a href="#topic+DSC_EA">DSC_EA</a>()</code>,
<code><a href="#topic+DSC_Hierarchical">DSC_Hierarchical</a>()</code>,
<code><a href="#topic+DSC_Kmeans">DSC_Kmeans</a>()</code>,
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Reachability">DSC_Reachability</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stream)

stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

# define the stream clusterer.
cl &lt;- DSC_SlidingWindow(
  formula = ~ . - `.class`,
  k = 3,
  window = 50,
  rebuild = 10
  )
cl

# update the clusterer with 100 points from the stream
update(cl, stream, 100)

# get the cluster model
cl$model$result

plot(cl$model$result)
</code></pre>

<hr>
<h2 id='DSC_Static'>Create as Static Copy of a Clustering</h2><span id='topic+DSC_Static'></span>

<h3>Description</h3>

<p>This representation cannot perform clustering anymore, but it also does not
need the supporting data structures. It only stores the cluster centers and
weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Static(
  x,
  type = c("auto", "micro", "macro"),
  k_largest = NULL,
  min_weight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Static_+3A_x">x</code></td>
<td>
<p>The clustering (a DSD object) to copy or a list with components <code>centers</code> (a data frame or matrix) and
<code>weights</code> (a vector with cluster weights).</p>
</td></tr>
<tr><td><code id="DSC_Static_+3A_type">type</code></td>
<td>
<p>which clustering to copy.</p>
</td></tr>
<tr><td><code id="DSC_Static_+3A_k_largest">k_largest</code></td>
<td>
<p>only copy the k largest (highest weight) clusters.</p>
</td></tr>
<tr><td><code id="DSC_Static_+3A_min_weight">min_weight</code></td>
<td>
<p>only copy clusters with a weight larger or equal to
<code>min_weight</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DSC_Static</code> (sub class of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>). The list also contains either <a href="#topic+DSC_Micro">DSC_Micro</a> or
<a href="#topic+DSC_Macro">DSC_Macro</a> depending on what type of clustering was copied.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

dstream &lt;- DSC_DStream(gridsize = 0.05)
update(dstream, stream, 500)
dstream
plot(dstream, stream)

# create a static copy of the clustering
static &lt;- DSC_Static(dstream)
static
plot(static, stream)

# copy only the 5 largest clusters
static2 &lt;- DSC_Static(dstream, k_largest = 5)
static2
plot(static2, stream)

# copy all clusters with a weight of at least .3
static3 &lt;- DSC_Static(dstream, min_weight = .3)
static3
plot(static3, stream)

# create a manual clustering
static4 &lt;- DSC_Static(list(
             centers = data.frame(X1 = c(1, 2), X2 = c(1, 2)),
             weights = c(1, 2)),
             type = "macro")
static4
plot(static4)
</code></pre>

<hr>
<h2 id='DSC_TwoStage'>TwoStage Clustering Process</h2><span id='topic+DSC_TwoStage'></span>

<h3>Description</h3>

<p>Combines an <strong>online clustering component</strong> (<a href="#topic+DSC_Micro">DSC_Micro</a>)
and an <strong>offline reclustering component</strong> (<a href="#topic+DSC_Macro">DSC_Macro</a>)
into a single process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_TwoStage(micro, macro)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_TwoStage_+3A_micro">micro</code></td>
<td>
<p>Clustering algorithm used in the online stage
(<a href="#topic+DSC_Micro">DSC_Micro</a>)</p>
</td></tr>
<tr><td><code id="DSC_TwoStage_+3A_macro">macro</code></td>
<td>
<p>Clustering algorithm used for reclustering in the offline stage
(<a href="#topic+DSC_Macro">DSC_Macro</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>update()</code> runs the online micro-clustering stage and only when macro cluster
centers/weights are requested using <code><a href="#topic+get_centers">get_centers()</a></code> or <code><a href="#topic+get_weights">get_weights()</a></code>, then the offline stage
reclustering is automatically performed.
</p>
<p>Available clustering methods can be found in the See Also section below.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_TwoStage</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_Macro">DSC_Macro</a>) which is a named list with elements:
</p>

<ul>
<li> <p><code>description</code>: a description of the clustering algorithms.
</p>
</li>
<li> <p><code>micro</code>: The <a href="#topic+DSD">DSD</a> used for creating micro clusters in the online component.
</p>
</li>
<li> <p><code>macro</code>: The <a href="#topic+DSD">DSD</a> for offline reclustering.
</p>
</li>
<li> <p><code>state</code>: an environment storing state information needed for reclustering.
</p>
</li></ul>

<p>with the two clusterers. The names are
&ldquo;
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC_TwoStage: 
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2)

# Create a clustering process that uses a window for the online stage and
# k-means for the offline stage (reclustering)
win_km &lt;- DSC_TwoStage(
  micro = DSC_Window(horizon = 100),
  macro = DSC_Kmeans(k = 3)
  )
win_km

update(win_km, stream, 200)
win_km
win_km$micro
win_km$macro

plot(win_km, stream)
evaluate_static(win_km, stream, assign = "macro")
</code></pre>

<hr>
<h2 id='DSC_Window'>A sliding window from a Data Stream</h2><span id='topic+DSC_Window'></span>

<h3>Description</h3>

<p>Interface for DSO_Window. Represents the points in the sliding window as
micro-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_Window(horizon = 100, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_Window_+3A_horizon">horizon</code></td>
<td>
<p>the window length.</p>
</td></tr>
<tr><td><code id="DSC_Window_+3A_lambda">lambda</code></td>
<td>
<p>decay factor damped window model. <code>lambda = 0</code> means no
dampening.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lambda</code> is greater than 0 then the weight uses a damped window
model (Zhu and Shasha, 2002).  The weight for points in the window follows
<code class="reqn">2^{-lambda*t}</code> where <code class="reqn">t</code> is the age of the point.
</p>


<h3>Value</h3>

<p>An object of class <code>DSC_Window</code> (subclass of <a href="#topic+DSC">DSC</a>,
<a href="#topic+DSC_R">DSC_R</a>, <a href="#topic+DSC_Micro">DSC_Micro</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Zhu, Y. and Shasha, D. (2002). StatStream: Statistical
Monitoring of Thousands of Data Streams in Real Time, <em>International
Conference of Very Large Data Bases (VLDB'02).</em>
</p>


<h3>See Also</h3>

<p>Other DSC_Micro: 
<code><a href="#topic+DSC_BICO">DSC_BICO</a>()</code>,
<code><a href="#topic+DSC_BIRCH">DSC_BIRCH</a>()</code>,
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_Sample">DSC_Sample</a>()</code>,
<code><a href="#topic+DSC_evoStream">DSC_evoStream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.05)

window &lt;- DSC_Window(horizon = 100)
window

update(window, stream, 200)
window

# plot micro-clusters
plot(window, stream)

# animation for a window using a damped window model. The weight decays
# with a half-life of 25
## Not run: 
window &lt;- DSC_Window(horizon = 25, lambda = 1 / 25)
animate_cluster(window, stream, horizon = 1, n = 100, xlim = c(0, 1), ylim = c(0, 1))

## End(Not run)

</code></pre>

<hr>
<h2 id='DSClassifier'>Abstract Class for Data Stream Classifiers</h2><span id='topic+DSClassifier'></span>

<h3>Description</h3>

<p>Abstract class for data stream classifiers. More implementations can be found in
package <span class="pkg">streamMOA</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSClassifier(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSClassifier_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSClassifier: 
<code><a href="#topic+DSClassifier_SlidingWindow">DSClassifier_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSClassifier()
</code></pre>

<hr>
<h2 id='DSClassifier_SlidingWindow'>DSClassifier_SlidingWindow &ndash; Data Stream Classifier Using a Sliding Window</h2><span id='topic+DSClassifier_SlidingWindow'></span>

<h3>Description</h3>

<p>The classifier keeps a sliding window for the stream and rebuilds a classification model at regular
intervals. By default is builds a decision tree using <code><a href="rpart.html#topic+rpart">rpart()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSClassifier_SlidingWindow(formula, model = rpart::rpart, window, rebuild, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSClassifier_SlidingWindow_+3A_formula">formula</code></td>
<td>
<p>a formula for the classification problem.</p>
</td></tr>
<tr><td><code id="DSClassifier_SlidingWindow_+3A_model">model</code></td>
<td>
<p>classifier model (that has a formula interface).</p>
</td></tr>
<tr><td><code id="DSClassifier_SlidingWindow_+3A_window">window</code></td>
<td>
<p>size of the sliding window.</p>
</td></tr>
<tr><td><code id="DSClassifier_SlidingWindow_+3A_rebuild">rebuild</code></td>
<td>
<p>interval (number of points) for rebuilding the classifier. Set rebuild to
<code>Inf</code> to prevent automatic rebuilding. Rebuilding can be initiated manually when
calling <code>update()</code>.</p>
</td></tr>
<tr><td><code id="DSClassifier_SlidingWindow_+3A_...">...</code></td>
<td>
<p>additional parameters are passed on to the classifier (default is <code>rpart()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructor creates classifier based on <code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a></code>. The classifier has
a <code>update()</code> and <code>predict()</code> method.
</p>


<h3>Value</h3>

<p>An object of class <code>DST_SlidingWindow</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSClassifier: 
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stream)

# create a data stream for the iris dataset
data &lt;- iris[sample(nrow(iris)), ]
stream &lt;- DSD_Memory(data)

# define the stream classifier.
cl &lt;- DSClassifier_SlidingWindow(
  Species ~ Sepal.Length + Sepal.Width + Petal.Length,
  window = 50,
  rebuild = 10
  )
cl

# update the classifier with 100 points from the stream
update(cl, stream, 100)

# predict the class for the next 50 points
newdata &lt;- get_points(stream, n = 50)
pr &lt;- predict(cl, newdata, type = "class")
pr

table(pr, newdata$Species)

# get the tree model
get_model(cl)
</code></pre>

<hr>
<h2 id='DSD'>Data Stream Data Generator Base Classes</h2><span id='topic+DSD'></span><span id='topic+DSD_R'></span>

<h3>Description</h3>

<p>Abstract base classes for DSD (Data Stream Data Generator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD(...)

DSD_R(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSD</code> class cannot be instantiated, but it serves as a abstract
base class from which all DSD objects inherit. Implementations can be found in the
See Also section below.
</p>
<p><code>DSD</code> provides common functionality like:
</p>

<ul>
<li> <p><code><a href="#topic+get_points">get_points()</a></code>
</p>
</li>
<li> <p><code>print()</code>
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+reset_stream">reset_stream()</a></code> (if available)
</p>
</li>
<li> <p><code><a href="#topic+close_stream">close_stream()</a></code> (if needed)
</p>
</li></ul>

<p><code>DSD_R</code> inherits form <code>DSD</code> and is the abstract parent class for
DSD implemented in R. To create a new R-based implementation there are only
two function that needs to be implemented for a new <code>DSD</code> subclass
called <code>Foo</code> would be:
</p>

<ol>
<li><p> A creator function <code>DSD_Foo(...)</code> and
</p>
</li>
<li><p> a method <code>get_points.DSD_Foo(x, n = 1L)</code> for that class.
</p>
</li></ol>

<p>For details see <code>vignette()</code>
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSD()

# create data stream with three clusters in 3-dimensional space
stream &lt;- DSD_Gaussians(k = 3, d = 3)

# get points from stream
get_points(stream, n = 5)

# plotting the data (scatter plot matrix, first and third dimension, and first
#  two principal components)
plot(stream)
plot(stream, dim = c(1, 3))
plot(stream, method = "pca")
</code></pre>

<hr>
<h2 id='DSD_BarsAndGaussians'>Data Stream Generator for Bars and Gaussians</h2><span id='topic+DSD_BarsAndGaussians'></span>

<h3>Description</h3>

<p>A data stream generator which creates the shape of two bars and two
Gaussians clusters with different density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_BarsAndGaussians(angle = NULL, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_BarsAndGaussians_+3A_angle">angle</code></td>
<td>
<p>rotation in degrees. <code>NULL</code> will produce a random rotation.</p>
</td></tr>
<tr><td><code id="DSD_BarsAndGaussians_+3A_noise">noise</code></td>
<td>
<p>The amount of noise that should be added to the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>DSD_BarsAndGaussians</code> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><a href="#topic+DSD">DSD</a>
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data stream with three clusters in 2D
stream &lt;- DSD_BarsAndGaussians(noise = 0.1)

get_points(stream, n = 10)
plot(stream)
</code></pre>

<hr>
<h2 id='DSD_Benchmark'>Data Stream Generator for Dynamic Data Stream Benchmarks</h2><span id='topic+DSD_Benchmark'></span>

<h3>Description</h3>

<p>A data stream generator that generates several dynamic streams indented to
be benchmarks to compare data stream clustering algorithms.  The benchmarks
can be used to test if a clustering algorithm can follow moving clusters, and merging and
separating clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Benchmark(i = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Benchmark_+3A_i">i</code></td>
<td>
<p>integer; the number of the benchmark.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently available benchmarks are:
</p>

<ul>
<li> <p><code>1</code>: two tight clusters moving across the data space with noise and intersect in the middle.
</p>
</li>
<li> <p><code>2</code>: two clusters are located in two corners of the data space. A third cluster moves between the two clusters
forth and back.
</p>
</li></ul>

<p>The benchmarks are created using <a href="#topic+DSD_MG">DSD_MG</a>.
</p>


<h3>Value</h3>

<p>Returns a <a href="#topic+DSD">DSD</a> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Benchmark(i = 1)
get_points(stream, n = 5)

## Not run: 
stream &lt;- DSD_Benchmark(i = 1)
animate_data(stream, n = 10000, horizon = 100, xlim = c(0, 1), ylim = c(0, 1))

stream &lt;- DSD_Benchmark(i = 2)
animate_data(stream, n = 10000, horizon = 100, xlim = c(0, 1), ylim = c(0, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='DSD_Cubes'>Static Cubes Data Stream Generator</h2><span id='topic+DSD_Cubes'></span>

<h3>Description</h3>

<p>A data stream generator that produces a data stream with static (hyper)
cubes filled uniformly with data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Cubes(k = 2, d = 2, center, size, p, noise = 0, noise_range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Cubes_+3A_k">k</code></td>
<td>
<p>Determines the number of clusters.</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_d">d</code></td>
<td>
<p>Determines the number of dimensions.</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_center">center</code></td>
<td>
<p>A matrix of means for each dimension of each cluster.</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_size">size</code></td>
<td>
<p>A <code>k</code> times <code>d</code> matrix with the cube dimensions.</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_p">p</code></td>
<td>
<p>A vector of probabilities that determines the likelihood of
generated a data point from a particular cluster.</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_noise">noise</code></td>
<td>
<p>Noise probability between 0 and 1.  Noise is uniformly
distributed within noise range (see below).</p>
</td></tr>
<tr><td><code id="DSD_Cubes_+3A_noise_range">noise_range</code></td>
<td>
<p>A matrix with d rows and 2 columns. The first column
contains the minimum values and the second column contains the maximum
values for noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>DSD_Cubes</code> object (subclass of <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data stream with three clusters in 3D
stream &lt;- DSD_Cubes(k = 3, d = 3, noise = 0.05)

get_points(stream, n = 5)

plot(stream)
</code></pre>

<hr>
<h2 id='DSD_Gaussians'>Mixture of Gaussians Data Stream Generator</h2><span id='topic+DSD_Gaussians'></span>

<h3>Description</h3>

<p>A data stream generator that produces a data stream with a mixture of static
Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Gaussians(
  k = 3,
  d = 2,
  p,
  mu,
  sigma,
  variance_limit = c(0.001, 0.002),
  separation = 6,
  space_limit = c(0, 1),
  noise = 0,
  noise_limit = space_limit,
  noise_separation = 3,
  separation_type = c("Euclidean", "Mahalanobis"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Gaussians_+3A_k">k</code></td>
<td>
<p>Determines the number of clusters.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_d">d</code></td>
<td>
<p>Determines the number of dimensions.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_p">p</code></td>
<td>
<p>A vector of probabilities that determines the likelihood of
generated a data point from a particular cluster.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_mu">mu</code></td>
<td>
<p>A matrix of means for each dimension of each cluster.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_sigma">sigma</code></td>
<td>
<p>A list of length <code>k</code> of covariance matrices.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_variance_limit">variance_limit</code></td>
<td>
<p>Lower and upper limit for the randomly generated variance when
creating cluster covariance matrices.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_separation">separation</code></td>
<td>
<p>Minimum separation distance between clusters
(measured in standard deviations according to <code>separation_type</code>).</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_space_limit">space_limit</code></td>
<td>
<p>Defines the space bounds. All constructs are generated
inside these bounds. For clusters this means that their centroids must be
within these space bounds.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_noise">noise</code></td>
<td>
<p>Noise probability between 0 and 1.  Noise is uniformly
distributed within noise range (see below).</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_noise_limit">noise_limit</code></td>
<td>
<p>A matrix with d rows and 2 columns. The first column
contains the minimum values and the second column contains the maximum
values for noise.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_noise_separation">noise_separation</code></td>
<td>
<p>Minimum separation distance between cluster centers and noise
points (measured in standard deviations according to <code>separation_type</code>). <code>0</code> means separation is ignored.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_separation_type">separation_type</code></td>
<td>
<p>The type of the separation distance calculation. It
can be either Euclidean distance or Mahalanobis distance.</p>
</td></tr>
<tr><td><code id="DSD_Gaussians_+3A_verbose">verbose</code></td>
<td>
<p>Report cluster and outlier generation process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DSD_Gaussians</code> creates a mixture of <code>k</code> static clusters in a <code>d</code>-dimensional
space. The cluster
centers <code>mu</code> and the covariance matrices <code>sigma</code> can be supplied
or will be randomly generated. The probability vector <code>p</code> defines for
each cluster the probability that the next data point will be chosen from it
(defaults to equal probability). Separation between generated clusters (and outliers; see below)
can be imposed by using
Euclidean or Mahalanobis distance, which is controlled by the
<code>separation_type</code> parameter. Separation value then is supplied in the
<code>separation</code> parameter.
The generation method is similar to the one
suggested by Jain and Dubes (1988).
</p>
<p>Noise points which are uniformly chosen from <code>noise_limit</code> can be added.
</p>
<p>Outlier points can be added. The outlier spatial positions
<code>predefined_outlier_space_positions</code> and the outlier stream positions
<code>predefined_outlier_stream_positions</code> can be supplied or will be
randomly generated. Cluster and outlier separation distance is determined by
and <code>outlier_virtual_variance</code> parameters. The
outlier virtual variance defines an empty space around outliers, which
separates them from their surrounding. Unlike noise, outliers are data
points of interest for end-users, and the goal of outlier detectors is to
find them in data streams. For more details, read the &quot;Introduction to
<span class="pkg">stream</span>&quot; vignette.
</p>


<h3>Value</h3>

<p>Returns a  object of class <code>DSD_Gaussian</code> (subclass of <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Jain and Dubes (1988) Algorithms for clustering data,
Prentice-Hall, Inc., Upper Saddle River, NJ, USA.
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: create data stream with three clusters in 3-dimensional data space
#            with 5 times sqrt(variance_limit) separation.
set.seed(1)
stream1 &lt;- DSD_Gaussians(k = 3, d = 3)
stream1

get_points(stream1, n = 5)
plot(stream1, xlim = c(0, 1), ylim = c(0, 1))


# Example 2: create data stream with specified cluster positions,
# 5% noise in a given bounding box and
# with different densities (1 to 9 between the two clusters)
stream2 &lt;- DSD_Gaussians(k = 2, d = 2,
    mu = rbind(c(-.5, -.5), c(.5, .5)),
    p = c(.1, .9),
    variance_limit = c(0.02, 0.04),
    noise = 0.05,
    noise_limit = rbind(c(-1, 1), c(-1, 1)))

get_points(stream2, n = 5)
plot(stream2, xlim = c(-1, 1), ylim = c(-1, 1))


# Example 3: create 4 clusters and noise separated by a Mahalanobis
# distance. Distance to noise is increased to 6 standard deviations to make them
# easier detectable outliers.
stream3 &lt;- DSD_Gaussians(k = 4, d = 2,
  separation_type = "Mahalanobis",
  space_limit = c(5, 20),
  variance_limit = c(1, 2),
  noise = 0.05,
  noise_limit = c(0, 25),
  noise_separation = 6
  )
plot(stream3)
</code></pre>

<hr>
<h2 id='DSD_Memory'>A Data Stream Interface for Data Stored in Memory</h2><span id='topic+DSD_Memory'></span>

<h3>Description</h3>

<p>This class provides a data stream interface for data stored in memory as
matrix-like objects (including data frames). All or a portion of the stored
data can be replayed several times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Memory(
  x,
  n,
  k = NA,
  outofpoints = c("warn", "ignore", "stop"),
  loop = FALSE,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Memory_+3A_x">x</code></td>
<td>
<p>A matrix-like object containing the data.  If <code>x</code> is a DSD
object then a data frame for <code>n</code> data points from this DSD is created.</p>
</td></tr>
<tr><td><code id="DSD_Memory_+3A_n">n</code></td>
<td>
<p>Number of points used if <code>x</code> is a DSD object. If <code>x</code> is a
matrix-like object then <code>n</code> is ignored.</p>
</td></tr>
<tr><td><code id="DSD_Memory_+3A_k">k</code></td>
<td>
<p>Optional: The known number of clusters in the data</p>
</td></tr>
<tr><td><code id="DSD_Memory_+3A_outofpoints">outofpoints</code></td>
<td>
<p>Action taken if less than <code>n</code> data points are
available. The default is to return the available data points with a warning. Other supported actions are:
</p>

<ul>
<li> <p><code>warn</code>: return the available points (maybe an empty data.frame) with a warning.
</p>
</li>
<li> <p><code>ignore</code>: silently return the available points.
</p>
</li>
<li> <p><code>stop</code>: stop with an error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DSD_Memory_+3A_loop">loop</code></td>
<td>
<p>Should the stream start over when it reaches the end?</p>
</td></tr>
<tr><td><code id="DSD_Memory_+3A_description">description</code></td>
<td>
<p>character string with a description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to regular data.frames other matrix-like objects that provide
subsetting with the bracket operator can be used. This includes <code>ffdf</code>
(large data.frames stored on disk) from package <span class="pkg">ff</span> and
<code>big.matrix</code> from <span class="pkg">bigmemory</span>.
</p>
<p><strong>Reading the whole stream</strong>
By using <code>n = -1</code> in <code>get_points()</code>, the whole stream is returned.
</p>


<h3>Value</h3>

<p>Returns a <code>DSD_Memory</code> object (subclass of <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: store 1000 points from a stream
stream &lt;- DSD_Gaussians(k = 3, d = 2)
replayer &lt;- DSD_Memory(stream, k = 3, n = 1000)
replayer
plot(replayer)

# creating 2 clusterers of different algorithms
dsc1 &lt;- DSC_DBSTREAM(r = 0.1)
dsc2 &lt;- DSC_DStream(gridsize = 0.1, Cm = 1.5)

# clustering the same data in 2 DSC objects
reset_stream(replayer) # resetting the replayer to the first position
update(dsc1, replayer, 500)
reset_stream(replayer)
update(dsc2, replayer, 500)

# plot the resulting clusterings
reset_stream(replayer)
plot(dsc1, replayer, main = "DBSTREAM")
reset_stream(replayer)
plot(dsc2, replayer, main = "D-Stream")


# Example 2: use a data.frame to create a stream (3rd col. contains the assignment)
df &lt;- data.frame(x = runif(100), y = runif(100),
  .class = sample(1:3, 100, replace = TRUE))

# add some outliers
out &lt;- runif(100) &gt; .95
df[['.outlier']] &lt;- out
df[['.class']] &lt;- NA
head(df)

stream &lt;- DSD_Memory(df)
stream

reset_stream(stream)
get_points(stream, n = 5)

# get the remaining points
rest &lt;- get_points(stream, n = -1)
nrow(rest)

# plot all available points with n = -1
reset_stream(stream)
plot(stream, n = -1)
</code></pre>

<hr>
<h2 id='DSD_MG'>DSD Moving Generator</h2><span id='topic+DSD_MG'></span><span id='topic+add_cluster'></span><span id='topic+get_clusters'></span><span id='topic+remove_cluster'></span><span id='topic+add_cluster.DSD_MG'></span>

<h3>Description</h3>

<p>Creates an evolving DSD that consists of several <a href="#topic+MGC">MGC</a>, each representing a moving cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_MG(dimension = 2, ..., labels = NULL, description = NULL)

add_cluster(x, c, label = NULL)

get_clusters(x)

remove_cluster(x, i)

## S3 method for class 'DSD_MG'
add_cluster(x, c, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_MG_+3A_dimension">dimension</code></td>
<td>
<p>the dimension of the DSD object</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_...">...</code></td>
<td>
<p>initial set of <a href="#topic+MGC">MGC</a>s</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_description">description</code></td>
<td>
<p>An optional string used by <code>print()</code> to describe the
data generator.</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_x">x</code></td>
<td>
<p>A <code>DSD_MG</code> object.</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_c">c</code></td>
<td>
<p>The cluster that should be added to the <code>DSD_MG</code> object.</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_label">label</code>, <code id="DSD_MG_+3A_labels">labels</code></td>
<td>
<p>integer representing the cluster label. <code>NA</code>
represents noise.  If labels are not specified, then each new cluster gets a
new label.</p>
</td></tr>
<tr><td><code id="DSD_MG_+3A_i">i</code></td>
<td>
<p>The index of the cluster that should be removed from the
<code>DSD_MG</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This DSD is able to generate complex datasets that are able to evolve over a
period of time. Its behavior is determined by as set of <a href="#topic+MGC">MGC</a>s, each representing
a moving cluster.
</p>


<h3>Author(s)</h3>

<p>Matthew Bolanos
</p>


<h3>See Also</h3>

<p><a href="#topic+MGC">MGC</a> for types of moving clusters.
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create an empty DSD_MG
stream &lt;- DSD_MG(dim = 2)
stream

### add two clusters
c1 &lt;- MGC_Random(density = 50, center = c(50, 50), parameter = 1)
add_cluster(stream, c1)
stream

c2 &lt;- MGC_Noise(density = 1, range = rbind(c(-20, 120), c(-20, 120)))
add_cluster(stream, c2)
stream

get_clusters(stream)
get_points(stream, n = 5)
plot(stream, xlim = c(-20,120), ylim = c(-20, 120))

if (interactive()) {
animate_data(stream, n = 5000, xlim = c(-20, 120), ylim = c(-20, 120))
}

### remove cluster 1
remove_cluster(stream, 1)
stream

get_clusters(stream)
plot(stream, xlim = c(-20, 120), ylim = c(-20, 120))

### create a more complicated cluster structure (using 2 clusters with the same
### label to form an L shape)
stream &lt;- DSD_MG(dim = 2,
  MGC_Static(density = 10, center = c(.5, .2),   par = c(.4, .2),   shape = Shape_Block),
  MGC_Static(density = 10, center = c(.6, .5),   par = c(.2, .4),   shape = Shape_Block),
  MGC_Static(density = 5,  center = c(.39, .53), par = c(.16, .35), shape = Shape_Block),
  MGC_Noise( density = 1,  range = rbind(c(0,1), c(0,1))),
  labels = c(1, 1, 2, NA)
  )
stream

plot(stream, xlim = c(0, 1), ylim = c(0, 1))

### simulate the clustering of a splitting cluster
c1 &lt;- MGC_Linear(dim = 2, keyframelist = list(
  keyframe(time = 1,  dens = 20, center = c(0,0),   param = 10),
  keyframe(time = 50, dens = 10, center = c(50,50), param = 10),
  keyframe(time = 100,dens = 10, center = c(50,100),param = 10)
))

### Note: Second cluster appearch at time=50
c2 &lt;- MGC_Linear(dim = 2, keyframelist = list(
  keyframe(time = 50, dens = 10, center = c(50,50), param = 10),
  keyframe(time = 100,dens = 10, center = c(100,50),param = 10)
))

stream &lt;- DSD_MG(dim = 2, c1, c2)
stream

dbstream &lt;- DSC_DBSTREAM(r = 20, lambda = 0.1)
if (interactive()) {
purity &lt;- animate_cluster(dbstream, stream, n = 2500, type = "micro",
  xlim = c(-10, 120), ylim = c(-10, 120), measure = "purity", horizon = 100)
}
</code></pre>

<hr>
<h2 id='DSD_Mixture'>Mixes Data Points from Several Streams into a Single Stream</h2><span id='topic+DSD_Mixture'></span>

<h3>Description</h3>

<p>This generator mixes multiple streams given specified probabilities.
The streams have to contain the same number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Mixture(..., prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Mixture_+3A_...">...</code></td>
<td>
<p><a href="#topic+DSD">DSD</a> objects.</p>
</td></tr>
<tr><td><code id="DSD_Mixture_+3A_prob">prob</code></td>
<td>
<p>a numeric vector with the probability for each stream that the next point will
be drawn from that stream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>DSD_Mixture</code> object.(subclass of <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data stream with three clusters in 2D
stream1 &lt;- DSD_Gaussians(d = 2, k = 3)
stream2 &lt;- DSD_UniformNoise(d = 2,  range = rbind(c(-.5, 1.5), c(-.5, 1.5)))

combinedStream &lt;- DSD_Mixture(stream1, stream2, prob = c(.9, .1))
combinedStream

get_points(combinedStream, n = 20)
plot(combinedStream, n = 200)
</code></pre>

<hr>
<h2 id='DSD_mlbenchData'>Stream Interface for Data Sets From mlbench</h2><span id='topic+DSD_mlbenchData'></span>

<h3>Description</h3>

<p>Provides a convenient stream interface for data sets from the mlbench
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_mlbenchData(data = NULL, loop = FALSE, random = FALSE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_mlbenchData_+3A_data">data</code></td>
<td>
<p>The name of the dataset from mlbench. If missing then a list of
all available data sets is shown and returned.</p>
</td></tr>
<tr><td><code id="DSD_mlbenchData_+3A_loop">loop</code></td>
<td>
<p>logical; loop or not to loop over the
data frame.</p>
</td></tr>
<tr><td><code id="DSD_mlbenchData_+3A_random">random</code></td>
<td>
<p>logical; should the data be used a random order?</p>
</td></tr>
<tr><td><code id="DSD_mlbenchData_+3A_scale">scale</code></td>
<td>
<p>logical; apply scaling to the data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSD_mlbenchData</code> class is designed to be a wrapper class for data
from the mlbench package.
</p>
<p>All data is held in memory in either data frame or matrix form. It is served as a stream using the
<a href="#topic+DSD_Memory">DSD_Memory</a> class. The stream can be reset to position 1 using <code><a href="#topic+reset_stream">reset_stream()</a></code>.
</p>
<p>Call <code>DSD_mlbenchData</code> with a missing value for <code>data</code> to get a list of
all available data sets.
</p>


<h3>Value</h3>

<p>Returns a <code>DSD_mlbenchData</code> object which is also of class
<a href="#topic+DSD_Memory">DSD_Memory</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Matthew Bolanos
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSD_mlbenchData()

stream &lt;- DSD_mlbenchData("Shuttle")
stream

get_points(stream, n = 5)

plot(stream, n = 100)
</code></pre>

<hr>
<h2 id='DSD_mlbenchGenerator'>mlbench Data Stream Generator</h2><span id='topic+DSD_mlbenchGenerator'></span>

<h3>Description</h3>

<p>A data stream generator class that interfaces data generators found in
package <code>mlbench</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_mlbenchGenerator(method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_mlbenchGenerator_+3A_method">method</code></td>
<td>
<p>The name of the mlbench data generator. If missing then a list of
all available generators is shown and returned.</p>
</td></tr>
<tr><td><code id="DSD_mlbenchGenerator_+3A_...">...</code></td>
<td>
<p>Parameters for the mlbench data generator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSD_mlbenchGenerator</code> class is designed to be a wrapper class for
data created by data generators in the <code>mlbench</code> library.
</p>
<p>Call <code>DSD_mlbenchGenerator</code> with missing method to get a list of
available methods.
</p>


<h3>Value</h3>

<p>Returns a <code>DSD_mlbenchGenerator</code> object (subclass of
<a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>)
</p>


<h3>Author(s)</h3>

<p>John Forrest
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSD_mlbenchGenerator()

stream &lt;- DSD_mlbenchGenerator(method = "cassini")
stream

get_points(stream, n = 5)

plot(stream, n = 500)
</code></pre>

<hr>
<h2 id='DSD_NULL'>Placeholder for a DSD Stream</h2><span id='topic+DSD_NULL'></span>

<h3>Description</h3>

<p>Placeholder for a <a href="#topic+DSD">DSD</a>. <code>DSD_NULL</code> does not produce points and creates an error
for <code><a href="#topic+get_points">get_points()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_NULL()
</code></pre>


<h3>Value</h3>

<p>Returns a <code>DSD_NULL</code> object (subclass of <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullstream &lt;- DSD_NULL()
nullstream

## This will produce an error
## Not run: 
get_points(nullstream)
## End(Not run)
</code></pre>

<hr>
<h2 id='DSD_ReadDB'>Read a Data Stream from an open DB Query</h2><span id='topic+DSD_ReadDB'></span><span id='topic+close_stream.DSD_ReadDB'></span>

<h3>Description</h3>

<p>A DSD class that reads a data stream from an open DB result set from a
relational database with using R's data base interface (DBI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_ReadDB(
  result,
  k = NA,
  outofpoints = c("warn", "ignore", "stop"),
  description = NULL
)

## S3 method for class 'DSD_ReadDB'
close_stream(dsd, disconnect = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_ReadDB_+3A_result">result</code></td>
<td>
<p>An open DBI result set.</p>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_k">k</code></td>
<td>
<p>Number of true clusters, if known.</p>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_outofpoints">outofpoints</code></td>
<td>
<p>Action taken if less than <code>n</code> data points are
available. The default is to return the available data points with a warning. Other supported actions are:
</p>

<ul>
<li> <p><code>warn</code>: return the available points (maybe an empty data.frame) with a warning.
</p>
</li>
<li> <p><code>ignore</code>: silently return the available points.
</p>
</li>
<li> <p><code>stop</code>: stop with an error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_description">description</code></td>
<td>
<p>a character string describing the data.</p>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_dsd">dsd</code></td>
<td>
<p>a stream.</p>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_disconnect">disconnect</code></td>
<td>
<p>logical; disconnect from the database?</p>
</td></tr>
<tr><td><code id="DSD_ReadDB_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class provides a streaming interface for result sets from a data base
with via <a href="DBI.html#topic+DBI-package">DBI::DBI</a>. You need to connect to the data base and submit a SQL
query using <code><a href="DBI.html#topic+dbGetQuery">DBI::dbGetQuery()</a></code> to obtain a result set. Make sure that your
query only includes the columns that should be included in the stream
(including class and outlier marking columns).
</p>
<p><strong>Closing and resetting the stream</strong>
</p>
<p>Do not forget to clear the
result set and disconnect from the data base connection.
<code>close_stream()</code> clears the query result with <code><a href="DBI.html#topic+dbClearResult">DBI::dbClearResult()</a></code>
and the disconnects from the database with <code><a href="DBI.html#topic+dbDisconnect">DBI::dbDisconnect()</a></code>. Disconnecting
can be prevented by calling <code>close_stream()</code> with <code>disconnect = FALSE</code>.
</p>
<p><code><a href="#topic+reset_stream">reset_stream()</a></code> is not available for this type of stream.
</p>
<p><strong>Additional information</strong>
</p>
<p>If additional information is available (e.g., class information), then the SQL
statement needs to make sure that the columns have the appropriate name starting with <code>.</code>.
See Examples section below.
</p>


<h3>Value</h3>

<p>An object of class <code>DSD_ReadDB</code> (subclass of  <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="DBI.html#topic+dbGetQuery">DBI::dbGetQuery()</a></code>
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### create a data base with a table with 3 Gaussians
if(require("RSQLite")) {

library("RSQLite")
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

points &lt;- get_points(DSD_Gaussians(k = 3, d = 2), n = 110)
head(points)

dbWriteTable(con, "Gaussians", points)

### prepare a query result set. Make sure that the additional information
### column starts with .
res &lt;- dbSendQuery(con, "SELECT X1, X2, `.class` AS '.class' FROM Gaussians")
res

### create a stream interface to the result set
stream &lt;- DSD_ReadDB(res, k = 3)
stream

### get points
get_points(stream, n = 5)

plot(stream, n = 100)

### close stream clears the query and disconnects the database
close_stream(stream)
}
</code></pre>

<hr>
<h2 id='DSD_ReadStream'>Read a Data Stream from a File or a Connection</h2><span id='topic+DSD_ReadStream'></span><span id='topic+DSD_ReadCSV'></span><span id='topic+close_stream.DSD_ReadStream'></span><span id='topic+close_stream.DSD_ReadCSV'></span>

<h3>Description</h3>

<p>A DSD class that reads a data stream (text format) from a file or any R connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_ReadStream(
  file,
  k = NA,
  take = NULL,
  sep = ",",
  header = FALSE,
  skip = 0,
  col.names = NULL,
  colClasses = NA,
  outofpoints = c("warn", "ignore", "stop"),
  ...
)

DSD_ReadCSV(
  file,
  k = NA,
  take = NULL,
  sep = ",",
  header = FALSE,
  skip = 0,
  col.names = NULL,
  colClasses = NA,
  outofpoints = c("warn", "ignore", "stop"),
  ...
)

## S3 method for class 'DSD_ReadStream'
close_stream(dsd, ...)

## S3 method for class 'DSD_ReadCSV'
close_stream(dsd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_ReadStream_+3A_file">file</code></td>
<td>
<p>A file/URL or an open connection.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_k">k</code></td>
<td>
<p>Number of true clusters, if known.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_take">take</code></td>
<td>
<p>indices of columns to extract from the file.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_sep">sep</code></td>
<td>
<p>The character string that separates dimensions in data points in
the stream.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_header">header</code></td>
<td>
<p>Does the first line contain variable names?</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_skip">skip</code></td>
<td>
<p>the number of lines of the data file to skip before beginning to
read data.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_col.names">col.names</code></td>
<td>
<p>A vector of optional names for the variables. The default is to use <code>"V"</code> followed by the
column number. Additional information (e.g., class labels) need to have names starting with <code>.</code>.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_colclasses">colClasses</code></td>
<td>
<p>A vector of classes to be assumed for the columns passed
on to <code><a href="utils.html#topic+read.table">read.table()</a></code>.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_outofpoints">outofpoints</code></td>
<td>
<p>Action taken if less than <code>n</code> data points are
available. The default is to return the available data points with a warning. Other supported actions are:
</p>

<ul>
<li> <p><code>warn</code>: return the available points (maybe an empty data.frame) with a warning.
</p>
</li>
<li> <p><code>ignore</code>: silently return the available points.
</p>
</li>
<li> <p><code>stop</code>: stop with an error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_...">...</code></td>
<td>
<p>Further arguments are passed on to <code><a href="utils.html#topic+read.table">read.table()</a></code>.  This can
for example be used for encoding, quotes, etc.</p>
</td></tr>
<tr><td><code id="DSD_ReadStream_+3A_dsd">dsd</code></td>
<td>
<p>A object of class <code>DSD_ReadCSV</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DSD_ReadStream</code> uses <code><a href="base.html#topic+readLines">readLines()</a></code> and <code><a href="utils.html#topic+read.table">read.table()</a></code> to read data from an R
connection line-by-line and convert it into a data.frame.
The connection is responsible for maintaining where the stream
is currently being read from. In general, the connections will consist of
files stored on disk but have many other possibilities (see
<a href="base.html#topic+connection">connection</a>).
</p>
<p>The implementation tries to gracefully deal with slightly corrupted data by
dropping points with inconsistent reading and producing a warning. However,
this might not always be possible resulting in an error instead.
</p>
<p><strong>Column names</strong>
</p>
<p>If the file has column headers in the first line, then they can be used by setting <code>header = TRUE</code>.
Alternatively, column names can be set using <code>col.names</code> or a named vector for <code>take</code>. If no column
names are specified then default names will be created.
</p>
<p>Columns with names that start with <code>.</code> are considered information columns and are ignored by <code>DST</code>s.
See <code><a href="#topic+get_points">get_points()</a></code> for details.
</p>
<p>Other information columns are are used by various functions.
</p>
<p><strong>Reading the whole stream</strong>
By using <code>n = -1</code> in <code>get_points()</code>, the whole stream is returned.
</p>
<p><strong>Resetting and closing a stream</strong>
</p>
<p>The position in the file can be reset to the beginning or another position using
<code><a href="#topic+reset_stream">reset_stream()</a></code>. This fails of the underlying connection is not seekable (see <a href="base.html#topic+connection">connection</a>).
</p>
<p><code>DSD_ReadStream</code> maintains an open connection to the stream and needs to be closed
using <code><a href="#topic+close_stream">close_stream()</a></code>.
</p>
<p><code>DSD_ReadCSV</code> reads a stream from a comma-separated values file.
</p>


<h3>Value</h3>

<p>An object of class <code>DSD_ReadCSV</code> (subclass of <a href="#topic+DSD_R">DSD_R</a>, <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines()</a></code>, <code><a href="utils.html#topic+read.table">read.table()</a></code>.
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: creating data and writing it to disk
stream &lt;- DSD_Gaussians(k = 3, d = 2)
write_stream(stream, "data.txt", n = 100, info = TRUE, header = TRUE)
readLines("data.txt", n = 5)

# reading the same data back
stream2 &lt;- DSD_ReadStream("data.txt", header = TRUE)
stream2

# get points
get_points(stream2, n = 5)
plot(stream2, n = 20)

# clean up
close_stream(stream2)
file.remove("data.txt")

# Example 2:  Read part of the kddcup1999 data (take only cont. variables)
# col 42 is the class variable
file &lt;- system.file("examples", "kddcup10000.data.gz", package = "stream")
stream &lt;- DSD_ReadCSV(gzfile(file),
        take = c(1, 5, 6, 8:11, 13:20, 23:41, .class = 42), k = 7)
stream

get_points(stream, 5)

# plot 100 points (projected on the first two principal components)
plot(stream, n = 100, method = "pca")

close_stream(stream)
</code></pre>

<hr>
<h2 id='DSD_ScaleStream'>Deprecated DSD_ScaleStream</h2><span id='topic+DSD_ScaleStream'></span>

<h3>Description</h3>

<p>Deprecated! Use <a href="#topic+DSF_Scale">DSF_Scale</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_ScaleStream(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_ScaleStream_+3A_...">...</code></td>
<td>
<p>arguments are passed on to <code><a href="#topic+DSF_Scale">DSF_Scale()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a depreation warning and returns an object of class
<a href="#topic+DSF_Scale">DSF_Scale</a> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>

<hr>
<h2 id='DSD_Target'>Target Data Stream Generator</h2><span id='topic+DSD_Target'></span>

<h3>Description</h3>

<p>A data stream generator that generates a data stream in the shape of a
target. It has a single Gaussian cluster in the center and a ring that
surrounds it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_Target(
  center_sd = 0.05,
  center_weight = 0.5,
  ring_r = 0.2,
  ring_sd = 0.02,
  noise = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_Target_+3A_center_sd">center_sd</code></td>
<td>
<p>standard deviation of center</p>
</td></tr>
<tr><td><code id="DSD_Target_+3A_center_weight">center_weight</code></td>
<td>
<p>proportion of points in center</p>
</td></tr>
<tr><td><code id="DSD_Target_+3A_ring_r">ring_r</code></td>
<td>
<p>average ring radius</p>
</td></tr>
<tr><td><code id="DSD_Target_+3A_ring_sd">ring_sd</code></td>
<td>
<p>standard deviation of ring radius</p>
</td></tr>
<tr><td><code id="DSD_Target_+3A_noise">noise</code></td>
<td>
<p>proportion of noise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This DSD will produce a singular Gaussian cluster in the center with a ring around
it.
</p>


<h3>Value</h3>

<p>Returns a <code>DSD_Target</code> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data stream with three clusters in 2D
stream &lt;- DSD_Target()

get_points(stream, n = 5)

plot(stream)
</code></pre>

<hr>
<h2 id='DSD_UniformNoise'>Uniform Noise Data Stream Generator</h2><span id='topic+DSD_UniformNoise'></span>

<h3>Description</h3>

<p>This generator produces uniform noise in a d-dimensional unit (hyper) cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSD_UniformNoise(d = 2, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSD_UniformNoise_+3A_d">d</code></td>
<td>
<p>Determines the number of dimensions.</p>
</td></tr>
<tr><td><code id="DSD_UniformNoise_+3A_range">range</code></td>
<td>
<p>A matrix with two columns and <code>d</code> rows giving the minimum
and maximum for each dimension. Defaults to the range of <code class="reqn">[0,1]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>DSD_UniformNoise</code> object.(subclass of <code>DSD_R</code>,
<code>DSD</code>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data stream with three clusters in 2D
stream &lt;- DSD_UniformNoise(d = 2)
get_points(stream, n = 5)
plot(stream, n = 100)

# specify a different range for each dimension
stream &lt;- DSD_UniformNoise(d = 3,
  range = rbind(c(0, 1), c(0, 10), c(0, 5)))
plot(stream, n = 100)
</code></pre>

<hr>
<h2 id='DSF'>Data Stream Filter Base Classes</h2><span id='topic+DSF'></span><span id='topic+reset_stream.DSF'></span><span id='topic+get_points.DSF'></span><span id='topic+update.DSF'></span><span id='topic+close_stream.DSF'></span>

<h3>Description</h3>

<p>Abstract base classes for all data stream filter (DSF) classes.
Data stream filters transform a data stream (<a href="#topic+DSD">DSD</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF(...)

## S3 method for class 'DSF'
reset_stream(dsd, pos = 1)

## S3 method for class 'DSF'
get_points(x, n = 1L, info = TRUE, ...)

## S3 method for class 'DSF'
update(object, dsd = NULL, n = 1L, return = "data", ...)

## S3 method for class 'DSF'
close_stream(dsd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_+3A_...">...</code></td>
<td>
<p>Further arguments passed on.</p>
</td></tr>
<tr><td><code id="DSF_+3A_dsd">dsd</code></td>
<td>
<p>a stream object of class <a href="#topic+DSD">DSD</a>.</p>
</td></tr>
<tr><td><code id="DSF_+3A_pos">pos</code></td>
<td>
<p>position in the stream.</p>
</td></tr>
<tr><td><code id="DSF_+3A_x">x</code>, <code id="DSF_+3A_object">object</code></td>
<td>
<p>a <code>DSF</code> object.</p>
</td></tr>
<tr><td><code id="DSF_+3A_n">n</code></td>
<td>
<p>number of points to get/use for the update.</p>
</td></tr>
<tr><td><code id="DSF_+3A_info">info</code></td>
<td>
<p>return additional columns with information about the data point (e.g., a known cluster assignment).</p>
</td></tr>
<tr><td><code id="DSF_+3A_return">return</code></td>
<td>
<p>a character string indicating what update returns. The only
value is currently  <code>"data"</code> to return the transformed data.
possible values depend on the <code>DST</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DSF</code> class cannot be instantiated, but it serve as a base
class from which other DSF classes inherit.
</p>
<p>Data stream filters transform a <a href="#topic+DSD">DSD</a> data stream. <code>DSF</code> can be used in two ways.
</p>

<ol>
<li> <p><strong>DSD Adapter:</strong>
When a data stream (<code>dsd</code>) is specified in the constructor, then the DSF acts as an a
adapter for a connected data stream. The DSF implementations inherit the
interface from <a href="#topic+DSD">DSD</a> and provide:
</p>

<ul>
<li> <p><code><a href="#topic+get_points">get_points()</a></code> get the transformed points.
</p>
</li>
<li> <p><code><a href="#topic+reset_stream">reset_stream()</a></code> reset the underlying stream
</p>
</li>
<li> <p><code><a href="#topic+close_stream">close_stream()</a></code> close the underlying stream
</p>
</li></ul>

</li>
<li> <p><strong>Stream Transformer:</strong>
When no data stream (<code>dsd</code>) is specified in the constructor, then the DSF acts like a
<a href="#topic+DST">DST</a> data stream task and provides:
</p>

<ul>
<li> <p><code><a href="#topic+update">update()</a></code> to transform the points from a specified <code>DSD</code>.
It is convenient to use the pipe (<a href="magrittr.html#topic+pipe">magrittr::%&gt;%</a>) to apply one or more filters to data
streams (see Examples section).
</p>
</li></ul>

</li></ol>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>reset_stream(DSF)</code>: reset the attached stream if reset is supported.
</p>
</li>
<li> <p><code>get_points(DSF)</code>: DSD-like interface to get points if the DSF was created with an attached stream.
</p>
</li>
<li> <p><code>update(DSF)</code>: updates with data and returns the filtered data.
</p>
</li>
<li> <p><code>close_stream(DSF)</code>: close the attached stream if close is supported.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>
</p>
<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSF()

# Example 1: Use as a DSD adapter
stream &lt;- DSD_Gaussians(k = 3, d = 2) %&gt;%
  DSF_Func(func = function(x) cbind(x, Xsum = x$X1 + x$X2))
stream

get_points(stream, n = 5)

# Example 2: Use as a stream transformer
trans &lt;- DSF_Func(func = function(x) cbind(x, Xsum = x$X1 + x$X2))
trans

update(trans, stream, n = 5)

# Example 3: Use as a DST preprocessor
clusterer &lt;- DSF_Func(func = function(x) cbind(x, X1_squared = x$X1^2)) %&gt;%
               DST_Runner(DSC_Kmeans(k = 3))
clusterer

update(clusterer, stream, n = 100)

# Example 5: Specify a complete pipeline DSD -&gt; DSF -&gt; DST
pipeline &lt;- DSD_Gaussians(k = 3, d = 2) %&gt;%
               DSF_Func(func = function(x) cbind(x, X1_squared = x$X1^2)) %&gt;%
               DST_Runner(DSC_Kmeans(k = 3))
pipeline

update(pipeline, n = 100)
plot(pipeline$dst)
</code></pre>

<hr>
<h2 id='DSF_Convolve'>Apply a Filter to a Data Stream</h2><span id='topic+DSF_Convolve'></span><span id='topic+filter_MA'></span><span id='topic+filter_Hamming'></span><span id='topic+filter_diff'></span><span id='topic+filter_Sinc'></span><span id='topic+pow2'></span>

<h3>Description</h3>

<p>Applies a filter (i.e., a convolution with a filter kernel) to a data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_Convolve(
  dsd = NULL,
  dim = NULL,
  kernel = NULL,
  pre = NULL,
  post = NULL,
  na.rm = FALSE,
  replace = TRUE,
  name = NULL
)

filter_MA(width)

filter_Hamming(width)

filter_diff(lag)

filter_Sinc(fc, fs, width = NULL, bw = NULL)

pow2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_Convolve_+3A_dsd">dsd</code></td>
<td>
<p>A object of class <a href="#topic+DSD">DSD</a>.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_dim">dim</code></td>
<td>
<p>columns to which the filter should be applied. Default is all columns.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_kernel">kernel</code></td>
<td>
<p>filter kernel as a numeric vector of weights.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_pre">pre</code>, <code id="DSF_Convolve_+3A_post">post</code></td>
<td>
<p>functions to be applied before and after the convolution.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; should NAs be ignored?</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_replace">replace</code></td>
<td>
<p>logical; should the column be replaced or a column with the convolved column added?</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_name">name</code></td>
<td>
<p>character; the new column will be name with the old column name + <code style="white-space: pre;">&#8288;_&#8288;</code> + <code>name</code>.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_width">width</code></td>
<td>
<p>filter width.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_lag">lag</code></td>
<td>
<p>an integer indicating which time lag to use.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_fc">fc</code></td>
<td>
<p>cutoff frequency.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_fs">fs</code></td>
<td>
<p>sampling frequency.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_bw">bw</code></td>
<td>
<p>transition bandwidth.</p>
</td></tr>
<tr><td><code id="DSF_Convolve_+3A_x">x</code></td>
<td>
<p>values to be squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A filter kernel is a vector with kernel weights. A few filter are provided.
</p>

<ul>
<li> <p><code>filter_MA(width)</code> creates a moving average.
</p>
</li>
<li> <p><code>filter_diff(lag)</code> calculates laged differences. Note that <code>na.rm = TRUE</code> will lead to artifacts and should not be used.
</p>
</li>
<li> <p><code>filter_Hamming(width)</code> creates a Hamming window.
</p>
</li>
<li> <p><code>filter_Sinc(fc, fs, width, bw)</code> creates a windowed-sinc filter. One of <code>width</code> (filter length) or
<code>bw</code> (transition bandwidth can  be used to control the filter roll-off. The relationship is <code class="reqn">width = 4/bw</code>.
See Chapter 16 in Smith (1997).
</p>
</li></ul>

<p><code>pre</code> and <code>post</code> are functions that are called before and after the convolution. For example, to calculate
RMS, you can use <code>pre = pow2</code> and <code>post = sqrt</code>. <code>pow2()</code> is a convenience function.
</p>


<h3>Value</h3>

<p>An object of class <code>DSF_Convolve</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Steven W. Smith, The Scientist and Engineer's Guide to
Digital Signal Processing, California Technical Pub; 1st edition (January 1, 1997).
ISBN 0966017633, URL: https://www.dspguide.com/
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+filter">stats::filter</a> provides non-streaming convolution.
</p>
<p>Other DSF: 
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presidents)

## Example 1: Create a data stream with three copies of president approval ratings.
## We will use several convolutions.
stream &lt;- data.frame(
    approval_orig = presidents,
    approval_MA = presidents,
    approval_diff1 = presidents,
    .time = time(presidents)) %&gt;%
  DSD_Memory()

plot(stream, dim = 1, n = 120, method = "ts")

## apply a moving average filter to dimension 1 (using the column name) and diff to dimension 3
filteredStream &lt;- stream %&gt;%
  DSF_Convolve(kernel = filter_MA(5), dim = "approval_orig", na.rm = TRUE) %&gt;%
  DSF_Convolve(kernel = filter_diff(1), dim = 3)
filteredStream

## resetting the filtered stream also resets the original stream
reset_stream(filteredStream)
ps &lt;- get_points(filteredStream, n = 120)
head(ps)

year &lt;- ps[[".time"]]
approval &lt;- remove_info(ps)
matplot(year, approval, type = "l", ylim = c(-20, 100))
legend("topright", colnames(approval), col = 1:3, lty = 1:3, bty = "n")

## Example 2: Create a stream with a constant sine wave and apply
## a moving average, an RMS envelope and a differences
stream &lt;- DSD_Memory(data.frame(y = sin(seq(0, 2 * pi - (2 * pi / 100) ,
  length.out = 100))), loop = TRUE)
plot(stream, n = 200, method = "ts")

filteredStream &lt;- stream %&gt;%
  DSF_Convolve(kernel = filter_MA(100), dim = 1,
    replace = FALSE, name = "MA") %&gt;%
  DSF_Convolve(kernel = filter_MA(100), pre = pow2, post = sqrt, dim = 1,
    replace = FALSE, name = "RMS") %&gt;%
  DSF_Convolve(kernel = filter_diff(1), dim = 1,
    replace = FALSE, name = "diff1")
filteredStream

ps &lt;- get_points(filteredStream, n = 500)
head(ps)

matplot(ps, type = "l")
legend("topright", colnames(ps), col = 1:4, lty = 1:4)

## Note that MA and RMS use a window of length 200 and are missing at the
##   beginning of the stream the window is full.

## Filters: look at different filters
filter_MA(5)
filter_diff(1)
plot(filter_Hamming(20), type = "h")
plot(filter_Sinc(10, 100, width = 20), type = "h")
</code></pre>

<hr>
<h2 id='DSF_Downsample'>Downsample a Data Stream</h2><span id='topic+DSF_Downsample'></span>

<h3>Description</h3>

<p>Creates a new stream that reduces the frequency of a given stream by a given factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_Downsample(dsd = NULL, factor = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_Downsample_+3A_dsd">dsd</code></td>
<td>
<p>The input stream as an <a href="#topic+DSD">DSD</a> object.</p>
</td></tr>
<tr><td><code id="DSF_Downsample_+3A_factor">factor</code></td>
<td>
<p>the downsampling factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>DSF_Downsample</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple downsampling example
stream &lt;- DSD_Memory(data.frame(rownum = seq(100))) %&gt;% DSF_Downsample(factor = 10)
stream

get_points(stream, n = 2)
get_points(stream, n = 1)
get_points(stream, n = 5)

# DSD_Memory supports getting the remaining points using n = -1
get_points(stream, n = -1)

# Downsample a time series
data(presidents)

stream &lt;- data.frame(
    presidents,
    .time = time(presidents)) %&gt;%
  DSD_Memory()

plot(stream, dim = 1, n = 120, method = "ts")

# downsample by taking only every 3rd data point (quarters)
downsampledStream &lt;- stream %&gt;% DSF_Downsample(factor = 3)

reset_stream(downsampledStream)
plot(downsampledStream, dim = 1, n = 40, method = "ts")
</code></pre>

<hr>
<h2 id='DSF_dplyr'>Apply a dplyr Transformation to a Data Stream</h2><span id='topic+DSF_dplyr'></span>

<h3>Description</h3>

<p>Applies dplyr transformations to a data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_dplyr(dsd = NULL, func = NULL, info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_dplyr_+3A_dsd">dsd</code></td>
<td>
<p>A object of class <a href="#topic+DSD">DSD</a>.</p>
</td></tr>
<tr><td><code id="DSF_dplyr_+3A_func">func</code></td>
<td>
<p>a dplyr expression.</p>
</td></tr>
<tr><td><code id="DSF_dplyr_+3A_info">info</code></td>
<td>
<p>logical; does the function also receive and modify the info columns?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">dplyr</span> needs to be installed and loaded with <code>library(dplyr)</code> before <code>DSF_dplyr</code> can be used.
</p>
<p>Since streams are processed one point or block at a time, only <a href="dplyr.html#topic+dplyr-package">dplyr::dplyr</a> operations that work on individual
rows are allowed on streams. Examples are:
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+select">dplyr::select()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+mutate">dplyr::transmute()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>
</p>
</li></ul>

<p>Summary functions can be used, but will only be applied to the requested part of the stream of length <code>n</code>.
</p>
<p><code>DSF_dplyr()</code> calls the function using <code style="white-space: pre;">&#8288;points %&gt;% &lt;func&gt;&#8288;</code> and multiple <code>dplyr</code> functions can be applied by
using <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> between them.
</p>


<h3>Value</h3>

<p>An object of class <code>DSF_dplyr</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(dplyr)) {

library(dplyr)

stream &lt;- DSD_Gaussians(k = 3, d = 3)
plot(stream, xlim = c(0, 1), ylim = c(0, 1))

# 1. Select only columns X1 and X2
# 2. filter points by X1 &gt; .5 (Note that the info columns also need to be filtered!)
# 3. Add a sum columns

stream2 &lt;- stream %&gt;%
  DSF_dplyr(select(X1, X2)) %&gt;%
  DSF_dplyr(filter(X1 &gt; .5), info = TRUE) %&gt;%
  DSF_dplyr(mutate(Xsum = X1 + X2))
stream2

# Note: you get fewer points because of the filter operation.
get_points(stream2, n = 10)
plot(stream2, xlim = c(0, 1), ylim = c(0, 1))

}
</code></pre>

<hr>
<h2 id='DSF_ExponentialMA'>Exponential Moving Average over a Data Stream</h2><span id='topic+DSF_ExponentialMA'></span>

<h3>Description</h3>

<p>Applies an exponential moving average to components of a data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_ExponentialMA(dsd = NULL, dim = NULL, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_ExponentialMA_+3A_dsd">dsd</code></td>
<td>
<p>The input stream as an <a href="#topic+DSD">DSD</a> object.</p>
</td></tr>
<tr><td><code id="DSF_ExponentialMA_+3A_dim">dim</code></td>
<td>
<p>columns to which the filter should be applied. Default is all columns.</p>
</td></tr>
<tr><td><code id="DSF_ExponentialMA_+3A_alpha">alpha</code></td>
<td>
<p>smoothing coefficient in <code class="reqn">[0, 1]</code>. Larger means discounting older observations faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential moving average is calculated by:
</p>
<p><code class="reqn">S_t = \alpha Y_t + (1 - \alpha)\; S_{i-1}</code>
</p>
<p>with <code class="reqn">S_0 = Y_0</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>DSF_ExponentialMA</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Smooth a time series
data(presidents)

stream &lt;- data.frame(
    presidents,
    .time = time(presidents)) %&gt;%
  DSD_Memory()

plot(stream, dim = 1, n = 120, method = "ts", main = "Original")

smoothStream &lt;- stream %&gt;% DSF_ExponentialMA(alpha = .7)
smoothStream

reset_stream(smoothStream)
plot(smoothStream, dim = 1, n = 120, method = "ts", main = "With ExponentialMA(.7)")
</code></pre>

<hr>
<h2 id='DSF_Func'>Apply a Function to Transformation to a Data Stream</h2><span id='topic+DSF_Func'></span>

<h3>Description</h3>

<p>Applies an R function to transform to a data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_Func(dsd = NULL, func, ..., info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_Func_+3A_dsd">dsd</code></td>
<td>
<p>A object of class <a href="#topic+DSD">DSD</a>.</p>
</td></tr>
<tr><td><code id="DSF_Func_+3A_func">func</code></td>
<td>
<p>a function that takes a data.frame as the first argument and returns the transformed data.frame.</p>
</td></tr>
<tr><td><code id="DSF_Func_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the function specified in <code>func</code>.</p>
</td></tr>
<tr><td><code id="DSF_Func_+3A_info">info</code></td>
<td>
<p>logical; does the function also receive and modify the info columns?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function's first argument needs to be a data.frame representing points of the
data stream. The function will be called as <code>ps %&gt;% your_function()</code>, where <code>ps</code> is the
data.frame with some points obtained using <code><a href="#topic+get_points">get_points()</a></code> on the data stream source.
</p>


<h3>Value</h3>

<p>An object of class <code>DSF_Func</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Scale">DSF_Scale</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 3)
get_points(stream, n = 5)

## Example 1: rename the columns
rename &lt;- function(x, names) {
  colnames(x) &lt;-  names
  x
}

# By default, the info columns starting with . are not affected.
stream2 &lt;- stream %&gt;% DSF_Func(rename, names = c("A", "B", "C"))
stream2
get_points(stream2, n = 5)

## Example 2: add a sum columns
stream3 &lt;- stream2 %&gt;% DSF_Func(function(x) {
  x$sum = rowSums(x)
  x
})
stream3
get_points(stream3, n = 5)

## Example 3: Project the stream on its first 2 PCs (using a sample)
pr &lt;- princomp(get_points(stream, n = 100, info = FALSE))
pca_trans &lt;- function(x) predict(pr, x[, c("X1", "X2", "X3")])[, 1:2 , drop = FALSE]
pca_trans(get_points(stream, n = 3, info = FALSE))

stream4 &lt;- stream %&gt;% DSF_Func(pca_trans)
stream4

get_points(stream4, n = 3)
plot(stream4)

## Example 4: Change a class labels using info = TRUE. We redefine class 3 as noise (NA)
stream5 &lt;- stream %&gt;% DSF_Func(
  function(x) { x[['.class']][x[['.class']] == 3] &lt;- NA; x },
  info = TRUE)
stream5

get_points(stream5, n = 5)
plot(stream5)
</code></pre>

<hr>
<h2 id='DSF_Scale'>Scale a Data Stream</h2><span id='topic+DSF_Scale'></span>

<h3>Description</h3>

<p>Make an unscaled data stream into a scaled data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSF_Scale(dsd = NULL, dim = NULL, center = TRUE, scale = TRUE, n = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSF_Scale_+3A_dsd">dsd</code></td>
<td>
<p>A object of class <a href="#topic+DSD">DSD</a> that will be scaled.</p>
</td></tr>
<tr><td><code id="DSF_Scale_+3A_dim">dim</code></td>
<td>
<p>integer vector or names of dimensions that should be scaled? Default is all.</p>
</td></tr>
<tr><td><code id="DSF_Scale_+3A_center">center</code>, <code id="DSF_Scale_+3A_scale">scale</code></td>
<td>
<p>logical or a numeric vector of length equal to the
number of columns (selected with dim) used for centering/scaling (see function <a href="base.html#topic+scale">scale</a>).</p>
</td></tr>
<tr><td><code id="DSF_Scale_+3A_n">n</code></td>
<td>
<p>The number of points used by <code>scale_stream()</code> to creating the centering/scaling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>center</code> and <code>scale</code> are not vectors with scaling factors, then <code>scale_stream()</code>
estimates the values for centering and scaling (see
<a href="base.html#topic+scale">scale</a> in <span class="pkg">base</span>) using <code>n</code> points from the stream and the stream is reset if <code>reset = TRUE</code> and the
<a href="#topic+DSD">DSD</a> object supports resetting.
</p>


<h3>Value</h3>

<p>An object of class <code>DSF_Scale</code> (subclass of <a href="#topic+DSF">DSF</a> and <a href="#topic+DSD">DSD</a>).
</p>


<h3>Deprecated</h3>

<p><code>DSD_ScaleStream</code> is deprecated. Use <code>DSF_Scale</code> instead.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+scale">scale</a> in <span class="pkg">base</span>
</p>
<p>Other DSF: 
<code><a href="#topic+DSF_Convolve">DSF_Convolve</a>()</code>,
<code><a href="#topic+DSF_Downsample">DSF_Downsample</a>()</code>,
<code><a href="#topic+DSF_ExponentialMA">DSF_ExponentialMA</a>()</code>,
<code><a href="#topic+DSF_Func">DSF_Func</a>()</code>,
<code><a href="#topic+DSF_dplyr">DSF_dplyr</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2)
get_points(stream, 3)

# scale with manually calculated scaling factors
points &lt;- get_points(stream, n = 100, info = FALSE)
center &lt;- colMeans(points)
scale &lt;- apply(points, MARGIN = 2, sd)

scaledStream &lt;- stream %&gt;%  DSF_Scale(dim = c(1L, 2L), center = center, scale = scale)
colMeans(get_points(scaledStream, n = 100, info = FALSE))
apply(get_points(scaledStream, n = 100, info = FALSE), MARGIN = 2, sd)

# let DSF_Scale calculate the scaling factors from the first n points of the stream
scaledStream &lt;- stream %&gt;% DSF_Scale(dim = c(1L, 2L), n = 100)
colMeans(get_points(scaledStream, n = 100, info = FALSE))
apply(get_points(scaledStream, n = 100, info = FALSE), MARGIN = 2, sd)

## scale only X2
scaledStream &lt;- stream %&gt;% DSF_Scale(dim = "X2", n = 100)
colMeans(get_points(scaledStream, n = 100, info = FALSE))
apply(get_points(scaledStream, n = 100, info = FALSE), MARGIN = 2, sd)
</code></pre>

<hr>
<h2 id='DSFP'>Abstract Class for Frequent Pattern Mining Algorithms for Data Streams</h2><span id='topic+DSFP'></span>

<h3>Description</h3>

<p>Abstract class for frequent pattern mining algorithms for data streams.
Currently, <span class="pkg">stream</span> does not implement frequent pattern mining
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSFP(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSFP_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><a href="#topic+DST">DST</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSFP()
</code></pre>

<hr>
<h2 id='DSOutlier'>Abstract Class for Data Stream Outlier Detectors</h2><span id='topic+DSOutlier'></span>

<h3>Description</h3>

<p>The abstract class for all data stream outlier detectors. Cannot be
instantiated. Some <a href="#topic+DSC">DSC</a> implementations also implement outlier/noise
detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSOutlier(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSOutlier_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+plot">plot()</a></code> has an extra logical argument to specify if outliers should be plotted
as red crosses.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSOutlier: 
<code><a href="#topic+DSC_DBSTREAM">DSC_DBSTREAM</a>()</code>,
<code><a href="#topic+DSC_DStream">DSC_DStream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSOutlier()

#' @examples
set.seed(1000)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = 0.1, noise_separation = 5)

outlier_detector &lt;- DSOutlier_DBSTREAM(r = .05, outlier_multiplier = 2)
update(outlier_detector, stream, 500)
outlier_detector

points &lt;- get_points(stream, 20)
points

# Outliers are predicted as class NA
predict(outlier_detector, points)

# Plot new points from the stream. Predicted outliers are marked with a red x.
plot(outlier_detector, stream)

evaluate_static(outlier_detector, stream, measure =
  c("noiseActual", "noisePredicted", "noisePrecision", "outlierJaccard"))

# use a different detector
outlier_detector2 &lt;- DSOutlier_DStream(gridsize = .05, Cl = 0.5, outlier_multiplier = 2)
update(outlier_detector2, stream, 500)
plot(outlier_detector2, stream)

evaluate_static(outlier_detector2, stream, measure =
  c("noiseActual", "noisePredicted", "noisePrecision", "outlierJaccard"))
</code></pre>

<hr>
<h2 id='DSRegressor'>Abstract Class for Data Stream Regressors</h2><span id='topic+DSRegressor'></span>

<h3>Description</h3>

<p>Abstract class for data stream regressors. More implementations can be found in
package <span class="pkg">streamMOA</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSRegressor(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSRegressor_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSRegressor: 
<code><a href="#topic+DSRegressor_SlidingWindow">DSRegressor_SlidingWindow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSClassifier()
</code></pre>

<hr>
<h2 id='DSRegressor_SlidingWindow'>DSRegressor_SlidingWindow &ndash; Data Stream Regressor Using a Sliding Window</h2><span id='topic+DSRegressor_SlidingWindow'></span>

<h3>Description</h3>

<p>The Regressor keeps a sliding window for the stream and rebuilds a regression model at regular
intervals. By default is builds a decision tree using <code><a href="stats.html#topic+lm">lm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSRegressor_SlidingWindow(formula, model = stats::lm, window, rebuild, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSRegressor_SlidingWindow_+3A_formula">formula</code></td>
<td>
<p>a formula for the classification problem.</p>
</td></tr>
<tr><td><code id="DSRegressor_SlidingWindow_+3A_model">model</code></td>
<td>
<p>regression model (that has a formula interface).</p>
</td></tr>
<tr><td><code id="DSRegressor_SlidingWindow_+3A_window">window</code></td>
<td>
<p>size of the sliding window.</p>
</td></tr>
<tr><td><code id="DSRegressor_SlidingWindow_+3A_rebuild">rebuild</code></td>
<td>
<p>interval (number of points) for rebuilding the regression. Set rebuild to
<code>Inf</code> to prevent automatic rebuilding. Rebuilding can be initiated manually when
calling <code>update()</code>.</p>
</td></tr>
<tr><td><code id="DSRegressor_SlidingWindow_+3A_...">...</code></td>
<td>
<p>additional parameters are passed on to the regressor (default is <code>lm()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructor creates a regressor based on <code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a></code>. The regressor has
a <code>update()</code> and <code>predict()</code> method.
</p>


<h3>Value</h3>

<p>An object of class <code>DST_SlidingWindow</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSRegressor: 
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stream)

# create a data stream for the iris dataset
data &lt;- iris[sample(nrow(iris)), ]
stream &lt;- DSD_Memory(data)

# define the stream Regressor.
cl &lt;- DSRegressor_SlidingWindow(
  Sepal.Length ~ Petal.Length + Petal.Length,
  window = 50,
  rebuild = 10
  )
cl

# update the regressor with 100 points from the stream
update(cl, stream, 100)

# predict the class for the next 50 points
newdata &lt;- get_points(stream, n = 50)
pr &lt;- predict(cl, newdata)
pr

plot(pr, newdata$Sepal.Length)
abline(0, 1, col = "red")

# get the tree model
get_model(cl)
</code></pre>

<hr>
<h2 id='DST'>Conceptual Base Class for All Data Stream Mining Tasks</h2><span id='topic+DST'></span><span id='topic+description'></span><span id='topic+get_model'></span>

<h3>Description</h3>

<p>Conceptual base class for all data stream mining tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DST(...)

description(x, ...)

get_model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DST_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="DST_+3A_x">x</code></td>
<td>
<p>an object of a concrete implementation of a DST.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Base class for data stream mining tasks. Types of <code>DST</code> are
</p>

<ul>
<li> <p><a href="#topic+DSAggregate">DSAggregate</a> to aggregate data streams (e.g., with a sliding window).
</p>
</li>
<li> <p><a href="#topic+DSC">DSC</a> for data stream clustering.
</p>
</li>
<li> <p><a href="#topic+DSClassifier">DSClassifier</a> classification for data streams.
</p>
</li>
<li> <p><a href="#topic+DSRegressor">DSRegressor</a> regression for data streams.
</p>
</li>
<li> <p><a href="#topic+DSOutlier">DSOutlier</a> outlier detection for data streams.
</p>
</li>
<li> <p><a href="#topic+DSFP">DSFP</a> frequent pattern mining for data streams.
</p>
</li></ul>

<p>The common interface for all <a href="#topic+DST">DST</a> classes consists of
</p>

<ul>
<li> <p><code><a href="#topic+update">update()</a></code> update the DST with data points.
</p>
</li>
<li><p> description() a string describing the DST.
</p>
</li>
<li><p> get_model() returns the DST's current model (often as a data.frame or a R model object).
</p>
</li>
<li> <p><code><a href="#topic+predict">predict()</a></code> use the learned DST model to make predictions.
</p>
</li></ul>

<p>and the methods in the Methods Section below.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DST()
</code></pre>

<hr>
<h2 id='DST_Multi'>Apply Multiple Task to the Same Data Stream</h2><span id='topic+DST_Multi'></span>

<h3>Description</h3>

<p>Apply multiple task (<a href="#topic+DST">DST</a>) to the same data stream. The tasks can be accessed
as a list as <code style="white-space: pre;">&#8288;$dsts&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DST_Multi(dsts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DST_Multi_+3A_dsts">dsts</code></td>
<td>
<p>a list of <a href="#topic+DST">DST</a> objects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)

stream &lt;- DSD_Gaussians(k = 3, d = 2)

## define multiple tasks as a list
tasks &lt;- DST_Multi(list(
   DSAggregate_Window(horizon = 10),
   DSC_DStream(gridsize = 0.1)
))
tasks

## update both tasks with the same stream
update(tasks, stream, n = 1000)

## inspect the results of the tasks
tasks$dsts[[1]]
get_model(tasks$dsts[[1]])

tasks$dsts[[2]]
plot(tasks$dsts[[2]])
</code></pre>

<hr>
<h2 id='DST_SlidingWindow'>DST_SlidingWindow &ndash; Call R Functions on a Sliding Window</h2><span id='topic+DST_SlidingWindow'></span><span id='topic+update.DST_SlidingWindow'></span><span id='topic+predict.DST_SlidingWindow'></span>

<h3>Description</h3>

<p>Keeps a sliding window of the data stream an calls a function at regular
intervals with the contents of the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DST_SlidingWindow(f, window, rebuild, ...)

## S3 method for class 'DST_SlidingWindow'
update(
  object,
  dsd,
  n = 1L,
  return = c("nothing", "model"),
  rebuild = FALSE,
  ...
)

## S3 method for class 'DST_SlidingWindow'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DST_SlidingWindow_+3A_f">f</code></td>
<td>
<p>the function to be called.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_window">window</code></td>
<td>
<p>size of the sliding window.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_rebuild">rebuild</code></td>
<td>
<p>logical; perform a rebuild after the update.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to the <code>predict()</code> function of the underlying model.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_object">object</code></td>
<td>
<p>the updated <code>DST_SlidingWindow</code> object.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_dsd">dsd</code></td>
<td>
<p>A <a href="#topic+DSD">DSD</a> object with the data stream.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_n">n</code></td>
<td>
<p>number of points from <code>dsd</code> to use for the update.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_return">return</code></td>
<td>
<p>a character string indicating what update returns. The default is <code>"nothing"</code>
and <code>"model"</code> returns the aggregated data.</p>
</td></tr>
<tr><td><code id="DST_SlidingWindow_+3A_newdata">newdata</code></td>
<td>
<p>dataframe with the new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keeps a sliding window of the data stream an calls a function at regular
intervals with the contents of the window.
The function needs to have the form
</p>
<p><code>f &lt;- function(data, ...) {...}</code>
</p>
<p>where <code>data</code> is the data.frame
with the points in the sliding window (See <code>get_points()</code> in <a href="#topic+DSAggregate_Window">DSAggregate_Window</a>). The
function will be executed at regular intervals after <code>update()</code> was called with fixed
number of points. <code>update(..., rebuild = TRUE)</code> can be used to force recomputing the function.
This can be used with <code>n = 0</code> to recompute it even without adding more points.
The last valid function result can be retrieved/
</p>
<p>Many modelling functions provide a formula interface which lets them be directly used
inside a <code>DST_SlidingWindow</code> (see Examples section).
</p>
<p>If the function returns a model that supports <code>predict()</code>, then predict can directly be
called on the <code>DST_SlidingWindow</code> object.
</p>


<h3>Value</h3>

<p>An object of class <code>DST_SlidingWindow</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stream)

# create a data stream for the iris dataset
data &lt;- iris[sample(nrow(iris)), ]
stream &lt;- DSD_Memory(data)
stream

## Example 1: Use a function on the sliding window
summarizer &lt;- function(data) summary(data)

s &lt;- DST_SlidingWindow(summarizer,
  window = 100, rebuild = 50)
s

# update window with 49 points. The function is not yet called
update(s, stream, 49)
get_model(s)

# updating with the 50th point will trigger a function call (see rebuild parameter)
# note that the window is only 1/2 full and we have 50 NAs
update(s, stream, 1)
get_model(s)

# 50 more points and the function will be recomputed
update(s, stream, 50)
get_model(s)


## Example 2: Use classifier on the sliding window
reset_stream(stream)

# rpart, like most models in R, already have a formula interface that uses a
# data parameter. We can use these types of models directly
library(rpart)
cl &lt;- DST_SlidingWindow(
  rpart, formula = Species ~ Petal.Length + Petal.Width,
  window = 100, rebuild = 50)
cl

# update window with 50 points so the model is built
update(cl, stream, 50)
get_model(cl)

# update with 40 more points and force the function to be recomputed even though it would take
#  50 points to automatically rebuild.
update(cl, stream, 40, rebuild = TRUE)
get_model(cl)

# rpart supports predict, so we can use it directly with the DST_SlidingWindow
new_points &lt;- get_points(stream, n = 5)
predict(cl, new_points, type = "class")

## Example 3: Regression using a sliding window
reset_stream(stream)

## lm can be directly used
reg &lt;- DST_SlidingWindow(
  lm, formula = Sepal.Length ~ Petal.Width + Petal.Length,
  window = 100, rebuild = 50)
reg

update(reg, stream, 100)
get_model(reg)

# lm supports predict, so we can use it directly with the DST_SlidingWindow
new_points &lt;- get_points(stream, n = 5)
predict(reg, new_points)
</code></pre>

<hr>
<h2 id='DST_WriteStream'>Task to Write a Stream to a File or a Connection</h2><span id='topic+DST_WriteStream'></span><span id='topic+close_stream.DST_WriteStream'></span>

<h3>Description</h3>

<p>Writes points from a data stream DSD object to a file or a connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DST_WriteStream(file, append = FALSE, ...)

## S3 method for class 'DST_WriteStream'
close_stream(dsd, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DST_WriteStream_+3A_file">file</code></td>
<td>
<p>A file name or a R connection to be written to.</p>
</td></tr>
<tr><td><code id="DST_WriteStream_+3A_append">append</code></td>
<td>
<p>Append the data to an existing file.</p>
</td></tr>
<tr><td><code id="DST_WriteStream_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to <code><a href="#topic+write_stream">write_stream()</a></code>. Note that <code>close</code> is
always <code>FALSE</code> and cannot be specified.</p>
</td></tr>
<tr><td><code id="DST_WriteStream_+3A_dsd">dsd</code></td>
<td>
<p>a <code>DSD_WriteStream</code> object with an open connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> <code>header = TRUE</code> is not supported for files. The header would be
added for every call for update.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)

stream &lt;- DSD_Gaussians(k = 3, d = 2)
writer &lt;- DST_WriteStream(file = "data.txt", info = TRUE)

update(writer, stream, n = 2)
readLines("data.txt")
update(writer, stream, n = 3)
readLines("data.txt")

# clean up
close_stream(writer)

file.remove("data.txt")
</code></pre>

<hr>
<h2 id='evaluate'>Evaluate a Data Stream Mining Task</h2><span id='topic+evaluate'></span><span id='topic+evaluate_static'></span><span id='topic+evaluate_stream'></span>

<h3>Description</h3>

<p>Generic function to calculate evaluation measures for a data stream mining task <a href="#topic+DST">DST</a> on
a data stream <a href="#topic+DSD">DSD</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_static(object, dsd, measure, n, ...)

evaluate_stream(object, dsd, measure, n, horizon, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+DST">DST</a> object that the evaluation measure is being requested
from.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_dsd">dsd</code></td>
<td>
<p>The <a href="#topic+DSD">DSD</a> object used to create the test data.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_measure">measure</code></td>
<td>
<p>Evaluation measure(s) to use. If missing then all available
measures are returned.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_n">n</code></td>
<td>
<p>The number of data points being requested.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>
<p>Further arguments are passed on to the specific implementation (e.g., see <a href="#topic+evaluate.DSC">evaluate.DSC</a>)</p>
</td></tr>
<tr><td><code id="evaluate_+3A_horizon">horizon</code></td>
<td>
<p>Evaluation is done using horizon many previous points (see
detail section).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_verbose">verbose</code></td>
<td>
<p>Report progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We define two generic evaluation functions:
</p>

<ul>
<li> <p><code>evaluate_static()</code> evaluates the current <a href="#topic+DST">DST</a> model on new data without updating the model.
</p>
</li>
<li> <p><code>evaluate_stream()</code> evaluates the <a href="#topic+DST">DST</a> model using
<em>prequential error estimation</em> (see Gama, Sebastiao and Rodrigues; 2013). The data points
in the horizon are first used to calculate the evaluation measure and then
they are used for updating the cluster model. A horizon of ' means that each point is evaluated and
then used to update the model.
</p>
</li></ul>

<p>The available evaluation measures depend on the task. Currently available task to evaluate:
</p>

<ul>
<li> <p><a href="#topic+DSC">DSC</a> via <a href="#topic+evaluate.DSC">evaluate.DSC</a>
</p>
</li></ul>



<h3>Value</h3>

<p><code>evaluate</code> returns an object of class <code>stream_eval</code> which
is a numeric vector of the values of the requested measures.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Joao Gama, Raquel Sebastiao, Pedro Pereira Rodrigues (2013). On
evaluating stream learning algorithms. <em>Machine Learning,</em> March 2013,
Volume 90, Issue 3, pp 317-346.
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other evaluation: 
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>
</p>

<hr>
<h2 id='evaluate.DSC'>Evaluate a Stream Clustering Task</h2><span id='topic+evaluate.DSC'></span><span id='topic+evaluate_static.DSC'></span><span id='topic+evaluate_stream.DSC'></span>

<h3>Description</h3>

<p>Methods for the generic functions <code><a href="#topic+evaluate_static">evaluate_static()</a></code> and <code><a href="#topic+evaluate_stream">evaluate_stream()</a></code>  to calculate evaluation measures for micro or macro-clusters created by a <a href="#topic+DSC">DSC</a> on the
a <a href="#topic+DSD">DSD</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DSC'
evaluate_static(
  object,
  dsd,
  measure,
  n = 100,
  type = c("auto", "micro", "macro"),
  assign = "micro",
  assignmentMethod = c("auto", "model", "nn"),
  excludeNoise = FALSE,
  callbacks = list(),
  ...
)

## S3 method for class 'DSC'
evaluate_stream(
  object,
  dsd,
  measure,
  n = 1000,
  horizon = 100,
  type = c("auto", "micro", "macro"),
  assign = "micro",
  assignmentMethod = c("auto", "model", "nn"),
  excludeNoise = FALSE,
  callbacks = NULL,
  ...,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.DSC_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+DSC">DSC</a> object that the evaluation measure is being requested
from.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_dsd">dsd</code></td>
<td>
<p>The <a href="#topic+DSD">DSD</a> object that holds the initial training data for the DSC.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_measure">measure</code></td>
<td>
<p>Evaluation measure(s) to use. If missing then all available
measures are returned.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_n">n</code></td>
<td>
<p>The number of data points being requested.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_type">type</code></td>
<td>
<p>Use micro- or macro-clusters for evaluation. Auto used the class
of <a href="#topic+DSC">DSC</a> to decide.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_assign">assign</code></td>
<td>
<p>Assign points to micro or macro-clusters?</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_assignmentmethod">assignmentMethod</code></td>
<td>
<p>How are points assigned to clusters for evaluation
(see <code><a href="#topic+predict">predict()</a></code>)?</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_excludenoise">excludeNoise</code></td>
<td>
<p>logical; Should noise points in the data stream be excluded from
the calculation?</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_callbacks">callbacks</code></td>
<td>
<p>A named list of functions to calculate custom evaluation measures.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_...">...</code></td>
<td>
<p>Unused arguments are ignored.</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_horizon">horizon</code></td>
<td>
<p>Evaluation is done using horizon many previous points (see
detail section).</p>
</td></tr>
<tr><td><code id="evaluate.DSC_+3A_verbose">verbose</code></td>
<td>
<p>logical; Report progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For evaluation, each data point is assigned to its nearest cluster using
Euclidean distance to the cluster centers. Then for each cluster the
majority class is determined. Based on the majority class several evaluation
measures can be computed.
</p>
<p>We provide two evaluation methods:
</p>

<ul>
<li> <p><code>evaluate_static()</code> evaluates the current static clustering using new data without updating the model.
</p>
</li>
<li> <p><code>evaluate_stream()</code> evaluates the clustering process using
<em>prequential error estimation</em> (see Gama, Sebastiao and Rodrigues; 2013).  The current model is
first applied to the data points in the horizon to calculate the evaluation measures. Then, the
cluster model is updated with the points.
</p>
</li></ul>

<p><strong>Evaluation Measures</strong>
</p>
<p>Many evaluation measures are available using
code from other packages including <code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>,
<code><a href="clue.html#topic+cl_agreement">clue:: cl_agreement()</a></code>, and <code><a href="fpc.html#topic+cluster.stats">fpc::cluster.stats()</a></code>.
</p>
<p>The following information items are available:
</p>

<ul>
<li> <p><code>"numPoints"</code> number of points used for evaluation.
</p>
</li>
<li> <p><code>"numMicroClusters"</code> number of micro-clusters
</p>
</li>
<li> <p><code>"numMacroClusters"</code> number of macro-clusters
</p>
</li>
<li> <p><code>"numClasses"</code> number of classes
</p>
</li></ul>

<p>The following noise-related/outlier items are available:
</p>

<ul>
<li> <p><code>"noisePredicted"</code> Number data points predicted as noise
</p>
</li>
<li> <p><code>"noiseActual"</code> Number of data points which are actually noise
</p>
</li>
<li> <p><code>"noisePrecision"</code> Precision of the predicting noise (i.e., number of
correctly predicted noise points over the total number of points predicted
as noise)
</p>
</li>
<li> <p><code>"outlierJaccard"</code> - A variant of the Jaccard index used to assess
outlier detection accuracy (see Krleza et al (2020)).  Outlier Jaccard index
is calculated as <code>TP / (TP + FP + UNDETECTED)</code>.
</p>
</li></ul>

<p>The following internal evaluation measures are available:
</p>

<ul>
<li> <p><code>"SSQ"</code> within cluster sum of squares. Assigns each point to
its nearest center from the clustering and calculates the sum of squares.
Noise points in the data stream are always ignored.
</p>
</li>
<li> <p><code>"silhouette"</code> average silhouette width. Actual noise points
which stay unassigned by the clustering algorithm are ignored; regular
points that are unassigned by the clustering algorithm form their own
noise cluster) (<span class="pkg">cluster</span>)
</p>
</li>
<li> <p><code>"average.between"</code> average distance between clusters (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"average.within"</code> average distance within clusters (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"max.diameter"</code> maximum cluster diameter (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"min.separation"</code> minimum cluster separation (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"ave.within.cluster.ss"</code> a generalization
of the within clusters sum of squares (half the sum of the within cluster
squared dissimilarities divided by the cluster size) (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"g2"</code> Goodman and Kruskal's Gamma coefficient (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"pearsongamma"</code> correlation between distances and a 0-1-vector where 0
means same cluster, 1 means different clusters (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"dunn"</code> Dunn index (minimum separation / maximum diameter) (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"dunn2"</code> minimum average dissimilarity between two cluster /
maximum average within cluster dissimilarity (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"entropy"</code> entropy of the distribution of cluster memberships (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"wb.ratio"</code> average.within/average.between (<span class="pkg">fpc</span>)
</p>
</li></ul>

<p>The following external evaluation measures are available:
</p>

<ul>
<li> <p><code>"precision"</code>, <code>"recall"</code>, <code>"F1"</code> F1.  A true positive (TP)
decision assigns two points in the same true cluster also to the same
cluster, a true negative (TN) decision assigns two points from two different
true clusters to two different clusters.  A false positive (FP) decision
assigns two points from the same true cluster to two different clusters.  A
false negative (FN) decision assigns two points from the same true cluster
to different clusters.
</p>
<p><code>precision = TP / (TP + FP)</code>
</p>
<p><code>recall = TP / (TP + FN)</code>
</p>
<p>The F1 measure is the harmonic mean of precision and recall.
</p>
</li>
<li> <p><code>"purity"</code> Average purity of clusters. The purity of each cluster
is the proportion of the points of the majority true group assigned to it
(see Cao et al. (2006)).
</p>
</li>
<li> <p><code>"classPurity"</code> (of real clusters; see Wan et al (2009)).
</p>
</li>
<li> <p><code>"fpr"</code> false positive rate.
</p>
</li>
<li> <p><code>"Euclidean"</code> Euclidean dissimilarity of the memberships (see
Dimitriadou, Weingessel and Hornik (2002)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"Manhattan"</code> Manhattan dissimilarity of the memberships (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"Rand"</code> Rand index (see Rand (1971)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"cRand"</code> Adjusted Rand index (see Hubert and Arabie (1985)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"NMI"</code> Normalized Mutual Information (see Strehl and Ghosh (2002)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"KP"</code> Katz-Powell index (see Katz and Powell (1953)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"angle"</code> maximal cosine of the angle between the agreements (<span class="pkg">clue</span>)
-<code> "diag"</code> maximal co-classification rate (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"FM"</code> Fowlkes and Mallows's index (see Fowlkes and Mallows (1983)) (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"Jaccard"</code> Jaccard index (<span class="pkg">clue</span>)
</p>
</li>
<li> <p><code>"PS"</code> Prediction Strength (see Tibshirani and Walter (2005)) (<span class="pkg">clue</span>) %
</p>
</li>
<li> <p><code>"corrected.rand"</code>  corrected Rand index (<span class="pkg">fpc</span>)
</p>
</li>
<li> <p><code>"vi"</code> variation of information (VI) index (<span class="pkg">fpc</span>)
</p>
</li></ul>

<p>Many measures are the average over all clusters. For example, purity is the
average purity over all clusters.
</p>
<p>For <a href="#topic+DSC_Micro">DSC_Micro</a> objects, data points are assigned to micro-clusters and
then each micro-cluster is evaluated. For <a href="#topic+DSC_Macro">DSC_Macro</a> objects, data
points by default (<code>assign = "micro"</code>) also assigned to micro-clusters,
but these assignments are translated to macro-clusters. The evaluation is
here done for macro-clusters. This is important when macro-clustering is
done with algorithms which do not create spherical clusters (e.g,
hierarchical clustering with single-linkage or DBSCAN) and this assignment
to the macro-clusters directly (i.e., their center) does not make sense.
</p>
<p>Using <code>type</code> and <code>assign</code>, the user can select how to assign data
points and ad what level (micro or macro) to evaluate.
</p>
<p><code>evaluate_cluster()</code> is used to evaluate an evolving data stream using
the method described by Wan et al. (2009). Of the <code>n</code> data points
<code>horizon</code> many points are clustered and then the evaluation measure is
calculated on the same data points. The idea is to find out if the
clustering algorithm was able to adapt to the changing stream.
</p>
<p><strong>Custom Evaluation Measures</strong>
</p>
<p>The parameter <code>callbacks</code> can be supplied with a named list with
functions with the signature <code style="white-space: pre;">&#8288;function(actual, predict, points, centers, dsc)&#8288;</code>
as elements. See the Examples sections for details.
</p>


<h3>Value</h3>

<p><code>evaluate</code> returns an object of class <code>stream_eval</code> which
is a numeric vector of the values of the requested measures and two
attributes, <code>"type"</code> and <code>"assign"</code>, to see at what level the
evaluation was done.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler, Matthew Bolanos, John Forrest, and Dalibor Krleža
</p>


<h3>References</h3>

<p>Joao Gama, Raquel Sebastiao, Pedro Pereira Rodrigues (2013). On
evaluating stream learning algorithms. <em>Machine Learning,</em> March 2013,
Volume 90, Issue 3, pp 317-346.
</p>
<p>F. Cao, M. Ester, W. Qian, A. Zhou (2006). Density-Based Clustering over an
Evolving Data Stream with Noise.
<em>Proceeding of the 2006 SIAM Conference on Data Mining,</em> 326-337.
</p>
<p>E. Dimitriadou, A. Weingessel and K. Hornik (2002).  A combination scheme
for fuzzy clustering.
<em>International Journal of Pattern Recognition and Artificial Intelligence,</em>
16, 901-912.
</p>
<p>E. B. Fowlkes and C. L. Mallows (1983).  A method for comparing two
hierarchical clusterings.
<em>Journal of the American Statistical Association,</em> 78, 553-569.
</p>
<p>L. Hubert and P. Arabie (1985).  Comparing partitions.
<em>Journal of Classification,</em> 2, 193-218.
</p>
<p>W. M. Rand (1971).  Objective criteria for the evaluation of clustering
methods.  <em>Journal of the American Statistical Association,</em> 66,
846-850.
</p>
<p>L. Katz and J. H. Powell (1953).  A proposed index of the conformity of one
sociometric measurement to another. <em>Psychometrika,</em> 18, 249-256.
</p>
<p>A. Strehl and J. Ghosh (2002).  Cluster ensembles - A knowledge reuse
framework for combining multiple partitions.
<em>Journal of Machine Learning Research,</em> 3, 583-617.
</p>
<p>R. Tibshirani and G. Walter (2005).  Cluster validation by Prediction
Strength. <em>Journal of Computational and Graphical Statistics,</em> 14/3,
511-528.
</p>
<p>L Wan, W.K. Ng, X.H. Dang, P.S. Yu and K. Zhang (2009). Density-Based
Clustering of Data Streams at Multiple Resolutions, <em>ACM Transactions
on Knowledge Discovery from Data,</em> 3(3).
</p>
<p>D. Krleža, B. Vrdoljak, and M. Brčić (2020). Statistical Hierarchical
Clustering Algorithm for Outlier Detection in Evolving Data Streams,
<em>Springer Machine Learning</em>.
</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">cluster::silhouette()</a></code>, <code><a href="clue.html#topic+cl_agreement">clue:: cl_agreement()</a></code>, and <code><a href="fpc.html#topic+cluster.stats">fpc::cluster.stats()</a></code>.
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>
<p>Other evaluation: 
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Static Evaluation
set.seed(0)
stream &lt;- DSD_Gaussians(k = 3, d = 2)

dstream &lt;- DSC_DStream(gridsize = 0.05, Cm = 1.5)
update(dstream, stream, 500)
plot(dstream, stream)

# Evaluate the micro-clusters in the clustering
# Note: we use here only n = 100 points for evaluation to speed up execution
evaluate_static(dstream, stream, n = 100)

evaluate_static(dstream, stream,
  measure = c("numMicro", "numMacro", "purity", "crand", "SSQ"),
  n = 100)

# DStream also provides macro clusters. Evaluate macro clusters with type = "macro"
# Note that SSQ and cRand increase.
plot(dstream, stream, type = "macro")
evaluate_static(dstream, stream, type = "macro",
  measure = c("numMicro", "numMacro", "purity", "crand", "SSQ"),
  n = 100)

# Points are by default assigned to micro clusters using the method
# specified for the clustering algorithm.
# However, points can also be assigned to the closest macro-cluster using
# assign = "macro".
evaluate_static(dstream, stream, type = "macro", assign = "macro",
  measure = c("numMicro", "numMacro", "purity", "crand", "SSQ"),
  n = 100)

# Example 2: Evaluate with Noise/Outliers
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = .05)
dstream &lt;- DSC_DStream(gridsize = 0.05, Cm = 1.5)
update(dstream, stream, 500)

# For cRand, noise is its own group, for SSQ, actual noise is always
# excluded.
plot(dstream, stream, 500)
evaluate_static(dstream, stream, n = 100,
  measure = c("numPoints", "noisePredicted", "noiseActual",
    "noisePrecision", "outlierJaccard", "cRand", "SSQ"))

# Note that if noise is excluded, the number of used points is reduced.
evaluate_static(dstream, stream, n = 100,
  measure = c("numPoints", "noisePredicted", "noiseActual",
    "noisePrecision", "outlierJaccard", "cRand", "SSQ"), excludeNoise = TRUE)


# Example 3: Evaluate an evolving data stream
stream &lt;- DSD_Benchmark(1)
dstream &lt;- DSC_DStream(gridsize = 0.05, lambda = 0.1)

evaluate_stream(dstream, stream, type = "macro", assign = "micro",
  measure = c("numMicro", "numMacro", "purity", "cRand"),
  n = 600, horizon = 100)

if (interactive()){
# animate the clustering process
reset_stream(stream)
dstream &lt;- DSC_DStream(gridsize = 0.05, lambda = 0.1)
animate_cluster(dstream, stream, horizon = 100, n = 5000,
  measure = "cRand", type = "macro", assign = "micro",
  plot.args = list(type = "both", xlim = c(0,1), ylim = c(0,1)))
}

# Example 4: Add a custom measure as a callback
callbacks &lt;- list(
   noisePercentage = function(actual, predict, points, centers, dsc) {
     sum(actual == 0L) / length(actual)
   },
   noiseFN = function(actual, predict, points, centers, dsc) {
     sum(actual == 0L &amp; predict != 0L)
   },
   noiseFP = function(actual, predict, points, centers, dsc) {
     sum(actual != 0L &amp; predict == 0L)
   }
 )

stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = .2)
dstream &lt;- DSC_DStream(gridsize = 0.05, Cm = 1.5)
update(dstream, stream, 500)

evaluate_static(dstream, stream,
  measure = c("numPoints", "noiseActual", "noisePredicted",
    "noisePercentage", "noiseFN", "noiseFP"),
  callbacks = callbacks, n = 100)

evaluate_static(dstream, stream, callbacks = callbacks)
</code></pre>

<hr>
<h2 id='get_assignment'>Assignment Data Points to Clusters <a href="base.html#topic+deprecated">deprecated</a></h2><span id='topic+get_assignment'></span><span id='topic+get_assignment.DSC'></span>

<h3>Description</h3>

<p><strong>Deprecation Notice:</strong> use <code><a href="#topic+predict">predict()</a></code> for a more general interface to apply
a data stream model to new data. <code>get_assignment()</code> is deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_assignment(
  dsc,
  points,
  type = c("auto", "micro", "macro"),
  method = "auto",
  ...
)

## S3 method for class 'DSC'
get_assignment(
  dsc,
  points,
  type = c("auto", "micro", "macro"),
  method = c("auto", "nn", "model"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_assignment_+3A_dsc">dsc</code></td>
<td>
<p>The <a href="#topic+DSC">DSC</a> object with the clusters for assignment.</p>
</td></tr>
<tr><td><code id="get_assignment_+3A_points">points</code></td>
<td>
<p>The points to be assigned as a data.frame.</p>
</td></tr>
<tr><td><code id="get_assignment_+3A_type">type</code></td>
<td>
<p>Use micro- or macro-clusters in <a href="#topic+DSC">DSC</a> for assignment.</p>
</td></tr>
<tr><td><code id="get_assignment_+3A_method">method</code></td>
<td>
<p>assignment method
</p>

<ul>
<li> <p><code>"model"</code> uses the assignment method of the underlying algorithm
(unassigned points return <code>NA</code>). Not all algorithms implement this option.
</p>
</li>
<li> <p><code>"nn"</code> performs nearest neighbor assignment using Euclidean distance.
</p>
</li>
<li> <p><code>"auto"</code> uses the model assignment method. If this method is not
implemented/available then method <code>"nn"</code> is used instead.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_assignment_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get the assignment of data points to clusters in a <code>DSC</code> using the
model's assignment rules or nearest neighbor assignment. The clustering is
not modified.
</p>
<p>Each data point is assigned either using the original model's assignment
rule or Euclidean nearest neighbor assignment. If the user specifies the
model's assignment strategy, but is not available, then nearest neighbor
assignment is used and a warning is produced.
</p>


<h3>Value</h3>

<p>A vector containing the assignment of each point. <code>NA</code> means
that a data point was not assigned to a cluster.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = .05)

dbstream &lt;- DSC_DBSTREAM(r = .1)
update(dbstream, stream, n = 100)

# find the assignment for the next 100 points to
# micro-clusters in dsc. This uses the model's assignment function
points &lt;- get_points(stream, n = 100)
a &lt;- predict(dbstream, points)
head(a)

# show the MC assignment areas. Assigned points as blue circles and
# the unassigned points as red dots
plot(dbstream, stream, assignment = TRUE, type = "none")
points(points[!is.na(a[, ".class"]),], col = "blue")
points(points[is.na(a[, ".class"]),], col = "red", pch = 20)

# use nearest neighbor assignment instead
a &lt;- predict(dbstream, points, method = "nn")
head(a)
</code></pre>

<hr>
<h2 id='get_points'>Get Points from a Data Stream Generator</h2><span id='topic+get_points'></span><span id='topic+get_points.DSD'></span><span id='topic+remove_info'></span>

<h3>Description</h3>

<p>Gets points from a <a href="#topic+DSD">DSD</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_points(x, ...)

## S3 method for class 'DSD'
get_points(x, n = 1L, info = TRUE, ...)

remove_info(points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_points_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+DSD">DSD</a> object.</p>
</td></tr>
<tr><td><code id="get_points_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to the <code>get_points()</code> implementations.</p>
</td></tr>
<tr><td><code id="get_points_+3A_n">n</code></td>
<td>
<p>integer; request up to <code>n</code> points from the stream. <code>n = -1</code> returns
all remaining points from limited streams.</p>
</td></tr>
<tr><td><code id="get_points_+3A_info">info</code></td>
<td>
<p>return additional columns with information about the data point (e.g., a known cluster assignment).</p>
</td></tr>
<tr><td><code id="get_points_+3A_points">points</code></td>
<td>
<p>a data.frame with points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each DSD object has a unique way for creating/returning data points, but they all are
called through the generic function, <code>get_points()</code>. This is done by
using the S3 class system. See the man page for the specific <a href="#topic+DSD">DSD</a> class on
the semantics for each implementation of <code>get_points()</code>.
</p>
<p><strong>Additional Point Information</strong>
</p>
<p>Additional point information (e.g., known cluster/class assignment, noise status) can be requested
with <code>info = TRUE</code>. This information is returned as additional columns. The column names start with
<code>.</code> and are ignored by <a href="#topic+DST">DST</a> implementations. <code>remove_info()</code> is a convenience function to remove the
information columns.
Examples are
</p>

<ul>
<li> <p><code>.id</code> for point IDs
</p>
</li>
<li> <p><code>.class</code> for known cluster/class labels used for plotting and evaluation
</p>
</li>
<li> <p><code>.time</code> a time stamp for the point (can be in seconds or an index for ordering)
</p>
</li></ul>

<p><strong>Resetting a Stream</strong>
</p>
<p>Many streams can be reset using <code><a href="#topic+reset_stream">reset_stream()</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <a href="base.html#topic+data.frame">data.frame</a> with (up to) <code>n</code> rows and as many columns as <code>x</code> produces.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians()
points &lt;- get_points(stream, n = 5)
points

remove_info(points)
</code></pre>

<hr>
<h2 id='MGC'>Moving Generator Cluster</h2><span id='topic+MGC'></span><span id='topic+MGC_Function'></span><span id='topic+MGC_Linear'></span><span id='topic+keyframe'></span><span id='topic+add_keyframe'></span><span id='topic+get_keyframes'></span><span id='topic+remove_keyframe'></span><span id='topic+MGC_Noise'></span><span id='topic+MGC_Random'></span><span id='topic+Shape_Gaussian'></span><span id='topic+Shape_Block'></span><span id='topic+MGC_Static'></span>

<h3>Description</h3>

<p>Creates an evolving cluster for use as a component of a <a href="#topic+DSD_MG">DSD_MG</a> data stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGC(...)

MGC_Function(density, center, parameter, shape = Shape_Gaussian)

MGC_Linear(dimension = 2, keyframelist = NULL, shape = Shape_Gaussian)

keyframe(time, density, center, parameter, reset = FALSE)

add_keyframe(x, time, density, center, parameter, reset = FALSE)

get_keyframes(x)

remove_keyframe(x, time)

MGC_Noise(density, range)

MGC_Random(density, center, parameter, randomness = 1, shape = Shape_Gaussian)

Shape_Gaussian(center, parameter)

Shape_Block(center, parameter)

MGC_Static(density = 1, center, parameter, shape = Shape_Gaussian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGC_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="MGC_+3A_density">density</code></td>
<td>
<p>The density of the cluster. For 'MGC_Function, this
attribute is a function and defines the density of a cluster (i.e., how many points it creates)
at each given timestamp.</p>
</td></tr>
<tr><td><code id="MGC_+3A_center">center</code></td>
<td>
<p>A list that defines the center of the cluster. The list should
have a length equal to the dimensionality. For <code>MGC_Function</code>, this
list consists of functions that define the movement of the cluster. For
<code>MGC_Random</code>, this attribute defines the beginning location for the
<code>MGC</code> before it begins moving.</p>
</td></tr>
<tr><td><code id="MGC_+3A_parameter">parameter</code></td>
<td>
<p>Parameters for the shape. For the default shape
<code>Shape_Gaussian</code> the parameter is the standard deviation, one per
dimension. If a single value is specified then it is recycled for all
dimensions.</p>
</td></tr>
<tr><td><code id="MGC_+3A_shape">shape</code></td>
<td>
<p>A function creating the shape of the cluster. It gets passed on
the parameters argument from above. Available functions are
<code>Shape_Gaussian</code> (the parameters are a vector containing standard
deviations) and <code>Shape_Block</code> (parameters are the dimensions of the
uniform block).</p>
</td></tr>
<tr><td><code id="MGC_+3A_dimension">dimension</code></td>
<td>
<p>Dimensionality of the data stream.</p>
</td></tr>
<tr><td><code id="MGC_+3A_keyframelist">keyframelist</code></td>
<td>
<p>a list of keyframes to initialize the <code>MGC_Linear</code>
object with.</p>
</td></tr>
<tr><td><code id="MGC_+3A_time">time</code></td>
<td>
<p>The time stamp the keyframe should be located or which keyframe
should be removed.</p>
</td></tr>
<tr><td><code id="MGC_+3A_reset">reset</code></td>
<td>
<p>Should the cluster reset to the first keyframe (time 0) after
this keyframe is finished?</p>
</td></tr>
<tr><td><code id="MGC_+3A_x">x</code></td>
<td>
<p>An object of class <code>MGC_Linear</code>.</p>
</td></tr>
<tr><td><code id="MGC_+3A_range">range</code></td>
<td>
<p>The area in which the noise should appear.</p>
</td></tr>
<tr><td><code id="MGC_+3A_randomness">randomness</code></td>
<td>
<p>The maximum amount the cluster will move during one time
step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>MGC</code> describes a single cluster for use as a component in a <a href="#topic+DSD_MG">DSD_MG</a>.
Different <a href="#topic+MGC">MGC</a>s  allow the user to express
different cluster behaviors within a single data stream. Static, (i.e., not moving)
clusters are defined as:
</p>

<ul>
<li> <p><code>MGC_Static</code> cluster positions are fixed
</p>
</li>
<li> <p><code>MGC_Noise</code> allows to add random noise.
</p>
</li></ul>

<p>Moving (evolving) clusters are defined as:
</p>

<ul>
<li> <p><code>MGC_Linear</code> creates an evolving cluster for a who's behavior is determined by
keyframes. Several keyframe
functions are provided to create, add and remove keyframes.
See Examples section for details.
</p>
</li>
<li> <p><code>MGC_Function</code> allows to specify <code>density</code>, <code>center</code>, and <code>parameter</code>
as a function of time.
</p>
</li>
<li> <p><code>MGC_Random</code> allows for a creation of a cluster that follows a random walk.
</p>
</li></ul>

<p>Cluster shapes can be specified using the functions:
</p>

<ul>
<li> <p><code>Shape_Gaussian</code>
</p>
</li>
<li> <p><code>Shape_Block</code>
</p>
</li></ul>

<p>New
shapes can be defined as a function with parameters <code>center</code> and <code>parameter</code> that return a single new
point. Here is an example:
</p>
<div class="sourceCode"><pre>Shape_Gaussian &lt;- function(center, parameter)
   rnorm(length(center), mean = center, sd = parameter)
</pre></div>


<h3>Author(s)</h3>

<p>Matthew Bolanos
</p>


<h3>See Also</h3>

<p><a href="#topic+DSD_MG">DSD_MG</a> for details on how to use an <code>MGC</code> within
a <a href="#topic+DSD">DSD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MGC()

### Two static clusters (Gaussian with sd of .1 and a Block with width .4)
###   with added noise
stream &lt;- DSD_MG(dim = 2,
  MGC_Static(den = .45, center = c(1, 0), par = .1, shape = Shape_Gaussian),
  MGC_Static(den = .45, center = c(2, 0), par = .4, shape = Shape_Block),
  MGC_Noise( den = .1, range = rbind(c(0, 3), c(-1,1)))
)
stream

plot(stream)

### Example of several MGC_Randoms which define clusters that randomly move.
stream &lt;- DSD_MG(dim = 2,
  MGC_Random(den = 100, center=c(1, 0), par = .1, rand = .2),
  MGC_Random(den = 100, center=c(2, 0), par = .4, shape = Shape_Block, rand = .2)
)

## Not run: 
  animate_data(stream, 2500, xlim = c(0,3), ylim = c(-1,1), horizon = 100)

## End(Not run)


### Example of several MGC_Functions

### a block-shaped cluster moving from bottom-left to top-right increasing size
c1 &lt;- MGC_Function(
  density = function(t){ 100 },
  parameter = function(t){ 1 * t },
  center = function(t) c(t, t),
  shape = Shape_Block
  )

### a cluster moving in a circle (default shape is Gaussian)
c2 &lt;- MGC_Function(
  density = function(t){ 25 },
  parameter = function(t){ 5 },
  center= function(t) c(sin(t / 10) * 50 + 50, cos(t / 10) * 50 + 50)
)

stream &lt;- DSD_MG(dim = 2, c1, c2)

## adding noise after the stream was created
add_cluster(stream, MGC_Noise(den = 10, range = rbind(c(-20, 120), c(-20, 120))))

stream

## Not run: 
animate_data(stream, 10000, xlim = c(-20, 120), ylim = c(-20, 120), horizon = 100)

## End(Not run)

### Example of several MGC_Linear: A single cluster splits at time 50 into two.
### Note that c2 starts at time = 50!
stream &lt;- DSD_MG(dim = 2)
c1 &lt;- MGC_Linear(dim = 2)
add_keyframe(c1, time = 1,  dens = 50, par = 5, center = c(0, 0))
add_keyframe(c1, time = 50, dens = 50, par = 5, center = c(50, 50))
add_keyframe(c1, time = 100,dens = 50, par = 5, center = c(50, 100))
add_cluster(stream, c1)

c2 &lt;- MGC_Linear(dim = 2, shape = Shape_Block)
add_keyframe(c2, time = 50, dens = 25, par = c(10, 10), center = c(50, 50))
add_keyframe(c2, time = 100,dens = 25, par = c(30, 30), center = c(100, 50))
add_cluster(stream, c2)

## Not run: 
animate_data(stream, 5000, xlim = c(0, 100), ylim = c(0, 100), horiz = 100)

## End(Not run)

### two fixed and a moving cluster
stream &lt;- DSD_MG(dim = 2,
  MGC_Static(dens = 1, par = .1, center = c(0, 0)),
  MGC_Static(dens = 1, par = .1, center = c(1, 1)),
  MGC_Linear(dim = 2, list(
    keyframe(time = 0,    dens = 1, par = .1, center = c(0, 0)),
    keyframe(time = 1000, dens = 1, par = .1, center = c(1, 1)),
    keyframe(time = 2000, dens = 1, par = .1, center = c(0, 0), reset = TRUE)
  )))

noise &lt;- MGC_Noise(dens = .1, range = rbind(c(-.2, 1.2), c(-.2, 1.2)))
add_cluster(stream, noise)

## Not run: 
animate_data(stream, n = 2000 * 3.1, xlim = c(-.2, 1.2), ylim = c(-.2, 1.2), horiz = 200)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.DSC'>Plot Results of a Data Stream Clustering</h2><span id='topic+plot.DSC'></span>

<h3>Description</h3>

<p>Method to plot the result of data stream data clustering. To plot <a href="#topic+DSD">DSD</a> see <code><a href="#topic+plot.DSD">plot.DSD()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DSC'
plot(
  x,
  dsd = NULL,
  n = 500,
  col_points = NULL,
  col_clusters = c("red", "blue", "green"),
  weights = TRUE,
  scale = c(1, 5),
  cex = 1,
  pch = NULL,
  method = c("pairs", "scatter", "pca"),
  dim = NULL,
  type = c("auto", "micro", "macro", "both", "none"),
  assignment = FALSE,
  transform = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DSC_+3A_x">x</code></td>
<td>
<p>the <a href="#topic+DSC">DSC</a> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_dsd">dsd</code></td>
<td>
<p>a <a href="#topic+DSD">DSD</a> object to plot the data in the background.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_n">n</code></td>
<td>
<p>number of plots taken from <code>dsd</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_col_points">col_points</code>, <code id="plot.DSC_+3A_col_clusters">col_clusters</code></td>
<td>
<p>colors used for plotting.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_weights">weights</code></td>
<td>
<p>if <code>TRUE</code> then the cluster weight is used for symbol size. Alternatively, a
vector with the size of the symbols for micro- and macro-clusters can be supplied.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_scale">scale</code></td>
<td>
<p>range for the symbol sizes used.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_cex">cex</code></td>
<td>
<p>size factor for symbols.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_pch">pch</code></td>
<td>
<p>symbol type for points.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_method">method</code></td>
<td>
<p>method used for plotting: <code>"pairs"</code> (pairs plot), <code>"scatter"</code>
(scatter plot), <code>"pca"</code> (plot first 2 principal components).</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_dim">dim</code></td>
<td>
<p>an integer vector with the dimensions to plot. If <code>NULL</code>
then for methods <code>pairs</code> and <code>"pca"</code> all dimensions are used and
for <code>"scatter"</code> the first two dimensions are plotted.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_type">type</code></td>
<td>
<p>Plot micro clusters (<code>type = "micro"</code>), macro clusters
(<code>type = "macro"</code>), both micro and macro clusters (<code>type = "both"</code>).</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_assignment">assignment</code></td>
<td>
<p>logical; show assignment area of micro-clusters.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_transform">transform</code></td>
<td>
<p>a function that maps data stream points onto a 2-D plane for plotting.</p>
</td></tr>
<tr><td><code id="plot.DSC_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code> or <code><a href="graphics.html#topic+pairs">graphics::pairs()</a></code>.
<span class="pkg">graphics</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>
<p>Other plot: 
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k = 3, d = 3, noise = 0.05)

## Example 1: Plot data
plot(stream)

## Example 2: Plot a clustering
dstream &lt;- DSC_DStream(gridsize = 0.1)
update(dstream, stream, 500)
dstream
plot(dstream, stream)

## plot micro or macro-clusters only
plot(dstream, stream, type = "micro")
plot(dstream, stream, type = "macro")

## plot projected on the first two principal components
## and on dimensions 2 and 3
plot(dstream, stream, method = "pca")
plot(dstream, stream, dim = c(2, 3))

## D-Stream has a special implementation to show assignment areas
plot(dstream, stream, assignment = TRUE)

## Example 4: Use a custom transformation for plotting.
##     We fit PCA using 100 points and create a transformation
##     function to project the stream to the first two PCs.
pr &lt;- princomp(get_points(stream, n = 100, info = FALSE))
trans &lt;- function(x) predict(pr, x)[, 1:2 , drop = FALSE]

trans(get_points(stream, n = 3))

plot(dstream, stream, transform = trans)
</code></pre>

<hr>
<h2 id='plot.DSD'>Plot Data Stream Data</h2><span id='topic+plot.DSD'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Method to plot data stream data. To plot <a href="#topic+DSC">DSC</a> see <code><a href="#topic+plot.DSC">plot.DSC()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DSD'
plot(
  x,
  n = 500,
  col = NULL,
  pch = NULL,
  ...,
  method = c("pairs", "scatter", "pca", "ts"),
  dim = NULL,
  alpha = 0.6,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DSD_+3A_x">x</code></td>
<td>
<p>the <a href="#topic+DSD">DSD</a> object to be plotted.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_n">n</code></td>
<td>
<p>number of plots taken from <code>x</code> to plot.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_col">col</code></td>
<td>
<p>colors used for points.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_pch">pch</code></td>
<td>
<p>symbol type.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code> or <code><a href="graphics.html#topic+pairs">graphics::pairs()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_method">method</code></td>
<td>
<p>method used for plotting: <code>"pairs"</code> (pairs plot), <code>"scatter"</code>
(scatter plot), <code>"pca"</code> (plot first 2 principal components), or <code>"ts"</code> (time series).</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_dim">dim</code></td>
<td>
<p>an integer vector with the dimensions to plot. If <code>NULL</code>
then for methods <code>pairs</code> and <code>"pca"</code> all dimensions are used and
for <code>"scatter"</code> the first two dimensions are plotted.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_alpha">alpha</code></td>
<td>
<p>alpha shading used to plot the points.</p>
</td></tr>
<tr><td><code id="plot.DSD_+3A_transform">transform</code></td>
<td>
<p>a function that maps data stream points onto a 2-D plane for plotting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+reset_stream">reset_stream</a>()</code>
</p>
<p>Other plot: 
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- DSD_Gaussians(k=3, d=3)

## plot data
plot(stream, n = 500)
plot(stream, method = "pca", n = 500)
plot(stream, method = "scatter", dim = c(1, 3), n = 500)

## create and plot micro-clusters
dstream &lt;- DSC_DStream(gridsize = 0.1)
update(dstream, stream, 500)
plot(dstream)

## plot with data, projected on the first two principal components
## and dimensions 2 and 3
plot(dstream, stream)
plot(dstream, stream, method = "pca")
plot(dstream, stream, dim = c(2, 3))

## plot micro and macro-clusters
plot(dstream, stream, type = "both")

## plot a time series using the AirPassenger data with the total monthly
## passengers from 1949 to 1960) a as a stream
AirPassengers
stream &lt;- DSD_Memory(data.frame(
  .time = time(AirPassengers),
  passengers = AirPassengers))

get_points(stream, n = 10)
plot(stream, n = 100, method = "ts")
</code></pre>

<hr>
<h2 id='predict'>Make a Prediction for a Data Stream Mining Task</h2><span id='topic+predict'></span><span id='topic+predict.DST'></span><span id='topic+predict.DSC'></span>

<h3>Description</h3>

<p><code>predict()</code> for data stream mining tasks <a href="#topic+DST">DST</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DST'
predict(object, newdata, ...)

## S3 method for class 'DSC'
predict(
  object,
  newdata,
  type = c("auto", "micro", "macro"),
  method = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+DST">DST</a> object.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>The points to make predictions for as a data.frame.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed on.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>Use micro- or macro-clusters in <a href="#topic+DSC">DSC</a> for assignment.</p>
</td></tr>
<tr><td><code id="predict_+3A_method">method</code></td>
<td>
<p>assignment method
</p>

<ul>
<li> <p><code>"model"</code> uses the assignment method of the underlying algorithm
(unassigned points return <code>NA</code>). Not all algorithms implement this option.
</p>
</li>
<li> <p><code>"nn"</code> performs nearest neighbor assignment using Euclidean distance.
</p>
</li>
<li> <p><code>"auto"</code> uses the model assignment method. If this method is not
implemented/available then method <code>"nn"</code> is used instead.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns containing the predictions. The columns depend on the type of the
data stream mining task.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>,
<code><a href="#topic+update">update</a>()</code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = .1)

dbstream &lt;- DSC_DBSTREAM(r = .1)
update(dbstream, stream, n = 100)
plot(dbstream, stream, type = "both")

# find the assignment for the next 100 points to
# micro-clusters in dsc. This uses the model's assignment function
points &lt;- get_points(stream, n = 10)
points

pr &lt;- predict(dbstream, points, type = "macro")
pr

# Note that the clusters are labeled in arbitrary order. Check the
# agreement.
agreement(pr[,".class"], points[,".class"])
</code></pre>

<hr>
<h2 id='prune_clusters'>Prune Clusters from a Clustering</h2><span id='topic+prune_clusters'></span>

<h3>Description</h3>

<p>Creates a (static) copy of a clustering where a fraction of the weight or
the number of clusters with the lowest weights were pruned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_clusters(dsc, threshold = 0.05, weight = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_clusters_+3A_dsc">dsc</code></td>
<td>
<p>The DSC object to be pruned.</p>
</td></tr>
<tr><td><code id="prune_clusters_+3A_threshold">threshold</code></td>
<td>
<p>The numeric vector of probabilities for the quantile.</p>
</td></tr>
<tr><td><code id="prune_clusters_+3A_weight">weight</code></td>
<td>
<p>should a fraction of the total weight in the clustering be
pruned? Otherwise a fraction of clusters is pruned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>DSC_Static</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DSC_Static">DSC_Static</a></code>
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 3 clusters with 10% noise
stream &lt;- DSD_Gaussians(k=3, noise=0.1)

dbstream &lt;- DSC_DBSTREAM(r=0.1)
update(dbstream, stream, 500)
dbstream
plot(dbstream, stream)

# prune lightest micro-clusters for 20% of the weight of the clustering
static &lt;- prune_clusters(dbstream, threshold=0.2)
static
plot(static, stream)

</code></pre>

<hr>
<h2 id='read_saveDSC'>Save and Read DSC Objects</h2><span id='topic+read_saveDSC'></span><span id='topic+saveDSC'></span><span id='topic+readDSC'></span>

<h3>Description</h3>

<p>Save and Read DSC objects safely (serializes the underlying data structure).
This also works for <span class="pkg">streamMOA</span> DSC objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDSC(object, file, ...)

readDSC(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_saveDSC_+3A_object">object</code></td>
<td>
<p>a DSC object.</p>
</td></tr>
<tr><td><code id="read_saveDSC_+3A_file">file</code></td>
<td>
<p>filename.</p>
</td></tr>
<tr><td><code id="read_saveDSC_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+saveRDS">saveRDS</a></code> and <code><a href="base.html#topic+readRDS">readRDS</a></code>.
</p>
<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+recluster">recluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stream &lt;- DSD_Gaussians(k = 3, noise = 0.05)

# create clusterer with r = 0.05
dbstream1 &lt;- DSC_DBSTREAM(r = .05)
update(dbstream1, stream, 1000)
dbstream1

saveDSC(dbstream1, file="dbstream.Rds")

dbstream2 &lt;- readDSC("dbstream.Rds")
dbstream2

## cleanup
unlink("dbstream.Rds")
</code></pre>

<hr>
<h2 id='recluster'>Re-clustering micro-clusters</h2><span id='topic+recluster'></span><span id='topic+recluster.DSC_Macro'></span>

<h3>Description</h3>

<p>Use an *<strong>offline</strong> macro clustering algorithm to recluster micro-clusters into a final
clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recluster(macro, micro, type = "auto", ...)

## S3 method for class 'DSC_Macro'
recluster(macro, micro, type = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recluster_+3A_macro">macro</code></td>
<td>
<p>an empty <a href="#topic+DSC_Macro">DSC_Macro</a>.</p>
</td></tr>
<tr><td><code id="recluster_+3A_micro">micro</code></td>
<td>
<p>an updated <a href="#topic+DSC_Micro">DSC_Micro</a> with micro-clusters.</p>
</td></tr>
<tr><td><code id="recluster_+3A_type">type</code></td>
<td>
<p>controls which clustering is used from <code>micro</code>. Typically
<code>auto</code>.</p>
</td></tr>
<tr><td><code id="recluster_+3A_...">...</code></td>
<td>
<p>additional arguments passed on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes centers and weights of the micro-clusters and applies the macro
clustering algorithm.
</p>
<p>See <a href="#topic+DSC_TwoStage">DSC_TwoStage</a> for a convenient combination of micro and macro clustering.
</p>


<h3>Value</h3>

<p>The object <code>macro</code> is altered in place and contains the clustering.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSC: 
<code><a href="#topic+DSC_Macro">DSC_Macro</a>()</code>,
<code><a href="#topic+DSC_Micro">DSC_Micro</a>()</code>,
<code><a href="#topic+DSC_R">DSC_R</a>()</code>,
<code><a href="#topic+DSC_SlidingWindow">DSC_SlidingWindow</a>()</code>,
<code><a href="#topic+DSC_Static">DSC_Static</a>()</code>,
<code><a href="#topic+DSC_TwoStage">DSC_TwoStage</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+animate_cluster">animate_cluster</a>()</code>,
<code><a href="#topic+evaluate.DSC">evaluate.DSC</a></code>,
<code><a href="#topic+get_assignment">get_assignment</a>()</code>,
<code><a href="#topic+plot.DSC">plot.DSC</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+prune_clusters">prune_clusters</a>()</code>,
<code><a href="#topic+read_saveDSC">read_saveDSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
### create a data stream and a micro-clustering
stream &lt;- DSD_Gaussians(k = 3, d = 3)

### sample can be seen as a simple online clusterer where the sample points
### are the micro clusters.
sample &lt;- DSC_Sample(k = 50)
update(sample, stream, 500)
sample

### recluster using k-means
kmeans &lt;- DSC_Kmeans(k = 3)
recluster(kmeans, sample)

### plot clustering
plot(kmeans, stream, type = "both", main = "Macro-clusters (Sampling + k-means)")
</code></pre>

<hr>
<h2 id='reset_stream'>Reset a Data Stream to its Beginning</h2><span id='topic+reset_stream'></span>

<h3>Description</h3>

<p>Resets the position in a <a href="#topic+DSD">DSD</a> object to the beginning or, if available, any other position in
the stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_stream(dsd, pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_stream_+3A_dsd">dsd</code></td>
<td>
<p>An object of class a subclass of <a href="#topic+DSD">DSD</a> which implements a
reset function.</p>
</td></tr>
<tr><td><code id="reset_stream_+3A_pos">pos</code></td>
<td>
<p>Position in the stream (the beginning of the stream is position
1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resets the counter of the stream object. For example, for <a href="#topic+DSD_Memory">DSD_Memory</a>,
the counter stored in the environment variable is moved back to 1. For
<a href="#topic+DSD_ReadCSV">DSD_ReadCSV</a> objects, this is done by calling <code><a href="base.html#topic+seek">seek()</a></code> on the
underlying connection.
</p>
<p><code>reset_stream()</code> is implemented for:
</p>

<ul>
<li> <p><a href="#topic+DSD">DSD</a>
</p>
</li>
<li> <p><a href="#topic+DSD_MG">DSD_MG</a>
</p>
</li>
<li> <p><a href="#topic+DSD_Memory">DSD_Memory</a>
</p>
</li>
<li> <p><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>
</p>
</li>
<li> <p><a href="#topic+DSF">DSF</a>
</p>
</li>
<li> <p><a href="#topic+DSF_Convolve">DSF_Convolve</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DSD: 
<code><a href="#topic+DSD_BarsAndGaussians">DSD_BarsAndGaussians</a>()</code>,
<code><a href="#topic+DSD_Benchmark">DSD_Benchmark</a>()</code>,
<code><a href="#topic+DSD_Cubes">DSD_Cubes</a>()</code>,
<code><a href="#topic+DSD_Gaussians">DSD_Gaussians</a>()</code>,
<code><a href="#topic+DSD_MG">DSD_MG</a>()</code>,
<code><a href="#topic+DSD_Memory">DSD_Memory</a>()</code>,
<code><a href="#topic+DSD_Mixture">DSD_Mixture</a>()</code>,
<code><a href="#topic+DSD_NULL">DSD_NULL</a>()</code>,
<code><a href="#topic+DSD_ReadDB">DSD_ReadDB</a>()</code>,
<code><a href="#topic+DSD_ReadStream">DSD_ReadStream</a>()</code>,
<code><a href="#topic+DSD_Target">DSD_Target</a>()</code>,
<code><a href="#topic+DSD_UniformNoise">DSD_UniformNoise</a>()</code>,
<code><a href="#topic+DSD_mlbenchData">DSD_mlbenchData</a>()</code>,
<code><a href="#topic+DSD_mlbenchGenerator">DSD_mlbenchGenerator</a>()</code>,
<code><a href="#topic+DSD">DSD</a>()</code>,
<code><a href="#topic+DSF">DSF</a>()</code>,
<code><a href="#topic+animate_data">animate_data</a>()</code>,
<code><a href="#topic+close_stream">close_stream</a>()</code>,
<code><a href="#topic+get_points">get_points</a>()</code>,
<code><a href="#topic+plot.DSD">plot.DSD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initializing the objects
stream &lt;- DSD_Gaussians()
replayer &lt;- DSD_Memory(stream, 100)
replayer

p &lt;- get_points(replayer, 50)
replayer

# reset replayer to the beginning of the stream
reset_stream(replayer)
replayer

# set replayer to position 21
reset_stream(replayer, pos = 21)
replayer
</code></pre>

<hr>
<h2 id='stream_pipeline'>Create a Data Stream Pipeline</h2><span id='topic+stream_pipeline'></span><span id='topic+DST_Runner'></span>

<h3>Description</h3>

<p>Define a complete data stream pipe line
consisting of a data stream, filters and a data mining task using <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DST_Runner(dsd, dst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_pipeline_+3A_dsd">dsd</code></td>
<td>
<p>A data stream (subclass of <a href="#topic+DSD">DSD</a>) typically provided using a <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> (pipe).</p>
</td></tr>
<tr><td><code id="stream_pipeline_+3A_dst">dst</code></td>
<td>
<p>A data stream mining task (subclass of <a href="#topic+DST">DST</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data stream pipe line
consisting of a data stream, filters and a data mining task:
</p>
<p><code>DSD %&gt;% DSF %&gt;% DST_Runner</code>
</p>
<p>Once the pipeline is defined, it can be run using <code><a href="#topic+update">update()</a></code> where points are
taken from the <a href="#topic+DSD">DSD</a> data stream source,
filtered through a sequence of <a href="#topic+DSF">DSF</a> filters and then used to update
the <a href="#topic+DST">DST</a> task.
</p>
<p><a href="#topic+DST_Multi">DST_Multi</a> can be used to update multiple models in the pipeline with the same stream.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+update">update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)

# Set up a pipeline with a DSD data source, DSF Filters and then a DST task
cluster_pipeline &lt;- DSD_Gaussians(k = 3, d = 2) %&gt;%
                    DSF_Scale() %&gt;%
                    DST_Runner(DSC_DBSTREAM(r = .3))

cluster_pipeline

# the DSD and DST can be accessed directly
cluster_pipeline$dsd
cluster_pipeline$dst

# update the DST using the pipeline, by default update returns the micro clusters
update(cluster_pipeline, n = 1000)

cluster_pipeline$dst
get_centers(cluster_pipeline$dst, type = "macro")
plot(cluster_pipeline$dst)
</code></pre>

<hr>
<h2 id='stream-package'>stream: Infrastructure for Data Stream Mining</h2><span id='topic+stream-package'></span>

<h3>Description</h3>

<p>A framework for data stream modeling and associated data mining tasks such as clustering and classification.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>

<hr>
<h2 id='update'>Update a Data Stream Mining Task Model with Points from a Stream</h2><span id='topic+update'></span><span id='topic+update.DST'></span>

<h3>Description</h3>

<p><code>update()</code> for data stream mining tasks <a href="#topic+DST">DST</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DST'
update(object, dsd, n = 1L, return = "nothing", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>The <a href="#topic+DST">DST</a> object.</p>
</td></tr>
<tr><td><code id="update_+3A_dsd">dsd</code></td>
<td>
<p>A <a href="#topic+DSD">DSD</a> object with the data stream.</p>
</td></tr>
<tr><td><code id="update_+3A_n">n</code></td>
<td>
<p>number of points from <code>dsd</code> to use for the update. Some DSD <code>dsd</code> accept <code>n = -1</code> to update with all remaining points in the stream.</p>
</td></tr>
<tr><td><code id="update_+3A_return">return</code></td>
<td>
<p>a character string indicating what update returns. The default is <code>"nothing"</code>. Other
possible values depend on the <code>DST</code>. Examples are <code>"data"</code>, <code>"model"</code> and <code>"assignment"</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> or a data.frame <code>n</code> rows containing update information for each data point.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other DST: 
<code><a href="#topic+DSAggregate">DSAggregate</a>()</code>,
<code><a href="#topic+DSClassifier">DSClassifier</a>()</code>,
<code><a href="#topic+DSC">DSC</a>()</code>,
<code><a href="#topic+DSOutlier">DSOutlier</a>()</code>,
<code><a href="#topic+DSRegressor">DSRegressor</a>()</code>,
<code><a href="#topic+DST_SlidingWindow">DST_SlidingWindow</a>()</code>,
<code><a href="#topic+DST_WriteStream">DST_WriteStream</a>()</code>,
<code><a href="#topic+DST">DST</a>()</code>,
<code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+stream_pipeline">stream_pipeline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1500)
stream &lt;- DSD_Gaussians(k = 3, d = 2, noise = .1)

dbstream &lt;- DSC_DBSTREAM(r = .1)
assignment &lt;- update(dbstream, stream, n = 100, return = "assignment")
plot(dbstream, stream, type = "both")

# DBSTREAM returns cluster assignments (see DSC_DBSTREAM).
head(assignment)
</code></pre>

<hr>
<h2 id='write_stream'>Write a Data Stream to a File</h2><span id='topic+write_stream'></span>

<h3>Description</h3>

<p>Writes points from a data stream DSD object to a file or a connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_stream(
  dsd,
  file,
  n,
  block = 100000L,
  info = FALSE,
  append = FALSE,
  sep = ",",
  header = FALSE,
  row.names = FALSE,
  close = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_stream_+3A_dsd">dsd</code></td>
<td>
<p>The DSD object that will generate the data points for output.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_file">file</code></td>
<td>
<p>A file name or a R connection to be written to.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_n">n</code></td>
<td>
<p>The number of data points to be written. For finite streams, <code>n = -1</code> writes all available data points.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_block">block</code></td>
<td>
<p>Write stream in blocks to improve file I/O speed.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_info">info</code></td>
<td>
<p>Save the class/cluster labels and other information columns with the data.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_append">append</code></td>
<td>
<p>Append the data to an existing file. If <code>FALSE</code>, then the file will be overwritten.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_sep">sep</code></td>
<td>
<p>The character that will separate attributes in a data point.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_header">header</code></td>
<td>
<p>A flag that determines if column names will be output
(equivalent to <code>col.names</code> in <code><a href="utils.html#topic+write.table">write.table()</a></code>).</p>
</td></tr>
<tr><td><code id="write_stream_+3A_row.names">row.names</code></td>
<td>
<p>A flag that determines if row names will be output.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_close">close</code></td>
<td>
<p>close stream after writing.</p>
</td></tr>
<tr><td><code id="write_stream_+3A_...">...</code></td>
<td>
<p>Additional parameters that are passed to <code><a href="utils.html#topic+write.table">write.table()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is no value returned from this operation.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+write.table">write.table</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create data and write 10 points to disk
stream &lt;- DSD_Gaussians(k = 3, d = 5)
stream

write_stream(stream, file="data.txt", n = 10, header = TRUE, info = TRUE)

readLines("data.txt")

# clean up
file.remove("data.txt")

# create a finite stream and write all data to disk using n = -1
stream2 &lt;- DSD_Memory(stream, n = 5)
stream2

write_stream(stream2, file="data.txt", n = -1, header = TRUE, info = TRUE)

readLines("data.txt")

# clean up
file.remove("data.txt")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
