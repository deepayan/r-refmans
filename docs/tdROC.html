<!DOCTYPE html><html><head><title>Help for package tdROC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tdROC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#AUC_calc_integral'><p>Calculate the area under a ROC curve (AUC) by trapezoidal integration</p></a></li>
<li><a href='#AUC.cr'><p>Calculate Time-dependent ROC and AUC with competing risk</p></a></li>
<li><a href='#calc.kw'><p>Calculate Kernel weights</p></a></li>
<li><a href='#mayo'><p>Example data: Mayo Data</p></a></li>
<li><a href='#Melano'><p>Example data: Malignant Melanoma Data</p></a></li>
<li><a href='#plot_tdROC'><p>Plot the time-dependent ROC curve</p></a></li>
<li><a href='#plot_tdROC_cr'><p>Plot the time-dependent ROC curve with competing risk</p></a></li>
<li><a href='#td.kw.cr'><p>Calculate conditional probability of being a case at time tau</p></a></li>
<li><a href='#tdBrier'><p>Calculate the Brier Score</p></a></li>
<li><a href='#tdROC'><p>Estimate time-dependent prediction accuracy measures, including the ROC, AUC, Brier score,</p>
and survival difference, with right-censored survival data.</a></li>
<li><a href='#tdROC.cr'><p>Estimate time-dependent prediction accuracy measures, including the ROC, AUC, Brier score, and survival probability difference, with competing risk data.</p></a></li>
<li><a href='#tdSurvDiff'><p>Calculate the Survival Difference</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Estimation of Time-Dependent ROC, Brier Score, and
Survival Difference from Right Censored Time-to-Event Data with
or without Competing Risks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaoyang Li &lt;xli35@mdanderson.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The tdROC package facilitates the estimation of time-dependent ROC 
    (Receiver Operating Characteristic) curves and the Area Under the time-dependent 
    ROC Curve (AUC) in the context of survival data, accommodating scenarios with 
    right censored data and the option to account for competing risks. In addition 
    to the ROC/AUC estimation, the package also estimates time-dependent Brier score and 
    survival difference. Confidence intervals of various estimated quantities can be 
    obtained from bootstrap. The package also offers plotting functions for visualizing 
    time-dependent ROC curves.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival (&ge; 3.4), graphics (&ge; 4.2.2), stats (&ge; 4.2.2), Rcpp
(&ge; 1.0.10), magrittr (&ge; 2.0.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 07:18:31 UTC; 43770</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaoyang Li [aut, cre],
  Zhe Yin [aut],
  Liang Li [aut, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='AUC_calc_integral'>Calculate the area under a ROC curve (AUC) by trapezoidal integration</h2><span id='topic+AUC_calc_integral'></span>

<h3>Description</h3>

<p>This function reads in a vector of sensitivity and a vector of specificity to calculates
the area under the curve (AUC) by trapezoidal integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC_calc_integral(sens, spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC_calc_integral_+3A_sens">sens</code></td>
<td>
<p>a numerical vector of sensitivity values within the range of (0, 1).</p>
</td></tr>
<tr><td><code id="AUC_calc_integral_+3A_spec">spec</code></td>
<td>
<p>a numerical vector of specificity values within the range of (0, 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns AUC as a numerical scalar.
</p>


<h3>Note</h3>

<p>This function sorts <code>sens</code> and <code>1-spec</code> in an increasing order.
A 0 and 1 will be added to the two ends of the sorted vectors. The Area Under the Curve (AUC) is obtained by trapezoidal
integration of the area under the piecewise linear curve obtained by connecting
points in <code>sens</code> and <code>1-spec</code>.
</p>

<hr>
<h2 id='AUC.cr'>Calculate Time-dependent ROC and AUC with competing risk</h2><span id='topic+AUC.cr'></span>

<h3>Description</h3>

<p>This function calculates the time-dependent sensitivity and specificity and area under the curve (AUC)
using precalculated weights by <code>td.kw.cr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC.cr(X, W.prim, W.cmp, cut.off = NULL, n.grid = 1000, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC.cr_+3A_x">X</code></td>
<td>
<p>a numeric vector of risk score ranging from 0 to 1 in the same length as <code>Y</code> and <code>delta</code>. A higher value indicates higher
higher risk of the event. It can be a biomarker value, a function of multiple value, or the predicted cumulative incidence
probability from a copeting risk regression model that we want to evaluate.</p>
</td></tr>
<tr><td><code id="AUC.cr_+3A_w.prim">W.prim</code></td>
<td>
<p>a numeric vector of weight for the primary event you want to study. It has the same length as <code>X</code>.
It should be generated by <code>td.kw.cr</code> with <code>event.code = 1</code>.</p>
</td></tr>
<tr><td><code id="AUC.cr_+3A_w.cmp">W.cmp</code></td>
<td>
<p>a numeric vector of weight for the competing event. It has the same length as <code>X</code>.
It should be generated by <code>td.kw.cr</code> with <code>event.code = 2</code>.</p>
</td></tr>
<tr><td><code id="AUC.cr_+3A_cut.off">cut.off</code></td>
<td>
<p>a vector of risk score cut-off values at which sensitivity and specificity will be calculated. Default is <code>NULL</code>,
and we set cut off point by  <code>n.grid</code> to calculate sensitivity and specificity.</p>
</td></tr>
<tr><td><code id="AUC.cr_+3A_n.grid">n.grid</code></td>
<td>
<p>a positive integer, the number of grid points used when calculating the ROC curve. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="AUC.cr_+3A_method">method</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>This function read in the risk score value <code>X</code>, estimated conditional probability for primary event <code>W.prim</code>,
and estimated conditional probability for competing event <code>W.cmp</code> to calculate sensitivity and specificity
for a series specified grid points. Based on the definition of controls mentioned in Wu and Li, 2018, we separately
calculate specificity and corresponding AUC for each definition. In addition, this function returns both the
AUC estimated by trapezoidal integration and AUC estimated by nonparametric framework mentioned in Wu and Li, 2018.
</p>


<h3>Value</h3>

<p>Returns a list of the following items:
</p>
<p>a list of <code>AUC.A.integral</code> estimated by trapezoidal integration for definition A,
<code>AUC.A.empirical</code> estimated by nonparametric framework for definition A (Wu and Li, 2018),
<code>AUC.B.integral</code> estimated by trapezoidal integration for definition B,
<code>AUC.B.empirical</code> estimated by nonparametric framework for definition B (Wu and Li, 2018),
and a data frame <code>ROC</code> with dimension <code>(2+n.grid) x 4</code> with columns <code>cut.off</code>, <code>sens</code>, <code>specA</code> and <code>specB</code>.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>
</p>

<hr>
<h2 id='calc.kw'>Calculate Kernel weights</h2><span id='topic+calc.kw'></span>

<h3>Description</h3>

<p>This function calculate the nearest neighbor kernel weights using uniform kernel weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.kw(X, x0, span = 0.1, h = NULL, type = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.kw_+3A_x">X</code></td>
<td>
<p>the vector of biomarker values from other subjects used to calculate the weights around the center x0.</p>
</td></tr>
<tr><td><code id="calc.kw_+3A_x0">x0</code></td>
<td>
<p>a scalar as the center around which the kernel weights are calculated.</p>
</td></tr>
<tr><td><code id="calc.kw_+3A_span">span</code></td>
<td>
<p>a numeric value of the proportion of neighbour observations used, default is 0.1.</p>
</td></tr>
<tr><td><code id="calc.kw_+3A_h">h</code></td>
<td>
<p>a numeric value of the bandwidth of kernel weights, defualt is NULL. If not specified, the function used the value of <code>span</code> to calculate weights.
If both <code>span</code> and <code>h</code> are specified, the function will ignore the span and used bandwidth of kernel function instead.</p>
</td></tr>
<tr><td><code id="calc.kw_+3A_type">type</code></td>
<td>
<p>a character value of the type of kernel function used to calculate kernel weights. Default is &quot;uniform&quot; kernel. Other options are &quot;Epanichnekov&quot; and &quot;normal&quot;.
It will only be used when the bandwidth <code>h</code> is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector of kernel weights for each element in X. It has the same length as X.
</p>


<h3>Note</h3>

<p>X must be the vector of ALL risk score values in the data; it cannot
be any other vector of arbitrary length.
</p>

<hr>
<h2 id='mayo'>Example data: Mayo Data</h2><span id='topic+mayo'></span>

<h3>Description</h3>

<p>This example dataset is included for illustration. The Mayo PBC data is publicly
available and has been used in many statistical researches (e.g., Zheng and Heagerty 2005).
This example dataset is a subset of the full PBC data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mayo)
</code></pre>


<h3>Format</h3>

<p>A data frame with 312 observations and 4 variables:
</p>
<p><code>time</code>: event time or censoring time
</p>
<p><code>censor</code> : censoring indicator.
</p>
<p><code>mayoscore4</code> and <code>mayoscore5</code>: derived from 4 and 5 covariates respectively.
</p>


<h3>References</h3>

<p>Heagerty, P. J., &amp; Zheng, Y. (2005). Survival model predictive accuracy and ROC curves. Biometrics, 61(1), 92-105.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mayo)
head(mayo)
</code></pre>

<hr>
<h2 id='Melano'>Example data: Malignant Melanoma Data</h2><span id='topic+Melano'></span>

<h3>Description</h3>

<p>This example dataset is included for illustration. The Melano data is publicly available.
In 1962-1977, 205 patients with malignant melanoma (skin cancer) had a radical
operation performed at an academic medical center. At the end of the follow-up,
57 died from cancer, 14 died from other causes, and the other 134 patients were
alive (censored). This example dataset illustrates the prediction accuracy of
competing risk outcomes with baseline age and tumor thickness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Melano)
</code></pre>


<h3>Format</h3>

<p>A data frame with 312 observations and 4 variables: time (event time/censoring), time), censor (censoring
mayoscore4, mayoscore5. The two scores are derived from 4 and 5 covariates
respectively.
</p>


<h3>References</h3>

<p>Andersen, P. K. , &amp; Skovgaard, L. T. (2010). Regression with linear predictors. New York, NY: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Melano)
head(Melano)
</code></pre>

<hr>
<h2 id='plot_tdROC'>Plot the time-dependent ROC curve</h2><span id='topic+plot_tdROC'></span>

<h3>Description</h3>

<p>This function reads in object returned by <code>tdROC()</code> and plot ROC curve for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tdROC(
  x,
  lwd = 2,
  xlab = "1-specificity",
  ylab = "sensitivity",
  xlim = c(0, 1),
  ylim = c(0, 1),
  main = "ROC curve",
  col = "black",
  abline = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tdROC_+3A_x">x</code></td>
<td>
<p>the object returned by <code>tdROC()</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_lwd">lwd</code></td>
<td>
<p>user-specified line width. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_xlab">xlab</code></td>
<td>
<p>user-specified label for x-axis. Default is &quot;<code>1-specificity</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_ylab">ylab</code></td>
<td>
<p>user-specified label for y-axis. Default is &quot;<code>sensitivity</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_xlim">xlim</code></td>
<td>
<p>user-specified limit for x axis. Default is <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_ylim">ylim</code></td>
<td>
<p>user-specified limit for y axis. Default is <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_main">main</code></td>
<td>
<p>user-specified title for the plot. Default is &quot;<code>ROC curve</code>&quot;</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_col">col</code></td>
<td>
<p>user-specified color for ROC curve. Defualt is &quot;<code>black</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_abline">abline</code></td>
<td>
<p>user-specified reference diagnol line. Default is <code>True</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_+3A_...">...</code></td>
<td>
<p>for future methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of ROC curve. If the tdROC object comes with bootstrap result,
then the ROC curve will be plotted with confidence interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(mayo)
dat &lt;- mayo[, c("time", "censor", "mayoscore5")]
fm &lt;- tdROC(
  X = dat$mayoscore5, Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05, n.grid = 1000, cut.off = 5:9
)
# plot the object "fm" from tdROC()
plot_tdROC(fm)

</code></pre>

<hr>
<h2 id='plot_tdROC_cr'>Plot the time-dependent ROC curve with competing risk</h2><span id='topic+plot_tdROC_cr'></span>

<h3>Description</h3>

<p>This function reads in object returned by <code>tdROC.cr()</code> and plot ROC curve for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tdROC_cr(
  x,
  lwd = 2,
  xlab = "1-specificity",
  ylab = "sensitivity",
  xlim = c(0, 1),
  ylim = c(0, 1),
  col = c("red", "blue"),
  main = "ROC curve",
  abline = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_tdROC_cr_+3A_x">x</code></td>
<td>
<p>the object returned by <code>tdROC.cr()</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_lwd">lwd</code></td>
<td>
<p>user-specified line width. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_xlab">xlab</code></td>
<td>
<p>user-specified label for x-axis. Default is &quot;<code>1-specificity</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_ylab">ylab</code></td>
<td>
<p>user-specified label for y-axis. Default is &quot;<code>sensitivity</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_xlim">xlim</code></td>
<td>
<p>user-specified limit for x axis. Default is <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_ylim">ylim</code></td>
<td>
<p>user-specified limit for y axis. Default is <code>c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_col">col</code></td>
<td>
<p>user-specified color for ROC curve. Defualt is &quot;<code>c("red", "blue")</code>&quot; for the primary event and competing event.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_main">main</code></td>
<td>
<p>user-specified title for the plot. Default is &quot;<code>ROC curve</code>&quot;</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_abline">abline</code></td>
<td>
<p>user-specified reference diagnol line. Default is <code>True</code>.</p>
</td></tr>
<tr><td><code id="plot_tdROC_cr_+3A_...">...</code></td>
<td>
<p>for future methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns several plots of ROC curve. For competing risk data, there are two definitions of controls introduced by Zheng et al, which was listed below
</p>
<p style="text-align: center;"><code class="reqn">
 \text{Definition A:} \text{Case} k:T \le \tau, \delta = k; \text{Control}_A: (T&gt;\tau)\cup (T \le \tau \cap \delta \ne k)
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \text{Definition B:} \text{Case} k:T \le \tau, \delta = k; \text{Control}_B: (T&gt;\tau)
 </code>
</p>

<p>For more details about above two definitions, please read details of function <code>tdROC.cr</code>.
If the <code>tdROC.cr</code> object comes without bootstrap result, the ROC curve for above two definitions will be plotted together and indicated by the specified <code>col</code>.
If the <code>tdROC.cr</code> object with bootstrap result, one more ROC curve with confidence interval will be plotted for each definition.
</p>


<h3>References</h3>

<p>Zheng Y, Cai T, Jin Y, Feng Z. Evaluating prognostic accuracy of biomarkers under competing risk. Biometrics. 2012;68(2):388-396. doi:10.1111/j.1541-0420.2011.01671.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(Melano)
tdROC.cr_res &lt;- tdROC.cr(
  X = Melano$thick, Y = Melano$time,
  delta = Melano$status, tau = 1800, nboot = 10
)
plot_tdROC_cr(tdROC.cr_res)

</code></pre>

<hr>
<h2 id='td.kw.cr'>Calculate conditional probability of being a case at time tau</h2><span id='topic+td.kw.cr'></span>

<h3>Description</h3>

<p>This is key function to estimate the weight, the conditional probability of being a case at time tau
given the observed time to event, event status, and prognostic risk score, as described in Wu and Li, 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>td.kw.cr(
  X,
  Y,
  delta,
  event.code,
  tau,
  span = 0.1,
  h = NULL,
  type = "uniform",
  epsilon = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="td.kw.cr_+3A_x">X</code></td>
<td>
<p>a numeric vector of risk score for each subject. Higher value of <code>X</code> indicates higher risk of the event.
It can be biomarker, a function of multiple biomarker, or predicted cumulative incidence function by other methods.
Same length with <code>Y</code> and <code>delta</code>.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_y">Y</code></td>
<td>
<p>a numeric vector of time to event. Same length with <code>X</code> and <code>delta</code>.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_delta">delta</code></td>
<td>
<p>a vector of numeric indicator of event type. The primary event you want to study should be coded as 1,
the competing event should be coded as 2, and censoring should be coded as 0. Same length with <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_event.code">event.code</code></td>
<td>
<p>numeric indicator of event (1), or competing event (2), it specifies you are going to calculate the
conditional probability for which event.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_tau">tau</code></td>
<td>
<p>a scalar, the prediction horizon at which the prediction is evaluated.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_span">span</code></td>
<td>
<p>a numeric value, the proportion of neighbour observations used in nearest neighbor method, default is 0.1.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_h">h</code></td>
<td>
<p>a numeric value, the bandwidth of kernel weights, defualt is <code>NULL</code>. If not specified, the function will use the value of
<code>span</code> to calculate kernel weights. In case both <code>span</code> and <code>h</code> are specified, the function will use <code>h</code>.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_type">type</code></td>
<td>
<p>a character value, indicating the type of kernel function used to calculate kernel weights. Default is &quot;<code>uniform</code>&quot; kernel.
Other options are &quot;<code>Epanechnikov</code>&quot; and &quot;<code>normal</code>&quot;.</p>
</td></tr>
<tr><td><code id="td.kw.cr_+3A_epsilon">epsilon</code></td>
<td>
<p>the precision parameter for weight calculation using neighborhood approximation. If not specified, default will be
calculating weights for all right censored points individually.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function read in the risk score value <code>X</code>, the time-to-event data <code>Y</code> and censoring indicator <code>delta</code>
to estimate the weight, the conditional probability of being a case at time tau when there is competing event.
The weight estimation serves for the further prediction accuracy estimation, including AUC, Brier score and so on.
</p>


<h3>Value</h3>

<p>Returns the estimated conditional probability of being a case at time tau for the specified event code.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>
</p>

<hr>
<h2 id='tdBrier'>Calculate the Brier Score</h2><span id='topic+tdBrier'></span>

<h3>Description</h3>

<p>This function reads in a vector of estimated weight and same length biomarker to calculate
Brier Score by formula (Wu and Li, 2018). This function is used internally by other functions
in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdBrier(W, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdBrier_+3A_w">W</code></td>
<td>
<p>a numerical vector of weight estimated by nonparametric weight adjustments (Li <em>et al.</em>, 2015). Same length with <code>X</code>.</p>
</td></tr>
<tr><td><code id="tdBrier_+3A_x">X</code></td>
<td>
<p>a numerical vector of risk score values. Same length with <code>W</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Brier Score as a numerical scalar.
</p>


<h3>Note</h3>

<p>This function estimates brier score by using the formula from Wu and Li, 2018.
</p>

<hr>
<h2 id='tdROC'>Estimate time-dependent prediction accuracy measures, including the ROC, AUC, Brier score,
and survival difference, with right-censored survival data.</h2><span id='topic+tdROC'></span>

<h3>Description</h3>

<p>This is a core function of the ‘tdROC‘ package. It uses the nonparametric weights proposed by Li (Li et al., 2015)
to estimate a number of time-dependent prediction accuracy measures for right-censored survival outcomes,
including ROC curve, AUC, Brier score, and survival difference. For each measure, the variance can be estimated
through bootstrap resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdROC(
  X,
  Y,
  delta,
  tau,
  span = 0.1,
  h = NULL,
  type = "uniform",
  n.grid = 1000,
  X.min = NULL,
  X.max = NULL,
  cut.off = NULL,
  nboot = 0,
  alpha = 0.05,
  epsilon = NULL,
  method = "both",
  output = "both"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdROC_+3A_x">X</code></td>
<td>
<p>a numeric vector of risk score in the same length as <code>Y</code> and <code>delta</code>, such as biomarker or predicted probability. A higher value indicates higher risk of the event.
The calibration results (Brier score, survival difference) are applicable only when the risk score has the predicted probability interpretation.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_y">Y</code></td>
<td>
<p>a numeric vector of time to event in the same length as <code>X</code> and <code>delta</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_delta">delta</code></td>
<td>
<p>a vector of binary indicator of event (1) or censoring (0) in the same length as <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_tau">tau</code></td>
<td>
<p>a scalar, the prediction horizon at which the prediction is evaluated.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_span">span</code></td>
<td>
<p>a numeric value, the proportion of neighbour observations used in nearest neighbor method, default to 0.1.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_h">h</code></td>
<td>
<p>a numeric value, the bandwidth of kernel weights, the defualt is <code>NULL</code>. If not specified, the function will use the value of
<code>span</code> to calculate kernel weights. In case both <code>span</code> and <code>h</code> are specified, the function will use <code>h</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_type">type</code></td>
<td>
<p>a character value, indicating the type of kernel function used to calculate kernel weights. The default is <code>"uniform"</code> kernel. Other options are <code>"Epanechnikov"</code> and <code>"normal"</code>.
It will only be used when the bandwidth <code>h</code> is specified.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_n.grid">n.grid</code></td>
<td>
<p>a positive integer, the number of grid points used when calculating the ROC curve. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_x.min">X.min</code></td>
<td>
<p>the lower boundary of grid cut-off points for biomarker <code>X</code>. The default is the minimum of <code>X</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_x.max">X.max</code></td>
<td>
<p>the upper boundary of grid cut-off points for biomarker <code>X</code>. The default is the maximum of <code>X</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_cut.off">cut.off</code></td>
<td>
<p>a vector of <code>X</code> cut-off values at which sensitivity and specificity will be calculated.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap replications to be used for variance estimation. The default is <code>nboot = 0</code>, corresponding to no variance estimation.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_alpha">alpha</code></td>
<td>
<p>It is (1 - level of confidence interval)/2, default is <code>0.05</code>. It is used only when <code>nboot &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_epsilon">epsilon</code></td>
<td>
<p>The precision parameter used in an approximation to the weight calculation when the sample size is large. If a weight corresponding to a specific risk score is already calculated,
then the weights corresponding to adjacent risk scores, within the distance specified by epsilon, will be the same under the approximation. This approximation avoids repeated
calculation of weights that are almost the same, and hence increases the speed of computation in this situation. The default is NULL, which means no approximation is used. A higher
value indicates less precision.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_method">method</code></td>
<td>
<p>It is used to specify which method you would like to use to estimate AUC, default to <code>"both"</code>. Other options are <code>"integral"</code> and <code>"empirical"</code>.</p>
</td></tr>
<tr><td><code id="tdROC_+3A_output">output</code></td>
<td>
<p>It is used to specify which kind of output you want, default to <code>"both"</code>. Other options are <code>"AUC"</code>, including AUC, sensitivity, and specificity are included,
and <code>"calibration"</code> including Brier Score and survival difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the risk score value <code>X</code>, the time-to-event data <code>Y</code> and censoring indicator <code>delta</code> as input to estimate
a number of time-dependent prediction accuracy measures for right-censored survival outcomes, including ROC curve, AUC, Brier score, and survival difference.
The confidence intervals of above quantities will be estimated by bootstrap.
</p>
<p>This function offer two options to estimate AUC. The first one make use of estimated sensitivity and specificity to calculate the AUC via trapezoidal integration
by setting a series of cutoff point. The output will also include corresponding sensitivity and specificity for our plot function. The other one estimate AUC by the empirical estimator
of the proportion of concordance pairs with proposed weight estimator (Li et al, 2015). These two methods will generate quite similar estimates. The option can be set by argument <code>method</code>.
</p>
<p>We also include Brier Score and survival difference to evaluate the calibration metrics. Their definitions are included below.
They can be estimated with the proposed conditional probability weight (Wu and Li, 2018).
Both of them are measures to assess the accuracy of probabilistic predictions <code>X</code>. The calibration result makes sense only
when the risk score <code>X</code> is a predicted probability, and should be ignored otherwise.
</p>
<p style="text-align: center;"><code class="reqn">
 \text{Brier Score} = E{[1(T \le \tau, \delta = 1) - X]^2}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \text{Survival difference} = E[1(T \le \tau, \delta = 1) - X]
 </code>
</p>

<p>As mentioned in arguments, we introduced a small precision parameter <code>epsilon</code> to speed up the computation when the sample size is large.
For each subject with a risk score, <code class="reqn">X_i</code>, we assess whether there exists a previously processed grid point, <code class="reqn">X_{grid,m}</code> where <code class="reqn">1\le m \le j</code>,
within the proximity of <code class="reqn">X_i</code> such that <code class="reqn">|X_i - X_{grid,m}| &lt; \epsilon</code>. In the absence of such a point, we designate <code class="reqn">X_i</code> as a new grid point,
<code class="reqn">X_{grid,j+1}</code>, and store the corresponding <code>survfit</code> object for subsequent weight estimation and mark it as a processed grid point. Conversely,
if a previously processed grid point is found, we directly utilize the stored <code>survfit</code> object associated with it for weight calculation.
Given that the most time-consuming step in our estimation process is the <code>survfit</code> computation, this method significantly reduces computing time
without incurring notable bias especially when dealing with large sample sizes.
</p>


<h3>Value</h3>

<p>Returns a list of the following items:
</p>
<p><code>main_res:</code> a list of <code>AUC.integral</code> estimated by trapezoidal integration, <code>AUC.empirical</code> estimated by empirical estimator of the proportion of concordance pairs.
and a data frame <code>ROC</code> with dimension <code>(2+n.grid) x 3</code> with columns <code>cut.off</code>, <code>sens</code>, and <code>spec</code>.
</p>
<p><code>calibration_res:</code> brier score and survival difference estimated based on the formula similar to Wu and Li (2018). When the risk score <code>X</code>
is a biomarker value instead of a predicted cumulative incidence probability, the brier score and survival difference cannot be calculated. In this case, please disregard the calibration results.
</p>
<p><code>boot_res:</code> a list of bootstrap results, including <code>bAUC</code>, <code>bAUC2</code>, <code>bBS</code>, <code>bSurvDiff</code>, <code>bROC</code>.
For <code>bAUC</code>, <code>bAUC2</code>, <code>bBS</code>, <code>bSurvDiff</code>, each one is a list including corresponding mean, standard deviation, and confidence interval.
<code>bROC</code> is a data frame with colomns <code>sens.mean</code>, <code>sens.sd</code>, <code>sens.lower</code>, <code>sens.upper</code>, <code>spec.mean</code>, <code>spec.sd</code>, <code>spec.lower</code>, <code>spec.upper</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(mayo)
dat &lt;- mayo[, c("time", "censor", "mayoscore5")]
fm &lt;- tdROC(
  X = dat$mayoscore5, Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9
)
# In the following example, We use biomarker mayoscore5 to estimate predicted probability
# tipycally a monotone transformation function such as expit() is used to transform biomarker
# with range out of range into estimated probability between 0 and 1
expit &lt;- function(x){ 1/(1+exp(-x)) }

tdROC(
  X = expit(dat$mayoscore5), Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9
)

tdROC(
  X = expit(dat$mayoscore5), Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9, epsilon = 0.05
)


</code></pre>

<hr>
<h2 id='tdROC.cr'>Estimate time-dependent prediction accuracy measures, including the ROC, AUC, Brier score, and survival probability difference, with competing risk data.</h2><span id='topic+tdROC.cr'></span>

<h3>Description</h3>

<p>This is a core function of the ‘tdROC‘ package. It uses the nonparametric weights proposed by Wu (Wu and Li, 2018)
to estimate a number of time-dependent prediction accuracy measures for right-censored survival outcomes,
including ROC curve, AUC, Brier score, and survival difference, with competing risk data. For each measure, the variance can be estimated
through bootstrap resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdROC.cr(
  X,
  Y,
  delta,
  tau,
  span = 0.1,
  h = NULL,
  type = "uniform",
  epsilon = 0.01,
  cut.off = NULL,
  n.grid = 1000,
  nboot = 0,
  alpha = 0.05,
  method = "both",
  output = "both"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdROC.cr_+3A_x">X</code></td>
<td>
<p>a numeric vector of risk score in the same length as <code>Y</code> and <code>delta</code>, such as biomarker or predicted probability. A higher value indicates higher risk of the event.
The calibration results (Brier score, survival difference) are applicable only when the risk score has the predicted probability interpretation.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_y">Y</code></td>
<td>
<p>a numeric vector of time to event in the same length as <code>X</code> and <code>delta</code>.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_delta">delta</code></td>
<td>
<p>a vector of numeric indicator of event type in the same length as <code>X</code> and <code>Y</code>. The primary event should be coded as 1,
the competing event should be coded as 2, and censoring should be coded as 0.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_tau">tau</code></td>
<td>
<p>a scalar, the prediction horizon at which the prediction is evaluated.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_span">span</code></td>
<td>
<p>a numeric value, the proportion of neighbour observations used in nearest neighbor method. The default is 0.1.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_h">h</code></td>
<td>
<p>a numeric value, the bandwidth of kernel weights, the defualt is <code>NULL</code>. If not specified, the function will use the value of
<code>span</code> to calculate kernel weights. In case both <code>span</code> and <code>h</code> are specified, the function will use <code>h</code>.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_type">type</code></td>
<td>
<p>a character value, indicating the type of kernel function used to calculate kernel weights. The default is <code>"uniform"</code> kernel. Other options are <code>"Epanechnikov"</code> and <code>"normal"</code>.
It will only be used when the bandwidth <code>h</code> is specified.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_epsilon">epsilon</code></td>
<td>
<p>The precision parameter used in an approximation to the weight calculation when the sample size is large. If a weight corresponding to a specific risk score is already calculated,
then the weights corresponding to adjacent risk scores, within the distance specified by epsilon, will be the same under the approximation. This approximation avoids repeated
calculation of weights that are almost the same, and hence increases the speed of computation in this situation. The default is NULL, which means no approximation is used. A higher
value indicates less precision.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_cut.off">cut.off</code></td>
<td>
<p>a vector of <code>X</code> cut-off values at which sensitivity and specificity will be calculated.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_n.grid">n.grid</code></td>
<td>
<p>a positive integer, the number of grid points used when calculating the ROC curve. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap replications to be used for variance estimation. The default is <code>nboot = 0</code>, corresponding to no variance estimation.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_alpha">alpha</code></td>
<td>
<p>It is (1 - level of confidence interval)/2, default is <code>0.05</code>. It is used only when <code>nboot &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_method">method</code></td>
<td>
<p>It is used to specify which method you would like to use to estimate AUC, default to <code>"both"</code>. Other options are <code>"integral"</code> and <code>"empirical"</code>.</p>
</td></tr>
<tr><td><code id="tdROC.cr_+3A_output">output</code></td>
<td>
<p>It is used to specify which kind of output you want, default to <code>"both"</code>. Other options are <code>"AUC"</code>, including AUC, sensitivity, and specificity are included,
and <code>"calibration"</code> including Brier Score and survival difference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the risk score value <code>X</code>, the time-to-event data <code>Y</code> and censoring indicator <code>delta</code> as input to estimate
a number of time-dependent prediction accuracy measures for survival outcomes, including ROC curve, AUC, Brier score, and survival difference, with competing risk.
The confidence intervals of above quantities are estimated by bootstrap.
</p>
<p>For competing risk data, there are two definition of controls introduced by Zheng et al, which are listed below
</p>
<p style="text-align: center;"><code class="reqn">
 \text{Definition A:} \text{Case} k:T \le \tau, \delta = k; \text{Control}_A: (T&gt;\tau)\cup (T \le \tau \cap \delta \ne k)
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \text{Definition B:} \text{Case} k:T \le \tau, \delta = k; \text{Control}_B: (T&gt;\tau)
 </code>
</p>

<p>Based on the definition A, both the event-free subjects and subjects who experience other competing events were included as controls. While definition B include only event-free subjects.
This function offers two options to estimate AUC. The first one make use of estimated sensitivity and specificity to calculate the AUC via trapezoidal integration
by setting a series of cutoff point. For the two different definition, we separately calculate the sensitivity, specificity and AUC. The output will also include the sensitivities
and specificities for our plot function. The other one estimates AUC by the empirical estimator of the proportion of concordance pairs with proposed weight estimator (Wu and Li, 2018).
These two methods generate quite similar estimates. The option can be set by the argument <code>method</code>.
</p>
<p>In addition to the above prediction measures, we include Brier Score and survival difference to evaluate the calibration metrics. Their definitions are included below.
They can be estimated with the proposed conditional probability weight (Wu and Li, 2018).
Both of them are measures to assess the accuracy of probabilistic predictions <code>X</code>. The calibration result makes sense only
when the risk score <code>X</code> is a predicted probability, and should be ignored otherwise.
</p>
<p style="text-align: center;"><code class="reqn">
 \text{Brier Score} = E{[1(T \le \tau, \delta = 1) - X]^2}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \text{Survival difference} = E[1(T \le \tau, \delta = 1) - X]
 </code>
</p>

<p>This function uses the same approximation as <code>tdROC</code> with the argument <code>epsilon</code>
</p>


<h3>Value</h3>

<p>Returns a list of the following items:
</p>
<p><code>main_res:</code> a list of <code>AUC.A.integral</code> estimated by trapezoidal integration for definition A,
<code>AUC.A.empirical</code> estimated by empirical estimator for definition A,
<code>AUC.B.integral</code> estimated by trapezoidal integration for definition B,
<code>AUC.B.empirical</code> estimated by empirical estimator for definition B,
and a data frame <code>ROC</code> with dimension <code>(2+n.grid) x 4</code> with columns <code>cut.off</code>, <code>sens</code>, <code>specA</code> and <code>specB</code>.
</p>
<p><code>calibration_res:</code> brier score and survival difference estimated based on the formula similar to Wu and Li (2018). When the risk score <code>X</code>
is a biomarker value instead of a predicted cumulative incidence probability, the brier score and survival difference cannot be calculated. In this case, please disregard the calibration results.
</p>
<p><code>boot_res:</code> a list of bootstrap results, including <code>bAUC.A.integral</code>, <code>bAUC.A.empirical</code>,  <code>bAUC.B.integral</code>, <code>bAUC.B.empirical</code>, <code>bBS</code>, <code>bSurvDiff</code>, <code>bROC</code>.
For <code>bAUC.A.integral</code>, <code>bAUC.A.empirical</code>,  <code>bAUC.B.integral</code>, <code>bAUC.B.empirical</code>, <code>bBS</code>, <code>bSurvDiff</code>, each one is a list including corresponding mean, standard deviation, confidence interval.
<code>bROC</code> is a data frame with colomns <code>sens.mean</code>, <code>sens.sd</code>, <code>sens.lower</code>, <code>sens.upper</code>,
<code>specA.mean</code>, <code>specA.sd</code>, <code>specA.lower</code>, <code>specA.upper</code>, <code>specB.mean</code>, <code>specB.sd</code>, <code>specB.lower</code>, <code>specB.upper</code>
</p>


<h3>References</h3>

<p>Zheng Y, Cai T, Jin Y, Feng Z. Evaluating prognostic accuracy of biomarkers under competing risk. Biometrics. 2012;68(2):388-396. doi:10.1111/j.1541-0420.2011.01671.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(Melano)
expit &lt;- function(x){ 1/(1+exp(-x)) }
tdROC.cr(X = expit(Melano$thick) , Y = Melano$time, delta = Melano$status, tau = 1800, nboot = 10)

</code></pre>

<hr>
<h2 id='tdSurvDiff'>Calculate the Survival Difference</h2><span id='topic+tdSurvDiff'></span>

<h3>Description</h3>

<p>This function reads in a vector of estimated weight and same length risk score to calculate
survival difference by formula (Wu and Li, 2018).This function is used internally by other functions
in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdSurvDiff(W, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdSurvDiff_+3A_w">W</code></td>
<td>
<p>a numerical vector of weight estimated by nonparametric weight adjustments (Li <em>et al.</em>, 2015). Same length with <code>X</code>.</p>
</td></tr>
<tr><td><code id="tdSurvDiff_+3A_x">X</code></td>
<td>
<p>a numerical vector of risk score values. Same length with <code>W</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Survival difference as a numerical scalar.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
