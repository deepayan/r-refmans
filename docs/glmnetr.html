<!DOCTYPE html><html><head><title>Help for package glmnetr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmnetr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aicreg'><p>Identify model based upon AIC criteria from a stepreg() putput</p></a></li>
<li><a href='#ann_tab_cv'><p>Fit an Artificial Neural Network model on &quot;tabular&quot; provided as a matrix, optionally</p>
allowing for an offset term</a></li>
<li><a href='#ann_tab_cv_best'><p>Fit multiple Artificial Neural Network models on &quot;tabular&quot; provided as a matrix, and</p>
keep the best one.</a></li>
<li><a href='#best.preds'><p>Get the best models for the steps of a stepreg() fit</p></a></li>
<li><a href='#boot.factor.foldid'><p>Generate foldid's by 0/1 factor for bootstrap like samples where unique option between 0 and 1</p></a></li>
<li><a href='#calceloss'><p>calculate cross-entry for multinomial outcomes</p></a></li>
<li><a href='#calplot'><p>Construct calibration plots for a nested.glmnetr output object</p></a></li>
<li><a href='#cox.sat.dev'><p>Calculate the CoxPH saturated log-likelihood</p></a></li>
<li><a href='#cv.glmnetr'><p>Get a cross validation informed relaxed lasso model fit.</p></a></li>
<li><a href='#cv.stepreg'><p>Cross validation informed stepwise regression model fit.</p></a></li>
<li><a href='#devrat_'><p>Calculate deviance ratios for CV based</p></a></li>
<li><a href='#diff_time'><p>Output to console the elapsed and split times</p></a></li>
<li><a href='#diff_time1'><p>Get elapsed time in c(hour, minute, secs)</p></a></li>
<li><a href='#factor.foldid'><p>Generate foldid's by factor levels</p></a></li>
<li><a href='#get.foldid'><p>Get foldid's with branching for cox, binomial and gaussian models</p></a></li>
<li><a href='#glmnetr'><p>Fit relaxed part of lasso model</p></a></li>
<li><a href='#glmnetr_seed'><p>Get seeds to store, facilitating replicable results</p></a></li>
<li><a href='#glmnetr.cis'><p>A redirect to nested.cis()</p></a></li>
<li><a href='#glmnetr.compcv'><p>A redirect to nested.compare</p></a></li>
<li><a href='#glmnetr.simdata'><p>Generate example data</p></a></li>
<li><a href='#nested.cis'><p>Calculate performance measure CI's and p's</p></a></li>
<li><a href='#nested.compare'><p>Compare cross validation fit performances from a nested.glmnetr output.</p></a></li>
<li><a href='#nested.glmnetr'><p>Using (nested) cross validation, describe and compare some machine learning model performances</p></a></li>
<li><a href='#orf_tune'><p>Fit a Random Forest model on data provided in matrix and vector formats.</p></a></li>
<li><a href='#plot_perf_glmnetr'><p>Plot nested cross validation performance summaries</p></a></li>
<li><a href='#plot.cv.glmnetr'><p>Plot cross-validation deviances, or model coefficients.</p></a></li>
<li><a href='#plot.glmnetr'><p>Plot the relaxed lasso coefficients.</p></a></li>
<li><a href='#plot.nested.glmnetr'><p>Plot results from a nested.glmnetr() output</p></a></li>
<li><a href='#predict_ann_tab'><p>Get predicteds for an Artificial Neural Network model fit in nested.glmnetr()</p></a></li>
<li><a href='#predict.cv.glmnetr'><p>Give predicteds based upon a cv.glmnetr() output object.</p></a></li>
<li><a href='#predict.cv.stepreg'><p>Beta's or predicteds based upon a cv.stepreg() output object.</p></a></li>
<li><a href='#predict.glmnetr'><p>Get predicteds or coefficients using a glmnetr output object</p></a></li>
<li><a href='#predict.nested.glmnetr'><p>Give predicteds based upon the cv.glmnet output object contained in the</p>
nested.glmnetr output object.</a></li>
<li><a href='#print.nested.glmnetr'><p>A redirect to the summary() function for nested.glmnetr() output objects</p></a></li>
<li><a href='#print.orf_tune'><p>Print output from orf_tune() function</p></a></li>
<li><a href='#print.rf_tune'><p>Print output from rf_tune() function</p></a></li>
<li><a href='#rederive_orf'><p>Rederive Oblique Random Forest models not kept in nested.glmnetr() output</p></a></li>
<li><a href='#rederive_rf'><p>Rederive Random Forest models not kept in nested.glmnetr() output</p></a></li>
<li><a href='#rederive_xgb'><p>Rederive XGB models not kept in nested.glmnetr() output</p></a></li>
<li><a href='#rf_tune'><p>Fit a Random Forest model on data provided in matrix and vector formats.</p></a></li>
<li><a href='#roundperf'><p>round elements of a summary.glmnetr() output</p></a></li>
<li><a href='#stepreg'><p>Fit the steps of a stepwise regression.</p></a></li>
<li><a href='#summary.cv.glmnetr'><p>Output summary of a cv.glmnetr() output object.</p></a></li>
<li><a href='#summary.cv.stepreg'><p>Summarize results from a cv.stepreg() output object.</p></a></li>
<li><a href='#summary.nested.glmnetr'><p>Summarize a nested.glmnetr() output object</p></a></li>
<li><a href='#summary.orf_tune'><p>Summarize output from rf_tune() function</p></a></li>
<li><a href='#summary.rf_tune'><p>Summarize output from rf_tune() function</p></a></li>
<li><a href='#summary.stepreg'><p>Briefly summarize steps in a stepreg() output object, i.e. a stepwise regression fit</p></a></li>
<li><a href='#xgb.simple'><p>Get a simple XGBoost model fit (no tuning)</p></a></li>
<li><a href='#xgb.tuned'><p>Get a tuned XGBoost model fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Nested Cross Validation for the Relaxed Lasso and Other Machine
Learning Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, survival, Matrix, xgboost, smoof, mlrMBO,
ParamHelpers, randomForestSRC, rpart, torch, aorsf,
DiceKriging, rgenoud</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Walter K Kremers <a href="https://orcid.org/0000-0001-5714-3473"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nicholas B Larson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Walter K Kremers &lt;kremers.walter@mayo.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Cross validation informed Relaxed LASSO, Artificial Neural Network (ANN), gradient boosting machine ('xgboost'), Random Forest ('RandomForestSRC'), Oblique Random Forest ('aorsf'), Recursive Partitioning ('RPART') or step wise regression models are fit.  Cross validation leave out samples (leading to nested cross validation) or bootstrap out-of-bag samples are used to evaluate and compare performances between these models with results presented in tabular or graphical means.  Calibration plots can also be generated, again based upon (outer nested) cross validation or bootstrap leave out (out of bag) samples. 
    For some datasets, for example when the design matrix is not of full rank, 'glmnet' may have very long run times when fitting the relaxed lasso model, from our experience when fitting Cox models on data with many predictors and many patients, making it difficult to get solutions from either glmnet() or cv.glmnet().  This may be remedied by using the 'path=TRUE' option when calling glmnet() and cv.glmnet().  Within the glmnetr package the approach of path=TRUE is taken by default. 
    When fitting not a relaxed lasso model but an elastic-net model, then the R-packages 'nestedcv' <a href="https://cran.r-project.org/package=nestedcv">https://cran.r-project.org/package=nestedcv</a>, 'glmnetSE' <a href="https://cran.r-project.org/package=glmnetSE">https://cran.r-project.org/package=glmnetSE</a> or others may provide greater functionality when performing a nested CV. 
    Use of the 'glmnetr' has many similarities to the 'glmnet' package and it is recommended that the user of 'glmnetr' also become familiar with the 'glmnet' package <a href="https://cran.r-project.org/package=glmnet">https://cran.r-project.org/package=glmnet</a>, with the "An Introduction to 'glmnet'" and "The Relaxed Lasso" being especially useful in this regard. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Mayo Foundation for Medical Education and Research</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-12 03:51:08 UTC; kremers.walter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-12 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aicreg'>Identify model based upon AIC criteria from a stepreg() putput</h2><span id='topic+aicreg'></span>

<h3>Description</h3>

<p>Identify model based upon AIC criteria from a stepreg() putput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aicreg(
  xs,
  start,
  y_,
  event,
  steps_n = steps_n,
  family = family,
  object = NULL,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aicreg_+3A_xs">xs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="aicreg_+3A_start">start</code></td>
<td>
<p>start time, Cox model only - class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="aicreg_+3A_y_">y_</code></td>
<td>
<p>output vector: time, or stop time for Cox model, y_ 0 or 1 for binomial (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="aicreg_+3A_event">event</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="aicreg_+3A_steps_n">steps_n</code></td>
<td>
<p>maximum number of steps done in stepwise regression fitting</p>
</td></tr>
<tr><td><code id="aicreg_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="aicreg_+3A_object">object</code></td>
<td>
<p>A stepreg() output.  If NULL it will be derived.</p>
</td></tr>
<tr><td><code id="aicreg_+3A_track">track</code></td>
<td>
<p>Indicate whether or not to update progress in the console.  Default of
0 suppresses these updates.  The option of 1 provides these updates.  In fitting 
clinical data with non full rank design matrix we have found some R-packages to
take a very long time or possibly get caught in infinite loops.  Therefore we allow
the user to track the package and judge whether things are moving forward or 
if the process should be stopped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The identified model in form of a glm() or coxph() output object, with an 
entry of the stepreg() output object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepreg">stepreg</a></code> , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(18306296)
sim.data=glmnetr.simdata(nrows=100, ncols=100, beta=c(0,1,1))
# this gives a more intersting case but takes longer to run
xs=sim.data$xs           
# this will work numerically
xs=sim.data$xs[,c(2,3,50:55)] 
y_=sim.data$yt  
event=sim.data$event
cox.aic.fit = aicreg(xs, NULL, y_, event, family="cox", steps_n=40) 
summary(cox.aic.fit)

y_=sim.data$yt  
norm.aic.fit = aicreg(xs, NULL, y_, NULL, family="gaussian", steps_n=40) 
summary(norm.aic.fit)

</code></pre>

<hr>
<h2 id='ann_tab_cv'>Fit an Artificial Neural Network model on &quot;tabular&quot; provided as a matrix, optionally 
allowing for an offset term</h2><span id='topic+ann_tab_cv'></span>

<h3>Description</h3>

<p>Fit an Artificial Neural Network model for analysis of &quot;tabular&quot; data.  The 
model has two hidden layers where the number of terms in each layer is configurable 
by the user.  The activation function can also be switched between relu() (default) 
gelu() or sigmoid().  Optionally an offset term may be included. Model &quot;family&quot; may 
be &quot;cox&quot; to fit a generalization of the Cox proportional hazards model, &quot;binomial&quot; 
to fit a generalization of the logistic regression model and &quot;gaussian&quot; to fit a 
generalization of linear regression model for a quantitative response.  See the 
corresponding vignette for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ann_tab_cv(
  myxs,
  mystart = NULL,
  myy,
  myevent = NULL,
  myoffset = NULL,
  family = "binomial",
  fold_n = 5,
  epochs = 200,
  eppr = 40,
  lenz1 = 16,
  lenz2 = 8,
  actv = 1,
  drpot = 0,
  mylr = 0.005,
  wd = 0,
  l1 = 0,
  lasso = 0,
  lscale = 5,
  scale = 1,
  resetlw = 1,
  minloss = 1,
  gotoend = 0,
  seed = NULL,
  foldid = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ann_tab_cv_+3A_myxs">myxs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_mystart">mystart</code></td>
<td>
<p>an optional vector of start times in case of a Cox model. Class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_myy">myy</code></td>
<td>
<p>dependent variable as a vector: time, or stop time for Cox model, Y_ 0 or 1 for binomial (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_myevent">myevent</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_myoffset">myoffset</code></td>
<td>
<p>an offset term to be used when fitting the ANN.  Not yet implemented 
in its pure form.  Functionally an offset can be included in the first column
of the predictor or feature matrix myxs and indicated as such using the lasso option.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_fold_n">fold_n</code></td>
<td>
<p>number of folds for each level of cross validation</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_epochs">epochs</code></td>
<td>
<p>number of epochs to run when tuning on number of epochs for fitting 
final model number of epochs informed by cross validation</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_eppr">eppr</code></td>
<td>
<p>for EPoch PRint.  print summary info every eppr epochs. 0 will 
print first and last epochs, 0 for first and last epoch, -1 for minimal and -2 for none.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_lenz1">lenz1</code></td>
<td>
<p>length of the first hidden layer in the neural network, default 16</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_lenz2">lenz2</code></td>
<td>
<p>length of the second hidden layer in the neural network, default 16</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_actv">actv</code></td>
<td>
<p>for ACTiVation function.  Activation function between layers, 
1 for relu, 2 for gelu, 3 for sigmoid.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_drpot">drpot</code></td>
<td>
<p>fraction of weights to randomly zero out.  NOT YET implemented.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_mylr">mylr</code></td>
<td>
<p>learning rate for the optimization step in the neural network model fit</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_wd">wd</code></td>
<td>
<p>a possible weight decay for the model fit, default 0 for not considered</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_l1">l1</code></td>
<td>
<p>a possible L1 penalty weight for the model fit, default 0 for not considered</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_lasso">lasso</code></td>
<td>
<p>1 to indicate the first column of the input matrix is an offset 
term, often derived from a lasso model, else 0 (default)</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_lscale">lscale</code></td>
<td>
<p>Scale used to allow ReLU to exend +/- lscale before capping the 
inputted linear estimated</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_scale">scale</code></td>
<td>
<p>Scale used to transform the inital random paramter assingments by 
dividing by scale</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_resetlw">resetlw</code></td>
<td>
<p>1 as default to re-adjust weights to account for the offset every 
epoch.  This is only used in case lasso is set to 1.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_minloss">minloss</code></td>
<td>
<p>default of 1 for minimizing loss, else maximizing agreement (concordance 
for Cox and Binomial, R-square for Gaussian), as function of epochs by cross validaition</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_gotoend">gotoend</code></td>
<td>
<p>fit to the end of epochs.  Good for plotting and exploration</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_seed">seed</code></td>
<td>
<p>an optional a numerical/integer vector of length 2, for R and torch 
random generators, default NULL to generate these.  Integers should be positive 
and not more than 2147483647.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_+3A_foldid">foldid</code></td>
<td>
<p>a vector of integers to associate each record to a fold.  Should 
be integers from 1 and fold_n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an artificial neural network model fit
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ann_tab_cv_best">ann_tab_cv_best</a></code> , <code><a href="#topic+predict_ann_tab">predict_ann_tab</a></code>, <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='ann_tab_cv_best'>Fit multiple Artificial Neural Network models on &quot;tabular&quot; provided as a matrix, and 
keep the best one.</h2><span id='topic+ann_tab_cv_best'></span>

<h3>Description</h3>

<p>Fit an multiple Artificial Neural Network models for analysis of &quot;tabular&quot; 
data using ann_tab_cv() and select the best fitting model according to cross
validaiton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ann_tab_cv_best(
  myxs,
  mystart = NULL,
  myy,
  myevent = NULL,
  myoffset = NULL,
  family = "binomial",
  fold_n = 5,
  epochs = 200,
  eppr = 40,
  lenz1 = 32,
  lenz2 = 8,
  actv = 1,
  drpot = 0,
  mylr = 0.005,
  wd = 0,
  l1 = 0,
  lasso = 0,
  lscale = 5,
  scale = 1,
  resetlw = 1,
  minloss = 1,
  gotoend = 0,
  bestof = 10,
  seed = NULL,
  foldid = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ann_tab_cv_best_+3A_myxs">myxs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_mystart">mystart</code></td>
<td>
<p>an optional vector of start times in case of a Cox model. Class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_myy">myy</code></td>
<td>
<p>dependent variable as a vector: time, or stop time for Cox model, Y_ 0 or 1 for binomial (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_myevent">myevent</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_myoffset">myoffset</code></td>
<td>
<p>an offset term to be ues when fitting the ANN.  Not yet implemented.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_fold_n">fold_n</code></td>
<td>
<p>number of folds for each level of cross validation</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_epochs">epochs</code></td>
<td>
<p>number of epochs to run when tuning on number of epochs for fitting 
final model number of epochs informed by cross validation</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_eppr">eppr</code></td>
<td>
<p>for EPoch PRint.  print summry info every eppr epochs. 0 will 
print first and last epochs, -1 nothing.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_lenz1">lenz1</code></td>
<td>
<p>length of the first hidden layer in the neural network, default 16</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_lenz2">lenz2</code></td>
<td>
<p>length of the second hidden layer in the neural network, default 16</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_actv">actv</code></td>
<td>
<p>for ACTiVation function.  Activation function between layers, 
1 for relu, 2 for gelu, 3 for sigmoid.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_drpot">drpot</code></td>
<td>
<p>fraction of weights to randomly zero out.  NOT YET implemented.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_mylr">mylr</code></td>
<td>
<p>learning rate for the optimization step in teh neural network model fit</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_wd">wd</code></td>
<td>
<p>weight decay for the model fit.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_l1">l1</code></td>
<td>
<p>a possible L1 penalty weight for the model fit, default 0 for not considered</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_lasso">lasso</code></td>
<td>
<p>1 to indicate the first column of the input matrix is an offset 
term, often derived from a lasso model</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_lscale">lscale</code></td>
<td>
<p>Scale used to allow ReLU to extend +/- lscale before capping the 
inputted linear estimated</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_scale">scale</code></td>
<td>
<p>Scale used to transform the initial random parameter assingments by 
dividing by scale</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_resetlw">resetlw</code></td>
<td>
<p>1 as default to re-adjust weights to account for the offset every 
epoch.  This is only used in case lasso is set to 1</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_minloss">minloss</code></td>
<td>
<p>default of 1 for minimizing loss, else maximizing agreement (concordance 
for Cox and Binomial, R-square for Gaussian), as function of epochs by cross validation</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_gotoend">gotoend</code></td>
<td>
<p>fit to the end of epochs.  Good for plotting and exploration</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_bestof">bestof</code></td>
<td>
<p>how many models to run, from which the best fitting model will be selected.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_seed">seed</code></td>
<td>
<p>an optional a numerical/integer vector of length 2, for R and torch 
random generators, default NULL to generate these.  Integers should be positive 
and not more than 2147483647.</p>
</td></tr>
<tr><td><code id="ann_tab_cv_best_+3A_foldid">foldid</code></td>
<td>
<p>a vector of integers to associate each record to a fold.  Should 
be integers from 1 and fold_n.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an artificial neural network model fit
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ann_tab_cv">ann_tab_cv</a></code> , <code><a href="#topic+predict_ann_tab">predict_ann_tab</a></code>, <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='best.preds'>Get the best models for the steps of a stepreg() fit</h2><span id='topic+best.preds'></span>

<h3>Description</h3>

<p>Get the best models for the steps of a stepreg() fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.preds(modsum, risklist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.preds_+3A_modsum">modsum</code></td>
<td>
<p>model summmary</p>
</td></tr>
<tr><td><code id="best.preds_+3A_risklist">risklist</code></td>
<td>
<p>riskset list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>best predictors at each step of a stepwise regression
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepreg">stepreg</a></code> , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='boot.factor.foldid'>Generate foldid's by 0/1 factor for bootstrap like samples where unique option between 0 and 1</h2><span id='topic+boot.factor.foldid'></span>

<h3>Description</h3>

<p>Generate foldid's by 0/1 factor for bootstrap like samples where unique option between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.factor.foldid(event, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.factor.foldid_+3A_event">event</code></td>
<td>
<p>the outcome variable in a vector identifying the different potential 
levels of the outcome</p>
</td></tr>
<tr><td><code id="boot.factor.foldid_+3A_fraction">fraction</code></td>
<td>
<p>the fraction of the whole sample included in the bootstratp sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>foldid's in a vector the same length as event
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.foldid">get.foldid</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='calceloss'>calculate cross-entry for multinomial outcomes</h2><span id='topic+calceloss'></span>

<h3>Description</h3>

<p>calculate cross-entry for multinomial outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calceloss(xx, yy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calceloss_+3A_xx">xx</code></td>
<td>
<p>the sigmoid of the link, i.e, the estimated probabilities, i.e. xx = 1/(1+exp(-xb))</p>
</td></tr>
<tr><td><code id="calceloss_+3A_yy">yy</code></td>
<td>
<p>the observed data as 0's and 1's</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cross-entropy on a per observation basis
</p>

<hr>
<h2 id='calplot'>Construct calibration plots for a nested.glmnetr output object</h2><span id='topic+calplot'></span>

<h3>Description</h3>

<p>Using k-fold cross validation this function constructs calibration plots for 
a nested.glmnetr output object. Each hold out subset of the k-fold cross 
validation is regressed on the x*beta predicteds based upon the 
model fit using the non-hold out data using splines.  This yields k spline 
functions for evaluating model performance.  These k spline functions are 
averaged to provide an overall model calibration.  Standard deviations of 
the k spline fits are also calculated as a function of the predicted X*beta, 
and these are used to derive and plot approximate 95
(mean +/- 2 * SD/sqrt(k)).  Because regression equations can be unreliable 
when extrapolating beyond the data range used in model derivation, we 
display this overall calibration fit and CIs with solid lines only for the 
region which lies within the ranges of the predicted x*betas for  
all the k leave out sets.  The spline fits are made using the same framework 
as in the original machine learning model fits, i.e. one of &quot;cox&quot;, &quot;binomial&quot; 
or &quot;gaussian&quot;family. For the &quot;cox&quot; famework the pspline() funciton is used, 
and for the &quot;binomial&quot; and &quot;gaussian&quot; frameworks the ns() function is 
used.  Predicted X*betas beyond the range of any of the hold 
out sets are displayed by dashed lines to reflect the lessor certainty when 
extrapolating even for a single hold out set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calplot(
  object,
  wbeta = NULL,
  df = 3,
  resample = NULL,
  usefold = 1,
  plot = 1,
  plotfold = 0,
  plothr = 0,
  knottype = 1,
  trim = 0,
  vref = 0,
  xlim = NULL,
  ylim = NULL,
  xlab = NULL,
  ylab = NULL,
  col.term = 1,
  col.se = 2,
  rug = 1,
  seed = NULL,
  cv = NULL,
  fold = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calplot_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr() output object for calibration</p>
</td></tr>
<tr><td><code id="calplot_+3A_wbeta">wbeta</code></td>
<td>
<p>Which Beta should be plotted, an integer.  This will depend on
which machine learning models were run when creating the output object.   If 
unsure the user can run the function without specifying wbeta and a legend 
will be directed to the console.</p>
</td></tr>
<tr><td><code id="calplot_+3A_df">df</code></td>
<td>
<p>The degrees of freedom for the spline function</p>
</td></tr>
<tr><td><code id="calplot_+3A_resample">resample</code></td>
<td>
<p>1 to base the splines on the leave out X*Beta's ($xbetas.cv 
or $xbetas.boot), or 0 to use the naive X*Beta's ($xbetas).  This can be done 
to see biases associated with the naive approach.</p>
</td></tr>
<tr><td><code id="calplot_+3A_usefold">usefold</code></td>
<td>
<p>1 (default) to base the calibration by first fitting splines for 
each individual fold and then averaging, 0 to base the calibration on a single
spline fit using all X*Beta.</p>
</td></tr>
<tr><td><code id="calplot_+3A_plot">plot</code></td>
<td>
<p>1 by default to produce plots, 0 to output data for plots only, 
2 to plot and output data.</p>
</td></tr>
<tr><td><code id="calplot_+3A_plotfold">plotfold</code></td>
<td>
<p>0 by default to not plot the individual fold calibrations, 1 
to overlay the k leave out spline calibration fits in a single figure and 2 
to produce seperate plots for each of the k hold out calibration curves.</p>
</td></tr>
<tr><td><code id="calplot_+3A_plothr">plothr</code></td>
<td>
<p>a power &gt; 1 determining the spacing of the values 
on the axes, e.g. 2, exp(1), sqrt(10) or 10.  The default of 0 plots the 
X*Beta.  This only applies fore &quot;cox&quot; survival data models.</p>
</td></tr>
<tr><td><code id="calplot_+3A_knottype">knottype</code></td>
<td>
<p>1 (default) to use OOB (out of bag) test validation data when 
choosing ns() knots for gaussian and binomial families, 2 to use the larger 
training data</p>
</td></tr>
<tr><td><code id="calplot_+3A_trim">trim</code></td>
<td>
<p>the percent of top and bottom of the data to be trimmed away when 
producing plots.  The original data are still used used calcualting the curves 
for plotting.</p>
</td></tr>
<tr><td><code id="calplot_+3A_vref">vref</code></td>
<td>
<p>Similar to trim but instead of trimming the spline lines, plots 
vertical refence lines aht the top vref and bottom vref percent of the model
X*Betas's</p>
</td></tr>
<tr><td><code id="calplot_+3A_xlim">xlim</code></td>
<td>
<p>xlim for the plots.  This does not effect the curves within 
the plotted region.  Caution, for the &quot;cox&quot; framework the xlim are specified
in terms of the X*beta and not the HR, even when HR is described on the axes.</p>
</td></tr>
<tr><td><code id="calplot_+3A_ylim">ylim</code></td>
<td>
<p>ylim for the plots, which will usually only be specified in a 
second run of for the same data.  This does not effect the curves within 
the plotted region.  Caution, for the &quot;cox&quot; framework the ylim are specified
in terms of the X*beta and not the HR, even when HR is described on the axes.</p>
</td></tr>
<tr><td><code id="calplot_+3A_xlab">xlab</code></td>
<td>
<p>a user specified label for the x axis</p>
</td></tr>
<tr><td><code id="calplot_+3A_ylab">ylab</code></td>
<td>
<p>a user specified label for the y axis</p>
</td></tr>
<tr><td><code id="calplot_+3A_col.term">col.term</code></td>
<td>
<p>a number for the line depicting the overall calibration estimates</p>
</td></tr>
<tr><td><code id="calplot_+3A_col.se">col.se</code></td>
<td>
<p>a number for the line depicting the +/- 2 * standard error 
lines for the overall calibration estimates</p>
</td></tr>
<tr><td><code id="calplot_+3A_rug">rug</code></td>
<td>
<p>1 to plot a rug for the model x*betas, 0 (default) to not.</p>
</td></tr>
<tr><td><code id="calplot_+3A_seed">seed</code></td>
<td>
<p>an integer seed used to random select the multiple of X*Betas
to be used in the rug when using bootstraping for model evaluation as sample 
elements may be included multiple times as test (Out Of Bag) data.</p>
</td></tr>
<tr><td><code id="calplot_+3A_cv">cv</code></td>
<td>
<p>Deprecated. Use resample option instead.</p>
</td></tr>
<tr><td><code id="calplot_+3A_fold">fold</code></td>
<td>
<p>Deprecated.  Use instead usefold. fold is too easily confused with a 
single fold for plotting.</p>
</td></tr>
<tr><td><code id="calplot_+3A_...">...</code></td>
<td>
<p>allowance to pass terms to the invoked plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally, for comparison,  
the program can fit a spline based upon the predicted x*betas ignoring the 
cross validation structure, or one can fit a spline using the x*betas 
calculated using the model based upon all data.
</p>


<h3>Value</h3>

<p>Calibration plots are returned by default, and optionally data for plots 
are output to a list.
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='cox.sat.dev'>Calculate the CoxPH saturated log-likelihood</h2><span id='topic+cox.sat.dev'></span>

<h3>Description</h3>

<p>Calculate the saturated log-likelihood for the Cox 
model using both the Efron and Breslow approximations for the case where all ties
at a common event time have the same weights (exp(X*B)).  For 
the simple case without ties 
the saturated log-likelihood is 0 as the contribution to the log-likelihood at 
each event time point can be made arbitrarily close to 1 by assigning a much larger 
weight to the record with an 
event.  Similarly, in the case of ties 
one can assign a much larger weight to be associated with one of the event times 
such that the associated record contributes a 1 to the likelihood.  Next one 
can assign a very large weight to a second tie, but smaller than the first tie 
considered, and this too will contribute a 1 to the 
likelihood.  Continuing in this way for this and all time points with ties, 
the partial log-likelihood is 0, just like for the no-ties case.  Note, this is 
the same argument with which we derive the log-likelihood of 0 for the no ties
case. Still, to be consistent with others we derive the saturated log-likelihood
with ties under the constraint that all ties at each event time carry the same weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.sat.dev(y_, e_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.sat.dev_+3A_y_">y_</code></td>
<td>
<p>Time variable for a survival analysis, whether or not there is a start time</p>
</td></tr>
<tr><td><code id="cox.sat.dev_+3A_e_">e_</code></td>
<td>
<p>Event indicator with 1 for event 0 otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Saturated log likelihood for the Efron and Breslow approximations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='cv.glmnetr'>Get a cross validation informed relaxed lasso model fit.</h2><span id='topic+cv.glmnetr'></span>

<h3>Description</h3>

<p>Derive a relaxed lasso model and identifies hyperparameters, i.e. lambda and gamma,  
which give the best bit using cross validation.  It is analogous to the cv.glmnet() function of the 
'glmnet' package, but handles cases where glmnet() may run slowly when using the
relaxed=TRUE option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.glmnetr(
  xs,
  start = NULL,
  y_,
  event = NULL,
  family = "gaussian",
  lambda = NULL,
  gamma = c(0, 0.25, 0.5, 0.75, 1),
  folds_n = 10,
  limit = 2,
  fine = 0,
  track = 0,
  seed = NULL,
  foldid = NULL,
  ties = "efron",
  stratified = 1,
  time = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.glmnetr_+3A_xs">xs</code></td>
<td>
<p>predictor matrix</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_start">start</code></td>
<td>
<p>vector of start times or the Cox model.  Should be NULL for other models.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_y_">y_</code></td>
<td>
<p>outcome vector</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_event">event</code></td>
<td>
<p>event vector in case of the Cox model.  May be NULL for other models.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_lambda">lambda</code></td>
<td>
<p>the lambda vector.  May be NULL.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_gamma">gamma</code></td>
<td>
<p>the gamma vector.  Default is c(0,0.25,0.50,0.75,1).</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_folds_n">folds_n</code></td>
<td>
<p>number of folds for cross validation.  Default and generally recommended is 10.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_limit">limit</code></td>
<td>
<p>limit the small values for lambda after the initial fit.
This will eliminate calculations that have small or minimal impact on the cross validation.  
Default is 2 for moderate limitation, 1 for less limitation, 0 for none.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_fine">fine</code></td>
<td>
<p>use a finer step in determining lambda.  Of little value unless one 
repeats the cross validation many times to more finely tune the hyperparameters.  
See the 'glmnet' package documentation.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_track">track</code></td>
<td>
<p>indicate whether or not to update progress in the console.  Default of
0 suppresses these updates.  The option of 1 provides these updates.  In fitting 
clinical data with non full rank design matrix we have found some R-packages to
take a vary long time or seemingly be caught in infinite loops.  Therefore we allow
the user to track the program progress and judge whether things are moving forward or 
if the process should be stopped.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() so one can reproduce the model fit.  If 
NULL the program will generate a random seed.  Whether specified or NULL, the 
seed is stored in the output object for future reference.  Note,
for the default this randomly generated seed depends on the seed in memory at that 
time so will depend on any calls of set.seed prior to the call of this function.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_foldid">foldid</code></td>
<td>
<p>a vector of integers to associate each record to a fold.  The integers should be between 1 and folds_n.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_ties">ties</code></td>
<td>
<p>method for handling ties in Cox model for relaxed model component.  Default 
is &quot;efron&quot;, optionally &quot;breslow&quot;.  For penalized fits &quot;breslow&quot; is 
always used as in the 'glmnet' package.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_stratified">stratified</code></td>
<td>
<p>folds are to be constructed stratified on an indicator outcome 
1 (default) for yes, 0 for no.  Pertains to event variable for &quot;cox&quot; and y_ for 
&quot;binomial&quot; family.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_time">time</code></td>
<td>
<p>track progress by printing to console elapsed and split times.  Suggested to use
track option instead as time options will be eliminated.</p>
</td></tr>
<tr><td><code id="cv.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to glmnet()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main program for model derivation.  As currently implemented the 
package requires the data to be input as vectors and matrices with no missing values 
(NA).  All data vectors and matrices must be numerical.  For factors (categorical variables) one
should first construct corresponding numerical variables to represent the factor 
levels.  To take advantage of the lasso model, one can use one hot coding
assigning an indicator for each level of each categorical variable, or creating 
as well other contrasts variables suggested by the subject matter.
</p>


<h3>Value</h3>

<p>A cross validation informed relaxed lasso model fit.
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cv.glmnetr">summary.cv.glmnetr</a></code> , <code><a href="#topic+predict.cv.glmnetr">predict.cv.glmnetr</a></code> , <code><a href="#topic+glmnetr">glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed for random numbers, optionally, to get reproducible results
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=100, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$y_ 
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
cv.glmnetr.fit = cv.glmnetr(xs, NULL, y_, NULL, family="gaussian", folds_n=3, limit=2) 
plot(cv.glmnetr.fit)
plot(cv.glmnetr.fit, coefs=1)
summary(cv.glmnetr.fit)

</code></pre>

<hr>
<h2 id='cv.stepreg'>Cross validation informed stepwise regression model fit.</h2><span id='topic+cv.stepreg'></span>

<h3>Description</h3>

<p>Cross validation informed stepwise regression model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.stepreg(
  xs_cv,
  start_cv = NULL,
  y_cv,
  event_cv,
  family = "cox",
  steps_n = 0,
  folds_n = 10,
  method = "loglik",
  seed = NULL,
  foldid = NULL,
  stratified = 1,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.stepreg_+3A_xs_cv">xs_cv</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_start_cv">start_cv</code></td>
<td>
<p>start time, Cox model only - class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_y_cv">y_cv</code></td>
<td>
<p>output vector: time, or stop time for Cox model, Y_ 0 or 1 for binomal (logistic), numeric for gaussian. 
#' Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_event_cv">event_cv</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_steps_n">steps_n</code></td>
<td>
<p>Maximun number of steps done in stepwise regression fitting.  If 0, then takes the value rank(xs_cv).</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_folds_n">folds_n</code></td>
<td>
<p>number of folds for cross validation</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_method">method</code></td>
<td>
<p>method for choosing model in stepwise procedure, &quot;loglik&quot; or &quot;concordance&quot;.
Other procedures use the &quot;loglik&quot;.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() to assure one can get the same results twice.  If NULL 
the program will generate a random seed.  Whether specified or NULL, the seed is stored in the output
object for future reference.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_foldid">foldid</code></td>
<td>
<p>a vector of integers to associate each record to a fold.  The integers should be between 1 and folds_n.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_stratified">stratified</code></td>
<td>
<p>folds are to be constructed stratified on an indicator outcome 
1 (default) for yes, 0 for no.  Pertains to event variable for &quot;cox&quot; and y_ for 
&quot;binomial&quot; family.</p>
</td></tr>
<tr><td><code id="cv.stepreg_+3A_track">track</code></td>
<td>
<p>indicate whether or not to update progress in the console.  Default of
0 suppresses these updates.  The option of 1 provides these updates.  
In fitting clinical data with non full rank design matrix we have found some 
R-packages to take a very long time.  Therefore we allow the user to track the 
program progress and judge whether things are 
moving forward or if the process should be stopped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cross validation infomred stepwise regression model fit tuned by number of model terms or p-value for inclusion.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.cv.stepreg">predict.cv.stepreg</a></code> , <code><a href="#topic+summary.cv.stepreg">summary.cv.stepreg</a></code>, <code><a href="#topic+stepreg">stepreg</a></code> , <code><a href="#topic+aicreg">aicreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(955702213)
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=c(0,1,1))
# this gives a more interesting case but takes longer to run
xs=sim.data$xs           
# this will work numerically as an example 
xs=sim.data$xs[,c(2,3,50:55)] 
dim(xs)
y_=sim.data$yt 
event=sim.data$event
# for this example we use small numbers for steps_n and folds_n to shorten run time 
cv.stepreg.fit = cv.stepreg(xs, NULL, y_, event, steps_n=10, folds_n=3, track=0)
summary(cv.stepreg.fit)

</code></pre>

<hr>
<h2 id='devrat_'>Calculate deviance ratios for CV based</h2><span id='topic+devrat_'></span>

<h3>Description</h3>

<p>Calculate deviance ratios for individual folds and collectively.  Calculations
are based upon the average -2 Log Likelihoods calculated on each leave out test fold
data for the models trained on the other (K-1) folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devrat_(m2.ll.mod, m2.ll.null, m2.ll.sat, n__)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devrat__+3A_m2.ll.mod">m2.ll.mod</code></td>
<td>
<p>-2 Log Likelihoods calculated on the test data</p>
</td></tr>
<tr><td><code id="devrat__+3A_m2.ll.null">m2.ll.null</code></td>
<td>
<p>-2 Log Likelihoods for the null models</p>
</td></tr>
<tr><td><code id="devrat__+3A_m2.ll.sat">m2.ll.sat</code></td>
<td>
<p>-2 Log Likelihoods for teh saturated models</p>
</td></tr>
<tr><td><code id="devrat__+3A_n__">n__</code></td>
<td>
<p>sample zize for the indivual foles, or number of events for the Cox model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with devrat.cv for the deviance ratios for the indivual folds, 
and devrat, a single collective deviance ratio
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='diff_time'>Output to console the elapsed and split times</h2><span id='topic+diff_time'></span>

<h3>Description</h3>

<p>Output to console the elapsed and split times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_time(time_start = NULL, time_last = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_time_+3A_time_start">time_start</code></td>
<td>
<p>beginning time for printing elapsed time</p>
</td></tr>
<tr><td><code id="diff_time_+3A_time_last">time_last</code></td>
<td>
<p>last time for calculating split time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time of program invocation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_time">diff_time</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time_start = diff_time()
time_last = diff_time(time_start)
time_last = diff_time(time_start,time_last)
time_last = diff_time(time_start,time_last)

</code></pre>

<hr>
<h2 id='diff_time1'>Get elapsed time in c(hour, minute, secs)</h2><span id='topic+diff_time1'></span>

<h3>Description</h3>

<p>Get elapsed time in c(hour, minute, secs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_time1(time1, time2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_time1_+3A_time1">time1</code></td>
<td>
<p>start time</p>
</td></tr>
<tr><td><code id="diff_time1_+3A_time2">time2</code></td>
<td>
<p>stop time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of elapsed time in (hour, minute, secs)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_time">diff_time</a></code>
</p>

<hr>
<h2 id='factor.foldid'>Generate foldid's by factor levels</h2><span id='topic+factor.foldid'></span>

<h3>Description</h3>

<p>Generate foldid's by factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor.foldid(event, fold_n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor.foldid_+3A_event">event</code></td>
<td>
<p>the outcome variable in a vector identifying the different potential 
levels of the outcome</p>
</td></tr>
<tr><td><code id="factor.foldid_+3A_fold_n">fold_n</code></td>
<td>
<p>the numbe of folds to be constructed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>foldid's in a vector the same length as event
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.foldid">get.foldid</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='get.foldid'>Get foldid's with branching for cox, binomial and gaussian models</h2><span id='topic+get.foldid'></span>

<h3>Description</h3>

<p>Get foldid's with branching for cox, binomial and gaussian models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.foldid(y_, event, family, folds_n, stratified = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.foldid_+3A_y_">y_</code></td>
<td>
<p>see help for cv.glmnetr() or nested.glmnetr()</p>
</td></tr>
<tr><td><code id="get.foldid_+3A_event">event</code></td>
<td>
<p>see help for cv.glmnetr() or nested.glmnetr()</p>
</td></tr>
<tr><td><code id="get.foldid_+3A_family">family</code></td>
<td>
<p>see help for cv.glmnetr() or nested.glmnetr()</p>
</td></tr>
<tr><td><code id="get.foldid_+3A_folds_n">folds_n</code></td>
<td>
<p>see help for cv.glmnetr() or nested.glmnetr()</p>
</td></tr>
<tr><td><code id="get.foldid_+3A_stratified">stratified</code></td>
<td>
<p>see help for cv.glmnetr() or nested.glmnetr()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with foldid's for use in a cross validation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+factor.foldid">factor.foldid</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='glmnetr'>Fit relaxed part of lasso model</h2><span id='topic+glmnetr'></span>

<h3>Description</h3>

<p>Derive the relaxed lasso fits and optionally calls glmnet() to 
derive the fully penalized lasso fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetr(
  xs_tmp,
  start_tmp,
  y_tmp,
  event_tmp,
  family = "cox",
  lambda = NULL,
  gamma = c(0, 0.25, 0.5, 0.75, 1),
  object = NULL,
  track = 0,
  ties = "efron",
  time = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetr_+3A_xs_tmp">xs_tmp</code></td>
<td>
<p>predictor (X) matrix</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_start_tmp">start_tmp</code></td>
<td>
<p>start time in case Cox model and (Start, Stop) time for use in model</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_y_tmp">y_tmp</code></td>
<td>
<p>outcome (Y) variable, in case of Cox model (stop) time</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_event_tmp">event_tmp</code></td>
<td>
<p>event variable in case of Cox model</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_lambda">lambda</code></td>
<td>
<p>lambda vector, as in glmnet(), default is NULL</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_gamma">gamma</code></td>
<td>
<p>gamma vector, as with glmnet(), default c(0,0.25,0.50,0.75,1)</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_object">object</code></td>
<td>
<p>an output object from glmnet() using relax=FALSE with the model fits for
the fully penalized lasso models, i.e. gamma=1.  Default is NULL in which case these are derived 
within the function.</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_track">track</code></td>
<td>
<p>Indicate whether or not to update progress in the console.  Default of
0 suppresses these updates.  The option of 1 provides these updates.  In fitting 
clinical data with non full rank design matrix we have found some R-packages to
take a vary long time or possibly get caught in infinite loops.  Therefore we allow
the user to track the package and judge whether things are moving forward or 
if the process should be stopped.</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_ties">ties</code></td>
<td>
<p>method for handling ties in Cox model for relaxed model component.  Default 
is &quot;efron&quot;, optionally &quot;breslow&quot;.  For penalized fits &quot;breslow&quot; is 
always used as in the 'glmnet' package.</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_time">time</code></td>
<td>
<p>track progress by printing to console elapsed and split times.  Suggested to use
track option instead as time options will be eliminated.</p>
</td></tr>
<tr><td><code id="glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to glmnet()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two matrices, one for the model coefficients with
gamma=1 and the other with gamma=0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.glmnetr">predict.glmnetr</a></code> , <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=200, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
glmnetr.fit = glmnetr( xs, NULL, y_, event, family="cox")
plot(glmnetr.fit)


</code></pre>

<hr>
<h2 id='glmnetr_seed'>Get seeds to store, facilitating replicable results</h2><span id='topic+glmnetr_seed'></span>

<h3>Description</h3>

<p>Get seeds to store, facilitating replicable results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetr_seed(seed, folds_n = 10, folds_ann_n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetr_seed_+3A_seed">seed</code></td>
<td>
<p>The intput seed as a start, NULL, a vector of lenght 1 or 2, or 
a list with vectors of lenght 1 or the number of folds, $seedr for most models 
and $seedt for the ANN fits</p>
</td></tr>
<tr><td><code id="glmnetr_seed_+3A_folds_n">folds_n</code></td>
<td>
<p>The number of folds in general</p>
</td></tr>
<tr><td><code id="glmnetr_seed_+3A_folds_ann_n">folds_ann_n</code></td>
<td>
<p>The number of folds for the ANN fits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>seed(s) in a list format for input to subsequent runs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='glmnetr.cis'>A redirect to nested.cis()</h2><span id='topic+glmnetr.cis'></span>

<h3>Description</h3>

<p>See nested.cis(), glmnetr.cis() is depricated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetr.cis(object, type = "devrat", pow = 1, digits = 4, returnd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetr.cis_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="glmnetr.cis_+3A_type">type</code></td>
<td>
<p>determines what type of nested cross validation performance measures are 
compared.  Possible values are &quot;devrat&quot; to compare the deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
&quot;agree&quot; to compare agreement, &quot;lincal&quot; to compare the linear calibration 
slope coefficients, &quot;intcal&quot; to compare the linear calibration intercept 
coefficients, from the nested cross validation.</p>
</td></tr>
<tr><td><code id="glmnetr.cis_+3A_pow">pow</code></td>
<td>
<p>the power to which the average of correlations is to be raised.  Only 
applies to the &quot;gaussian&quot; model.  Default is 2 to yield R-square but can be on to 
show correlations.  pow is ignored for the family of &quot;cox&quot; and &quot;binomial&quot;.  When
pow = 2, calculations are made using correlations and the final estimates and 
confidence intervals are raised to the power of 2.  A negative sign before an 
R-square estimate or confidence limit indicates the estimate or confidence 
limit was negative before being raised to the power of 2.</p>
</td></tr>
<tr><td><code id="glmnetr.cis_+3A_digits">digits</code></td>
<td>
<p>digits for printing of z-scores, p-values, etc. with default of 4</p>
</td></tr>
<tr><td><code id="glmnetr.cis_+3A_returnd">returnd</code></td>
<td>
<p>1 to return the deviance ratios in a list, 0 to not return.  The
deviances are stored in the nested.glmnetr() output object but not the deviance
ratios.  This function provides a simple mechanism to obtain the cross validated
deviance ratios.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout to the R console
</p>

<hr>
<h2 id='glmnetr.compcv'>A redirect to nested.compare</h2><span id='topic+glmnetr.compcv'></span>

<h3>Description</h3>

<p>See nested.compare(), as glmnetr() is depricated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetr.compcv(object, digits = 4, type = "devrat", pow = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetr.compcv_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="glmnetr.compcv_+3A_digits">digits</code></td>
<td>
<p>digits for printing of z-scores, p-values, etc. with default of 4</p>
</td></tr>
<tr><td><code id="glmnetr.compcv_+3A_type">type</code></td>
<td>
<p>determines what type of nested cross validation performance measures are 
compared.  Possible values are &quot;devrat&quot; to compare the deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
&quot;agree&quot; to compare agreement, &quot;lincal&quot; to compare the linear calibration 
slope coefficients, &quot;intcal&quot; to compare the linear calibration intercept 
coefficients, from the nested cross validation.</p>
</td></tr>
<tr><td><code id="glmnetr.compcv_+3A_pow">pow</code></td>
<td>
<p>the power to which the average of correlations is to be raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout to the R console.
</p>

<hr>
<h2 id='glmnetr.simdata'>Generate example data</h2><span id='topic+glmnetr.simdata'></span>

<h3>Description</h3>

<p>Generate an example data set with specified number of observations, 
and predictors.  The first column in the design matrix is identically equal to 1
for an intercept.  Columns 2 to 5 are for the 4 levels of a character variable, 
6 to 11 for the 6 levels of another character variable.  Columns 12 to 17 are for 3
binomial predictors, again over parameterized.  Such over parameterization
can cause difficulties with the glmnet() of the 'glmnet' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnetr.simdata(nrows = 1000, ncols = 100, beta = NULL, intr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnetr.simdata_+3A_nrows">nrows</code></td>
<td>
<p>Sample size (&gt;=100) for simulated data, default=1000.</p>
</td></tr>
<tr><td><code id="glmnetr.simdata_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns (&gt;=17) in design matrix, i.e. predictors, default=100.</p>
</td></tr>
<tr><td><code id="glmnetr.simdata_+3A_beta">beta</code></td>
<td>
<p>Vector of length &lt;= ncols for &quot;left most&quot; coefficients.  If beta has 
length &lt; ncols, then the values at length(beta)+1 to ncols are set to 0.
Default=NULL, where a beta of length 25 is assigned standard normal values.</p>
</td></tr>
<tr><td><code id="glmnetr.simdata_+3A_intr">intr</code></td>
<td>
<p>either NULL for no interactions or a vector of length 3 to impose a 
product effect as decribed by 
intr[1]*xs[,3]*xs[,8] + intr[2]*xs[,4]*xs[,16] + intr[3]*xs[,18]*xs[,19] + intr[4]*xs[,21]*xs[,22]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements xs for desing matrix, y_ for a quantitative outcome, 
yt for a survival time, event for an indicator of event (1) or censoring (0), 
in the Cox proportional hazards survival model setting, yb for 
yes/no (binomial) outcome data, and beta the beta used in random number generation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
# for Cox PH survial model data 
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for linear regression model data 
xs=sim.data$xs 
y_=sim.data$y_
# for logistic regression model data 
xs=sim.data$xs 
y_=sim.data$yb

</code></pre>

<hr>
<h2 id='nested.cis'>Calculate performance measure CI's and p's</h2><span id='topic+nested.cis'></span>

<h3>Description</h3>

<p>Calculate overall estimates and confidence intervals for performance measures
based upon stored cross validation performance measures in a nested.glmnetr()
output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.cis(object, type = "devrat", pow = 1, digits = 4, returnd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested.cis_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="nested.cis_+3A_type">type</code></td>
<td>
<p>determines what type of nested cross validation performance measures are 
compared.  Possible values are &quot;devrat&quot; to compare the deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
&quot;agree&quot; to compare agreement, &quot;lincal&quot; to compare the linear calibration 
slope coefficients, &quot;intcal&quot; to compare the linear calibration intercept 
coefficients, from the nested cross validation.</p>
</td></tr>
<tr><td><code id="nested.cis_+3A_pow">pow</code></td>
<td>
<p>the power to which the average of correlations is to be raised.  Only 
applies to the &quot;gaussian&quot; model.  Default is 2 to yield R-square but can be on to 
show correlations.  pow is ignored for the family of &quot;cox&quot; and &quot;binomial&quot;.  When
pow = 2, calculations are made using correlations and the final estimates and 
confidence intervals are raised to the power of 2.  A negative sign before an 
R-square estimate or confidence limit indicates the estimate or confidence 
limit was negative before being raised to the power of 2.</p>
</td></tr>
<tr><td><code id="nested.cis_+3A_digits">digits</code></td>
<td>
<p>digits for printing of z-scores, p-values, etc. with default of 4</p>
</td></tr>
<tr><td><code id="nested.cis_+3A_returnd">returnd</code></td>
<td>
<p>1 to return the deviance ratios in a list, 0 to not return.  The
deviances are stored in the nested.glmnetr() output object but not the deviance
ratios.  This function provides a simple mechanism to obtain the cross validated
deviance ratios.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout to the R console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.compare">nested.compare</a></code> , <code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
nested.cis(fit3)


</code></pre>

<hr>
<h2 id='nested.compare'>Compare cross validation fit performances from a nested.glmnetr output.</h2><span id='topic+nested.compare'></span>

<h3>Description</h3>

<p>Compare cross-validation model fits in terms of average performances from the 
nested cross validation fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.compare(object, type = "devrat", digits = 4, pow = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested.compare_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="nested.compare_+3A_type">type</code></td>
<td>
<p>determines what type of nested cross validation performance measures are 
compared.  Possible values are &quot;devrat&quot; to compare the deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
&quot;agree&quot; to compare agreement, &quot;lincal&quot; to compare the linear calibration 
slope coefficients, &quot;intcal&quot; to compare the linear calibration intercept 
coefficients, from the nested cross validation.</p>
</td></tr>
<tr><td><code id="nested.compare_+3A_digits">digits</code></td>
<td>
<p>digits for printing of z-scores, p-values, etc. with default of 4</p>
</td></tr>
<tr><td><code id="nested.compare_+3A_pow">pow</code></td>
<td>
<p>the power to which the average of correlations is to be raised.  Only 
applies to the &quot;gaussian&quot; model.  Default is 2 to yield R-square but can be on to 
show correlations.  pow is ignored for the family of &quot;cox&quot; and &quot;binomial&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout to the R console.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.cis">nested.cis</a></code> , <code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
nested.compare(fit3)


</code></pre>

<hr>
<h2 id='nested.glmnetr'>Using (nested) cross validation, describe and compare some machine learning model performances</h2><span id='topic+nested.glmnetr'></span>

<h3>Description</h3>

<p>Performs a nested cross validation or bootstrap validation 
for cross validation informed relaxed lasso, Gradient Boosting Machine (GBM), 
Random Forest (RF), (artificial) Neural Network (ANN) with two hidden layers, 
Recursive Partitioning (RPART) and step wise regression.  That is
hyper parameters for all these models are informed by cross validation (CV) (or in the 
case of RF by out-of-bag calculations), and a second  layer of resampling  
is used to evaluate the performance of these CV informed model fits.  For
step wise regression CV is used to inform either a p-value for entry or degrees of 
freedom (df) for the final model choice.  For input 
we require predictors (features) to be in numeric matrix format with no missing 
values.  This is similar to how the glmnet package expects predictors.  For 
survival data we allow input of start time as an option, and require stop time, 
and an event indicator, 1 for event and 0 for censoring, as separate terms. This
may seem unorthodox as it might seem simpler to accept a Surv() object as input.  However,
multiple packages we use for model fitting models require data
in various formats and this choice was the most straight forward for constructing the 
data formats required.  As an example, 
the XGBoost routines require a data format specific to the XGBoost 
package, not a matrix, not a data frame.  Note, for XGBoost and survival models, 
only a &quot;stop time&quot; variable, taking a positive value to indicate 
being associated with an event, and the negative of the time when 
associated with a censoring, is passed to the input data object for 
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested.glmnetr(
  xs,
  start = NULL,
  y_,
  event = NULL,
  family = "gaussian",
  resample = NULL,
  folds_n = 10,
  stratified = NULL,
  dolasso = 1,
  doxgb = 0,
  dorf = 0,
  doorf = 0,
  doann = 0,
  dorpart = 0,
  dostep = 0,
  doaic = 0,
  ensemble = 0,
  method = "loglik",
  lambda = NULL,
  gamma = NULL,
  relax = TRUE,
  steps_n = 0,
  seed = NULL,
  foldid = NULL,
  limit = 1,
  fine = 0,
  ties = "efron",
  keepdata = 0,
  keepxbetas = 1,
  bootstrap = 0,
  unique = 0,
  track = 0,
  do_ncv = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested.glmnetr_+3A_xs">xs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample 
size, and p (columns) the number of predictors.  Must be in matrix form for 
complete data, no NA's, no Inf's, etc., and not a data frame.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_start">start</code></td>
<td>
<p>optional start times in case of a Cox model.  A numeric (vector) 
of length same as number of patients (n).  Optionally start may be specified as 
a column matrix in which case the colname value is used when outputing summaries.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_y_">y_</code></td>
<td>
<p>dependent variable as a vector: time, or stop time for Cox 
model, Y_ 0 or 1 for binomal (logistic), numeric for gaussian. Must be a 
vector of length same as number of sample size. Optionally y_ may be specified as 
a column matrix in which case the colname value is used when outputing summaries.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_event">event</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.  Optionally event may be specified as 
a column matrix in which case the colname value is used when outputing summaries.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_resample">resample</code></td>
<td>
<p>1 by default to do the Nested Cross Validation or bootstrap
resampling calculations to assess model performance (see bootstrap option), or 0
to only fit the various models without doing resampling. In this case the 
nested.glmnetr() function will only derive the models based upon the full 
data set.  This may be useful when exploring various models without having to 
the the timely resampling to assess model performance, for example, when
wanting to examine extreme gradient boosting 
models (GBM) or Artificial Neural Network (ANN) models which can take a long 
time.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_folds_n">folds_n</code></td>
<td>
<p>the number of folds for the outer loop of the nested cross 
validation, and if not overridden by the individual model specifications, also 
the number of folds for the inner loop of the nested cross validation, i.e. 
the number of folds used in model derivation.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_stratified">stratified</code></td>
<td>
<p>1 to generate fold IDs stratified on outcome or event 
indicators for the binomial or Cox model, 0 to generate foldid's without 
regard to outcome.  Default is 1 for nested CV (i.e. bootstrap=0), and 0 
for bootstrap&gt;=1.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_dolasso">dolasso</code></td>
<td>
<p>fit and do cross validation for lasso model, 0 or 1</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_doxgb">doxgb</code></td>
<td>
<p>fit and evaluate a cross validation informed XGBoost (GBM) 
model.  1 for yes, 0 for no (default).  By default the number of folds used when 
training the GBM model will be the same as the number of folds used in the outer
loop of the nested cross validation, and the maximum number of rounds when 
training the GBM model is set to 1000.  To control these values one 
may specify a list for the doxgb argument.  The list can have 
elements  $nfold, $nrounds,
and $early_stopping_rounds, each numerical values of length 1, $folds, a list as 
used by xgb.cv() do identify folds for cross validation, and $eta, $gamma, $max_depth, 
$min_child_seight, $colsample_bytree, $lambda, $alpha and $subsample, each a numeric 
of length 2 giving the lower and upper values for the respective tuning 
parameter.  Here we deviate from nomenclature used elsewhere in the package to
be able to use terms those used in the 'xgboost' (and mlrMBO) package, in particular as used
in xgb.train(), e.g. nfold instead of folds_n and folds instead of foldid.  If 
not provided defaults will be used.  Defaults
can be seen from the output object$doxgb element, again a list. In case not NULL, 
the seed and folds option values override the $seed and $folds values.  
</p>
<p>If to shorten run time the user sets nfold to a value 
other than folds_n we recommend that nfold = folds_n/2 or folds_n/3.  Then the 
folds will be formed by collapsing the folds_n folds allowing a better comparisons of 
model performances between the different machine learning models. Typically 
one would want to keep the full data model but the GBM models can cause the 
output object to require large amounts of storage space so optionally one can 
choose to not keep the final model when the goal is basically only to assess 
model performance for the GBM.  In that case the tuning parameters for the final
tuned model ae retained facilitating recalculation of the final model, this will
also require the original training data.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_dorf">dorf</code></td>
<td>
<p>fit and evaluate a random forest (RF) 
model.  1 for yes, 0 for no (default).  Also, if dorf is specified by a list, 
then RF models will be fit.  The randomForestSRC package is used.  This list can have 
three elements.  One is the vector mtryc, and contains values for mtry.  The program 
searches over the different values to find a better fir for the final model.  If 
not specified mtryc is set to 
round( sqrt(dim(xs)[2]) * c(0.67 , 1, 1.5, 2.25, 3.375) ).  The second list element 
the vector ntreec.  The first item (ntreec[1]) specifies the number of trees to 
fit in evaluating the models specified by the different mtry values.  The second 
item (ntreec[2]) specifies the number of trees to fit in the final model.  The
default is ntreec = c(25,250).  The third element in the list is the numeric variable keep, with  
the value 1 (default) to store the model fit on all data in the output object, or the value 0 
to not store the full data model fit.  Typically 
one would want to keep the full data model but the RF models can cause the 
output object to require large amounts of storage space so optionally one can 
choose to not keep the final model when the goal is basically only to assess 
model performance for the RF.   Random forests use the out-of-bag (OOB) data elements
for assessing model fit and hyperparameter tuning and so cross validation is 
not used for tuning.  Still, because of the number of trees in the forest random forest 
can take long to run.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_doorf">doorf</code></td>
<td>
<p>fit and evaluate an Oblique random forest (RF)
model.  1 for yes, 0 for no (default).  While the nomenclature used by orrsf() 
is slightly different than that used by rfsrc() nomenclature for this object 
follows that of dorf.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_doann">doann</code></td>
<td>
<p>fit and evaluate a cross validation informed Artificial Neural Network 
(ANN) model with two hidden levels.  1 for yes, 0 for no (default). By default 
the number of folds used when training the ANN model will be the same as the 
number of folds used in the outer loop of the nested cross validation.  To override 
this, for example to shrtn run time, one may specify a list for the doann argument 
where the element $folds_ann_n gives the number of folds used when training the 
ANN.  To shorten run we recommend folds_ann_n = folds_n/2 or folds_n/3, and at 
least 3.  Then the folds will be formed by collapsing the folds_n folds using 
in fitting other models allowing a better comparisons of model performances 
between the different machine learning models.  The list can also have 
elements $epochs, $epochs2, $myler, $myler2, $eppr, $eppr2, $lenv1, $lenz2, 
$actv, $drpot, $wd, wd2, l1, l12, $lscale, $scale, $minloss and $gotoend.  These 
arguments are then passed to the ann_tab_cv_best() function, with the 
meanings described in the help for that function, with some exception.  When 
there are two similar values like $epoch and $epoch2 the first applies to the 
ANN models trained without transfer learning and the second to the models 
trained with transfer learning from the lasso model.  Elements of this list 
unspecified will take default values.  The user may also specify the element 
$bestof (a positive integer) to fit bestof models with different random 
starting weights and biases while taking the best performing of the different 
fits based upon CV as the final model.  The default value for bestof is 1.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_dorpart">dorpart</code></td>
<td>
<p>fit and do a nested cross validation for an RPART model.  As rpart() does its
own approximation for cross validation there is no new functions for cross validation.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_dostep">dostep</code></td>
<td>
<p>fit and do cross validation for stepwise regression fit, 0 or 1, 
as discussed in James, Witten, Hastie and Tibshirani, 2nd edition.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_doaic">doaic</code></td>
<td>
<p>fit and do cross validation for AIC fit, 0 or 1.
This is provided primarily as a reference.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_ensemble">ensemble</code></td>
<td>
<p>This is a vector 8 characters long and specifies a set of ensemble 
like model to be fit based upon the predicteds form a relaxed lasso model fit, by 
either inlcuding the predicteds as an additional term (feature) in the machine 
learning model, or including the predicteds similar to an offset.  For XGBoost, 
the offset is specified in the model with the &quot;base_margin&quot; in the XGBoost 
call.  For the Artificial Neural Network models fit using the ann_tab_cv_best() function, 
one can initialize model weights (parameters) to account for the predicteds in 
prediction and either let these weights by modified each epoch or update and maintain 
these weights during the fitting process.  For ensemble[1] = 1 a model is fit
ignoring these predicteds, ensemble[2]=1 a model is fit including the predicteds 
as an additional feature.  For ensemble[3]=1 a model is fit using the predicteds
as an offset when running the xgboost model, or a model is fit including the 
predicteds with initial weights corresponding to an offset, but then weights are 
allowed to be tuned over the epochs.  For i &gt;= 4 ensemble[i] only applies to 
the neural network models.  For ensemble[4]=1 a model is fit like for 
ensemble[3]=1 but the weights are reassigned to correspond to an offset after 
each epoch.  For i in (5,6,7,8) ensemble[i] is similar to ensemble[i-4] except
the original predictor (feature) set is replaced by the set of non-zero terms 
in the relaxed lasso model fit. If ensemble is specified as 0 or NULL, then ensemble 
is assigned c(1,0,0,0, 0,0,0,0).  If ensemble is specified as 1, then ensemble 
is assigned c(1,0,0,0, 0,1,0,1).</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_method">method</code></td>
<td>
<p>method for choosing model in stepwise procedure, &quot;loglik&quot; or &quot;concordance&quot;.
Other procedures use the &quot;loglik&quot;.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_lambda">lambda</code></td>
<td>
<p>lambda vector for the lasso fit</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_gamma">gamma</code></td>
<td>
<p>gamma vector for the relaxed lasso fit, default is c(0,0.25,0.5,0.75,1)</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_relax">relax</code></td>
<td>
<p>fit the relaxed lasso model when fitting a lasso model</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_steps_n">steps_n</code></td>
<td>
<p>number of steps done in stepwise regression fitting</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_seed">seed</code></td>
<td>
<p>optional, either NULL, or a numerical/integer vector of length 2, for R and torch 
random generators, or a list with two two vectors, each of length folds_n+1, for 
generation of random folds of the outer cross validation loop, and the remaining 
folds_n terms for the random generation of the folds or the bootstrap samples for the 
model fits of the inner loops.  This can be used to replicate model fits.  Whether 
specified or NULL, the seed is stored 
in the output object for future reference.  The stored seed is a list with two
vectors seedr for the seeds used in generating the random fold splits, and seedt
for generating the random initial weights and biases in the torch neural network 
models.  The first element in each of these vectors is for the all data fits and
remaining elements for the folds of the inner cross validation.  The integers assigned to 
seed should be positive and not more than 2147483647.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_foldid">foldid</code></td>
<td>
<p>a vector of integers to associate each record to a fold.  Should 
be integers from 1 and folds_n.  These will only be used in the outer folds.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_limit">limit</code></td>
<td>
<p>limit the small values for lambda after the initial fit.  This 
will have minimal impact on the cross validation.  Default is 2 for moderate 
limitation, 1 for less limitation, 0 for none.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_fine">fine</code></td>
<td>
<p>use a finer step in determining lambda.  Of little value unless one 
repeats the cross validation many times to more finely tune the hyper paramters.  
See the 'glmnet' package documentation</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_ties">ties</code></td>
<td>
<p>method for handling ties in Cox model for relaxed model component.  Default 
is &quot;efron&quot;, optionally &quot;breslow&quot;.  For penalized fits &quot;breslow&quot; is 
always used as derived form to 'glmnet' package.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_keepdata">keepdata</code></td>
<td>
<p>0 (default) to delete the input data (xs, start, y_, event) 
from the output objects from the random forest fit and the glm() fit for the 
stepwise AIC model, 1 to keep.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_keepxbetas">keepxbetas</code></td>
<td>
<p>1 (default) to retain in the output object a copy of the 
functional outcome variable, i.e. y_ for &quot;gaussian&quot; and &quot;binomial&quot; data, and 
the Surv(y_,event) or Surv(start,y_,event) for &quot;cox&quot; data.  This allows 
calibration studies of the models, going beyond the linear calibration 
information calculated by the function.  The xbetas are calculated both for
the model derived using all data as well as for the hold out sets (1/k of the 
data each) for the models derived within the cross validation ((k-1)/k of the 
data for each fit).</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_bootstrap">bootstrap</code></td>
<td>
<p>0 (default) to use nested cross validation, a positive integer
to perform as many iterations of the bootstrap for model evaluation.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_unique">unique</code></td>
<td>
<p>0 to use the bootstrap sample as is as training data, 1 to 
include the unique sample elements only once.  A fractional value between 0.5 
and 0.9 will sample without replacement a fraction of this value for training 
and use the remaining as test data.</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_track">track</code></td>
<td>
<p>1 (default) to track progress by printing to console elapsed and 
split times, 0 to not track</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_do_ncv">do_ncv</code></td>
<td>
<p>Deprecated, and replaced by resample</p>
</td></tr>
<tr><td><code id="nested.glmnetr_+3A_...">...</code></td>
<td>
<p>additional arguments that can be passed to glmnet()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- Model fit performance for LASSO, GBM, Random 
Forest, RPART, artificial neural network (ANN) or STEPWISE models are 
estimated using k-cross validation or bootstrap.  Full data model fits for 
these models are also calculated independently (prior to) the performance 
evaluation, often using a second layer of resampling validation.
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmnetr.simdata">glmnetr.simdata</a></code> , <code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.compare">nested.compare</a></code> , 
<code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+predict.nested.glmnetr">predict.nested.glmnetr</a></code> ,
<code><a href="#topic+predict_ann_tab">predict_ann_tab</a></code>, <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code> , 
<code><a href="#topic+xgb.tuned">xgb.tuned</a></code> , <code><a href="#topic+rf_tune">rf_tune</a></code> , <code><a href="#topic+orf_tune">orf_tune</a></code> , <code><a href="#topic+ann_tab_cv">ann_tab_cv</a></code> , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$y_ 
# for this example we use a small number for folds_n to shorten run time 
nested.glmnetr.fit = nested.glmnetr( xs, NULL, y_, NULL, family="gaussian", folds_n=3)
plot(nested.glmnetr.fit, type="devrat", ylim=c(0.7,1)) 
plot(nested.glmnetr.fit, type="lincal", ylim=c(0.9,1.1)) 
plot(nested.glmnetr.fit, type="lasso") 
plot(nested.glmnetr.fit, type="coef") 
summary(nested.glmnetr.fit) 
nested.compare(nested.glmnetr.fit) 
summary(nested.glmnetr.fit, cvfit=TRUE) 


</code></pre>

<hr>
<h2 id='orf_tune'>Fit a Random Forest model on data provided in matrix and vector formats.</h2><span id='topic+orf_tune'></span>

<h3>Description</h3>

<p>Fit an Random Forest model using the orsf() function of the 
randomForestSRC package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orf_tune(
  xs,
  start = NULL,
  y_,
  event = NULL,
  family = NULL,
  mtryc = NULL,
  ntreec = NULL,
  nsplitc = 8,
  seed = NULL,
  tol = 1e-05,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orf_tune_+3A_xs">xs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_start">start</code></td>
<td>
<p>an optional vector of start times in case of a Cox model. Class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_y_">y_</code></td>
<td>
<p>dependent variable as a vector: time, or stop time for Cox model, Y_ 0 or 1 for binomial (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_event">event</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_mtryc">mtryc</code></td>
<td>
<p>a vector (numeric) of values to search over for optimization of the 
Random Forest fit.  This if for the mtry input variable of the orsf() program 
specifying the number of terms to consider in each step of teh Random Forest fit.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_ntreec">ntreec</code></td>
<td>
<p>a vector (numeric) of 2 values, the first for the number of forests
(ntree from orsf()) to use when searhcing for a better bit and the second to use
when fitting the final model.  More trees should give a better fit but 
require more computations and storage for the final. 
model.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_nsplitc">nsplitc</code></td>
<td>
<p>This nsplit of orsf(), a non-negative integer for the  number of 
random splits for a predictor.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() so one can reproduce the model fit.  If 
NULL the program will generate a random seed.  Whether specified or NULL, the 
seed is stored in the output object for future reference.  Note,
for the default this randomly generated seed depends on the seed in memory at that 
time so will depend on any calls of set.seed prior to the call of this function.</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_tol">tol</code></td>
<td>
<p>a small number, a lower bound to avoid division by 0</p>
</td></tr>
<tr><td><code id="orf_tune_+3A_track">track</code></td>
<td>
<p>1 to output a brief summary of the final selected model, 2 to 
output a brief summary on each model fit in search of a better model or 0 
(default) to not output this information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Random Forest model fit
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.orf_tune">summary.orf_tune</a></code> , <code><a href="#topic+rederive_orf">rederive_orf</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='plot_perf_glmnetr'>Plot nested cross validation performance summaries</h2><span id='topic+plot_perf_glmnetr'></span>

<h3>Description</h3>

<p>This function plots summary information from a nested.glmnetr() output object, that 
is from a nested cross validation performance.  Alternamvely one can output the 
numbers otherwise displayed to a list for extraction or customized plotting.  Performance
measures for plotting include &quot;devrat&quot; the deviance ratio, i.e. the fractional 
reduction in deviance relative to the null model deviance, &quot;agree&quot; a measure 
of agreement, &quot;lincal&quot; the slope from a linear calibration and &quot;intcal&quot; the 
intercept from a linear calibration.  Performance measure estimates 
from the individual (outer) cross validation fold are depicted by thin lines 
of different colors and styles, while the composite value from all folds is 
depicted by a thicker black line, and the performance measures naively 
calculated on the all data using the model derived from all data is 
depicted by a thicker red line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_perf_glmnetr(
  x,
  type = "devrat",
  pow = 2,
  ylim = 1,
  fold = 1,
  xgbsimple = 0,
  plot = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_perf_glmnetr_+3A_x">x</code></td>
<td>
<p>A nested.glmnetr output object</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_type">type</code></td>
<td>
<p>determines what type of nested cross validation performance measures are 
plotted.  Possible values are 
&quot;devrat&quot; to plot the deviance ratio, i.e. the fractional reduction in 
deviance relative to the null model deviance, 
&quot;agree&quot; to plot agreement in terms of concordance, correlation or R-square, 
&quot;lincal&quot; to plot the linear calibration slope coefficients, 
&quot;intcal&quot; to plot the linear calibration intercept coefficients, 
from the (nested) cross validation.</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_pow">pow</code></td>
<td>
<p>Power to which agreement is to be raised when the &quot;gaussian&quot; model 
is fit, i.e. 2 for R-square, 1 for correlation.  Does not apply to type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits for model perforamnce plots, i.e. does not apply to 
type = &quot;lasso&quot;.  The ridge model may calibrate very poorly obscuring plots for 
type of &quot;lincal&quot; or &quot;intcal&quot;, so one may specify the ylim value.  If ylim is 
set to 1, then the program will derive a reasonable range for ylim.  If ylim is 
set to 0, then the entire range for all models will be displayed.  Does not 
apply to type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_fold">fold</code></td>
<td>
<p>By default 1 to display using a spaghetti the performance as 
calculated from the individual folds, 0 to display using dots only the composite 
values calculated using all folds.</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_xgbsimple">xgbsimple</code></td>
<td>
<p>1 (default) to include results for the untuned XGB model, 0 to not include.</p>
</td></tr>
<tr><td><code id="plot_perf_glmnetr_+3A_plot">plot</code></td>
<td>
<p>By default 1 to produce a plot, 0 to return the data used in the 
plot in the form of a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This program returns a plot to the graphics window by default, and returns
a list with data used in teh plots if the plot=1 is specified.
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='plot.cv.glmnetr'>Plot cross-validation deviances, or model coefficients.</h2><span id='topic+plot.cv.glmnetr'></span>

<h3>Description</h3>

<p>By default, with coefs=FALSE, plots the average deviances as function of lam (lambda) and gam (gamma), and also 
indicates the gam and lam which minimize deviance based upon a cv.glmnetr() output object.
Optionally, with coefs=TRUE, plots the relaxed lasso coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnetr'
plot(
  x,
  gam = NULL,
  lambda.lo = NULL,
  plup = 0,
  title = NULL,
  coefs = FALSE,
  comment = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.glmnetr_+3A_x">x</code></td>
<td>
<p>a cv.glmnetr()  output object.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_gam">gam</code></td>
<td>
<p>a specific level of gamma for plotting.  By default gamma.min will be used.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_lambda.lo">lambda.lo</code></td>
<td>
<p>a lower limit of lambda when plotting.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_plup">plup</code></td>
<td>
<p>an indicator to plot the upper 95 percent two-sided confidence limits.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_title">title</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_coefs">coefs</code></td>
<td>
<p>default of FALSE plots deviances, option of TRUE plots coefficients.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_comment">comment</code></td>
<td>
<p>default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.</p>
</td></tr>
<tr><td><code id="plot.cv.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This program returns a plot to the graphics window, and may provide 
some numerical information to the R Console.  If gam is not specified, then 
then the gamma.min from the deviance minimizing (lambda.min, gamma.min) pair 
will be used, and the corresponding lambda.min will be indicated by a vertical
line, and the lambda minimizing deviance under the restricted set of models 
where gamma=0 will be indicated by a second vertical line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.glmnetr">plot.glmnetr</a></code> , <code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed for random numbers, optionally, to get reproducible results
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=100, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$y_ 
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
cv_glmnetr_fit = cv.glmnetr(xs, NULL, y_, NULL, family="gaussian", folds_n=3, limit=2) 
plot(cv_glmnetr_fit)
plot(cv_glmnetr_fit, coefs=1)

</code></pre>

<hr>
<h2 id='plot.glmnetr'>Plot the relaxed lasso coefficients.</h2><span id='topic+plot.glmnetr'></span>

<h3>Description</h3>

<p>Plot the relaxed lasso coefficients from either a glmnetr(), cv.glmnetr() or nested.glmnetr() output object.
One may specify gam, single value for gamma.  If gam is unspecified (NULL), then cv.glmnetr and 
nested.glmnetr() will use the gam which minimizes loss, and glmentr() will use gam=1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmnetr'
plot(x, gam = NULL, lambda.lo = NULL, title = NULL, comment = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.glmnetr_+3A_x">x</code></td>
<td>
<p>Either a glmnetr, cv.glmnetr or a nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="plot.glmnetr_+3A_gam">gam</code></td>
<td>
<p>A specific level of gamma for plotting.  By default gamma.min from
the deviance minimizing (lambda.min, gamma.min) pair will be used.</p>
</td></tr>
<tr><td><code id="plot.glmnetr_+3A_lambda.lo">lambda.lo</code></td>
<td>
<p>A lower limit of lambda for plotting.</p>
</td></tr>
<tr><td><code id="plot.glmnetr_+3A_title">title</code></td>
<td>
<p>A title for the plot</p>
</td></tr>
<tr><td><code id="plot.glmnetr_+3A_comment">comment</code></td>
<td>
<p>Default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.</p>
</td></tr>
<tr><td><code id="plot.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This program returns a plot to the graphics window, and may provide 
some numerical information to the R Console.  If the input object is from a
nested.glmnetr or cv.glmnetr object, and gamma is not specified, 
then the gamma.min from
the deviance minimizing (lambda.min, gamma.min) pair will be used, and the
minimizing lambda.min will be indicated by a vertical line.  Also, if one 
specifies gam=0, the lambda which minimizes deviance for the restricted 
set of models where gamma=0 will indicated by a vertical line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cv.glmnetr">plot.cv.glmnetr</a></code> , <code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+glmnetr">glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=200, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
glmnetr.fit = glmnetr( xs, NULL, y_, event, family="cox")
plot(glmnetr.fit)


</code></pre>

<hr>
<h2 id='plot.nested.glmnetr'>Plot results from a nested.glmnetr() output</h2><span id='topic+plot.nested.glmnetr'></span>

<h3>Description</h3>

<p>Plot the nested cross validation performance numbers, cross 
validated relaxed lasso deviances or coefficients from a nested.glmnetr() call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested.glmnetr'
plot(
  x,
  type = "devrat",
  gam = NULL,
  lambda.lo = NULL,
  title = NULL,
  plup = 0,
  coefs = FALSE,
  comment = TRUE,
  pow = 2,
  ylim = 1,
  plot = 1,
  fold = 1,
  xgbsimple = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nested.glmnetr_+3A_x">x</code></td>
<td>
<p>A nested.glmnetr output object</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_type">type</code></td>
<td>
<p>type of plot to be produced form the (nested) cross validation 
performance measures, and the lasso model tuning or lasso model 
coefficients. For the lasso model the options include &quot;lasso&quot; to plot deviances
informing hyperparmeter choice or &quot;coef&quot; to plot lasso parameter estimates.  
Else nested cross validation performance measures are 
plotted.  
To show cross validation performance measures the options include 
&quot;devrat&quot; to plot deviance ratios, i.e. the 
fractional reduction in deviance relative to the null model deviance, 
&quot;agree&quot; to plot agreement, &quot;lincal&quot; to plot the linear
calibration slope coefficients, &quot;intcal&quot; to plot the linear calibration intercept 
coefficients or &quot;devian&quot; to plot the deviances from the nested cross 
validation. 
For each performance measure estimates from the individual (outer) 
cross validation fold are depicted by thin lines of different colors and styles, 
while the composite value from all fol=ds is depicted by a thicker black line, 
and the performance measures naively calculated on the all data using the model 
derived from all data is depicted in a thicker red line.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_gam">gam</code></td>
<td>
<p>A specific level of gamma for plotting.  By default gamma.min will 
be used.  Applies only for type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_lambda.lo">lambda.lo</code></td>
<td>
<p>A lower limit of lambda when plotting.  Applies only for type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_title">title</code></td>
<td>
<p>A title</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_plup">plup</code></td>
<td>
<p>Plot upper 95 percent two-sided confidence intervals for the deviance 
plots.  Applies only for type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_coefs">coefs</code></td>
<td>
<p>Depricated.  See option 'type'.  To plot coefficients specify 'type = coef'.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_comment">comment</code></td>
<td>
<p>Default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.  Applies only for type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_pow">pow</code></td>
<td>
<p>Power to which agreement is to be raised when the &quot;gaussian&quot; model 
is fit, i.e. 2 for R-square, 1 for correlation.  Does not apply to type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits for model performance plots, i.e. does not apply to 
type = &quot;lasso&quot;.  The ridge model may calibrate very poorly obscuring plots for 
type of &quot;lincal&quot; or &quot;intcal&quot;, so one may specify the ylim value.  If ylim is 
set to 1, then the program will derive a reasonable range for ylim.  If ylim is 
set to 0, then the entire range for all models will be displayed.  Does not 
apply to type = &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_plot">plot</code></td>
<td>
<p>By default 1 to produce a plot, 0 to return the data used in the 
plot in the form of a list.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_fold">fold</code></td>
<td>
<p>By default 1 to display model performance estimates form 
individual folds (or replicaitons for boostrap evaluations) when type of 
&quot;agree&quot;, &quot;intcal&quot;, &quot;lincal&quot;, &quot;devrat&quot; for &quot;devian&quot;. If 0 then the individual 
fold calculations are not displayed. When there are many replications as
sometimes the case when using bootstrap, one may specify the number of 
randomly selected lines for plotting.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_xgbsimple">xgbsimple</code></td>
<td>
<p>1 (default) to include results for the untuned XGB model, 0 to not include.</p>
</td></tr>
<tr><td><code id="plot.nested.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This program returns a plot to the graphics window, and may provide 
some numerical information to the R Console.
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_perf_glmnetr">plot_perf_glmnetr</a></code> , <code><a href="#topic+calplot">calplot</a></code> , <code><a href="#topic+plot.cv.glmnetr">plot.cv.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
plot(fit3)
plot(fit3, type="coef")


</code></pre>

<hr>
<h2 id='predict_ann_tab'>Get predicteds for an Artificial Neural Network model fit in nested.glmnetr()</h2><span id='topic+predict_ann_tab'></span>

<h3>Description</h3>

<p>All but one of the Artificial Neural Network (ANNs) fit by nested.glmnetr() are based 
upon a neural network model and input from a lasso model.  Thus a simple model(xs)
statement will not give the proper predicted values.  This function process information 
form the lasso and ANN model fits to give the correct predicteds.  Whereas the ann_tab_cv()
function ca be used to fit a model based upon an input data set it does not fit a 
lasso model to allow an informed starting point for the ANN fit.  The pieces fo this
are in nested.glmnetr().  To fit a cross validation (CV) informed ANN model fit
one can run nested.glmnetr() with folds_n = 0 to derive the full data models without 
doing a cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_ann_tab(object, xs, modl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_ann_tab_+3A_object">object</code></td>
<td>
<p>a output object from the nested.glmnetr() function</p>
</td></tr>
<tr><td><code id="predict_ann_tab_+3A_xs">xs</code></td>
<td>
<p>new data of the same form used as input to nested.glmnetr()</p>
</td></tr>
<tr><td><code id="predict_ann_tab_+3A_modl">modl</code></td>
<td>
<p>ANN model entry an integer from 1 to 5 indicating which &quot;lasso informed&quot; 
ANN is to be used for calculations.  The number corresponds to the position of the 
ensemble input from the nested.glmnetr() call.  The model must already be fit 
to calculate predicteds:   
1 for ensemble[1] = 1, for model based upon raw data ; 
2 for ensemble[2] = 1, raw data plus lasso predicteds as a predictor variable (features) ;
4 for ensemble[3] = 1, raw data plus lasso predicteds and initial weights corresponding to offset and allowed to update ; 
5 for ensemble[4] = 1, raw data plus lasso predicteds and initial weights corresponding to offset and not allowed to updated  ; 
6 for ensemble[5] = 1, nonzero relaxed lasso terms ; 
7 for ensemble[6] = 1, nonzero relaxed lasso terms plus lasso predicteds as a predictor variable (features) ;
8 for ensemble[7] = 1, nonzero relaxed lasso terms plus lasso predicteds with initial weights corresponding to offset and allowed to update ; 
9 for ensemble[8] = 1, nonzero relaxed lasso terms plus lasso predicteds with initial weights corresponding to offset and not allowed to update.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of predicteds
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ann_tab_cv">ann_tab_cv</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='predict.cv.glmnetr'>Give predicteds based upon a cv.glmnetr() output object.</h2><span id='topic+predict.cv.glmnetr'></span>

<h3>Description</h3>

<p>Give predicteds based upon a cv.glmnetr() output object. By default lambda and gamma 
are chosen as the minimizing values for the relaxed lasso model.  If gam=1 and lam=NULL 
then the best unrelaxed lasso model is chosen and if gam=0 and lam=NULL then
the best fully relaxed lasso model is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnetr'
predict(object, xs_new = NULL, lam = NULL, gam = NULL, comment = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.glmnetr_+3A_object">object</code></td>
<td>
<p>A cv.glmnetr (or nested.glmnetr) output object.</p>
</td></tr>
<tr><td><code id="predict.cv.glmnetr_+3A_xs_new">xs_new</code></td>
<td>
<p>The predictor matrix.  If NULL, then betas are provided.</p>
</td></tr>
<tr><td><code id="predict.cv.glmnetr_+3A_lam">lam</code></td>
<td>
<p>The lambda value for choice of beta.  If NULL, then 
lambda.min is used from the cross validated tuned relaxed model.  We
use the term lam instead of lambda as lambda usually denotes a vector 
in the package.</p>
</td></tr>
<tr><td><code id="predict.cv.glmnetr_+3A_gam">gam</code></td>
<td>
<p>The gamma value for choice of beta.  If NULL, then 
gamma.min is used from the cross validated tuned relaxed model.  We
use the term gam instead of gamma as gamma usually denotes a vector 
in the package.</p>
</td></tr>
<tr><td><code id="predict.cv.glmnetr_+3A_comment">comment</code></td>
<td>
<p>Default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.</p>
</td></tr>
<tr><td><code id="predict.cv.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the predict function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either predicteds (xs_new*beta estimates based upon the predictor matrix xs_new)  
or model coefficients, based upon a cv.glmnetr() output object.  When 
outputting coefficients (beta), creates a list 
with the first element, beta_, including 0 and non-0 terms and the 
second element, beta, including only non 0 terms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cv.glmnetr">summary.cv.glmnetr</a></code> , <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed for random numbers, optionally, to get reproducible results
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=200, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$y_ 
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
cv.glmnetr.fit = cv.glmnetr(xs, NULL, y_, NULL, family="gaussian", folds_n=3, limit=2) 
predict(cv.glmnetr.fit)

</code></pre>

<hr>
<h2 id='predict.cv.stepreg'>Beta's or predicteds based upon a cv.stepreg() output object.</h2><span id='topic+predict.cv.stepreg'></span>

<h3>Description</h3>

<p>Give predicteds or Beta's based upon a cv.stepreg() output object. If an input data matrix is 
specified the X*Beta's are output.  If an input data matrix is not specified then 
the Beta's are output.  In the first column values are given based upon df as a tuning 
parameter and in the second column values based upon p as a tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.stepreg'
predict(object, xs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.stepreg_+3A_object">object</code></td>
<td>
<p>cv.stepreg() output object</p>
</td></tr>
<tr><td><code id="predict.cv.stepreg_+3A_xs">xs</code></td>
<td>
<p>dataset for predictions.  Must have the same columns as the input predictor matrix in the call to cv.stepreg().</p>
</td></tr>
<tr><td><code id="predict.cv.stepreg_+3A_...">...</code></td>
<td>
<p>pass through parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of beta's or predicteds
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cv.stepreg">summary.cv.stepreg</a></code>, <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='predict.glmnetr'>Get predicteds or coefficients using a glmnetr output object</h2><span id='topic+predict.glmnetr'></span>

<h3>Description</h3>

<p>Give predicteds based upon a glmnetr() output object. Because the glmnetr() function 
has no cross validation information, lambda and gamma must be specified.  To choose 
lambda and gamma based upon cross validation one may use the cv.glmnetr() or nested.glmnetr() 
and the corresponding predict() functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmnetr'
predict(object, xs_new = NULL, lam = NULL, gam = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.glmnetr_+3A_object">object</code></td>
<td>
<p>A glmnetr output object</p>
</td></tr>
<tr><td><code id="predict.glmnetr_+3A_xs_new">xs_new</code></td>
<td>
<p>A desing matrix for predictions</p>
</td></tr>
<tr><td><code id="predict.glmnetr_+3A_lam">lam</code></td>
<td>
<p>The value for lambda for determining the lasso fit.  Required.</p>
</td></tr>
<tr><td><code id="predict.glmnetr_+3A_gam">gam</code></td>
<td>
<p>The value for gamma for determining the lasso fit. Required.</p>
</td></tr>
<tr><td><code id="predict.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the predict function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients or predictions using a glmnetr output object.  When
outputting coefficients (beta), creates a list with the first element, beta_, 
including 0 and non-0 terms and the second element, beta, including only 
non 0 terms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmnetr">glmnetr</a></code> , <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=200, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
glmnetr.fit = glmnetr( xs, NULL, y_, event, family="cox")
betas = predict(glmnetr.fit,NULL,exp(-2),0.5 )
betas$beta


</code></pre>

<hr>
<h2 id='predict.nested.glmnetr'>Give predicteds based upon the cv.glmnet output object contained in the 
nested.glmnetr output object.</h2><span id='topic+predict.nested.glmnetr'></span>

<h3>Description</h3>

<p>This is essentially a redirect to the summary.cv.glmnetr
function for nested.glmnetr output objects, based uopn the cv.glmnetr
output object contained in the nested.glmnetr output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested.glmnetr'
predict(object, xs_new = NULL, lam = NULL, gam = NULL, comment = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.nested.glmnetr_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr output object.</p>
</td></tr>
<tr><td><code id="predict.nested.glmnetr_+3A_xs_new">xs_new</code></td>
<td>
<p>The predictor matrix.  If NULL, then betas are provided.</p>
</td></tr>
<tr><td><code id="predict.nested.glmnetr_+3A_lam">lam</code></td>
<td>
<p>The lambda value for choice of beta.  If NULL, then 
lambda.min is used from the cross validation informed relaxed model.  We
use the term lam instead of lambda as lambda usually denotes a vector 
in the package.</p>
</td></tr>
<tr><td><code id="predict.nested.glmnetr_+3A_gam">gam</code></td>
<td>
<p>The gamma value for choice of beta.  If NULL, then 
gamma.min is used from the cross validation informed relaxed model.  We
use the term gam instead of gamma as gamma usually denotes a vector 
in the package.</p>
</td></tr>
<tr><td><code id="predict.nested.glmnetr_+3A_comment">comment</code></td>
<td>
<p>Default of TRUE to write to console information on lam and gam selected for output.
FALSE will suppress this write to console.</p>
</td></tr>
<tr><td><code id="predict.nested.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the predict function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the xs_new*Beta estimates based upon the predictor matrix, 
or model coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.cv.glmnetr">predict.cv.glmnetr</a></code> , <code><a href="#topic+predict_ann_tab">predict_ann_tab</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3) 
betas = predict(fit3)
betas$beta


</code></pre>

<hr>
<h2 id='print.nested.glmnetr'>A redirect to the summary() function for nested.glmnetr() output objects</h2><span id='topic+print.nested.glmnetr'></span>

<h3>Description</h3>

<p>A redirect to the summary() function for nested.glmnetr() output objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested.glmnetr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nested.glmnetr_+3A_x">x</code></td>
<td>
<p>a nested.glmnetr() output object.</p>
</td></tr>
<tr><td><code id="print.nested.glmnetr_+3A_...">...</code></td>
<td>
<p>additional pass through inputs for the print function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- a nested cross validation fit summary, or a cross validation model summary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3)  
print(fit3)


</code></pre>

<hr>
<h2 id='print.orf_tune'>Print output from orf_tune() function</h2><span id='topic+print.orf_tune'></span>

<h3>Description</h3>

<p>Print output from orf_tune() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orf_tune'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.orf_tune_+3A_x">x</code></td>
<td>
<p>output from an orf_tune() function</p>
</td></tr>
<tr><td><code id="print.orf_tune_+3A_...">...</code></td>
<td>
<p>optional pass through parameters to pass to print.orf()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary to console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.orf_tune">summary.orf_tune</a></code> , <code><a href="#topic+orf_tune">orf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='print.rf_tune'>Print output from rf_tune() function</h2><span id='topic+print.rf_tune'></span>

<h3>Description</h3>

<p>Print output from rf_tune() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf_tune'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rf_tune_+3A_x">x</code></td>
<td>
<p>output from an rf_tune() function</p>
</td></tr>
<tr><td><code id="print.rf_tune_+3A_...">...</code></td>
<td>
<p>optional pass through parameters to pass to print.rfsrc()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary to console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rf_tune">summary.rf_tune</a></code> , <code><a href="#topic+rf_tune">rf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='rederive_orf'>Rederive Oblique Random Forest models not kept in nested.glmnetr() output</h2><span id='topic+rederive_orf'></span>

<h3>Description</h3>

<p>Because the oblique random forest models sometimes take large 
amounts of storage one may decide to set keep=0 within the doorf list passed 
to nested.glmnetr().  This function allows the user to rederive the oblique 
random forest models without doing the search. Note, the oblique random 
forest fitting for survival data routine does not allow for (start,stop) 
times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rederive_orf(object, xs, y_, event = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rederive_orf_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr() output object</p>
</td></tr>
<tr><td><code id="rederive_orf_+3A_xs">xs</code></td>
<td>
<p>Same xs used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_orf_+3A_y_">y_</code></td>
<td>
<p>Same y_ used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_orf_+3A_event">event</code></td>
<td>
<p>Same event used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_orf_+3A_type">type</code></td>
<td>
<p>Same type used as input to ntested.glmnetr() for input object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an output like nested.glmnetr()$rf_tuned_fitX for X in c(&quot;&quot;, &quot;F&quot;, &quot;O&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orf_tune">orf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='rederive_rf'>Rederive Random Forest models not kept in nested.glmnetr() output</h2><span id='topic+rederive_rf'></span>

<h3>Description</h3>

<p>Because the random forest models sometimes take large amounts of 
storage one may decide to set keep=0 within the dorf list passed to 
nested.glmnetr().  This function allows the user to rederive the random forest 
models without doing the search. Note, the random forest fitting routine does
not allow for (start,stop) times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rederive_rf(object, xs, y_, event = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rederive_rf_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr() output object</p>
</td></tr>
<tr><td><code id="rederive_rf_+3A_xs">xs</code></td>
<td>
<p>Same xs used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_rf_+3A_y_">y_</code></td>
<td>
<p>Same y_ used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_rf_+3A_event">event</code></td>
<td>
<p>Same event used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_rf_+3A_type">type</code></td>
<td>
<p>Same type used as input to ntested.glmnetr() for input object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an output like nested.glmnetr()$rf_tuned_fitX for X in c(&quot;&quot;, &quot;F&quot;, &quot;O&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_tune">rf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='rederive_xgb'>Rederive XGB models not kept in nested.glmnetr() output</h2><span id='topic+rederive_xgb'></span>

<h3>Description</h3>

<p>Because the XGBoost models sometimes take large amounts of 
storage one may decide to set keep=0 with in the doxgb list passed to 
nested.glmnetr().  This function allows the user to rederive the XGBoost 
models without doing the search.  Note, the random forest fitting routine 
does not allow for (start,stop) times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rederive_xgb(object, xs, y_, event = NULL, type = "base", tuned = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rederive_xgb_+3A_object">object</code></td>
<td>
<p>A nested.glmnetr() output object</p>
</td></tr>
<tr><td><code id="rederive_xgb_+3A_xs">xs</code></td>
<td>
<p>Same xs used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_xgb_+3A_y_">y_</code></td>
<td>
<p>Same y_ used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_xgb_+3A_event">event</code></td>
<td>
<p>Same event used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_xgb_+3A_type">type</code></td>
<td>
<p>Same type used as input to ntested.glmnetr() for input object.</p>
</td></tr>
<tr><td><code id="rederive_xgb_+3A_tuned">tuned</code></td>
<td>
<p>1 (default) to derive the tuned model like with xgb.tuned(), 0
to derive the basic models like with xgb.simple().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an output like nested.glmnetr()$xgb.simple.fitX or 
nested.glmnetr()$xgb.tuned.fitX for X in c(&quot;&quot;, &quot;F&quot;, &quot;O&quot;)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xgb.tuned">xgb.tuned</a></code> , <code><a href="#topic+xgb.simple">xgb.simple</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='rf_tune'>Fit a Random Forest model on data provided in matrix and vector formats.</h2><span id='topic+rf_tune'></span>

<h3>Description</h3>

<p>Fit an Random Forest model using the rfsrc() function of the 
randomForestSRC package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_tune(
  xs,
  start = NULL,
  y_,
  event = NULL,
  family = NULL,
  mtryc = NULL,
  ntreec = NULL,
  nsplitc = 8,
  seed = NULL,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_tune_+3A_xs">xs</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_start">start</code></td>
<td>
<p>an optional vector of start times in case of a Cox model. Class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_y_">y_</code></td>
<td>
<p>dependent variable as a vector: time, or stop time for Cox model, Y_ 0 or 1 for binomial (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_event">event</code></td>
<td>
<p>event indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot; (default)</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_mtryc">mtryc</code></td>
<td>
<p>a vector (numeric) of values to search over for optimization of the 
Random Forest fit.  This if for the mtry input variable of the rfsrc() program 
specifying the number of terms to consider in each step of teh Random Forest fit.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_ntreec">ntreec</code></td>
<td>
<p>a vector (numeric) of 2 values, the first for the number of forests
(ntree from rfsrc()) to use when searhcing for a better bit and the second to use
when fitting the final model.  More trees should give a better fit but 
require more computations and storage for the final. 
model.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_nsplitc">nsplitc</code></td>
<td>
<p>This nsplit of rfsrc(), a non-negative integer for the  number of 
random splits for a predictor.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() so one can reproduce the model fit.  If 
NULL the program will generate a random seed.  Whether specified or NULL, the 
seed is stored in the output object for future reference.  Note,
for the default this randomly generated seed depends on the seed in memory at that 
time so will depend on any calls of set.seed prior to the call of this function.</p>
</td></tr>
<tr><td><code id="rf_tune_+3A_track">track</code></td>
<td>
<p>1 to output a brief summary of the final selected model, 2 to 
output a brief summary on each model fit in search of a better model or 0 
(default) to not output this information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Random Forest model fit
</p>


<h3>Author(s)</h3>

<p>Walter Kremers (kremers.walter@mayo.edu)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rf_tune">summary.rf_tune</a></code> , <code><a href="#topic+rederive_rf">rederive_rf</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='roundperf'>round elements of a summary.glmnetr() output</h2><span id='topic+roundperf'></span>

<h3>Description</h3>

<p>round elements of a summary.glmnetr() output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundperf(summdf, digits = 3, resample = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundperf_+3A_summdf">summdf</code></td>
<td>
<p>a summary data frame from summary.nested.glmnetr() obtained using 
the option table=0</p>
</td></tr>
<tr><td><code id="roundperf_+3A_digits">digits</code></td>
<td>
<p>the minimum number of decimals to display the elements of the data
frame</p>
</td></tr>
<tr><td><code id="roundperf_+3A_resample">resample</code></td>
<td>
<p>1 (default) if the summdf object is a summary for an analysis including
nested cross validation, 0 if only the full data models were fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with same form as the input but with rounding for easier 
display
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.nested.glmnetr">summary.nested.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='stepreg'>Fit the steps of a stepwise regression.</h2><span id='topic+stepreg'></span>

<h3>Description</h3>

<p>Fit the steps of a stepwise regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepreg(
  xs_st,
  start_time_st = NULL,
  y_st,
  event_st,
  steps_n = 0,
  method = "loglik",
  family = NULL,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepreg_+3A_xs_st">xs_st</code></td>
<td>
<p>predictor input - an n by p matrix, where n (rows) is sample size, and p (columns) 
the number of predictors.  Must be in matrix form for complete data, no NA's, no Inf's, etc.,
and not a data frame.</p>
</td></tr>
<tr><td><code id="stepreg_+3A_start_time_st">start_time_st</code></td>
<td>
<p>start time, Cox model only - class numeric of length same as number of patients (n)</p>
</td></tr>
<tr><td><code id="stepreg_+3A_y_st">y_st</code></td>
<td>
<p>output vector: time, or stop time for Cox model, y_st 0 or 1 for binomal (logistic), numeric for gaussian. 
Must be a vector of length same as number of sample size.</p>
</td></tr>
<tr><td><code id="stepreg_+3A_event_st">event_st</code></td>
<td>
<p>event_st indicator, 1 for event, 0 for census, Cox model only.
Must be a numeric vector of length same as sample size.</p>
</td></tr>
<tr><td><code id="stepreg_+3A_steps_n">steps_n</code></td>
<td>
<p>number of steps done in stepwise regression fitting</p>
</td></tr>
<tr><td><code id="stepreg_+3A_method">method</code></td>
<td>
<p>method for choosing model in stepwise procedure, &quot;loglik&quot; or &quot;concordance&quot;.
Other procedures use the &quot;loglik&quot;.</p>
</td></tr>
<tr><td><code id="stepreg_+3A_family">family</code></td>
<td>
<p>model family, &quot;cox&quot;, &quot;binomial&quot; or &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="stepreg_+3A_track">track</code></td>
<td>
<p>1 to output stepwise fit program, 0 (default) to suppress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>does a stepwise regression of depth maximum depth steps_n
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.stepreg">summary.stepreg</a></code> , <code><a href="#topic+aicreg">aicreg</a></code> , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(18306296)
sim.data=glmnetr.simdata(nrows=100, ncols=100, beta=c(0,1,1))
# this gives a more intersting case but takes longer to run
xs=sim.data$xs           
# this will work numerically
xs=sim.data$xs[,c(2,3,50:55)] 
y_=sim.data$yt  
event=sim.data$event
# for a Cox model 
cox.step.fit = stepreg(xs, NULL, y_, event, family="cox", steps_n=40) 
# ... and for a linear model 
y_=sim.data$yt  
norm.step.fit = stepreg(xs, NULL, y_, NULL, family="gaussian", steps_n=40) 

</code></pre>

<hr>
<h2 id='summary.cv.glmnetr'>Output summary of a cv.glmnetr() output object.</h2><span id='topic+summary.cv.glmnetr'></span>

<h3>Description</h3>

<p>Summarize the cross-validation informed model fit.  The fully penalized
(gamma=1) beta estimate will not be given by default but can too be output  
using printg1=TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnetr'
summary(object, printg1 = "FALSE", orderall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cv.glmnetr_+3A_object">object</code></td>
<td>
<p>a cv.glmnetr() output object.</p>
</td></tr>
<tr><td><code id="summary.cv.glmnetr_+3A_printg1">printg1</code></td>
<td>
<p>TRUE to also print out the fully penalized lasso beta, else FALSE to suppress.</p>
</td></tr>
<tr><td><code id="summary.cv.glmnetr_+3A_orderall">orderall</code></td>
<td>
<p>By default (orderall=FALSE) the order terms enter into the lasso model 
is given for the number of terms that enter in lasso minimizing loss model.  If 
orderall=TRUE then all terms that are included in any lasso fit are described.</p>
</td></tr>
<tr><td><code id="summary.cv.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficient estimates (beta)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.cv.glmnetr">predict.cv.glmnetr</a></code> , <code><a href="#topic+cv.glmnetr">cv.glmnetr</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set seed for random numbers, optionally, to get reproducible results
set.seed(82545037)
sim.data=glmnetr.simdata(nrows=100, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$y_ 
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
cv.glmnetr.fit = cv.glmnetr(xs, NULL, y_, NULL, family="gaussian", folds_n=3, limit=2) 
summary(cv.glmnetr.fit)

</code></pre>

<hr>
<h2 id='summary.cv.stepreg'>Summarize results from a cv.stepreg() output object.</h2><span id='topic+summary.cv.stepreg'></span>

<h3>Description</h3>

<p>Summarize results from a cv.stepreg() output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.stepreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cv.stepreg_+3A_object">object</code></td>
<td>
<p>A cv.stepreg() output object</p>
</td></tr>
<tr><td><code id="summary.cv.stepreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of a stepreg() (stepwise regression) output object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.cv.stepreg">predict.cv.stepreg</a></code>  , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(955702213)
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=c(0,1,1))
# this gives a more interesting case but takes longer to run
xs=sim.data$xs           
# this will work numerically as an example 
xs=sim.data$xs[,c(2,3,50:55)] 
dim(xs)
y_=sim.data$yt 
event=sim.data$event
# for this example we use small numbers for steps_n and folds_n to shorten run time 
cv.stepreg.fit = cv.stepreg(xs, NULL, y_, event, steps_n=10, folds_n=3, track=0)
summary(cv.stepreg.fit)


</code></pre>

<hr>
<h2 id='summary.nested.glmnetr'>Summarize a nested.glmnetr() output object</h2><span id='topic+summary.nested.glmnetr'></span>

<h3>Description</h3>

<p>Summarize the model fit from a nested.glmnetr() output object, i.e. the fit of 
a cross-validation informed relaxed lasso model fit, inferred by nested cross 
validation.  Else summarize the cross-validated model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nested.glmnetr'
summary(
  object,
  cvfit = FALSE,
  pow = 2,
  printg1 = FALSE,
  digits = 4,
  Call = NULL,
  onese = 0,
  table = 1,
  tuning = 0,
  width = 84,
  cal = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nested.glmnetr_+3A_object">object</code></td>
<td>
<p>a nested.glmnetr() output object.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_cvfit">cvfit</code></td>
<td>
<p>default of FALSE to summarize fit of a cross validation informed 
relaxed lasso model fit, inferred by nested cross validation.  Option of TRUE 
will describe the cross validation informed relaxed lasso model itself.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_pow">pow</code></td>
<td>
<p>the power to which the average of correlations is to be raised.  Only 
applies to the &quot;gaussian&quot; model.  Default is 2 to yield R-square but can be on to 
show correlations.  Pow is ignored for the family of &quot;cox&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_printg1">printg1</code></td>
<td>
<p>TRUE to also print out the fully penalized lasso beta, else to suppress.
Only applies to cvfit=TRUE.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_digits">digits</code></td>
<td>
<p>digits for printing of deviances, linear calibration coefficients 
and agreement (concordances and R-squares).</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_call">Call</code></td>
<td>
<p>1 to print call used in generation of the object, 0 or NULL to not print</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_onese">onese</code></td>
<td>
<p>0 (default) to not include summary for 1se lasso fits in tables, 1 to include</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_table">table</code></td>
<td>
<p>1 to print table to console, 0 to output the tabled information to a data frame</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_tuning">tuning</code></td>
<td>
<p>1 to print tuning parameters, 0 (default) to not print</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_width">width</code></td>
<td>
<p>character width of the text body preceding the performance 
measures which can be adjusted between 60 and 120.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_cal">cal</code></td>
<td>
<p>1 print out performance statistics for lasso models calibrated on 
training data. 0 (default) to not print.  Note, these training data calibrated
estimates may not do very well for some of the other machine learning models.</p>
</td></tr>
<tr><td><code id="summary.nested.glmnetr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- a nested cross validation fit summary, or a cross validation model summary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested.compare">nested.compare</a></code> , <code><a href="#topic+nested.cis">nested.cis</a></code> , <code><a href="#topic+summary.cv.glmnetr">summary.cv.glmnetr</a></code> , <code><a href="#topic+roundperf">roundperf</a></code> , 
<code><a href="#topic+plot.nested.glmnetr">plot.nested.glmnetr</a></code> , <code><a href="#topic+calplot">calplot</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
xs=sim.data$xs 
y_=sim.data$yt
event=sim.data$event
# for this example we use a small number for folds_n to shorten run time 
fit3 = nested.glmnetr(xs, NULL, y_, event, family="cox", folds_n=3)  
summary(fit3)


</code></pre>

<hr>
<h2 id='summary.orf_tune'>Summarize output from rf_tune() function</h2><span id='topic+summary.orf_tune'></span>

<h3>Description</h3>

<p>Summarize output from rf_tune() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orf_tune'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.orf_tune_+3A_object">object</code></td>
<td>
<p>output from an rf_tune() function</p>
</td></tr>
<tr><td><code id="summary.orf_tune_+3A_...">...</code></td>
<td>
<p>optional pass through parameters to pass to summary.orsf()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary to console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_tune">rf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='summary.rf_tune'>Summarize output from rf_tune() function</h2><span id='topic+summary.rf_tune'></span>

<h3>Description</h3>

<p>Summarize output from rf_tune() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rf_tune'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rf_tune_+3A_object">object</code></td>
<td>
<p>output from an rf_tune() function</p>
</td></tr>
<tr><td><code id="summary.rf_tune_+3A_...">...</code></td>
<td>
<p>optional pass through parameters to pass to summary.rfsrc()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary to console
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rf_tune">rf_tune</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='summary.stepreg'>Briefly summarize steps in a stepreg() output object, i.e. a stepwise regression fit</h2><span id='topic+summary.stepreg'></span>

<h3>Description</h3>

<p>Briefly summarize steps in a stepreg() output object, i.e. a stepwise regression fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stepreg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stepreg_+3A_object">object</code></td>
<td>
<p>A stepreg() output object</p>
</td></tr>
<tr><td><code id="summary.stepreg_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summarize a stepreg() object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepreg">stepreg</a></code> , <code><a href="#topic+cv.stepreg">cv.stepreg</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>

<hr>
<h2 id='xgb.simple'>Get a simple XGBoost model fit (no tuning)</h2><span id='topic+xgb.simple'></span>

<h3>Description</h3>

<p>This fits a gradient boosting machine model using the XGBoost
platform.  If uses a single set of hyperparameters that have sometimes been 
reasonable so runs very fast.  For a better fit one can use xgb.tuned()
which searches for a set of hyperparameters using the mlrMBO package
which will generally provide a better fit but take much longer.  See xgb.tuned()
for a description of the data format required for input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgb.simple(
  train.xgb.dat,
  booster = "gbtree",
  objective = "survival:cox",
  eval_metric = NULL,
  minimize = NULL,
  seed = NULL,
  folds = NULL,
  doxgb = NULL,
  track = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgb.simple_+3A_train.xgb.dat">train.xgb.dat</code></td>
<td>
<p>The data to be used for training the XGBoost model</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_booster">booster</code></td>
<td>
<p>for now just &quot;gbtree&quot; (default)</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_objective">objective</code></td>
<td>
<p>one of &quot;survival:cox&quot; (default), &quot;binary:logistic&quot; or &quot;reg:squarederror&quot;</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_eval_metric">eval_metric</code></td>
<td>
<p>one of &quot;cox-nloglik&quot; (default), &quot;auc&quot;, &quot;rmse&quot; or NULL.  Default
of NULL will select an appropriate value based upon the objective value.</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_minimize">minimize</code></td>
<td>
<p>whether the eval_metric is to be minimized or maximized</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() to assure one can get the same results twice.  If NULL 
the program will generate a random seed.  Whether specified or NULL, the seed is stored in the output
object for future reference.</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_folds">folds</code></td>
<td>
<p>an optional list where each element is a vector of indexes for a 
test fold.  Default is NULL.  If specified then doxgb$nfold is ignored as in xgb.cv().</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_doxgb">doxgb</code></td>
<td>
<p>a list with parameters for passed to xgb.cv() including $nfold, $nrounds,
and $early_stopping_rounds.  If not provided defaults will be used.  Defaults
can be seen form the output object$doxgb element, again a list. In case not NULL, 
the seed and folds option values override the $seed and $folds values in doxgb.</p>
</td></tr>
<tr><td><code id="xgb.simple_+3A_track">track</code></td>
<td>
<p>0 (default) to not track progress, 2 to track progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a XGBoost model fit
</p>


<h3>Author(s)</h3>

<p>Walter K Kremers with contributions from Nicholas B Larson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xgb.tuned">xgb.tuned</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data for a Cox model 
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
Surv.xgb = ifelse( sim.data$event==1, sim.data$yt, -sim.data$yt )
data.full &lt;- xgboost::xgb.DMatrix(data = sim.data$xs, label = Surv.xgb)
# for this example we use a small number for folds_n and nrounds to shorten run time 
xgbfit = xgb.simple( data.full, objective = "survival:cox")
preds = predict(xgbfit, sim.data$xs)
summary( preds ) 
preds[1:8]


</code></pre>

<hr>
<h2 id='xgb.tuned'>Get a tuned XGBoost model fit</h2><span id='topic+xgb.tuned'></span>

<h3>Description</h3>

<p>This fits a gradient boosting machine model using the XGBoost
platform.  It uses the mlrMBO mlrMBO package to search for a well fitting set of 
hyperparameters and will generally provide a better fit than xgb.simple(). 
Both this program and xgb.simple() require data to be provided in a 
xgb.DMatrix() object.  This object can be constructed with a command like 
data.full &lt;- xgb.DMatrix( data=myxs, label=mylabel), where myxs object contains the 
predictors (features) in a numerical matrix format with no missing 
values, and mylabel is the outcome or dependent variable.  For logistic regression
this would typically be a vector of 0's and 1's.  For linear regression this would be 
vector of numerical values. For a Cox proportional hazards model this would be 
in a format required for XGBoost, which is different than for the survival package 
or glmnet package.  For the Cox model a vector is used where observations 
associated with an event are assigned the time of event, and observations 
associated with censoring are assigned the NEGATIVE of the time of censoring.  In    
this way information about time and status are communicated in a single vector
instead of two vectors.  The xgb.tuned() function does not handle (start,stop) 
time, i.e. interval, data.  To tune the xgboost model we use the mlrMBO package
which &quot;suggests&quot; the DiceKriging and rgenoud packages, but doe not install 
these.  Still, for xgb.tuned() to run it seems that one should install the 
DiceKriging and rgenoud packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xgb.tuned(
  train.xgb.dat,
  booster = "gbtree",
  objective = "survival:cox",
  eval_metric = NULL,
  minimize = NULL,
  seed = NULL,
  folds = NULL,
  doxgb = NULL,
  track = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xgb.tuned_+3A_train.xgb.dat">train.xgb.dat</code></td>
<td>
<p>The data to be used for training the XGBoost model</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_booster">booster</code></td>
<td>
<p>for now just &quot;gbtree&quot; (default)</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_objective">objective</code></td>
<td>
<p>one of &quot;survival:cox&quot; (default), &quot;binary:logistic&quot; or &quot;reg:squarederror&quot;</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_eval_metric">eval_metric</code></td>
<td>
<p>one of &quot;cox-nloglik&quot; (default), &quot;auc&quot; or &quot;rmse&quot;,</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_minimize">minimize</code></td>
<td>
<p>whether the eval_metric is to be minimized or maximized</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_seed">seed</code></td>
<td>
<p>a seed for set.seed() to assure one can get the same results twice.  If NULL 
the program will generate a random seed.  Whether specified or NULL, the seed is stored in the output
object for future reference.</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_folds">folds</code></td>
<td>
<p>an optional list where each element is a vector of indeces for a 
test fold.  Default is NULL.  If specified then nfold is ignored a la xgb.cv().</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_doxgb">doxgb</code></td>
<td>
<p>A list specifying how the program is to do the xgb tune and 
fit.  The list can have elements $nfold, $nrounds,
and $early_stopping_rounds, each numerical values of length 1, $folds, a list as 
used by xgb.cv() do identify folds for cross validation, and $eta, $gamma, $max_depth, 
$min_child_seight, $colsample_bytree, $lambda, $alpha and $subsample, each a numeric 
of length 2 giving the lower and upper values for the respective tuning 
parameter.  The meaning of these terms is as in 'xgboost' xgb.train().  If 
not provided defaults will be used.  Defaults
can be seen from the output object$doxgb element, again a list. In case not NULL, 
the seed and folds option values override the $seed and $folds values.</p>
</td></tr>
<tr><td><code id="xgb.tuned_+3A_track">track</code></td>
<td>
<p>0 (default) to not track progress, 2 to track progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tuned XGBoost model fit
</p>


<h3>Author(s)</h3>

<p>Walter K Kremers with contributions from Nicholas B Larson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xgb.simple">xgb.simple</a></code> , <code><a href="#topic+rederive_xgb">rederive_xgb</a></code> , <code><a href="#topic+nested.glmnetr">nested.glmnetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data for a Cox model 
sim.data=glmnetr.simdata(nrows=1000, ncols=100, beta=NULL)
Surv.xgb = ifelse( sim.data$event==1, sim.data$yt, -sim.data$yt )
data.full &lt;- xgboost::xgb.DMatrix(data = sim.data$xs, label = Surv.xgb)
# for this example we use a small number for folds_n and nrounds to shorten 
# run time.  This may still take a minute or so.  
# xgbfit=xgb.tuned(data.full,objective="survival:cox",nfold=5,nrounds=20)
# preds = predict(xgbfit, sim.data$xs)
# summary( preds ) 


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
