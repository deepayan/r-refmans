<!DOCTYPE html><html><head><title>Help for package hopit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hopit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.hopit'><p>Extracting the Akaike Information Criterion from the fitted model</p></a></li>
<li><a href='#anova.hopit'><p>Likelihood Ratio Test Tables</p></a></li>
<li><a href='#boot_hopit'><p>Bootstrapping hopit model</p></a></li>
<li><a href='#coef.hopit'><p>Extracting the model coefficients</p></a></li>
<li><a href='#get.hopit.start'><p>INTERNAL: Get the starting parameters</p></a></li>
<li><a href='#getCutPoints'><p>Calculate the threshold cut-points and individual adjusted responses using Jurges' method</p></a></li>
<li><a href='#getLevels'><p>Summarize the adjusted and the original self-rated response levels</p></a></li>
<li><a href='#healthsurvey'><p>Artificially generated health survey data</p></a></li>
<li><a href='#hopit'><p>Generalized hierarchical ordered threshold models.</p></a></li>
<li><a href='#hopit_derivLL'><p>INTERNAL: The gradient of the log likelihood function</p></a></li>
<li><a href='#hopit_fitter'><p>INTERNAL: Fit a <code>hopit</code> model given the starting parameters</p></a></li>
<li><a href='#hopit_Latent'><p>INTERNAL: Calculate the predicted continuous latent measure (h_i).</p></a></li>
<li><a href='#hopit_negLL'><p>INTERNAL: The log likelihood function</p></a></li>
<li><a href='#hopit_Threshold'><p>INTERNAL: Calculate the model cut-points (alpha)</p></a></li>
<li><a href='#hopit.control'><p>Auxiliary for controlling the fitting of a <code>hopit</code> model</p></a></li>
<li><a href='#latentIndex'><p>Calculate the latent index</p></a></li>
<li><a href='#logLik.hopit'><p>Extracting a log likelihood of the fitted model</p></a></li>
<li><a href='#lrt.hopit'><p>Likelihood ratio test for a pair of models</p></a></li>
<li><a href='#percentile_CI'><p>Calculating the confidence intervals of the bootstrapped function using the percentile method</p></a></li>
<li><a href='#plot.hopitCP'><p>Plotting Cut-Points</p></a></li>
<li><a href='#plot.hopitDW'><p>Plotting standardized coefficients</p></a></li>
<li><a href='#plot.hopitHI'><p>Plotting Latent Index</p></a></li>
<li><a href='#plot.hopitLV'><p>Plotting getLevels object</p></a></li>
<li><a href='#plot.profile.hopit'><p>Plot the log likelihood profile for a profile.hopit object</p></a></li>
<li><a href='#print.hopit'><p>Printing basic information about fitted <code>hopit</code> model</p></a></li>
<li><a href='#print.lrt.hopit'><p>Printing an object calculated by <code>lrt.hopit</code></p></a></li>
<li><a href='#print.profile.hopit'><p>Print method for a profile.hopit object</p></a></li>
<li><a href='#profile.hopit'><p>Calculate the log likelihood profile for the fitted <code>hopit</code> model</p></a></li>
<li><a href='#sigma.hopit'><p>Extract the <code>Sigma</code> parameter from a <code>hopit</code> model</p></a></li>
<li><a href='#standardizeCoef'><p>Standardization of the coefficients</p></a></li>
<li><a href='#summary.hopit'><p>Calculate the model summary</p></a></li>
<li><a href='#svy.varcoef_hopit'><p>Calculation of the variance-covariance matrix for a specified survey design (experimental function)</p></a></li>
<li><a href='#vcov.hopit'><p>Variance-covariance matrix from the fitted model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Ordered Probit Models with Application to Reporting
Heterogeneity</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.6</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), survey (&ge; 4.1-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Rcpp, graphics, stats, grDevices, questionr, parallel,
Rdpack (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Self-reported health, happiness, attitudes, and other statuses or perceptions are often the subject of biases that may come from different sources. For example, the evaluation of an individual’s own health may depend on previous medical diagnoses, functional status, and symptoms and signs of illness; as on well as life-style behaviors, including contextual social, gender, age-specific, linguistic and other cultural factors (Jylha 2009 &lt;<a href="https://doi.org/10.1016%2Fj.socscimed.2009.05.013">doi:10.1016/j.socscimed.2009.05.013</a>&gt;; Oksuzyan et al. 2019 &lt;<a href="https://doi.org/10.1016%2Fj.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>&gt;). The hopit package offers versatile functions for analyzing different self-reported ordinal variables, and for helping to estimate their biases. Specifically, the package provides the function to fit a generalized ordered probit model that regresses original self-reported status measures on two sets of independent variables (King et al. 2004 &lt;<a href="https://doi.org/10.1017%2FS0003055403000881">doi:10.1017/S0003055403000881</a>&gt;; Jurges 2007  &lt;<a href="https://doi.org/10.1002%2Fhec.1134">doi:10.1002/hec.1134</a>&gt;; Oksuzyan et al. 2019  &lt;<a href="https://doi.org/10.1016%2Fj.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>&gt;). The first set of variables (e.g., health variables) included in the regression are individual statuses and characteristics that are directly related to the self-reported variable. In the case of self-reported health, these could be chronic conditions, mobility level, difficulties with daily activities, performance on grip strength tests, anthropometric measures, and lifestyle behaviors. The second set of independent variables (threshold variables) is used to model cut-points between adjacent self-reported response categories as functions of individual characteristics, such as gender, age group, education, and country (Oksuzyan et al. 2019 &lt;<a href="https://doi.org/10.1016%2Fj.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>&gt;). The model helps to adjust for specific socio-demographic and cultural differences in how the continuous latent health is projected onto the ordinal self-rated measure. The fitted model can be used to calculate an individual predicted latent status variable, a latent index, and standardized latent coefficients; and makes it possible to reclassify a categorical status measure that has been adjusted for inter-individual differences in reporting behavior.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), R.rsp (&ge; 0.43.0), usethis (&ge; 1.5.0),
knitr (&ge; 1.20), rmarkdown (&ge; 1.12), qpdf, roxygen2 (&ge; 6.1.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 11:30:06 UTC; maciej</td>
</tr>
<tr>
<td>Author:</td>
<td>Maciej J. Danko <a href="https://orcid.org/0000-0002-7924-9022"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maciej J. Danko &lt;Maciej.Danko@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 13:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.hopit'>Extracting the Akaike Information Criterion from the fitted model</h2><span id='topic+AIC.hopit'></span>

<h3>Description</h3>

<p>Extract the Akaike Information Criterion (AIC) from a fitted <code>hopit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
AIC(object, ..., k = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.hopit_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="AIC.hopit_+3A_...">...</code></td>
<td>
<p>additional objects of the class <code>hopit</code>.</p>
</td></tr>
<tr><td><code id="AIC.hopit_+3A_k">k</code></td>
<td>
<p>a penalty per parameter to be used; the default k = 2 is the
classical AIC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='anova.hopit'>Likelihood Ratio Test Tables</h2><span id='topic+anova.hopit'></span>

<h3>Description</h3>

<p>Perform the likelihood ratio test(s) for two or more <code>hopit</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
anova(object, ..., method = c("sequential",
"with.most.complex", 'with.least.complex'),
direction = c("decreasing", "increasing"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.hopit_+3A_object">object</code></td>
<td>
<p>an object containing the results returned by a <code>hopit</code>.</p>
</td></tr>
<tr><td><code id="anova.hopit_+3A_...">...</code></td>
<td>
<p>an additional object(s) of the same type.</p>
</td></tr>
<tr><td><code id="anova.hopit_+3A_method">method</code></td>
<td>
<p>the method of ordered model comparisons. Choose <code>"sequential"</code>
for 1-2, 2-3, 3-4, ... comparisons or
<code>"with.most.complex"</code> for 1-2, 1-3, 1-4, ... comparisons,
where 1 is the most complex model (the least complex for <code>"with.least.complex"</code>).</p>
</td></tr>
<tr><td><code id="anova.hopit_+3A_direction">direction</code></td>
<td>
<p>determine if the complexity of listed models is
<code>"increasing"</code> or <code>"decreasing"</code> (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix with the results of the test(s).
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.lrt.hopit">print.lrt.hopit</a></code>,
<code><a href="#topic+lrt.hopit">lrt.hopit</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fitting two nested models
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# a model with an interaction between hypertension and high_cholesterol
model2 &lt;- hopit(latent.formula = health ~ hypertension * high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# a likelihood ratio test
lrt1 &lt;- anova(model1, model2)
lrt1

# print results in a shorter form
print(lrt1, short = TRUE)

# or equivalently
lrt.hopit(model2, model1)

# Example 2 ---------------------

# fitting additional nested models
model3 &lt;- hopit(latent.formula = health ~ hypertension * high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese * diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

model4 &lt;- hopit(latent.formula = health ~ hypertension * high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese * diabetes + other_diseases,
              thresh.formula = ~ sex * ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# sequential likelihood ratio tests
# model complexity increases so direction = "increasing"
anova(model1, model2, model3, model4,
      direction = "increasing", method = "sequential")

# likelihood ratio tests of the most complex model with the rest of the models
anova(model1, model2, model3, model4,
      direction = "increasing", method = "with.most.complex")

# likelihood ratio tests of the least complex model with the rest of the models
anova(model1, model2, model3, model4,
      direction = "increasing", method = "with.least.complex")

</code></pre>

<hr>
<h2 id='boot_hopit'>Bootstrapping hopit model</h2><span id='topic+boot_hopit'></span>

<h3>Description</h3>

<p><code>boot_hopit</code> performs the bootstrap of a function dependent on a fitted model.
In each of the bootstrap repetitions, a set of new model coefficients is drawn from the multivariate normal distribution,
assuming the originally estimated model coefficients (see <code><a href="#topic+coef.hopit">coef.hopit</a></code>)
as a mean and using the model variance-covariance matrix (see <code><a href="#topic+vcov.hopit">vcov.hopit</a></code>).
The drawn coefficients are then used to calculate the measure of interest using a function delivered by the <code>func</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_hopit(
  model,
  func,
  data = model$frame,
  nboot = 500,
  unlist = TRUE,
  boot.only.latent = TRUE,
  parallel.flag = FALSE,
  parallel.nb_cores = NULL,
  parallel.packages = NULL,
  parallel.variables = NULL,
  robust.vcov,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_hopit_+3A_model">model</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_func">func</code></td>
<td>
<p>a function to be bootstrapped of the form <code>func(model, ...)</code>.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_data">data</code></td>
<td>
<p>data used to fit the model.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_nboot">nboot</code></td>
<td>
<p>a number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_unlist">unlist</code></td>
<td>
<p>a logical indicating whether to unlist the boot object.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_boot.only.latent">boot.only.latent</code></td>
<td>
<p>a logical indicating whether to perform the bootstrap on latent variables only.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_parallel.flag">parallel.flag</code></td>
<td>
<p>a logical if to use parallel computations.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_parallel.nb_cores">parallel.nb_cores</code></td>
<td>
<p>number of cores (&lt;= number of CPU cores on the current host).</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_parallel.packages">parallel.packages</code></td>
<td>
<p>list of packages needed to run &quot;func&quot;.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_parallel.variables">parallel.variables</code></td>
<td>
<p>list of global variables and functions needed to run &quot;func&quot;.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_robust.vcov">robust.vcov</code></td>
<td>
<p>see <code><a href="#topic+vcov.hopit">vcov.hopit</a></code>.</p>
</td></tr>
<tr><td><code id="boot_hopit_+3A_...">...</code></td>
<td>
<p>other parameters passed to the <code>func</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with bootstrapped elements.
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+percentile_CI">percentile_CI</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, <code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+latentIndex">latentIndex</a></code>, <code><a href="#topic+standardiseCoef">standardiseCoef</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# fit a model
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# Example 1 ---------------------
# bootstrapping cut-points

# a function to be bootstrapped
cutpoints &lt;-  function(model) getCutPoints(model)$cutpoints
B &lt;- boot_hopit(model = model1, func = cutpoints, nboot = 100)

# calculate lower and upper bounds using the percentile method
cutpoints.CI &lt;- percentile_CI(B)

# print estimated cutpoints and their confidence intervals
cutpoints(model1)
cutpoints.CI

# Example 2 ---------------------
# bootstrapping differences in health levels

# a function to be bootstrapped
diff_BadHealth &lt;- function(model) {
  hl &lt;- getLevels(model = model, formula=~ sex + ageclass, sep=' ')
  hl$original[,1] + hl$original[,2] - hl$adjusted[,1]- hl$adjusted[,2]
}

# estimate the difference
est.org &lt;- diff_BadHealth(model = model1)

# perform the bootstrap
B &lt;- boot_hopit(model = model1, func = diff_BadHealth, nboot = 100)

# calculate lower and upper bounds using the percentile method
est.CI &lt;- percentile_CI(B)

# plot the difference and its (asymmetrical) confidence intervals
pmar &lt;- par('mar'); par(mar = c(9.5,pmar[2:4]))
m &lt;- max(abs(est.CI))
pos &lt;- barplot(est.org, names.arg = names(est.org), las = 3,
               ylab = 'Original - Adjusted',
               ylim=c(-m, m), density = 20, angle = c(45, -45),
               col = c('blue', 'orange'))
for (k in seq_along(pos)) lines(c(pos[k,1],pos[k,1]),
                                est.CI[,k], lwd = 2, col = 2)
abline(h = 0); box(); par(mar = pmar)

</code></pre>

<hr>
<h2 id='coef.hopit'>Extracting the model coefficients</h2><span id='topic+coef.hopit'></span><span id='topic+coefficients.hopit'></span>

<h3>Description</h3>

<p>Extract the model coefficients from the <code>hopit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
coef(object, aslist = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.hopit_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="coef.hopit_+3A_aslist">aslist</code></td>
<td>
<p>a logical indicating whether the model coefficients should be returned
as a list of three vectors
related to latent variables, threshold lambdas, and threshold gammas.</p>
</td></tr>
<tr><td><code id="coef.hopit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='get.hopit.start'>INTERNAL: Get the starting parameters</h2><span id='topic+get.hopit.start'></span>

<h3>Description</h3>

<p>INTERNAL: Get the starting parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hopit.start(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.hopit.start_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="get.hopit.start_+3A_data">data</code></td>
<td>
<p>a data.frame with data used to fit the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code>hopit</code> object.
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='getCutPoints'>Calculate the threshold cut-points and individual adjusted responses using Jurges' method</h2><span id='topic+getCutPoints'></span>

<h3>Description</h3>

<p>Calculate the threshold cut-points and individual adjusted responses using Jurges' method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCutPoints(model, decreasing.levels = model$decreasing.levels, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCutPoints_+3A_model">model</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
<tr><td><code id="getCutPoints_+3A_decreasing.levels">decreasing.levels</code></td>
<td>
<p>a logical indicating whether self-reported health classes are ordered in increasing order.</p>
</td></tr>
<tr><td><code id="getCutPoints_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>cutpoints</code></td>
<td>
<p> cut-points for the adjusted categorical response levels with the corresponding percentiles of the latent index.</p>
</td></tr>
<tr><td><code>adjusted.levels</code></td>
<td>
<p> adjusted categorical response levels for each individual.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>References</h3>

<p>Jurges H (2007).
&ldquo;True health vs response styles: exploring cross-country differences in self-reported health.&rdquo;
<em>Health Economics</em>, <b>16</b>(2), 163-178.
<a href="https://doi.org/10.1002/hec.1134">doi:10.1002/hec.1134</a>.<br /><br />
Oksuzyan A, Danko MJ, Caputo J, Jasilionis D, Shkolnikov VM (2019).
&ldquo;Is the story about sensitive women and stoical men true? Gender differences in health after adjustment for reporting behavior.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>228</b>, 41-50.
<a href="https://doi.org/10.1016/j.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+latentIndex">latentIndex</a></code>, <code><a href="#topic+standardiseCoef">standardiseCoef</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fit a model
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# calculate the health index cut-points
z &lt;- getCutPoints(model = model1)
z$cutpoints

plot(z)

# tabulate the adjusted health levels for individuals (Jurges method):
rev(table(z$adjusted.levels))

# tabulate the original health levels for individuals
table(model1$y_i)

# tabulate the predicted health levels
table(model1$Ey_i)
</code></pre>

<hr>
<h2 id='getLevels'>Summarize the adjusted and the original self-rated response levels</h2><span id='topic+getLevels'></span>

<h3>Description</h3>

<p>Summarize the adjusted and the original self-rated response levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLevels(
  model,
  formula = model$thresh.formula,
  data = model$frame,
  sep = "_",
  decreasing.levels = model$decreasing.levels,
  sort.flag = FALSE,
  weight.original = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLevels_+3A_model">model</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_formula">formula</code></td>
<td>
<p>a formula containing the grouping variables. It is by default set to threshold formula.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_data">data</code></td>
<td>
<p>data used to fit the model.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_sep">sep</code></td>
<td>
<p>a separator for the level names.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_decreasing.levels">decreasing.levels</code></td>
<td>
<p>a logical indicating whether self-reported health classes are ordered in increasing order.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_sort.flag">sort.flag</code></td>
<td>
<p>a logical indicating whether to sort the levels.</p>
</td></tr>
<tr><td><code id="getLevels_+3A_weight.original">weight.original</code></td>
<td>
<p>a logical indicating if use survey weights for calcualtion of original responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>original</code></td>
<td>
<p> frequencies of original response levels for selected groups/categories.</p>
</td></tr>
<tr><td><code>adjusted</code></td>
<td>
<p> frequencies of adjusted response levels (Jurges 2007 method) for selected groups/categories.</p>
</td></tr>
<tr><td><code>N.original</code></td>
<td>
<p> the number of original response levels for selected groups/categories.</p>
</td></tr>
<tr><td><code>N.adjusted</code></td>
<td>
<p> the number of adjusted response levels (Jurges 2007 method) for selected groups/categories.</p>
</td></tr>
<tr><td><code>categories</code></td>
<td>
<p> selected groups/categories used in summary.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p> an original vs. an adjusted contingency table.</p>
</td></tr>
<tr><td><code>mat</code></td>
<td>
<p> a matrix with columns: grouping variables, original response levels, adjusted response levels.
Each row corresponds to a single individual from the data used to fit the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>References</h3>

<p>Jurges H (2007).
&ldquo;True health vs response styles: exploring cross-country differences in self-reported health.&rdquo;
<em>Health Economics</em>, <b>16</b>(2), 163-178.
<a href="https://doi.org/10.1002/hec.1134">doi:10.1002/hec.1134</a>.<br /><br />
Oksuzyan A, Danko MJ, Caputo J, Jasilionis D, Shkolnikov VM (2019).
&ldquo;Is the story about sensitive women and stoical men true? Gender differences in health after adjustment for reporting behavior.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>228</b>, 41-50.
<a href="https://doi.org/10.1016/j.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+latentIndex">latentIndex</a></code>, <code><a href="#topic+standardiseCoef">standardiseCoef</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# fit a model
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# Example 1 ---------------------

# calculate a summary by country
hl &lt;- getLevels(model=model1, formula=~ country, sep=' ')
plot(hl, las=1, mar = c(3,2,1.5,0.5))

# differences between frequencies of original and adjusted health levels
round(100*(hl$original - hl$adjusted),2)

# extract good and bad health levels (combined levels)
Org &lt;- cbind(bad = rowSums(hl$original[,1:2]),
             good = rowSums(hl$original[,4:5]))
Adj &lt;- cbind(bad = rowSums(hl$adjusted[,1:2]),
             good = rowSums(hl$adjusted[,4:5]))
round(100*(Org - Adj),2)

# plot the differences
barplot(t(Org - Adj), beside = TRUE, density = 20, angle = c(-45, 45),
        col = c('pink4', 'green2'),
        ylab = 'Original - adjusted reported health frequencies')
abline(h = 0); box()
legend('top', c('Bad health','Good health'),
       density = 20, angle = c(-45, 45),
       fill = c('pink4', 'green2'), bty = 'n', cex = 1.2)

# in country X, bad health seems to be over-reported while good health
# is under-reported; in country Z, good health is highly over-reported.

# Example 2 ---------------------

# summary by gender and age
hl &lt;- getLevels(model = model1, formula=~ sex + ageclass, sep=' ')
plot(hl)

# differences between frequencies of original and adjusted health levels
round(100*(hl$original - hl$adjusted),2)

# extract good health levels (combined "Very good" and "Excellent" levels)
Org &lt;- rowSums(hl$original[,4:5])
Adj &lt;- rowSums(hl$adjusted[,4:5])
round(100*(Org - Adj),2)

pmar &lt;- par('mar'); par(mar = c(9.5, pmar[2:4]))
barplot(Org-Adj,
        ylab = 'Original - adjusted reported good health frequencies',
        las = 3,
        density = 20, angle = c(45, -45), col = c('blue', 'orange'))
abline(h = 0); box(); par(mar = pmar)
legend('top', c('Man','Woman'), density = 20, angle = c(-45, 45),
       fill = c('blue', 'orange'), bty = 'n', cex = 1.2)

# results show that women in general tend to over-report good health,
# while men aged 50-59 greatly under-report good health.

# more examples can be found in the description of the boot_hopit() function.
</code></pre>

<hr>
<h2 id='healthsurvey'>Artificially generated health survey data</h2><span id='topic+healthsurvey'></span>

<h3>Description</h3>

<p>A dataset containing artificially generated survey data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>healthsurvey
</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 rows and 11 variables:
</p>

<dl>
<dt>ID</dt><dd><p> personal identification number. </p>
</dd>
<dt>health</dt><dd><p> reported health, 5 levels. </p>
</dd>
<dt>diabetes</dt><dd><p> has diabetes? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>obese</dt><dd><p> is obese? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>IADL_problems</dt><dd><p> has problems with Instrumental Activities of Daily Living? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>hypertension</dt><dd><p> has hypertension? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>high_cholesterol</dt><dd><p> has high cholesterol? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>respiratory_problems</dt><dd><p> has respiratory problems? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>heart_attack_or_stroke</dt><dd><p> had a stroke or a heart attack? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>poor_mobility</dt><dd><p> has poor mobility? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>very_poor_grip</dt><dd><p> cannot perform grip strength test? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>depression</dt><dd><p> has depression? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>other_diseases</dt><dd><p> has other diseases? &quot;yes&quot; or &quot;no&quot;.</p>
</dd>
<dt>sex</dt><dd><p> sex/gender: &quot;woman&quot; or &quot;man&quot;.</p>
</dd>
<dt>ageclass</dt><dd><p> categorized age: [50,60), [60,70), [70,80), [80,120).</p>
</dd>
<dt>education</dt><dd><p> two levels of education: primary or lower (&quot;prim-&quot;) and secondary or higher (&quot;sec+&quot;.</p>
</dd>
<dt>country</dt><dd><p> country: &quot;X&quot;, &quot;Y&quot;, or &quot;Z&quot;.</p>
</dd>
<dt>csw</dt><dd><p> cross-sectional survey weights.</p>
</dd>
<dt>psu</dt><dd><p> primary statistical unit.</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>healthsurvey</code> is a completely artificial data set simulated using distributions of
some major health and socio-demographic characteristics. The distributions and the data
structure are roughly based on the WAVE1 SHARE database (DOIs: 10.6103/SHARE.w1.600); see
(Borsch-Supan et al. 2013) for technical details.
None of the records represent any part of the true data.
</p>
<p>The SHARE data collection has been primarily funded by the European Commission through FP5 (QLK6-CT-2001-00360), FP6 (SHARE-I3: RII-CT-2006-062193, COMPARE: CIT5-CT-2005-028857, SHARELIFE: CIT4-CT-2006-028812) and FP7 (SHARE-PREP: N°211909, SHARE-LEAP: N°227822, SHARE M4: N°261982). Additional funding from the German Ministry of Education and Research, the Max Planck Society for the Advancement of Science, the U.S. National Institute on Aging (U01_AG09740-13S2, P01_AG005842, P01_AG08291, P30_AG12815, R21_AG025169, Y1-AG-4553-01, IAG_BSR06-11, OGHA_04-064, HHSN271201300071C) and from various national funding sources is gratefully acknowledged (see www.share-project.org).
</p>


<h3>References</h3>

<p>Borsch-Supan A, Brandt M, Hunkler C, Kneip T, Korbmacher J, Malter F, Schaan B, Stuck S, Zuber S (2013).
&ldquo;Data Resource Profile: The Survey of Health, Ageing and Retirement in Europe (SHARE).&rdquo;
<em>International Journal of Epidemiology</em>, <b>42</b>(4), 992-1001.
<a href="https://doi.org/10.1093/ije/dyt088">doi:10.1093/ije/dyt088</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load *healthsurvey* dataset
data(healthsurvey)

# horizontal view of the dataset (omitting ID)
print(t(healthsurvey[1:6,-1]), quote=FALSE, na.print='NA', right=TRUE)
</code></pre>

<hr>
<h2 id='hopit'>Generalized hierarchical ordered threshold models.</h2><span id='topic+hopit'></span>

<h3>Description</h3>

<p>The ordered response data classify a measure of interest into ordered categories
collected during a survey. For example, if the dependent variable is a happiness
rating, a respondent typically answers a question such as: “Taking all things
together, would you say you are ... ?&quot; and then selects from response options
along the lines of: &quot;very happy&quot;, &quot;pretty happy&quot;, &quot;not too happy&quot;, and &quot;very unhappy&quot;
(Liao et al. 2005). Similarly, if interviewees are asked to evaluate their
health in general (e.g., “Would you say your health is ... ?”) they, can typically choose among
several categories, such as &quot;very good&quot;, &quot;good&quot;, &quot;fair&quot;, &quot;bad&quot;, and &quot;very bad&quot;
(King et al. 2004; Jurges 2007; Rebelo and Pereira 2014; Oksuzyan et al. 2019). In political science, a respondent
may be asked for an opinion about recent legislation (e.g. “Rate your feelings about
the proposed legislation.&quot;) and asked to choose among categories like: &quot;strongly
oppose&quot;, &quot;mildly oppose&quot;, &quot;indifferent&quot;, &quot;mildly support&quot;, and &quot;strongly support&quot;
(Greene and Hensher 2010). It is easy to imagine other multi-level ordinal
variables that might be used during a survey and to which the methodology described
below could be applied.<br />
</p>
<p>In practice, it is assumed that when responding to a survey question about their general
happiness, health, feelings, attitudes or other status, participants are
assessing their true value of this unobserved continuous variable, and
project it onto the discrete scale provided. The thresholds that individuals
use to categorize their true status by selecting a specific response option
may be affected by the reference group chosen, their earlier life experiences,
and cross-cultural differences in using scales. Thus, the responses of
individuals may differ depending on their gender, age, cultural background,
education, and personality traits; among other factors
(King et al. 2004; Jurges 2007; Oksuzyan et al. 2019).<br />
From the perspective of reporting behavior modeling, one of the main tasks
researchers face is to compute this continuous estimate of the underlying,
latent measures of individuals based on several specific characteristics
of the responses considered (e.g., health variables or happiness variables),
and to account for variations in reporting across socio-demographic and
cultural groups. More specifically, to build a latent, underlying measure,
a generalized hierarchical ordered threshold model is fitted that regresses
the reported status/attitude/feeling on two sets of independent variables
(Boes and Winkelmann 2006; Greene et al. 2014). When the dependent reported ordered
variable is self-rated health status, then the first set of variables –
i.e., health variables – assess specific aspects of individuals’ health,
such as measures of chronic conditions, mobility, difficulties with a range
of daily activities, grip strength, anthropometric characteristics, and
lifestyle behaviors. Using the second set of independent variables
(threshold variables), the model also adjusts for differences across
socio-demographic and cultural groups, such as differences in cultural
background, gender, age, and education
(King et al. 2004; Jurges 2007; Oksuzyan et al. 2019).<br />
</p>
<p>Ordered threshold models are used to fit ordered categorical dependent variables.
The generalized ordered threshold models (Ierza 1985; Boes and Winkelmann 2006; Greene et al. 2014)
are an extension of the ordered threshold models (McKelvey and Zavoina 1975).
Whereas in the latter models, the thresholds are constant, in the generalized models the
thresholds are allowed to be dependent on covariates.
Greene and Hensher (2010); Greene et al. (2014) pointed out that for a
model to make sense, the thresholds must also be ordered.
This observation motivated Greene and coauthors to call these models <em>HOPIT</em>, which stands
for hierarchical ordered probit models.
</p>
<p>The fitted <em>hopit</em> model is used to analyze heterogeneity in reporting behavior.
See <code><a href="#topic+standardizeCoef">standardizeCoef</a></code>, <code><a href="#topic+latentIndex">latentIndex</a></code>,
<code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, and <code><a href="#topic+boot_hopit">boot_hopit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit(
  latent.formula,
  thresh.formula = ~1,
  data,
  decreasing.levels,
  start = NULL,
  fit.sigma = FALSE,
  design = list(),
  weights = NULL,
  link = c("probit", "logit"),
  control = list(),
  na.action = na.fail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_+3A_latent.formula">latent.formula</code></td>
<td>
<p>a formula used to model the latent variable. It should not contain any threshold variable.
To specify the interactions between the latent and the threshold variables, see details.</p>
</td></tr>
<tr><td><code id="hopit_+3A_thresh.formula">thresh.formula</code></td>
<td>
<p>a formula used to model the threshold variable. It should not contain any latent variable.
To specify interactions between the latent and the threshold variables, see details.
Any dependent variable (left side of &quot;~&quot; in the formula) will be ignored.</p>
</td></tr>
<tr><td><code id="hopit_+3A_data">data</code></td>
<td>
<p>a data frame that includes all modeled variables.</p>
</td></tr>
<tr><td><code id="hopit_+3A_decreasing.levels">decreasing.levels</code></td>
<td>
<p>a logical indicating whether self-reported health classes are ordered in decreasing order.</p>
</td></tr>
<tr><td><code id="hopit_+3A_start">start</code></td>
<td>
<p>a vector with starting coefficient values in the form <code>c(latent_parameters, threshold_lambdas, threshold_gammas)</code> or
<code>c(latent_parameters, threshold_lambdas, threshold_gammas, logSigma)</code> if the <code>fit.sigma == TRUE</code>.</p>
</td></tr>
<tr><td><code id="hopit_+3A_fit.sigma">fit.sigma</code></td>
<td>
<p>a logical indicating whether to fit an additional parameter sigma,
which models a standard deviation of the error term (e.g., the standard deviation of the cumulative normal distribution in the probit model).</p>
</td></tr>
<tr><td><code id="hopit_+3A_design">design</code></td>
<td>
<p>an optional survey design. Use the <code><a href="survey.html#topic+svydesign">svydesign</a></code> function to specify the design.
The design cannot be specified together with parameter <code>weights</code>.</p>
</td></tr>
<tr><td><code id="hopit_+3A_weights">weights</code></td>
<td>
<p>optional model weights. Use design parameter to construct survey weights.</p>
</td></tr>
<tr><td><code id="hopit_+3A_link">link</code></td>
<td>
<p>a link function. The possible values are <code>"probit"</code> (default) and <code>"logit"</code>.</p>
</td></tr>
<tr><td><code id="hopit_+3A_control">control</code></td>
<td>
<p>a list with control parameters. See <code><a href="#topic+hopit.control">hopit.control</a></code>.</p>
</td></tr>
<tr><td><code id="hopit_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the <code>data</code> contain <code>NA</code>s.
The default is <code><a href="stats.html#topic+na.fail">na.fail</a></code>,
which generates an error if any missing value is found. The alternative is <code><a href="stats.html#topic+na.omit">na.omit</a></code>
(or <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> equivalently), which removes rows with missing
values from the <code>data</code>. Using <code><a href="stats.html#topic+na.pass">na.pass</a></code> will lead to an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits generalized hierarchical ordered threshold models.<br />
</p>
<p><code>latent.formula</code> models the latent variable.
If the response variable is self-rated health, then the latent measure can depend on different health
conditions and diseases (latent variables are called health variables).
Latent variables are modeled with the parallel regression assumption. According to this assumption, the coefficients
that describe the relationship between the lowest response category and all of the higher response categories, are the same as the coefficients
that describe the relationship between another (e.g., adjacent) lowest response category and the remaining higher response categories.
The predicted latent variable is modeled as a linear function of the health variables and the corresponding coefficients.<br />
</p>
<p><code>thresh.formula</code> models the threshold variable.
The thresholds (cut-points, <code>alpha</code>) are modeled by the threshold variables <code>gamma</code> and the intercepts <code>lambda</code>.
It is assumed that they model the contextual characteristics of the respondent (e.g., country, gender, and age).
The threshold variables are modeled without the parallel regression assumption; thus, each threshold is modeled by
a variable independently (Boes and Winkelmann 2006; Greene et al. 2014).
The <code>hopit</code>() function uses the parameterization of thresholds proposed by Jurges (2007).<br />
</p>
<p><code>decreasing.levels</code> it is the logical that determines the ordering of the levels of the categorical response variable.
It is always advisable to first check the ordering of the levels before starting (see example 1)<br />
</p>
<p>It is possible to model the interactions, including interactions between the latent and the threshold variables. The interactions added to the latent formula
only model the latent measure, and the interactions modeled in the threshold formula only model the thresholds.
The general rule for modeling any kind of interaction is to use &quot;*&quot; to specify interactions within a latent (or threshold) formula and to
use ':' to specify interactions between the latent and the threshold variables. In the latter case, the main effects of an interaction must also be specified;
i.e., the main latent effects must be specified in the latent formula, and the main threshold effect must be speciffied in the threshold formula.
See also <code>Example 3</code> below.<br />
</p>
<p>For more details, please see the package vignette, which is also available under this link:
<a href="https://github.com/MaciejDanko/hopit/blob/master/vignettes/vig_hopit.pdf">vig_hopit.pdf</a>
</p>


<h3>Value</h3>

<p>a <code>hopit</code> object used by other functions and methods. The object is a list with the following components:
</p>
<table>
<tr><td><code>control</code></td>
<td>
<p> a list with control parameters. See <code><a href="#topic+hopit.control">hopit.control</a></code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p> a link function used.</p>
</td></tr>
<tr><td><code>hasdisp</code></td>
<td>
<p> a logical indicating whether fit.sigma was modeled.</p>
</td></tr>
<tr><td><code>use.weights</code></td>
<td>
<p> a logical indicating whether any weights were used.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> a vector with model weights.</p>
</td></tr>
<tr><td><code>frame</code></td>
<td>
<p> a model frame.</p>
</td></tr>
<tr><td><code>latent.formula</code></td>
<td>
<p> a latent formula used to fit the model.</p>
</td></tr>
<tr><td><code>latent.mm</code></td>
<td>
<p> a latent model matrix.</p>
</td></tr>
<tr><td><code>latent.terms</code></td>
<td>
<p> latent variables used, and their interactions.</p>
</td></tr>
<tr><td><code>cross.inter.latent</code></td>
<td>
<p> a part of the latent formula used for modeling cross-interactions in the latent model</p>
</td></tr>
<tr><td><code>thresh.formula</code></td>
<td>
<p> a threshold formula used to fit the model.</p>
</td></tr>
<tr><td><code>thresh.mm</code></td>
<td>
<p> a threshold model matrix.</p>
</td></tr>
<tr><td><code>thresh.extd</code></td>
<td>
<p> an extended threshold model matrix.</p>
</td></tr>
<tr><td><code>thresh.terms</code></td>
<td>
<p> threshold variables used, and their interactions.</p>
</td></tr>
<tr><td><code>cross.inter.thresh</code></td>
<td>
<p> a part of the threshold formula used for modeling cross-interactions in the threshold model</p>
</td></tr>
<tr><td><code>thresh.no.cov</code></td>
<td>
<p> a logical indicating whether gamma parameters are present.</p>
</td></tr>
<tr><td><code>parcount</code></td>
<td>
<p> a 3-element vector with a number of parameters for the latent variables (beta),
the threshold intercepts (lambda), and the threshold covariates (gamma).</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p> a vector with model coefficients.</p>
</td></tr>
<tr><td><code>coef.ls</code></td>
<td>
<p> model coefficients as a list.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> a vector with the starting values of the coefficients.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p> estimated individual-specific thresholds.</p>
</td></tr>
<tr><td><code>y_i</code></td>
<td>
<p> a vector with individual responses - the response variable.</p>
</td></tr>
<tr><td><code>y_latent_i</code></td>
<td>
<p> a vector with predicted latent measures for each individual.</p>
</td></tr>
<tr><td><code>Ey_i</code></td>
<td>
<p> a vector with predicted categorical responses for each individual.</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p> a number of response levels.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p> a number of observations.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> a deviance.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p> a log likelihood.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p> an AIC for models without a survey design.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p> a variance-covariance matrix.</p>
</td></tr>
<tr><td><code>vcov.basic</code></td>
<td>
<p> a variance-covariance matrix that ignores the survey design.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p> a Hessian matrix.</p>
</td></tr>
<tr><td><code>estfun</code></td>
<td>
<p> a gradient (a vector of partial derivatives) of the log likelihood function at the estimated coefficient values.</p>
</td></tr>
<tr><td><code>YYY1</code>, <code>YYY2</code>, <code>YYY3</code></td>
<td>
<p> an internal objects used for the calculation of gradient and Hessian functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>References</h3>

<p>Boes S, Winkelmann R (2006).
&ldquo;Ordered response models.&rdquo;
<em>Allgemeines Statistisches Archiv</em>, <b>90</b>(1), 167&ndash;181.
ISSN 1614-0176, <a href="https://doi.org/10.1007/s10182-006-0228-y">doi:10.1007/s10182-006-0228-y</a>.<br /><br /> Greene W, Harris MN, Hollingsworth B, Weterings TA (2014).
&ldquo;Heterogeneity in Ordered Choice Models: A Review with Applications to Self-Assessed Health.&rdquo;
<em>Journal of Economic Surveys</em>, <b>28</b>(1), 109-133.
<a href="https://doi.org/10.1111/joes.12002">doi:10.1111/joes.12002</a>.<br /><br /> Greene W, Hensher D (2010).
<em>Modeling Ordered Choices</em>.
Cambridge University Press.<br /><br /> Ierza JV (1985).
&ldquo;Ordinal probit: A generalization.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>14</b>(1), 1-11.
ISSN 0361-0926, <a href="https://doi.org/10.1080/03610928508828893">doi:10.1080/03610928508828893</a>.<br /><br /> Jurges H (2007).
&ldquo;True health vs response styles: exploring cross-country differences in self-reported health.&rdquo;
<em>Health Economics</em>, <b>16</b>(2), 163-178.
<a href="https://doi.org/10.1002/hec.1134">doi:10.1002/hec.1134</a>.<br /><br /> King G, Murray CJL, Salomon JA, Tandon A (2004).
&ldquo;Enhancing the Validity and Cross-Cultural Comparability of Measurement in Survey Research.&rdquo;
<em>American Political Science Review</em>, <b>98</b>(1), 191–207.
<a href="https://doi.org/10.1017/S000305540400108X">doi:10.1017/S000305540400108X</a>.<br /><br /> Liao P, Fu Y, Yi C (2005).
&ldquo;Perceived quality of life in Taiwan and Hong Kong: an intra-culture comparison.&rdquo;
<em>Journal of Happiness Studies</em>, <b>6</b>(1), 43&ndash;67.
ISSN 1573-7780, <a href="https://doi.org/10.1007/s10902-004-1753-6">doi:10.1007/s10902-004-1753-6</a>.<br /><br /> McKelvey RD, Zavoina W (1975).
&ldquo;A Statistical Model for the Analysis of Ordinal Level Dependent Variables.&rdquo;
<em>Journal of Mathematical Sociology</em>, <b>4</b>(1), 103–120.<br /><br /> Oksuzyan A, Danko MJ, Caputo J, Jasilionis D, Shkolnikov VM (2019).
&ldquo;Is the story about sensitive women and stoical men true? Gender differences in health after adjustment for reporting behavior.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>228</b>, 41-50.
<a href="https://doi.org/10.1016/j.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>.<br /><br /> Rebelo LP, Pereira NS (2014).
&ldquo;Assessing health endowment, access and choice determinants: Impact on retired Europeans' (in)activity and quality of life.&rdquo;
<em>Social Indicators Research</em>, <b>119</b>(3), 1411-1446.
<a href="https://doi.org/10.1007/s11205-013-0542-1">doi:10.1007/s11205-013-0542-1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.hopit">coef.hopit</a></code>,
<code><a href="#topic+profile.hopit">profile.hopit</a></code>,
<code><a href="#topic+hopit.control">hopit.control</a></code>,
<code><a href="#topic+anova.hopit">anova.hopit</a></code>,
<code><a href="#topic+vcov.hopit">vcov.hopit</a></code>,
<code><a href="#topic+logLik.hopit">logLik.hopit</a></code>,
<code><a href="#topic+AIC.hopit">AIC.hopit</a></code>,
<code><a href="#topic+summary.hopit">summary.hopit</a></code>,
<code><a href="survey.html#topic+svydesign">svydesign</a></code>, <br /><br />
For heterogeneity in reporting behavior analysis see:<br />
<code><a href="#topic+standardizeCoef">standardizeCoef</a></code>,
<code><a href="#topic+latentIndex">latentIndex</a></code>,
<code><a href="#topic+getCutPoints">getCutPoints</a></code>,
<code><a href="#topic+getLevels">getLevels</a></code>,
<code><a href="#topic+boot_hopit">boot_hopit</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# first determine the order of the levels of the dependent variable
levels(healthsurvey$health)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE

# Example 1 ---------------------

# fitting the model:
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# summarize the fit:
summary(model1)

# extract parameters in the form of a list
cm1 &lt;- coef(model1, aslist = TRUE)

# names of the returned coefficients
names(cm1)

# extract the latent health coefficients
cm1$latent.params

# check the fit

profile(model1)

# Example 2 ---------------------


# incorporate the survey design
design &lt;- svydesign(ids = ~ country + psu, weights = healthsurvey$csw,
data = healthsurvey)

model2 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                  heart_attack_or_stroke + poor_mobility +
                  very_poor_grip + depression + respiratory_problems +
                  IADL_problems + obese + diabetes + other_diseases,
                thresh.formula = ~ sex + ageclass + country,
                decreasing.levels = TRUE,
                design = design,
                control = list(trace = FALSE),
                data = healthsurvey)

# compare the latent variables
cbind('No survey design' = coef(model1, aslist = TRUE)$latent.par,
'Has survey design' = coef(model2, aslist = TRUE)$latent.par)


# Example 3 ---------------------

# defining the interactions between the threshold and the latent variables

# correctly defined interactions:
model3 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility * very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases +
                sex : depression + sex : diabetes + ageclass:obese,
              thresh.formula = ~ sex * ageclass + country + sex : obese,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

## Not run: 
# badly defined interactions:

# 1) lack of a main effect of "other_diseases" in any formula
# it can be solved by adding " + other_diseases" to the latent formula
model3a &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases : sex,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# 2) the main effect of sex is present in both formulas.
# it can be solved by replacing "*" with ":" in "other_diseases * sex"
model3b &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases * sex,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)


## End(Not run)
# Example 4 ---------------------


# construct a naive continuous variable:
hs &lt;- healthsurvey
hs$cont_var &lt;- sample(5000:5020,nrow(hs),replace=TRUE)

latent.formula = health ~ hypertension + high_cholesterol +
  heart_attack_or_stroke + poor_mobility + very_poor_grip +
  depression + respiratory_problems +
  IADL_problems + obese + diabetes + other_diseases

# in some cases, when continuous variables are used, the hopit:::get.hopit.start() function
# do not find starting parameters (R version 3.4.4 (2018-03-15)):
## Not run: 
model4 &lt;- hopit(latent.formula = latent.formula,
                thresh.formula = ~ sex + cont_var,
                decreasing.levels = TRUE,
                data = hs)

## End(Not run)
# one of the solutions is to transform one or more continuous variables:
hs$cont_var_t &lt;- hs$cont_var-min(hs$cont_var)

model4b &lt;- hopit(latent.formula = latent.formula,
                 thresh.formula = ~ sex + cont_var_t,
                 decreasing.levels = TRUE,
                 data = hs)

# this can also be done automatically using the the control parameter
model4c &lt;- hopit(latent.formula = latent.formula,
                 thresh.formula = ~ sex + cont_var,
                 decreasing.levels = TRUE,
                 control = list(transform.thresh = 'min',
                                transform.latent = 'none'),
                 data = hs)

model4d &lt;- hopit(latent.formula = latent.formula,
                 thresh.formula = ~ sex + cont_var,
                 decreasing.levels = TRUE,
                 control = list(transform.thresh = 'scale_01',
                                transform.latent = 'none'),
                 data = hs)

model4e &lt;- hopit(latent.formula = latent.formula,
                 thresh.formula = ~ sex + cont_var,
                 decreasing.levels = TRUE,
                 control = list(transform.thresh = 'standardize',
                                transform.latent = 'none'),
                 data = hs)

model4f &lt;- hopit(latent.formula = latent.formula,
                 thresh.formula = ~ sex + cont_var,
                 decreasing.levels = TRUE,
                 control = list(transform.thresh = 'standardize_trunc',
                                transform.latent = 'none'),
                 data = hs)

round(t(rbind(coef(model4b),
              coef(model4c),
              coef(model4d),
              coef(model4e),
              coef(model4f))),4)


</code></pre>

<hr>
<h2 id='hopit_derivLL'>INTERNAL: The gradient of the log likelihood function</h2><span id='topic+hopit_derivLL'></span>

<h3>Description</h3>

<p>INTERNAL: The gradient of the log likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit_derivLL(
  parameters = model$coef,
  model,
  collapse = TRUE,
  use_weights,
  negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_derivLL_+3A_parameters">parameters</code></td>
<td>
<p>model parameters (optional). If the parameters not delivered, they are taken from the <code>model$coef</code>.</p>
</td></tr>
<tr><td><code id="hopit_derivLL_+3A_model">model</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="hopit_derivLL_+3A_collapse">collapse</code></td>
<td>
<p>a logical indicating whether to sum individual LL contributions.</p>
</td></tr>
<tr><td><code id="hopit_derivLL_+3A_use_weights">use_weights</code></td>
<td>
<p>a logical indicating whether to use model weights.</p>
</td></tr>
<tr><td><code id="hopit_derivLL_+3A_negative">negative</code></td>
<td>
<p>a logical indicating whether the function should return negative LL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='hopit_fitter'>INTERNAL: Fit a <code>hopit</code> model given the starting parameters</h2><span id='topic+hopit_fitter'></span>

<h3>Description</h3>

<p>Fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit_fitter(model, start = model$start, use_weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_fitter_+3A_model">model</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="hopit_fitter_+3A_start">start</code></td>
<td>
<p>starting parameters.</p>
</td></tr>
<tr><td><code id="hopit_fitter_+3A_use_weights">use_weights</code></td>
<td>
<p>a logical indicating whether to use model weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='hopit_Latent'>INTERNAL: Calculate the predicted continuous latent measure (h_i).</h2><span id='topic+hopit_Latent'></span>

<h3>Description</h3>

<p>INTERNAL: Calculate the predicted continuous latent measure (h_i).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit_Latent(latent.params, model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_Latent_+3A_latent.params">latent.params</code></td>
<td>
<p>vectors with model parameters.</p>
</td></tr>
<tr><td><code id="hopit_Latent_+3A_model">model</code></td>
<td>
<p>a <code>hopit</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='hopit_negLL'>INTERNAL: The log likelihood function</h2><span id='topic+hopit_negLL'></span>

<h3>Description</h3>

<p>INTERNAL: The log likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit_negLL(
  parameters = model$coef,
  model,
  collapse = TRUE,
  use_weights,
  negative = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_negLL_+3A_parameters">parameters</code></td>
<td>
<p>model parameters (optional). If the parameters are not delivered, they are taken from <code>model$coef</code>.</p>
</td></tr>
<tr><td><code id="hopit_negLL_+3A_model">model</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="hopit_negLL_+3A_collapse">collapse</code></td>
<td>
<p>a logical indicating whether to sum the individual LL contributions.</p>
</td></tr>
<tr><td><code id="hopit_negLL_+3A_use_weights">use_weights</code></td>
<td>
<p>a logical indicating whether to use model weights.</p>
</td></tr>
<tr><td><code id="hopit_negLL_+3A_negative">negative</code></td>
<td>
<p>a logical indicating whether the function should return negative.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='hopit_Threshold'>INTERNAL: Calculate the model cut-points (alpha)</h2><span id='topic+hopit_Threshold'></span>

<h3>Description</h3>

<p>INTERNAL: Calculate the model cut-points (alpha)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit_Threshold(thresh.lambda, thresh.gamma, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit_Threshold_+3A_thresh.lambda">thresh.lambda</code>, <code id="hopit_Threshold_+3A_thresh.gamma">thresh.gamma</code></td>
<td>
<p>vectors with model parameters.</p>
</td></tr>
<tr><td><code id="hopit_Threshold_+3A_model">model</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='hopit.control'>Auxiliary for controlling the fitting of a <code>hopit</code> model</h2><span id='topic+hopit.control'></span>

<h3>Description</h3>

<p>An auxiliary function for controlling the fitting of a <code>hopit</code> model.
Use this function to set the control
parameters of the <code><a href="#topic+hopit">hopit</a></code> and other related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hopit.control(
  grad.eps = 3e-05,
  bgfs.maxit = 10000,
  cg.maxit = 10000,
  nlm.maxit = 150,
  bgfs.reltol = 5e-10,
  cg.reltol = 5e-10,
  nlm.gradtol = 1e-07,
  nlm.steptol = 1e-07,
  fit.methods = "BFGS",
  nlm.fit = FALSE,
  trace = TRUE,
  transform.latent = "none",
  transform.thresh = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hopit.control_+3A_grad.eps">grad.eps</code></td>
<td>
<p>an epsilon parameter (&quot;a very small number&quot;) used to calculate the Hessian from the gradient function.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_bgfs.maxit">bgfs.maxit</code>, <code id="hopit.control_+3A_cg.maxit">cg.maxit</code>, <code id="hopit.control_+3A_nlm.maxit">nlm.maxit</code></td>
<td>
<p>the maximum number of iterations.
See <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code> for details.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_bgfs.reltol">bgfs.reltol</code>, <code id="hopit.control_+3A_cg.reltol">cg.reltol</code></td>
<td>
<p>the relative convergence tolerances for the BFGS and the CG methods.
See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_nlm.gradtol">nlm.gradtol</code>, <code id="hopit.control_+3A_nlm.steptol">nlm.steptol</code></td>
<td>
<p>a tolerance at which the scaled gradient is
considered close enough to zero and
a minimum allowable relative step length for the nlm method. See <code><a href="stats.html#topic+nlm">nlm</a></code>.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_fit.methods">fit.methods</code></td>
<td>
<p>&quot;CG&quot;, &quot;BFGS&quot;, or both. If both, the CG is run first, followed by the BFGS. See <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_nlm.fit">nlm.fit</code></td>
<td>
<p>a logical; if FALSE (default) the <code>nlm</code> optimization method
is omitted and only the BFGS and/or the CG methods are run.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_trace">trace</code></td>
<td>
<p>a logical for whether to trace the process of model fitting.</p>
</td></tr>
<tr><td><code id="hopit.control_+3A_transform.latent">transform.latent</code>, <code id="hopit.control_+3A_transform.thresh">transform.thresh</code></td>
<td>
<p>a type of transformation applied to
the all of the latent's or all of the threshold's numeric variables. Possible values:
</p>

<ul>
<li><p> &quot;none&quot; : no transformation
</p>
</li>
<li><p> &quot;min&quot; : subtract the minimum from a variable
</p>
</li>
<li><p> &quot;scale_01&quot; : transform the variable to fit the range from 0 to 1
</p>
</li>
<li><p> &quot;standardize&quot; or &quot;standardise&quot; : subtract the mean from a variable then divide it by its standard deviation
</p>
</li>
<li><p> &quot;standardize_trunc&quot; or &quot;standardise_trunc&quot; : subtract the minimum from a variable then divide it by its standard deviation
</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hopit">hopit</a></code>
</p>

<hr>
<h2 id='latentIndex'>Calculate the latent index</h2><span id='topic+latentIndex'></span><span id='topic+healthIndex'></span>

<h3>Description</h3>

<p>Calculate the latent index from the fitted model. The latent index is a standardized latent measure that takes values from 0 to 1, where
0 refers to the worst predicted state (the maximal observed value for the latent measure) and 1 refers
to the best predicted state (the minimal observed value for the latent measure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latentIndex(model, subset = NULL)

healthIndex(model, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latentIndex_+3A_model">model</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
<tr><td><code id="latentIndex_+3A_subset">subset</code></td>
<td>
<p>an optional vector that specifies a subset of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with a latent index for each individual.
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>References</h3>

<p>Jurges H (2007).
&ldquo;True health vs response styles: exploring cross-country differences in self-reported health.&rdquo;
<em>Health Economics</em>, <b>16</b>(2), 163-178.
<a href="https://doi.org/10.1002/hec.1134">doi:10.1002/hec.1134</a>.<br /><br />
Oksuzyan A, Danko MJ, Caputo J, Jasilionis D, Shkolnikov VM (2019).
&ldquo;Is the story about sensitive women and stoical men true? Gender differences in health after adjustment for reporting behavior.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>228</b>, 41-50.
<a href="https://doi.org/10.1016/j.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardizeCoef">standardizeCoef</a></code>, <code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fit a model
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                  heart_attack_or_stroke + poor_mobility + very_poor_grip +
                  depression + respiratory_problems +
                  IADL_problems + obese + diabetes + other_diseases,
                thresh.formula = ~ sex + ageclass + country,
                decreasing.levels = TRUE,
                control = list(trace = FALSE),
                data = healthsurvey)

# calculate the health index
hi &lt;- latentIndex(model1)

summary(hi)

# plot a simple histogram of the function output
hist(hi, col='deepskyblue3')

#plot the reported health status versus the health index.
plot(hi, response = "data", ylab = 'Health index',
     col='deepskyblue3', main = 'Reported health levels')

# plot the model-predicted health levels versus the health index.
plot(hi, response = "fitted", ylab = 'Health index',
     col='deepskyblue3', main = 'Model-predicted health levels')
</code></pre>

<hr>
<h2 id='logLik.hopit'>Extracting a log likelihood of the fitted model</h2><span id='topic+logLik.hopit'></span>

<h3>Description</h3>

<p>Extract the log likelihood of a <code>hopit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.hopit_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="logLik.hopit_+3A_...">...</code></td>
<td>
<p>additional objects of the class <code>hopit</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='lrt.hopit'>Likelihood ratio test for a pair of models</h2><span id='topic+lrt.hopit'></span>

<h3>Description</h3>

<p>Likelihood ratio test for a pair of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrt.hopit(full, nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrt.hopit_+3A_full">full</code>, <code id="lrt.hopit_+3A_nested">nested</code></td>
<td>
<p>models to be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the results of the test.
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.lrt.hopit">print.lrt.hopit</a></code>, <code><a href="#topic+anova.hopit">anova.hopit</a></code>,
<code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fitting two nested models
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# model with an interaction between hypertension and high_cholesterol
model2 &lt;- hopit(latent.formula = health ~ hypertension * high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# Likelihood ratio test
lrt1 &lt;- lrt.hopit(full = model2, nested = model1)
lrt1

# print the results in a shorter form
print(lrt1, short = TRUE)

# equivalently
print(anova(model2, model1), short = TRUE)

</code></pre>

<hr>
<h2 id='percentile_CI'>Calculating the confidence intervals of the bootstrapped function using the percentile method</h2><span id='topic+percentile_CI'></span>

<h3>Description</h3>

<p>Calculate the confidence intervals of the bootstrapped function using the percentile method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile_CI(boot, alpha = 0.05, bounds = c("both", "lo", "up"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile_CI_+3A_boot">boot</code></td>
<td>
<p>a matrix or a list of vectors with bootstrapped elements. If it is list, then each element of the list is one replication.</p>
</td></tr>
<tr><td><code id="percentile_CI_+3A_alpha">alpha</code></td>
<td>
<p>a significance level.</p>
</td></tr>
<tr><td><code id="percentile_CI_+3A_bounds">bounds</code></td>
<td>
<p>which bounds to return; one of <code>"both"</code>, <code>"lo"</code>, <code>"up"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot_hopit">boot_hopit</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, <code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+latentIndex">latentIndex</a></code>, <code><a href="#topic+standardiseCoef">standardiseCoef</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in boot_hopit() function.
</code></pre>

<hr>
<h2 id='plot.hopitCP'>Plotting Cut-Points</h2><span id='topic+plot.hopitCP'></span>

<h3>Description</h3>

<p>Plotting Cut-Points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopitCP'
plot(
  x,
  decreasing.levels = x$decreasing.levels,
  mar = c(4, 4, 1, 1),
  oma = c(0, 0, 0, 0),
  XLab = "Health index",
  XLab.cex = 1.1,
  YLab = "Counts",
  YLab.cex = 1.1,
  border.col = 2,
  border.lty = 2,
  border.lwd = 1.5,
  group.labels.type = c("middle", "border", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hopitCP_+3A_decreasing.levels">decreasing.levels</code></td>
<td>
<p>a logical indicating whether self-reported health classes are ordered in decreasing order.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_mar">mar</code>, <code id="plot.hopitCP_+3A_oma">oma</code></td>
<td>
<p>graphic parameters, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_xlab">XLab</code>, <code id="plot.hopitCP_+3A_xlab.cex">XLab.cex</code></td>
<td>
<p>a label of the x axis and it's size.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_ylab">YLab</code>, <code id="plot.hopitCP_+3A_ylab.cex">YLab.cex</code></td>
<td>
<p>a label of the y axis and it's size.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_border.lwd">border.lwd</code>, <code id="plot.hopitCP_+3A_border.lty">border.lty</code>, <code id="plot.hopitCP_+3A_border.col">border.col</code></td>
<td>
<p>graphic parameters for vertical lines used to plot cut-points.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_group.labels.type">group.labels.type</code></td>
<td>
<p>a position of the legend. One of <code>middle</code>, <code>border</code>, or <code>none</code>.</p>
</td></tr>
<tr><td><code id="plot.hopitCP_+3A_...">...</code></td>
<td>
<p>further plotting arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='plot.hopitDW'>Plotting standardized coefficients</h2><span id='topic+plot.hopitDW'></span>

<h3>Description</h3>

<p>Plotting standardized coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopitDW'
plot(
  x,
  ordered = TRUE,
  show.signif = TRUE,
  mar = c(10, 4, 1.5, 1),
  oma = c(0, 0, 0, 0),
  ylab = "Disability weight",
  xlab = "",
  density = 20,
  angle = 45,
  col = "orange",
  las = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hopitDW_+3A_x">x</code></td>
<td>
<p>a object generated by <code><a href="#topic+standardizeCoef">standardizeCoef</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.hopitDW_+3A_ordered">ordered</code></td>
<td>
<p>a logical indicating whether to sort the disability weights.</p>
</td></tr>
<tr><td><code id="plot.hopitDW_+3A_show.signif">show.signif</code></td>
<td>
<p>show significance codes.</p>
</td></tr>
<tr><td><code id="plot.hopitDW_+3A_mar">mar</code>, <code id="plot.hopitDW_+3A_oma">oma</code></td>
<td>
<p>graphic parameters, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitDW_+3A_ylab">ylab</code>, <code id="plot.hopitDW_+3A_xlab">xlab</code>, <code id="plot.hopitDW_+3A_density">density</code>, <code id="plot.hopitDW_+3A_angle">angle</code>, <code id="plot.hopitDW_+3A_col">col</code>, <code id="plot.hopitDW_+3A_las">las</code>, <code id="plot.hopitDW_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='plot.hopitHI'>Plotting Latent Index</h2><span id='topic+plot.hopitHI'></span>

<h3>Description</h3>

<p>Plotting Latent Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopitHI'
plot(x, response = c("data", "fitted"), xlab = "", ylab = "Latent index", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hopitHI_+3A_x">x</code></td>
<td>
<p>a object generated by <code><a href="#topic+latentIndex">latentIndex</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.hopitHI_+3A_response">response</code></td>
<td>
<p>X-axis plotting option; choose <code>'data'</code> for the raw responses and <code>'fitted'</code> for the responses reclassified by the model.</p>
</td></tr>
<tr><td><code id="plot.hopitHI_+3A_xlab">xlab</code></td>
<td>
<p>a label of the x-axis.</p>
</td></tr>
<tr><td><code id="plot.hopitHI_+3A_ylab">ylab</code></td>
<td>
<p>a label of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.hopitHI_+3A_...">...</code></td>
<td>
<p>further parameters passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='plot.hopitLV'>Plotting getLevels object</h2><span id='topic+plot.hopitLV'></span>

<h3>Description</h3>

<p>Plotting getLevels object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopitLV'
plot(
  x,
  mar = c(7, 2, 1.5, 0.5),
  oma = c(0, 3, 0, 0),
  YLab = "Fraction [%]",
  YLab.cex = 1.1,
  legbg = grDevices::adjustcolor("white", alpha.f = 0.4),
  legbty = "o",
  las = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hopitLV_+3A_x">x</code></td>
<td>
<p>aobject generated by <code><a href="#topic+getLevels">getLevels</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_mar">mar</code>, <code id="plot.hopitLV_+3A_oma">oma</code></td>
<td>
<p>graphic parameters, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_ylab">YLab</code>, <code id="plot.hopitLV_+3A_ylab.cex">YLab.cex</code></td>
<td>
<p>a label for the y-axis and it's size.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_legbg">legbg</code></td>
<td>
<p>a legend background color. See <code>bg</code> parameter in <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_legbty">legbty</code></td>
<td>
<p>a legend box type. See <code>bty</code> parameter in <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_las">las</code></td>
<td>
<p>the style of axis labels, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.hopitLV_+3A_...">...</code></td>
<td>
<p>further plotting arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='plot.profile.hopit'>Plot the log likelihood profile for a profile.hopit object</h2><span id='topic+plot.profile.hopit'></span>

<h3>Description</h3>

<p>Plot the method for a profile.hopit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.hopit'
plot(x, ..., ylim = NULL, relative = FALSE,
leg.cex = 0.85, leg.col = 'blue4')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile.hopit_+3A_x">x</code></td>
<td>
<p>a <code>profile.hopit</code> object.</p>
</td></tr>
<tr><td><code id="plot.profile.hopit_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>() function (see
<code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.profile.hopit_+3A_ylim">ylim</code></td>
<td>
<p>see <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.hopit_+3A_relative">relative</code></td>
<td>
<p>a logical indicating whether <code>ylim</code> on each panel should be the
same (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.profile.hopit_+3A_leg.cex">leg.cex</code></td>
<td>
<p>a character expansion factor relative to the current
<code>par("cex")</code> (see <code><a href="graphics.html#topic+legend">legend</a></code>).</p>
</td></tr>
<tr><td><code id="plot.profile.hopit_+3A_leg.col">leg.col</code></td>
<td>
<p>a color used for the legend text.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.hopit">profile.hopit</a></code>, <code><a href="#topic+print.profile.hopit">print.profile.hopit</a></code>,
<code><a href="#topic+hopit">hopit</a></code>.
</p>

<hr>
<h2 id='print.hopit'>Printing basic information about fitted <code>hopit</code> model</h2><span id='topic+print.hopit'></span>

<h3>Description</h3>

<p>Print a <code>hopit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hopit_+3A_x">x</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="print.hopit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='print.lrt.hopit'>Printing an object calculated by <code><a href="#topic+lrt.hopit">lrt.hopit</a></code></h2><span id='topic+print.lrt.hopit'></span>

<h3>Description</h3>

<p>Printing an object calculated by <code><a href="#topic+lrt.hopit">lrt.hopit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lrt.hopit'
print(x, short = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lrt.hopit_+3A_x">x</code></td>
<td>
<p>an object obtained from <code><a href="#topic+lrt.hopit">lrt.hopit</a></code>.</p>
</td></tr>
<tr><td><code id="print.lrt.hopit_+3A_short">short</code></td>
<td>
<p>a logical indicating whether to show a shortened description.</p>
</td></tr>
<tr><td><code id="print.lrt.hopit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lrt.hopit">lrt.hopit</a></code>, <code><a href="#topic+anova.hopit">anova.hopit</a></code>,
<code><a href="#topic+hopit">hopit</a></code>.
</p>

<hr>
<h2 id='print.profile.hopit'>Print method for a profile.hopit object</h2><span id='topic+print.profile.hopit'></span>

<h3>Description</h3>

<p>Print method for a profile.hopit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.hopit'
print(x, ..., plotf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.profile.hopit_+3A_x">x</code></td>
<td>
<p>a <code>profile.hopit</code> object.</p>
</td></tr>
<tr><td><code id="print.profile.hopit_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>plot</code>() function (see
<code><a href="#topic+plot.profile.hopit">plot.profile.hopit</a></code>).</p>
</td></tr>
<tr><td><code id="print.profile.hopit_+3A_plotf">plotf</code></td>
<td>
<p>a logical indicating whether to plot the profile.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.hopit">profile.hopit</a></code>, <code><a href="#topic+plot.profile.hopit">plot.profile.hopit</a></code>,
<code><a href="#topic+hopit">hopit</a></code>
</p>

<hr>
<h2 id='profile.hopit'>Calculate the log likelihood profile for the fitted <code>hopit</code> model</h2><span id='topic+profile.hopit'></span>

<h3>Description</h3>

<p>Calculate the log likelihood profile for the fitted <code>hopit</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
profile(fitted, ..., scope = 0.15, steps = 101)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.hopit_+3A_fitted">fitted</code></td>
<td>
<p>a <code>hopit</code> object (a fitted model).</p>
</td></tr>
<tr><td><code id="profile.hopit_+3A_...">...</code></td>
<td>
<p>unused now.</p>
</td></tr>
<tr><td><code id="profile.hopit_+3A_scope">scope</code></td>
<td>
<p>a value (fraction) defining the plotting range for a coefficient.
The range is <code>c(coef \* (1-scope), coef \* (1+scope))</code>.</p>
</td></tr>
<tr><td><code id="profile.hopit_+3A_steps">steps</code></td>
<td>
<p>at how many equally spaced points the log likelihood
function is calculated for each coefficient.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.profile.hopit">plot.profile.hopit</a></code>, <code><a href="#topic+print.profile.hopit">print.profile.hopit</a></code>,
<code><a href="#topic+hopit">hopit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fitting the model:
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# check the fit using the profile function (at 51 points)
pr &lt;- profile(model1, steps = 51)
print(pr, plotf = FALSE)

# plot profile
plot(pr, relative = FALSE)

# alternative plot
plot(pr, relative = TRUE)

</code></pre>

<hr>
<h2 id='sigma.hopit'>Extract the <code>Sigma</code> parameter from a <code>hopit</code> model</h2><span id='topic+sigma.hopit'></span>

<h3>Description</h3>

<p>Extract the <code>Sigma</code> parameter from a <code>hopit</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.hopit_+3A_object">object</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='standardizeCoef'>Standardization of the coefficients</h2><span id='topic+standardizeCoef'></span><span id='topic+standardiseCoef'></span><span id='topic+disabilityWeights'></span>

<h3>Description</h3>

<p>Calculate standardized the coefficients (e.g. disability weights for the health variables) using
the predicted latent measure obtained from the model.<br />
In the self-rated health example the standardized coefficients are called disability weights Jurges (2007)
and are calculated for each health variable to provide information about the impact of a specific health measure on the latent index
(see <code><a href="#topic+latentIndex">latentIndex</a></code>). The disability weight for a health variable is equal to the ratio of the corresponding health coefficient
and the difference between the lowest and the highest values of the predicted latent health. In other words, the disability weight reduces
the latent index by some given amount or percentage (i.e., the latent index of every individual is reduced by the same amount if the person had a heart attack or other
heart problems)(Jurges 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeCoef(model, namesf = identity)

standardiseCoef(model, namesf = identity)

disabilityWeights(model, namesf = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardizeCoef_+3A_model">model</code></td>
<td>
<p>a fitted <code>hopit</code> model.</p>
</td></tr>
<tr><td><code id="standardizeCoef_+3A_namesf">namesf</code></td>
<td>
<p>a vector of the names of coefficients or one argument function that modifies the names of coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with standardized coefficients.
</p>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>


<h3>References</h3>

<p>Jurges H (2007).
&ldquo;True health vs response styles: exploring cross-country differences in self-reported health.&rdquo;
<em>Health Economics</em>, <b>16</b>(2), 163-178.
<a href="https://doi.org/10.1002/hec.1134">doi:10.1002/hec.1134</a>.<br /><br />
Oksuzyan A, Danko MJ, Caputo J, Jasilionis D, Shkolnikov VM (2019).
&ldquo;Is the story about sensitive women and stoical men true? Gender differences in health after adjustment for reporting behavior.&rdquo;
<em>Social Science &amp; Medicine</em>, <b>228</b>, 41-50.
<a href="https://doi.org/10.1016/j.socscimed.2019.03.002">doi:10.1016/j.socscimed.2019.03.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+latentIndex">latentIndex</a></code>, <code><a href="#topic+getCutPoints">getCutPoints</a></code>, <code><a href="#topic+getLevels">getLevels</a></code>, <code><a href="#topic+hopit">hopit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DATA
data(healthsurvey)

# the order of response levels decreases from the best health to
# the worst health; hence the hopit() parameter decreasing.levels
# is set to TRUE
levels(healthsurvey$health)

# Example 1 ---------------------

# fit a model
model1 &lt;- hopit(latent.formula = health ~ hypertension + high_cholesterol +
                heart_attack_or_stroke + poor_mobility + very_poor_grip +
                depression + respiratory_problems +
                IADL_problems + obese + diabetes + other_diseases,
              thresh.formula = ~ sex + ageclass + country,
              decreasing.levels = TRUE,
              control = list(trace = FALSE),
              data = healthsurvey)

# a function that modifies the coefficient names.
txtfun &lt;- function(x) gsub('_',' ',substr(x,1,nchar(x)-3))

# calculate and plot the disability weights
sc &lt;- standardizeCoef(model1, namesf = txtfun)
sc

summary(sc)

plot(sc)
</code></pre>

<hr>
<h2 id='summary.hopit'>Calculate the model summary</h2><span id='topic+summary.hopit'></span>

<h3>Description</h3>

<p>Summarize a <code>hopit</code>  model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
summary(object, robust.se, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hopit_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="summary.hopit_+3A_robust.se">robust.se</code></td>
<td>
<p>a logical indicating whether to use robust standard errors based
on the sandwich estimator.
If a survey design is detected, then this option is ignored.
See <code><a href="#topic+hopit.control">hopit.control</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hopit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

<hr>
<h2 id='svy.varcoef_hopit'>Calculation of the variance-covariance matrix for a specified survey design (experimental function)</h2><span id='topic+svy.varcoef_hopit'></span>

<h3>Description</h3>

<p>This function is an equivalent of <code>survey:::svy.varcoef</code>. In the original approach <code>estfun</code> is calculated from
glm's working residuals:<br />
<code>estfun &lt;- model.matrix(glm.object) * resid(glm.object, "working") * glm.object$weights</code><br />
In the hopit package, estfun is directly calculated as a gradient (vector of partial derivatives) of the log likelihood function.
Depending on detected design an appropriate <code>survey</code> function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svy.varcoef_hopit(vcovMat, estfun, design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svy.varcoef_hopit_+3A_vcovmat">vcovMat</code></td>
<td>
<p>a variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="svy.varcoef_hopit_+3A_estfun">estfun</code></td>
<td>
<p>a gradient function of the log-likelihood function.</p>
</td></tr>
<tr><td><code id="svy.varcoef_hopit_+3A_design">design</code></td>
<td>
<p>a <code>survey.design</code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survey.html#topic+svydesign">svydesign</a></code>
<code><a href="#topic+hopit">hopit</a></code>
</p>

<hr>
<h2 id='vcov.hopit'>Variance-covariance matrix from the fitted model</h2><span id='topic+vcov.hopit'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the main parameters of a fitted <code>hopit</code> model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hopit'
vcov(object, robust.vcov, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.hopit_+3A_object">object</code></td>
<td>
<p>a <code>hopit</code> object.</p>
</td></tr>
<tr><td><code id="vcov.hopit_+3A_robust.vcov">robust.vcov</code></td>
<td>
<p>a logical indicating whether to use the sandwich estimator to
calculate the variance-covariance matrix.
If a survey design is detected, then this option is ignored.</p>
</td></tr>
<tr><td><code id="vcov.hopit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maciej J. Danko
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
