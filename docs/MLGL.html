<!DOCTYPE html><html lang="en"><head><title>Help for package MLGL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MLGL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MLGL-package'><p>MLGL</p></a></li>
<li><a href='#bootstrapHclust'><p>Hierarchical Clustering with distance matrix computed using bootstrap replicates</p></a></li>
<li><a href='#coef.cv.MLGL'><p>Get coefficients from a <code>cv.MLGL</code> object</p></a></li>
<li><a href='#coef.MLGL'><p>Get coefficients from a <code>MLGL</code> object</p></a></li>
<li><a href='#computeGroupSizeWeight'><p>Compute the group size weight vector with an authorized maximal size</p></a></li>
<li><a href='#cv.MLGL'><p>Multi-Layer Group-Lasso with cross V-fold validation</p></a></li>
<li><a href='#Ftest'><p>F-test</p></a></li>
<li><a href='#fullProcess'><p>Full process of MLGL</p></a></li>
<li><a href='#hierarchicalFDR'><p>Hierarchical testing with FDR control</p></a></li>
<li><a href='#hierarchicalFWER'><p>Hierarchical testing with FWER control</p></a></li>
<li><a href='#HMT'><p>Hierarchical Multiple Testing procedure</p></a></li>
<li><a href='#listToMatrix'><p>Obtain a sparse matrix of the coefficients of the path</p></a></li>
<li><a href='#MLGL'><p>Multi-Layer Group-Lasso</p></a></li>
<li><a href='#overlapgglasso'><p>Group-lasso with overlapping groups</p></a></li>
<li><a href='#partialFtest'><p>Partial F-test</p></a></li>
<li><a href='#plot.cv.MLGL'><p>Plot the cross-validation obtained from <code>cv.MLGL</code> function</p></a></li>
<li><a href='#plot.fullProcess'><p>Plot the path obtained from <code>fullProcess</code> function</p></a></li>
<li><a href='#plot.HMT'><p>Plot the path obtained from <code>HMT</code> function</p></a></li>
<li><a href='#plot.MLGL'><p>Plot the path obtained from <code>MLGL</code> function</p></a></li>
<li><a href='#plot.stability.MLGL'><p>Plot the stability path obtained from <code>stability.MLGL</code> function</p></a></li>
<li><a href='#predict.cv.MLGL'><p>Predict fitted values from a <code>cv.MLGL</code> object</p></a></li>
<li><a href='#predict.MLGL'><p>Predict fitted values from a <code>MLGL</code> object</p></a></li>
<li><a href='#print.fullProcess'><p>Print Values</p></a></li>
<li><a href='#print.HMT'><p>Print Values</p></a></li>
<li><a href='#print.MLGL'><p>Print Values</p></a></li>
<li><a href='#selFDR'><p>Selection from hierarchical testing with FDR control</p></a></li>
<li><a href='#selFWER'><p>Selection from hierarchical testing with FWER control</p></a></li>
<li><a href='#simuBlockGaussian'><p>Simulate multivariate Gaussian samples with block diagonal variance matrix</p></a></li>
<li><a href='#stability.MLGL'><p>Stability Selection for Multi-Layer Group-lasso</p></a></li>
<li><a href='#summary.fullProcess'><p>Object Summaries</p></a></li>
<li><a href='#summary.HMT'><p>Object Summaries</p></a></li>
<li><a href='#summary.MLGL'><p>Object Summaries</p></a></li>
<li><a href='#uniqueGroupHclust'><p>Find all unique groups in <code>hclust</code> results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Layer Group-Lasso</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-15</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Inria</td>
</tr>
<tr>
<td>Description:</td>
<td>It implements a new procedure of variable selection in the context of redundancy between explanatory variables, which holds true with high dimensional data (Grimonprez et al. (2023) &lt;<a href="https://doi.org/10.18637%2Fjss.v106.i03">doi:10.18637/jss.v106.i03</a>&gt;).</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/modal-inria/MLGL/issues">https://github.com/modal-inria/MLGL/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>gglasso, MASS, Matrix, fastcluster, FactoMineR, parallelDist</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-15 10:09:58 UTC; quentin</td>
</tr>
<tr>
<td>Author:</td>
<td>Quentin Grimonprez [aut, cre],
  Samuel Blanck [ctb],
  Alain Celisse [ths],
  Guillemette Marot [ths],
  Yi Yang [ctb],
  Hui Zou [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin Grimonprez &lt;quentingrim@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-15 12:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='MLGL-package'>MLGL</h2><span id='topic+MLGL-package'></span>

<h3>Description</h3>

<p>This package presents a method combining Hierarchical Clustering and Group-lasso. Usually, a single partition of the 
covariates is used in the group-lasso.
Here, we provide several partitions from the hierarchical tree.
</p>
<p>A post-treatment method based on statistical test (with FWER and FDR control) for selecting the regularization parameter 
and the optimal group for this value is provided.
This method can be applied for the classical group-lasso and our method.
</p>


<h3>Details</h3>

<p>The <a href="#topic+MLGL">MLGL</a> function performs the hierarchical clustering and the group-lasso. The post-treatment method can be 
performed with <a href="#topic+hierarchicalFWER">hierarchicalFWER</a> and <a href="#topic+selFWER">selFWER</a> functions.
The whole process can be run with the <a href="#topic+fullProcess">fullProcess</a> function.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>References</h3>

<p>Grimonprez Q, Blanck S, Celisse A, Marot G (2023). &quot;MLGL: An R Package Implementing Correlated Variable 
Selection by Hierarchical Clustering and Group-Lasso.&quot; Journal of Statistical Software, 106(3), 1-33. 
doi:10.18637/jss.v106.i03.
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>, <a href="#topic+cv.MLGL">cv.MLGL</a>, <a href="#topic+fullProcess">fullProcess</a>, <a href="#topic+hierarchicalFWER">hierarchicalFWER</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
</code></pre>

<hr>
<h2 id='bootstrapHclust'>Hierarchical Clustering with distance matrix computed using bootstrap replicates</h2><span id='topic+bootstrapHclust'></span>

<h3>Description</h3>

<p>Hierarchical Clustering with distance matrix computed using bootstrap replicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapHclust(X, frac = 1, B = 50, method = "ward.D2", nCore = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrapHclust_+3A_x">X</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="bootstrapHclust_+3A_frac">frac</code></td>
<td>
<p>fraction of sample used at each replicate</p>
</td></tr>
<tr><td><code id="bootstrapHclust_+3A_b">B</code></td>
<td>
<p>number of replicates</p>
</td></tr>
<tr><td><code id="bootstrapHclust_+3A_method">method</code></td>
<td>
<p>desired method: &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;centroid&quot;, &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="bootstrapHclust_+3A_ncore">nCore</code></td>
<td>
<p>number of cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>hclust</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- bootstrapHclust(USArrests, nCore = 1)
</code></pre>

<hr>
<h2 id='coef.cv.MLGL'>Get coefficients from a <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object</h2><span id='topic+coef.cv.MLGL'></span>

<h3>Description</h3>

<p>Get coefficients from a <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.MLGL'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.MLGL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="coef.cv.MLGL_+3A_s">s</code></td>
<td>
<p>Either &quot;lambda.1se&quot; or &quot;lambda.min&quot;</p>
</td></tr>
<tr><td><code id="coef.cv.MLGL_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with estimated coefficients for given values of s.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+cv.MLGL">cv.MLGL</a>, <a href="#topic+predict.cv.MLGL">predict.cv.MLGL</a>
</p>

<hr>
<h2 id='coef.MLGL'>Get coefficients from a <code><a href="#topic+MLGL">MLGL</a></code> object</h2><span id='topic+coef.MLGL'></span>

<h3>Description</h3>

<p>Get coefficients from a <code><a href="#topic+MLGL">MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MLGL'
coef(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.MLGL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="coef.MLGL_+3A_s">s</code></td>
<td>
<p>values of lambda. If NULL, use values from object</p>
</td></tr>
<tr><td><code id="coef.MLGL_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with estimated coefficients for given values of s.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>, <a href="#topic+predict.MLGL">predict.MLGL</a>
</p>

<hr>
<h2 id='computeGroupSizeWeight'>Compute the group size weight vector with an authorized maximal size</h2><span id='topic+computeGroupSizeWeight'></span>

<h3>Description</h3>

<p>Compute the group size weight vector with an authorized maximal size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGroupSizeWeight(hc, sizeMax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeGroupSizeWeight_+3A_hc">hc</code></td>
<td>
<p>output of hclust</p>
</td></tr>
<tr><td><code id="computeGroupSizeWeight_+3A_sizemax">sizeMax</code></td>
<td>
<p>maximum size of cluster to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the weight vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# use 20 as the maximal number of group
hc &lt;- hclust(dist(t(X)))
w &lt;- computeGroupSizeWeight(hc, sizeMax = 20)
# Apply MLGL method
res &lt;- MLGL(X, y, hc = hc, weightSizeGroup = w)
</code></pre>

<hr>
<h2 id='cv.MLGL'>Multi-Layer Group-Lasso with cross V-fold validation</h2><span id='topic+cv.MLGL'></span>

<h3>Description</h3>

<p>V-fold cross validation for <code><a href="#topic+MLGL">MLGL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.MLGL(
  X,
  y,
  nfolds = 5,
  lambda = NULL,
  hc = NULL,
  weightLevel = NULL,
  weightSizeGroup = NULL,
  loss = c("ls", "logit"),
  intercept = TRUE,
  sizeMaxGroup = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.MLGL_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_y">y</code></td>
<td>
<p>vector of size n. If loss = &quot;logit&quot;, elements of y must be in -1,1</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_lambda">lambda</code></td>
<td>
<p>lambda values for group lasso. If not provided, the function generates its own values of lambda</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_hc">hc</code></td>
<td>
<p>output of <code><a href="stats.html#topic+hclust">hclust</a></code> function. If not provided, <code><a href="stats.html#topic+hclust">hclust</a></code> is run with ward.D2 method</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_weightlevel">weightLevel</code></td>
<td>
<p>a vector of size p for each level of the hierarchy. A zero indicates that the level will be ignored. 
If not provided, use 1/(height between 2 successive levels)</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_weightsizegroup">weightSizeGroup</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_loss">loss</code></td>
<td>
<p>a character string specifying the loss function to use, valid options are: &quot;ls&quot; least squares 
loss (regression) and &quot;logit&quot; logistic loss (classification)</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_intercept">intercept</code></td>
<td>
<p>should an intercept be included in the model ?</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_sizemaxgroup">sizeMaxGroup</code></td>
<td>
<p>maximum size of selected groups. If NULL, no restriction</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_verbose">verbose</code></td>
<td>
<p>print some informations</p>
</td></tr>
<tr><td><code id="cv.MLGL_+3A_...">...</code></td>
<td>
<p>Others parameters for <code><a href="gglasso.html#topic+cv.gglasso">cv.gglasso</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hierarchical clustering is performed with all the variables. Then, the partitions from the different
levels of the hierarchy are used in the different run of MLGL for cross validation.
</p>


<h3>Value</h3>

<p>a cv.MLGL object containing:
</p>

<dl>
<dt>lambda</dt><dd><p>values of <code>lambda</code>.</p>
</dd>
<dt>cvm</dt><dd><p>the mean cross-validated error.</p>
</dd>
<dt>cvsd</dt><dd><p>estimate of standard error of <code>cvm</code></p>
</dd>
<dt>cvupper</dt><dd><p>upper curve = <code>cvm+cvsd</code></p>
</dd>
<dt>cvlower</dt><dd><p>lower curve = <code>cvm-cvsd</code></p>
</dd>
<dt>lambda.min</dt><dd><p>The optimal value of <code>lambda</code> that gives minimum cross validation error <code>cvm</code>.</p>
</dd>
<dt>lambda.1se</dt><dd><p>The largest value of <code>lambda</code> such that error is within 1 standard error of the minimum.</p>
</dd>
<dt>time</dt><dd><p>computation time</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>, <a href="#topic+stability.MLGL">stability.MLGL</a>, <a href="gglasso.html#topic+predict.cv.gglasso">predict.cv.gglasso</a>, <a href="#topic+coef.cv.MLGL">coef.cv.MLGL</a>, <a href="#topic+plot.cv.MLGL">plot.cv.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply cv.MLGL method
res &lt;- cv.MLGL(X, y)
</code></pre>

<hr>
<h2 id='Ftest'>F-test</h2><span id='topic+Ftest'></span>

<h3>Description</h3>

<p>Perform a F-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ftest(X, y, varToTest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ftest_+3A_x">X</code></td>
<td>
<p>design matrix of size n*p</p>
</td></tr>
<tr><td><code id="Ftest_+3A_y">y</code></td>
<td>
<p>response vector of length n</p>
</td></tr>
<tr><td><code id="Ftest_+3A_vartotest">varToTest</code></td>
<td>
<p>vector containing the index of the column of X to test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>y = X * beta + epsilon
</p>
<p>null hypothesis: beta[varToTest] = 0
alternative hypothesis: it exists an index k in varToTest such that beta[k] != 0
</p>
<p>The test statistic is based on a full and a reduced model.
full: y = X * beta[varToTest] + epsilon
reduced: the null model
</p>


<h3>Value</h3>

<p>a vector of the same length as varToTest containing the p-values of the test.
</p>


<h3>See Also</h3>

<p><a href="#topic+partialFtest">partialFtest</a>
</p>

<hr>
<h2 id='fullProcess'>Full process of MLGL</h2><span id='topic+fullProcess'></span><span id='topic+fullProcess.default'></span><span id='topic+fullProcess.formula'></span>

<h3>Description</h3>

<p>Run hierarchical clustering following by a group-lasso on all the different partition and a hierarchical testing procedure. 
Only for linear regression problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullProcess(X, ...)

## Default S3 method:
fullProcess(
  X,
  y,
  control = c("FWER", "FDR"),
  alpha = 0.05,
  test = partialFtest,
  hc = NULL,
  fractionSampleMLGL = 1/2,
  BHclust = 50,
  nCore = NULL,
  addRoot = FALSE,
  Shaffer = FALSE,
  ...
)

## S3 method for class 'formula'
fullProcess(
  formula,
  data,
  control = c("FWER", "FDR"),
  alpha = 0.05,
  test = partialFtest,
  hc = NULL,
  fractionSampleMLGL = 1/2,
  BHclust = 50,
  nCore = NULL,
  addRoot = FALSE,
  Shaffer = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fullProcess_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_...">...</code></td>
<td>
<p>Others parameters for MLGL</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_y">y</code></td>
<td>
<p>vector of size n.</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_control">control</code></td>
<td>
<p>either &quot;FDR&quot; or &quot;FWER&quot;</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_alpha">alpha</code></td>
<td>
<p>control level for testing procedure</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_test">test</code></td>
<td>
<p>test used in the testing procedure. Default is <a href="#topic+partialFtest">partialFtest</a></p>
</td></tr>
<tr><td><code id="fullProcess_+3A_hc">hc</code></td>
<td>
<p>output of <code><a href="stats.html#topic+hclust">hclust</a></code> function. If not provided, <code><a href="stats.html#topic+hclust">hclust</a></code> is run with ward.D2 method. User 
can also provide the desired method: &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;centroid&quot;, &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_fractionsamplemlgl">fractionSampleMLGL</code></td>
<td>
<p>a real between 0 and 1: the fraction of individuals to use in the sample for MLGL (see Details).</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_bhclust">BHclust</code></td>
<td>
<p>number of replicates for computing the distance matrix for the hierarchical clustering tree</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_ncore">nCore</code></td>
<td>
<p>number of cores used for distance computation. Use all cores by default.</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_addroot">addRoot</code></td>
<td>
<p>If TRUE, add a common root containing all the groups</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_shaffer">Shaffer</code></td>
<td>
<p>If TRUE, a Shaffer correction is performed (only if control = &quot;FWER&quot;)</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the 
model to be fitted.</p>
</td></tr>
<tr><td><code id="fullProcess_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing 
the variables in the model. If not found in data, the variables are taken from environment (formula)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Divide the n individuals in two samples. Then the three following steps are done:
1) Bootstrap Hierarchical Clustering of the variables of X
2) MLGL on the second sample of individuals
3) Hierarchical testing procedure on the first sample of individuals.
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>res</dt><dd><p>output of <a href="#topic+MLGL">MLGL</a> function</p>
</dd>
<dt>lambdaOpt</dt><dd><p>lambda values maximizing the number of rejects</p>
</dd>
<dt>var</dt><dd><p>A vector containing the index of selected variables for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>group</dt><dd><p>A vector containing the values index of selected groups for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>selectedGroups</dt><dd><p>Selected groups for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>reject</dt><dd><p>Selected groups for all lambda values</p>
</dd>
<dt>alpha</dt><dd><p>Control level</p>
</dd>
<dt>test</dt><dd><p>Test used in the testing procedure</p>
</dd>
<dt>control</dt><dd><p>&quot;FDR&quot; or &quot;FWER&quot;</p>
</dd>
<dt>time</dt><dd><p>Elapsed time</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>, <a href="#topic+hierarchicalFDR">hierarchicalFDR</a>, <a href="#topic+hierarchicalFWER">hierarchicalFWER</a>, <a href="#topic+selFDR">selFDR</a>, <a href="#topic+selFWER">selFWER</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># least square loss
set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- fullProcess(X, y)
</code></pre>

<hr>
<h2 id='hierarchicalFDR'>Hierarchical testing with FDR control</h2><span id='topic+hierarchicalFDR'></span>

<h3>Description</h3>

<p>Apply hierarchical test for each hierarchy, and test external variables for FDR control at level alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchicalFDR(X, y, group, var, test = partialFtest, addRoot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchicalFDR_+3A_x">X</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code id="hierarchicalFDR_+3A_y">y</code></td>
<td>
<p>associated response</p>
</td></tr>
<tr><td><code id="hierarchicalFDR_+3A_group">group</code></td>
<td>
<p>vector with index of groups. group[i] contains the index of the group of the variable var[i].</p>
</td></tr>
<tr><td><code id="hierarchicalFDR_+3A_var">var</code></td>
<td>
<p>vector with the variables contained in each group. group[i] contains the index of the group of the variable var[i].</p>
</td></tr>
<tr><td><code id="hierarchicalFDR_+3A_test">test</code></td>
<td>
<p>function for testing the nullity of a group of coefficients in linear regression. 
The function has 3 arguments: <code>X</code>, the design matrix, <code>y</code>, response, and <code>varToTest</code>, 
a vector containing the indices of the variables to test. The function returns a p-value</p>
</td></tr>
<tr><td><code id="hierarchicalFDR_+3A_addroot">addRoot</code></td>
<td>
<p>If TRUE, add a common root containing all the groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Version of the hierarchical testing procedure of Yekutieli for MLGL output. You can use th <a href="#topic+selFDR">selFDR</a> function 
to select groups at a desired level alpha.
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>pvalues</dt><dd><p>pvalues of the different test (without correction)</p>
</dd>
<dt>adjPvalues</dt><dd><p>adjusted pvalues</p>
</dd>
<dt>groupId</dt><dd><p>Index of the group</p>
</dd>
<dt>hierMatrix</dt><dd><p>Matrix describing the hierarchical tree.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yekutieli, Daniel. &quot;Hierarchical False Discovery Rate-Controlling Methodology.&quot; 
Journal of the American Statistical Association 103.481 (2008): 309-16.
</p>


<h3>See Also</h3>

<p><a href="#topic+selFDR">selFDR</a>, <a href="#topic+hierarchicalFWER">hierarchicalFWER</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- MLGL(X, y)
test &lt;- hierarchicalFDR(X, y, res$group[[20]], res$var[[20]])
</code></pre>

<hr>
<h2 id='hierarchicalFWER'>Hierarchical testing with FWER control</h2><span id='topic+hierarchicalFWER'></span>

<h3>Description</h3>

<p>Apply hierarchical test for each hierarchy, and test external variables for FWER control at level alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchicalFWER(
  X,
  y,
  group,
  var,
  test = partialFtest,
  Shaffer = FALSE,
  addRoot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchicalFWER_+3A_x">X</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_y">y</code></td>
<td>
<p>associated response</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_group">group</code></td>
<td>
<p>vector with index of groups. group[i] contains the index of the group of the variable var[i].</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_var">var</code></td>
<td>
<p>vector with the variables contained in each group. group[i] contains the index of the group of the variable var[i].</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_test">test</code></td>
<td>
<p>function for testing the nullity of a group of coefficients in linear regression. 
The function has 3 arguments: <code>X</code>, the design matrix, <code>y</code>, response, and <code>varToTest</code>, a vector containing 
the indices of the variables to test. The function returns a p-value</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_shaffer">Shaffer</code></td>
<td>
<p>boolean, if TRUE, a Shaffer correction is performed</p>
</td></tr>
<tr><td><code id="hierarchicalFWER_+3A_addroot">addRoot</code></td>
<td>
<p>If TRUE, add a common root containing all the groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Version of the hierarchical testing procedure of Meinshausen for MLGL output. You can use th <a href="#topic+selFWER">selFWER</a> 
function to select groups at a desired level alpha
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>pvalues</dt><dd><p>pvalues of the different test (without correction)</p>
</dd>
<dt>adjPvalues</dt><dd><p>adjusted pvalues</p>
</dd>
<dt>groupId</dt><dd><p>Index of the group</p>
</dd>
<dt>hierMatrix</dt><dd><p>Matrix describing the hierarchical tree.</p>
</dd>
</dl>



<h3>References</h3>

<p>Meinshausen, Nicolai. &quot;Hierarchical Testing of Variable Importance.&quot; Biometrika 95.2 (2008): 265-78.
</p>


<h3>See Also</h3>

<p><a href="#topic+selFWER">selFWER</a>, <a href="#topic+hierarchicalFDR">hierarchicalFDR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- MLGL(X, y)
test &lt;- hierarchicalFWER(X, y, res$group[[20]], res$var[[20]])
</code></pre>

<hr>
<h2 id='HMT'>Hierarchical Multiple Testing procedure</h2><span id='topic+HMT'></span>

<h3>Description</h3>

<p>Apply Hierarchical Multiple Testing procedure on a <code><a href="#topic+MLGL">MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMT(
  res,
  X,
  y,
  control = c("FWER", "FDR"),
  alpha = 0.05,
  test = partialFtest,
  addRoot = FALSE,
  Shaffer = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HMT_+3A_res">res</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="HMT_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="HMT_+3A_y">y</code></td>
<td>
<p>vector of size n.</p>
</td></tr>
<tr><td><code id="HMT_+3A_control">control</code></td>
<td>
<p>either &quot;FDR&quot; or &quot;FWER&quot;</p>
</td></tr>
<tr><td><code id="HMT_+3A_alpha">alpha</code></td>
<td>
<p>control level for testing procedure</p>
</td></tr>
<tr><td><code id="HMT_+3A_test">test</code></td>
<td>
<p>test used in the testing procedure. Default is <a href="#topic+partialFtest">partialFtest</a></p>
</td></tr>
<tr><td><code id="HMT_+3A_addroot">addRoot</code></td>
<td>
<p>If TRUE, add a common root containing all the groups</p>
</td></tr>
<tr><td><code id="HMT_+3A_shaffer">Shaffer</code></td>
<td>
<p>If TRUE, a Shaffer correction is performed (only if control = &quot;FWER&quot;)</p>
</td></tr>
<tr><td><code id="HMT_+3A_...">...</code></td>
<td>
<p>extra parameters for <a href="#topic+selFDR">selFDR</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>lambdaOpt</dt><dd><p>lambda values maximizing the number of rejects</p>
</dd>
<dt>var</dt><dd><p>A vector containing the index of selected variables for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>group</dt><dd><p>A vector containing the values index of selected groups for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>selectedGroups</dt><dd><p>Selected groups for the first <code>lambdaOpt</code> value</p>
</dd>
<dt>indLambdaOpt</dt><dd><p>indices associated with optimal lambdas</p>
</dd>
<dt>reject</dt><dd><p>Selected groups for all lambda values</p>
</dd>
<dt>alpha</dt><dd><p>Control level</p>
</dd>
<dt>test</dt><dd><p>Test used in the testing procedure</p>
</dd>
<dt>control</dt><dd><p>&quot;FDR&quot; or &quot;FWER&quot;</p>
</dd>
<dt>time</dt><dd><p>Elapsed time</p>
</dd>
<dt>hierTest</dt><dd><p>list containing the output of the testing function for each lambda. Each element can be used 
with the <a href="#topic+selFWER">selFWER</a> or <a href="#topic+selFDR">selFDR</a> functions.</p>
</dd>
<dt>lambda</dt><dd><p>lambda path</p>
</dd>
<dt>nGroup</dt><dd><p>Number of groups before testing</p>
</dd>
<dt>nSelectedGroup</dt><dd><p>Numer of groups after testing</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+hierarchicalFWER">hierarchicalFWER</a> <a href="#topic+hierarchicalFDR">hierarchicalFDR</a> <a href="#topic+selFWER">selFWER</a> <a href="#topic+selFDR">selFDR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- MLGL(X, y)

# perform hierarchical testing with FWER control
out &lt;- HMT(res, X, y, alpha = 0.05)

# test a new value of alpha for a specific lambda
selFWER(out$hierTest[[60]], alpha = 0.1)
</code></pre>

<hr>
<h2 id='listToMatrix'>Obtain a sparse matrix of the coefficients of the path</h2><span id='topic+listToMatrix'></span>

<h3>Description</h3>

<p>Obtain a sparse matrix of the coefficients of the path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listToMatrix(x, row = c("covariates", "lambda"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listToMatrix_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="listToMatrix_+3A_row">row</code></td>
<td>
<p>&quot;lambda&quot; or &quot;covariates&quot;. If row=&quot;covariates&quot;, each row of the output matrix represents a covariate else 
if row=&quot;lambda&quot;, it represents a value of lambda.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used with a <code><a href="#topic+MLGL">MLGL</a></code> object to obtain a matrix with all estimated coefficients 
for the p original variables.
In case of overlapping groups, coefficients from repeated variables are summed.
</p>


<h3>Value</h3>

<p>a sparse matrix containing the estimated coefficients for different lambdas
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>, <a href="#topic+overlapgglasso">overlapgglasso</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
# Convert output in sparse matrix format
beta &lt;- listToMatrix(res)
</code></pre>

<hr>
<h2 id='MLGL'>Multi-Layer Group-Lasso</h2><span id='topic+MLGL'></span><span id='topic+MLGL.default'></span><span id='topic+MLGL.formula'></span>

<h3>Description</h3>

<p>Run hierarchical clustering following by a group-lasso on all the different partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLGL(X, ...)

## Default S3 method:
MLGL(
  X,
  y,
  hc = NULL,
  lambda = NULL,
  weightLevel = NULL,
  weightSizeGroup = NULL,
  intercept = TRUE,
  loss = c("ls", "logit"),
  sizeMaxGroup = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'formula'
MLGL(
  formula,
  data,
  hc = NULL,
  lambda = NULL,
  weightLevel = NULL,
  weightSizeGroup = NULL,
  intercept = TRUE,
  loss = c("ls", "logit"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLGL_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="MLGL_+3A_...">...</code></td>
<td>
<p>Others parameters for <code><a href="gglasso.html#topic+gglasso">gglasso</a></code> function</p>
</td></tr>
<tr><td><code id="MLGL_+3A_y">y</code></td>
<td>
<p>vector of size n. If loss = &quot;logit&quot;, elements of y must be in -1,1</p>
</td></tr>
<tr><td><code id="MLGL_+3A_hc">hc</code></td>
<td>
<p>output of <code><a href="stats.html#topic+hclust">hclust</a></code> function. If not provided, <code><a href="stats.html#topic+hclust">hclust</a></code> is run with <code>ward.D2</code> method. 
User can also provide the desired method: &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;centroid&quot;, &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="MLGL_+3A_lambda">lambda</code></td>
<td>
<p>lambda values for group lasso. If not provided, the function generates its own values of lambda</p>
</td></tr>
<tr><td><code id="MLGL_+3A_weightlevel">weightLevel</code></td>
<td>
<p>a vector of size p for each level of the hierarchy. A zero indicates that the level will be ignored. 
If not provided, use 1/(height between 2 successive levels). Only if <code>hc</code> is provided</p>
</td></tr>
<tr><td><code id="MLGL_+3A_weightsizegroup">weightSizeGroup</code></td>
<td>
<p>a vector of size 2*p-1 containing the weight for each group. 
Default is the square root of the size of each group. Only if <code>hc</code> is provided</p>
</td></tr>
<tr><td><code id="MLGL_+3A_intercept">intercept</code></td>
<td>
<p>should an intercept be included in the model ?</p>
</td></tr>
<tr><td><code id="MLGL_+3A_loss">loss</code></td>
<td>
<p>a character string specifying the loss function to use, valid options are: &quot;ls&quot; least squares loss (regression)
and &quot;logit&quot; logistic loss (classification)</p>
</td></tr>
<tr><td><code id="MLGL_+3A_sizemaxgroup">sizeMaxGroup</code></td>
<td>
<p>maximum size of selected groups. If NULL, no restriction</p>
</td></tr>
<tr><td><code id="MLGL_+3A_verbose">verbose</code></td>
<td>
<p>print some information</p>
</td></tr>
<tr><td><code id="MLGL_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the 
model to be fitted.</p>
</td></tr>
<tr><td><code id="MLGL_+3A_data">data</code></td>
<td>
<p>an optional data.frame, list or environment (or object coercible by as.data.frame to a data.frame) containing 
the variables in the model. If not found in data, the variables are taken from environment (formula)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a MLGL object containing:
</p>

<dl>
<dt>lambda</dt><dd><p>lambda values</p>
</dd>
<dt>b0</dt><dd><p>intercept values for <code>lambda</code></p>
</dd>
<dt>beta</dt><dd><p>A list containing the values of estimated coefficients for each values of <code>lambda</code></p>
</dd>
<dt>var</dt><dd><p>A list containing the index of selected variables for each values of <code>lambda</code></p>
</dd>
<dt>group</dt><dd><p>A list containing the values index of selected groups for each values of <code>lambda</code></p>
</dd>
<dt>nVar</dt><dd><p>A vector containing the number of non zero coefficients for each values of <code>lambda</code></p>
</dd>
<dt>nGroup</dt><dd><p>A vector containing the number of non zero groups for each values of <code>lambda</code></p>
</dd>
<dt>structure</dt><dd><p>A list containing 3 vectors. var: all variables used. group: associated groups.
weight: weight associated with the different groups.
level: for each group, the corresponding level of the hierarchy where it appears and disappears. 
3 indicates the level with a partition of 3 groups.</p>
</dd>
<dt>time</dt><dd><p>computation time</p>
</dd>
<dt>dim</dt><dd><p>dimension of <code>X</code></p>
</dd>
<dt>hc</dt><dd><p>Output of hierarchical clustering</p>
</dd>
<dt>call</dt><dd><p>Code executed by user</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+cv.MLGL">cv.MLGL</a>, <a href="#topic+stability.MLGL">stability.MLGL</a>, <a href="#topic+listToMatrix">listToMatrix</a>, <a href="#topic+predict.MLGL">predict.MLGL</a>, <a href="#topic+coef.MLGL">coef.MLGL</a>, <a href="#topic+plot.cv.MLGL">plot.cv.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
</code></pre>

<hr>
<h2 id='overlapgglasso'>Group-lasso with overlapping groups</h2><span id='topic+overlapgglasso'></span>

<h3>Description</h3>

<p>Group-lasso with overlapping groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapgglasso(
  X,
  y,
  var,
  group,
  lambda = NULL,
  weight = NULL,
  loss = c("ls", "logit"),
  intercept = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlapgglasso_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_y">y</code></td>
<td>
<p>vector of size n. If loss = &quot;logit&quot;, elements of y must be in -1,1</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_var">var</code></td>
<td>
<p>vector containing the variable to use</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_group">group</code></td>
<td>
<p>vector containing the associated groups</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_lambda">lambda</code></td>
<td>
<p>lambda values for group lasso. If not provided, the function generates its own values of lambda</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_weight">weight</code></td>
<td>
<p>a vector the weight for each group. Default is the square root of the size of each group</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_loss">loss</code></td>
<td>
<p>a character string specifying the loss function to use, valid options are: &quot;ls&quot; least squares loss 
(regression) and &quot;logit&quot; logistic loss (classification)</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_intercept">intercept</code></td>
<td>
<p>should an intercept be included in the model ?</p>
</td></tr>
<tr><td><code id="overlapgglasso_+3A_...">...</code></td>
<td>
<p>Others parameters for <code><a href="gglasso.html#topic+gglasso">gglasso</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use a group-lasso algorithm (see <code><a href="gglasso.html#topic+gglasso">gglasso</a></code>) to solve a group-lasso with overlapping groups.
Each variable j of the original matrix <code>X</code> is paste k(j) times in a new dataset with k(j) the number of 
different groups containing the variable j.
The new dataset is used to solve the group-lasso with overlapping groups running a group-lasso algorithm.
</p>


<h3>Value</h3>

<p>a MLGL object containing:
</p>

<dl>
<dt>lambda</dt><dd><p>lambda values</p>
</dd>
<dt>b0</dt><dd><p>intercept values for <code>lambda</code></p>
</dd>
<dt>beta</dt><dd><p>A list containing the values of estimated coefficients for each values of <code>lambda</code></p>
</dd>
<dt>var</dt><dd><p>A list containing the index of selected variables for each values of <code>lambda</code></p>
</dd>
<dt>group</dt><dd><p>A list containing the values index of selected groups for each values of <code>lambda</code></p>
</dd>
<dt>nVar</dt><dd><p>A vector containing the number of non zero coefficients for each values of <code>lambda</code></p>
</dd>
<dt>nGroup</dt><dd><p>A vector containing the number of non zero groups for each values of <code>lambda</code></p>
</dd>
<dt>structure</dt><dd><p>A list containing 3 vectors. var: all variables used. group: associated groups.
weight: weight associated with the different groups.</p>
</dd>
<dt>time</dt><dd><p>computation time</p>
</dd>
<dt>dim</dt><dd><p>dimension of <code>X</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Laurent Jacob, Guillaume Obozinski, and Jean-Philippe Vert. 2009. Group lasso with overlap and graph lasso. 
In Proceedings of the 26th Annual International Conference on Machine Learning (ICML '09).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+listToMatrix">listToMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Least square loss
set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
var &lt;- c(1:60, 1:8, 7:15)
group &lt;- c(rep(1:12, each = 5), rep(13, 8), rep(14, 9))
res &lt;- overlapgglasso(X, y, var, group)

# Logistic loss
y &lt;- 2 * (rowSums(X[, 1:4]) &gt; 0) - 1
var &lt;- c(1:60, 1:8, 7:15)
group &lt;- c(rep(1:12, each = 5), rep(13, 8), rep(14, 9))
res &lt;- overlapgglasso(X, y, var, group, loss = "logit")
</code></pre>

<hr>
<h2 id='partialFtest'>Partial F-test</h2><span id='topic+partialFtest'></span>

<h3>Description</h3>

<p>Perform a partial F-test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialFtest(X, y, varToTest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partialFtest_+3A_x">X</code></td>
<td>
<p>design matrix of size n*p</p>
</td></tr>
<tr><td><code id="partialFtest_+3A_y">y</code></td>
<td>
<p>response vector of length n</p>
</td></tr>
<tr><td><code id="partialFtest_+3A_vartotest">varToTest</code></td>
<td>
<p>vector containing the index of the column of X to test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>y = X * beta + epsilon
</p>
<p>null hypothesis: beta[varToTest] = 0
alternative hypothesis: it exists an index k in varToTest such that beta[k] != 0
</p>
<p>The test statistic is based on a full and a reduced model.
full: y = X * beta + epsilon
reduced: y = X * beta[-varToTest] + epsilon
</p>


<h3>Value</h3>

<p>a vector of the same length as varToTest containing the p-values of the test.
</p>


<h3>See Also</h3>

<p><a href="#topic+Ftest">Ftest</a>
</p>

<hr>
<h2 id='plot.cv.MLGL'>Plot the cross-validation obtained from <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> function</h2><span id='topic+plot.cv.MLGL'></span>

<h3>Description</h3>

<p>Plot the cross-validation obtained from <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.MLGL'
plot(x, log.lambda = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv.MLGL_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cv.MLGL_+3A_log.lambda">log.lambda</code></td>
<td>
<p>If TRUE, use log(lambda) instead of lambda in abscissa</p>
</td></tr>
<tr><td><code id="plot.cv.MLGL_+3A_...">...</code></td>
<td>
<p>Other parameters for plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+cv.MLGL">cv.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply cv.MLGL method
res &lt;- cv.MLGL(X, y)
# Plot the cv error curve
plot(res)
</code></pre>

<hr>
<h2 id='plot.fullProcess'>Plot the path obtained from <code><a href="#topic+fullProcess">fullProcess</a></code> function</h2><span id='topic+plot.fullProcess'></span>

<h3>Description</h3>

<p>Plot the path obtained from <code><a href="#topic+fullProcess">fullProcess</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fullProcess'
plot(
  x,
  log.lambda = FALSE,
  lambda.lines = FALSE,
  lambda.opt = c("min", "max", "both"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fullProcess_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fullProcess">fullProcess</a></code> object</p>
</td></tr>
<tr><td><code id="plot.fullProcess_+3A_log.lambda">log.lambda</code></td>
<td>
<p>If TRUE, use log(lambda) instead of lambda in abscissa</p>
</td></tr>
<tr><td><code id="plot.fullProcess_+3A_lambda.lines">lambda.lines</code></td>
<td>
<p>If TRUE, add vertical lines at lambda values</p>
</td></tr>
<tr><td><code id="plot.fullProcess_+3A_lambda.opt">lambda.opt</code></td>
<td>
<p>If there is several optimal lambdas, which one to print &quot;min&quot;, &quot;max&quot; or &quot;both&quot;</p>
</td></tr>
<tr><td><code id="plot.fullProcess_+3A_...">...</code></td>
<td>
<p>Other parameters for plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fullProcess">fullProcess</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- fullProcess(X, y)
# Plot the solution path
plot(res)
</code></pre>

<hr>
<h2 id='plot.HMT'>Plot the path obtained from <code><a href="#topic+HMT">HMT</a></code> function</h2><span id='topic+plot.HMT'></span>

<h3>Description</h3>

<p>Plot the path obtained from <code><a href="#topic+HMT">HMT</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMT'
plot(
  x,
  log.lambda = FALSE,
  lambda.lines = FALSE,
  lambda.opt = c("min", "max", "both"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.HMT_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fullProcess">fullProcess</a></code> object</p>
</td></tr>
<tr><td><code id="plot.HMT_+3A_log.lambda">log.lambda</code></td>
<td>
<p>If TRUE, use log(lambda) instead of lambda in abscissa</p>
</td></tr>
<tr><td><code id="plot.HMT_+3A_lambda.lines">lambda.lines</code></td>
<td>
<p>If TRUE, add vertical lines at lambda values</p>
</td></tr>
<tr><td><code id="plot.HMT_+3A_lambda.opt">lambda.opt</code></td>
<td>
<p>If there is several optimal lambdas, which one to print &quot;min&quot;, &quot;max&quot; or &quot;both&quot;</p>
</td></tr>
<tr><td><code id="plot.HMT_+3A_...">...</code></td>
<td>
<p>Other parameters for plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+HMT">HMT</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)

out &lt;- HMT(res, X, y)
plot(out)
</code></pre>

<hr>
<h2 id='plot.MLGL'>Plot the path obtained from <code><a href="#topic+MLGL">MLGL</a></code> function</h2><span id='topic+plot.MLGL'></span>

<h3>Description</h3>

<p>Plot the path obtained from <code><a href="#topic+MLGL">MLGL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MLGL'
plot(x, log.lambda = FALSE, lambda.lines = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MLGL_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="plot.MLGL_+3A_log.lambda">log.lambda</code></td>
<td>
<p>If TRUE, use log(lambda) instead of lambda in abscissa</p>
</td></tr>
<tr><td><code id="plot.MLGL_+3A_lambda.lines">lambda.lines</code></td>
<td>
<p>if TRUE, add vertical lines at lambda values</p>
</td></tr>
<tr><td><code id="plot.MLGL_+3A_...">...</code></td>
<td>
<p>Other parameters for plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
# Plot the solution path
plot(res)
</code></pre>

<hr>
<h2 id='plot.stability.MLGL'>Plot the stability path obtained from <code><a href="#topic+stability.MLGL">stability.MLGL</a></code> function</h2><span id='topic+plot.stability.MLGL'></span>

<h3>Description</h3>

<p>Plot the stability path obtained from <code><a href="#topic+stability.MLGL">stability.MLGL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stability.MLGL'
plot(x, log.lambda = FALSE, threshold = 0.75, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.stability.MLGL_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+stability.MLGL">stability.MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="plot.stability.MLGL_+3A_log.lambda">log.lambda</code></td>
<td>
<p>If TRUE, use log(lambda) instead of lambda in abscissa</p>
</td></tr>
<tr><td><code id="plot.stability.MLGL_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for selection frequency</p>
</td></tr>
<tr><td><code id="plot.stability.MLGL_+3A_...">...</code></td>
<td>
<p>Other parameters for plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>var</dt><dd><p>Index of selected variables for the given threshold.</p>
</dd>
<dt>group</dt><dd><p>Index of the associated group.</p>
</dd>
<dt>threshold</dt><dd><p>Value of threshold</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+stability.MLGL">stability.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)

# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)

# Apply stability.MLGL method
res &lt;- stability.MLGL(X, y)
selected &lt;- plot(res)
print(selected)


</code></pre>

<hr>
<h2 id='predict.cv.MLGL'>Predict fitted values from a <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object</h2><span id='topic+predict.cv.MLGL'></span>

<h3>Description</h3>

<p>Predict fitted values from a <code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.MLGL'
predict(
  object,
  newx = NULL,
  s = c("lambda.1se", "lambda.min"),
  type = c("fit", "coefficients"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.MLGL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+cv.MLGL">cv.MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="predict.cv.MLGL_+3A_newx">newx</code></td>
<td>
<p>matrix with new individuals for prediction. If type=&quot;coefficients&quot;, the parameter has to be NULL</p>
</td></tr>
<tr><td><code id="predict.cv.MLGL_+3A_s">s</code></td>
<td>
<p>Either &quot;lambda.1se&quot; or &quot;lambda.min&quot;</p>
</td></tr>
<tr><td><code id="predict.cv.MLGL_+3A_type">type</code></td>
<td>
<p>if &quot;fit&quot;, return the fitted values for each values of s, if &quot;coefficients&quot;, return the estimated 
coefficients for each s</p>
</td></tr>
<tr><td><code id="predict.cv.MLGL_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with fitted values or estimated coefficients for given values of s.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+cv.MLGL">cv.MLGL</a>
</p>

<hr>
<h2 id='predict.MLGL'>Predict fitted values from a <code><a href="#topic+MLGL">MLGL</a></code> object</h2><span id='topic+predict.MLGL'></span>

<h3>Description</h3>

<p>Predict fitted values from a <code><a href="#topic+MLGL">MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MLGL'
predict(object, newx = NULL, s = NULL, type = c("fit", "coefficients"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MLGL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="predict.MLGL_+3A_newx">newx</code></td>
<td>
<p>matrix with new individuals for prediction. If type=&quot;coefficients&quot;, the parameter has to be NULL</p>
</td></tr>
<tr><td><code id="predict.MLGL_+3A_s">s</code></td>
<td>
<p>values of lambda. If NULL, use values from object</p>
</td></tr>
<tr><td><code id="predict.MLGL_+3A_type">type</code></td>
<td>
<p>if &quot;fit&quot;, return the fitted values for each values of s, if &quot;coefficients&quot;, return the estimated 
coefficients for each s</p>
</td></tr>
<tr><td><code id="predict.MLGL_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with fitted values or estimated coefficients for given values of s.
</p>


<h3>Author(s)</h3>

<p>original code from <span class="pkg">gglasso</span> package Author: Yi Yang &lt;yiyang@umn.edu&gt;, Hui Zou &lt;hzou@stat.umn.edu&gt;
</p>
<p>function inspired from predict function from gglasso package by Yi Yang and Hui Zou.
</p>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- simuBlockGaussian(n = 50, nBlock = 12, sizeBlock = 5, rho = 0.7)
y &lt;- drop(X[, c(2, 7, 12)] %*% c(2, 2, -1)) + rnorm(50, 0, 0.5)

m1 &lt;- MLGL(X, y, loss = "ls")
predict(m1, newx = X)
predict(m1, s=3, newx = X)
predict(m1, s=1:3, newx = X)

</code></pre>

<hr>
<h2 id='print.fullProcess'>Print Values</h2><span id='topic+print.fullProcess'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+fullProcess">fullProcess</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fullProcess'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fullProcess_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+fullProcess">fullProcess</a></code> object</p>
</td></tr>
<tr><td><code id="print.fullProcess_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fullProcess">fullProcess</a> <a href="#topic+summary.fullProcess">summary.fullProcess</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- fullProcess(X, y)
print(res)
</code></pre>

<hr>
<h2 id='print.HMT'>Print Values</h2><span id='topic+print.HMT'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+HMT">HMT</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMT'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.HMT_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+HMT">HMT</a></code> object</p>
</td></tr>
<tr><td><code id="print.HMT_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+HMT">HMT</a> <a href="#topic+summary.HMT">summary.HMT</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
out &lt;- HMT(res, X, y)
print(out)
</code></pre>

<hr>
<h2 id='print.MLGL'>Print Values</h2><span id='topic+print.MLGL'></span>

<h3>Description</h3>

<p>Print a <code><a href="#topic+MLGL">MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MLGL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.MLGL_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="print.MLGL_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a> <a href="#topic+summary.MLGL">summary.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
print(res)
</code></pre>

<hr>
<h2 id='selFDR'>Selection from hierarchical testing with FDR control</h2><span id='topic+selFDR'></span>

<h3>Description</h3>

<p>Select groups from hierarchical testing procedure with FDR control (<a href="#topic+hierarchicalFDR">hierarchicalFDR</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selFDR(out, alpha = 0.05, global = TRUE, outer = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selFDR_+3A_out">out</code></td>
<td>
<p>output of <a href="#topic+hierarchicalFDR">hierarchicalFDR</a> function</p>
</td></tr>
<tr><td><code id="selFDR_+3A_alpha">alpha</code></td>
<td>
<p>control level for test</p>
</td></tr>
<tr><td><code id="selFDR_+3A_global">global</code></td>
<td>
<p>if FALSE the provided alpha is the desired level control for each family.</p>
</td></tr>
<tr><td><code id="selFDR_+3A_outer">outer</code></td>
<td>
<p>if TRUE, the FDR is controlled only on outer node (rejected groups without rejected children). 
If FALSE, it is controlled on the full tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the reference for mode details about the method.
</p>
<p>If each family is controlled at a level alpha, we have the following control:
FDR control of full tree: alpha * delta * 2  (delta = 1.44)
FDR control of outer node: alpha * L * delta * 2 (delta = 1.44)
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>toSel</dt><dd><p>vector of boolean. TRUE if the group is selected</p>
</dd>
<dt>groupId</dt><dd><p>Names of groups</p>
</dd>
<dt>local.alpha</dt><dd><p>control level for each family of hypothesis</p>
</dd>
<dt>global.alpha</dt><dd><p>control level for the tree (full tree or outer node)</p>
</dd>
</dl>



<h3>References</h3>

<p>Yekutieli, Daniel. &quot;Hierarchical False Discovery Rate-Controlling Methodology.&quot; 
Journal of the American Statistical Association 103.481 (2008): 309-16.
</p>


<h3>See Also</h3>

<p><a href="#topic+hierarchicalFDR">hierarchicalFDR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- MLGL(X, y)
test &lt;- hierarchicalFDR(X, y, res$group[[20]], res$var[[20]])
sel &lt;- selFDR(test, alpha = 0.05)
</code></pre>

<hr>
<h2 id='selFWER'>Selection from hierarchical testing with FWER control</h2><span id='topic+selFWER'></span>

<h3>Description</h3>

<p>Select groups from hierarchical testing procedure with FWER control (<a href="#topic+hierarchicalFWER">hierarchicalFWER</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selFWER(out, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selFWER_+3A_out">out</code></td>
<td>
<p>output of <a href="#topic+hierarchicalFWER">hierarchicalFWER</a> function</p>
</td></tr>
<tr><td><code id="selFWER_+3A_alpha">alpha</code></td>
<td>
<p>control level for test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only outer nodes (rejected groups without rejected children) are returned as TRUE.
</p>


<h3>Value</h3>

<p>a list containing:
</p>

<dl>
<dt>toSel</dt><dd><p>vector of boolean. TRUE if the group is selected</p>
</dd>
<dt>groupId</dt><dd><p>Names of groups</p>
</dd>
</dl>



<h3>References</h3>

<p>Meinshausen, Nicolai. &quot;Hierarchical Testing of Variable Importance.&quot; Biometrika 95.2 (2008): 265-78.
</p>


<h3>See Also</h3>

<p><a href="#topic+hierarchicalFWER">hierarchicalFWER</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
res &lt;- MLGL(X, y)
test &lt;- hierarchicalFWER(X, y, res$group[[20]], res$var[[20]])
sel &lt;- selFWER(test, alpha = 0.05)
</code></pre>

<hr>
<h2 id='simuBlockGaussian'>Simulate multivariate Gaussian samples with block diagonal variance matrix</h2><span id='topic+simuBlockGaussian'></span>

<h3>Description</h3>

<p>Simulate n samples from a gaussian multivariate law with 0 vector mean and block diagonal variance matrix with 
diagonal 1 and block of rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simuBlockGaussian(n, nBlock, sizeBlock, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simuBlockGaussian_+3A_n">n</code></td>
<td>
<p>number of samples to simulate</p>
</td></tr>
<tr><td><code id="simuBlockGaussian_+3A_nblock">nBlock</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="simuBlockGaussian_+3A_sizeblock">sizeBlock</code></td>
<td>
<p>size of blocks</p>
</td></tr>
<tr><td><code id="simuBlockGaussian_+3A_rho">rho</code></td>
<td>
<p>correlation within each block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size n * (nBlock * sizeBlock) containing the samples
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
</code></pre>

<hr>
<h2 id='stability.MLGL'>Stability Selection for Multi-Layer Group-lasso</h2><span id='topic+stability.MLGL'></span>

<h3>Description</h3>

<p>Stability selection for <code><a href="#topic+MLGL">MLGL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability.MLGL(
  X,
  y,
  B = 50,
  fraction = 0.5,
  hc = NULL,
  lambda = NULL,
  weightLevel = NULL,
  weightSizeGroup = NULL,
  loss = c("ls", "logit"),
  intercept = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability.MLGL_+3A_x">X</code></td>
<td>
<p>matrix of size n*p</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_y">y</code></td>
<td>
<p>vector of size n. If loss = &quot;logit&quot;, elements of y must be in -1,1</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_b">B</code></td>
<td>
<p>number of bootstrap sample</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_fraction">fraction</code></td>
<td>
<p>Fraction of data used at each of the <code>B</code> sub-samples</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_hc">hc</code></td>
<td>
<p>output of <code><a href="stats.html#topic+hclust">hclust</a></code> function. If not provided, <code><a href="stats.html#topic+hclust">hclust</a></code> is run with ward.D2 method</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_lambda">lambda</code></td>
<td>
<p>lambda values for group lasso. If not provided, the function generates its own values of lambda</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_weightlevel">weightLevel</code></td>
<td>
<p>a vector of size p for each level of the hierarchy. A zero indicates that the level will be ignored. 
If not provided, use 1/(height between 2 successive levels)</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_weightsizegroup">weightSizeGroup</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_loss">loss</code></td>
<td>
<p>a character string specifying the loss function to use, valid options are: &quot;ls&quot; least squares loss 
(regression) and &quot;logit&quot; logistic loss (classification)</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_intercept">intercept</code></td>
<td>
<p>should an intercept be included in the model ?</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_verbose">verbose</code></td>
<td>
<p>print some informations</p>
</td></tr>
<tr><td><code id="stability.MLGL_+3A_...">...</code></td>
<td>
<p>Others parameters for <code><a href="gglasso.html#topic+gglasso">gglasso</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hierarchical clustering is performed with all the variables. Then, the partitions from the different
levels of the hierarchy are used in the different runs of MLGL for estimating the probability of selection of each group.
</p>


<h3>Value</h3>

<p>a stability.MLGL object containing:
</p>

<dl>
<dt>lambda</dt><dd><p>sequence of <code>lambda</code>.</p>
</dd>
<dt>B</dt><dd><p>Number of bootstrap samples.</p>
</dd>
<dt>stability</dt><dd><p>A matrix of size length(lambda)*number of groups containing the probability of selection of each group</p>
</dd>
<dt>var</dt><dd><p>vector containing the index of covariates</p>
</dd>
<dt>group</dt><dd><p>vector containing the index of associated groups of covariates</p>
</dd>
<dt>time</dt><dd><p>computation time</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>References</h3>

<p>Meinshausen and Buhlmann (2010). Stability selection. 
Journal of the Royal Statistical Society: Series B (Statistical Methodology) 72.4, p. 417-473.
</p>


<h3>See Also</h3>

<p><a href="#topic+cv.MLGL">cv.MLGL</a>, <a href="#topic+MLGL">MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)

# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)

# Apply stability.MLGL method
res &lt;- stability.MLGL(X, y)


</code></pre>

<hr>
<h2 id='summary.fullProcess'>Object Summaries</h2><span id='topic+summary.fullProcess'></span>

<h3>Description</h3>

<p>Summary of a <code><a href="#topic+fullProcess">fullProcess</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fullProcess'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fullProcess_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+fullProcess">fullProcess</a></code> object</p>
</td></tr>
<tr><td><code id="summary.fullProcess_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fullProcess">fullProcess</a> <a href="#topic+print.fullProcess">print.fullProcess</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- fullProcess(X, y)
summary(res)
</code></pre>

<hr>
<h2 id='summary.HMT'>Object Summaries</h2><span id='topic+summary.HMT'></span>

<h3>Description</h3>

<p>Summary of a <code><a href="#topic+HMT">HMT</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMT'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.HMT_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+HMT">HMT</a></code> object</p>
</td></tr>
<tr><td><code id="summary.HMT_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+HMT">HMT</a> <a href="#topic+print.HMT">print.HMT</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
out &lt;- HMT(res, X, y)
summary(out)
</code></pre>

<hr>
<h2 id='summary.MLGL'>Object Summaries</h2><span id='topic+summary.MLGL'></span>

<h3>Description</h3>

<p>Summary of a <code><a href="#topic+MLGL">MLGL</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MLGL'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MLGL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+MLGL">MLGL</a></code> object</p>
</td></tr>
<tr><td><code id="summary.MLGL_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+MLGL">MLGL</a> <a href="#topic+print.MLGL">print.MLGL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Simulate gaussian data with block-diagonal variance matrix containing 12 blocks of size 5
X &lt;- simuBlockGaussian(50, 12, 5, 0.7)
# Generate a response variable
y &lt;- X[, c(2, 7, 12)] %*% c(2, 2, -2) + rnorm(50, 0, 0.5)
# Apply MLGL method
res &lt;- MLGL(X, y)
summary(res)
</code></pre>

<hr>
<h2 id='uniqueGroupHclust'>Find all unique groups in <code><a href="stats.html#topic+hclust">hclust</a></code> results</h2><span id='topic+uniqueGroupHclust'></span>

<h3>Description</h3>

<p>Find all unique groups in <code><a href="stats.html#topic+hclust">hclust</a></code> results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqueGroupHclust(hc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniqueGroupHclust_+3A_hc">hc</code></td>
<td>
<p>output of <code><a href="stats.html#topic+hclust">hclust</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>indexGroup</dt><dd><p>Vector containing the index of variables.</p>
</dd>
<dt>varGroup</dt><dd><p>Vector containing the index of the group of each variable.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hc &lt;- hclust(dist(USArrests), "average")
res &lt;- uniqueGroupHclust(hc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
