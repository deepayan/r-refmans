<!DOCTYPE html><html lang="en"><head><title>Help for package orthoDr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orthoDr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#orthoDr-package'><p>orthoDr: Semi-Parametric Dimension Reduction Models Using Orthogonality Constrained Optimization</p></a></li>
<li><a href='#CP_SIR'><p>Counting process based sliced inverse regression model</p></a></li>
<li><a href='#dist_cross'><p>Cross distance matrix</p></a></li>
<li><a href='#distance'><p>Compute Distance Correlation</p></a></li>
<li><a href='#dosepred'><p>The prediction function for the personalized direct learning dose model</p></a></li>
<li><a href='#gen_solver'><p>General solver <code>C++</code> function</p></a></li>
<li><a href='#hMave'><p>Hazard Mave for Censored Survival Data</p></a></li>
<li><a href='#initB'><p>initB</p></a></li>
<li><a href='#kernel_weight'><p>Kernel Weight</p></a></li>
<li><a href='#KernelDist_cross'><p>KernelDist_cross</p></a></li>
<li><a href='#local_f'><p>local_f</p></a></li>
<li><a href='#local_solver'><p>local semi regression solver <code>C++</code> function</p></a></li>
<li><a href='#ortho_optim'><p>Orthogonality constrained optimization</p></a></li>
<li><a href='#orthoDr_pdose'><p>Direct Learning &amp; Pseudo-direct Learning Model</p></a></li>
<li><a href='#orthoDr_reg'><p>Semiparametric dimension reduction method from Ma &amp; Zhu (2012).</p></a></li>
<li><a href='#orthoDr_surv'><p>Counting Process based semiparametric dimension reduction (IR-CP) model</p></a></li>
<li><a href='#pdose_direct_solver'><p>pdose_direct_solver</p></a></li>
<li><a href='#pdose_semi_solver'><p>pdose_semi_solver</p></a></li>
<li><a href='#phd_init'><p>phd_init</p></a></li>
<li><a href='#phd_solver'><p>semi-phd solver <code>C++</code> function</p></a></li>
<li><a href='#predict.orthoDr'><p>Predictions under <code>orthoDr</code> models</p></a></li>
<li><a href='#print.orthoDr'><p>Print a <code>orthoDr</code> object</p></a></li>
<li><a href='#pSAVE'><p>Partial Sliced Averaged Variance Estimation</p></a></li>
<li><a href='#reg_init'><p>reg_init</p></a></li>
<li><a href='#reg_solve'><p>reg_solve</p></a></li>
<li><a href='#save_init'><p>save_init</p></a></li>
<li><a href='#save_solver'><p>semi-save solver <code>C++</code> function</p></a></li>
<li><a href='#seff_init'><p>seff_init</p></a></li>
<li><a href='#seff_solver'><p>Eff semi regression solver <code>C++</code> function</p></a></li>
<li><a href='#silverman'><p>Silverman's rule of thumb</p></a></li>
<li><a href='#sir_init'><p>sir_init</p></a></li>
<li><a href='#sir_solver'><p>semi-sir solver <code>C++</code> function</p></a></li>
<li><a href='#skcm.clinical'><p>Skin Cutaneous Melanoma Data set</p></a></li>
<li><a href='#skcm.melgene'><p>Genes associated with Melanoma given by the MelGene Database</p></a></li>
<li><a href='#surv_dm_solver'><p>surv_dm_solver <code>C++</code> function</p></a></li>
<li><a href='#surv_dn_solver'><p>surv_dn_solver <code>C++</code> function</p></a></li>
<li><a href='#surv_forward_solver'><p>surv_forward_solver <code>C++</code> function</p></a></li>
<li><a href='#view_dr_surv'><p>2D or 2D view of survival data on reduced dimension</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semi-Parametric Dimension Reduction Models Using Orthogonality
Constrained Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilize an orthogonality constrained optimization algorithm of
    Wen &amp; Yin (2013) &lt;<a href="https://doi.org/10.1007%2Fs10107-012-0584-1">doi:10.1007/s10107-012-0584-1</a>&gt; to solve a variety of
    dimension reduction problems in the semiparametric framework, such as
    Ma &amp; Zhu (2012) &lt;<a href="https://doi.org/10.1080%2F01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>&gt;, Ma &amp; Zhu (2013) 
    &lt;<a href="https://doi.org/10.1214%2F12-AOS1072">doi:10.1214/12-AOS1072</a>&gt;, Sun, Zhu, Wang &amp; Zeng (2019) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasy064">doi:10.1093/biomet/asy064</a>&gt;
    and Zhou, Zhu &amp; Zeng (2021) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaa087">doi:10.1093/biomet/asaa087</a>&gt;. The package also
    implements some existing dimension reduction methods such as hMave by Xia, Zhang,
    &amp; Xu (2010) &lt;<a href="https://doi.org/10.1198%2Fjasa.2009.tm09372">doi:10.1198/jasa.2009.tm09372</a>&gt; and partial SAVE by Feng, Wen &amp; Zhu (2013)
    &lt;<a href="https://doi.org/10.1080%2F01621459.2012.746065">doi:10.1080/01621459.2012.746065</a>&gt;. It also serves as a general purpose 
    optimization solver for problems with orthogonality constraints, i.e., in Stiefel 
    manifold. Parallel computing for approximating the gradient is enabled through 'OpenMP'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), survival, dr, pracma, plot3D, rgl, MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/teazrq/orthoDr">https://github.com/teazrq/orthoDr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/teazrq/orthoDr/issues">https://github.com/teazrq/orthoDr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 02:44:48 UTC; zrq</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruilin Zhao [aut, cph],
  Ruoqing Zhu <a href="https://orcid.org/0000-0002-0753-5716"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Jiyang Zhang [aut, cph],
  Wenzhuo Zhou [aut, cph],
  Peng Xu [aut, cph],
  James Joseph Balamuta
    <a href="https://orcid.org/0000-0003-2826-8458"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruoqing Zhu &lt;teazrq@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='orthoDr-package'>orthoDr: Semi-Parametric Dimension Reduction Models Using Orthogonality Constrained Optimization</h2><span id='topic+orthoDr'></span><span id='topic+orthoDr-package'></span>

<h3>Description</h3>

<p>Utilize an orthogonality constrained optimization algorithm of Wen &amp; Yin (2013) <a href="https://doi.org/10.1007/s10107-012-0584-1">doi:10.1007/s10107-012-0584-1</a> to solve a variety of dimension reduction problems in the semiparametric framework, such as Ma &amp; Zhu (2012) <a href="https://doi.org/10.1080/01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>, Ma &amp; Zhu (2013) <a href="https://doi.org/10.1214/12-AOS1072">doi:10.1214/12-AOS1072</a>, Sun, Zhu, Wang &amp; Zeng (2019) <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a> and Zhou, Zhu &amp; Zeng (2021) <a href="https://doi.org/10.1093/biomet/asaa087">doi:10.1093/biomet/asaa087</a>. The package also implements some existing dimension reduction methods such as hMave by Xia, Zhang, &amp; Xu (2010) <a href="https://doi.org/10.1198/jasa.2009.tm09372">doi:10.1198/jasa.2009.tm09372</a> and partial SAVE by Feng, Wen &amp; Zhu (2013) <a href="https://doi.org/10.1080/01621459.2012.746065">doi:10.1080/01621459.2012.746065</a>. It also serves as a general purpose optimization solver for problems with orthogonality constraints, i.e., in Stiefel manifold. Parallel computing for approximating the gradient is enabled through 'OpenMP'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ruoqing Zhu <a href="mailto:teazrq@gmail.com">teazrq@gmail.com</a> (<a href="https://orcid.org/0000-0002-0753-5716">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Ruilin Zhao <a href="mailto:rzhao15@seas.upenn.edu">rzhao15@seas.upenn.edu</a> [copyright holder]
</p>
</li>
<li><p> Jiyang Zhang <a href="mailto:jiyangz2@illinois.edu">jiyangz2@illinois.edu</a> [copyright holder]
</p>
</li>
<li><p> Wenzhuo Zhou <a href="mailto:wenzhuo3@illinois.edu">wenzhuo3@illinois.edu</a> [copyright holder]
</p>
</li>
<li><p> Peng Xu <a href="mailto:px2132@columbia.edu">px2132@columbia.edu</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> James Joseph Balamuta <a href="mailto:balamut2@illinois.edu">balamut2@illinois.edu</a> (<a href="https://orcid.org/0000-0003-2826-8458">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/teazrq/orthoDr">https://github.com/teazrq/orthoDr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/teazrq/orthoDr/issues">https://github.com/teazrq/orthoDr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CP_SIR'>Counting process based sliced inverse regression model</h2><span id='topic+CP_SIR'></span>

<h3>Description</h3>

<p>The CP-SIR model for right-censored survival outcome. This model is correct
only under very strong assumptions, however, since it only requires an SVD,
the solution is used as the initial value in the orthoDr optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP_SIR(x, y, censor, bw = silverman(1, length(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CP_SIR_+3A_x">x</code></td>
<td>
<p>A matrix for features (continuous only).</p>
</td></tr>
<tr><td><code id="CP_SIR_+3A_y">y</code></td>
<td>
<p>A vector of observed time.</p>
</td></tr>
<tr><td><code id="CP_SIR_+3A_censor">censor</code></td>
<td>
<p>A vector of censoring indicator.</p>
</td></tr>
<tr><td><code id="CP_SIR_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for nonparametric estimations (one-dimensional),
the default is using Silverman's formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>The eigenvalues of the estimation matrix</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>The estimated directions, ordered by eigenvalues</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T. and Zeng, D. (2019) &quot;Counting Process Based Dimension Reduction Method for Censored Outcomes.&quot;
Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is setting 1 in Sun et. al. (2017) with reduced sample size
library(MASS)
set.seed(1)
N &lt;- 200
P &lt;- 6
V &lt;- 0.5^abs(outer(1:P, 1:P, "-"))
dataX &lt;- as.matrix(mvrnorm(N, mu = rep(0, P), Sigma = V))
failEDR &lt;- as.matrix(c(1, 0.5, 0, 0, 0, rep(0, P - 5)))
censorEDR &lt;- as.matrix(c(0, 0, 0, 1, 1, rep(0, P - 5)))
T &lt;- rexp(N, exp(dataX %*% failEDR))
C &lt;- rexp(N, exp(dataX %*% censorEDR - 1))
ndr &lt;- 1
Y &lt;- pmin(T, C)
Censor &lt;- (T &lt; C)

# fit the model
cpsir.fit &lt;- CP_SIR(dataX, Y, Censor)
distance(failEDR, cpsir.fit$vectors[, 1:ndr, drop = FALSE], "dist")
</code></pre>

<hr>
<h2 id='dist_cross'>Cross distance matrix</h2><span id='topic+dist_cross'></span>

<h3>Description</h3>

<p>Calculate the Gaussian kernel distance between rows of X1 and rows of X2.
As a result, this is an extension to the <code><a href="stats.html#topic+dist">stats::dist()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_cross(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_cross_+3A_x1">x1</code></td>
<td>
<p>First data matrix</p>
</td></tr>
<tr><td><code id="dist_cross_+3A_x2">x2</code></td>
<td>
<p>Second data matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix with its (i, j)th element being the Gaussian kernel
distance between ith row of <code>X1</code> jth row of <code>X2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two matrices
set.seed(1)
x1 &lt;- matrix(rnorm(10), 5, 2)
x2 &lt;- matrix(rnorm(6), 3, 2)
dist_cross(x1, x2)
</code></pre>

<hr>
<h2 id='distance'>Compute Distance Correlation</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Calculate the distance correlation between two linear spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(s1, s2, type = "dist", x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_+3A_s1">s1</code></td>
<td>
<p>First space</p>
</td></tr>
<tr><td><code id="distance_+3A_s2">s2</code></td>
<td>
<p>Second space</p>
</td></tr>
<tr><td><code id="distance_+3A_type">type</code></td>
<td>
<p>Type of distance measures: <code>"dist"</code> (default), <code>"trace"</code>,
<code>"canonical"</code> or <code>"sine"</code></p>
</td></tr>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>The covariate values, for canonical correlation only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between <code>s1</code> and <code>s2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two spaces
failEDR &lt;- as.matrix(cbind(
  c(1, 1, 0, 0, 0, 0),
  c(0, 0, 1, -1, 0, 0)
))
B &lt;- as.matrix(cbind(
  c(0.1, 1.1, 0, 0, 0, 0),
  c(0, 0, 1.1, -0.9, 0, 0)
))

distance(failEDR, B, "dist")
distance(failEDR, B, "trace")

N &lt;- 300
P &lt;- 6
dataX &lt;- matrix(rnorm(N * P), N, P)
distance(failEDR, B, "canonical", dataX)
</code></pre>

<hr>
<h2 id='dosepred'>The prediction function for the personalized direct learning dose model</h2><span id='topic+dosepred'></span>

<h3>Description</h3>

<p>Predict the fitted dose from the direct learning dose model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dosepred(B, X, X_test, bw, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dosepred_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="dosepred_+3A_x">X</code></td>
<td>
<p>The covariate matrix</p>
</td></tr>
<tr><td><code id="dosepred_+3A_x_test">X_test</code></td>
<td>
<p>The test covariate matrix</p>
</td></tr>
<tr><td><code id="dosepred_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variable have unit variance</p>
</td></tr>
<tr><td><code id="dosepred_+3A_w">w</code></td>
<td>
<p>The kernel ridge regression coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted dose
</p>

<hr>
<h2 id='gen_solver'>General solver <code>C++</code> function</h2><span id='topic+gen_solver'></span>

<h3>Description</h3>

<p>A general purpose optimization solver with orthogonality constraint. For details, please see the original <code>MATLAB</code> code by Wen and Yin (2013). This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_solver(
  B,
  f,
  g,
  env,
  useg,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_f">f</code></td>
<td>
<p>A function that calculates the objective function value. The first argument should be <code>B</code>. Returns a single value.</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_g">g</code></td>
<td>
<p>A function that calculates the gradient. The first argument should be <code>B</code>. Returns a matrix with the same dimension as <code>B</code>. If not specified, then the numerical approximation is used.</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_env">env</code></td>
<td>
<p>Environment passed to the Rcpp function for evaluating <code>f</code> and <code>g</code></p>
</td></tr>
<tr><td><code id="gen_solver_+3A_useg">useg</code></td>
<td>
<p>If true, the gradient is calculated using <code>g</code> function, otherwise numerically approximated</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="gen_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wen, Z., &amp; Yin, W. (2013). A feasible method for optimization with orthogonality constraints.
Mathematical Programming, 142(1), 397-434.
DOI: <a href="https://doi.org/10.1007/s10107-012-0584-1">doi:10.1007/s10107-012-0584-1</a>
</p>
<p>Zhang, H., &amp; Hager, W. W. (2004). A nonmonotone line search technique and its application to unconstrained optimization.
SIAM journal on Optimization, 14(4), 1043-1056.
DOI: <a href="https://doi.org/10.1137/S1052623403428208">doi:10.1137/S1052623403428208</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function should be called internally. When having all objects pre-computed, one can call
# gen_solver(B, f, g, env, useg, rho, eta, gamma, tau, epsilon, btol, ftol, gtol, maxitr, verbose)
# to solve for the parameters B.
</code></pre>

<hr>
<h2 id='hMave'>Hazard Mave for Censored Survival Data</h2><span id='topic+hMave'></span>

<h3>Description</h3>

<p>This is an almost direct R translation of Xia, Zhang &amp; Xu's (2010) hMave
<code>MATLAB</code> code. We implemented further options for setting a different initial
value. The computational algorithm does not utilize the orthogonality
constrained optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hMave(x, y, censor, m0, B0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hMave_+3A_x">x</code></td>
<td>
<p>A matrix for features.</p>
</td></tr>
<tr><td><code id="hMave_+3A_y">y</code></td>
<td>
<p>A vector of observed time.</p>
</td></tr>
<tr><td><code id="hMave_+3A_censor">censor</code></td>
<td>
<p>A vector of censoring indicator.</p>
</td></tr>
<tr><td><code id="hMave_+3A_m0">m0</code></td>
<td>
<p>number of dimensions to use</p>
</td></tr>
<tr><td><code id="hMave_+3A_b0">B0</code></td>
<td>
<p>initial value of B. This is a feature we implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The estimated B matrix</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>Leave one out cross-validation error</p>
</td></tr>
</table>


<h3>References</h3>

<p>Xia, Y., Zhang, D., &amp; Xu, J. (2010). Dimension reduction and semiparametric estimation of survival models.
Journal of the American Statistical Association, 105(489), 278-290.
DOI: <a href="https://doi.org/10.1198/jasa.2009.tm09372">doi:10.1198/jasa.2009.tm09372</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some survival data
set.seed(1)
P &lt;- 7
N &lt;- 150
dataX &lt;- matrix(runif(N * P), N, P)
failEDR &lt;- as.matrix(cbind(c(1, 1.3, -1.3, 1, -0.5, 0.5, -0.5, rep(0, P - 7))))
T &lt;- exp(dataX %*% failEDR + rnorm(N))
C &lt;- runif(N, 0, 15)
Y &lt;- pmin(T, C)
Censor &lt;- (T &lt; C)

# fit the model
hMave.fit &lt;- hMave(dataX, Y, Censor, 1)
</code></pre>

<hr>
<h2 id='initB'>initB</h2><span id='topic+initB'></span>

<h3>Description</h3>

<p>regression initiation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initB(x, y, ndr, bw, method, ncore)
</code></pre>

<hr>
<h2 id='kernel_weight'>Kernel Weight</h2><span id='topic+kernel_weight'></span>

<h3>Description</h3>

<p>Calculate the Gaussian kernel weights between rows of <code>X1</code> and rows of <code>X2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_weight(x1, x2, kernel = "gaussian", dist = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_weight_+3A_x1">x1</code></td>
<td>
<p>First data matrix</p>
</td></tr>
<tr><td><code id="kernel_weight_+3A_x2">x2</code></td>
<td>
<p>Second data matrix</p>
</td></tr>
<tr><td><code id="kernel_weight_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function, currently only using Gaussian kernel.</p>
</td></tr>
<tr><td><code id="kernel_weight_+3A_dist">dist</code></td>
<td>
<p>The distance metric, currently only using the Euclidean
distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix, with its (i, j)th element being the kernel weights for
the <em>i</em> th row of <code>X1</code> jth row of <code>X2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two matrices
set.seed(1)
x1 &lt;- matrix(rnorm(10), 5, 2)
x2 &lt;- matrix(rnorm(6), 3, 2)
kernel_weight(x1, x2)
</code></pre>

<hr>
<h2 id='KernelDist_cross'>KernelDist_cross</h2><span id='topic+KernelDist_cross'></span>

<h3>Description</h3>

<p>Calculate the kernel distance between testing data and training data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernelDist_cross(TestX, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernelDist_cross_+3A_testx">TestX</code></td>
<td>
<p>testing data</p>
</td></tr>
<tr><td><code id="KernelDist_cross_+3A_x">X</code></td>
<td>
<p>training data</p>
</td></tr>
</table>

<hr>
<h2 id='local_f'>local_f</h2><span id='topic+local_f'></span>

<h3>Description</h3>

<p>local method f value function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_f(B, X, Y, bw, ncore)
</code></pre>

<hr>
<h2 id='local_solver'>local semi regression solver <code>C++</code> function</h2><span id='topic+local_solver'></span>

<h3>Description</h3>

<p>Sovling the local semiparametric estimating equations. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_solver(
  B,
  X,
  Y,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="local_solver_+3A_x">X</code></td>
<td>
<p>A matrix of the parameters <code>X</code></p>
</td></tr>
<tr><td><code id="local_solver_+3A_y">Y</code></td>
<td>
<p>A matrix of the parameters <code>Y</code></p>
</td></tr>
<tr><td><code id="local_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="local_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="local_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="local_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="local_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="local_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for apprximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="local_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="local_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="local_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="local_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="local_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2013). Efficient estimation in sufficient dimension reduction.
Annals of statistics, 41(1), 250.
DOI: <a href="https://doi.org/10.1214/12-AOS1072">doi:10.1214/12-AOS1072</a>
</p>

<hr>
<h2 id='ortho_optim'>Orthogonality constrained optimization</h2><span id='topic+ortho_optim'></span>

<h3>Description</h3>

<p>A general purpose optimization solver with orthogonality constraint.
The orthogonality constrained optimization method is a nearly direct
translation from Wen and Yin (2010)'s <code>MATLAB</code> code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho_optim(
  B,
  fn,
  grad = NULL,
  ...,
  maximize = FALSE,
  control = list(),
  maxitr = 500,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ortho_optim_+3A_b">B</code></td>
<td>
<p>Initial <code>B</code> values. Must be a matrix, and the columns are
subject to the orthogonality constrains. Will be processed
by Gram-Schmidt if not orthogonal</p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_fn">fn</code></td>
<td>
<p>A function that calculate the objective function value.
The first argument should be <code>B</code>. Returns a single value.</p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_grad">grad</code></td>
<td>
<p>A function that calculate the gradient. The first argument
should be <code>B</code>. Returns a matrix with the same dimension
as <code>B</code>. If not specified, then numerical approximation is
used.</p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>fn</code> and <code>grad</code></p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_maximize">maximize</code></td>
<td>
<p>By default, the solver will try to minimize the objective
function unless <code>maximize = TRUE</code></p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_control">control</code></td>
<td>
<p>A list of tuning variables for optimization. <code>epsilon</code> is
the size for numerically approximating the gradient.
For others, see Wen and Yin (2013).</p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="ortho_optim_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>orthoDr</code> object that consists of a <code>list</code> with named entries of:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The optimal <code>B</code> value</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>The final functional value</p>
</td></tr>
<tr><td><code>itr</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>convergence code</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wen, Z., &amp; Yin, W. (2013). A feasible method for optimization with orthogonality constraints. Mathematical Programming, 142(1), 397-434.
DOI: <a href="https://doi.org/10.1007/s10107-012-0584-1">doi:10.1007/s10107-012-0584-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an eigen value problem
library(pracma)
set.seed(1)
n &lt;- 100
k &lt;- 6
A &lt;- matrix(rnorm(n * n), n, n)
A &lt;- t(A) %*% A
B &lt;- gramSchmidt(matrix(rnorm(n * k), n, k))$Q

fx &lt;- function(B, A) -0.5 * sum(diag(t(B) %*% A %*% B))
gx &lt;- function(B, A) -A %*% B
fit &lt;- ortho_optim(B, fx, gx, A = A)
fx(fit$B, A)

# compare with the solution from the eigen function
sol &lt;- eigen(A)$vectors[, 1:k]
fx(sol, A)
</code></pre>

<hr>
<h2 id='orthoDr_pdose'>Direct Learning &amp; Pseudo-direct Learning Model</h2><span id='topic+orthoDr_pdose'></span>

<h3>Description</h3>

<p>Performs the &quot;Direct Learning &amp; Pseudo-direct Learning&quot; Method for
personalized medicine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoDr_pdose(
  x,
  a,
  r,
  ndr = ndr,
  B.initial = NULL,
  bw = NULL,
  lambda = 0.1,
  K = sqrt(length(r)),
  method = c("direct", "pseudo_direct"),
  keep.data = FALSE,
  control = list(),
  maxitr = 500,
  verbose = FALSE,
  ncore = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthoDr_pdose_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> for features (continuous only).</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_a">a</code></td>
<td>
<p>A <code>vector</code> of observed dose</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_r">r</code></td>
<td>
<p>A <code>vector</code> of observed reward</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_ndr">ndr</code></td>
<td>
<p>A dimension structure</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_b.initial">B.initial</code></td>
<td>
<p>Initial <code>B</code> values. Will use the partial SAVE <a href="#topic+pSAVE">pSAVE</a> as the initial if
leaving as <code>NULL</code>. If specified, must be a matrix with
<code>ncol(x)</code> rows and <code>ndr</code> columns. Will be processed by
Gram-Schmidt if not orthogonal.</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variables have unit variance</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_lambda">lambda</code></td>
<td>
<p>The penalty level for kernel ridge regression. If a range of values is specified, the GCV will be used to select the best tuning</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_k">K</code></td>
<td>
<p>A number of grids in the range of dose</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_method">method</code></td>
<td>
<p>Either <code>"direct"</code> or <code>"pseudo_direct"</code></p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_keep.data">keep.data</code></td>
<td>
<p>Should the original data be kept for prediction</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_control">control</code></td>
<td>
<p>A list of tuning variables for optimization. <code>epsilon</code> is the size for numerically approximating the gradient. For others, see Wen and Yin (2013).</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="orthoDr_pdose_+3A_ncore">ncore</code></td>
<td>
<p>the number of cores for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>orthoDr</code> object consisting of <code>list</code> with named elements:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The optimal <code>B</code> value</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>The final functional value</p>
</td></tr>
<tr><td><code>itr</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>convergence code</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zhou, W., Zhu, R., &amp; Zeng, D. (2021). A parsimonious personalized dose-finding model via dimension reduction.
Biometrika, 108(3), 643-659.
DOI: <a href="https://doi.org/10.1093/biomet/asaa087">doi:10.1093/biomet/asaa087</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some personalized dose scenario

exampleset &lt;- function(size, ncov) {
  X &lt;- matrix(runif(size * ncov, -1, 1), ncol = ncov)
  A &lt;- runif(size, 0, 2)

  Edr &lt;- as.matrix(c(0.5, -0.5))

  D_opt &lt;- X %*% Edr + 1

  mu &lt;- 2 + 0.5 * (X %*% Edr) - 7 * abs(D_opt - A)

  R &lt;- rnorm(length(mu), mu, 1)

  R &lt;- R - min(R)

  datainfo &lt;- list(X = X, A = A, R = R, D_opt = D_opt, mu = mu)
  return(datainfo)
}

# generate data

set.seed(123)
n &lt;- 150
p &lt;- 2
ndr &lt;- 1
train &lt;- exampleset(n, p)
test &lt;- exampleset(500, p)

# the direct learning method
orthofit &lt;- orthoDr_pdose(train$X, train$A, train$R,
  ndr = ndr, lambda = 0.1,
  method = "direct", K = sqrt(n), keep.data = TRUE,
  maxitr = 150, verbose = FALSE, ncore = 2
)

dose &lt;- predict(orthofit, test$X)

# ` # compare with the optimal dose
dosedistance &lt;- mean((test$D_opt - dose$pred)^2)
print(dosedistance)

# the pseudo direct learning method
orthofit &lt;- orthoDr_pdose(train$X, train$A, train$R,
  ndr = ndr, lambda = seq(0.1, 0.2, 0.01),
  method = "pseudo_direct", K = as.integer(sqrt(n)), keep.data = TRUE,
  maxitr = 150, verbose = FALSE, ncore = 2
)

dose &lt;- predict(orthofit, test$X)

# compare with the optimal dose

dosedistance &lt;- mean((test$D_opt - dose$pred)^2)
print(dosedistance)
</code></pre>

<hr>
<h2 id='orthoDr_reg'>Semiparametric dimension reduction method from Ma &amp; Zhu (2012).</h2><span id='topic+orthoDr_reg'></span>

<h3>Description</h3>

<p>Performs the semiparametric dimension reduction method associated with
Ma &amp; Zhu (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoDr_reg(
  x,
  y,
  method = "sir",
  ndr = 2,
  B.initial = NULL,
  bw = NULL,
  keep.data = FALSE,
  control = list(),
  maxitr = 500,
  verbose = FALSE,
  ncore = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthoDr_reg_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> for features (continous only).
The algorithm will not scale the columns to unit variance</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_y">y</code></td>
<td>
<p>A <code>vector</code> of continuous outcome</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_method">method</code></td>
<td>
<p>Dimension reduction methods (semi-): <code>"sir"</code>, <code>"save"</code>,
<code>"phd"</code>, <code>"local"</code> or <code>"seff"</code>. Currently only
<code>"sir"</code> and <code>"phd"</code> are available.</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_ndr">ndr</code></td>
<td>
<p>The number of directions</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_b.initial">B.initial</code></td>
<td>
<p>Initial <code>B</code> values. If specified, must be a matrix with
<code>ncol(x)</code> rows and <code>ndr</code> columns. Will be processed by
Gram-Schmidt if not orthogonal. If the initial value is
not given, three initial values (<code>"sir"</code>, <code>"save"</code> and
<code>"phd"</code>) using the traditional method will be tested. The
one with smallest l2 norm of the estimating equation will
be used.</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variables have unit
variance</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_keep.data">keep.data</code></td>
<td>
<p>Should the original data be kept for prediction. Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_control">control</code></td>
<td>
<p>A list of tuning variables for optimization.
<code>epsilon</code> is the size for numerically approximating the
gradient. For others, see Wen and Yin (2013).</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="orthoDr_reg_+3A_ncore">ncore</code></td>
<td>
<p>Number of cores for parallel computing.
The default is the maximum number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>orthoDr</code> object consisting of <code>list</code> with named elements:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The optimal <code>B</code> value</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>The final functional value</p>
</td></tr>
<tr><td><code>itr</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>convergence code</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2012). A semiparametric approach to dimension reduction. Journal of the American Statistical Association, 107(497), 168-179.
DOI: <a href="https://doi.org/10.1080/01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>
</p>
<p>Ma, Y., &amp; Zhu, L. (2013). Efficient estimation in sufficient dimension reduction. Annals of statistics, 41(1), 250.
DOI: <a href="https://doi.org/10.1214/12-AOS1072">doi:10.1214/12-AOS1072</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some regression data
set.seed(1)
N &lt;- 100
P &lt;- 4
dataX &lt;- matrix(rnorm(N * P), N, P)
Y &lt;- -1 + dataX[, 1] + rnorm(N)

# fit the semi-sir model
orthoDr_reg(dataX, Y, ndr = 1, method = "sir")

# fit the semi-phd model
Y &lt;- -1 + dataX[, 1]^2 + rnorm(N)
orthoDr_reg(dataX, Y, ndr = 1, method = "phd")
</code></pre>

<hr>
<h2 id='orthoDr_surv'>Counting Process based semiparametric dimension reduction (IR-CP) model</h2><span id='topic+orthoDr_surv'></span>

<h3>Description</h3>

<p>Models the data according to the counting process based semiparametric
dimension reduction (IR-CP) model for right censored survival outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoDr_surv(
  x,
  y,
  censor,
  method = "dm",
  ndr = ifelse(method == "forward", 1, 2),
  B.initial = NULL,
  bw = NULL,
  keep.data = FALSE,
  control = list(),
  maxitr = 500,
  verbose = FALSE,
  ncore = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthoDr_surv_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> for features.
The algorithm will not scale the columns to unit variance</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_y">y</code></td>
<td>
<p>A <code>vector</code> of observed time</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_censor">censor</code></td>
<td>
<p>A <code>vector</code> of censoring indicator</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_method">method</code></td>
<td>
<p>Estimation equation to use. Either:
<code>"forward"</code> (1-d model), <code>"dn"</code> (counting process), or
<code>"dm"</code> (martingale).</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_ndr">ndr</code></td>
<td>
<p>The number of directions</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_b.initial">B.initial</code></td>
<td>
<p>Initial <code>B</code> values. Will use the counting process based
SIR model <a href="#topic+CP_SIR">CP_SIR</a> as the initial if
leaving as <code>NULL</code>. If specified, must be a matrix with
<code>ncol(x)</code> rows and <code>ndr</code> columns. Will be processed by
Gram-Schmidt if not orthogonal.</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variables have
unit variance.</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_keep.data">keep.data</code></td>
<td>
<p>Should the original data be kept for prediction.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_control">control</code></td>
<td>
<p>A list of tuning variables for optimization. <code>epsilon</code> is
the size for numerically approximating the gradient.
For others, see Wen and Yin (2013).</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="orthoDr_surv_+3A_ncore">ncore</code></td>
<td>
<p>Number of cores for parallel computing.
The default is the maximum number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>orthoDr</code> object consisting of <code>list</code> with named elements:
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The optimal <code>B</code> value</p>
</td></tr>
<tr><td><code>fn</code></td>
<td>
<p>The final functional value</p>
</td></tr>
<tr><td><code>itr</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>convergence code</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T., &amp; Zeng, D. (2019). Counting process-based dimension reduction methods for censored outcomes. Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is setting 1 in Sun et. al. (2017) with reduced sample size
library(MASS)
set.seed(1)
N &lt;- 200
P &lt;- 6
V &lt;- 0.5^abs(outer(1:P, 1:P, "-"))
dataX &lt;- as.matrix(mvrnorm(N, mu = rep(0, P), Sigma = V))
failEDR &lt;- as.matrix(c(1, 0.5, 0, 0, 0, rep(0, P - 5)))
censorEDR &lt;- as.matrix(c(0, 0, 0, 1, 1, rep(0, P - 5)))
T &lt;- rexp(N, exp(dataX %*% failEDR))
C &lt;- rexp(N, exp(dataX %*% censorEDR - 1))
ndr &lt;- 1
Y &lt;- pmin(T, C)
Censor &lt;- (T &lt; C)

# fit the model
forward.fit &lt;- orthoDr_surv(dataX, Y, Censor, method = "forward")
distance(failEDR, forward.fit$B, "dist")

dn.fit &lt;- orthoDr_surv(dataX, Y, Censor, method = "dn", ndr = ndr)
distance(failEDR, dn.fit$B, "dist")

dm.fit &lt;- orthoDr_surv(dataX, Y, Censor, method = "dm", ndr = ndr)
distance(failEDR, dm.fit$B, "dist")
</code></pre>

<hr>
<h2 id='pdose_direct_solver'>pdose_direct_solver</h2><span id='topic+pdose_direct_solver'></span>

<h3>Description</h3>

<p>The direct learning optimization function for personalized dose finding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdose_direct_solver(
  B,
  X,
  A,
  a_dist,
  a_seq,
  R,
  lambda,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdose_direct_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_x">X</code></td>
<td>
<p>The covariate matrix</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_a">A</code></td>
<td>
<p>observed dose levels</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_a_dist">a_dist</code></td>
<td>
<p>A kernel distance matrix for the observed dose and girds of the dose levels</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_a_seq">a_seq</code></td>
<td>
<p>A grid of dose levels</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_r">R</code></td>
<td>
<p>The perosnalzied medicine reward</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_lambda">lambda</code></td>
<td>
<p>The penalty for the GCV for the kernel ridge regression</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variable have unit variance</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Estimation equation 2-norm tolerance level</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="pdose_direct_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimizer <code>B</code> for the esitmating equation.
</p>


<h3>References</h3>

<p>Zhou, W., Zhu, R., &amp; Zeng, D. (2021). A parsimonious personalized dose-finding model via dimension reduction.
Biometrika, 108(3), 643-659.
DOI: <a href="https://doi.org/10.1093/biomet/asaa087">doi:10.1093/biomet/asaa087</a>
</p>

<hr>
<h2 id='pdose_semi_solver'>pdose_semi_solver</h2><span id='topic+pdose_semi_solver'></span>

<h3>Description</h3>

<p>The pseudo direct learning optimization function for personalized dose finding with dimension reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdose_semi_solver(
  B,
  X,
  R,
  A,
  a_dist,
  a_seq,
  lambda,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdose_semi_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_x">X</code></td>
<td>
<p>The covariate matrix</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_r">R</code></td>
<td>
<p>The perosnalzied medicine reward</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_a">A</code></td>
<td>
<p>observed dose levels</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_a_dist">a_dist</code></td>
<td>
<p>A kernel distance matrix for the observed dose and girds of the dose levels</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_a_seq">a_seq</code></td>
<td>
<p>A grid of dose levels</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_lambda">lambda</code></td>
<td>
<p>The penalty for the GCV for the kernel ridge regression</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth, assuming each variable have unit variance</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Estimation equation 2-norm tolerance level</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="pdose_semi_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimizer <code>B</code> for the esitmating equation.
</p>


<h3>References</h3>

<p>Zhou, W., Zhu, R., &amp; Zeng, D. (2021). A parsimonious personalized dose-finding model via dimension reduction.
Biometrika, 108(3), 643-659.
DOI: <a href="https://doi.org/10.1093/biomet/asaa087">doi:10.1093/biomet/asaa087</a>
</p>

<hr>
<h2 id='phd_init'>phd_init</h2><span id='topic+phd_init'></span>

<h3>Description</h3>

<p>phd initial value function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phd_init(B, X, Y, bw, ncore)
</code></pre>

<hr>
<h2 id='phd_solver'>semi-phd solver <code>C++</code> function</h2><span id='topic+phd_solver'></span>

<h3>Description</h3>

<p>Sovling the semi-phd estimating equations. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phd_solver(
  B,
  X,
  Y,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phd_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_x">X</code></td>
<td>
<p>A matrix of the parameters <code>X</code></p>
</td></tr>
<tr><td><code id="phd_solver_+3A_y">Y</code></td>
<td>
<p>A matrix of the parameters <code>Y</code></p>
</td></tr>
<tr><td><code id="phd_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for apprximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="phd_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2012). A semiparametric approach to dimension reduction.
Journal of the American Statistical Association, 107(497), 168-179.
DOI: <a href="https://doi.org/10.1080/01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>
</p>

<hr>
<h2 id='predict.orthoDr'>Predictions under <code>orthoDr</code> models</h2><span id='topic+predict.orthoDr'></span>

<h3>Description</h3>

<p>The prediction function for <code>orthoDr</code> fitted models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthoDr'
predict(object, testx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.orthoDr_+3A_object">object</code></td>
<td>
<p>A fitted <code>orthoDr</code> object</p>
</td></tr>
<tr><td><code id="predict.orthoDr_+3A_testx">testx</code></td>
<td>
<p>Testing data</p>
</td></tr>
<tr><td><code id="predict.orthoDr_+3A_...">...</code></td>
<td>
<p>Additional parameters, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predicted object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some survival data
N &lt;- 100
P &lt;- 4
dataX &lt;- matrix(rnorm(N * P), N, P)
Y &lt;- exp(-1 + dataX[, 1] + rnorm(N))
Censor &lt;- rbinom(N, 1, 0.8)

# fit the model with keep.data = TRUE
orthoDr.fit &lt;- orthoDr_surv(dataX, Y, Censor,
  ndr = 1,
  method = "dm", keep.data = TRUE
)

# predict 10 new observations
predict(orthoDr.fit, matrix(rnorm(10 * P), 10, P))

# generate some personalized dose scenario

exampleset &lt;- function(size, ncov) {
  X &lt;- matrix(runif(size * ncov, -1, 1), ncol = ncov)
  A &lt;- runif(size, 0, 2)

  Edr &lt;- as.matrix(c(0.5, -0.5))

  D_opt &lt;- X %*% Edr + 1

  mu &lt;- 2 + 0.5 * (X %*% Edr) - 7 * abs(D_opt - A)

  R &lt;- rnorm(length(mu), mu, 1)

  R &lt;- R - min(R)

  datainfo &lt;- list(X = X, A = A, R = R, D_opt = D_opt, mu = mu)
  return(datainfo)
}

# generate data

set.seed(123)
n &lt;- 150
p &lt;- 2
ndr &lt;- 1
train &lt;- exampleset(n, p)
test &lt;- exampleset(500, p)

# the direct learning method
orthofit &lt;- orthoDr_pdose(train$X, train$A, train$R,
  ndr = ndr, lambda = 0.1,
  method = "direct", K = as.integer(sqrt(n)), keep.data = TRUE,
  maxitr = 150, verbose = FALSE, ncore = 2
)

predict(orthofit, test$X)

# the pseudo direct learning method
orthofit &lt;- orthoDr_pdose(train$X, train$A, train$R,
  ndr = ndr, lambda = seq(0.1, 0.2, 0.01),
  method = "pseudo_direct", K = as.integer(sqrt(n)), keep.data = TRUE,
  maxitr = 150, verbose = FALSE, ncore = 2
)

predict(orthofit, test$X)
</code></pre>

<hr>
<h2 id='print.orthoDr'>Print a <code>orthoDr</code> object</h2><span id='topic+print.orthoDr'></span>

<h3>Description</h3>

<p>Provides a custom print wrapper for displaying <code>orthoDr</code> fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthoDr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.orthoDr_+3A_x">x</code></td>
<td>
<p>A fitted <code>orthoDr</code> object</p>
</td></tr>
<tr><td><code id="print.orthoDr_+3A_...">...</code></td>
<td>
<p>Additional parameters, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sliently returns the <code>orthoDr</code> object supplied into the function to
allow for use with pipes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some survival data
N &lt;- 100
P &lt;- 4
dataX &lt;- matrix(rnorm(N * P), N, P)
Y &lt;- exp(-1 + dataX[, 1] + rnorm(N))
Censor &lt;- rbinom(N, 1, 0.8)

# fit the model
orthoDr_surv(dataX, Y, Censor, ndr = 1, method = "dm")
</code></pre>

<hr>
<h2 id='pSAVE'>Partial Sliced Averaged Variance Estimation</h2><span id='topic+pSAVE'></span>

<h3>Description</h3>

<p>The partial-SAVE model. This model is correct only under very strong
assumptions, the solution is used as the initial value in the <code>orthoDr</code>
optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pSAVE(x, a, r, ndr = 2, nslices0 = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pSAVE_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> for features (continuous only).</p>
</td></tr>
<tr><td><code id="pSAVE_+3A_a">a</code></td>
<td>
<p>A <code>vector</code> of observed dose levels (continuous only).</p>
</td></tr>
<tr><td><code id="pSAVE_+3A_r">r</code></td>
<td>
<p>A <code>vector</code> of reward (outcome).</p>
</td></tr>
<tr><td><code id="pSAVE_+3A_ndr">ndr</code></td>
<td>
<p>The dimension structure</p>
</td></tr>
<tr><td><code id="pSAVE_+3A_nslices0">nslices0</code></td>
<td>
<p>Number of slides used for save</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> consisting of:
</p>
<table role = "presentation">
<tr><td><code>vectors</code></td>
<td>
<p>The basis of central subspace, ordered by eigenvalues</p>
</td></tr>
</table>


<h3>References</h3>

<p>Feng, Z., Wen, X. M., Yu, Z., &amp; Zhu, L. (2013). On partial sufficient dimension reduction with applications to partially linear multi-index models.
Journal of the American Statistical Association, 108(501), 237-246.
DOI: <a href="https://doi.org/10.1080/01621459.2012.746065">doi:10.1080/01621459.2012.746065</a>
</p>

<hr>
<h2 id='reg_init'>reg_init</h2><span id='topic+reg_init'></span>

<h3>Description</h3>

<p>regression initiation function to get better initial value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_init(method, ...)
</code></pre>

<hr>
<h2 id='reg_solve'>reg_solve</h2><span id='topic+reg_solve'></span><span id='topic+reg_solver'></span>

<h3>Description</h3>

<p>regression solver switch function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_solver(method, ...)
</code></pre>

<hr>
<h2 id='save_init'>save_init</h2><span id='topic+save_init'></span>

<h3>Description</h3>

<p>save initial value function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_init(B, X, Y, bw, ncore)
</code></pre>

<hr>
<h2 id='save_solver'>semi-save solver <code>C++</code> function</h2><span id='topic+save_solver'></span>

<h3>Description</h3>

<p>Sovling the semi-save estimating equations. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_solver(
  B,
  X,
  Y,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="save_solver_+3A_x">X</code></td>
<td>
<p>A matrix of the parameters <code>X</code></p>
</td></tr>
<tr><td><code id="save_solver_+3A_y">Y</code></td>
<td>
<p>A matrix of the parameters <code>Y</code></p>
</td></tr>
<tr><td><code id="save_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="save_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="save_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="save_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="save_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="save_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for apprximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="save_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="save_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="save_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="save_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="save_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2012). A semiparametric approach to dimension reduction.
Journal of the American Statistical Association, 107(497), 168-179.
DOI: <a href="https://doi.org/10.1080/01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>
</p>

<hr>
<h2 id='seff_init'>seff_init</h2><span id='topic+seff_init'></span>

<h3>Description</h3>

<p>semiparametric efficient method initial value function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seff_init(B, X, Y, bw, ncore)
</code></pre>

<hr>
<h2 id='seff_solver'>Eff semi regression solver <code>C++</code> function</h2><span id='topic+seff_solver'></span>

<h3>Description</h3>

<p>Sovling the semiparametric efficient estimating equations. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seff_solver(
  B,
  X,
  Y,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seff_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_x">X</code></td>
<td>
<p>A matrix of the parameters <code>X</code></p>
</td></tr>
<tr><td><code id="seff_solver_+3A_y">Y</code></td>
<td>
<p>A matrix of the parameters <code>Y</code></p>
</td></tr>
<tr><td><code id="seff_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for apprximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="seff_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2013). Efficient estimation in sufficient dimension reduction.
Annals of statistics, 41(1), 250.
DOI: <a href="https://doi.org/10.1214/12-AOS1072">doi:10.1214/12-AOS1072</a>
</p>

<hr>
<h2 id='silverman'>Silverman's rule of thumb</h2><span id='topic+silverman'></span>

<h3>Description</h3>

<p>A simple Silverman's rule of thumb bandwidth calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silverman(d, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silverman_+3A_d">d</code></td>
<td>
<p>Number of dimension</p>
</td></tr>
<tr><td><code id="silverman_+3A_n">n</code></td>
<td>
<p>Number of observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple bandwidth choice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>silverman(1, 300)
</code></pre>

<hr>
<h2 id='sir_init'>sir_init</h2><span id='topic+sir_init'></span>

<h3>Description</h3>

<p>sir initial value function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir_init(B, X, Y, bw, ncore)
</code></pre>

<hr>
<h2 id='sir_solver'>semi-sir solver <code>C++</code> function</h2><span id='topic+sir_solver'></span>

<h3>Description</h3>

<p>Sovling the semi-sir estimating equations. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir_solver(
  B,
  X,
  Y,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sir_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_x">X</code></td>
<td>
<p>A matrix of the parameters <code>X</code></p>
</td></tr>
<tr><td><code id="sir_solver_+3A_y">Y</code></td>
<td>
<p>A matrix of the parameters <code>Y</code></p>
</td></tr>
<tr><td><code id="sir_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for apprximating numerical gradient, if <code>g</code> is not given.</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Functional value tolerance level</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="sir_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, Y., &amp; Zhu, L. (2012). A semiparametric approach to dimension reduction.
Journal of the American Statistical Association, 107(497), 168-179.
DOI: <a href="https://doi.org/10.1080/01621459.2011.646925">doi:10.1080/01621459.2011.646925</a>
</p>

<hr>
<h2 id='skcm.clinical'>Skin Cutaneous Melanoma Data set</h2><span id='topic+skcm.clinical'></span>

<h3>Description</h3>

<p>The clinical variables of the SKCM dataset.
The original data was obtained from The Cancer Genome Atlas (TCGA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skcm.clinical
</code></pre>


<h3>Format</h3>

<p>Contains 469 subjects with 156 failures. Each row contains one subject,
subject ID is indicated by row name. Variables include:
</p>

<ul>
<li> <p><code>Time</code>
</p>
</li>
<li> <p><code>Censor</code>
</p>
</li>
<li> <p><code>Gender</code>
</p>
</li>
<li> <p><code>Age</code>
</p>
</li></ul>

<p><strong>Note:</strong> <code>Age</code> has 8 missing values.
</p>


<h3>References</h3>

<p><a href="https://www.cancer.gov/ccg/research/genome-sequencing/tcga">https://www.cancer.gov/ccg/research/genome-sequencing/tcga</a>
</p>

<hr>
<h2 id='skcm.melgene'>Genes associated with Melanoma given by the MelGene Database</h2><span id='topic+skcm.melgene'></span>

<h3>Description</h3>

<p>The expression of top 20 genes of cutaneous melanoma literature based on the
MelGene Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skcm.melgene
</code></pre>


<h3>Format</h3>

<p>Each row contains one subject, subject ID is indicated by row name.
Gene names in the columns. The columns are scaled.
</p>


<h3>References</h3>

<p>Chatzinasiou, Foteini, Christina M. Lill, Katerina Kypreou, Irene Stefanaki, Vasiliki Nicolaou, George Spyrou, Evangelos Evangelou et al. &quot;Comprehensive field synopsis and systematic meta-analyses of genetic association studies in cutaneous melanoma.&quot; Journal of the National Cancer Institute 103, no. 16 (2011): 1227-1235.
Emmanouil I. Athanasiadis, Kyriaki Antonopoulou, Foteini Chatzinasiou, Christina M. Lill, Marilena M. Bourdakou, Argiris Sakellariou, Katerina Kypreou, Irene Stefanaki, Evangelos Evangelou, John P.A. Ioannidis, Lars Bertram, Alexander J. Stratigos, George M. Spyrou, A Web-based database of genetic association studies in cutaneous melanoma enhanced with network-driven data exploration tools, Database, Volume 2014, 2014, bau101, https://doi.org/10.1093/database/bau101
<a href="https://www.cancer.gov/ccg/research/genome-sequencing/tcga">https://www.cancer.gov/ccg/research/genome-sequencing/tcga</a>
</p>

<hr>
<h2 id='surv_dm_solver'>surv_dm_solver <code>C++</code> function</h2><span id='topic+surv_dm_solver'></span>

<h3>Description</h3>

<p>The main optimization function for survival dimensional reduction, the IR-Semi method. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_dm_solver(
  B,
  X,
  Phit,
  Fail_Ind,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_dm_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_x">X</code></td>
<td>
<p>The covariate matrix (This matrix is ordered by the order of Y for faster computation)</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_phit">Phit</code></td>
<td>
<p>Phit as defined in Sun et al. (2017)</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_fail_ind">Fail_Ind</code></td>
<td>
<p>The locations of the failure subjects</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Estimation equation 2-norm tolerance level</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="surv_dm_solver_+3A_ncore">ncore</code></td>
<td>
<p>The number of cores for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimizer <code>B</code> for the estimating equation.
</p>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T., &amp; Zeng, D. (2019). Counting process-based dimension reduction methods for censored outcomes.
Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function should be called internally. When having all objects pre-computed, one can call
# surv_solver(B, X, Phit, Fail.Ind,
#             rho, eta, gamma, tau, epsilon, btol, ftol, gtol, maxitr, verbose)
# to solve for the parameters B.

</code></pre>

<hr>
<h2 id='surv_dn_solver'>surv_dn_solver <code>C++</code> function</h2><span id='topic+surv_dn_solver'></span>

<h3>Description</h3>

<p>The main optimization function for survival dimensional reduction, the IR-CP method. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_dn_solver(
  B,
  X,
  Phit,
  Fail_Ind,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_dn_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_x">X</code></td>
<td>
<p>The covariate matrix (This matrix is ordered by the order of Y for faster computation)</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_phit">Phit</code></td>
<td>
<p>Phit as defined in Sun et al. (2017)</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_fail_ind">Fail_Ind</code></td>
<td>
<p>The locations of the failure subjects</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Estimation equation 2-norm tolerance level</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="surv_dn_solver_+3A_ncore">ncore</code></td>
<td>
<p>The number of cores for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimizer <code>B</code> for the estimating equation.
</p>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T., &amp; Zeng, D. (2019). Counting process-based dimension reduction methods for censored outcomes.
Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function should be called internally. When having all objects pre-computed, one can call
# surv_solver(B, X, Phit, Fail.Ind,
#             rho, eta, gamma, tau, epsilon, btol, ftol, gtol, maxitr, verbose)
# to solve for the parameters B.

</code></pre>

<hr>
<h2 id='surv_forward_solver'>surv_forward_solver <code>C++</code> function</h2><span id='topic+surv_forward_solver'></span>

<h3>Description</h3>

<p>The main optimization function for survival dimensional reduction, the forward method. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_forward_solver(
  B,
  X,
  Fail_Ind,
  bw,
  rho,
  eta,
  gamma,
  tau,
  epsilon,
  btol,
  ftol,
  gtol,
  maxitr,
  verbose,
  ncore
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv_forward_solver_+3A_b">B</code></td>
<td>
<p>A matrix of the parameters <code>B</code>, the columns are subject to the orthogonality constraint</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_x">X</code></td>
<td>
<p>The covariate matrix (This matrix is ordered by the order of Y for faster computation)</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_fail_ind">Fail_Ind</code></td>
<td>
<p>The locations of the failure subjects</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_bw">bw</code></td>
<td>
<p>Kernel bandwidth for X</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_rho">rho</code></td>
<td>
<p>(don't change) Parameter for control the linear approximation in line search</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_eta">eta</code></td>
<td>
<p>(don't change) Factor for decreasing the step size in the backtracking line search</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_gamma">gamma</code></td>
<td>
<p>(don't change) Parameter for updating C by Zhang and Hager (2004)</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_tau">tau</code></td>
<td>
<p>(don't change) Step size for updating</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_epsilon">epsilon</code></td>
<td>
<p>(don't change) Parameter for approximating numerical gradient</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_btol">btol</code></td>
<td>
<p>(don't change) The <code>$B$</code> parameter tolerance level</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_ftol">ftol</code></td>
<td>
<p>(don't change) Estimation equation 2-norm tolerance level</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_gtol">gtol</code></td>
<td>
<p>(don't change) Gradient tolerance level</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_verbose">verbose</code></td>
<td>
<p>Should information be displayed</p>
</td></tr>
<tr><td><code id="surv_forward_solver_+3A_ncore">ncore</code></td>
<td>
<p>The number of cores for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimizer <code>B</code> for the esitmating equation.
</p>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T., &amp; Zeng, D. (2019). Counting process-based dimension reduction methods for censored outcomes.
Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function should be called internally. When having all objects pre-computed, one can call
# surv_forward_solver(B, X, Fail.Ind, bw,
#                     rho, eta, gamma, tau, epsilon, btol, ftol, gtol, maxitr, verbose)
# to solve for the parameters B.

</code></pre>

<hr>
<h2 id='view_dr_surv'>2D or 2D view of survival data on reduced dimension</h2><span id='topic+view_dr_surv'></span>

<h3>Description</h3>

<p>Produce 2D or 3D plots of right censored survival data based on a given
dimension reduction space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view_dr_surv(
  x,
  y,
  censor,
  B = NULL,
  bw = NULL,
  FUN = "log",
  type = "2D",
  legend.add = TRUE,
  xlab = "Reduced Direction",
  ylab = "Time",
  zlab = "Survival"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="view_dr_surv_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> for features (continuous only).
The algorithm will not scale the columns to unit variance</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_y">y</code></td>
<td>
<p>A <code>vector</code> of observed time</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_censor">censor</code></td>
<td>
<p>A <code>vector</code> of censoring indicator</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_b">B</code></td>
<td>
<p>The dimension reduction subspace, can only be 1 dimensional</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_bw">bw</code></td>
<td>
<p>A Kernel bandwidth (3D plot only) for approximating the
survival function, default is the Silverman's formula</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_fun">FUN</code></td>
<td>
<p>A scaling function applied to the time points <code>y</code>.
Default is <code>"log"</code>.</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;2D&#8288;</code> or <code style="white-space: pre;">&#8288;3D&#8288;</code> plot</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_legend.add">legend.add</code></td>
<td>
<p>Should legend be added (2D plot only)</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="view_dr_surv_+3A_zlab">zlab</code></td>
<td>
<p>z axis label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rgl</code> object that is rendered.
</p>


<h3>References</h3>

<p>Sun, Q., Zhu, R., Wang, T., &amp; Zeng, D. (2019). Counting process-based dimension reduction methods for censored outcomes. Biometrika, 106(1), 181-196.
DOI: <a href="https://doi.org/10.1093/biomet/asy064">doi:10.1093/biomet/asy064</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some survival data
N &lt;- 100
P &lt;- 4
dataX &lt;- matrix(rnorm(N * P), N, P)
Y &lt;- exp(-1 + dataX[, 1] + rnorm(N))
Censor &lt;- rbinom(N, 1, 0.8)

orthoDr.fit &lt;- orthoDr_surv(dataX, Y, Censor, ndr = 1, method = "dm")
view_dr_surv(dataX, Y, Censor, orthoDr.fit$B)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
