<!DOCTYPE html><html><head><title>Help for package ghql</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ghql}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Fragment'><p>Fragment</p></a></li>
<li><a href='#ghql-package'><p>ghql</p></a></li>
<li><a href='#GraphqlClient'><p>GraphqlClient</p></a></li>
<li><a href='#Query'><p>Query</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General Purpose 'GraphQL' Client</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'GraphQL' client, with an R6 interface for initializing
    a connection to a 'GraphQL' instance, and methods for constructing
    queries, including fragments and parameterized queries. Queries
    are checked with the 'libgraphqlparser' C++ parser via the
    'gaphql' package.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/ghql">https://github.com/ropensci/ghql</a> (devel)
<a href="https://docs.ropensci.org/ghql">https://docs.ropensci.org/ghql</a> (docs)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/ghql/issues">https://github.com/ropensci/ghql/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>crul, jsonlite, R6, graphql</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Web</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>http, API, web-services, curl, data, GraphQL</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-24 18:13:41 UTC; sckott</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Chamberlain &lt;myrmecocystus@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-04 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='Fragment'>Fragment</h2><span id='topic+Fragment'></span>

<h3>Description</h3>

<p>ghql fragment class
</p>


<h3>Value</h3>

<p>a 'Fragment' class (R6 class)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>fragments</code></dt><dd><p>(list) list of fragments</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-print"><code>Fragment$print()</code></a>
</p>
</li>
<li> <p><a href="#method-fragment"><code>Fragment$fragment()</code></a>
</p>
</li></ul>


<hr>
<a id="method-print"></a>


<h4>Method <code>print()</code></h4>

<p>print method for the 'Fragment' class
</p>


<h5>Usage</h5>

<div class="r"><pre>Fragment$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-fragment"></a>


<h4>Method <code>fragment()</code></h4>

<p>create a fragment by name
</p>


<h5>Usage</h5>

<div class="r"><pre>Fragment$fragment(name, x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>(character) fragment name</p>
</dd>
<dt><code>x</code></dt><dd><p>(character) the fragment</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets fragments internally
</p>




<h3>Examples</h3>

<pre><code class='language-R'># make a fragment class
frag &lt;- Fragment$new()

# define a fragment
frag$fragment('Watchers', '
  fragment on Repository {
    watchers(first: 3) {
      edges {
        node {
          name
       }
    }
  }
}')

# define another fragment
frag$fragment('Stargazers', '
  fragment on Repository {
    stargazers(first: 3) {
      edges {
        node {
          name
       }
    }
  }
}')
frag
frag$fragments
frag$fragments$Watchers
frag$fragments$Stargazers
</code></pre>

<hr>
<h2 id='ghql-package'>ghql</h2><span id='topic+ghql-package'></span><span id='topic+ghql'></span>

<h3>Description</h3>

<p>General purpose GraphQL client
</p>


<h3>ghql API</h3>

<p>The main interface in this package is [GraphqlClient], which produces
a client (R6 class) with various methods for interacting with a
GraphQL server. [GraphqlClient] also accepts various input parameters
to set a base URL, and any headers required, which is usually the required
set of things needed to connect to a GraphQL service.
</p>
<p>[Query] is an interface to creating GraphQL queries,
which works together with [GraphqlClient]
</p>
<p>[Fragment] is an interface to creating GraphQL fragments,
which works together with [GraphqlClient]
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus@gmail.com">myrmecocystus@gmail.com</a>
</p>

<hr>
<h2 id='GraphqlClient'>GraphqlClient</h2><span id='topic+GraphqlClient'></span>

<h3>Description</h3>

<p>R6 class for constructing GraphQL queries
</p>


<h3>Value</h3>

<p>a 'GraphqlClient' class (R6 class)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt><dd><p>(character) list of fragments</p>
</dd>
<dt><code>headers</code></dt><dd><p>list of named headers</p>
</dd>
<dt><code>schema</code></dt><dd><p>holds schema</p>
</dd>
<dt><code>result</code></dt><dd><p>holds result from http request</p>
</dd>
<dt><code>fragments</code></dt><dd><p>(list) list of fragments</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>GraphqlClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>GraphqlClient$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ping"><code>GraphqlClient$ping()</code></a>
</p>
</li>
<li> <p><a href="#method-load_schema"><code>GraphqlClient$load_schema()</code></a>
</p>
</li>
<li> <p><a href="#method-dump_schema"><code>GraphqlClient$dump_schema()</code></a>
</p>
</li>
<li> <p><a href="#method-schema2json"><code>GraphqlClient$schema2json()</code></a>
</p>
</li>
<li> <p><a href="#method-fragment"><code>GraphqlClient$fragment()</code></a>
</p>
</li>
<li> <p><a href="#method-exec"><code>GraphqlClient$exec()</code></a>
</p>
</li>
<li> <p><a href="#method-prep_query"><code>GraphqlClient$prep_query()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>


<h4>Method <code>new()</code></h4>

<p>Create a new 'GraphqlClient' object
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$new(url, headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>(character) URL for the GraphQL schema</p>
</dd>
<dt><code>headers</code></dt><dd><p>Any acceptable headers, a named list. See examples</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'GraphqlClient' object
</p>


<hr>
<a id="method-print"></a>


<h4>Method <code>print()</code></h4>

<p>print method for the 'GraphqlClient' class
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ping"></a>


<h4>Method <code>ping()</code></h4>

<p>ping the GraphQL server
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$ping(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>curl options passed on to [crul::verb-HEAD]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>'TRUE' if successful response, 'FALSE' otherwise
</p>


<hr>
<a id="method-load_schema"></a>


<h4>Method <code>load_schema()</code></h4>

<p>load schema, from URL or local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$load_schema(schema_url = NULL, schema_file = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>schema_url</code></dt><dd><p>(character) url for a schema file</p>
</dd>
<dt><code>schema_file</code></dt><dd><p>(character) path to a schema file</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options passed on to [crul::verb-GET]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing, loads schema into '$schema' slot
</p>


<hr>
<a id="method-dump_schema"></a>


<h4>Method <code>dump_schema()</code></h4>

<p>dump schema to a local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$dump_schema(file)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>(character) path to a file</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing, writes schema to 'file'
</p>


<hr>
<a id="method-schema2json"></a>


<h4>Method <code>schema2json()</code></h4>

<p>convert schema to JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$schema2json(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>options passed on to [jsonlite::toJSON()]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>json
</p>


<hr>
<a id="method-fragment"></a>


<h4>Method <code>fragment()</code></h4>

<p>load schema, from URL or local file
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$fragment(name, x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>(character) fragment name</p>
</dd>
<dt><code>x</code></dt><dd><p>(character) the fragment</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets fragments internally
</p>


<hr>
<a id="method-exec"></a>


<h4>Method <code>exec()</code></h4>

<p>execute the query
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$exec(query, variables, encoding = "UTF-8", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>(character) a query, of class 'query' or 'fragment'</p>
</dd>
<dt><code>variables</code></dt><dd><p>(list) named list with query variables values</p>
</dd>
<dt><code>encoding</code></dt><dd><p>(character) encoding to use to parse the response. passed
on to [crul::HttpResponse] '$parse()' method. default: &quot;UTF-8&quot;</p>
</dd>
<dt><code>...</code></dt><dd><p>curl options passed on to [crul::verb-POST]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character string of response, if successful
</p>


<hr>
<a id="method-prep_query"></a>


<h4>Method <code>prep_query()</code></h4>

<p>not used right now
</p>


<h5>Usage</h5>

<div class="r"><pre>GraphqlClient$prep_query(query)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>(character) a query, of class 'query' or 'fragment'</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- GraphqlClient$new()
x

## Not run: 
# make a client
token &lt;- Sys.getenv("GITHUB_GRAPHQL_TOKEN")
cli &lt;- GraphqlClient$new(
  url = "https://api.github.com/graphql",
  headers = list(Authorization = paste0("Bearer ", token))
)

# if the GraphQL server has a schema, you can load it
cli$load_schema()

# dump schema to local file
f &lt;- tempfile(fileext = ".json")
cli$dump_schema(file = f)
readLines(f)
jsonlite::fromJSON(readLines(f))

# after dumping to file, you can later read schema from file for faster loading
rm(cli)
cli &lt;- GraphqlClient$new(
  url = "https://api.github.com/graphql",
  headers = list(Authorization = paste0("Bearer ", token))
)
cli$load_schema(schema_file = f)

# variables
cli$url
cli$schema
cli$schema$data
cli$schema$data$`__schema`
cli$schema$data$`__schema`$queryType
cli$schema$data$`__schema`$mutationType
cli$schema$data$`__schema`$subscriptionType
head(cli$schema$data$`__schema`$types)
cli$schema$data$`__schema`$directives


# methods
## ping - hopefully you get TRUE
cli$ping()

## dump schema
cli$schema2json()


## define query
### creat a query class first
qry &lt;- Query$new()
## another
qry$query('repos', '{
  viewer {
    repositories(last: 10, isFork: false, privacy: PUBLIC) {
      edges {
        node {
          isPrivate
          id
          name
        }
      }
    }
  }
}')
qry
qry$queries
qry$queries$repos
### execute the query
cli$exec(qry$queries$repos)


# query with a fragment
### define query without fragment, but referring to it
qry &lt;- Query$new()
qry$query('queryfrag', '{
  ropensci: repositoryOwner(login:"ropensci") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
  ropenscilabs: repositoryOwner(login:"ropenscilabs") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
}')

### define a fragment
frag &lt;- Fragment$new()
frag$fragment('Watchers', '
  fragment on Repository {
    watchers(first: 3) {
      edges {
        node {
          name
       }
    }
  }
}')
frag$fragments
frag$fragments$Watchers

### add the fragment to the query 'queryfrag'
qry$add_fragment('queryfrag', frag$fragments$Watchers)
qry
qry$queries$queryfrag

### execute query: we'll hook together the query and your fragment internally
cli$exec(qry$queries$queryfrag)

## End(Not run)
</code></pre>

<hr>
<h2 id='Query'>Query</h2><span id='topic+Query'></span>

<h3>Description</h3>

<p>ghql query class
</p>


<h3>Value</h3>

<p>a 'Query' class (R6 class)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>queries</code></dt><dd><p>(list) list of queries</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-print"><code>Query$print()</code></a>
</p>
</li>
<li> <p><a href="#method-query"><code>Query$query()</code></a>
</p>
</li>
<li> <p><a href="#method-add_fragment"><code>Query$add_fragment()</code></a>
</p>
</li>
<li> <p><a href="#method-parse2json"><code>Query$parse2json()</code></a>
</p>
</li></ul>


<hr>
<a id="method-print"></a>


<h4>Method <code>print()</code></h4>

<p>print method for the 'Query' class
</p>


<h5>Usage</h5>

<div class="r"><pre>Query$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-query"></a>


<h4>Method <code>query()</code></h4>

<p>define query in a character string
</p>


<h5>Usage</h5>

<div class="r"><pre>Query$query(name, x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>(character) name of the query</p>
</dd>
<dt><code>x</code></dt><dd><p>(character) the query</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets query with 'name' internally
</p>


<hr>
<a id="method-add_fragment"></a>


<h4>Method <code>add_fragment()</code></h4>

<p>add a fragment to a query
</p>


<h5>Usage</h5>

<div class="r"><pre>Query$add_fragment(query_name, fragment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query_name</code></dt><dd><p>(character) the query name to add the fragment to</p>
</dd>
<dt><code>fragment</code></dt><dd><p>(character) the fragment itself</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets the fragment with the query
</p>


<hr>
<a id="method-parse2json"></a>


<h4>Method <code>parse2json()</code></h4>

<p>parse query string with libgraphqlparser and get back JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>Query$parse2json(query, parse_schema = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>(character) a query to parse</p>
</dd>
<dt><code>parse_schema</code></dt><dd><p>(logical) enable schema definition parsing?
default: 'FAlSE'</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>adf
</p>




<h3>Note</h3>

<p>we run an internal method 'check_query()' that runs the public
method &lsquo;parse2json()' - if the query doesn&rsquo;t pass the libgraphqlparser
parser, we return the error message
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a client
qry &lt;- Query$new()

## define query
qry$query('query2', '{
  viewer {
    repositories(last: 10, isFork: false, privacy: PUBLIC) {
      edges {
        node {
          isPrivate
          id
          name
        }
      }
    }
  }
}')
qry
qry$queries
qry$queries$query2

# fragments
## by hand
qry$query('querywithfrag', '{
  ropensci: repositoryOwner(login:"ropensci") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
  ropenscilabs: repositoryOwner(login:"ropenscilabs") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
}
fragment Watchers on Repository {
  watchers(first: 3) {
    edges {
      node {
        name
      }
    }
  }
}')
qry
qry$queries
qry$queries$querywithfrag


## Not run: 
token &lt;- Sys.getenv("GITHUB_GRAPHQL_TOKEN")
con &lt;- GraphqlClient$new(
  url = "https://api.github.com/graphql",
  headers = list(Authorization = paste0("Bearer ", token))
)
jsonlite::fromJSON(con$exec(qry$queries$querywithfrag))

## use Fragment class fragments generator
### define query without fragment, but referring to it
qry$query('queryfrag', '{
  ropensci: repositoryOwner(login:"ropensci") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
  ropenscilabs: repositoryOwner(login:"ropenscilabs") {
    repositories(first: 3) {
      edges {
        node {
          ...Watchers
        }
      }
    }
  }
}')

### define a fragment, and use it later
frag &lt;- Fragment$new()
frag$fragment('Watchers', '
  fragment on Repository {
    watchers(first: 3) {
      edges {
        node {
          name
       }
    }
  }
}')
frag$fragments
frag$fragments$Watchers

### add the fragment to the query 'queryfrag'
qry$add_fragment('queryfrag', frag$fragments$Watchers)
qry
qry$queries
qry$queries$queryfrag

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
