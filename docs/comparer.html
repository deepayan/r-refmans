<!DOCTYPE html><html><head><title>Help for package comparer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comparer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ffexp'><p>Full factorial experiment</p></a></li>
<li><a href='#hype'><p>Hyperparameter optimization</p></a></li>
<li><a href='#mbc'><p>Model benchmark compare</p></a></li>
<li><a href='#par_discretenum'><p>Parameter with uniform distribution for hyperparameter optimization</p></a></li>
<li><a href='#par_integer'><p>Parameter with uniform distribution over integer range</p>
for hyperparameter optimization</a></li>
<li><a href='#par_log10'><p>Hyperparameter on log10 scale</p></a></li>
<li><a href='#par_ordered'><p>Hyperparameter of discrete (factor) variable</p></a></li>
<li><a href='#par_unif'><p>Uniform parameter</p></a></li>
<li><a href='#par_unordered'><p>Hyperparameter of discrete (factor) variable</p></a></li>
<li><a href='#plot.mbc'><p>Plot mbc class</p></a></li>
<li><a href='#print.mbc'><p>Print mbc class</p></a></li>
<li><a href='#R6_hype'><p>Hyperparameter optimization</p></a></li>
<li><a href='#R6_par_discretenum'><p>R6 object for discrete numeric</p></a></li>
<li><a href='#R6_par_hype'><p>Parameter for hyperparameter optimization</p></a></li>
<li><a href='#R6_par_integer'><p>Parameter with uniform distribution over integer range</p>
for hyperparameter optimization</a></li>
<li><a href='#R6_par_log10'><p>R6 class for hyperparameter on log10 scale</p></a></li>
<li><a href='#R6_par_ordered'><p>R6 class for hyperparameter of discrete (factor) variable</p></a></li>
<li><a href='#R6_par_unif'><p>R6 class for Uniform parameter</p></a></li>
<li><a href='#R6_par_unordered'><p>R6 class for hyperparameter of discrete (factor) variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compare Output and Run Time</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Quickly run experiments to compare the run time and output of
    code blocks. The function mbc() can make fast comparisons of code,
    and will calculate statistics comparing the resulting outputs.
    It can be used to compare model fits to the same data or
    see which function runs faster.
    The R6 class ffexp$new() runs a function using all possible combinations
    of selected inputs. This is useful for comparing the effect of
    different parameter values. It can also run in parallel and
    automatically save intermediate results, which is very useful
    for long computations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plyr, progress, testthat (&ge; 2.1.0), covr, knitr, GauPro (&ge;
0.2.7), ggplot2, GGally, ggpubr, ContourFunctions, parallel,
snow, rmarkdown, reshape, tibble, lhs, DiceKriging, DiceOptim,
mixopt, reshape2, microbenchmark</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CollinErickson/comparer">https://github.com/CollinErickson/comparer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CollinErickson/comparer/issues">https://github.com/CollinErickson/comparer/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-18 18:22:10 UTC; colli</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Erickson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Erickson &lt;collinberickson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-19 23:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='ffexp'>Full factorial experiment</h2><span id='topic+ffexp'></span>

<h3>Description</h3>

<p>A class for easily creating and evaluating full factorial experiments.
</p>


<h3>Usage</h3>

<pre>
e1 &lt;- ffexp$new(eval_func=, )

e1$run_all()

e1$plot_run_times()

e1$save_self()

</pre>


<h3>Arguments</h3>

<p><code>eval_func</code> The function called to evaluate each design point.
</p>
<p><code>...</code> Factors and their levels to be evaluated at.
</p>
<p><code>save_output</code> Should the output be saved?
</p>
<p><code>parallel</code> If <code>TRUE</code>, function evaluations are done in parallel.
</p>
<p><code>parallel_cores</code> Number of cores to be used in parallel.
If <code>"detect"</code>, <code>parallel::detectCores()</code> is used to determine
number. <code>"detect-1"</code> may be used so that the computer isn't running
at full capacity, which can slow down other tasks.
</p>


<h3>Methods</h3>

<p><code>$new()</code> Initialize an experiment. The preprocessing is done,
but no function evaluations are run.
</p>
<p><code>$run_all()</code> Run all factor combinations.
</p>
<p><code>$run_one()</code> Run a single factor combination.
</p>
<p><code>$add_result_of_one()</code> Used to add result of evaluation to data set,
don't manually call.
</p>
<p><code>$plot_run_times()</code> Plot the run times. Especially useful when
they have been run in parallel.
</p>
<p><code>$save_self()</code> Save ffexp R6 object.
</p>
<p><code>$recover_parallel_temp_save()</code> If you ran the experiment using
parallel with <code>parallel_temp_save=TRUE</code> and it crashes partway
through, call this to recover the runs that were completed.
Runs that were stopped mid-execution are not recoverable.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>outrawdf</code></dt><dd><p>Raw data frame of output.</p>
</dd>
<dt><code>outcleandf</code></dt><dd><p>Clean output in data frame.</p>
</dd>
<dt><code>rungrid</code></dt><dd><p>matrix specifying which inputs will be run
for each experiment.</p>
</dd>
<dt><code>nvars</code></dt><dd><p>Number of variables</p>
</dd>
<dt><code>allvars</code></dt><dd><p>All variables</p>
</dd>
<dt><code>varlist</code></dt><dd><p>Character vector of objects to pass to a parallel
cluster.</p>
</dd>
<dt><code>arglist</code></dt><dd><p>List of values for each argument</p>
</dd>
<dt><code>number_runs</code></dt><dd><p>Total number of runs</p>
</dd>
<dt><code>completed_runs</code></dt><dd><p>Logical vector of whether each run has been
completed.</p>
</dd>
<dt><code>eval_func</code></dt><dd><p>The function that is called for each experiment trial.</p>
</dd>
<dt><code>outlist</code></dt><dd><p>A list of the output from each run.</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Logical of whether the output should be saved.</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Logical whether experiment runs should be run in
parallel. Allows for massive speedup.</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>How many cores to use when running in parallel.
Can be an integer, or 'detect' will detect how many cores are
available, or 'detect-1' will do one less than that.</p>
</dd>
<dt><code>parallel_cluster</code></dt><dd><p>The parallel cluster being used.</p>
</dd>
<dt><code>folder_path</code></dt><dd><p>The path to the folder where output will be saved.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>extract_output_to_df</code></dt><dd><p>A function to extract the raw output into
a data frame. E.g., if the output is a list, but you want a single
item to show up in the output data frame.</p>
</dd>
<dt><code>hashvalue</code></dt><dd><p>A value used to make sure inputs match when reloading.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ffexp-new"><code>ffexp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_all"><code>ffexp$run_all()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_for_time"><code>ffexp$run_for_time()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_superbatch"><code>ffexp$run_superbatch()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-run_one"><code>ffexp$run_one()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_result_of_one"><code>ffexp$add_result_of_one()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot_run_times"><code>ffexp$plot_run_times()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot_pairs"><code>ffexp$plot_pairs()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-plot"><code>ffexp$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-calculate_effects"><code>ffexp$calculate_effects()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-calculate_effects2"><code>ffexp$calculate_effects2()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-save_self"><code>ffexp$save_self()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-create_save_folder_if_nonexistent"><code>ffexp$create_save_folder_if_nonexistent()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-rename_save_folder"><code>ffexp$rename_save_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-delete_save_folder_if_empty"><code>ffexp$delete_save_folder_if_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-recover_parallel_temp_save"><code>ffexp$recover_parallel_temp_save()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-rungrid2"><code>ffexp$rungrid2()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_variable"><code>ffexp$add_variable()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-add_level"><code>ffexp$add_level()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-remove_results"><code>ffexp$remove_results()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-print"><code>ffexp$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-set_parallel_cores"><code>ffexp$set_parallel_cores()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-stop_cluster"><code>ffexp$stop_cluster()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-finalize"><code>ffexp$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-ffexp-clone"><code>ffexp$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ffexp-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an 'ffexp' object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$new(
  ...,
  eval_func,
  save_output = FALSE,
  parallel = FALSE,
  parallel_cores = "detect",
  folder_path,
  varlist = NULL,
  verbose = 2,
  extract_output_to_df = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Input arguments for the experiment</p>
</dd>
<dt><code>eval_func</code></dt><dd><p>The function to be run. It must take
named arguments matching the names of ...</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should output be saved to file?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should a parallel cluster be used?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>folder_path</code></dt><dd><p>Where the data and files should be stored.
If not given, a folder in the existing directory will be created.</p>
</dd>
<dt><code>varlist</code></dt><dd><p>Character vector of names of objects that need to be
passed to the parallel environment.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>extract_output_to_df</code></dt><dd><p>A function to extract the raw output into
a data frame. E.g., if the output is a list, but you want a single
item to show up in the output data frame.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-run_all"></a>



<h4>Method <code>run_all()</code></h4>

<p>Run an experiment. The user can choose
to run all rows, or just specified ones, if it should
be run in parallel, and what files should be saved.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_all(
  to_run = NULL,
  random_n = NULL,
  redo = FALSE,
  run_order,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  outfile,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to_run</code></dt><dd><p>Which rows should be run? If NULL, then all that haven't
been run yet.</p>
</dd>
<dt><code>random_n</code></dt><dd><p>Randomly selects n trials among those not yet completed
and runs them.</p>
</dd>
<dt><code>redo</code></dt><dd><p>Should already completed rows be run again?</p>
</dd>
<dt><code>run_order</code></dt><dd><p>In what order should the rows by run?
Options: random, in_order, and reverse.</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt><dd><p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt><dd><p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt><dd><p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt><dd><p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt><dd><p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>outfile</code></dt><dd><p>Where should master output file be saved when running
in parallel?</p>
</dd>
<dt><code>warn_repeat</code></dt><dd><p>Should warnings be given when repeating already
completed rows?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-run_for_time"></a>



<h4>Method <code>run_for_time()</code></h4>

<p>Run the experiment for a given time, not for a specified
number of trials. Runs 'batch_size' trials between checking the time
elapsed, only needs to be more than 1 when running in parallel.
It will complete the current batch before stopping, it does not quit
in the middle of the batch when reaching the time limit, so it will
go over the time limit given.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_for_time(
  sec,
  batch_size,
  show_time_in_bar = FALSE,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sec</code></dt><dd><p>Number of seconds to run for</p>
</dd>
<dt><code>batch_size</code></dt><dd><p>Number of trials to run between checking the time
elapsed.</p>
</dd>
<dt><code>show_time_in_bar</code></dt><dd><p>The progress bar can show either the number of
runs completed or the time elapsed.</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt><dd><p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt><dd><p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt><dd><p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt><dd><p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt><dd><p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>warn_repeat</code></dt><dd><p>Should warnings be given when repeating already
completed rows?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-run_superbatch"></a>



<h4>Method <code>run_superbatch()</code></h4>

<p>Run batches. Allows for better progress visualization
and saving when running in parallel
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_superbatch(
  nsb,
  redo = FALSE,
  run_order,
  save_output = self$save_output,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores,
  parallel_temp_save = save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  delete_parallel_temp_save_after = FALSE,
  varlist = self$varlist,
  verbose = self$verbose,
  warn_repeat = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nsb</code></dt><dd><p>Number of super batches</p>
</dd>
<dt><code>redo</code></dt><dd><p>Should already completed rows be run again?</p>
</dd>
<dt><code>run_order</code></dt><dd><p>In what order should the rows by run?
Options: random, in_order, and reverse.</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should the output be saved?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should it be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
<dt><code>parallel_temp_save</code></dt><dd><p>Should temp files be written when running
in parallel? Prevents losing results if it crashes partway through.</p>
</dd>
<dt><code>write_start_files</code></dt><dd><p>Should start files be written?</p>
</dd>
<dt><code>write_error_files</code></dt><dd><p>Should error files be written for rows that
fail?</p>
</dd>
<dt><code>delete_parallel_temp_save_after</code></dt><dd><p>If using parallel temp save
files, should they be deleted afterwards?</p>
</dd>
<dt><code>varlist</code></dt><dd><p>A character vector of names of variables to be passed
the the parallel cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>warn_repeat</code></dt><dd><p>Should warnings be given when repeating already
completed rows?</p>
</dd>
<dt><code>outfile</code></dt><dd><p>Where should master output file be saved when running
in parallel?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-run_one"></a>



<h4>Method <code>run_one()</code></h4>

<p>Run a single row of the experiment.
You can specify which one to run.
Generally this should not be used by users, use 'run_all'
instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$run_one(
  irow = NULL,
  save_output = self$save_output,
  write_start_files = save_output,
  write_error_files = save_output,
  warn_repeat = TRUE,
  is_parallel = FALSE,
  return_list_result_of_one = FALSE,
  verbose = self$verbose,
  force_this_as_output
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>irow</code></dt><dd><p>Which row should be run?</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should the output be saved?</p>
</dd>
<dt><code>write_start_files</code></dt><dd><p>Should a file be written when starting
the experiment?</p>
</dd>
<dt><code>write_error_files</code></dt><dd><p>Should a file be written if there is
an error?</p>
</dd>
<dt><code>warn_repeat</code></dt><dd><p>Should a warning be given if repeating a row?</p>
</dd>
<dt><code>is_parallel</code></dt><dd><p>Is this being run in parallel?</p>
</dd>
<dt><code>return_list_result_of_one</code></dt><dd><p>Should the list of the result of
this one be return?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
<dt><code>force_this_as_output</code></dt><dd><p>Value to use instead of evaluating
function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-add_result_of_one"></a>



<h4>Method <code>add_result_of_one()</code></h4>

<p>Add the result of a single experiment to the object.
This shouldn't be used by users.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_result_of_one(
  output,
  systime,
  irow,
  row_grid,
  row_df,
  start_time,
  end_time,
  save_output,
  hashvalue
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output</code></dt><dd><p>The output of the experiment.</p>
</dd>
<dt><code>systime</code></dt><dd><p>The time it took to run</p>
</dd>
<dt><code>irow</code></dt><dd><p>The row of inputs used.</p>
</dd>
<dt><code>row_grid</code></dt><dd><p>The corresponding row in the run grid.</p>
</dd>
<dt><code>row_df</code></dt><dd><p>The corresponding row data frame.</p>
</dd>
<dt><code>start_time</code></dt><dd><p>The start time of the experiment.</p>
</dd>
<dt><code>end_time</code></dt><dd><p>The end time of the experiment.</p>
</dd>
<dt><code>save_output</code></dt><dd><p>Should the output be saved?</p>
</dd>
<dt><code>hashvalue</code></dt><dd><p>Not used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-plot_run_times"></a>



<h4>Method <code>plot_run_times()</code></h4>

<p>Plot the run times of each trial.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot_run_times()</pre></div>


<hr>
<a id="method-ffexp-plot_pairs"></a>



<h4>Method <code>plot_pairs()</code></h4>

<p>Plot pairs of inputs and outputs.
Helps see correlations and distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot_pairs()</pre></div>


<hr>
<a id="method-ffexp-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Calling 'plot' on an 'ffexp' object calls 'plot_pairs()'
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$plot()</pre></div>


<hr>
<a id="method-ffexp-calculate_effects"></a>



<h4>Method <code>calculate_effects()</code></h4>

<p>Calculate the effects of each variable as if this
was an experiment using a linear model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$calculate_effects()</pre></div>


<hr>
<a id="method-ffexp-calculate_effects2"></a>



<h4>Method <code>calculate_effects2()</code></h4>

<p>Calculate the effects of each variable as if this
was an experiment using a linear model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$calculate_effects2()</pre></div>


<hr>
<a id="method-ffexp-save_self"></a>



<h4>Method <code>save_self()</code></h4>

<p>Save this R6 object
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$save_self(verbose = self$verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-create_save_folder_if_nonexistent"></a>



<h4>Method <code>create_save_folder_if_nonexistent()</code></h4>

<p>Create the save folder if it doesn't already exist.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$create_save_folder_if_nonexistent()</pre></div>


<hr>
<a id="method-ffexp-rename_save_folder"></a>



<h4>Method <code>rename_save_folder()</code></h4>

<p>Rename the save folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$rename_save_folder(new_folder_path, new_folder_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_folder_path</code></dt><dd><p>New path for the save folder</p>
</dd>
<dt><code>new_folder_name</code></dt><dd><p>If you want the new save folder to be in the
current directory, you can use this instead of 'new_folder_path' and
just give the folder name.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-delete_save_folder_if_empty"></a>



<h4>Method <code>delete_save_folder_if_empty()</code></h4>

<p>Delete the save folder if it is empty.
Used to prevent leaving behind empty folders.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$delete_save_folder_if_empty(verbose = self$verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>How much should be printed when running. 0 is none,
2 is average.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-recover_parallel_temp_save"></a>



<h4>Method <code>recover_parallel_temp_save()</code></h4>

<p>Running this loads the information saved to files
if 'save_parallel_temp_save=TRUE' was used when running.
Useful when running long jobs in parallel so that you don't
lose all results if it crashes before finishing.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$recover_parallel_temp_save(delete_after = FALSE, only_reload_new = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delete_after</code></dt><dd><p>Should the temp files be deleted after they
are recovered? If TRUE, make sure you save the ffexp object after
running this function so
you don't lose the data.</p>
</dd>
<dt><code>only_reload_new</code></dt><dd><p>Will only reload output from runs that don't show as
completed yet. Can make it much faster if there are many saved files, but
most have already been loaded to this object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-rungrid2"></a>



<h4>Method <code>rungrid2()</code></h4>

<p>Display the input rows of the experiment.
rungrid just gives integers, this gives the actual values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$rungrid2(rows = 1:nrow(self$rungrid))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rows</code></dt><dd><p>Which rows to display the inputs for? On big
experiments, specifying the rows can be much faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-add_variable"></a>



<h4>Method <code>add_variable()</code></h4>

<p>Add a variable to the experiment. You must specify the
value of the variable for all existing rows, and then also the values
of the variable which haven't been run yet.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_variable(name, existing_value, new_values, suppressMessage = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the variable being added.</p>
</dd>
<dt><code>existing_value</code></dt><dd><p>Which existing argument is a level being added to?</p>
</dd>
<dt><code>new_values</code></dt><dd><p>The values of the new variable which have not been
run. This should not include 'arg_name', the name of the new variable
at the existing values.</p>
</dd>
<dt><code>suppressMessage</code></dt><dd><p>Should the message be suppressed? The message
tells the user a new variable was added and it is being returned in a new
object. Default FALSE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-add_level"></a>



<h4>Method <code>add_level()</code></h4>

<p>Add a level to one of the arguments. This returns a new
object. The existing object is not changed.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$add_level(arg_name, new_values, suppressMessage = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>arg_name</code></dt><dd><p>Which existing argument is a level being added to?</p>
</dd>
<dt><code>new_values</code></dt><dd><p>The value of the new levels to be added to 'arg_name'.</p>
</dd>
<dt><code>suppressMessage</code></dt><dd><p>Should the message be suppressed? The message
tells the user a new level was added and it is being returned in a new
object. Default FALSE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-remove_results"></a>



<h4>Method <code>remove_results()</code></h4>

<p>Remove results of completed trials. They will be rerun
next time $run_all() is called.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$remove_results(to_remove)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>to_remove</code></dt><dd><p>Indexes of trials to remove</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printing the object shows some
summary information.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$print()</pre></div>


<hr>
<a id="method-ffexp-set_parallel_cores"></a>



<h4>Method <code>set_parallel_cores()</code></h4>

<p>Set the number of parallel cores to be used when
running in parallel. Needed in case user sets &quot;detect&quot;
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$set_parallel_cores(parallel_cores)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parallel_cores</code></dt><dd><p>When running in parallel, how many cores should
be used. Not actually the number of cores used, actually the number
of clusters created. Can be more than the computer has available,
but will hurt performance. Can set to 'detect' to have it detect
how many cores are available and use that, or 'detect-1' to use
one fewer than there are.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ffexp-stop_cluster"></a>



<h4>Method <code>stop_cluster()</code></h4>

<p>Stop the parallel cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$stop_cluster()</pre></div>


<hr>
<a id="method-ffexp-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Cleanup after deleting object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$finalize()</pre></div>


<hr>
<a id="method-ffexp-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ffexp$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Two factors, both with two levels.
#   The evaluation function simply prints out the combination
cc &lt;- ffexp$new(a=1:2,b=c("A","B"),
                eval_func=function(...) {c(...)})
# View the factor settings it will run (each row).
cc$rungrid
# Evaluate all four settings
cc$run_all()


cc &lt;- ffexp$new(a=1:3,b=2, cd=data.frame(c=3:4,d=5:6),
                eval_func=function(...) {list(...)})
</code></pre>

<hr>
<h2 id='hype'>Hyperparameter optimization</h2><span id='topic+hype'></span>

<h3>Description</h3>

<p>Hyperparameter optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hype(
  eval_func,
  ...,
  X0 = NULL,
  Z0 = NULL,
  n_lhs,
  extract_output_func,
  verbose = 1,
  model = "GauPro",
  covtype = "matern5_2",
  nugget.estim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hype_+3A_eval_func">eval_func</code></td>
<td>
<p>The function we evaluate.</p>
</td></tr>
<tr><td><code id="hype_+3A_...">...</code></td>
<td>
<p>Pass in hyperparameters, such as par_unif()
as unnamed arguments.</p>
</td></tr>
<tr><td><code id="hype_+3A_x0">X0</code></td>
<td>
<p>A data frame of initial points to include. They must
have the same names as the hyperparameters. If Z0 is also passed,
it should match the points in X0. If Z0 is not passed,
then X0 will be the first points evaluated.</p>
</td></tr>
<tr><td><code id="hype_+3A_z0">Z0</code></td>
<td>
<p>A vector whose values are the result of applying 'eval_func'
to each row of X0.</p>
</td></tr>
<tr><td><code id="hype_+3A_n_lhs">n_lhs</code></td>
<td>
<p>The number of random points to start with. They are
selected using a Latin hypercube sample.</p>
</td></tr>
<tr><td><code id="hype_+3A_extract_output_func">extract_output_func</code></td>
<td>
<p>A function that takes in the output from
'eval_func' and returns the value we are trying to minimize.</p>
</td></tr>
<tr><td><code id="hype_+3A_verbose">verbose</code></td>
<td>
<p>How much should be printed? 0 is none, 1 is standard,
2 is more, 5+ is a lot</p>
</td></tr>
<tr><td><code id="hype_+3A_model">model</code></td>
<td>
<p>What kind of model to use.</p>
</td></tr>
<tr><td><code id="hype_+3A_covtype">covtype</code></td>
<td>
<p>The covariance function to use for the Gaussian
process model.</p>
</td></tr>
<tr><td><code id="hype_+3A_nugget.estim">nugget.estim</code></td>
<td>
<p>Whether a nugget should be estimated when
fitting the Gaussian process model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Have df output, but only use one value from it
h1 &lt;- hype(
  eval_func = function(a, b) {data.frame(c=a^2+b^2, d=1:2)},
  extract_output_func = function(odf) {odf$c[1]},
  a = par_unif('a', -1, 2),
  b = par_unif('b', -10, 10),
  n_lhs = 10
)
h1$run_all()
h1$add_EI(n = 1)
h1$run_all()
#system.time(h1$run_EI_for_time(sec=3, batch_size = 1))
#system.time(h1$run_EI_for_time(sec=3, batch_size = 3))
h1$plotorder()
h1$plotX()
</code></pre>

<hr>
<h2 id='mbc'>Model benchmark compare</h2><span id='topic+mbc'></span>

<h3>Description</h3>

<p>Compare the run time and output of various code chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbc(
  ...,
  times = 5,
  input,
  inputi,
  evaluator,
  post,
  target,
  targetin,
  metric = "rmse",
  paired,
  kfold
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbc_+3A_...">...</code></td>
<td>
<p>Functions to run</p>
</td></tr>
<tr><td><code id="mbc_+3A_times">times</code></td>
<td>
<p>Number of times to run</p>
</td></tr>
<tr><td><code id="mbc_+3A_input">input</code></td>
<td>
<p>Object to be passed as input to each function</p>
</td></tr>
<tr><td><code id="mbc_+3A_inputi">inputi</code></td>
<td>
<p>Function to be called with the replicate number then passed to each function.</p>
</td></tr>
<tr><td><code id="mbc_+3A_evaluator">evaluator</code></td>
<td>
<p>An expression that the ... expressions will be passed as &quot;.&quot; for evaluation.</p>
</td></tr>
<tr><td><code id="mbc_+3A_post">post</code></td>
<td>
<p>Function or expression (using &quot;.&quot;) to post-process results.</p>
</td></tr>
<tr><td><code id="mbc_+3A_target">target</code></td>
<td>
<p>Values the functions are expected to (approximately) return.</p>
</td></tr>
<tr><td><code id="mbc_+3A_targetin">targetin</code></td>
<td>
<p>Values that will be given to the result of the run to produce output.</p>
</td></tr>
<tr><td><code id="mbc_+3A_metric">metric</code></td>
<td>
<p>c(&quot;rmse&quot;, &quot;t&quot;, &quot;mis90&quot;, &quot;sr27&quot;) Metric used to compare output values to target.
mis90 is the mean interval score for 90% confidence, see Gneiting and Raftery (2007).
sr27 is the scoring rule given in Equation 27 of Gneiting and Raftery (2007).</p>
</td></tr>
<tr><td><code id="mbc_+3A_paired">paired</code></td>
<td>
<p>Should the results be paired for comparison?</p>
</td></tr>
<tr><td><code id="mbc_+3A_kfold">kfold</code></td>
<td>
<p>First element should be the number of elements that are being
split into groups. If the number of folds is different from 'times', then
the second argument is the number of folds.
Use 'ki' in 'inputi' and 'targeti' to select elements in the current fold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of comparison results
</p>


<h3>References</h3>

<p>Gneiting, T., &amp; Raftery, A. E. (2007). Strictly proper scoring rules, prediction, and estimation. Journal of the American Statistical Association, 102(477), 359-378.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare distribution of mean for different sample sizes
mbc(mean(rnorm(1e2)),
    mean(rnorm(1e4)),
    times=20)

# Compare mean and median on same data
mbc(mean(x),
    median(x),
    inputi={x=rexp(1e2)})

# input given, no post
mbc({Sys.sleep(rexp(1, 30));mean(x)},
     {Sys.sleep(rexp(1, 5));median(x)},
    inputi={x=runif(100)})

# input given with post
mbc(mean={Sys.sleep(rexp(1, 30));mean(x)},
    med={Sys.sleep(rexp(1, 5));median(x)},
    inputi={x=runif(100)},
    post=function(x){c(x+1, x^2)})

# input given with post, 30 times
mbc(mean={Sys.sleep(rexp(1, 30));mean(x)+runif(1)},
    med={Sys.sleep(rexp(1, 50));median(x)+runif(1)},
    inputi={x=runif(100)},
    post=function(x){c(x+1, x^2)}, times=10)

# Name one function and post
mbc({mean(x)+runif(1)},
    a1={median(x)+runif(1)},
    inputi={x=runif(100)},
    post=function(x){c(rr=x+1, gg=x^2)}, times=10)

# No input
m1 &lt;- mbc(mean={x &lt;- runif(100);Sys.sleep(rexp(1, 30));mean(x)},
          med={x &lt;- runif(100);Sys.sleep(rexp(1, 50));median(x)})
</code></pre>

<hr>
<h2 id='par_discretenum'>Parameter with uniform distribution for hyperparameter optimization</h2><span id='topic+par_discretenum'></span>

<h3>Description</h3>

<p>Parameter with uniform distribution for hyperparameter optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_discretenum(name, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_discretenum_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_discretenum_+3A_values">values</code></td>
<td>
<p>Values, discrete numeric</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_discretenum('x1', 0:2)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='par_integer'>Parameter with uniform distribution over integer range
for hyperparameter optimization</h2><span id='topic+par_integer'></span>

<h3>Description</h3>

<p>Parameter with uniform distribution over integer range
for hyperparameter optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_integer(name, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_integer_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_integer_+3A_lower">lower</code></td>
<td>
<p>Lower bound of the parameter</p>
</td></tr>
<tr><td><code id="par_integer_+3A_upper">upper</code></td>
<td>
<p>Upper bound of the parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_integer('x1', 3, 8)
class(p1)
print(p1)
table(p1$generate(runif(1000)))
</code></pre>

<hr>
<h2 id='par_log10'>Hyperparameter on log10 scale</h2><span id='topic+par_log10'></span>

<h3>Description</h3>

<p>Hyperparameter on log10 scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_log10(name, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_log10_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_log10_+3A_lower">lower</code></td>
<td>
<p>Lower bound of the parameter</p>
</td></tr>
<tr><td><code id="par_log10_+3A_upper">upper</code></td>
<td>
<p>Upper bound of the parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_log10('x1', 1e-4, 1e4)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='par_ordered'>Hyperparameter of discrete (factor) variable</h2><span id='topic+par_ordered'></span>

<h3>Description</h3>

<p>Hyperparameter of discrete (factor) variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_ordered(name, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_ordered_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_ordered_+3A_values">values</code></td>
<td>
<p>Vector of values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_ordered('x1', c('a', 'b', 'c'))
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='par_unif'>Uniform parameter</h2><span id='topic+par_unif'></span>

<h3>Description</h3>

<p>Parameter with uniform distribution for hyperparameter optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_unif(name, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_unif_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_unif_+3A_lower">lower</code></td>
<td>
<p>Lower bound of the parameter</p>
</td></tr>
<tr><td><code id="par_unif_+3A_upper">upper</code></td>
<td>
<p>Upper bound of the parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an R6 class generated by R6_par_unif.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_unif('x1', 1, 10)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='par_unordered'>Hyperparameter of discrete (factor) variable</h2><span id='topic+par_unordered'></span>

<h3>Description</h3>

<p>Hyperparameter of discrete (factor) variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_unordered(name, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_unordered_+3A_name">name</code></td>
<td>
<p>Name of the parameter, must match the input to 'eval_func'.</p>
</td></tr>
<tr><td><code id="par_unordered_+3A_values">values</code></td>
<td>
<p>Vector of values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_unordered('x1', c('a', 'b', 'c'))
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='plot.mbc'>Plot mbc class</h2><span id='topic+plot.mbc'></span>

<h3>Description</h3>

<p>Plot mbc class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mbc_+3A_x">x</code></td>
<td>
<p>Object of class mbc</p>
</td></tr>
<tr><td><code id="plot.mbc_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- mbc(mn= {Sys.sleep(rexp(1, 30));mean(x)},
          med={Sys.sleep(rexp(1, 5));median(x)},
          input=runif(100))
plot(m1)
</code></pre>

<hr>
<h2 id='print.mbc'>Print mbc class</h2><span id='topic+print.mbc'></span>

<h3>Description</h3>

<p>Print mbc class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mbc_+3A_x">x</code></td>
<td>
<p>Object of class mbc</p>
</td></tr>
<tr><td><code id="print.mbc_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- mbc({Sys.sleep(rexp(1, 30));mean(x)},
          {Sys.sleep(rexp(1, 5));median(x)},
          input=runif(100))
print(m1)
</code></pre>

<hr>
<h2 id='R6_hype'>Hyperparameter optimization</h2><span id='topic+R6_hype'></span>

<h3>Description</h3>

<p>Hyperparameter optimization
</p>
<p>Hyperparameter optimization
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>X</code></dt><dd><p>Data frame of inputs that have been evaluated or will be evaluated
next.</p>
</dd>
<dt><code>Z</code></dt><dd><p>Output at X</p>
</dd>
<dt><code>runtime</code></dt><dd><p>The time it took to evaluate each row of X</p>
</dd>
<dt><code>parnames</code></dt><dd><p>Names of the parameters</p>
</dd>
<dt><code>parlowerraw</code></dt><dd><p>Lower bounds for each parameter on raw scale</p>
</dd>
<dt><code>parupperraw</code></dt><dd><p>Upper bounds for each parameter on raw scale</p>
</dd>
<dt><code>parlowertrans</code></dt><dd><p>Lower bounds for each parameter on transformed scale</p>
</dd>
<dt><code>paruppertrans</code></dt><dd><p>Upper bounds for each parameter on transformed scale</p>
</dd>
<dt><code>parlist</code></dt><dd><p>List of all parameters</p>
</dd>
<dt><code>modlist</code></dt><dd><p>A list with details about the model. The user shouldn't
ever edit this directly.</p>
</dd>
<dt><code>ffexp</code></dt><dd><p>An ffexp R6 object used to run the experiment and store
the results.</p>
</dd>
<dt><code>eval_func</code></dt><dd><p>The function we evaluate.</p>
</dd>
<dt><code>extract_output_func</code></dt><dd><p>A function that takes in the output from
'eval_func' and returns the value we are trying to minimize.</p>
</dd>
<dt><code>par_all_cts</code></dt><dd><p>Are all the parameters continuous?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed? 0 is none, 1 is standard,
2 is more, 5+ is a lot</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mod</code></dt><dd><p>Gaussian process model used to predict what the output will be.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-hype-new"><code>R6_hype$new()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-add_data"><code>R6_hype$add_data()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-add_X"><code>R6_hype$add_X()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-add_LHS"><code>R6_hype$add_LHS()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-convert_trans_to_raw"><code>R6_hype$convert_trans_to_raw()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-convert_raw_to_trans"><code>R6_hype$convert_raw_to_trans()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-change_par_bounds"><code>R6_hype$change_par_bounds()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-add_EI"><code>R6_hype$add_EI()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-fit_mod"><code>R6_hype$fit_mod()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-run_all"><code>R6_hype$run_all()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-run_EI_for_time"><code>R6_hype$run_EI_for_time()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-plot"><code>R6_hype$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-pairs"><code>R6_hype$pairs()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-plotorder"><code>R6_hype$plotorder()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-plotX"><code>R6_hype$plotX()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-plotXorder"><code>R6_hype$plotXorder()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-plotinteractions"><code>R6_hype$plotinteractions()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-print"><code>R6_hype$print()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-best_params"><code>R6_hype$best_params()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-update_mod_userspeclist"><code>R6_hype$update_mod_userspeclist()</code></a>
</p>
</li>
<li> <p><a href="#method-hype-clone"><code>R6_hype$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-hype-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create hype R6 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$new(
  eval_func,
  ...,
  X0 = NULL,
  Z0 = NULL,
  n_lhs,
  extract_output_func,
  verbose = 1,
  model = "GauPro",
  covtype = "matern5_2",
  nugget.estim = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>eval_func</code></dt><dd><p>The function used to evaluate new points.</p>
</dd>
<dt><code>...</code></dt><dd><p>Hyperparameters to optimize over.</p>
</dd>
<dt><code>X0</code></dt><dd><p>Data frame of initial points to run, or points already
evaluated. If already evaluated, give in outputs in &quot;Z0&quot;</p>
</dd>
<dt><code>Z0</code></dt><dd><p>Evaluated outputs at &quot;X0&quot;.</p>
</dd>
<dt><code>n_lhs</code></dt><dd><p>The number that should initially be run using
a maximin Latin hypercube.</p>
</dd>
<dt><code>extract_output_func</code></dt><dd><p>A function that takes in the output from
'eval_func' and returns the value we are trying to minimize.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>How much should be printed? 0 is none, 1 is standard,
2 is more, 5+ is a lot</p>
</dd>
<dt><code>model</code></dt><dd><p>What package to fit the Gaussian process model with.
Either &quot;GauPro&quot; or &quot;DiceKriging&quot;/&quot;DK&quot;.</p>
</dd>
<dt><code>covtype</code></dt><dd><p>Covariance/correlation/kernel function for the GP model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should the nugget be estimated when fitting
the GP model?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-add_data"></a>



<h4>Method <code>add_data()</code></h4>

<p>Add data to the experiment results.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$add_data(X, Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data frame with names matching the input parameters</p>
</dd>
<dt><code>Z</code></dt><dd><p>Output at rows of X matching the experiment output.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-add_X"></a>



<h4>Method <code>add_X()</code></h4>

<p>Add new inputs to run. This allows the user to specify
what they want run next.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$add_X(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data frame with names matching the input parameters.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-add_LHS"></a>



<h4>Method <code>add_LHS()</code></h4>

<p>Add new input points using a maximin
Latin hypercube.
Latin hypercubes are usually more spacing than randomly picking points.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$add_LHS(n, just_return_df = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points to add.</p>
</dd>
<dt><code>just_return_df</code></dt><dd><p>Instead of adding to experiment, should
it just return the new set of values?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-convert_trans_to_raw"></a>



<h4>Method <code>convert_trans_to_raw()</code></h4>

<p>Convert parameters from transformed scale to raw scale.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$convert_trans_to_raw(Xtrans)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xtrans</code></dt><dd><p>Parameters on the transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-convert_raw_to_trans"></a>



<h4>Method <code>convert_raw_to_trans()</code></h4>

<p>Convert parameters from raw scale to transformed scale.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$convert_raw_to_trans(Xraw)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xraw</code></dt><dd><p>Parameters on the raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-change_par_bounds"></a>



<h4>Method <code>change_par_bounds()</code></h4>

<p>Change lower/upper bounds of a parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$change_par_bounds(parname, lower, upper)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parname</code></dt><dd><p>Name of the parameter</p>
</dd>
<dt><code>lower</code></dt><dd><p>New lower bound. Leave empty if not changing.</p>
</dd>
<dt><code>upper</code></dt><dd><p>New upper bound. Leave empty if not changing.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-add_EI"></a>



<h4>Method <code>add_EI()</code></h4>

<p>Add new inputs to run using the expected information
criteria
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$add_EI(
  n,
  covtype = NULL,
  nugget.estim = NULL,
  model = NULL,
  eps,
  just_return = FALSE,
  calculate_at
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points to add.</p>
</dd>
<dt><code>covtype</code></dt><dd><p>Covariance function to use for the Gaussian process
model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should a nugget be estimated?</p>
</dd>
<dt><code>model</code></dt><dd><p>Which package should be used to fit the model and
calculate the EI? Use &quot;DK&quot; for DiceKriging or &quot;GauPro&quot; for GauPro.</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter. The minimum amount of improvement
you care about.</p>
</dd>
<dt><code>just_return</code></dt><dd><p>Just return the EI info, don't actually add the
points to the design.</p>
</dd>
<dt><code>calculate_at</code></dt><dd><p>Calculate the EI at a specific point.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-fit_mod"></a>



<h4>Method <code>fit_mod()</code></h4>

<p>Fit model to the data collected so far
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$fit_mod(covtype = NULL, nugget.estim = NULL, model = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covtype</code></dt><dd><p>Covariance function to use for the Gaussian process
model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should a nugget be estimated?</p>
</dd>
<dt><code>model</code></dt><dd><p>Which package should be used to fit the model and
calculate the EI? Use &quot;DK&quot; for DiceKriging or &quot;GauPro&quot; for GauPro.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-run_all"></a>



<h4>Method <code>run_all()</code></h4>

<p>Run all unevaluated input points.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$run_all(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed into &lsquo;ffexp$run_all'. Can set &rsquo;parallel=TRUE'
to evaluate multiple points simultaneously as long as all needed
variables have been passed to 'varlist'</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-run_EI_for_time"></a>



<h4>Method <code>run_EI_for_time()</code></h4>

<p>Add points using the expected information criteria,
evaluate them, and repeat until a specified amount of time has passed.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$run_EI_for_time(
  sec,
  batch_size,
  covtype = "matern5_2",
  nugget.estim = TRUE,
  verbose = 0,
  model = "GauPro",
  eps = 0,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sec</code></dt><dd><p>Number of seconds to run for. It will go over this time
limit, finish the current iteration, then stop.</p>
</dd>
<dt><code>batch_size</code></dt><dd><p>Number of points to run at once.</p>
</dd>
<dt><code>covtype</code></dt><dd><p>Covariance function to use for the Gaussian process
model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should a nugget be estimated?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Verbose parameter to pass to ffexp$</p>
</dd>
<dt><code>model</code></dt><dd><p>Which package should be used to fit the model and
calculate the EI? Use &quot;DK&quot; for DiceKriging or &quot;GauPro&quot; for GauPro.</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter. The minimum amount of improvement
you care about.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed into 'ffexp$run_all'.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Make a plot to summarize the experiment.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$plot()</pre></div>


<hr>
<a id="method-hype-pairs"></a>



<h4>Method <code>pairs()</code></h4>

<p>Plot pairs of inputs and output
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$pairs()</pre></div>


<hr>
<a id="method-hype-plotorder"></a>



<h4>Method <code>plotorder()</code></h4>

<p>Plot the output of the points evaluated in order.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$plotorder()</pre></div>


<hr>
<a id="method-hype-plotX"></a>



<h4>Method <code>plotX()</code></h4>

<p>Plot the output as a function of each input.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$plotX(
  addlines = TRUE,
  addEIlines = TRUE,
  covtype = NULL,
  nugget.estim = NULL,
  model = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>addlines</code></dt><dd><p>Should prediction mean and 95% interval be plotted?</p>
</dd>
<dt><code>addEIlines</code></dt><dd><p>Should expected improvement lines be plotted?</p>
</dd>
<dt><code>covtype</code></dt><dd><p>Covariance function to use for the Gaussian process
model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should a nugget be estimated?</p>
</dd>
<dt><code>model</code></dt><dd><p>Which package should be used to fit the model and
calculate the EI? Use &quot;DK&quot; for DiceKriging or &quot;GauPro&quot; for GauPro.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-plotXorder"></a>



<h4>Method <code>plotXorder()</code></h4>

<p>Plot each input in the order they were chosen.
Colored by quality.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$plotXorder()</pre></div>


<hr>
<a id="method-hype-plotinteractions"></a>



<h4>Method <code>plotinteractions()</code></h4>

<p>Plot the 2D plots from inputs to the output.
All other variables are held at their values for the best input.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$plotinteractions(covtype = "matern5_2", nugget.estim = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covtype</code></dt><dd><p>Covariance function to use for the Gaussian process
model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should a nugget be estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-best_params"></a>



<h4>Method <code>best_params()</code></h4>

<p>Returns the best parameters
evaluated so far.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$best_params()</pre></div>


<hr>
<a id="method-hype-update_mod_userspeclist"></a>



<h4>Method <code>update_mod_userspeclist()</code></h4>

<p>Updates the specifications for the GP model.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$update_mod_userspeclist(
  model = NULL,
  covtype = NULL,
  nugget.estim = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>What package to fit the Gaussian process model with.
Either &quot;GauPro&quot; or &quot;DiceKriging&quot;/&quot;DK&quot;.</p>
</dd>
<dt><code>covtype</code></dt><dd><p>Covariance/correlation/kernel function for the GP model.</p>
</dd>
<dt><code>nugget.estim</code></dt><dd><p>Should the nugget be estimated when fitting
the GP model?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-hype-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_hype$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
# Have df output, but only use one value from it
h1 &lt;- hype(
  eval_func = function(a, b) {data.frame(c=a^2+b^2, d=1:2)},
  extract_output_func = function(odf) {odf$c[1]},
  a = par_unif('a', -1, 2),
  b = par_unif('b', -10, 10),
  n_lhs = 10
)
h1$run_all()
h1$add_EI(n = 1)
h1$run_all()
#system.time(h1$run_EI_for_time(sec=3, batch_size = 1))
#system.time(h1$run_EI_for_time(sec=3, batch_size = 3))
h1$plotorder()
h1$plotX()
</code></pre>

<hr>
<h2 id='R6_par_discretenum'>R6 object for discrete numeric</h2><span id='topic+R6_par_discretenum'></span>

<h3>Description</h3>

<p>R6 object for discrete numeric
</p>
<p>R6 object for discrete numeric
</p>


<h3>Details</h3>

<p>Parameter with uniform distribution for hyperparameter optimization
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_discretenum</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>Values, discrete numeric</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_discretenum-fromraw"><code>R6_par_discretenum$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-toraw"><code>R6_par_discretenum$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-generate"><code>R6_par_discretenum$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-getseq"><code>R6_par_discretenum$getseq()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-isvalid"><code>R6_par_discretenum$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-convert_to_mopar"><code>R6_par_discretenum$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-new"><code>R6_par_discretenum$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-print"><code>R6_par_discretenum$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_discretenum-clone"><code>R6_par_discretenum$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-par_discretenum-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-getseq"></a>



<h4>Method <code>getseq()</code></h4>

<p>Get a sequence, uniform on the transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$getseq(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points. Ignored for discrete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$new(name, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>Numeric values, must be in ascending order</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_discretenum-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_discretenum$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- R6_par_discretenum$new('x1', 0:2)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='R6_par_hype'>Parameter for hyperparameter optimization</h2><span id='topic+R6_par_hype'></span>

<h3>Description</h3>

<p>Parameter for hyperparameter optimization
</p>
<p>Parameter for hyperparameter optimization
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>partrans</code></dt><dd><p>The transformation type.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_hype-getseq"><code>R6_par_hype$getseq()</code></a>
</p>
</li>
<li> <p><a href="#method-par_hype-clone"><code>R6_par_hype$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-par_hype-getseq"></a>



<h4>Method <code>getseq()</code></h4>

<p>Get a sequence, uniform on the transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_hype$getseq(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points. Ignored for discrete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_hype-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_hype$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- R6_par_hype$new()
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='R6_par_integer'>Parameter with uniform distribution over integer range
for hyperparameter optimization</h2><span id='topic+R6_par_integer'></span>

<h3>Description</h3>

<p>Parameter with uniform distribution over integer range
for hyperparameter optimization
</p>
<p>Parameter with uniform distribution over integer range
for hyperparameter optimization
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_integer</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_integer-fromraw"><code>R6_par_integer$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-toraw"><code>R6_par_integer$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-generate"><code>R6_par_integer$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-getseq"><code>R6_par_integer$getseq()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-isvalid"><code>R6_par_integer$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-convert_to_mopar"><code>R6_par_integer$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-new"><code>R6_par_integer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-print"><code>R6_par_integer$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_integer-clone"><code>R6_par_integer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-par_integer-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-getseq"></a>



<h4>Method <code>getseq()</code></h4>

<p>Get a sequence, uniform on the transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$getseq(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points. Ignored for discrete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$new(name, lower, upper)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used,</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_integer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_integer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- R6_par_integer$new('x1', 0, 2)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='R6_par_log10'>R6 class for hyperparameter on log10 scale</h2><span id='topic+R6_par_log10'></span>

<h3>Description</h3>

<p>R6 class for hyperparameter on log10 scale
</p>
<p>R6 class for hyperparameter on log10 scale
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_log10</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_log10-fromraw"><code>R6_par_log10$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-toraw"><code>R6_par_log10$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-generate"><code>R6_par_log10$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-isvalid"><code>R6_par_log10$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-convert_to_mopar"><code>R6_par_log10$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-new"><code>R6_par_log10$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-print"><code>R6_par_log10$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_log10-clone"><code>R6_par_log10$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="comparer" data-topic="par_hype" data-id="getseq"><a href='../../comparer/html/par_hype.html#method-par_hype-getseq'><code>comparer::par_hype$getseq()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-par_log10-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$new(name, lower, upper)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_log10-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_log10$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_log10('x1', 1e-4, 1e4)
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='R6_par_ordered'>R6 class for hyperparameter of discrete (factor) variable</h2><span id='topic+R6_par_ordered'></span>

<h3>Description</h3>

<p>R6 class for hyperparameter of discrete (factor) variable
</p>
<p>R6 class for hyperparameter of discrete (factor) variable
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_ordered</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>Vector of values</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_ordered-fromraw"><code>R6_par_ordered$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-toraw"><code>R6_par_ordered$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-fromint"><code>R6_par_ordered$fromint()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-toint"><code>R6_par_ordered$toint()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-generate"><code>R6_par_ordered$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-getseq"><code>R6_par_ordered$getseq()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-isvalid"><code>R6_par_ordered$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-convert_to_mopar"><code>R6_par_ordered$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-new"><code>R6_par_ordered$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-print"><code>R6_par_ordered$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_ordered-clone"><code>R6_par_ordered$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-par_ordered-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-fromint"></a>



<h4>Method <code>fromint()</code></h4>

<p>Convert from integer index to actual value
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$fromint(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer index</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-toint"></a>



<h4>Method <code>toint()</code></h4>

<p>Convert from value to integer index
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$toint(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-getseq"></a>



<h4>Method <code>getseq()</code></h4>

<p>Get a sequence, uniform on the transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$getseq(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points. Ignored for discrete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$new(name, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>The values the variable can take on.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_ordered-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_ordered$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_ordered('x1', c('a', 'b', 'c'))
class(p1)
print(p1)
</code></pre>

<hr>
<h2 id='R6_par_unif'>R6 class for Uniform parameter</h2><span id='topic+R6_par_unif'></span>

<h3>Description</h3>

<p>R6 class for Uniform parameter
</p>
<p>R6 class for Uniform parameter
</p>


<h3>Details</h3>

<p>Parameter with uniform distribution for hyperparameter optimization
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_unif</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_unif-fromraw"><code>R6_par_unif$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-toraw"><code>R6_par_unif$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-generate"><code>R6_par_unif$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-isvalid"><code>R6_par_unif$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-convert_to_mopar"><code>R6_par_unif$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-new"><code>R6_par_unif$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-print"><code>R6_par_unif$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unif-clone"><code>R6_par_unif$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="comparer" data-topic="par_hype" data-id="getseq"><a href='../../comparer/html/par_hype.html#method-par_hype-getseq'><code>comparer::par_hype$getseq()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-par_unif-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$new(name, lower, upper)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used,</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unif-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unif$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='R6_par_unordered'>R6 class for hyperparameter of discrete (factor) variable</h2><span id='topic+R6_par_unordered'></span>

<h3>Description</h3>

<p>R6 class for hyperparameter of discrete (factor) variable
</p>
<p>R6 class for hyperparameter of discrete (factor) variable
</p>


<h3>Super class</h3>

<p><code>comparer::par_hype</code> -&gt; <code>par_unordered</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>Vector of values</p>
</dd>
<dt><code>ggtrans</code></dt><dd><p>Transformation for ggplot, see ggplot2::scale_x_continuous()</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of the parameter</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of the parameter</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-par_unordered-fromraw"><code>R6_par_unordered$fromraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-toraw"><code>R6_par_unordered$toraw()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-fromint"><code>R6_par_unordered$fromint()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-toint"><code>R6_par_unordered$toint()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-generate"><code>R6_par_unordered$generate()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-getseq"><code>R6_par_unordered$getseq()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-isvalid"><code>R6_par_unordered$isvalid()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-convert_to_mopar"><code>R6_par_unordered$convert_to_mopar()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-new"><code>R6_par_unordered$new()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-print"><code>R6_par_unordered$print()</code></a>
</p>
</li>
<li> <p><a href="#method-par_unordered-clone"><code>R6_par_unordered$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-par_unordered-fromraw"></a>



<h4>Method <code>fromraw()</code></h4>

<p>Function to convert from raw scale to transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$fromraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of raw scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-toraw"></a>



<h4>Method <code>toraw()</code></h4>

<p>Function to convert from transformed scale to raw scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$toraw(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value of transformed scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-fromint"></a>



<h4>Method <code>fromint()</code></h4>

<p>Convert from integer index to actual value
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$fromint(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer index</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-toint"></a>



<h4>Method <code>toint()</code></h4>

<p>Convert from value to integer index
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$toint(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-generate"></a>



<h4>Method <code>generate()</code></h4>

<p>Generate values in the raw space based on quantiles.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$generate(q)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>In [0,1].</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-getseq"></a>



<h4>Method <code>getseq()</code></h4>

<p>Get a sequence, uniform on the transformed scale
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$getseq(n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of points. Ignored for discrete.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-isvalid"></a>



<h4>Method <code>isvalid()</code></h4>

<p>Check if input is valid for parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$isvalid(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Parameter value</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-convert_to_mopar"></a>



<h4>Method <code>convert_to_mopar()</code></h4>

<p>Convert this to a parameter for the
mixopt R package.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$convert_to_mopar(raw_scale = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw_scale</code></dt><dd><p>Should it be on the raw scale?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyperparameter with uniform distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$new(name, values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the parameter, must match the input to 'eval_func'.</p>
</dd>
<dt><code>values</code></dt><dd><p>The values the variable can take on.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print details of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-par_unordered-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R6_par_unordered$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- par_unordered('x1', c('a', 'b', 'c'))
class(p1)
print(p1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
