<!DOCTYPE html><html><head><title>Help for package vglmer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vglmer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#custom_glmer_samples'><p>Get samples from GLMER</p></a></li>
<li><a href='#fallback_interpret.gam0'><p>Interpret a vglmer formula for splines</p></a></li>
<li><a href='#formOmega'><p>Code from Wand and Ormerod (2008)</p>
Found here here: 10.1111/j.1467-842X.2008.00507.x</a></li>
<li><a href='#LinRegChol'><p>Linear Regression by Cholesky</p></a></li>
<li><a href='#MAVB'><p>Perform MAVB after fitting vglmer</p></a></li>
<li><a href='#posterior_samples.vglmer'><p>Draw samples from the variational distribution</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#simple_EM'><p>Simple EM algorithm for starting values.</p></a></li>
<li><a href='#sl_vglmer'><p>SuperLearner with (Variational) Hierarchical Models</p></a></li>
<li><a href='#v_s'><p>Create splines for use in vglmer</p></a></li>
<li><a href='#var_mat'><p>Variance of Rows or Columns of Matrices</p></a></li>
<li><a href='#vglmer'><p>Variational Inference for Hierarchical Generalized Linear Models</p></a></li>
<li><a href='#vglmer_control'><p>Control for vglmer estimation</p></a></li>
<li><a href='#vglmer_predict'><p>Predict after vglmer</p></a></li>
<li><a href='#vglmer-class'><p>Generic Functions after Running vglmer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variational Inference for Hierarchical Generalized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates hierarchical models using mean-field variational Bayes. 
    At present, it can estimate logistic, linear, and negative binomial models. 
    It can accommodate models with an arbitrary number of random effects and 
    requires no integration to estimate. It also provides the ability to improve 
    the quality of the approximation using marginal augmentation. 
    Goplerud (2022) &lt;<a href="https://doi.org/10.1214%2F21-BA1266">doi:10.1214/21-BA1266</a>&gt; provides details on the variational
    algorithms.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), lme4, CholWishart, mvtnorm, Matrix, stats,
graphics, methods, lmtest, splines, mgcv</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SuperLearner, MASS, tictoc, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mgoplerud/vglmer">https://github.com/mgoplerud/vglmer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mgoplerud/vglmer/issues">https://github.com/mgoplerud/vglmer/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 17:41:46 UTC; MHG23</td>
</tr>
<tr>
<td>Author:</td>
<td>Max Goplerud [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Max Goplerud &lt;mgoplerud@pitt.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='custom_glmer_samples'>Get samples from GLMER</h2><span id='topic+custom_glmer_samples'></span>

<h3>Description</h3>

<p>Order samples from glmer to match names from vglmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_glmer_samples(glmer, samples, ordering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_glmer_samples_+3A_glmer">glmer</code></td>
<td>
<p>object fitted using glmer</p>
</td></tr>
<tr><td><code id="custom_glmer_samples_+3A_samples">samples</code></td>
<td>
<p>number of samples to draw</p>
</td></tr>
<tr><td><code id="custom_glmer_samples_+3A_ordering">ordering</code></td>
<td>
<p>order of output</p>
</td></tr>
</table>

<hr>
<h2 id='fallback_interpret.gam0'>Interpret a vglmer formula for splines</h2><span id='topic+fallback_interpret.gam0'></span>

<h3>Description</h3>

<p>A modified version of interpret.gam0 from mgcv. Used when mgcv's
interpret.gam fails; usually when some environment object is passed to v_s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fallback_interpret.gam0(gf, textra = NULL, extra.special = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fallback_interpret.gam0_+3A_gf">gf</code></td>
<td>
<p>A vglmer formula</p>
</td></tr>
<tr><td><code id="fallback_interpret.gam0_+3A_textra">textra</code></td>
<td>
<p>Unused internal argument</p>
</td></tr>
<tr><td><code id="fallback_interpret.gam0_+3A_extra.special">extra.special</code></td>
<td>
<p>Allow extra special terms to be passed</p>
</td></tr>
</table>

<hr>
<h2 id='formOmega'>Code from Wand and Ormerod (2008)
Found here here: 10.1111/j.1467-842X.2008.00507.x</h2><span id='topic+formOmega'></span>

<h3>Description</h3>

<p>Code from Wand and Ormerod (2008)
Found here here: 10.1111/j.1467-842X.2008.00507.x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formOmega(a, b, intKnots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formOmega_+3A_a">a</code></td>
<td>
<p>lower boundary</p>
</td></tr>
<tr><td><code id="formOmega_+3A_b">b</code></td>
<td>
<p>upper boundary</p>
</td></tr>
<tr><td><code id="formOmega_+3A_intknots">intKnots</code></td>
<td>
<p>internal knots</p>
</td></tr>
</table>

<hr>
<h2 id='LinRegChol'>Linear Regression by Cholesky</h2><span id='topic+LinRegChol'></span>

<h3>Description</h3>

<p>Do linear regression of form (X^T O X + P)^-1 X^T y where O is omega, P is
precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinRegChol(X, omega, prior_precision, y, save_chol = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinRegChol_+3A_x">X</code></td>
<td>
<p>Design Matrix</p>
</td></tr>
<tr><td><code id="LinRegChol_+3A_omega">omega</code></td>
<td>
<p>Polya-Gamma weights</p>
</td></tr>
<tr><td><code id="LinRegChol_+3A_prior_precision">prior_precision</code></td>
<td>
<p>Prior Precision for Regression</p>
</td></tr>
<tr><td><code id="LinRegChol_+3A_y">y</code></td>
<td>
<p>Outcome</p>
</td></tr>
<tr><td><code id="LinRegChol_+3A_save_chol">save_chol</code></td>
<td>
<p>Save cholesky factor</p>
</td></tr>
</table>

<hr>
<h2 id='MAVB'>Perform MAVB after fitting vglmer</h2><span id='topic+MAVB'></span>

<h3>Description</h3>

<p>Given a model estimated using <code>vglmer</code>, this function
performs marginally augmented variational Bayes (MAVB) to improve the
approximation quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAVB(object, samples, verbose = FALSE, var_px = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAVB_+3A_object">object</code></td>
<td>
<p>Model fit using <code>vglmer</code>.</p>
</td></tr>
<tr><td><code id="MAVB_+3A_samples">samples</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="MAVB_+3A_verbose">verbose</code></td>
<td>
<p>Show progress in drawing samples.</p>
</td></tr>
<tr><td><code id="MAVB_+3A_var_px">var_px</code></td>
<td>
<p>Variance of working prior for marginal augmentation. Default
(<code>Inf</code>) is a flat, improper, prior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the improved estimates of the
<em>parameters</em>. To use MAVB when generating predictions, one should use
<a href="#topic+predict_MAVB">predict_MAVB</a>. At present, MAVB is only enabled for binomial models.
</p>


<h3>Value</h3>

<p>This function returns a matrix with <code>samples</code> rows and columns
for each fixed and random effect.
</p>


<h3>References</h3>

<p>Goplerud, Max. 2022a. &quot;Fast and Accurate Estimation of Non-Nested Binomial
Hierarchical Models Using Variational Inference.&quot; <em>Bayesian Analysis</em>. 17(2):
623-650.
</p>

<hr>
<h2 id='posterior_samples.vglmer'>Draw samples from the variational distribution</h2><span id='topic+posterior_samples.vglmer'></span>

<h3>Description</h3>

<p>This function draws samples from the estimated variational
distributions. If using <code>MAVB</code> to improve the quality of the
approximating distribution, please use <a href="#topic+MAVB">MAVB</a> or <a href="#topic+predict_MAVB">predict_MAVB</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_samples.vglmer(object, samples, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_samples.vglmer_+3A_object">object</code></td>
<td>
<p>Model fit using <code>vglmer</code>.</p>
</td></tr>
<tr><td><code id="posterior_samples.vglmer_+3A_samples">samples</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="posterior_samples.vglmer_+3A_verbose">verbose</code></td>
<td>
<p>Show progress in drawing samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with <code>samples</code> rows and columns
for each fixed and random effect.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+fixef'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lme4</dt><dd><p><code><a href="lme4.html#topic+fixef">fixef</a></code>, <code><a href="lme4.html#topic+ranef">ranef</a></code></p>
</dd>
</dl>

<hr>
<h2 id='simple_EM'>Simple EM algorithm for starting values.</h2><span id='topic+simple_EM'></span><span id='topic+EM_prelim_logit'></span><span id='topic+EM_prelim_nb'></span>

<h3>Description</h3>

<p>Use ridge penalty to prevent separation. Not be called by user!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_prelim_logit(X, Z, s, pg_b, iter, ridge = 2)

EM_prelim_nb(X, Z, y, est_r, iter, ridge = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_EM_+3A_x">X</code></td>
<td>
<p>Design matrix</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_z">Z</code></td>
<td>
<p>RE design matrix</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_s">s</code></td>
<td>
<p>(y_i - n_i)/2 for polya-gamma input</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_pg_b">pg_b</code></td>
<td>
<p>n_i as vector input</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_iter">iter</code></td>
<td>
<p>iterations</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_ridge">ridge</code></td>
<td>
<p>variance of ridge prior</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_y">y</code></td>
<td>
<p>Raw observed y_i</p>
</td></tr>
<tr><td><code id="simple_EM_+3A_est_r">est_r</code></td>
<td>
<p>Initial r value (not updated!)</p>
</td></tr>
</table>

<hr>
<h2 id='sl_vglmer'>SuperLearner with (Variational) Hierarchical Models</h2><span id='topic+sl_vglmer'></span><span id='topic+SL.vglmer'></span><span id='topic+predict.SL.vglmer'></span><span id='topic+SL.glmer'></span><span id='topic+predict.SL.glmer'></span><span id='topic+add_formula_SL'></span>

<h3>Description</h3>

<p>These functions integrate <code>vglmer</code> (or <code>glmer</code>) into
<code>SuperLearner</code>. Most of the arguments are standard for
<code>SuperLearner</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL.vglmer(
  Y,
  X,
  newX,
  formula,
  family,
  id,
  obsWeights,
  control = vglmer_control()
)

## S3 method for class 'SL.vglmer'
predict(object, newdata, allow_missing_levels = TRUE, ...)

SL.glmer(Y, X, newX, formula, family, id, obsWeights, control = NULL)

## S3 method for class 'SL.glmer'
predict(object, newdata, allow.new.levels = TRUE, ...)

add_formula_SL(learner, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sl_vglmer_+3A_y">Y</code></td>
<td>
<p>From <code>SuperLearner</code>: The outcome in the training data set.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_x">X</code></td>
<td>
<p>From <code>SuperLearner</code>: The predictor variables in the training
data.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_newx">newX</code></td>
<td>
<p>From <code>SuperLearner</code>: The predictor variables in validation
data.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_formula">formula</code></td>
<td>
<p>The formula used for estimation.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_family">family</code></td>
<td>
<p>From <code>SuperLearner</code>: Currently allows <code>gaussian</code> or
<code>binomial</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_id">id</code></td>
<td>
<p>From <code>SuperLearner</code>: Optional cluster identification variable.
See <code>SuperLearner</code> for more details.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_obsweights">obsWeights</code></td>
<td>
<p>From <code>SuperLearner</code>: Weights for each observation. Not
permitted for <code>SL.vglmer</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_control">control</code></td>
<td>
<p>Control object for estimating <code>vglmer</code> (e.g.,
<a href="#topic+vglmer_control">vglmer_control</a>) or <code>[g]lmer</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_object">object</code></td>
<td>
<p>Used in <code>predict</code> for <code>SL.glmer</code> and
<code>SL.vglmer</code>. A model estimated using either <code>SL.vglmer</code> or
<code>SL.glmer</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_newdata">newdata</code></td>
<td>
<p>Dataset to use for predictions.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_allow_missing_levels">allow_missing_levels</code></td>
<td>
<p>Default (<code>TRUE</code>) allows prediction for
levels not observed in the estimation data; the value of <code>0</code> (with no
uncertainty) is used for the corresponding random effect. <b>Note:</b> This
default differs from <code>predict.vglmer</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_...">...</code></td>
<td>
<p>Not used; included to maintain compatibility with existing
methods.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>From <code>lme4</code>: Allow levels in prediction that are
not in the training data. Default is <code>TRUE</code> for <code>SuperLearner</code>.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_learner">learner</code></td>
<td>
<p>Character name of model from <code>SuperLearner</code>. See
&quot;Details&quot; for how this is used.</p>
</td></tr>
<tr><td><code id="sl_vglmer_+3A_env">env</code></td>
<td>
<p>Environment to assign model. See &quot;Details&quot; for how this is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This documentation describes two types of function. 
</p>
<p><b>Estimating Hierarchical Models in SuperLearner</b>: Two methods for
estimating hierarchical models are provided one for variational methods
(<code>SL.vglmer</code>) and one for non-variational methods (<code>SL.glmer</code>).
The accompanying prediction functions are also provided.
</p>
<p><b>Formula with SuperLearner</b>: The <code>vglmer</code> package provides a way
to estimate models that require or use a formula with <code>SuperLearner</code>.
This allows for a design to be passed that contains variables that are
<em>not</em> used in estimation. This can be used as follows (see
&quot;Examples&quot;). One calls the function <code>add_formula_SL</code> around the quoted
name of a <code>SuperLearner</code> model, e.g. <code>add_formula_SL(learner =
  "SL.knn")</code>. This creates a new model and predict function with the suffix
<code>"_f"</code>. This <b>requires</b> a formula to be provided for estimation.
</p>
<p>With this in hand, <code>"SL.knn_f"</code> can be passed to <code>SuperLearner</code> with the
accompanying formula argument and thus one can compare models with
different formula or design on the same ensemble. The <code>env</code> argument
may need to be manually specified to ensure the created functions can be
called by <code>SuperLearner</code>.
</p>


<h3>Value</h3>

<p>The functions here return different types of output. <code>SL.vglmer</code>
and <code>SL.glmer</code> return fitted models with the in-sample predictions as
standard for <code>SuperLearner</code>. The <code>predict</code> methods return vectors
of predicted values. <code>add_formula_SL</code> creates two objects in the
environment (one for estimation <code>model_f</code> and one for prediction
<code>predict.model_f</code>) used for <code>SuperLearner</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(456)

if (requireNamespace('SuperLearner', quietly = TRUE)){
require(SuperLearner)
sim_data &lt;- data.frame(
  x = rnorm(100),
  g = sample(letters, 100, replace = TRUE)
)
sim_data$y &lt;- rbinom(nrow(sim_data), 
  1, plogis(runif(26)[match(sim_data$g, letters)]))
sim_data$g &lt;- factor(sim_data$g)
sl_vglmer &lt;- function(...){SL.vglmer(..., formula = y ~ x + (1 | g))}
SL.glm &lt;- SuperLearner::SL.glm
add_formula_SL('SL.glm')
sl_glm_form &lt;- function(...){SL.glm_f(..., formula = ~ x)}

   SuperLearner::SuperLearner(
     Y = sim_data$y, family = 'binomial',
     X = sim_data[, c('x', 'g')],
     cvControl = list(V = 2),
     SL.library = c('sl_vglmer', 'sl_glm_form')
   )

}
</code></pre>

<hr>
<h2 id='v_s'>Create splines for use in vglmer</h2><span id='topic+v_s'></span>

<h3>Description</h3>

<p>This function estimates splines in <code>vglmer</code>, similar to <code>s(...)</code> in
<code>mgcv</code> albeit with many fewer options than <code>mgcv</code>. It allows for
truncated (linear) splines or O'Sullivan splines. Please see <a href="#topic+vglmer">vglmer</a>
for more discussion and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v_s(
  ...,
  type = "tpf",
  knots = NULL,
  by = NA,
  by_re = TRUE,
  force_vector = FALSE,
  outer_okay = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_s_+3A_...">...</code></td>
<td>
<p>Variable name, e.g. <code>v_s(x)</code></p>
</td></tr>
<tr><td><code id="v_s_+3A_type">type</code></td>
<td>
<p>Default (<code>"tpf"</code>) uses truncated linear splines for the
basis. The other option (<code>"o"</code>) uses O'Sullivan splines (Wand and
Ormerod 2008).</p>
</td></tr>
<tr><td><code id="v_s_+3A_knots">knots</code></td>
<td>
<p>Default (<code>NULL</code>) uses <code class="reqn">K=min(N/4,35)</code> knots evenly
spaced at quantiles of the covariate <code>x</code>. A single number specifies a
specific number of knots; a vector can set custom locations for knots.</p>
</td></tr>
<tr><td><code id="v_s_+3A_by">by</code></td>
<td>
<p>A categorical or factor covariate to interact the spline with; for
example, <code>v_s(x, by = g)</code>.</p>
</td></tr>
<tr><td><code id="v_s_+3A_by_re">by_re</code></td>
<td>
<p>Default (<code>TRUE</code>) regularizes the interactions between the
categorical factor and the covariate. See &quot;Details&quot; in <a href="#topic+vglmer">vglmer</a> for
more discussion.</p>
</td></tr>
<tr><td><code id="v_s_+3A_force_vector">force_vector</code></td>
<td>
<p>Force that argument to <code>knots</code> is treated as vector.
This is usually not needed unless <code>knots</code> is a single integer that
should be treated as a single knot (vs. the number of knots).</p>
</td></tr>
<tr><td><code id="v_s_+3A_outer_okay">outer_okay</code></td>
<td>
<p>Default (<code>FALSE</code>) does not permit values in <code>x</code>
to exceed the outer knots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of class of <code>vglmer_spline</code> that is
passed to unexported functions. It contains the arguments noted above where
<code>...</code> is parsed into an argument called <code>term</code>.
</p>


<h3>References</h3>

<p>Wand, Matt P. and Ormerod, John T. 2008. &quot;On Semiparametric Regression with
O'Sullivan Penalized Splines&quot;. <em>Australian &amp; New Zealand Journal of
Statistics</em>. 50(2): 179-198.
</p>
<p>Wood, Simon N. 2017. <em>Generalized Additive Models: An Introduction with
R</em>. Chapman and Hall/CRC.
</p>

<hr>
<h2 id='var_mat'>Variance of Rows or Columns of Matrices</h2><span id='topic+var_mat'></span><span id='topic+rowVar'></span><span id='topic+colVar'></span>

<h3>Description</h3>

<p>Base R implementation for variance. Analogue of rowMeans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowVar(matrix)

colVar(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_mat_+3A_matrix">matrix</code></td>
<td>
<p>Matrix of numeric inputs.</p>
</td></tr>
</table>

<hr>
<h2 id='vglmer'>Variational Inference for Hierarchical Generalized Linear Models</h2><span id='topic+vglmer'></span>

<h3>Description</h3>

<p>This function estimates hierarchical models using mean-field variational
inference. <code>vglmer</code> accepts standard syntax used for <code>lme4</code>, e.g.,
<code>y ~ x + (x | g)</code>. Options are described below. Goplerud (2022a; 2022b)
provides details on the variational algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vglmer(formula, data, family, control = vglmer_control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vglmer_+3A_formula">formula</code></td>
<td>
<p><code>lme4</code> style-formula for random effects. Typically,
<code>(1 + z | g)</code> indicates a random effect for each level of variable
<code>"g"</code> with a differing slope for the effect of variable <code>"z"</code> and
an intercept (<code>1</code>); see &quot;Details&quot; for further discussion and how to
incorporate splines.</p>
</td></tr>
<tr><td><code id="vglmer_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the outcome and predictors.</p>
</td></tr>
<tr><td><code id="vglmer_+3A_family">family</code></td>
<td>
<p>Options are &quot;binomial&quot;, &quot;linear&quot;, or &quot;negbin&quot; (experimental).
If &quot;binomial&quot;, outcome must be either binary (<code class="reqn">\{0,1\}</code>) or
<code>cbind(success, failure)</code> as per standard <code>glm(er)</code> syntax.
Non-integer values are permitted for binomial if <code>force_whole</code> is set
to <code>FALSE</code> in <code>vglmer_control</code>.</p>
</td></tr>
<tr><td><code id="vglmer_+3A_control">control</code></td>
<td>
<p>Adjust internal options for estimation. Must use an object
created by <a href="#topic+vglmer_control">vglmer_control</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Estimation Syntax:</b> The <code>formula</code> argument takes syntax designed
to be a similar as possible to <code>lme4</code>. That is, one can specify models
using <code>y ~ x + (1 | g)</code> where <code>(1 | g)</code> indicates a random intercept. While
not tested extensively, terms of <code>(1 | g / f)</code> should work as expected. Terms
of <code>(1 + x || g)</code> may work, although will raise a warning about duplicated
names of random effects. <code>(1 + x || g)</code> terms may not work with spline
estimation. To get around this, one can might copy the column <code>g</code> to
<code>g_copy</code> and then write <code>(1 | g) + (0 + x | g_copy)</code>.
</p>
<p><b>Splines:</b> Splines can be added using the term <code>v_s(x)</code> for a
spline on the variable <code>x</code>. These are transformed into hierarchical
terms in a standard fashion (e.g. Ruppert et al. 2003) and then estimated
using the variational algorithms. At the present, only truncated linear
functions (<code>type = "tpf"</code>; the default) and O'Sullivan splines (Wand and
Ormerod 2008) are included. The options are described in more detail at
<a href="#topic+v_s">v_s</a>.
</p>
<p>It is possible to have the spline vary across some categorical predictor by
specifying the <code>"by"</code> argument such as <code>v_s(x, by = g)</code>. In effect,
this adds additional hierarchical terms for the group-level deviations from
the &quot;global&quot; spline. <em>Note:</em> In contrast to the typical presentation of
these splines interacted with categorical variables (e.g., Ruppert et al.
2003), the default use of <code>"by"</code> includes the lower order interactions
that are regularized, i.e. <code>(1 + x | g)</code>, versus their unregularized
version (e.g., <code>x * g</code>); this can be changed using the <code>by_re</code>
argument described in <a href="#topic+v_s">v_s</a>. Further, all group-level deviations from
the global spline share the same smoothing parameter (same prior
distribution).
</p>
<p><b>Default Settings:</b> By default, the model is estimated using the
&quot;strong&quot; (i.e. fully factorized) variational assumption. Setting
<code>vglmer_control(factorization_method = "weak")</code> will improve the quality
of the variance approximation but may take considerably more time to
estimate. See Goplerud (2022a) for discussion. 
</p>
<p>By default, the prior on each random effect variance (<code class="reqn">\Sigma_j</code>) uses a Huang-Wand prior (Huang
and Wand 2013) with hyper-parameters <code class="reqn">\nu_j = 2</code> and <code class="reqn">A_{j,k} = 5</code>.
This is designed to be proper but weakly informative. Other options are
discussed in <a href="#topic+vglmer_control">vglmer_control</a> under the <code>prior_variance</code> argument.
</p>
<p>By default, estimation is accelerated using SQUAREM (Varadhan and Roland
2008) and (one-step-late) parameter expansion for variational Bayes. Under
the default <code>"strong"</code> factorization, a &quot;translation&quot; expansion is used;
under other factorizations a &quot;mean&quot; expansion is used. These can be adjusted
using <a href="#topic+vglmer_control">vglmer_control</a>. See Goplerud (2022b) for more discussion of
these methods.
</p>


<h3>Value</h3>

<p>This returns an object of class <code>vglmer</code>. The available methods
(e.g. <code>coef</code>) can be found using <code>methods(class="vglmer")</code>.
</p>

<dl>
<dt>beta</dt><dd><p>Contains the estimated distribution of the fixed effects
(<code class="reqn">\beta</code>). It is multivariate normal. <code>mean</code> contains the means;
<code>var</code> contains the variance matrix; <code>decomp_var</code> contains a matrix
<code class="reqn">L</code> such that <code class="reqn">L^T L</code> equals the full variance matrix.</p>
</dd>
<dt>alpha</dt><dd><p>Contains the estimated distribution of the random effects
(<code class="reqn">\alpha</code>). They are all multivariate normal. <code>mean</code> contains the
means; <code>dia.var</code> contains the variance of each random effect. <code>var</code>
contains the variance matrix of each random effect (j,g). <code>decomp_var</code>
contains a matrix <code class="reqn">L</code> such that <code class="reqn">L^T L</code> equals the full variance of
the entire set of random effects.</p>
</dd>
<dt>joint</dt><dd><p>If <code>factorization_method="weak"</code>, this is a list with one
element (<code>decomp_var</code>) that contains a matrix <code class="reqn">L</code> such that <code class="reqn">L^T
L</code> equals the full variance matrix between the fixed and random effects
<code class="reqn">q(\beta,\alpha)</code>. The marginal variances are included in <code>beta</code> and
<code>alpha</code>. If the factorization method is not <code>"weak"</code>, this is
<code>NULL</code>.</p>
</dd>
<dt>sigma</dt><dd><p>Contains the estimated distribution of each random
effect covariance <code class="reqn">\Sigma_j</code>; all distributions are Inverse-Wishart.
<code>cov</code> contains a list of the estimated scale matrices. <code>df</code>
contains a list of the degrees of freedom.</p>
</dd>
<dt>hw</dt><dd><p>If a Huang-Wand prior is used (see Huang and Wand 2013 or Goplerud
2022b for more details), then the estimated distribution. Otherwise, it is
<code>NULL</code>. All distributions are Inverse-Gamma. <code>a</code> contains a list of
the scale parameters. <code>b</code> contains a list of the shape parameters.</p>
</dd>
<dt>sigmasq</dt><dd><p>If <code>family="linear"</code>, this contains a list of the
estimated parameters for <code class="reqn">\sigma^2</code>; its distribution is Inverse-Gamma.
<code>a</code> contains the scale parameter; <code>b</code> contains the shape
parameter.</p>
</dd>
<dt>ln_r</dt><dd><p>If <code>family="negbin"</code>, this contains the variational
parameters for the log dispersion parameter <code class="reqn">\ln(r)</code>. <code>mu</code> contains
the mean; <code>sigma</code> contains the variance.</p>
</dd>
<dt>family</dt><dd><p>Family of outcome.</p>
</dd>
<dt>ELBO</dt><dd><p>Contains the ELBO at the termination of the algorithm.</p>
</dd>
<dt>ELBO_trajectory</dt><dd><p><code>data.frame</code> tracking the ELBO per iteration.</p>
</dd>
<dt>control</dt><dd><p>Contains the control parameters from <code>vglmer_control</code>
used in estimation.</p>
</dd>
<dt>internal_parameters</dt><dd><p>Variety of internal parameters used in
post-estimation functions.</p>
</dd>
<dt>formula</dt><dd><p>Contains the formula used for estimation; contains the
original formula, fixed effects, and random effects parts separately for
post-estimation functions. See <code>formula.vglmer</code> for more details.</p>
</dd>
</dl>



<h3>References</h3>

<p>Goplerud, Max. 2022a. &quot;Fast and Accurate Estimation of Non-Nested Binomial
Hierarchical Models Using Variational Inference.&quot; <em>Bayesian Analysis</em>. 17(2):
623-650.
</p>
<p>Goplerud, Max. 2022b. &quot;Re-Evaluating Machine Learning for MRP Given the
Comparable Performance of (Deep) Hierarchical Models.&quot; Working paper.
</p>
<p>Huang, Alan, and Matthew P. Wand. 2013. &quot;Simple Marginally Noninformative
Prior Distributions for Covariance Matrices.&quot; <em>Bayesian Analysis</em>.
8(2):439-452.
</p>
<p>Ruppert, David, Matt P. Wand, and Raymond J. Carroll. 2003.
<em>Semiparametric Regression</em>. Cambridge University Press.
</p>
<p>Varadhan, Ravi, and Christophe Roland. 2008. &quot;Simple and Globally Convergent
Methods for Accelerating the Convergence of any EM Algorithm.&quot; <em>Scandinavian
Journal of Statistics</em>. 35(2): 335-353.
</p>
<p>Wand, Matt P. and Ormerod, John T. 2008. &quot;On Semiparametric Regression with
O'Sullivan Penalized Splines&quot;. <em>Australian &amp; New Zealand Journal of Statistics</em>.
50(2): 179-198.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(234)
sim_data &lt;- data.frame(
  x = rnorm(100),
  y = rbinom(100, 1, 0.5),
  g = sample(letters, 100, replace = TRUE)
)

# Run with defaults
est_vglmer &lt;- vglmer(y ~ x + (x | g), data = sim_data, family = "binomial")

# Simple prediction
predict(est_vglmer, newdata = sim_data)

# Summarize results
summary(est_vglmer)

# Extract parameters
coef(est_vglmer); vcov(est_vglmer)

# Comparability with lme4,
# although ranef is formatted differently.
ranef(est_vglmer); fixef(est_vglmer)


# Run with weaker (i.e. better) approximation
vglmer(y ~ x + (x | g),
  data = sim_data,
  control = vglmer_control(factorization_method = "weak"),
  family = "binomial")



# Use a spline on x with a linear outcome
vglmer(y ~ v_s(x),
  data = sim_data,
  family = "linear")


</code></pre>

<hr>
<h2 id='vglmer_control'>Control for vglmer estimation</h2><span id='topic+vglmer_control'></span>

<h3>Description</h3>

<p>This function controls various estimation options for <code>vglmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vglmer_control(
  iterations = 1000,
  prior_variance = "hw",
  factorization_method = c("strong", "partial", "weak"),
  parameter_expansion = "translation",
  do_SQUAREM = TRUE,
  tolerance_elbo = 1e-08,
  tolerance_parameters = 1e-05,
  force_whole = TRUE,
  print_prog = NULL,
  do_timing = FALSE,
  verbose_time = FALSE,
  return_data = FALSE,
  linpred_method = "joint",
  vi_r_method = "VEM",
  verify_columns = FALSE,
  debug_param = FALSE,
  debug_ELBO = FALSE,
  debug_px = FALSE,
  quiet = TRUE,
  quiet_rho = TRUE,
  px_method = "dynamic",
  px_numerical_it = 10,
  hw_inner = 10,
  init = "EM_FE"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vglmer_control_+3A_iterations">iterations</code></td>
<td>
<p>Default of 1000; this sets the maximum number of iterations
used in estimation.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_prior_variance">prior_variance</code></td>
<td>
<p>Prior distribution on the random effect variance
<code class="reqn">\Sigma_j</code>. Options are <code>hw</code>, <code>jeffreys</code>, <code>mean_exists</code>,
<code>uniform</code>, and <code>gamma</code>. The default (<code>hw</code>) is the Huang-Wand
(2013) prior whose hyper-parameters are <code class="reqn">\nu_j</code> = 2 and <code class="reqn">A_{j,k}</code> =
5. Otherwise, the prior is an Inverse Wishart with the following parameters
where <code class="reqn">d_j</code> is the dimensionality of the random effect <code class="reqn">j</code>.
</p>

<ul>
<li><p> mean_exists: <code class="reqn">IW(d_j + 1, I)</code>
</p>
</li>
<li><p> jeffreys: <code class="reqn">IW(0, 0)</code>
</p>
</li>
<li><p> uniform: <code class="reqn">IW(-[d_j+1], 0)</code>
</p>
</li>
<li><p> limit: <code class="reqn">IW(d_j - 1, 0)</code>
</p>
</li></ul>

<p>Estimation may fail if an improper prior (<code>jeffreys</code>, <code>uniform</code>,
<code>limit</code>) is used.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_factorization_method">factorization_method</code></td>
<td>
<p>Factorization assumption for the variational
approximation. Default of <code>"strong"</code>, i.e. a fully factorized model.
Described in detail in Goplerud (2022a). <code>"strong"</code>, <code>"partial"</code>,
and <code>"weak"</code> correspond to Schemes I, II, and III respectively in that
paper.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_parameter_expansion">parameter_expansion</code></td>
<td>
<p>Default of <code>"translation"</code>  (see Goplerud
2022b). Valid options are <code>"translation"</code>, <code>"mean"</code>, or
<code>"none"</code>. <code>"mean"</code> should be employed if <code>"translation"</code> is
not enabled or is too computationally expensive. For negative binomial
estimation or any estimation where <code>factorization_method != "strong"</code>,
only <code>"mean"</code> and <code>"none"</code> are available.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_do_squarem">do_SQUAREM</code></td>
<td>
<p>Default (<code>TRUE</code>) accelerates estimation using SQUAREM
(Varadhan and Roland 2008).</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_tolerance_elbo">tolerance_elbo</code></td>
<td>
<p>Default (<code>1e-8</code>) sets a convergence threshold if
the change in the ELBO is below the tolerance.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_tolerance_parameters">tolerance_parameters</code></td>
<td>
<p>Default (<code>1e-5</code>) sets a convergence
threshold that is achieved if no parameter changes by more than the
tolerance from the prior estimated value.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_force_whole">force_whole</code></td>
<td>
<p>Default (<code>TRUE</code>) requires integers for observed
outcome for binomial or count models. <code>FALSE</code> allows for fractional
responses.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_print_prog">print_prog</code></td>
<td>
<p>Default (<code>NULL</code>) prints a <code>"."</code> to indicate once
5% of the total iterations have elapsed. Set to a positive integer
<code>int</code> to print a <code>"."</code> every <code>int</code> iterations.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_do_timing">do_timing</code></td>
<td>
<p>Default (<code>FALSE</code>) does not estimate timing of each
variational update; <code>TRUE</code> requires the package <code>tictoc</code>.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_verbose_time">verbose_time</code></td>
<td>
<p>Default (<code>FALSE</code>) does not print the time elapsed
for each parameter update. Set to <code>TRUE</code>, in conjunction with
<code>do_timing=TRUE</code>, to see the time taken for each parameter update.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_return_data">return_data</code></td>
<td>
<p>Default (<code>FALSE</code>) does not return the original
design. Set to <code>TRUE</code> to debug convergence issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_linpred_method">linpred_method</code></td>
<td>
<p>Default (<code>"joint"</code>) updates the mean parameters
for the fixed and random effects simultaneously. This can improve the speed
of estimation but may be costly for large datasets; use <code>"cyclical"</code>
to update each parameter block separately.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_vi_r_method">vi_r_method</code></td>
<td>
<p>Default (<code>"VEM"</code>) uses a variational EM algorithm for
updating <code class="reqn">r</code> if <code>family="negbin"</code>. This assumes a point mass
distribution on <code class="reqn">r</code>. A number can be provided to fix <code class="reqn">r</code>. These are
the only available options.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_verify_columns">verify_columns</code></td>
<td>
<p>Default (<code>FALSE</code>) <b>does not</b> verify that all
columns are drawn from the data.frame itself versus the environment. Set to
<code>TRUE</code> to debug potential issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_debug_param">debug_param</code></td>
<td>
<p>Default (<code>FALSE</code>) does not store parameters before
the final iteration. Set to <code>TRUE</code> to debug convergence issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_debug_elbo">debug_ELBO</code></td>
<td>
<p>Default (<code>FALSE</code>) does not store the ELBO after each
parameter update. Set to <code>TRUE</code> to debug convergence issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_debug_px">debug_px</code></td>
<td>
<p>Default (<code>FALSE</code>) does not store information about
whether parameter expansion worked. Set to <code>TRUE</code> to convergence
issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_quiet">quiet</code></td>
<td>
<p>Default (<code>FALSE</code>) does not print intermediate output about
convergence. Set to <code>TRUE</code> to debug.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_quiet_rho">quiet_rho</code></td>
<td>
<p>Default (<code>FALSE</code>) does not print information about
parameter expansions. Set to <code>TRUE</code> to debug convergence issues.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_px_method">px_method</code></td>
<td>
<p>When code <code>parameter_expansion="translation"</code>, default
(<code>"dynamic"</code>) tries a one-step late update and, if this fails, a
numerical improvement by L-BFGS-B. For an Inverse-Wishart prior on
<code class="reqn">\Sigma_j</code>, this is set to <code>"osl"</code> that only attempts a
one-step-late update.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_px_numerical_it">px_numerical_it</code></td>
<td>
<p>Default of 10; if L-BFGS_B is needed for a parameter
expansion, this sets the number of steps used.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_hw_inner">hw_inner</code></td>
<td>
<p>If <code>prior_variance="hw"</code>, this sets the number of
repeated iterations between estimating <code class="reqn">\Sigma_j</code> and <code class="reqn">a_{j,k}</code>
variational distributions at each iteration. A larger number approximates
jointly updating both parameters. Default (10) typically performs well.</p>
</td></tr>
<tr><td><code id="vglmer_control_+3A_init">init</code></td>
<td>
<p>Default (<code>"EM_FE"</code>) initializes the mean variational
parameters for <code class="reqn">q(\beta, \alpha)</code> by setting the random effects to zero
and estimating the fixed effects using a short-running EM algorithm.
<code>"EM"</code> initializes the model with a ridge regression with a guess as
to the random effect variance. <code>"random"</code> initializes the means
randomly. <code>"zero"</code> initializes them at zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a named list with class <code>vglmer_control</code>.
It is passed to <code>vglmer</code> in the argument <code>control</code>. This argument
only accepts objects created using <code>vglmer_control</code>.
</p>


<h3>References</h3>

<p>Goplerud, Max. 2022a. &quot;Fast and Accurate Estimation of Non-Nested Binomial
Hierarchical Models Using Variational Inference.&quot; <em>Bayesian Analysis</em>.
17(2): 623-650.
</p>
<p>Goplerud, Max. 2022b. &quot;Re-Evaluating Machine Learning for MRP Given the
Comparable Performance of (Deep) Hierarchical Models.&quot; Working Paper.
</p>
<p>Huang, Alan, and Matthew P. Wand. 2013. &quot;Simple Marginally Noninformative
Prior Distributions for Covariance Matrices.&quot; <em>Bayesian Analysis</em>.
8(2):439-452.
</p>
<p>Varadhan, Ravi, and Christophe Roland. 2008. &quot;Simple and Globally Convergent
Methods for Accelerating the Convergence of any EM Algorithm.&quot;
<em>Scandinavian Journal of Statistics</em>. 35(2): 335-353.
</p>

<hr>
<h2 id='vglmer_predict'>Predict after vglmer</h2><span id='topic+vglmer_predict'></span><span id='topic+predict.vglmer'></span><span id='topic+predict_MAVB'></span>

<h3>Description</h3>

<p>These functions calculate the estimated linear predictor using
the variational distributions. <code>predict.vglmer</code> draws predictions
using the estimated variational distributions; <code>predict_MAVB</code> does so
using the MAVB procedure described in Goplerud (2022a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vglmer'
predict(
  object,
  newdata,
  samples = 0,
  samples_only = FALSE,
  summary = TRUE,
  allow_missing_levels = FALSE,
  ...
)

predict_MAVB(
  object,
  newdata,
  samples = 0,
  samples_only = FALSE,
  var_px = Inf,
  summary = TRUE,
  allow_missing_levels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vglmer_predict_+3A_object">object</code></td>
<td>
<p>Model fit using <code>vglmer</code>.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_newdata">newdata</code></td>
<td>
<p>Dataset to use for predictions. It cannot be missing.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_samples">samples</code></td>
<td>
<p>Number of samples to draw. Using <code>0</code> (default) gives the
expectation of the linear predictor. A positive integer draws
<code>samples</code> samples from the variational distributions and calculates
the linear predictor.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_samples_only">samples_only</code></td>
<td>
<p>Default (<code>FALSE</code>) returns the samples from the
variational distributions, <b>not</b> the prediction. Each row is a sample and
each column is a parameter.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_summary">summary</code></td>
<td>
<p>Default (<code>TRUE</code>) returns the mean and variance of the
samples for each observation. <code>FALSE</code> returns a matrix of the sampled
linear predictor for each observation. Each row is a sample and each column
is an observation.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_allow_missing_levels">allow_missing_levels</code></td>
<td>
<p>Default (<code>FALSE</code>) does not allow prediction
for levels not observed in the original data. <code>TRUE</code> allows for
prediction on unseen levels; the value of <code>0</code> (with no uncertainty) is
used for the corresponding random effect.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_...">...</code></td>
<td>
<p>Not used; included to maintain compatibility with existing
methods.</p>
</td></tr>
<tr><td><code id="vglmer_predict_+3A_var_px">var_px</code></td>
<td>
<p>Variance of working prior for marginal augmentation. Default
(<code>Inf</code>) is a flat, improper, prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an estimate of the linear predictor. The
default returns the expected mean, i.e. <code class="reqn">E_{q(\alpha,\beta)}[x_i^T
  \beta + z_i^T\alpha]</code>. If <code>samples &gt; 0</code>, these functions return a
summary of the prediction for each observation, i.e. the estimated mean and
variance. If <code>summary = FALSE</code>, the sampled values of the linear
predictor are returned as a matrix. <code>predict_MAVB</code> performs MAVB as
described in Goplerud (2022a) before returning the linear predictor.
</p>
<p>If <code>allow_missing_levels = TRUE</code>, then observations with a new
(unseen) level for the random effect are given a value of zero for that
term of the prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sim_data &lt;- data.frame(
  x = rnorm(100),
  y = rbinom(100, 1, 0.5),
  g = sample(letters, 100, replace = TRUE)
)

# Run with defaults
est_vglmer &lt;- vglmer(y ~ x + (x | g), data = sim_data, family = "binomial")

# Simple prediction
predict(est_vglmer, newdata = sim_data)
# Return 10 posterior draws of the linear predictor for each observation.
predict_MAVB(est_vglmer, newdata = sim_data, summary = FALSE, samples = 10)
# Predict with a new level; note this would fail if 
# allow_missing_levels = FALSE (the default)
predict(est_vglmer,
  newdata = data.frame(g = "AB", x = 0),
  allow_missing_levels = TRUE
)
</code></pre>

<hr>
<h2 id='vglmer-class'>Generic Functions after Running vglmer</h2><span id='topic+vglmer-class'></span><span id='topic+fixef.vglmer'></span><span id='topic+sigma.vglmer'></span><span id='topic+ranef.vglmer'></span><span id='topic+coef.vglmer'></span><span id='topic+vcov.vglmer'></span><span id='topic+fitted.vglmer'></span><span id='topic+print.vglmer'></span><span id='topic+summary.vglmer'></span><span id='topic+formula.vglmer'></span><span id='topic+format_vglmer'></span><span id='topic+format_glmer'></span><span id='topic+ELBO'></span>

<h3>Description</h3>

<p><code>vglmer</code> uses many standard methods from <code>lm</code> and <code>lme4</code> with
limited changes. These provide summaries of the estimated variational
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vglmer'
fixef(object, ...)

## S3 method for class 'vglmer'
sigma(object, ...)

## S3 method for class 'vglmer'
ranef(object, ...)

## S3 method for class 'vglmer'
coef(object, ...)

## S3 method for class 'vglmer'
vcov(object, ...)

## S3 method for class 'vglmer'
fitted(object, ...)

## S3 method for class 'vglmer'
print(x, ...)

## S3 method for class 'vglmer'
summary(object, display_re = TRUE, ...)

## S3 method for class 'vglmer'
formula(x, form = "original", ...)

format_vglmer(object)

format_glmer(object)

ELBO(object, type = c("final", "trajectory"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vglmer-class_+3A_object">object</code></td>
<td>
<p>Model fit using <code>vglmer</code>.</p>
</td></tr>
<tr><td><code id="vglmer-class_+3A_...">...</code></td>
<td>
<p>Not used; included to maintain compatibility with existing
methods.</p>
</td></tr>
<tr><td><code id="vglmer-class_+3A_x">x</code></td>
<td>
<p>Model fit using <code>vglmer</code>.</p>
</td></tr>
<tr><td><code id="vglmer-class_+3A_display_re">display_re</code></td>
<td>
<p>Default (<code>TRUE</code>) prints a summary of the
random effects alongside the fixed effects.</p>
</td></tr>
<tr><td><code id="vglmer-class_+3A_form">form</code></td>
<td>
<p>Describes the type of formula to report:
<code>"original"</code> returns the user input, <code>"fe"</code> returns the fixed
effects only, <code>"re"</code> returns the random effects only.</p>
</td></tr>
<tr><td><code id="vglmer-class_+3A_type">type</code></td>
<td>
<p>Default (<code>"final"</code>) gives the ELBO at convergence.
<code>"trajectory"</code> gives the ELBO estimated at each iteration. This is
used to assess model convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The accompanying functions are briefly described below. 
</p>
<p><code>coef</code> and <code>vcov</code> return the mean and variance of the fixed effects
(<code class="reqn">\beta</code>). <code>fixef</code> returns the mean of the fixed effects.
</p>
<p><code>ranef</code> extracts the random effects (<code class="reqn">\alpha</code>) in a similar,
although slightly different format, to <code>lme4</code>. It includes the estimated
posterior mean and variance in a list of data.frames with one entry per
random effect <code class="reqn">j</code>.
</p>
<p><code>fitted</code> extracts the estimated expected <em>linear predictor</em>, i.e.
<code class="reqn">E_{q(\theta)}[x_i^T \beta + z_i^T \alpha]</code> at convergence.
</p>
<p><code>summary</code> reports the estimates for all fixed effects as in <code>lm</code> as
well as some summaries of the random effects (if <code>display_re=TRUE</code>).
</p>
<p><code>format_vglmer</code> collects the mean and variance of the fixed and random
effects into a single data.frame. This is useful for examining all of the
posterior estimates simultaneously. <code>format_glmer</code> converts an object
estimated with <code>[g]lmer</code> into a comparable format.
</p>
<p><code>ELBO</code> extracts the ELBO from the estimated model. <code>type</code> can be
set equal to <code>"trajectory"</code> to get the estimated ELBO at each iteration
and assess convergence.
</p>
<p><code>sigma</code> extracts the square root of the posterior mode of
<code class="reqn">q(\sigma^2)</code> if a linear model is used.
</p>
<p><code>formula</code> extracts the formula associated with the <code>vglmer</code> object.
By default, it returns the formula provided. The fixed and random effects
portions can be extracted separately using the <code>form</code> argument.
</p>


<h3>Value</h3>

<p>The functions here return a variety of different objects depending on
the specific function. &quot;Details&quot; describes the behavior of each one. Their
output is similar to the typical behavior for the corresponding generic
functions.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
