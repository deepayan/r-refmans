<!DOCTYPE html><html><head><title>Help for package sadists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sadists}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sadists'><p>Some Additional Distributions</p></a></li>
<li><a href='#dnbeta'><p>The doubly non-central Beta distribution.</p></a></li>
<li><a href='#dneta'><p>The doubly non-central Eta distribution.</p></a></li>
<li><a href='#dnf'><p>The doubly non-central F distribution.</p></a></li>
<li><a href='#dnt'><p>The doubly non-central t distribution.</p></a></li>
<li><a href='#kprime'><p>The K prime distribution.</p></a></li>
<li><a href='#lambdap'><p>The lambda prime distribution.</p></a></li>
<li><a href='#prodchisqpow'><p>The product of (non-central) chi-squares raised to powers distribution.</p></a></li>
<li><a href='#proddnf'><p>The product of multiple doubly non-central F's distribution.</p></a></li>
<li><a href='#prodnormal'><p>The product of normal random variates.</p></a></li>
<li><a href='#runExample'><p>Run Shiny Application</p></a></li>
<li><a href='#sadists-NEWS'><p>News for package 'sadists'</p></a></li>
<li><a href='#sumchisqpow'><p>The sum of (non-central) chi-squares raised to powers distribution.</p></a></li>
<li><a href='#sumlogchisq'><p>The sum of the logs of (non-central) chi-squares distribution.</p></a></li>
<li><a href='#upsilon'><p>The upsilon distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Steven E. Pav &lt;shabbychef@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-20</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Some Additional Distributions</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shabbychef/sadists/issues">https://github.com/shabbychef/sadists/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the density, distribution, quantile and generation functions of some obscure probability 
    distributions, including the doubly non-central t, F, Beta, and Eta distributions; 
    the lambda-prime and K-prime; the upsilon distribution; the (weighted) sum of 
    non-central chi-squares to a power; the (weighted) sum of log non-central chi-squares;
    the product of non-central chi-squares to powers; the product of doubly non-central
    F variables; the product of independent normals.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>PDQutils (&ge; 0.1.1), hypergeo, orthopolynom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SharpeR, shiny, testthat, ggplot2, xtable, formatR, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shabbychef/sadists">https://github.com/shabbychef/sadists</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'cumulants.r' 'dnbeta.r' 'dneta.r' 'dnf.r' 'dnt.r' 'kprime.r'
'lambdap.r' 'moments.r' 'prodchisqpow.r' 'proddnf.r'
'prodnormal.r' 'runExample.r' 'sadists.r' 'sumchisqpow.r'
'sumlogchisq.r' 'upsilon.r' 'utils.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 16:02:29 UTC; spav</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven E. Pav <a href="https://orcid.org/0000-0002-4197-6195"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sadists'>Some Additional Distributions</h2><span id='topic+sadists'></span><span id='topic+_PACKAGE'></span><span id='topic+sadists-package'></span>

<h3>Description</h3>

<p>Some Additional Distributions.
</p>


<h3>Details</h3>

<p>A collection of distributions which can be approximated via
Edgeworth and Cornish-Fisher expansions
</p>


<h3>Sum of (non-central) chi-square to powers</h3>

<p>Let <code class="reqn">X_i \sim \chi^2\left(\delta_i, \nu_i\right)</code>
be independently distributed non-central chi-squares, where <code class="reqn">\nu_i</code>
are the degrees of freedom, and <code class="reqn">\delta_i</code> are the
non-centrality parameters.  
Let <code class="reqn">w_i</code> and <code class="reqn">p_i</code> be given constants. Suppose
</p>
<p style="text-align: center;"><code class="reqn">Y = \sum_i w_i X_i^{p_i}.</code>
</p>

<p>Then <code class="reqn">Y</code> follows a weighted sum of chi-squares to power distribution. 
The special case where all the <code class="reqn">p_i</code> are one is a 'sum of
chi-squares' distribution; 
The special case where all the <code class="reqn">p_i</code> are one half is a 'sum of
chis' distribution;
</p>


<h3>Lambda Prime</h3>

<p>Introduced by Lecoutre, the lambda prime distribution
finds use in inference on the Sharpe ratio under normal
returns.
Suppose <code class="reqn">y \sim \chi^2\left(\nu\right)</code>, and
<code class="reqn">Z</code> is a standard normal. 
</p>
<p style="text-align: center;"><code class="reqn">T = Z + t \sqrt{y/\nu}</code>
</p>

<p>takes a lambda prime distribution with parameters 
<code class="reqn">\nu, t</code>.
A lambda prime random variable can be viewed as a confidence
variable on a non-central t because 
</p>
<p style="text-align: center;"><code class="reqn">t = \frac{Z' + T}{\sqrt{y/\nu}}</code>
</p>



<h3>Upsilon</h3>

<p>The upsilon distribution generalizes the lambda prime to the
case of the sum of multiple chi variables. That is,
suppose <code class="reqn">y_i \sim \chi^2\left(\nu_i\right)</code>
independently and independently of <code class="reqn">Z</code>, a standard normal. 
Then 
</p>
<p style="text-align: center;"><code class="reqn">T = Z + \sum_i t_i \sqrt{y_i/\nu_i}</code>
</p>

<p>takes an upsilon distribution with parameter vectors
<code class="reqn">[\nu_1, \nu_2, \ldots, \nu_k]', [t_1, t_2, ..., t_k]'</code>.
</p>
<p>The upsilon distribution is used in certain tests of
the Sharpe ratio for independent observations.
</p>


<h3>K Prime</h3>

<p>Introduced by Lecoutre, the K prime family of distributions generalize
the (singly) non-central t, and lambda prime distributions. 
Suppose <code class="reqn">y \sim \chi^2\left(\nu_1\right)</code>, and
<code class="reqn">x \sim t \left(\nu_2, a\sqrt{y/\nu_1}/b\right)</code>.
Then the random variable
</p>
<p style="text-align: center;"><code class="reqn">T = b x</code>
</p>

<p>takes a K prime distribution with parameters 
<code class="reqn">\nu_1, \nu_2, a, b</code>. In Lecoutre's terminology,
<code class="reqn">T \sim K'_{\nu_1, \nu_2}\left(a, b\right)</code>
</p>
<p>Equivalently, we can think of
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{b Z + a \sqrt{\chi^2_{\nu_1} / \nu_1}}{\sqrt{\chi^2_{\nu_2} / \nu_2}}</code>
</p>

<p>where <code class="reqn">Z</code> is a standard normal, and the normal and the (central) chi-squares are
independent of each other. When <code class="reqn">a=0</code> we recover
a central t distribution; 
when <code class="reqn">\nu_1=\infty</code> we recover a rescaled non-central t distribution;
when <code class="reqn">b=0</code>, we get a rescaled square root of a central F
distribution; when <code class="reqn">\nu_2=\infty</code>, we recover a 
Lambda prime distribution.
</p>


<h3>Doubly Noncentral t</h3>

<p>The doubly noncentral t distribution generalizes the (singly)
noncentral t distribution to the case where the numerator is
the square root of a scaled noncentral chi-square distribution.
That is, if 
<code class="reqn">X \sim \mathcal{N}\left(\mu,1\right)</code> independently
of <code class="reqn">Y \sim \chi^2\left(k,\theta\right)</code>, then
the random variable
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{X}{\sqrt{Y/k}}</code>
</p>

<p>takes a doubly non-central t distribution with parameters
<code class="reqn">k, \mu, \theta</code>.
</p>


<h3>Doubly Noncentral F</h3>

<p>The doubly noncentral F distribution generalizes the (singly)
noncentral F distribution to the case where the numerator is
a scaled noncentral chi-square distribution.
That is, if 
<code class="reqn">X \sim \chi^2\left(n_1,\theta_1\right)</code> independently 
of <code class="reqn">Y \sim \chi^2\left(n_2,\theta_2\right)</code>, then
the random variable
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{X / n_1}{Y / n_2}</code>
</p>

<p>takes a doubly non-central F distribution with parameters
<code class="reqn">n_1, n_2, \theta_1, \theta_2</code>.
</p>


<h3>Parameter recycling</h3>

<p>It should be noted that the functions provided by sadists do <em>not</em>
recycle their distribution parameters against the 
<code>x, p, q</code> or <code>n</code> parameters. This is in contrast to the 
common R idiom, and may cause some confusion. This is mostly for reasons
of performance, but also because some of the distributions have vector-valued
parameters; recycling over these would require the user to provide <em>lists</em>
of parameters, which would be unpleasant.
</p>


<h3>Legal Mumbo Jumbo</h3>

<p>sadists is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
</p>


<h3>Note</h3>

<p>This package is maintained as a hobby.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>
<p><strong>Maintainer</strong>: Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a> (<a href="https://orcid.org/0000-0002-4197-6195">ORCID</a>)
</p>


<h3>References</h3>

<p>Lecoutre, Bruno. &quot;Two Useful distributions for Bayesian predictive
procedures under normal models.&quot; Journal of Statistical Planning and
Inference 79, no. 1 (1999): 93-105. 
</p>
<p>Poitevineau, Jacques, and Lecoutre, Bruno. &quot;Implementing Bayesian predictive
procedures: The K-prime and K-square distributions.&quot; Computational Statistics 
and Data Analysis 54, no. 3 (2010): 724-731.  <a href="https://arxiv.org/abs/1003.4890v1">https://arxiv.org/abs/1003.4890v1</a>
</p>
<p>Walck, C. &quot;Handbook on Statistical Distributions for experimentalists.&quot;
1996. 
<a href="https://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf">https://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/shabbychef/sadists">https://github.com/shabbychef/sadists</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shabbychef/sadists/issues">https://github.com/shabbychef/sadists/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dnbeta'>The doubly non-central Beta distribution.</h2><span id='topic+dnbeta'></span><span id='topic+ddnbeta'></span><span id='topic+pdnbeta'></span><span id='topic+qdnbeta'></span><span id='topic+rdnbeta'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the doubly non-central Beta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddnbeta(x, df1, df2, ncp1, ncp2, log = FALSE, order.max=6)

pdnbeta(q, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

qdnbeta(p, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

rdnbeta(n, df1, df2, ncp1, ncp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnbeta_+3A_x">x</code>, <code id="dnbeta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_df1">df1</code>, <code id="dnbeta_+3A_df2">df2</code></td>
<td>
<p>the degrees of freedom for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_ncp1">ncp1</code>, <code id="dnbeta_+3A_ncp2">ncp2</code></td>
<td>
<p>the non-centrality parameters for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="dnbeta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i \sim \chi^2\left(\delta_i,\nu_i\right)</code>
be independent non-central chi-squares for <code class="reqn">i=1,2</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">Y = \frac{x_1}{x_1 + x_2}</code>
</p>

<p>takes a doubly non-central Beta distribution with degrees of freedom
<code class="reqn">\nu_1, \nu_2</code> and non-centrality parameters
<code class="reqn">\delta_1,\delta_2</code>.
</p>


<h3>Value</h3>

<p><code>ddnbeta</code> gives the density, <code>pdnbeta</code> gives the 
distribution function, <code>qdnbeta</code> gives the quantile function, 
and <code>rdnbeta</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>(doubly non-central) F distribution functions, 
<code><a href="#topic+ddnf">ddnf</a>, <a href="#topic+pdnf">pdnf</a>, <a href="#topic+qdnf">qdnf</a>, <a href="#topic+rdnf">rdnf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rv &lt;- rdnbeta(500, df1=100,df2=500,ncp1=1.5,ncp2=12)
d1 &lt;- ddnbeta(rv, df1=100,df2=500,ncp1=1.5,ncp2=12)

plot(rv,d1)

p1 &lt;- ddnbeta(rv, df1=100,df2=500,ncp1=1.5,ncp2=12)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qdnbeta(ppoints(length(rv)), df1=100,df2=500,ncp1=1.5,ncp2=12)

qqplot(x=rv,y=q1)

</code></pre>

<hr>
<h2 id='dneta'>The doubly non-central Eta distribution.</h2><span id='topic+dneta'></span><span id='topic+ddneta'></span><span id='topic+pdneta'></span><span id='topic+qdneta'></span><span id='topic+rdneta'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the doubly non-central Eta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddneta(x, df, ncp1, ncp2, log = FALSE, order.max=6)

pdneta(q, df, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

qdneta(p, df, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

rdneta(n, df, ncp1, ncp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dneta_+3A_x">x</code>, <code id="dneta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dneta_+3A_df">df</code></td>
<td>
<p>the degrees of freedom for the denominator chi square.
We do <em>not</em> recycle this versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dneta_+3A_ncp1">ncp1</code>, <code id="dneta_+3A_ncp2">ncp2</code></td>
<td>
<p>the non-centrality parameters for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.
Note that the sign of <code>ncp1</code> is important, while
<code>ncp2</code> must be non-negative.</p>
</td></tr>
<tr><td><code id="dneta_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="dneta_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="dneta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dneta_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dneta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="dneta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">Z</code> is a normal with mean <code class="reqn">\delta_1</code>,
and standard deviation 1, independent of 
<code class="reqn">X \sim \chi^2\left(\delta_2,\nu_2\right)</code>,
a non-central chi-square with <code class="reqn">\nu_2</code> degrees of freedom
and non-centrality parameter <code class="reqn">\delta_2</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">Y = \frac{Z}{\sqrt{Z^2 + X}}</code>
</p>

<p>takes a doubly non-central Eta distribution with 
<code class="reqn">\nu_2</code> degrees of freedom and non-centrality parameters
<code class="reqn">\delta_1,\delta_2</code>. The <em>square</em> of
a doubly non-central Eta is a doubly non-central Beta variate.
</p>


<h3>Value</h3>

<p><code>ddneta</code> gives the density, <code>pdneta</code> gives the 
distribution function, <code>qdneta</code> gives the quantile function, 
and <code>rdneta</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>(doubly non-central) t distribution functions, 
<code><a href="#topic+ddnt">ddnt</a>, <a href="#topic+pdnt">pdnt</a>, <a href="#topic+qdnt">qdnt</a>, <a href="#topic+rdnt">rdnt</a></code>.
</p>
<p>(doubly non-central) Beta distribution functions, 
<code><a href="#topic+ddnbeta">ddnbeta</a>, <a href="#topic+pdnbeta">pdnbeta</a>, <a href="#topic+qdnbeta">qdnbeta</a>, <a href="#topic+rdnbeta">rdnbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rv &lt;- rdneta(500, df=100,ncp1=1.5,ncp2=12)
d1 &lt;- ddneta(rv, df=100,ncp1=1.5,ncp2=12)

plot(rv,d1)

p1 &lt;- ddneta(rv, df=100,ncp1=1.5,ncp2=12)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qdneta(ppoints(length(rv)), df=100,ncp1=1.5,ncp2=12)

qqplot(x=rv,y=q1)

</code></pre>

<hr>
<h2 id='dnf'>The doubly non-central F distribution.</h2><span id='topic+dnf'></span><span id='topic+ddnf'></span><span id='topic+pdnf'></span><span id='topic+qdnf'></span><span id='topic+rdnf'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the doubly non-central F distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddnf(x, df1, df2, ncp1, ncp2, log = FALSE, order.max=6)

pdnf(q, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

qdnf(p, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

rdnf(n, df1, df2, ncp1, ncp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnf_+3A_x">x</code>, <code id="dnf_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnf_+3A_df1">df1</code>, <code id="dnf_+3A_df2">df2</code></td>
<td>
<p>the degrees of freedom for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnf_+3A_ncp1">ncp1</code>, <code id="dnf_+3A_ncp2">ncp2</code></td>
<td>
<p>the non-centrality parameters for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnf_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="dnf_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="dnf_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dnf_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dnf_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="dnf_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i \sim \chi^2\left(\delta_i,\nu_i\right)</code>
be independent non-central chi-squares for <code class="reqn">i=1,2</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">Y = \frac{x_1/\nu_1}{x_2/\nu_2}</code>
</p>

<p>takes a doubly non-central F distribution with degrees of freedom
<code class="reqn">\nu_1, \nu_2</code> and non-centrality parameters
<code class="reqn">\delta_1,\delta_2</code>.
</p>


<h3>Value</h3>

<p><code>ddnf</code> gives the density, <code>pdnf</code> gives the 
distribution function, <code>qdnf</code> gives the quantile function, 
and <code>rdnf</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>(singly non-central) F distribution functions, 
<code><a href="stats.html#topic+df">df</a>, <a href="stats.html#topic+pf">pf</a>, <a href="stats.html#topic+qf">qf</a>, <a href="stats.html#topic+rf">rf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rv &lt;- rdnf(500, df1=100,df2=500,ncp1=1.5,ncp2=12)
d1 &lt;- ddnf(rv, df1=100,df2=500,ncp1=1.5,ncp2=12)

plot(rv,d1)

p1 &lt;- ddnf(rv, df1=100,df2=500,ncp1=1.5,ncp2=12)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qdnf(ppoints(length(rv)), df1=100,df2=500,ncp1=1.5,ncp2=12)

qqplot(x=rv,y=q1)

</code></pre>

<hr>
<h2 id='dnt'>The doubly non-central t distribution.</h2><span id='topic+dnt'></span><span id='topic+ddnt'></span><span id='topic+pdnt'></span><span id='topic+qdnt'></span><span id='topic+rdnt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the doubly non-central t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddnt(x, df, ncp1, ncp2, log = FALSE, order.max=6)

pdnt(q, df, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

qdnt(p, df, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=6)

rdnt(n, df, ncp1, ncp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnt_+3A_x">x</code>, <code id="dnt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dnt_+3A_df">df</code></td>
<td>
<p>the degrees of freedom for the denominator, <code class="reqn">\nu</code>.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnt_+3A_ncp1">ncp1</code>, <code id="dnt_+3A_ncp2">ncp2</code></td>
<td>
<p>the non-centrality parameters for the numerator and denominator,
respectively, <code class="reqn">\mu</code> and <code class="reqn">\theta</code>
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="dnt_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="dnt_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="dnt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dnt_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dnt_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="dnt_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z \sim \mathcal{N}\left(\mu,1\right)</code> independently
of <code class="reqn">X \sim \chi^2\left(\theta,\nu\right)</code>. The 
random variable
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{Z}{\sqrt{X/\nu}}</code>
</p>

<p>takes a <em>doubly non-central t distribution</em> with parameters
<code class="reqn">\nu, \mu, \theta</code>.
</p>


<h3>Value</h3>

<p><code>ddnt</code> gives the density, <code>pdnt</code> gives the 
distribution function, <code>qdnt</code> gives the quantile function, 
and <code>rdnt</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Krishnan, Marakatha. &quot;Series Representations of the Doubly Noncentral
t-Distribution.&quot; Journal of the American Statistical Association 63, 
no. 323 (1968): 1004-1012.
</p>


<h3>See Also</h3>

<p>t distribution functions, <code><a href="stats.html#topic+dt">dt</a>, <a href="stats.html#topic+pt">pt</a>, <a href="stats.html#topic+qt">qt</a>, <a href="stats.html#topic+rt">rt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rvs &lt;- rdnt(128, 20, 1, 1)
dvs &lt;- ddnt(rvs, 20, 1, 1)
pvs.H0 &lt;- pdnt(rvs, 20, 0, 1)
pvs.HA &lt;- pdnt(rvs, 20, 1, 1)

plot(ecdf(pvs.H0))
plot(ecdf(pvs.HA))

# compare to singly non-central
dv1 &lt;- ddnt(1, df=10, ncp1=5, ncp2=0, log=FALSE)
dv2 &lt;- dt(1, df=10, ncp=5, log=FALSE)
pv1 &lt;- pdnt(1, df=10, ncp1=5, ncp2=0, log.p=FALSE)
pv11 &lt;- pdnt(1, df=10, ncp1=5, ncp2=0.001, log.p=FALSE)
v2 &lt;- pt(1, df=10, ncp=5, log.p=FALSE)

q1 &lt;- qdnt(pv1, df=10, ncp1=5, ncp2=0, log.p=FALSE)
</code></pre>

<hr>
<h2 id='kprime'>The K prime distribution.</h2><span id='topic+kprime'></span><span id='topic+dkprime'></span><span id='topic+pkprime'></span><span id='topic+qkprime'></span><span id='topic+rkprime'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the K prime distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkprime(x, v1, v2, a, b = 1, order.max=6, log = FALSE)

pkprime(q, v1, v2, a, b = 1, order.max=6, lower.tail = TRUE, log.p = FALSE)

qkprime(p, v1, v2, a, b = 1, order.max=6, lower.tail = TRUE, log.p = FALSE)

rkprime(n, v1, v2, a, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kprime_+3A_x">x</code>, <code id="kprime_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="kprime_+3A_v1">v1</code></td>
<td>
<p>the degrees of freedom in the numerator chisquare. When
(positive) infinite, we recover a non-central t 
distribution with <code>v2</code> degrees of freedom and non-centrality
parameter <code>a</code>, scaled by <code>b</code>.
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_v2">v2</code></td>
<td>
<p>the degrees of freedom in the denominator chisquare.
When equal to infinity, we recover the Lambda prime distribution.
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_a">a</code></td>
<td>
<p>the non-centrality scaling parameter. When equal to zero,
we recover the (central) t distribution.
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_b">b</code></td>
<td>
<p>the scaling parameter.
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="kprime_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kprime_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="kprime_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="kprime_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y \sim \chi^2\left(\nu_1\right)</code>, and
<code class="reqn">x \sim t \left(\nu_2, a\sqrt{y/\nu_1}/b\right)</code>.
Then the random variable
</p>
<p style="text-align: center;"><code class="reqn">T = b x</code>
</p>

<p>takes a K prime distribution with parameters 
<code class="reqn">\nu_1, \nu_2, a, b</code>. In Lecoutre's terminology,
<code class="reqn">T \sim K'_{\nu_1, \nu_2}\left(a, b\right)</code>
</p>
<p>Equivalently, we can think of
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{b Z + a \sqrt{\chi^2_{\nu_1} / \nu_1}}{\sqrt{\chi^2_{\nu_2} / \nu_2}}</code>
</p>

<p>where <code class="reqn">Z</code> is a standard normal, and the normal and the (central) chi-squares are
independent of each other. When <code class="reqn">a=0</code> we recover
a central t distribution; 
when <code class="reqn">\nu_1=\infty</code> we recover a rescaled non-central t distribution;
when <code class="reqn">b=0</code>, we get a rescaled square root of a central F
distribution; when <code class="reqn">\nu_2=\infty</code>, we recover a 
Lambda prime distribution.
</p>


<h3>Value</h3>

<p><code>dkprime</code> gives the density, <code>pkprime</code> gives the 
distribution function, <code>qkprime</code> gives the quantile function, 
and <code>rkprime</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Lecoutre, Bruno. &quot;Two Useful distributions for Bayesian predictive
procedures under normal models.&quot; Journal of Statistical Planning and
Inference 79, no. 1 (1999): 93-105. 
</p>
<p>Poitevineau, Jacques, and Lecoutre, Bruno. &quot;Implementing Bayesian predictive
procedures: The K-prime and K-square distributions.&quot; Computational Statistics 
and Data Analysis 54, no. 3 (2010): 724-731.  <a href="https://arxiv.org/abs/1003.4890v1">https://arxiv.org/abs/1003.4890v1</a>
</p>


<h3>See Also</h3>

<p>t distribution functions, <code><a href="stats.html#topic+dt">dt</a>, <a href="stats.html#topic+pt">pt</a>, <a href="stats.html#topic+qt">qt</a>, <a href="stats.html#topic+rt">rt</a></code>,
lambda prime distribution functions, <code><a href="#topic+dlambdap">dlambdap</a>, <a href="#topic+plambdap">plambdap</a>, <a href="#topic+qlambdap">qlambdap</a>, <a href="#topic+rlambdap">rlambdap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- dkprime(1, 50, 20, a=0.01)
d2 &lt;- dkprime(1, 50, 20, a=0.0001)
d3 &lt;- dkprime(1, 50, 20, a=0)
d4 &lt;- dkprime(1, 10000, 20, a=1)
d5 &lt;- dkprime(1, Inf, 20, a=1)

</code></pre>

<hr>
<h2 id='lambdap'>The lambda prime distribution.</h2><span id='topic+lambdap'></span><span id='topic+dlambdap'></span><span id='topic+plambdap'></span><span id='topic+qlambdap'></span><span id='topic+rlambdap'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the lambda prime distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlambdap(x, df, t, log = FALSE, order.max=6)

plambdap(q, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

qlambdap(p, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

rlambdap(n, df, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdap_+3A_x">x</code>, <code id="lambdap_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_df">df</code></td>
<td>
<p>the degrees of freedom in the chi square. 
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_t">t</code></td>
<td>
<p>the scaling parameter on the chi.
This is not recycled against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="lambdap_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y \sim \chi^2\left(\nu\right)</code>, and
<code class="reqn">Z</code> is a standard normal. 
</p>
<p style="text-align: center;"><code class="reqn">T = Z + t \sqrt{y/\nu}</code>
</p>

<p>takes a lambda prime distribution with parameters 
<code class="reqn">\nu, t</code>.
A lambda prime random variable can be viewed as a confidence
level on a non-central t because 
</p>
<p style="text-align: center;"><code class="reqn">t = \frac{Z' + T}{\sqrt{y/\nu}}</code>
</p>



<h3>Value</h3>

<p><code>dlambdap</code> gives the density, <code>plambdap</code> gives the 
distribution function, <code>qlambdap</code> gives the quantile function, 
and <code>rlambdap</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Lecoutre, Bruno. &quot;Another look at confidence intervals for the noncentral t distribution.&quot; 
Journal of Modern Applied Statistical Methods 6, no. 1 (2007): 107&ndash;116.
<a href="https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm">https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm</a>
</p>
<p>Lecoutre, Bruno. &quot;Two useful distributions for Bayesian predictive procedures under normal models.&quot;
Journal of Statistical Planning and Inference 79  (1999): 93&ndash;105.
</p>


<h3>See Also</h3>

<p>t distribution functions, <code><a href="stats.html#topic+dt">dt</a>, <a href="stats.html#topic+pt">pt</a>, <a href="stats.html#topic+qt">qt</a>, <a href="stats.html#topic+rt">rt</a></code>,
K prime distribution functions, <code><a href="#topic+dkprime">dkprime</a>, <a href="#topic+pkprime">pkprime</a>, <a href="#topic+qkprime">qkprime</a>, <a href="#topic+rkprime">rkprime</a></code>,
upsilon distribution functions, <code><a href="#topic+dupsilon">dupsilon</a>, <a href="#topic+pupsilon">pupsilon</a>, <a href="#topic+qupsilon">qupsilon</a>, <a href="#topic+rupsilon">rupsilon</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rv &lt;- rlambdap(100, 50, t=0.01)
d1 &lt;- dlambdap(1, 50, t=0.01)
pv &lt;- plambdap(rv, 50, t=0.01)
qv &lt;- qlambdap(ppoints(length(rv)), 50, t=1)

</code></pre>

<hr>
<h2 id='prodchisqpow'>The product of (non-central) chi-squares raised to powers distribution.</h2><span id='topic+prodchisqpow'></span><span id='topic+dprodchisqpow'></span><span id='topic+pprodchisqpow'></span><span id='topic+qprodchisqpow'></span><span id='topic+rprodchisqpow'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the distribution of the product of non-central
chi-squares taken to powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprodchisqpow(x, df, ncp=0, pow=1, log = FALSE, order.max=5)

pprodchisqpow(q, df, ncp=0, pow=1, lower.tail = TRUE, log.p = FALSE, order.max=5)

qprodchisqpow(p, df, ncp=0, pow=1, lower.tail = TRUE, log.p = FALSE, order.max=5)

rprodchisqpow(n, df, ncp=0, pow=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodchisqpow_+3A_x">x</code>, <code id="prodchisqpow_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_df">df</code></td>
<td>
<p>the vector of degrees of freedom. 
This is recycled against the <code>ncp, pow</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_ncp">ncp</code></td>
<td>
<p>the vector of non-centrality parameters. 
This is recycled against the <code>df, pow</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_pow">pow</code></td>
<td>
<p>the vector of the power parameters. 
This is recycled against the <code>df, ncp</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="prodchisqpow_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_i \sim \chi^2\left(\delta_i, \nu_i\right)</code>
be independently distributed non-central chi-squares, where <code class="reqn">\nu_i</code>
are the degrees of freedom, and <code class="reqn">\delta_i</code> are the
non-centrality parameters.  
Let <code class="reqn">p_i</code> be given constants. Suppose
</p>
<p style="text-align: center;"><code class="reqn">Y = \prod_i X_i^{p_i}.</code>
</p>

<p>Then <code class="reqn">Y</code> follows a product of chi-squares to power distribution.
</p>


<h3>Value</h3>

<p><code>dprodchisqpow</code> gives the density, <code>pprodchisqpow</code> gives the 
distribution function, <code>qprodchisqpow</code> gives the quantile function, 
and <code>rprodchisqpow</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>
<p>The PDQ functions are computed by translation of the 
sum of log chi-squares distribution functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, Steven. Moments of the log non-central chi-square distribution.
<a href="https://arxiv.org/abs/1503.06266">https://arxiv.org/abs/1503.06266</a>
</p>


<h3>See Also</h3>

<p>The sum of log of chi-squares distribution,
<code><a href="#topic+dsumlogchisq">dsumlogchisq</a></code>,
<code><a href="#topic+psumlogchisq">psumlogchisq</a></code>,
<code><a href="#topic+qsumlogchisq">qsumlogchisq</a></code>,
<code><a href="#topic+rsumlogchisq">rsumlogchisq</a></code>,
The upsilon distribution, 
<code><a href="#topic+dupsilon">dupsilon</a></code>,
<code><a href="#topic+pupsilon">pupsilon</a></code>,
<code><a href="#topic+qupsilon">qupsilon</a></code>,
<code><a href="#topic+rupsilon">rupsilon</a></code>.
The sum of chi-square powers distribution, 
<code><a href="#topic+dsumchisqpow">dsumchisqpow</a></code>,
<code><a href="#topic+psumchisqpow">psumchisqpow</a></code>,
<code><a href="#topic+qsumchisqpow">qsumchisqpow</a></code>,
<code><a href="#topic+rsumchisqpow">rsumchisqpow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- c(100,20,10)
ncp &lt;- c(5,3,1)
pow &lt;- c(1,0.5,1)
rvs &lt;- rprodchisqpow(128, df, ncp, pow)
dvs &lt;- dprodchisqpow(rvs, df, ncp, pow)
qvs &lt;- pprodchisqpow(rvs, df, ncp, pow)
pvs &lt;- qprodchisqpow(ppoints(length(rvs)), df, ncp, pow)
</code></pre>

<hr>
<h2 id='proddnf'>The product of multiple doubly non-central F's distribution.</h2><span id='topic+proddnf'></span><span id='topic+dproddnf'></span><span id='topic+pproddnf'></span><span id='topic+qproddnf'></span><span id='topic+rproddnf'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the product of multiple independent 
doubly non-central F variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dproddnf(x, df1, df2, ncp1, ncp2, log = FALSE, order.max=4)

pproddnf(q, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=4)

qproddnf(p, df1, df2, ncp1, ncp2, lower.tail = TRUE, log.p = FALSE, order.max=4)

rproddnf(n, df1, df2, ncp1, ncp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proddnf_+3A_x">x</code>, <code id="proddnf_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_df1">df1</code>, <code id="proddnf_+3A_df2">df2</code></td>
<td>
<p>the vectors of the degrees of freedom for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_ncp1">ncp1</code>, <code id="proddnf_+3A_ncp2">ncp2</code></td>
<td>
<p>the vectors of the non-centrality parameters for the numerator and denominator.
We do <em>not</em> recycle these versus the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="proddnf_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let 
</p>
<p style="text-align: center;"><code class="reqn">x_j \sim F\left(\delta_{1,j},\delta_{2,j},\nu_{1,j},\nu_{2,j}\right)</code>
</p>

<p>be independent doubly non-central F variates with non-centrality parameters
<code class="reqn">\delta_{i,j}</code> and degrees of freedom
<code class="reqn">\nu_{i,j}</code> for <code class="reqn">i=1,2,\ldots,I</code> and 
<code class="reqn">j=1,2</code>.
Then 
</p>
<p style="text-align: center;"><code class="reqn">Y = \prod_j x_j</code>
</p>

<p>takes a product of doubly non-central F's distribution. We take the
parameters of this distribution as the four <code class="reqn">I</code> length vectors
of the two degrees of freedom and the two non-centrality parameters.
</p>


<h3>Value</h3>

<p><code>dproddnf</code> gives the density, <code>pproddnf</code> gives the 
distribution function, <code>qproddnf</code> gives the quantile function, 
and <code>rproddnf</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>
<p>The PDQ functions are computed by translation of the 
sum of log chi-squares distribution functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, Steven. Moments of the log non-central chi-square distribution.
<a href="https://arxiv.org/abs/1503.06266">https://arxiv.org/abs/1503.06266</a>
</p>


<h3>See Also</h3>

<p>The sum of log of chi-squares distribution,
<code><a href="#topic+dsumlogchisq">dsumlogchisq</a></code>,
<code><a href="#topic+psumlogchisq">psumlogchisq</a></code>,
<code><a href="#topic+qsumlogchisq">qsumlogchisq</a></code>,
<code><a href="#topic+rsumlogchisq">rsumlogchisq</a></code>.
(doubly non-central) F distribution functions, 
<code><a href="#topic+ddnf">ddnf</a></code>,
<code><a href="#topic+pdnf">pdnf</a></code>, 
<code><a href="#topic+qdnf">qdnf</a></code>, 
<code><a href="#topic+rdnf">rdnf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- c(10,20,5)
df2 &lt;- c(1000,500,150)
ncp1 &lt;- c(1,0,2.5)
ncp2 &lt;- c(0,1.5,5)

rv &lt;- rproddnf(500, df1=df1,df2=df2,ncp1=ncp1,ncp2=ncp2)
d1 &lt;- dproddnf(rv, df1=df1,df2=df2,ncp1=ncp1,ncp2=ncp2)

plot(rv,d1)

p1 &lt;- pproddnf(rv, df1=df1,df2=df2,ncp1=ncp1,ncp2=ncp2)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qproddnf(ppoints(length(rv)), df1=df1,df2=df2,ncp1=ncp1,ncp2=ncp2)

qqplot(x=rv,y=q1)

</code></pre>

<hr>
<h2 id='prodnormal'>The product of normal random variates.</h2><span id='topic+prodnormal'></span><span id='topic+dprodnormal'></span><span id='topic+pprodnormal'></span><span id='topic+qprodnormal'></span><span id='topic+rprodnormal'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the distribution of the product of indepdendent
normal random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprodnormal(x, mu, sigma, log = FALSE, order.max=5)

pprodnormal(q, mu, sigma, lower.tail = TRUE, log.p = FALSE, order.max=5)

qprodnormal(p, mu, sigma, lower.tail = TRUE, log.p = FALSE, order.max=5)

rprodnormal(n, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodnormal_+3A_x">x</code>, <code id="prodnormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_mu">mu</code></td>
<td>
<p>the vector of means.
This is recycled against the <code>sigma</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_sigma">sigma</code></td>
<td>
<p>the vector of standard deviations.
This is recycled against the <code>mu</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="prodnormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z_i \sim \mathcal{N}\left(\mu_i, \sigma_i^2\right)</code>
be independently distributed normal variates, with means <code class="reqn">\mu_i</code>
and variances <code class="reqn">\sigma_i^2</code>.
Suppose </p>
<p style="text-align: center;"><code class="reqn">Y = \prod_i Z_i.</code>
</p>

<p>Then <code class="reqn">Y</code> follows a product of normals distribution.
</p>


<h3>Value</h3>

<p><code>dprodnormal</code> gives the density, <code>pprodnormal</code> gives the 
distribution function, <code>qprodnormal</code> gives the quantile function, 
and <code>rprodnormal</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(100,20,10)
sigma &lt;- c(10,50,10)
rvs &lt;- rprodnormal(128, mu, sigma)
dvs &lt;- dprodnormal(rvs, mu, sigma)
qvs &lt;- pprodnormal(rvs, mu, sigma)
pvs &lt;- qprodnormal(ppoints(length(rvs)), mu, sigma)
</code></pre>

<hr>
<h2 id='runExample'>Run Shiny Application</h2><span id='topic+runExample'></span>

<h3>Description</h3>

<p>Runs a shiny application which draws from the given distributions, then
illustrates the fidelity of the density, CDF, and quantile functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runExample(port=NULL,launch.browser=TRUE,
 host=getOption('shiny.host','127.0.0.1'),display.mode='auto')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runExample_+3A_port">port</code></td>
<td>
<p>The TCP port that the application should listen on. If the
<code>port</code> is not specified, and the <code>shiny.port</code> option is set (with
<code>options(shiny.port = XX)</code>), then that port will be used. Otherwise,
use a random port.</p>
</td></tr>
<tr><td><code id="runExample_+3A_launch.browser">launch.browser</code></td>
<td>
<p>If true, the system's default web browser will be
launched automatically after the app is started. Defaults to true in
interactive sessions only. This value of this parameter can also be a
function to call with the application's URL.</p>
</td></tr>
<tr><td><code id="runExample_+3A_host">host</code></td>
<td>
<p>The IPv4 address that the application should listen on. Defaults
to the <code>shiny.host</code> option, if set, or <code>"127.0.0.1"</code> if not. See
Details.</p>
</td></tr>
<tr><td><code id="runExample_+3A_display.mode">display.mode</code></td>
<td>
<p>The mode in which to display the application. If set to
the value <code>"showcase"</code>, shows application code and metadata from a
<code>DESCRIPTION</code> file in the application directory alongside the
application. If set to <code>"normal"</code>, displays the application normally.
Defaults to <code>"auto"</code>, which displays the application in the mode given
in its <code>DESCRIPTION</code> file, if any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Launches shiny applications, and optionally, your system's web browser.
Draws are taken from the random variable, and d-d, q-q, and p-p plots
are available.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Attali, D. &quot;Supplementing your R package with a shiny app.&quot;
<a href="https://deanattali.com/2015/04/21/r-package-shiny-app/">https://deanattali.com/2015/04/21/r-package-shiny-app/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runExample(launch.browser=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='sadists-NEWS'>News for package 'sadists'</h2><span id='topic+sadists-NEWS'></span>

<h3>Description</h3>

<p>History of the 'sadists' package.
</p>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.5 (2023-08-20)</h3>


<ul>
<li><p> CRAN emergency release.
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.4 (2020-06-23)</h3>


<ul>
<li><p> CRAN emergency release.
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.3 (2017-03-19)</h3>


<ul>
<li><p> add product of normals distribution.
</p>
</li>
<li><p> move github figures to location CRAN understands.
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.2 (2016-03-03) </h3>


<ul>
<li><p> work around bad <code>rchisq</code> when <code class="reqn">df=0=ncp</code> (?)
</p>
</li>
<li><p> incompatibilities in vignette with ggplot2 release.
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.1 (2015-06-12) </h3>


<ul>
<li><p> shiny app (h/t Dean Attali).
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Version 0.2.0 (2015-04-01) </h3>


<ul>
<li><p> add doubly non-central Beta and Eta distributions.
</p>
</li>
<li><p> add (sum of) log chi-square distribution.
</p>
</li>
<li><p> have products of chi-square depend on transform of this distribution.
</p>
</li></ul>



<h3><a href="https://github.com/shabbychef/sadists"></a> Initial Version 0.1.0 (2015-03-07) </h3>


<ul>
<li><p> first CRAN release.
</p>
</li></ul>


<hr>
<h2 id='sumchisqpow'>The sum of (non-central) chi-squares raised to powers distribution.</h2><span id='topic+sumchisqpow'></span><span id='topic+dsumchisqpow'></span><span id='topic+psumchisqpow'></span><span id='topic+qsumchisqpow'></span><span id='topic+rsumchisqpow'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the distribution of the weighted sum of non-central
chi-squares taken to powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsumchisqpow(x, wts, df, ncp=0, pow=1, log = FALSE, order.max=6)

psumchisqpow(q, wts, df, ncp=0, pow=1, lower.tail = TRUE, log.p = FALSE, order.max=6)

qsumchisqpow(p, wts, df, ncp=0, pow=1, lower.tail = TRUE, log.p = FALSE, order.max=6)

rsumchisqpow(n, wts, df, ncp=0, pow=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumchisqpow_+3A_x">x</code>, <code id="sumchisqpow_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_wts">wts</code></td>
<td>
<p>the vector of weights. 
This is recycled against the <code>df, ncp, pow</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_df">df</code></td>
<td>
<p>the vector of degrees of freedom. 
This is recycled against the <code>wts, ncp, pow</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_ncp">ncp</code></td>
<td>
<p>the vector of non-centrality parameters. 
This is recycled against the <code>wts, df, pow</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_pow">pow</code></td>
<td>
<p>the vector of the power parameters. 
This is recycled against the <code>wts, df, ncp</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="sumchisqpow_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_i \sim \chi^2\left(\delta_i, \nu_i\right)</code>
be independently distributed non-central chi-squares, where <code class="reqn">\nu_i</code>
are the degrees of freedom, and <code class="reqn">\delta_i</code> are the
non-centrality parameters.  
Let <code class="reqn">w_i</code> and <code class="reqn">p_i</code> be given constants. Suppose
</p>
<p style="text-align: center;"><code class="reqn">Y = \sum_i w_i X_i^{p_i}.</code>
</p>

<p>Then <code class="reqn">Y</code> follows a weighted sum of chi-squares to power distribution.
</p>


<h3>Value</h3>

<p><code>dsumchisqpow</code> gives the density, <code>psumchisqpow</code> gives the 
distribution function, <code>qsumchisqpow</code> gives the quantile function, 
and <code>rsumchisqpow</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>
<p>The 'sum of chisquare power' distribution does <em>not</em> generalize
the 'chi-bar-square' distribution, whose <em>density</em> is the sum of
chi-square densities.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The upsilon distribution, 
<code><a href="#topic+dupsilon">dupsilon</a>,<a href="#topic+pupsilon">pupsilon</a>,<a href="#topic+qupsilon">qupsilon</a>,<a href="#topic+rupsilon">rupsilon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wts &lt;- c(1,-3,4)
df &lt;- c(100,20,10)
ncp &lt;- c(5,3,1)
pow &lt;- c(1,0.5,1)
rvs &lt;- rsumchisqpow(128, wts, df, ncp, pow)
dvs &lt;- dsumchisqpow(rvs, wts, df, ncp, pow)
qvs &lt;- psumchisqpow(rvs, wts, df, ncp, pow)
pvs &lt;- qsumchisqpow(ppoints(length(rvs)), wts, df, ncp, pow)
</code></pre>

<hr>
<h2 id='sumlogchisq'>The sum of the logs of (non-central) chi-squares distribution.</h2><span id='topic+sumlogchisq'></span><span id='topic+dsumlogchisq'></span><span id='topic+psumlogchisq'></span><span id='topic+qsumlogchisq'></span><span id='topic+rsumlogchisq'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the distribution of the weighted sum of logs of
non-central chi-squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsumlogchisq(x, wts, df, ncp=0, log = FALSE, order.max=6)

psumlogchisq(q, wts, df, ncp=0, lower.tail = TRUE, log.p = FALSE, order.max=6)

qsumlogchisq(p, wts, df, ncp=0, lower.tail = TRUE, log.p = FALSE, order.max=6)

rsumlogchisq(n, wts, df, ncp=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumlogchisq_+3A_x">x</code>, <code id="sumlogchisq_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_wts">wts</code></td>
<td>
<p>the vector of weights. 
This is recycled against the <code>df, ncp</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_df">df</code></td>
<td>
<p>the vector of degrees of freedom. 
This is recycled against the <code>wts, ncp</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_ncp">ncp</code></td>
<td>
<p>the vector of non-centrality parameters. 
This is recycled against the <code>wts, df</code>, but not against the <code>x,q,p,n</code>.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="sumlogchisq_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X_i \sim \chi^2\left(\delta_i, \nu_i\right)</code>
be independently distributed non-central chi-squares, where <code class="reqn">\nu_i</code>
are the degrees of freedom, and <code class="reqn">\delta_i</code> are the
non-centrality parameters.  
Let <code class="reqn">w_i</code> be given constants. Suppose
</p>
<p style="text-align: center;"><code class="reqn">Y = \sum_i w_i \log X_i.</code>
</p>

<p>Then <code class="reqn">Y</code> follows a weighted sum of log of chi-squares distribution.
</p>


<h3>Value</h3>

<p><code>dsumlogchisq</code> gives the density, <code>psumlogchisq</code> gives the 
distribution function, <code>qsumlogchisq</code> gives the quantile function, 
and <code>rsumlogchisq</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Pav, Steven. Moments of the log non-central chi-square distribution.
<a href="https://arxiv.org/abs/1503.06266">https://arxiv.org/abs/1503.06266</a>
</p>


<h3>See Also</h3>

<p>The product of chi-squares to a power,
<code><a href="#topic+dprodchisqpow">dprodchisqpow</a></code>,
<code><a href="#topic+pprodchisqpow">pprodchisqpow</a></code>,
<code><a href="#topic+qprodchisqpow">qprodchisqpow</a></code>,
<code><a href="#topic+rprodchisqpow">rprodchisqpow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wts &lt;- c(1,-3,4)
df &lt;- c(100,20,10)
ncp &lt;- c(5,3,1)
rvs &lt;- rsumlogchisq(128, wts, df, ncp)
dvs &lt;- dsumlogchisq(rvs, wts, df, ncp)
qvs &lt;- psumlogchisq(rvs, wts, df, ncp)
pvs &lt;- qsumlogchisq(ppoints(length(rvs)), wts, df, ncp)
</code></pre>

<hr>
<h2 id='upsilon'>The upsilon distribution.</h2><span id='topic+upsilon'></span><span id='topic+dupsilon'></span><span id='topic+pupsilon'></span><span id='topic+qupsilon'></span><span id='topic+rupsilon'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the upsilon distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupsilon(x, df, t, log = FALSE, order.max=6)

pupsilon(q, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

qupsilon(p, df, t, lower.tail = TRUE, log.p = FALSE, order.max=6)

rupsilon(n, df, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upsilon_+3A_x">x</code>, <code id="upsilon_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_df">df</code></td>
<td>
<p>the degrees of freedom in the chi square. a vector. we do
<em>not</em> vectorize over this variable.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_t">t</code></td>
<td>
<p>the scaling parameter on the chi. a vector. should be the same
length as <code>df</code>. we do <em>not</em> vectorize over this variable.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities <code class="reqn">f</code> are given 
as <code class="reqn">\mbox{log}(f)</code>.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_order.max">order.max</code></td>
<td>
<p>the order to use in the approximate density,
distribution, and quantile computations, via the Gram-Charlier,
Edeworth, or Cornish-Fisher expansion.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given 
as <code class="reqn">\mbox{log}(p)</code>.</p>
</td></tr>
<tr><td><code id="upsilon_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x_i \sim \chi^2\left(\nu_i\right)</code>
independently and independently of <code class="reqn">Z</code>, a standard normal. 
Then 
</p>
<p style="text-align: center;"><code class="reqn">\Upsilon = Z + \sum_i t_i \sqrt{x_i/\nu_i}</code>
</p>

<p>takes an upsilon distribution with parameter vectors
<code class="reqn">[\nu_1, \nu_2, \ldots, \nu_k]', [t_1, t_2, ..., t_k]'</code>.
</p>
<p>The upsilon distribution is used in certain tests of
the Sharpe ratio for independent observations, and generalizes
the lambda prime distribution, which can be written as
<code class="reqn">Z + t \sqrt{x/\nu}</code>.
</p>


<h3>Value</h3>

<p><code>dupsilon</code> gives the density, <code>pupsilon</code> gives the 
distribution function, <code>qupsilon</code> gives the quantile function, 
and <code>rupsilon</code> generates random deviates.
</p>
<p>Invalid arguments will result in return value <code>NaN</code> with a warning.
</p>


<h3>Note</h3>

<p>the PDF and CDF are approximated by an Edgeworth expansion; the
quantile function is approximated by a Cornish-Fisher expansion.
</p>
<p>The PDF, CDF, and quantile function are approximated, via
the Edgeworth or Cornish Fisher approximations, which may
not be terribly accurate in the tails of the distribution.
You are warned.
</p>
<p>The distribution parameters are <em>not</em> recycled
with respect to the <code>x, p, q</code> or <code>n</code> parameters,
for, respectively, the density, distribution, quantile
and generation functions. This is for simplicity of
implementation and performance. It is, however, in contrast
to the usual R idiom for dpqr functions.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Lecoutre, Bruno. &quot;Another look at confidence intervals for the noncentral t distribution.&quot; 
Journal of Modern Applied Statistical Methods 6, no. 1 (2007): 107&ndash;116.
<a href="https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm">https://digitalcommons.wayne.edu/cgi/viewcontent.cgi?article=1128&amp;context=jmasm</a>
</p>
<p>Lecoutre, Bruno. &quot;Two useful distributions for Bayesian predictive procedures under normal models.&quot;
Journal of Statistical Planning and Inference 79  (1999): 93&ndash;105.
</p>
<p>Pav, Steven. &quot;Inference on the Sharpe ratio via the upsilon distribution.'
Arxiv (2015). 
<a href="https://arxiv.org/abs/1505.00829">https://arxiv.org/abs/1505.00829</a>
</p>


<h3>See Also</h3>

<p>lambda-prime distribution functions, 
<code><a href="#topic+dlambdap">dlambdap</a>, <a href="#topic+plambdap">plambdap</a>, <a href="#topic+qlambdap">qlambdap</a>, <a href="#topic+rlambdap">rlambdap</a></code>.
Sum of chi-squares to power distribution functions,
<code><a href="#topic+dsumchisqpow">dsumchisqpow</a>, <a href="#topic+psumchisqpow">psumchisqpow</a>, <a href="#topic+qsumchisqpow">qsumchisqpow</a>, <a href="#topic+rsumchisqpow">rsumchisqpow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf &lt;- c(100,30,50)
myt &lt;- c(-1,3,5)
rv &lt;- rupsilon(500, df=mydf, t=myt)
d1 &lt;- dupsilon(rv, df=mydf, t=myt)

plot(rv,d1)

p1 &lt;- pupsilon(rv, df=mydf, t=myt)
# should be nearly uniform:

plot(ecdf(p1))

q1 &lt;- qupsilon(ppoints(length(rv)),df=mydf,t=myt)

qqplot(x=rv,y=q1)


if (require(SharpeR)) {
  ope &lt;- 252
  n.sim &lt;- 500
  n.term &lt;- 3
  set.seed(234234)
  pp &lt;- replicate(n.sim,{
    # these are population parameters 
    a &lt;- rnorm(n.term) 
    psi &lt;- 6 * rnorm(length(a)) / sqrt(ope)
    b &lt;- sum(a * psi)
    df &lt;- 100 + ceiling(200 * runif(length(psi)))
    comm &lt;- 1 / sqrt(sum(a^2 / df))
    cdf &lt;- df - 1
    # now independent draws from the SR distribution:
    x &lt;- rsr(length(df), df, zeta=psi, ope=1)
    # now compute a p-value under the true null
    pupsilon(comm * b,df=cdf,t=comm*a*x) 
  })
  # ought to be uniform:
  plot(ecdf(pp)) 
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
