<!DOCTYPE html><html lang="en-US"><head><title>Help for package rCNV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rCNV}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ad.correct'><p>Correct allele depth values</p></a></li>
<li><a href='#ADnorm'><p>Normalized allele depth example data</p></a></li>
<li><a href='#ADtable'><p>Allele Depth (AD) example data</p></a></li>
<li><a href='#allele.freq'><p>Generate allele frequency table for individuals or populations</p></a></li>
<li><a href='#allele.info'><p>Get allele information for duplicate detection</p></a></li>
<li><a href='#alleleINF'><p>Allele info example data</p></a></li>
<li><a href='#cnv'><p>Find CNVs from deviants</p></a></li>
<li><a href='#cpm.normal'><p>Calculate normalized depth for alleles</p></a></li>
<li><a href='#depthVsSample'><p>Simulate median allele ratios for varying number of samples and depth values</p></a></li>
<li><a href='#dup.plot'><p>Plot classified SNPs into deviants/CNVs and non-deviants/non-CNVs</p></a></li>
<li><a href='#dup.validate'><p>Validate detected deviants/cnvs</p></a></li>
<li><a href='#dupGet'><p>Detect deviants from SNPs; classify SNPs</p></a></li>
<li><a href='#exportVCF'><p>Export VCF files</p></a></li>
<li><a href='#get.miss'><p>Get missingness of individuals in raw vcf</p></a></li>
<li><a href='#gt.format'><p>Format genotype for BayEnv and BayPass</p></a></li>
<li><a href='#h.zygosity'><p>Determine per sample heterozygosity and inbreeding coefficient</p></a></li>
<li><a href='#hetTgen'><p>Generate allele depth or genotype table</p></a></li>
<li><a href='#maf'><p>Remove MAF allele</p></a></li>
<li><a href='#norm.fact'><p>Calculate normalization factor for each sample</p></a></li>
<li><a href='#power.bias'><p>Simulate and plot detection power of bias in allele ratios</p></a></li>
<li><a href='#readVCF'><p>Import VCF file</p></a></li>
<li><a href='#relatedness'><p>Determine pairwise relatedness</p></a></li>
<li><a href='#sig.hets'><p>Identify significantly different heterozygotes from SNPs data</p></a></li>
<li><a href='#sim.als'><p>Simulate Allele Frequencies</p></a></li>
<li><a href='#vcf.stat'><p>Get sequencing quality statistics of raw VCF files</p>
(with GatK generated vcf files only)</a></li>
<li><a href='#vst'><p>Calculate population-wise Vst</p></a></li>
<li><a href='#vstPermutation'><p>Run permutation on Vst</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Detect Copy Number Variants from SNPs Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-20</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Piyal Karunarathne &lt;piyalkarumail@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions in this package will import filtered variant call format (VCF) files of SNPs data and generate data sets to detect copy number variants, visualize them and do downstream analyses with copy number variants(e.g. Environmental association analyses).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, graphics, colorspace, R.utils, qgraph, stringr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), covr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://piyalkarum.github.io/rCNV/">https://piyalkarum.github.io/rCNV/</a>,
<a href="https://cran.r-project.org/package=rCNV">https://cran.r-project.org/package=rCNV</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/piyalkarum/rCNV/issues">https://github.com/piyalkarum/rCNV/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-20 12:14:33 UTC; piyalkaru</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Piyal Karunarathne
    <a href="https://orcid.org/0000-0002-1934-145X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Qiujie Zhou <a href="https://orcid.org/0000-0001-7351-2371"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Klaus Schliep <a href="https://orcid.org/0000-0003-2941-0161"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Pascal Milesi <a href="https://orcid.org/0000-0001-8580-4291"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-20 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ad.correct'>Correct allele depth values</h2><span id='topic+ad.correct'></span>

<h3>Description</h3>

<p>A function to correct depth values with odd number of coverage values due to
sequencing anomalies or miss classification where genotype is homozygous and
depth values indicate heterozygosity.
The function adds a value of one to the allele with the lowest depth value
for when odd number anomalies or make the depth value zero for when
miss-classified. The genotype table must be provided for the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ad.correct(
  het.table,
  gt.table = NULL,
  odd.correct = TRUE,
  verbose = TRUE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ad.correct_+3A_het.table">het.table</code></td>
<td>
<p>allele depth table generated from the function
<code>hetTgen</code></p>
</td></tr>
<tr><td><code id="ad.correct_+3A_gt.table">gt.table</code></td>
<td>
<p>genotype table generated from the function hetTgen</p>
</td></tr>
<tr><td><code id="ad.correct_+3A_odd.correct">odd.correct</code></td>
<td>
<p>logical, to correct for odd number anomalies in AD values.
default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ad.correct_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress. Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ad.correct_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coverage corrected allele depth table similar to the
output of <code>hetTgen</code>
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: adc&lt;-ad.correct(ADtable)

</code></pre>

<hr>
<h2 id='ADnorm'>Normalized allele depth example data</h2><span id='topic+ADnorm'></span>

<h3>Description</h3>

<p>Normalized example SNPs data of Chinook Salmon from Larson et al. 2014
The data has been normalized with TMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ADnorm)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>References</h3>

<p>Larson, W. A., Seeb, L. W., Everett, M. V., Waples, R. K.,
Templin, W. D., &amp; Seeb, J. E. (2014). Genotyping by sequencing resolves
shallow population structure to inform conservation of Chinook salmon
(Oncorhynchus tshawytscha). Evolutionary Applications, 7(3)
</p>

<hr>
<h2 id='ADtable'>Allele Depth (AD) example data</h2><span id='topic+ADtable'></span>

<h3>Description</h3>

<p>Example SNPs data of Chinook Salmon from Larson et al. et al. 2014.
The data contains only a partial snps data set of RadSeq data after
filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ADtable)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 3000 rows and 109 columns.
</p>


<h3>References</h3>


<ul>
<li><p>Larson, W. A., Seeb, L. W., Everett, M. V., Waples, R. K., Templin,
W. D., &amp; Seeb, J. E. (2014). Genotyping by sequencing resolves shallow
population structure to inform conservation of Chinook salmon
(Oncorhynchus tshawytscha). Evolutionary Applications, 7(3), 355-369.
</p>
</li>
<li><p>McKinney, G. J., Waples, R. K., Seeb, L. W., &amp; Seeb, J. E. (2017).
Paralogs are revealed by proportion of heterozygotes and deviations in
read ratios in genotyping by sequencing data from natural populations.
Molecular Ecology Resources, 17(4)
</p>
</li></ul>


<hr>
<h2 id='allele.freq'>Generate allele frequency table for individuals or populations</h2><span id='topic+allele.freq'></span>

<h3>Description</h3>

<p>Get alternative allele frequency across all individuals per SNP from the
genotype or allele depth tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele.freq(gtt, f.typ = c("pop", "ind"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allele.freq_+3A_gtt">gtt</code></td>
<td>
<p>a list or data frame of genotype and/or allele depth table produced from <code>hetTgen</code> (or similar)</p>
</td></tr>
<tr><td><code id="allele.freq_+3A_f.typ">f.typ</code></td>
<td>
<p>character. type of allele frequency to be calculated (individual <code>"ind"</code> or population <code>"pop"</code>)</p>
</td></tr>
<tr><td><code id="allele.freq_+3A_verbose">verbose</code></td>
<td>
<p>logical. whether to show the progress of the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the allele frequencies to be calculated for populations from both genotype table and the allele depth table, they must be provided in a list with element names <code>AD</code> for allele depth table and <code>GT</code> for the genotype table. See the examples.
</p>


<h3>Value</h3>

<p>Returns a data frame or a list (if both genotype and allele depth used)
of allele frequencies
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
het.table&lt;-hetTgen(vcf,"GT")
ad.table&lt;-hetTgen(vcf,"AD")

# for individual based AF
frQ&lt;-allele.freq(het.table,f.typ="ind")

#for population-wise and both allele depth and genotype tables
frQ&lt;-allele.freq(list(AD=ad.table,GT=het.table),f.typ="pop")
## End(Not run)

</code></pre>

<hr>
<h2 id='allele.info'>Get allele information for duplicate detection</h2><span id='topic+allele.info'></span>

<h3>Description</h3>

<p>The function to calculate allele median ratios, proportion of heterozygotes
and allele probability values under different assumptions (see details),
and their chi-square significance values for duplicate detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele.info(
  X,
  x.norm = NULL,
  Fis,
  method = c("MedR", "QN", "pca", "TMM", "TMMex"),
  logratioTrim = 0.3,
  sumTrim = 0.05,
  Weighting = TRUE,
  Acutoff = -1e+10,
  plot.allele.cov = TRUE,
  verbose = TRUE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allele.info_+3A_x">X</code></td>
<td>
<p>allele depth table generated from the function
<code>hetTgen</code> (non-normalized)</p>
</td></tr>
<tr><td><code id="allele.info_+3A_x.norm">x.norm</code></td>
<td>
<p>a data frame of normalized allele coverage, output of
<code>cpm.normal</code>. If not provided, calculated using <code>X</code>.</p>
</td></tr>
<tr><td><code id="allele.info_+3A_fis">Fis</code></td>
<td>
<p>numeric. Inbreeding coefficient calculated using <code>h.zygosity()</code> function</p>
</td></tr>
<tr><td><code id="allele.info_+3A_method">method</code></td>
<td>
<p>character. method to be used for normalization
(see <code>cpm.normal</code> details). Default <code>TMM</code></p>
</td></tr>
<tr><td><code id="allele.info_+3A_logratiotrim">logratioTrim</code></td>
<td>
<p>numeric. percentage value (0 - 1) of variation to be
trimmed in log transformation</p>
</td></tr>
<tr><td><code id="allele.info_+3A_sumtrim">sumTrim</code></td>
<td>
<p>numeric. amount of trim to use on the combined absolute
levels (&ldquo;A&rdquo; values) for method <code>TMM</code></p>
</td></tr>
<tr><td><code id="allele.info_+3A_weighting">Weighting</code></td>
<td>
<p>logical, whether to compute (asymptotic binomial precision)
weights</p>
</td></tr>
<tr><td><code id="allele.info_+3A_acutoff">Acutoff</code></td>
<td>
<p>numeric, cutoff on &ldquo;A&rdquo; values to use before trimming</p>
</td></tr>
<tr><td><code id="allele.info_+3A_plot.allele.cov">plot.allele.cov</code></td>
<td>
<p>logical, plot comparative plots of allele depth
coverage in homozygotes and heterozygotes</p>
</td></tr>
<tr><td><code id="allele.info_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print progress</p>
</td></tr>
<tr><td><code id="allele.info_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
<tr><td><code id="allele.info_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele information generated here are individual SNP based and presents the
proportion of heterozygotes, number of samples, and deviation of allele
detection from a 1:1 ratio of reference and alternative alleles.
The significance of the deviation is tested with Z-score test
<code class="reqn">Z = \frac{ \frac{N}{2}-N_A}{ \sigma_{x}}</code>,
and chi-square test (see references for more details on the method).
</p>


<h3>Value</h3>

<p>Returns a data frame of median allele ratio, proportion of
heterozygotes, number of heterozygotes, and allele probability at different
assumptions with their chi-square significance
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Pascal Milesi, Klaus Schliep
</p>


<h3>References</h3>


<ul>
<li><p>McKinney, G. J., Waples, R. K., Seeb, L. W., &amp; Seeb, J. E. (2017).
Paralogs are revealed by proportion of heterozygotes and deviations in read
ratios in genotyping by sequencing data from natural populations.
Molecular Ecology Resources, 17(4)
</p>
</li>
<li><p>Karunarathne et al. 2022 (to be added)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(ADtable)
hz&lt;-h.zygosity(vcf,verbose=FALSE)
Fis&lt;-mean(hz$Fis,na.rm = TRUE)
AI&lt;-allele.info(ADtable,x.norm=ADnorm,Fis=Fis)
## End(Not run)

</code></pre>

<hr>
<h2 id='alleleINF'>Allele info example data</h2><span id='topic+alleleINF'></span>

<h3>Description</h3>

<p>Semi-randomly generated data from the function dup.snp.info.
Data contains depth and proportion values of 2857 snps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(alleleINF)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 2857 rows and 28 columns.
</p>


<h3>Source</h3>

<p><a href="https://zenodo.org/record/5025423#.Yj2XKRDMLyQ">Chinook Salmon sequence reads McKinney et al. 2017</a>
</p>


<h3>References</h3>


<ul>
<li><p>Larson, W. A., Seeb, L. W., Everett, M. V., Waples, R. K., Templin, W. D., &amp; Seeb, J. E. (2014). Genotyping by sequencing resolves #' shallow population structure to inform conservation of Chinook salmon (Oncorhynchus tshawytscha). Evolutionary Applications, 7(3)
</p>
</li>
<li><p>McKinney, G. J., Waples, R. K., Seeb, L. W., &amp; Seeb, J. E. (2017). Paralogs are revealed by proportion of heterozygotes and deviations in read ratios in genotyping by sequencing data from natural populations. Molecular Ecology Resources, 17(4)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(alleleINF)
with(alleleINF,plot(medRatio~propHet))
</code></pre>

<hr>
<h2 id='cnv'>Find CNVs from deviants</h2><span id='topic+cnv'></span>

<h3>Description</h3>

<p>Categorize deviant and non-deviant into &quot;singlets&quot; and &quot;duplicates&quot; based on the statistical approaches specified by the user.
The intersection of all the stats provided will be used in the categorization. If one would like to use the intersection of at least two stats, this can be specified in the <code>n.ints</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnv(
  data,
  test = c("z.het", "z.05", "z.all", "chi.het", "chi.05", "chi.all"),
  filter = c("intersection", "kmeans"),
  WGS = TRUE,
  ft.threshold = 0.05,
  plot = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnv_+3A_data">data</code></td>
<td>
<p>A data frame of allele information generated with the function
<code>allele.info</code></p>
</td></tr>
<tr><td><code id="cnv_+3A_test">test</code></td>
<td>
<p>vector of characters. Type of test to be used for significance.
See details</p>
</td></tr>
<tr><td><code id="cnv_+3A_filter">filter</code></td>
<td>
<p>character. Type of filter to be used for filtering CNVs.
default <code>kmeans</code>. See details.</p>
</td></tr>
<tr><td><code id="cnv_+3A_wgs">WGS</code></td>
<td>
<p>logical. test parameter. See details</p>
</td></tr>
<tr><td><code id="cnv_+3A_ft.threshold">ft.threshold</code></td>
<td>
<p>confidence interval for filtering <code>default = 0.05</code></p>
</td></tr>
<tr><td><code id="cnv_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the detection of duplicates. default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cnv_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress</p>
</td></tr>
<tr><td><code id="cnv_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SNP deviants are detected with both excess of heterozygosity
according to HWE and deviant SNPs where depth values fall outside of the
normal distribution are detected using the
following methods:
</p>

<ul>
<li><p>Z-score test <code class="reqn">Z_{x} = \sum_{i=1}^{n} Z_{i}</code>;
<code class="reqn">Z_{i} = \frac{\left ( (N_{i}\times p)- N_{Ai} \right )}{\sqrt{N_{i}\times p(1-p)}}</code>
</p>
</li>
<li><p>chi-square test <code class="reqn">X_{x}^{2} = \sum_{i-1}^{n} X_{i}^{2}</code>;
<code class="reqn">X_{i}^{2} = (\frac{(N_{i}\times p - N_{Ai})^2}{N_{i}\times p} + \frac{(N_{i}\times (1 - p)- (N_{i} - N_{Ai}))^2}{N_{i}\times (1-p)})</code>
</p>
</li></ul>

<p>See references for more details on the methods
</p>
<p>Users can pick among Z-score for heterozygotes (<code>z.het, chi.het</code>),
all allele combinations (<code>z.all, chi.all</code>) and the assumption of no
probe bias p=0.5 (<code>z.05, chi.05</code>)
</p>
<p><code>filter</code> will determine whether the <code>intersection</code> or <code>kmeans</code>
clustering of the provided <code>test</code>s should be used in filtering CNVs.
The intersection uses threshold values for filtering and kmeans use
unsupervised clustering. Kmeans clustering is recommended if one is uncertain
about the threshold values.
</p>
<p><code>WGS</code> is a test parameter to include or exclude coefficient of variance
(cv) in kmeans. For data sets with more homogeneous depth distribution,
excluding cv improves CNV detection. If you're not certain about this, use
<code>TRUE</code> which is the default.
</p>


<h3>Value</h3>

<p>Returns a data frame of SNPs with their detected duplication status
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne Qiujie Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
DD&lt;-cnv(alleleINF)
## End(Not run)

</code></pre>

<hr>
<h2 id='cpm.normal'>Calculate normalized depth for alleles</h2><span id='topic+cpm.normal'></span>

<h3>Description</h3>

<p>This function outputs the normalized depth values separately for each allele,
calculated using normalization factor with trimmed mean of M-values of
sample libraries, median ratios normalization or quantile normalization,
See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpm.normal(
  het.table,
  method = c("MedR", "QN", "pca", "TMM", "TMMex"),
  logratioTrim = 0.3,
  sumTrim = 0.05,
  Weighting = TRUE,
  Acutoff = -1e+10,
  verbose = TRUE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpm.normal_+3A_het.table">het.table</code></td>
<td>
<p>allele depth table generated from the function
<code>hetTgen</code></p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_method">method</code></td>
<td>
<p>character. method to be used (see details). Default <code>TMM</code></p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_logratiotrim">logratioTrim</code></td>
<td>
<p>numeric. percentage value (0 - 1) of variation to be
trimmed in log transformation</p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_sumtrim">sumTrim</code></td>
<td>
<p>numeric. amount of trim to use on the combined absolute
levels (&ldquo;A&rdquo; values) for method <code>TMM</code></p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_weighting">Weighting</code></td>
<td>
<p>logical, whether to compute (asymptotic binomial precision)
weights</p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_acutoff">Acutoff</code></td>
<td>
<p>numeric, cutoff on &ldquo;A&rdquo; values to use before trimming
(only for TMM(ex))</p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress</p>
</td></tr>
<tr><td><code id="cpm.normal_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the boxplot of sample library sizes showing outliers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an observed depth value table to an
effective depth value table using several normalization methods;
</p>

<ol>
<li><p> TMM normalization (See the original publication for more information).
It is different from the function <code>normz</code> only in calculation of the
counts per million is for separate alleles instead of the total depth.
The <code>TMMex</code> method is an extension of the <code>TMM</code> method for
large data sets containing SNPs exceeding 10000
</p>
</li>
<li><p> The method <code>MedR</code> is median ratio normalization;
</p>
</li>
<li><p> QN - quantile normalization (see  Maza, Elie, et al. 2013 for a
comparison of methods).
</p>
</li>
<li><p> PCA - a modified Kaiser's Rule applied to depth values: Sample variation
of eigen values smaller than 0.7 are removed (i.e., the first eigen value &lt; 0.7)
to eliminate the effect of the library size of samples
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a list with (AD), a data frame of normalized depth values
similar to the output of <code>hetTgen</code> function and
(outliers) a list of outlier sample names
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Qiujie Zhou
</p>


<h3>References</h3>


<ul>
<li><p>Robinson MD, Oshlack A (2010). A scaling normalization method for
differential expression analysis of RNA-seq data. Genome Biology 11, R25
</p>
</li>
<li><p>Robinson MD, McCarthy DJ and Smyth GK (2010). edgeR: a Bioconductor
package for differential expression analysis of digital gene expression
data. Bioinformatics 26
</p>
</li>
<li><p>Maza, Elie, et al. &quot;Comparison of normalization methods for
differential gene expression analysis in RNA-Seq experiments: a matter of
relative size of studied transcriptomes.&quot; Communicative &amp; integrative
biology 6.6 (2013): e25849
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(ADtable)
ADnormalized&lt;-cpm.normal(ADtable)
## End(Not run)


</code></pre>

<hr>
<h2 id='depthVsSample'>Simulate median allele ratios for varying number of samples and depth values</h2><span id='topic+depthVsSample'></span>

<h3>Description</h3>

<p>This function will simulate the expected median allele ratios under HWE
for given ranges of no. of samples and depth coverage values.
This is useful if you need to find the cutoff values of allele ratios for
different no. of samples and depth of coverage values in your data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthVsSample(
  cov.len = 100,
  sam.len = 100,
  nsims = 1000,
  plot = TRUE,
  col = c("#1C86EE", "#00BFFF", "#DAA520", "#FF0000")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depthVsSample_+3A_cov.len">cov.len</code></td>
<td>
<p>max value of depth of coverage to be simulated</p>
</td></tr>
<tr><td><code id="depthVsSample_+3A_sam.len">sam.len</code></td>
<td>
<p>maximum no. of samples to be simulated</p>
</td></tr>
<tr><td><code id="depthVsSample_+3A_nsims">nsims</code></td>
<td>
<p>numerical. no. of simulations to be done for each combination of samples and depth
depth and no. samples ranges</p>
</td></tr>
<tr><td><code id="depthVsSample_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the output (a plot of no. samples
vs median depth of coverage colored by median allele ratios)</p>
</td></tr>
<tr><td><code id="depthVsSample_+3A_col">col</code></td>
<td>
<p>character. Two colors to add to the gradient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of median allele ratios where rows are the number of
samples and columns are depth of coverage values
</p>


<h3>Author(s)</h3>

<p>Pascal Milesi, Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: depthVsSample(cov.len=100,sam.len=100)

</code></pre>

<hr>
<h2 id='dup.plot'>Plot classified SNPs into deviants/CNVs and non-deviants/non-CNVs</h2><span id='topic+dup.plot'></span>

<h3>Description</h3>

<p>The function plots detected deviants/CNVs from functions <code>sig.snps</code>,
<code>cnv</code> and <code>dupGet</code> on a median ratio (MedRatio) Vs. proportion of
heterozygote (PropHet) plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.plot(ds, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dup.plot_+3A_ds">ds</code></td>
<td>
<p>a data frame of detected deviants/cnvs (outputs of functions above)</p>
</td></tr>
<tr><td><code id="dup.plot_+3A_...">...</code></td>
<td>
<p>other graphical parameters to be passed to the function
<code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no value, only plots proportion of heterozygotes vs allele
median ratio separated by duplication status
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
DD&lt;-dupGet(alleleINF,plot=FALSE)
dup.plot(DD)
## End(Not run)

</code></pre>

<hr>
<h2 id='dup.validate'>Validate detected deviants/cnvs</h2><span id='topic+dup.validate'></span>

<h3>Description</h3>

<p>This function will validate the detected duplicated-SNPs (deviants/cnvs) using a moving
window approach (see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.validate(d.detect, window.size = 100, scaf.size = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dup.validate_+3A_d.detect">d.detect</code></td>
<td>
<p>a data frame of detected duplicates or deviants from the outputs of <code>dupGet</code> or <code>cnv</code></p>
</td></tr>
<tr><td><code id="dup.validate_+3A_window.size">window.size</code></td>
<td>
<p>numerical. a single value of the desired moving window
size (default <code>100</code> bp)</p>
</td></tr>
<tr><td><code id="dup.validate_+3A_scaf.size">scaf.size</code></td>
<td>
<p>numerical. scaffold size to be checked. i.e. the chromosome/scaffolds will be split into equal pieces of this size
default=10000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loci/SNP positions correctly ordered according to a reference
sequence is necessary for this function to work properly. The list of deviants/cnvs provided in the <code>d.detect</code> will be split into pices of <code>scaf.size</code> and the number of deviants/cnvs will be counted along each split with a moving window of <code>window.size</code>. The resulting percentages of deviants/cnvs will be averaged for each scaf.size split; this is the <code>cnv.ratio</code> column in the output. Thus, ideally, the <code>cnv.ratio</code> is a measure of how confident the detected deviants/cnvs are in an actual putative duplicated region withing the given <code>scaf.size</code>. This ratio is sensitive to the picked window size and the scaf.size; as a rule of thumb, it is always good to use a known gene length as the scaf.size, if you need to check a specific gene for the validity of the detected duplicates.
Please also note that this function is still in its <code>beta-testing</code> phase and also under development for non-mapped reference sequences. Therefore, your feedback and suggestions will be highly appreciated.
</p>


<h3>Value</h3>

<p>A data frame of deviant/cnv ratios (column <code>cnv.ratio</code>) for a split of the chromosome/scaffold given by the <code>scaf.size</code>; this ratio is an average value of the percentage of deviants/cnvs present within the given <code>window.size</code> for each split (<code>chromosome/scaffold length/sacf.size</code>); the start and the end positions of each split is given in the <code>start</code> and <code>end</code> columns
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# suggestion to visualize dup.validate output

library(ggplot2)
library(dplyr)

dvs&lt;-dupGet(alleleINF,test=c("z.05","chi.05"))
dvd&lt;-dup.validate(dvs,window.size = 1000)

# Example data frame
df &lt;- data.frame(dvd[,3:5])
df$cnv.ratio&lt;-as.numeric(df$cnv.ratio)

# Calculate midpoints
df &lt;- df %&gt;%
  mutate(midpoint = (start + end) / 2)

ggplot() +
  # Horizontal segments for each start-end range
  geom_segment(data = df, aes(x = start, xend = end,
  y = cnv.ratio, yend = cnv.ratio), color = "blue") +
  # Midpoints line connecting midpoints of each range
  geom_path(data = df, aes(x = midpoint, y = cnv.ratio), color = "red") +
  geom_point(data = df, aes(x = midpoint, y = cnv.ratio), color = "red") +
  # Aesthetic adjustments
  theme_minimal() +
  labs(title = "CNV Ratio along a Continuous Axis with Midpoint Fluctuation",
      x = "Genomic Position",
       y = "CNV Ratio")

## End(Not run)


</code></pre>

<hr>
<h2 id='dupGet'>Detect deviants from SNPs; classify SNPs</h2><span id='topic+dupGet'></span>

<h3>Description</h3>

<p>Detect deviant SNPs using excess of heterozygotes
(alleles that do not follow HWE) and allelic-ratio deviations
(alleles with ratios that do not follow a normal Z-score or chi-square
distribution).
See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupGet(
  data,
  Fis,
  test = c("z.het", "z.05", "z.all", "chi.het", "chi.05", "chi.all"),
  intersection = FALSE,
  method = c("fisher", "chi.sq"),
  plot = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dupGet_+3A_data">data</code></td>
<td>
<p>data frame of the output of <code>allele.info</code></p>
</td></tr>
<tr><td><code id="dupGet_+3A_fis">Fis</code></td>
<td>
<p>numeric. Inbreeding coefficient calculated using <code>h.zygosity()</code> function</p>
</td></tr>
<tr><td><code id="dupGet_+3A_test">test</code></td>
<td>
<p>character. type of test to be used for significance. See details</p>
</td></tr>
<tr><td><code id="dupGet_+3A_intersection">intersection</code></td>
<td>
<p>logical, whether to use the intersection of the methods
specified in <code>test</code> (if more than one)</p>
</td></tr>
<tr><td><code id="dupGet_+3A_method">method</code></td>
<td>
<p>character. method for testing excess of heterozygotes.
Fisher exact test (<code>fisher</code>) or Chi-square test (<code>chi.sq</code>)</p>
</td></tr>
<tr><td><code id="dupGet_+3A_plot">plot</code></td>
<td>
<p>logical. whether to plot the detected singlets and duplicates
on allele ratio vs. proportion of heterozygotes plot.</p>
</td></tr>
<tr><td><code id="dupGet_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress</p>
</td></tr>
<tr><td><code id="dupGet_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SNP deviants are detected with both excess of heterozygosity
according to HWE and deviant SNPs where depth values fall outside of the
normal distribution are detected using the
following methods:
</p>

<ul>
<li><p>Z-score test <code class="reqn">Z_{x} = \sum_{i=1}^{n} Z_{i}</code>;
<code class="reqn">Z_{i} = \frac{\left ( (N_{i}\times p)- N_{Ai} \right )}{\sqrt{N_{i}\times p(1-p)}}</code>
</p>
</li>
<li><p>chi-square test <code class="reqn">X_{x}^{2} = \sum_{i-1}^{n} X_{i}^{2}</code>;
<code class="reqn">X_{i}^{2} = (\frac{(N_{i}\times p - N_{Ai})^2}{N_{i}\times p} + \frac{(N_{i}\times (1 - p)- (N_{i} - N_{Ai}))^2}{N_{i}\times (1-p)})</code>
</p>
</li></ul>

<p>See references for more details on the methods
</p>
<p>Users can pick among Z-score for heterozygotes (<code>z.het, chi.het</code>),
all allele combinations (<code>z.all, chi.all</code>) and the assumption of no
probe bias p=0.5 (<code>z.05, chi.05</code>)
</p>


<h3>Value</h3>

<p>Returns a data frame of snps/alleles with their duplication status
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne Qiujie Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
DD&lt;-dupGet(alleleINF,Fis=0.1,test=c("z.05","chi.05"))
## End(Not run)

</code></pre>

<hr>
<h2 id='exportVCF'>Export VCF files</h2><span id='topic+exportVCF'></span>

<h3>Description</h3>

<p>A function to export tables/matrices in VCF format to VCF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportVCF(out.vcf, out.path, compress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exportVCF_+3A_out.vcf">out.vcf</code></td>
<td>
<p>a matrix or data frame in vcf file format to be exported</p>
</td></tr>
<tr><td><code id="exportVCF_+3A_out.path">out.path</code></td>
<td>
<p>a character string of output path for the vcf file;
should end in the name as the vcf file and .vcf. See examples</p>
</td></tr>
<tr><td><code id="exportVCF_+3A_compress">compress</code></td>
<td>
<p>logical. whether to compress the output file. If <code>TRUE</code>,
the file will be <code>.gz</code> compressed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Exports a vcf file to a given destination
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path)
exportVCF(vcf,"../exVcf.vcf")
## End(Not run)

</code></pre>

<hr>
<h2 id='get.miss'>Get missingness of individuals in raw vcf</h2><span id='topic+get.miss'></span>

<h3>Description</h3>

<p>A function to get the percentage of missing data of snps per SNP and per
sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.miss(
  data,
  type = c("samples", "snps"),
  plot = TRUE,
  verbose = TRUE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.miss_+3A_data">data</code></td>
<td>
<p>a list containing imported vcf file using <code>readVCF</code> or
genotype table generated using <code>hetTgen</code></p>
</td></tr>
<tr><td><code id="get.miss_+3A_type">type</code></td>
<td>
<p>character.  Missing percentages per sample
&ldquo;samples&rdquo; or per SNP &ldquo;snps&rdquo;, default both</p>
</td></tr>
<tr><td><code id="get.miss_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the missingness density with ninety
five percent quantile</p>
</td></tr>
<tr><td><code id="get.miss_+3A_verbose">verbose</code></td>
<td>
<p>logical. Whether to show progress</p>
</td></tr>
<tr><td><code id="get.miss_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of allele depth or genotypes
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
missing&lt;-get.miss(vcf,plot=TRUE)
## End(Not run)

</code></pre>

<hr>
<h2 id='gt.format'>Format genotype for BayEnv and BayPass</h2><span id='topic+gt.format'></span>

<h3>Description</h3>

<p>This function generates necessary genotype count formats for BayEnv and
BayPass with a subset of SNPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gt.format(
  gt,
  info,
  format = c("benv", "bpass"),
  snp.subset = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gt.format_+3A_gt">gt</code></td>
<td>
<p>multi-vector. an imported data.frame of genotypes or genotype
data frame generated by <code>hetTgen</code> or path to GT.FORMAT
file generated from VCFTools</p>
</td></tr>
<tr><td><code id="gt.format_+3A_info">info</code></td>
<td>
<p>a data frame containing sample and population information.
It must have &ldquo;sample&rdquo; and &ldquo;population&rdquo; columns</p>
</td></tr>
<tr><td><code id="gt.format_+3A_format">format</code></td>
<td>
<p>character. output format i.e., for BayPass or BayEnv</p>
</td></tr>
<tr><td><code id="gt.format_+3A_snp.subset">snp.subset</code></td>
<td>
<p>numerical. number of randomly selected subsets of SNPs.
<code>default = NULL</code></p>
</td></tr>
<tr><td><code id="gt.format_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with formatted genotype data: <code>$bayenv</code> - snps
in horizontal format - for BayEnv (two lines per snp); <code>$baypass</code> - vertical format - for BayPass
(two column per snp); <code>$sub.bp</code> - subsets snps for BayPass <code>$sub.be</code> - subsets of snps for BayEnv
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
het.table&lt;-hetTgen(vcf,"GT")
info&lt;-unique(substr(colnames(het.table)[-c(1:3)],1,8))
GT&lt;-gt.format(het.table,info)
## End(Not run)

</code></pre>

<hr>
<h2 id='h.zygosity'>Determine per sample heterozygosity and inbreeding coefficient</h2><span id='topic+h.zygosity'></span>

<h3>Description</h3>

<p>This function will calculate the heterozygosity on a per-sample basis from
vcf files (snps), and most importantly inbreeding coefficient which is used
to filter out the samples with bad mapping quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.zygosity(vcf, plot = FALSE, pops = NA, verbose = TRUE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h.zygosity_+3A_vcf">vcf</code></td>
<td>
<p>an imported vcf file in in a list using
<code>readVCF</code> or a data frame of genotypes generated using
<code>hetTgen</code></p>
</td></tr>
<tr><td><code id="h.zygosity_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot a boxplot of inbreeding coefficients
for populations. A list of populations must be provided</p>
</td></tr>
<tr><td><code id="h.zygosity_+3A_pops">pops</code></td>
<td>
<p>character. A list of population names with the same length and
order as the number of samples in the vcf</p>
</td></tr>
<tr><td><code id="h.zygosity_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress</p>
</td></tr>
<tr><td><code id="h.zygosity_+3A_parallel">parallel</code></td>
<td>
<p>logical. Parallelize the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of expected &ldquo;E(Hom)&rdquo; and observed
&ldquo;O(Hom)&rdquo; homozygotes with their inbreeding coefficients.
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Pascal Milesi, Klaus Schliep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
pp&lt;-substr(colnames(vcf$vcf)[-c(1:9)],1,8)
hzygots&lt;-h.zygosity(vcf,plot=TRUE,pops=pp)
## End(Not run)

</code></pre>

<hr>
<h2 id='hetTgen'>Generate allele depth or genotype table</h2><span id='topic+hetTgen'></span>

<h3>Description</h3>

<p>hetTgen extracts the read depth and coverage values for each snp for all
the individuals from a vcf file generated from readVCF (or GatK
VariantsToTable: see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetTgen(
  vcf,
  info.type = c("AD", "AD-tot", "GT", "GT-012", "GT-AB", "DP"),
  verbose = TRUE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hetTgen_+3A_vcf">vcf</code></td>
<td>
<p>an imported vcf file in a list using <code>readVCF</code></p>
</td></tr>
<tr><td><code id="hetTgen_+3A_info.type">info.type</code></td>
<td>
<p>character. <code>AD</code>: allele depth value, <code>AD-tot</code>:total
allele depth, <code>DP</code>=unfiltered depth (sum), <code>GT</code>: genotype,
<code>GT-012</code>:genotype in 012 format, <code>GT-AB</code>:genotype in AB format.
Default <code>AD</code>,  See details.</p>
</td></tr>
<tr><td><code id="hetTgen_+3A_verbose">verbose</code></td>
<td>
<p>logical. whether to show the progress of the analysis</p>
</td></tr>
<tr><td><code id="hetTgen_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you generate the depth values for allele by sample using GatK
VariantsToTable option, use only -F CHROM -F POS -GF AD flags to generate
the table. Or keep only the CHROM, POS, ID, ALT, and individual AD columns.
For info.type <code>GT</code> option is provided to extract the genotypes of
individuals by snp.
</p>


<h3>Value</h3>

<p>Returns a data frame of allele depth, genotype of SNPs for all the
individuals extracted from a VCF file
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Klaus Schliep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
het.table&lt;-hetTgen(vcf)
## End(Not run)

</code></pre>

<hr>
<h2 id='maf'>Remove MAF allele</h2><span id='topic+maf'></span>

<h3>Description</h3>

<p>A function to remove the alleles with minimum allele frequency and keep only
a bi-allelic matrix when loci are multi-allelic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maf(h.table, AD = TRUE, verbose = TRUE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maf_+3A_h.table">h.table</code></td>
<td>
<p>allele depth table generated from the function <code>hetTgen</code></p>
</td></tr>
<tr><td><code id="maf_+3A_ad">AD</code></td>
<td>
<p>logical. If TRUE a allele depth table similar to <code>hetTgen</code>
output will be returns; If <code>FALSE</code>, individual AD values per SNP will be
returned in a list.</p>
</td></tr>
<tr><td><code id="maf_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress</p>
</td></tr>
<tr><td><code id="maf_+3A_parallel">parallel</code></td>
<td>
<p>logical. whether to parallelize the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or a list of minimum allele frequency removed allele depth
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mf&lt;-maf(ADtable)

</code></pre>

<hr>
<h2 id='norm.fact'>Calculate normalization factor for each sample</h2><span id='topic+norm.fact'></span>

<h3>Description</h3>

<p>This function calculates the normalization factor for each sample using
different methods. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.fact(
  df,
  method = c("TMM", "TMMex", "MedR", "QN"),
  logratioTrim = 0.3,
  sumTrim = 0.05,
  Weighting = TRUE,
  Acutoff = -1e+10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm.fact_+3A_df">df</code></td>
<td>
<p>a data frame or matrix of allele depth values
(total depth per snp per sample)</p>
</td></tr>
<tr><td><code id="norm.fact_+3A_method">method</code></td>
<td>
<p>character. method to be used (see details). Default <code>TMM</code></p>
</td></tr>
<tr><td><code id="norm.fact_+3A_logratiotrim">logratioTrim</code></td>
<td>
<p>numeric. percentage value (0 - 1) of variation to be
trimmed in log transformation</p>
</td></tr>
<tr><td><code id="norm.fact_+3A_sumtrim">sumTrim</code></td>
<td>
<p>numeric. amount of trim to use on the combined absolute
levels (&ldquo;A&rdquo; values) for method <code>TMM</code></p>
</td></tr>
<tr><td><code id="norm.fact_+3A_weighting">Weighting</code></td>
<td>
<p>logical, whether to compute (asymptotic binomial precision)
weights</p>
</td></tr>
<tr><td><code id="norm.fact_+3A_acutoff">Acutoff</code></td>
<td>
<p>numeric, cutoff on &ldquo;A&rdquo; values to use before trimming</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally described for normalization of RNA sequences
(Robinson &amp; Oshlack 2010), this function computes normalization (scaling)
factors to convert observed library sizes into effective library sizes.
It uses the method trimmed means of M-values proposed by Robinson &amp;
Oshlack (2010). See the original publication and <code>edgeR</code> package
for more information.
The method <code>MedR</code> is median ratio normalization;
QN - quantile normalization (see  Maza, Elie, et al. 2013 for a
comparison of methods).
</p>


<h3>Value</h3>

<p>Returns a numerical vector of normalization factors for each sample
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>References</h3>


<ul>
<li><p>Robinson MD, and Oshlack A (2010). A scaling normalization method for
differential expression analysis of RNA-seq data. Genome Biology 11, R25
</p>
</li>
<li><p>Robinson MD, McCarthy DJ and Smyth GK (2010). edgeR: a Bioconductor
package for differential expression analysis of digital gene expression
data. Bioinformatics 26
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path)
df&lt;-hetTgen(vcf,"AD-tot",verbose=FALSE)
norm.fact(df)
## End(Not run)


</code></pre>

<hr>
<h2 id='power.bias'>Simulate and plot detection power of bias in allele ratios</h2><span id='topic+power.bias'></span>

<h3>Description</h3>

<p>This function simulates 95% confidence level Z-score based detection power
of allele biases for a given number of samples and a range of depths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.bias(
  Dlist = c(2, 4, 8, 16),
  sam = 100,
  intensity = 0.005,
  nsims = 1000,
  p = 0.5,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.bias_+3A_dlist">Dlist</code></td>
<td>
<p>numerical. vector of depths values to be tested</p>
</td></tr>
<tr><td><code id="power.bias_+3A_sam">sam</code></td>
<td>
<p>numerical. number of samples</p>
</td></tr>
<tr><td><code id="power.bias_+3A_intensity">intensity</code></td>
<td>
<p>numerical. frequency of bias</p>
</td></tr>
<tr><td><code id="power.bias_+3A_nsims">nsims</code></td>
<td>
<p>numerical. number of simulations to be done for each sample</p>
</td></tr>
<tr><td><code id="power.bias_+3A_p">p</code></td>
<td>
<p>numerical. expected allele ratio (0.5 for data with known
sequencing biases)</p>
</td></tr>
<tr><td><code id="power.bias_+3A_plot">plot</code></td>
<td>
<p>logical. plot the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of detection probability values for the given range of
samples and depth
</p>


<h3>Author(s)</h3>

<p>Pascal Milesi, Piyal Karunarathne
</p>

<hr>
<h2 id='readVCF'>Import VCF file</h2><span id='topic+readVCF'></span>

<h3>Description</h3>

<p>Function to import raw single and multi-sample VCF files.
The function required the R-package <code>data.table</code> for faster importing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readVCF(vcf.file.path, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readVCF_+3A_vcf.file.path">vcf.file.path</code></td>
<td>
<p>path to the vcf file</p>
</td></tr>
<tr><td><code id="readVCF_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with vcf table in a data frame, excluding meta data.
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path)
## End(Not run)

</code></pre>

<hr>
<h2 id='relatedness'>Determine pairwise relatedness</h2><span id='topic+relatedness'></span>

<h3>Description</h3>

<p>Relatedness is determined according to genome-wide relationship assessment
of Yang et al. 2010 equation 6, on a per sample basis (with itself and
others), using SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness(
  vcf,
  plot = TRUE,
  threshold = 0.5,
  verbose = TRUE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relatedness_+3A_vcf">vcf</code></td>
<td>
<p>an imported vcf file in a list using <code>readVCF</code>
or a data frame of genotypes generated using <code>hetTgen</code></p>
</td></tr>
<tr><td><code id="relatedness_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot relatedness of samples against
themselves, among themselves and outliers</p>
</td></tr>
<tr><td><code id="relatedness_+3A_threshold">threshold</code></td>
<td>
<p>numerical. A value indicating to filter the individuals of
relatedness among themselves. Default <code>0.5</code> (siblings)</p>
</td></tr>
<tr><td><code id="relatedness_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress.</p>
</td></tr>
<tr><td><code id="relatedness_+3A_parallel">parallel</code></td>
<td>
<p>logical. Parallelize the process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to Yang et al. (2010), out breeding non-related pairs should have a
relatedness value of zero while the individual with itself will have a
relatedness value of one. Relatedness value of ~0.5 indicates siblings.
</p>


<h3>Value</h3>

<p>A data frame of individuals and relatedness score <code class="reqn">A_{jk}</code>
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Klaus Schliep
</p>


<h3>References</h3>

<p>Yang, J., Benyamin, B., McEvoy, B. et al. Common SNPs explain a
large proportion of the heritability for human height. Nat Genet 42, 565569
(2010).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
relate&lt;-relatedness(vcf)
## End(Not run)

</code></pre>

<hr>
<h2 id='sig.hets'>Identify significantly different heterozygotes from SNPs data</h2><span id='topic+sig.hets'></span>

<h3>Description</h3>

<p>This function will recognize the SNPs with a proportion of heterozygotes
significantly higher than expected under HWE and plot deviant snps based
only on the excess of heterozygotes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig.hets(
  a.info,
  Fis,
  method = c("chi.sq", "fisher"),
  plot = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sig.hets_+3A_a.info">a.info</code></td>
<td>
<p>allele info table generated from filtered vcfs using the
function <code>allele.info</code> or allele depth table generated from <code>hetTgen</code></p>
</td></tr>
<tr><td><code id="sig.hets_+3A_fis">Fis</code></td>
<td>
<p>numeric. Inbreeding coefficient calculated using <code>h.zygosity()</code> function</p>
</td></tr>
<tr><td><code id="sig.hets_+3A_method">method</code></td>
<td>
<p>character. Method for testing significance. Fisher exact test
(<code>fisher</code>) or Chi-square test (<code>chi.sq</code>)</p>
</td></tr>
<tr><td><code id="sig.hets_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the identified duplicated snps with
the expected values</p>
</td></tr>
<tr><td><code id="sig.hets_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE, the progress is shown</p>
</td></tr>
<tr><td><code id="sig.hets_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of expected heterozygote proportions from the observed
data with p-value indicating significance of deviation.
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne, Pascal Milesi, Klaus Schliep, Qiujie Zhou
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
AI &lt;- alleleINF
duplicates&lt;-sig.hets(AI,plot=TRUE,Fis=0.1)
## End(Not run)

</code></pre>

<hr>
<h2 id='sim.als'>Simulate Allele Frequencies</h2><span id='topic+sim.als'></span>

<h3>Description</h3>

<p>This function simulates allele frequencies of a desired population size
under HWE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.als(n = 500, nrun = 10000, res = 0.001, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.als_+3A_n">n</code></td>
<td>
<p>desired populations size (set this value same as your actual
population size for an accurate simulation)</p>
</td></tr>
<tr><td><code id="sim.als_+3A_nrun">nrun</code></td>
<td>
<p>number of simulations to run on each allele frequency.
The higher this number, the closer the simulations will be to the
theoretical values (at the cost of computer power); 10000 is an optimal value.</p>
</td></tr>
<tr><td><code id="sim.als_+3A_res">res</code></td>
<td>
<p>desired resolution of the theoretical allele frequency</p>
</td></tr>
<tr><td><code id="sim.als_+3A_plot">plot</code></td>
<td>
<p>logical. whether to plot the simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices:
</p>

<ol>
<li><p> allele_freqs: theoretical allele frequency
</p>
</li>
<li><p> simulated_freqs: simulated frequencies at different confidence intervals
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Piyal Karunarathne, Pascal Milesi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: alleles &lt;- sim.als(n=200,nrun=1000,res=0.001,plot=TRUE)

</code></pre>

<hr>
<h2 id='vcf.stat'>Get sequencing quality statistics of raw VCF files
(with GatK generated vcf files only)</h2><span id='topic+vcf.stat'></span>

<h3>Description</h3>

<p>This function will generate a table similar to VariantsToTable option in
GatK from raw vcf files for filtering purposes. The function will also
plot all the parameters (see details &amp; values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf.stat(vcf, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcf.stat_+3A_vcf">vcf</code></td>
<td>
<p>an imported vcf file in data.frame or matrix format using
<code>readVCF</code></p>
</td></tr>
<tr><td><code id="vcf.stat_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the (12) parameters</p>
</td></tr>
<tr><td><code id="vcf.stat_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code>plot</code>
(e.g. col,border)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see instructions of GatK
</p>


<h3>Value</h3>

<p>Returns a data frame with quality parameters from the INFO. field of
the vcf
</p>

<ul>
<li><p>QUAL: The Phred-scaled probability that a REF/ALT polymorphism exists
at this site given sequencing data
</p>
</li>
<li><p>AC: Allele count
</p>
</li>
<li><p>AF: Allele frequency
</p>
</li>
<li><p>DP: unfiltered depth
</p>
</li>
<li><p>QD: QualByDepth - This is the variant confidence (from the QUAL
field) divided by the unfiltered depth of non-hom-ref samples
</p>
</li>
<li><p>FS: FisherStrand - This is the Phred scaled probability that there is
strand bias at the site
</p>
</li>
<li><p>SOR: StrandOddsRatio - This is another way to estimate strand bias
using a test similar to the symmetric odds ratio test
</p>
</li>
<li><p>MQ: RMSMappingQuality - This is the root mean square mapping quality
over all the reads at the site
</p>
</li>
<li><p>MQRankSum: MappingQualityRankSumTest - This is the u-based
z-approximation from the Rank Sum Test for mapping qualities
</p>
</li>
<li><p>ReadPosRankSum: ReadPosRankSumTest: This is the u-based
z-approximation from the Rank Sum Test for site position within reads
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: vcf.file.path &lt;- paste0(path.package("rCNV"), "/example.raw.vcf.gz")
vcf &lt;- readVCF(vcf.file.path=vcf.file.path)
statistics&lt;-vcf.stat(vcf,plot=TRUE)
## End(Not run)

</code></pre>

<hr>
<h2 id='vst'>Calculate population-wise Vst</h2><span id='topic+vst'></span>

<h3>Description</h3>

<p>This function calculates Vst (variant fixation index) for populations given
a list of duplicated loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vst(AD, pops, id.list = NULL, qGraph = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vst_+3A_ad">AD</code></td>
<td>
<p>data frame of total allele depth values of (duplicated, if
<code>id.list</code> is not provided) SNPs</p>
</td></tr>
<tr><td><code id="vst_+3A_pops">pops</code></td>
<td>
<p>character. A vector of population names for each individual.
Must be the same length as the number of samples in AD</p>
</td></tr>
<tr><td><code id="vst_+3A_id.list">id.list</code></td>
<td>
<p>character. A vector of duplicated SNP IDs. Must match the IDs
in the AD data frame</p>
</td></tr>
<tr><td><code id="vst_+3A_qgraph">qGraph</code></td>
<td>
<p>logical. Plot the network plot based on Vst values
(see details)</p>
</td></tr>
<tr><td><code id="vst_+3A_verbose">verbose</code></td>
<td>
<p>logical. show progress</p>
</td></tr>
<tr><td><code id="vst_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>qgraph</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vst is calculated with the following equation
</p>
<p style="text-align: center;"><code class="reqn">V_{T} = \frac{ V_{S} }{V_{T}}</code>
</p>
<p> where VT is the variance of normalized
read depths among all individuals from the two populations and VS is the
average of the variance within each population, weighed for population size
(see reference for more details)
See <code>qgraph</code> help for details on qgraph output
</p>


<h3>Value</h3>

<p>Returns a matrix of pairwise Vst values for populations
</p>


<h3>Author(s)</h3>

<p>Piyal Karunarathne
</p>


<h3>References</h3>

<p>Redon, Richard, et al. Global variation in copy number in the human genome.
nature 444.7118 (2006)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
data(ADtable)
DD&lt;-dupGet(alleleINF)
ds&lt;-DD[DD$dup.stat=="deviant",]
ad&lt;-ADtable[match(paste0(ds$CHROM,".",ds$POS),paste0(ADtable$CHROM,".",ADtable$POS)),]
vst(ad,pops=substr(colnames(ad)[-c(1:4)],1,11))
## End(Not run)

</code></pre>

<hr>
<h2 id='vstPermutation'>Run permutation on Vst</h2><span id='topic+vstPermutation'></span>

<h3>Description</h3>

<p>This function runs a permutation test on Vst calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vstPermutation(
  AD,
  pops,
  nperm = 100,
  histogram = TRUE,
  stat = 2,
  qGraph = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vstPermutation_+3A_ad">AD</code></td>
<td>
<p>data frame of total allele depth values of SNPs</p>
</td></tr>
<tr><td><code id="vstPermutation_+3A_pops">pops</code></td>
<td>
<p>character. A vector of population names for each individual.
Must be the same length as the number of samples in AD</p>
</td></tr>
<tr><td><code id="vstPermutation_+3A_nperm">nperm</code></td>
<td>
<p>numeric. Number of permutations to perform</p>
</td></tr>
<tr><td><code id="vstPermutation_+3A_histogram">histogram</code></td>
<td>
<p>logical. plots the distribution histogram of permuted vst values vs. observed values</p>
</td></tr>
<tr><td><code id="vstPermutation_+3A_stat">stat</code></td>
<td>
<p>numeric. The stat to be plotted in histogram. 1 for Mean Absolute Distance or 2 (<code>default</code>) for Root Mean Square Distance</p>
</td></tr>
<tr><td><code id="vstPermutation_+3A_qgraph">qGraph</code></td>
<td>
<p>logical. Plot the network plot based on observed Vst values
(see <code>vst()</code> help page for more details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with observed vst values, an array of permuted vst values and the p-values for the permutation test
</p>


<h3>Author(s)</h3>

<p>Jorge Cortés-Miranda (email:<a href="mailto:jorge.cortes.m@ug.uchile.cl">jorge.cortes.m@ug.uchile.cl</a>), Piyal Karunarathne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(alleleINF)
data(ADtable)
DD&lt;-dupGet(alleleINF)
ds&lt;-DD[DD$dup.stat=="deviant",]
ad&lt;-ADtable[match(paste0(ds$CHROM,".",ds$POS),paste0(ADtable$CHROM,".",ADtable$POS)),]
vstPermutation(ad,pops=substr(colnames(ad)[-c(1:4)],1,11))
## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
