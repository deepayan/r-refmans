<!DOCTYPE html><html><head><title>Help for package neuroim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neuroim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#neuroim'><p>neuroim</p></a></li>
<li><a href='#.isExtension'><p>.isExtension</p></a></li>
<li><a href='#+5B+2CBrainBucket+2Cindex+2Cmissing+2CANY-method'><p>extract labeled volume from <code>BrainBucket</code></p></a></li>
<li><a href='#+5B+2CROIVolume+2Cnumeric+2Cmissing+2CANY-method'><p>extract data from <code>ROIVolume</code></p></a></li>
<li><a href='#+5B+2CSparseBrainVector+2Cmissing+2Cmissing+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVector+2Cmissing+2Cnumeric+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVector+2Cnumeric+2Cmissing+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVector+2Cnumeric+2Cnumeric+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVolume+2Cmatrix+2Cmissing+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVolume+2Cmissing+2Cmissing+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVolume+2Cmissing+2Cnumeric+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVolume+2Cnumeric+2Cmissing+2Cmissing-method'><p>extractor</p></a></li>
<li><a href='#+5B+2CSparseBrainVolume+2Cnumeric+2Cnumeric+2CANY-method'><p>extractor</p></a></li>
<li><a href='#+5B+5B+2CBrainBucket+2Cindex+2Cmissing-method'><p>extract labeled volume from <code>BrainBucket</code></p></a></li>
<li><a href='#addDim'><p>Generic function to add a dimension to an object</p></a></li>
<li><a href='#AFNIFileDescriptor-class'><p>AFNIFileDescriptor</p></a></li>
<li><a href='#AFNIMetaInfo'><p>AFNIMetaInfo</p></a></li>
<li><a href='#as'><p>conversion from DenseBrainVolume to array</p></a></li>
<li><a href='#as.array+2CBrainData-method'><p>convert <code>BrainData</code> instance to array</p></a></li>
<li><a href='#as.list+2CSparseBrainVector-method'><p>as.list</p></a></li>
<li><a href='#as.logical+2CBrainVolume-method'><p>as.logical</p></a></li>
<li><a href='#as.mask'><p>Convert to a LogicalBrainVolume</p></a></li>
<li><a href='#as.matrix+2CBrainData-method'><p>convert <code>BrainData</code> instance to matrix</p></a></li>
<li><a href='#as.matrix+2CSparseBrainVector-method'><p>as.matrix</p></a></li>
<li><a href='#as.numeric+2CSparseBrainVolume-method'><p>Convert SparseBrainVolume to numeric</p></a></li>
<li><a href='#as.raster+2CLayer-method'><p>as.raster</p></a></li>
<li><a href='#as.sparse'><p>Convert to from dense to sparse representation</p></a></li>
<li><a href='#as.vector+2CBrainData-method'><p>convert <code>BrainData</code> instance to vector</p></a></li>
<li><a href='#axes'><p>Generic getter function to extract image axes</p></a></li>
<li><a href='#AxisSet-class'><p>Base</p></a></li>
<li><a href='#AxisSet1D-class'><p>AxisSet1D</p></a></li>
<li><a href='#AxisSet2D-class'><p>AxisSet2D</p></a></li>
<li><a href='#AxisSet3D-class'><p>AxisSet3D</p></a></li>
<li><a href='#AxisSet4D-class'><p>AxisSet4D</p></a></li>
<li><a href='#AxisSet5D-class'><p>AxisSet5D</p></a></li>
<li><a href='#axisToIndex'><p>Generic function to convert 1-dimensional real axis coordinates along a single axis dimension to an 1D index along the same axis</p></a></li>
<li><a href='#Base-class'><p>Base</p></a></li>
<li><a href='#BaseMetaInfo-class'><p>BaseMetaInfo</p></a></li>
<li><a href='#BaseSource-class'><p>BaseSource</p></a></li>
<li><a href='#BinaryReader'><p>BinaryReader</p></a></li>
<li><a href='#BinaryReader-class'><p>BinaryReader</p></a></li>
<li><a href='#BinaryWriter-class'><p>BinaryWriter</p></a></li>
<li><a href='#BootstrapSearchlight'><p>Create a searchlight iterator that samples regions from within a mask.</p>
Searchlight centers are sampled *without* replacement, but the same voxel can belong to multiple searchlight samples.
It is in the latter sense that this is a bootstrap resampling scheme.</a></li>
<li><a href='#bounds'><p>Generic function to extract the spatial bounds (origin + dim * spacing) of an image</p>
param x the object</a></li>
<li><a href='#BrainBucket-class'><p>BrainBucket</p></a></li>
<li><a href='#BrainBucketSource-class'><p>BrainBucketSource</p></a></li>
<li><a href='#BrainData-class'><p>BrainData</p></a></li>
<li><a href='#BrainFileDescriptor-class'><p>BrainFileDescriptor</p></a></li>
<li><a href='#BrainFileSource-class'><p>BrainFileSource</p>
</p>
<p>Base class for representing a data source for images. The purpose of this class is to provide a layer in between</p>
low level IO and image loading functionality.</a></li>
<li><a href='#BrainMetaInfo-class'><p>BrainMetaInfo</p>
</p>
<p>This class contains meta information from an image</p></a></li>
<li><a href='#BrainSlice'><p>BrainSlice constructor</p></a></li>
<li><a href='#BrainSlice-class'><p>BrainSlice</p></a></li>
<li><a href='#BrainSource-class'><p>BrainSource</p></a></li>
<li><a href='#BrainSpace'><p>Constructor function for <code>BrainSpace</code> class</p></a></li>
<li><a href='#BrainSpace-class'><p>BrainSpace</p></a></li>
<li><a href='#BrainSurface-class'><p>BrainSurface</p></a></li>
<li><a href='#BrainSurfaceSource-class'><p>BrainSurfaceSource</p></a></li>
<li><a href='#BrainSurfaceVector-class'><p>BrainSurfaceVector</p></a></li>
<li><a href='#BrainSurfaceVectorSource-class'><p>BrainSurfaceVectorSource</p></a></li>
<li><a href='#BrainVector-class'><p>BrainVector</p></a></li>
<li><a href='#BrainVectorSource'><p>BrainVectorSource</p></a></li>
<li><a href='#BrainVectorSource-class'><p>BrainVectorSource</p></a></li>
<li><a href='#BrainVolume'><p>BrainVolume</p></a></li>
<li><a href='#BrainVolume-class'><p>Base class for image representing 3D volumetric data.</p></a></li>
<li><a href='#BrainVolumeSource-class'><p>BrainVolume</p>
BrainVolumeSource
</p>
<p>A class is used to produce a <code>BrainVolume</code> instance</p></a></li>
<li><a href='#close+2CBinaryReader-method'><p>close</p></a></li>
<li><a href='#clusterCenters'><p>clusterCenters</p></a></li>
<li><a href='#ClusteredBrainVolume-class'><p>ClusteredBrainVolume</p></a></li>
<li><a href='#ColumnReader'><p>ColumnReader</p></a></li>
<li><a href='#ColumnReader-class'><p>ColumnReader</p></a></li>
<li><a href='#concat'><p>Concatenate two objects</p></a></li>
<li><a href='#connComp'><p>Find connected components</p></a></li>
<li><a href='#connComp3D'><p>Extract connected components from a 3D mask</p></a></li>
<li><a href='#coords'><p>Extract coordinates</p></a></li>
<li><a href='#coordToGrid'><p>Generic function to convert N-dimensional real world coordinates to grid coordinates</p></a></li>
<li><a href='#coordToIndex'><p>Generic function to convert N-dimensional real world coordinates to 1D indices</p></a></li>
<li><a href='#dataFile'><p>Generic function to get the name of the data file, given a file name and a <code>BrainFileDescriptor</code> instance.</p></a></li>
<li><a href='#dataFileMatches'><p>Generic function to test whether a file name conforms to the given a <code>BrainFileDescriptor</code> instance.</p>
Will test for match to data file only</a></li>
<li><a href='#dataReader'><p>Generic function to create data reader</p></a></li>
<li><a href='#DenseBrainVector-class'><p>DenseBrainVector</p></a></li>
<li><a href='#DenseBrainVolume-class'><p>DenseBrainVolume</p></a></li>
<li><a href='#dim+2CBrainData-method'><p>dim of <code>BrainData</code> object</p></a></li>
<li><a href='#dim+2CBrainSpace-method'><p>dim</p></a></li>
<li><a href='#dim+2CFileMetaInfo-method'><p>dim of <code>FileMetaInfo</code></p></a></li>
<li><a href='#dropDim'><p>Generic function to drop a dimension from an object</p></a></li>
<li><a href='#eachSeries'><p>Generic functions to apply a function to each series of a 4D image</p>
That is, if the 4th dimension is 'time' each series is a 1D time series.</a></li>
<li><a href='#eachSlice'><p>Generic functions to apply a function to each (2D) slice of an image</p></a></li>
<li><a href='#eachVolume'><p>Generic function to apply a function to each volume of a four-dimensional image</p></a></li>
<li><a href='#fileMatches'><p>Generic function to test whether a file name conforms to the given <code>BrainFileDescriptor</code> instance.</p>
Will test for match to either header file or data file</a></li>
<li><a href='#FileMetaInfo-class'><p>FileMetaInfo</p></a></li>
<li><a href='#fill'><p>Generic function to map values from one set to another using a user-supplied lookup table</p></a></li>
<li><a href='#FreesurferAsciiSurfaceFileDescriptor-class'><p>FresurferAsciiSurfaceFileDescriptor</p></a></li>
<li><a href='#FreesurferSurfaceGeometryMetaInfo-class'><p>FreeSurferSurfaceGeometryMetaInfo</p>
</p>
<p>This class contains meta information for brain surface geometry</p></a></li>
<li><a href='#gridToCoord'><p>Generic function to convert N-dimensional grid coordinate coordinates to real world coordinates</p>
Generic function to convert N-dimensional grid coordinates to real world coordinates</a></li>
<li><a href='#gridToIndex'><p>Generic function to convert N-dimensional grid coordinate to 1D indices</p></a></li>
<li><a href='#headerFile'><p>Generic function to get the name of the header file, given a file name and a <code>BrainFileDescriptor</code> instance.</p></a></li>
<li><a href='#headerFileMatches'><p>Generic function to test whether a file name conforms to the given <code>BrainFileDescriptor</code> instance.</p>
Will test for match to header file only</a></li>
<li><a href='#image+2CBrainVolume-method'><p>image</p></a></li>
<li><a href='#imageGrid'><p>imageGrid</p></a></li>
<li><a href='#IndexLookupVolume-class'><p>IndexLookupVolume</p></a></li>
<li><a href='#indexToCoord'><p>Generic function to convert 1D indices to N-dimensional real world coordinates</p></a></li>
<li><a href='#indexToGrid'><p>Generic function to convert 1D indices to N-dimensional grid coordinates</p></a></li>
<li><a href='#indices'><p>Extract indices</p></a></li>
<li><a href='#inverseTrans'><p>Generic getter to extract inverse image coordinate transformation</p></a></li>
<li><a href='#Kernel'><p>Create a Kernel object</p></a></li>
<li><a href='#Kernel-class'><p>Kernel</p></a></li>
<li><a href='#Layer'><p>Layer</p></a></li>
<li><a href='#Layer-class'><p>Layer</p></a></li>
<li><a href='#length+2CROIVolume-method'><p>Get length of <code>BrainVector</code>. This is the numbe rof volumes in the volume vector (e.g. the 4th image dimension)</p></a></li>
<li><a href='#loadBucket'><p>loadBucket</p></a></li>
<li><a href='#loadData'><p>Generic function to load data from a data source</p></a></li>
<li><a href='#loadFSSurface'><p>load Freesurfer ascii surface</p></a></li>
<li><a href='#loadSurface'><p>load an surface from a set of files</p></a></li>
<li><a href='#loadVector'><p>loadVector</p></a></li>
<li><a href='#loadVolume'><p>Load an image volume from a file</p></a></li>
<li><a href='#loadVolumeList'><p>loadVolList</p></a></li>
<li><a href='#LogicalBrainVolume-class'><p>LogicalBrainVolume</p></a></li>
<li><a href='#lookup'><p>Index Lookup operation</p></a></li>
<li><a href='#makeVector'><p>makeVector</p></a></li>
<li><a href='#makeVolume'><p>makeVolume</p></a></li>
<li><a href='#map'><p>Generic function to apply a function to an object</p></a></li>
<li><a href='#mapToColors'><p>mapToColors</p></a></li>
<li><a href='#matchAnatomy2D'><p>given two named axes return AxisSet2D singleton</p></a></li>
<li><a href='#matchAnatomy3D'><p>given three named axes return AxisSet3D singleton</p></a></li>
<li><a href='#matrixToVolumeList'><p>matrixToVolumeList</p>
converts a matrix to a list of BrainVolumes with values filled at grid coordinates determined by the <code>vox</code> argument.</a></li>
<li><a href='#mergePartitions'><p>mergePartitions</p></a></li>
<li><a href='#MNI_SPACE_1MM'><p>MNI SPACE 1MM</p></a></li>
<li><a href='#NamedAxis-class'><p>NamedAxis</p></a></li>
<li><a href='#names+2CBrainBucketSource-method'><p>names</p></a></li>
<li><a href='#ndim'><p>Generic function to extract the number of dimensions of an object</p></a></li>
<li><a href='#NIfTIFileDescriptor-class'><p>NIfTIFileDescriptor</p></a></li>
<li><a href='#NIfTIMetaInfo'><p>Constructor for <code>NIfTIMetaInfo</code> class</p></a></li>
<li><a href='#NIMLSurfaceDataMetaInfo'><p>Constructor for <code>NIMLSurfaceDataMetaInfo</code> class</p></a></li>
<li><a href='#NIMLSurfaceDataMetaInfo-class'><p>NIMLSurfaceDataMetaInfo</p>
</p>
<p>This class contains meta information for surface-based data for the NIML data format</p></a></li>
<li><a href='#NIMLSurfaceFileDescriptor-class'><p>NIMLSurfaceFileDescriptor</p></a></li>
<li><a href='#NullMetaInfo-class'><p>NullMetaInfo</p></a></li>
<li><a href='#numClusters'><p>numClusters</p></a></li>
<li><a href='#origin'><p>Generic getter to extract image origin</p></a></li>
<li><a href='#overlay'><p>overlay two objects</p></a></li>
<li><a href='#partition'><p>partition</p></a></li>
<li><a href='#permMat'><p>Extract permutation matrix</p></a></li>
<li><a href='#pick'><p>pick</p></a></li>
<li><a href='#print'><p>Generic function to print an object</p></a></li>
<li><a href='#print+2CAxisSet2D-method'><p>print a <code>AxisSet2D</code> instance</p></a></li>
<li><a href='#print+2CAxisSet3D-method'><p>print a <code>AxisSet3D</code> instance</p></a></li>
<li><a href='#print+2CNamedAxis-method'><p>print a <code>NamedAxis</code></p></a></li>
<li><a href='#RandomSearchlight'><p>Create an Random Searchlight iterator</p></a></li>
<li><a href='#readAFNIHeader'><p>readAFNIHeader</p></a></li>
<li><a href='#readColumns'><p>Generic function to read a set of column vector from an input source (e.g. <code>ColumnReader</code>)</p></a></li>
<li><a href='#readElements'><p>Generic function to read a sequence of elements from an input source</p></a></li>
<li><a href='#readHeader'><p>read header information of an image file</p></a></li>
<li><a href='#readMetaInfo'><p>Generic function to read image meta info given a file and a <code>BrainFileDescriptor</code> instance.</p></a></li>
<li><a href='#RegionCube'><p>Create A Cuboid Region of Interest</p></a></li>
<li><a href='#RegionSphere'><p>Create A Spherical Region of Interest</p></a></li>
<li><a href='#RegionSquare'><p>Create a square region of interest where the z-dimension is fixed at one voxel coordinate.</p></a></li>
<li><a href='#render'><p>Render an image to create a drawable image.</p></a></li>
<li><a href='#renderSlice'><p>Render a slice at z coordinate</p></a></li>
<li><a href='#ROIVolume'><p>Create an instance of class ROIVolume</p></a></li>
<li><a href='#ROIVolume-class'><p>ROIVolume</p></a></li>
<li><a href='#scaleSeries'><p>Generic functions to scale (center and/or normalize by standard deviation) each series of a 4D image</p>
That is, if the 4th dimension is 'time' each series is a 1D time series.</a></li>
<li><a href='#Searchlight'><p>Create an exhaustive searchlight iterator</p></a></li>
<li><a href='#series'><p>Extract vector series from object</p></a></li>
<li><a href='#seriesIter'><p>seriesIter</p></a></li>
<li><a href='#show+2CAxisSet1D-method'><p>show an <code>AxisSet1D</code></p></a></li>
<li><a href='#show+2CAxisSet2D-method'><p>show an <code>AxisSet2D</code></p></a></li>
<li><a href='#show+2CAxisSet3D-method'><p>show an <code>AxisSet3D</code></p></a></li>
<li><a href='#show+2CAxisSet4D-method'><p>show an <code>AxisSet4D</code></p></a></li>
<li><a href='#show+2CBaseMetaInfo-method'><p>show a <code>BaseMetaInfo</code></p></a></li>
<li><a href='#show+2CBrainSpace-method'><p>show a <code>BrainSpace</code></p></a></li>
<li><a href='#show+2CBrainVector-method'><p>show a <code>BrainVector</code></p></a></li>
<li><a href='#show+2CBrainVectorSource-method'><p>show a <code>BrainVectorSource</code></p></a></li>
<li><a href='#show+2CBrainVolume-method'><p>show a <code>BrainVolume</code></p></a></li>
<li><a href='#show+2CFileMetaInfo-method'><p>show a <code>FileMetaInfo</code></p></a></li>
<li><a href='#show+2CNamedAxis-method'><p>show an <code>NamedAxis</code></p></a></li>
<li><a href='#show+2CNullMetaInfo-method'><p>show a <code>NullMetaInfo</code></p></a></li>
<li><a href='#show+2CROIVolume-method'><p>show an <code>ROIVolime</code></p></a></li>
<li><a href='#show+2CSparseBrainVector-method'><p>show a <code>SparseBrainVector</code></p></a></li>
<li><a href='#show+2CSurfaceDataMetaInfo-method'><p>show an <code>SurfaceDataMetaInfo</code></p></a></li>
<li><a href='#show+2CSurfaceGeometryMetaInfo-method'><p>show an <code>SurfaceGeometryMetaInfo</code></p></a></li>
<li><a href='#slice'><p>Extract a 2D slice from an image volume</p></a></li>
<li><a href='#sliceData'><p>sliceData</p></a></li>
<li><a href='#space'><p>Generic function to extract geometric properties of an image.</p></a></li>
<li><a href='#spacing'><p>Generic function to extract the voxel dimensions of an image</p></a></li>
<li><a href='#SparseBrainVector-class'><p>SparseBrainVector</p></a></li>
<li><a href='#SparseBrainVectorSource-class'><p>SparseBrainVectorSource</p></a></li>
<li><a href='#SparseBrainVolume-class'><p>SparseBrainVolume</p></a></li>
<li><a href='#splitFill'><p>Generic function to fill disjoint sets of values with the output of a function</p></a></li>
<li><a href='#splitReduce'><p>Generic function to summarize subsets of an object by first splitting by row and then &quot;reducing&quot; by a summary <code>function</code></p></a></li>
<li><a href='#splitScale'><p>Generic function to center/scale row-subsets of a matrix or matrix-like object</p></a></li>
<li><a href='#stripExtension'><p>Generic function to strip extension from file name, given a <code>BrainFileDescriptor</code> instance.</p></a></li>
<li><a href='#subVector'><p>Generic function to extract a sub-vector from a <code>BrainVector</code> object.</p></a></li>
<li><a href='#SurfaceDataMetaInfo'><p>Constructor for <code>SurfaceDataMetaInfo</code> class</p></a></li>
<li><a href='#SurfaceDataMetaInfo-class'><p>SurfaceDataMetaInfo</p>
</p>
<p>This class contains meta information for surface-based data (the values that map to a surface geometry)</p></a></li>
<li><a href='#SurfaceGeometryMetaInfo'><p>Constructor for <code>SurfaceGeometryMetaInfo</code> class</p></a></li>
<li><a href='#SurfaceGeometryMetaInfo-class'><p>SurfaceGeometryMetaInfo</p>
</p>
<p>This class contains meta information for brain surface geometry</p></a></li>
<li><a href='#takeSeries'><p>Generic function to extract a set of series from a 4D image</p></a></li>
<li><a href='#takeVolume'><p>Generic function to extract a one or more individual volumes from a four-dimensional image</p></a></li>
<li><a href='#tesselate'><p>tesselate</p></a></li>
<li><a href='#trans'><p>Generic getter to extract image coordinate transformation</p></a></li>
<li><a href='#values'><p>Generic function to extract data values of object</p></a></li>
<li><a href='#voxels'><p>extract voxel coordinates</p></a></li>
<li><a href='#writeElements'><p>Generic function to write a sequence of elements from an input source</p></a></li>
<li><a href='#writeVector'><p>Generic function to write a 4D image vector to disk</p></a></li>
<li><a href='#writeVolume'><p>Generic function to write a 3D image volume to disk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Imports:</td>
<td>Matrix, yaImpute, Rcpp, iterators, abind, assertthat, readr,
rgl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bradley Buchsbaum &lt;brad.buchsbaum@gmail.com&gt;</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Author:</td>
<td>Bradley R. Buchsbaum</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Structures and Handling for Neuroimaging Data</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of data structures that represent
    volumetric brain imaging data. The focus is on basic data handling for 3D
    and 4D neuroimaging data. In addition, there are function to read and write
    NIFTI files and limited support for reading AFNI files.</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-01-06</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach, testthat, knitr</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stringr, hash, methods, stats, grDevices, grid,
utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AFNI_IO.R' 'AllGeneric.R' 'AllClass.R' 'Axis.R' 'BinaryIO.R'
'BrainData.R' 'common.R' 'NIFTI_IO.R' 'BrainFileDescriptor.R'
'BrainMetaInfo.R' 'BrainRegion3D.R' 'BrainSlice.R'
'BrainSpace.R' 'BrainSurface.R' 'SparseBrainVector.R'
'BrainVector.R' 'BrainVolume.R' 'Display.R' 'FREESURFER_IO.R'
'IndexLookupVolume.R' 'Ops.R' 'RcppExports.R' 'conncomp.R'
'datadoc.R' 'neuroim.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-07 20:45:46 UTC; brad</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-01-07 23:59:04</td>
</tr>
</table>
<hr>
<h2 id='neuroim'>neuroim</h2><span id='topic+neuroim'></span><span id='topic+neuroim-package'></span>

<h3>Description</h3>

<p>Data structures for analysis of neuroimaging data.
</p>


<h3>Details</h3>

<p>none
</p>

<hr>
<h2 id='.isExtension'>.isExtension</h2><span id='topic+.concat4D'></span><span id='topic+.extract.array'></span><span id='topic+.getDataCode'></span><span id='topic+.getDataSize'></span><span id='topic+.getDataStorage'></span><span id='topic+.getEndian'></span><span id='topic+.getRStorage'></span><span id='topic+.gridToIndex'></span><span id='topic+.gridToIndex3D'></span><span id='topic+.indexToGrid'></span><span id='topic+.isExtension'></span><span id='topic+.matrixToQuatern'></span><span id='topic+.niftiExt'></span>

<h3>Description</h3>

<p>.isExtension
</p>
<p>.concat4D
</p>
<p>.extract.array
</p>
<p>.gridToIndex3D
</p>
<p>.gridToIndex
</p>
<p>.indexToGrid
</p>
<p>.getRStorage
</p>
<p>.getDataStorage
</p>
<p>.getDataCode
</p>
<p>.getDataSize
</p>
<p>.getEndian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.isExtension(fname, extension)

.concat4D(x, y, ...)

.extract.array(x, ..., drop = FALSE, indices = list(...))

.gridToIndex3D(dimensions, voxmat)

.gridToIndex(dimensions, vmat)

.indexToGrid(idx, array.dim)

.getRStorage(dataType)

.getDataStorage(code)

.getDataCode(dataType)

.getDataSize(dataType)

.getEndian(conn)

.niftiExt(filetype)

.matrixToQuatern(mat)
</code></pre>

<hr>
<h2 id='+5B+2CBrainBucket+2Cindex+2Cmissing+2CANY-method'>extract labeled volume from <code>BrainBucket</code></h2><span id='topic++5B+2CBrainBucket+2Cindex+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extract labeled volume from <code>BrainBucket</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainBucket,index,missing,ANY'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CBrainBucket+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CBrainBucket+2B2Cindex+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CROIVolume+2Cnumeric+2Cmissing+2CANY-method'>extract data from <code>ROIVolume</code></h2><span id='topic++5B+2CROIVolume+2Cnumeric+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extract data from <code>ROIVolume</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ROIVolume,numeric,missing,ANY'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CROIVolume+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CROIVolume+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CROIVolume+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CROIVolume+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>drop dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVector+2Cmissing+2Cmissing+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVector+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector,missing,missing,ANY'
x[i, j, k, m, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_m">m</code></td>
<td>
<p>the fourth index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVector+2Cmissing+2Cnumeric+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVector+2Cmissing+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector,missing,numeric,ANY'
x[i, j, k, m, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_m">m</code></td>
<td>
<p>the fourth index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVector+2Cnumeric+2Cmissing+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVector+2Cnumeric+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector,numeric,missing,ANY'
x[i, j, k, m, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_m">m</code></td>
<td>
<p>the fourth index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVector+2Cnumeric+2Cnumeric+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVector+2Cnumeric+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector,numeric,numeric,ANY'
x[i, j, k, m, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_m">m</code></td>
<td>
<p>the fourth index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVector+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVolume+2Cmatrix+2Cmissing+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVolume+2Cmatrix+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume,matrix,missing,ANY'
x[i, j, k, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmatrix+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVolume+2Cmissing+2Cmissing+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVolume+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume,missing,missing,ANY'
x[i, j, k, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cmissing+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVolume+2Cmissing+2Cnumeric+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVolume+2Cmissing+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume,missing,numeric,ANY'
x[i, j, k, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cmissing+2B2Cnumeric+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVolume+2Cnumeric+2Cmissing+2Cmissing-method'>extractor</h2><span id='topic++5B+2CSparseBrainVolume+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume,numeric,missing,missing'
x[i, j, k, ..., drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_drop">drop</code></td>
<td>
<p>drop dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CSparseBrainVolume+2Cnumeric+2Cnumeric+2CANY-method'>extractor</h2><span id='topic++5B+2CSparseBrainVolume+2Cnumeric+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>extractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume,numeric,numeric,ANY'
x[i, j, k, ...,
  drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>first index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_j">j</code></td>
<td>
<p>second index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_k">k</code></td>
<td>
<p>third index</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSparseBrainVolume+2B2Cnumeric+2B2Cnumeric+2B2CANY-method_+3A_drop">drop</code></td>
<td>
<p>dimension</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B+2CBrainBucket+2Cindex+2Cmissing-method'>extract labeled volume from <code>BrainBucket</code></h2><span id='topic++5B+5B+2CBrainBucket+2Cindex+2Cmissing-method'></span>

<h3>Description</h3>

<p>extract labeled volume from <code>BrainBucket</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainBucket,index,missing'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B2CBrainBucket+2B2Cindex+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2CBrainBucket+2B2Cindex+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>the first index</p>
</td></tr>
</table>

<hr>
<h2 id='addDim'>Generic function to add a dimension to an object</h2><span id='topic+addDim'></span><span id='topic+addDim+2CBrainSpace+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to add a dimension to an object
</p>
<p>add dimension to <code><a href="#topic+BrainSpace-class">BrainSpace</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDim(x, n)

## S4 method for signature 'BrainSpace,numeric'
addDim(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDim_+3A_x">x</code></td>
<td>
<p>a dimensioned object</p>
</td></tr>
<tr><td><code id="addDim_+3A_n">n</code></td>
<td>
<p>the size of the dimension to add</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = BrainSpace(c(10,10,10), c(1,1,1))
x1 &lt;- addDim(x, 10)
ndim(x1) == 4
dim(x1)[4] == 10
</code></pre>

<hr>
<h2 id='AFNIFileDescriptor-class'>AFNIFileDescriptor</h2><span id='topic+AFNIFileDescriptor-class'></span>

<h3>Description</h3>

<p>This class supports the AFNI file format
</p>

<hr>
<h2 id='AFNIMetaInfo'>AFNIMetaInfo</h2><span id='topic+AFNIMetaInfo'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+AFNIMetaInfo-class">AFNIMetaInfo</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AFNIMetaInfo(descriptor, afni_header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AFNIMetaInfo_+3A_descriptor">descriptor</code></td>
<td>
<p>an instance of class <code><a href="#topic+AFNIFileDescriptor-class">AFNIFileDescriptor</a></code></p>
</td></tr>
<tr><td><code id="AFNIMetaInfo_+3A_afni_header">afni_header</code></td>
<td>
<p>a <code>list</code> returned by <code>readAFNIHeader</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+AFNIMetaInfo-class">AFNIMetaInfo</a></code>
</p>

<hr>
<h2 id='as'>conversion from DenseBrainVolume to array</h2><span id='topic+as'></span>

<h3>Description</h3>

<p>conversion from DenseBrainVolume to array
</p>
<p>conversion from <code>SparseBrainVolume</code> to <code>array</code>
</p>
<p>conversion from SparseBrainVolume to numeric
</p>
<p>conversion from BrainVolume to LogicalBrainVolume
</p>
<p>conversion from DenseBrainVolume to LogicalBrainVolume
</p>
<p>conversion from ClusteredBrainVolume to LogicalBrainVolume
</p>
<p>conversion from BrainVolume to array
</p>

<hr>
<h2 id='as.array+2CBrainData-method'>convert <code>BrainData</code> instance to array</h2><span id='topic+as.array+2CBrainData-method'></span>

<h3>Description</h3>

<p>convert <code>BrainData</code> instance to array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainData'
as.array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array+2B2CBrainData-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='as.list+2CSparseBrainVector-method'>as.list</h2><span id='topic+as.list+2CBrainVector-method'></span><span id='topic+as.list+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>convert SparseBrainVector to list of <code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code>
</p>
<p>convert a <code>BrainVector</code> to <code>list</code> of volumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector'
as.list(x)

## S4 method for signature 'BrainVector'
as.list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list+2B2CSparseBrainVector-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='as.logical+2CBrainVolume-method'>as.logical</h2><span id='topic+as.logical+2CBrainVolume-method'></span>

<h3>Description</h3>

<p>Convert BrainVolume to <code>linkS4class{LogicalBrainVolume}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainVolume'
as.logical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.logical+2B2CBrainVolume-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the image values will be converted to using R base function <code>as.logical</code> and wrapped in <code>LogicalBrainVolume</code>
</p>


<h3>Value</h3>

<p>an instance of <code>linkS4class{LogicalBrainVolume}</code>
</p>

<hr>
<h2 id='as.mask'>Convert to a LogicalBrainVolume</h2><span id='topic+as.mask'></span><span id='topic+as.mask+2CBrainVolume+2Cmissing-method'></span><span id='topic+as.mask+2CBrainVolume+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Convert to a LogicalBrainVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mask(x, indices)

## S4 method for signature 'BrainVolume,missing'
as.mask(x)

## S4 method for signature 'BrainVolume,numeric'
as.mask(x, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mask_+3A_x">x</code></td>
<td>
<p>the object to binarize</p>
</td></tr>
<tr><td><code id="as.mask_+3A_indices">indices</code></td>
<td>
<p>the indices to set to TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='as.matrix+2CBrainData-method'>convert <code>BrainData</code> instance to matrix</h2><span id='topic+as.matrix+2CBrainData-method'></span>

<h3>Description</h3>

<p>convert <code>BrainData</code> instance to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainData'
as.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix+2B2CBrainData-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='as.matrix+2CSparseBrainVector-method'>as.matrix</h2><span id='topic+as.matrix+2CDenseBrainVector-method'></span><span id='topic+as.matrix+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>convert SparseBrainVector to matrix
</p>
<p>convert a <code>DenseBrainVector</code> to a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector'
as.matrix(x)

## S4 method for signature 'DenseBrainVector'
as.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix+2B2CSparseBrainVector-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric+2CSparseBrainVolume-method'>Convert SparseBrainVolume to numeric</h2><span id='topic+as.numeric+2CSparseBrainVolume-method'></span>

<h3>Description</h3>

<p>Convert SparseBrainVolume to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVolume'
as.numeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric+2B2CSparseBrainVolume-method_+3A_x">x</code></td>
<td>
<p>the object to convert</p>
</td></tr>
</table>

<hr>
<h2 id='as.raster+2CLayer-method'>as.raster</h2><span id='topic+as.raster+2CLayer-method'></span>

<h3>Description</h3>

<p>as.raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Layer'
as.raster(x, zpos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raster+2B2CLayer-method_+3A_x">x</code></td>
<td>
<p>the layer to convert</p>
</td></tr>
<tr><td><code id="as.raster+2B2CLayer-method_+3A_zpos">zpos</code></td>
<td>
<p>the z coordinate in coordinate space</p>
</td></tr>
</table>

<hr>
<h2 id='as.sparse'>Convert to from dense to sparse representation</h2><span id='topic+as.sparse'></span><span id='topic+as.sparse+2CDenseBrainVector+2CLogicalBrainVolume-method'></span><span id='topic+as.sparse+2CDenseBrainVector+2Cnumeric-method'></span><span id='topic+as.sparse+2CDenseBrainVolume+2CLogicalBrainVolume-method'></span><span id='topic+as.sparse+2CDenseBrainVolume+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Convert to from dense to sparse representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sparse(x, mask, ...)

## S4 method for signature 'DenseBrainVector,LogicalBrainVolume'
as.sparse(x, mask)

## S4 method for signature 'DenseBrainVector,numeric'
as.sparse(x, mask)

## S4 method for signature 'DenseBrainVolume,LogicalBrainVolume'
as.sparse(x, mask)

## S4 method for signature 'DenseBrainVolume,numeric'
as.sparse(x, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sparse_+3A_x">x</code></td>
<td>
<p>the object to make sparse, e.g. <code>DenseBrainVolume</code> or <code>DenseBrainVector</code></p>
</td></tr>
<tr><td><code id="as.sparse_+3A_mask">mask</code></td>
<td>
<p>the elements to retain</p>
</td></tr>
<tr><td><code id="as.sparse_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mask</code> can be an integer vector of 1D indices or a mask volume of class <code>LogicalBrainVolume</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvol &lt;- BrainVolume(array(runif(24*24*24), c(24,24,24)), BrainSpace(c(24,24,24), c(1,1,1)))
indmask &lt;- sort(sample(1:(24*24*24), 100))
svol &lt;- as.sparse(bvol, indmask)


mask &lt;- LogicalBrainVolume(runif(length(indmask)), space=space(bvol), indices=indmask)
sum(mask) == 100
</code></pre>

<hr>
<h2 id='as.vector+2CBrainData-method'>convert <code>BrainData</code> instance to vector</h2><span id='topic+as.vector+2CBrainData-method'></span>

<h3>Description</h3>

<p>convert <code>BrainData</code> instance to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainData'
as.vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vector+2B2CBrainData-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='axes'>Generic getter function to extract image axes</h2><span id='topic+axes'></span><span id='topic+axes+2CBrainData-method'></span><span id='topic+axes+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic getter function to extract image axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axes(x)

## S4 method for signature 'BrainSpace'
axes(x)

## S4 method for signature 'BrainData'
axes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axes_+3A_x">x</code></td>
<td>
<p>an object with a set of axes</p>
</td></tr>
</table>

<hr>
<h2 id='AxisSet-class'>Base</h2><span id='topic+AxisSet-class'></span>

<h3>Description</h3>

<p>Virtual base class representing an ordered set of named axes.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ndim</code></dt><dd><p>the number of axes (or dimensions)</p>
</dd>
</dl>

<hr>
<h2 id='AxisSet1D-class'>AxisSet1D</h2><span id='topic+AxisSet1D-class'></span>

<h3>Description</h3>

<p>A one-dimensional axis set
</p>


<h3>Slots</h3>


<dl>
<dt><code>i</code></dt><dd><p>the first axis</p>
</dd>
</dl>

<hr>
<h2 id='AxisSet2D-class'>AxisSet2D</h2><span id='topic+AxisSet2D-class'></span>

<h3>Description</h3>

<p>A two-dimensional axis set
</p>


<h3>Slots</h3>


<dl>
<dt><code>j</code></dt><dd><p>the second axis</p>
</dd>
</dl>

<hr>
<h2 id='AxisSet3D-class'>AxisSet3D</h2><span id='topic+AxisSet3D-class'></span>

<h3>Description</h3>

<p>A three-dimensional axis set
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>the third axis</p>
</dd>
</dl>

<hr>
<h2 id='AxisSet4D-class'>AxisSet4D</h2><span id='topic+AxisSet4D-class'></span>

<h3>Description</h3>

<p>A four-dimensional axis set
</p>


<h3>Slots</h3>


<dl>
<dt><code>l</code></dt><dd><p>the fourth axis</p>
</dd>
</dl>

<hr>
<h2 id='AxisSet5D-class'>AxisSet5D</h2><span id='topic+AxisSet5D-class'></span>

<h3>Description</h3>

<p>A five-dimensional axis set
</p>


<h3>Slots</h3>


<dl>
<dt><code>m</code></dt><dd><p>the fifth axis</p>
</dd>
</dl>

<hr>
<h2 id='axisToIndex'>Generic function to convert 1-dimensional real axis coordinates along a single axis dimension to an 1D index along the same axis</h2><span id='topic+axisToIndex'></span><span id='topic+axisToIndex+2CBrainSpace+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to convert 1-dimensional real axis coordinates along a single axis dimension to an 1D index along the same axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axisToIndex(x, real, dimNum)

## S4 method for signature 'BrainSpace,numeric,numeric'
axisToIndex(x, real, dimNum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axisToIndex_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="axisToIndex_+3A_real">real</code></td>
<td>
<p>the axis coordinates</p>
</td></tr>
<tr><td><code id="axisToIndex_+3A_dimnum">dimNum</code></td>
<td>
<p>the dimension number of the axis (e.g.  1, 2, 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of axis indices
</p>

<hr>
<h2 id='Base-class'>Base</h2><span id='topic+Base-class'></span>

<h3>Description</h3>

<p>Generic S4 Base class
</p>

<hr>
<h2 id='BaseMetaInfo-class'>BaseMetaInfo</h2><span id='topic+BaseMetaInfo-class'></span>

<h3>Description</h3>

<p>This is a base class to represent meta information
</p>

<hr>
<h2 id='BaseSource-class'>BaseSource</h2><span id='topic+BaseSource-class'></span>

<h3>Description</h3>

<p>This is a base class to represent a data source
</p>


<h3>Slots</h3>


<dl>
<dt><code>metaInfo</code></dt><dd><p>meta information for the data source</p>
</dd>
</dl>

<hr>
<h2 id='BinaryReader'>BinaryReader</h2><span id='topic+BinaryReader'></span>

<h3>Description</h3>

<p>Constructor for  <code><a href="#topic+BinaryReader-class">BinaryReader</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryReader(input, byteOffset, dataType, bytesPerElement,
  endian = .Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryReader_+3A_input">input</code></td>
<td>
<p>file name to read from or else a <code>connection</code> object</p>
</td></tr>
<tr><td><code id="BinaryReader_+3A_byteoffset">byteOffset</code></td>
<td>
<p>the number of bytes to skip at the start of input</p>
</td></tr>
<tr><td><code id="BinaryReader_+3A_datatype">dataType</code></td>
<td>
<p>R data type of binary elements</p>
</td></tr>
<tr><td><code id="BinaryReader_+3A_bytesperelement">bytesPerElement</code></td>
<td>
<p>number of bytes in each data element (e.g. 4 or 8 for floating point numbers)</p>
</td></tr>
<tr><td><code id="BinaryReader_+3A_endian">endian</code></td>
<td>
<p>endianness of binary input connection</p>
</td></tr>
</table>

<hr>
<h2 id='BinaryReader-class'>BinaryReader</h2><span id='topic+BinaryReader-class'></span>

<h3>Description</h3>

<p>This class supports reading of bulk binary data from a connection
</p>


<h3>Slots</h3>


<dl>
<dt><code>input</code></dt><dd><p>the binary input connection</p>
</dd>
<dt><code>byteOffset</code></dt><dd><p>the number of bytes to skip at the start of input</p>
</dd>
<dt><code>dataType</code></dt><dd><p>the dataType of the binary Elements</p>
</dd>
<dt><code>bytesPerElement</code></dt><dd><p>number of bytes in each data element (e.g. 4 or 8 for floating point numbers)</p>
</dd>
<dt><code>endian</code></dt><dd><p>endianness of binary input connection</p>
</dd>
</dl>

<hr>
<h2 id='BinaryWriter-class'>BinaryWriter</h2><span id='topic+BinaryWriter'></span><span id='topic+BinaryWriter-class'></span>

<h3>Description</h3>

<p>This class supports writing of bulk binary data to a connection
</p>
<p>Constructor for  <code><a href="#topic+BinaryWriter-class">BinaryWriter</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryWriter(output, byteOffset, dataType, bytesPerElement,
  endian = .Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryWriter-class_+3A_output">output</code></td>
<td>
<p>file name to write to or else a <code>connection</code> object</p>
</td></tr>
<tr><td><code id="BinaryWriter-class_+3A_byteoffset">byteOffset</code></td>
<td>
<p>the number of bytes to skip at the start of output</p>
</td></tr>
<tr><td><code id="BinaryWriter-class_+3A_datatype">dataType</code></td>
<td>
<p>R data type of binary elements</p>
</td></tr>
<tr><td><code id="BinaryWriter-class_+3A_bytesperelement">bytesPerElement</code></td>
<td>
<p>number of bytes in each data element (e.g. 4 or 8 for floating point numbers)</p>
</td></tr>
<tr><td><code id="BinaryWriter-class_+3A_endian">endian</code></td>
<td>
<p>endianness of binary output connection</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>output</code></dt><dd><p>the binary output connection</p>
</dd>
<dt><code>byteOffset</code></dt><dd><p>the number of bytes to skip at the start of input</p>
</dd>
<dt><code>dataType</code></dt><dd><p>the dataType of the binary Elements</p>
</dd>
<dt><code>bytesPerElement</code></dt><dd><p>number of bytes in each data element (e.g. 4 or 8 for floating point numbers)</p>
</dd>
<dt><code>endian</code></dt><dd><p>endianness of binary output connection</p>
</dd>
</dl>

<hr>
<h2 id='BootstrapSearchlight'>Create a searchlight iterator that samples regions from within a mask.
Searchlight centers are sampled *without* replacement, but the same voxel can belong to multiple searchlight samples.
It is in the latter sense that this is a bootstrap resampling scheme.</h2><span id='topic+BootstrapSearchlight'></span>

<h3>Description</h3>

<p>Create a searchlight iterator that samples regions from within a mask.
Searchlight centers are sampled *without* replacement, but the same voxel can belong to multiple searchlight samples.
It is in the latter sense that this is a bootstrap resampling scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootstrapSearchlight(mask, radius, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootstrapSearchlight_+3A_mask">mask</code></td>
<td>
<p>an image volume containing valid central voxels for roving searchlight</p>
</td></tr>
<tr><td><code id="BootstrapSearchlight_+3A_radius">radius</code></td>
<td>
<p>in mm of spherical searchlight</p>
</td></tr>
<tr><td><code id="BootstrapSearchlight_+3A_iter">iter</code></td>
<td>
<p>the total number of searchlights to sample (default is 100)</p>
</td></tr>
</table>

<hr>
<h2 id='bounds'>Generic function to extract the spatial bounds (origin + dim * spacing) of an image
param x the object</h2><span id='topic+bounds'></span><span id='topic+bounds+2CBrainData-method'></span><span id='topic+bounds+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic function to extract the spatial bounds (origin + dim * spacing) of an image
param x the object
</p>
<p>bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(x)

## S4 method for signature 'BrainSpace'
bounds(x)

## S4 method for signature 'BrainData'
bounds(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_x">x</code></td>
<td>
<p>the object with <code>bounds</code> property</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> where each row contains the min (column 1) and max (column 2) bounds of the image dimension from 1 to <code>ndim(image)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(10,10,10), c(2,2,2))
b &lt;- bounds(bspace)
nrow(b) == ndim(bspace)
ncol(b) == 2
</code></pre>

<hr>
<h2 id='BrainBucket-class'>BrainBucket</h2><span id='topic+BrainBucket'></span><span id='topic+BrainBucket-class'></span>

<h3>Description</h3>

<p>a four-dimensional image that conists of a sequence of labeled image volumes backed by a list
</p>
<p>Constructor function for <code><a href="#topic+BrainBucket-class">BrainBucket</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainBucket(volumeList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainBucket-class_+3A_volumelist">volumeList</code></td>
<td>
<p>a named list of <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+BrainBucket-class">BrainBucket</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>source</code></dt><dd><p>the data source for the bucket volumes</p>
</dd>
<dt><code>labels</code></dt><dd><p>the names of the sub-volumes contained in the bucket</p>
</dd>
<dt><code>data</code></dt><dd><p>a list of <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instances with names corresponding to volume labels</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>vol1 &lt;- BrainVolume(rnorm(24*24*24), BrainSpace(c(24,24,24), c(1,1,1)))
vol2 &lt;- BrainVolume(rnorm(24*24*24), BrainSpace(c(24,24,24), c(1,1,1)))
vol3 &lt;- BrainVolume(rnorm(24*24*24), BrainSpace(c(24,24,24), c(1,1,1)))
vlist &lt;- list(vol1,vol2,vol3)
names(vlist) &lt;- paste0("V", 1:3)
bucket &lt;- BrainBucket(vlist)
all.equal(dim(bucket[[1]]), dim(vol1))
</code></pre>

<hr>
<h2 id='BrainBucketSource-class'>BrainBucketSource</h2><span id='topic+BrainBucketSource'></span><span id='topic+BrainBucketSource-class'></span>

<h3>Description</h3>

<p>A class that is used to produce a <code><a href="#topic+BrainBucket-class">BrainBucket</a></code> instance
</p>
<p>Constructor function for <code><a href="#topic+BrainBucketSource-class">BrainBucketSource</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainBucketSource(fileName, pattern = NULL, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainBucketSource-class_+3A_filename">fileName</code></td>
<td>
<p>the name of the bucket file</p>
</td></tr>
<tr><td><code id="BrainBucketSource-class_+3A_pattern">pattern</code></td>
<td>
<p>optional regular expression used to filter the sub-volumes using associated labels</p>
</td></tr>
<tr><td><code id="BrainBucketSource-class_+3A_indices">indices</code></td>
<td>
<p>optional set of sub-volume indices to load</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>sourceList</code></dt><dd><p>a list of sources for the bucket sub-volumes</p>
</dd>
<dt><code>cache</code></dt><dd><p>a cache used to store data in memory</p>
</dd>
</dl>

<hr>
<h2 id='BrainData-class'>BrainData</h2><span id='topic+BrainData-class'></span>

<h3>Description</h3>

<p>Base class for brain image data
</p>


<h3>Slots</h3>


<dl>
<dt><code>source</code></dt><dd><p>an instance of class <code><a href="#topic+BaseSource-class">BaseSource</a></code> to store the source of the data</p>
</dd>
<dt><code>space</code></dt><dd><p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code> to represent the geometry of the data space</p>
</dd>
</dl>

<hr>
<h2 id='BrainFileDescriptor-class'>BrainFileDescriptor</h2><span id='topic+BrainFileDescriptor-class'></span>

<h3>Description</h3>

<p>This class represents a neuroimaging file format
</p>


<h3>Slots</h3>


<dl>
<dt><code>fileFormat</code></dt><dd><p>the name of the file format (e.g. NIfTI)</p>
</dd>
<dt><code>headerEncoding</code></dt><dd><p>the file encoding of the header file (e.g. 'raw' for binary, 'gzip' for gz compressed')</p>
</dd>
<dt><code>headerExtension</code></dt><dd><p>the file extension for the header file (e.g. 'nii' for NIfTI single files)</p>
</dd>
<dt><code>dataEncoding</code></dt><dd><p>the file encoding for the data file</p>
</dd>
<dt><code>dataExtension</code></dt><dd><p>the file extension for the data file (e.g. 'nii' for NIfTI single files)</p>
</dd>
</dl>

<hr>
<h2 id='BrainFileSource-class'>BrainFileSource
Base class for representing a data source for images. The purpose of this class is to provide a layer in between 
low level IO and image loading functionality.</h2><span id='topic+BrainFileSource-class'></span>

<h3>Description</h3>

<p>BrainFileSource
</p>
<p>Base class for representing a data source for images. The purpose of this class is to provide a layer in between 
low level IO and image loading functionality.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metaInfo</code></dt><dd><p>meta information for the data source</p>
</dd>
</dl>

<hr>
<h2 id='BrainMetaInfo-class'>BrainMetaInfo
This class contains meta information from an image</h2><span id='topic+BrainMetaInfo'></span><span id='topic+BrainMetaInfo-class'></span>

<h3>Description</h3>

<p>BrainMetaInfo
</p>
<p>This class contains meta information from an image
</p>
<p>This class contains meta information for an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainMetaInfo(Dim, spacing, origin = rep(0, length(spacing)),
  dataType = "FLOAT", label = "",
  spatialAxes = OrientationList3D$AXIAL_LPI, additionalAxes = NullAxis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainMetaInfo-class_+3A_dim">Dim</code></td>
<td>
<p>image dimensions</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_spacing">spacing</code></td>
<td>
<p>voxel dimensions</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_origin">origin</code></td>
<td>
<p>coordinate origin</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_datatype">dataType</code></td>
<td>
<p>the type of the data (e.g. &quot;FLOAT&quot;)</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_label">label</code></td>
<td>
<p>name(s) of images</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_spatialaxes">spatialAxes</code></td>
<td>
<p>image axes for spatial dimensions (x,y,z)</p>
</td></tr>
<tr><td><code id="BrainMetaInfo-class_+3A_additionalaxes">additionalAxes</code></td>
<td>
<p>axes for dimensions &gt; 3 (e.g. time, color band, direction)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+BrainMetaInfo-class">BrainMetaInfo</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>dataType</code></dt><dd><p>the data type code, e.g. FLOAT</p>
</dd>
<dt><code>Dim</code></dt><dd><p>image dimensions</p>
</dd>
<dt><code>spatialAxes</code></dt><dd><p>image axes for spatial dimensions (x,y,z)</p>
</dd>
<dt><code>additionalAxes</code></dt><dd><p>axes for dimensions &gt; 3 (e.g. time, color band, direction)</p>
</dd>
<dt><code>spacing</code></dt><dd><p>voxel dimensions</p>
</dd>
<dt><code>origin</code></dt><dd><p>coordinate origin</p>
</dd>
<dt><code>label</code></dt><dd><p>name(s) of images</p>
</dd>
</dl>

<hr>
<h2 id='BrainSlice'>BrainSlice constructor</h2><span id='topic+BrainSlice'></span>

<h3>Description</h3>

<p>BrainSlice constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainSlice(data, space, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainSlice_+3A_data">data</code></td>
<td>
<p>data vector or matrix</p>
</td></tr>
<tr><td><code id="BrainSlice_+3A_space">space</code></td>
<td>
<p>an instance of class BrainSpace</p>
</td></tr>
<tr><td><code id="BrainSlice_+3A_indices">indices</code></td>
<td>
<p>linear indices corresponding used if <code>data</code> is a 1D vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(64,64), spacing=c(1,1))
dat &lt;- array(rnorm(64*64), c(64,64))
bslice &lt;- BrainSlice(dat,bspace)
print(bslice) 
</code></pre>

<hr>
<h2 id='BrainSlice-class'>BrainSlice</h2><span id='topic+BrainSlice-class'></span>

<h3>Description</h3>

<p>Two-dimensional brain image
</p>

<hr>
<h2 id='BrainSource-class'>BrainSource</h2><span id='topic+BrainSource-class'></span>

<h3>Description</h3>

<p>Base class for representing a data source for images. The purpose of this class is to provide a layer in between 
low level IO and image loading functionality.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metaInfo</code></dt><dd><p>meta information for the data source</p>
</dd>
</dl>

<hr>
<h2 id='BrainSpace'>Constructor function for <code><a href="#topic+BrainSpace-class">BrainSpace</a></code> class</h2><span id='topic+BrainSpace'></span>

<h3>Description</h3>

<p>Constructor function for <code><a href="#topic+BrainSpace-class">BrainSpace</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainSpace(Dim, spacing = NULL, origin = NULL, axes = NULL,
  trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainSpace_+3A_dim">Dim</code></td>
<td>
<p>a vector describing the dimensions of the spatial grid</p>
</td></tr>
<tr><td><code id="BrainSpace_+3A_spacing">spacing</code></td>
<td>
<p>the real-valued voxel dimensions (usually in millimeters)</p>
</td></tr>
<tr><td><code id="BrainSpace_+3A_origin">origin</code></td>
<td>
<p>the coordinate origin of the image space</p>
</td></tr>
<tr><td><code id="BrainSpace_+3A_axes">axes</code></td>
<td>
<p>the image axes ordering (default is based on the NIFTI standard, Left-Posterior-Inferior)</p>
</td></tr>
<tr><td><code id="BrainSpace_+3A_trans">trans</code></td>
<td>
<p>a matrix representing the coordinate transformation associated with the image space (default is based on the NIFTI standard, Left-Posterior-Inferior)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code>
</p>


<h3>Note</h3>

<p>one should rarely need to create a new <code>BrainSpace</code> instance, as it will almost always be created automatically using information stored in an image header.
Also, If one already has an existing image object, its <code>BrainSpace</code> instance can be easily extracted with the <code>space</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(64,64,64), origin=c(0,0,0), spacing=c(2,2,2))
print(bspace)
origin(bspace)
axes(bspace)
trans(bspace)
</code></pre>

<hr>
<h2 id='BrainSpace-class'>BrainSpace</h2><span id='topic+BrainSpace-class'></span>

<h3>Description</h3>

<p>This class represents the geometry of a brain image
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code></dt><dd><p>the grid dimensions of the image</p>
</dd>
<dt><code>origin</code></dt><dd><p>the coordinates of the spatial origin</p>
</dd>
<dt><code>spacing</code></dt><dd><p>the dimensions (in mm) of the grid units (voxels)</p>
</dd>
<dt><code>axes</code></dt><dd><p>the set of named spatial axes</p>
</dd>
<dt><code>trans</code></dt><dd><p>an affine transformation matrix that moves from grid -&gt; real world coordinates</p>
</dd>
<dt><code>inverseTrans</code></dt><dd><p>an inverse matrix that moves from real world -&gt; grid coordinates</p>
</dd>
</dl>

<hr>
<h2 id='BrainSurface-class'>BrainSurface</h2><span id='topic+BrainSurface-class'></span>

<h3>Description</h3>

<p>a three-dimensional surface consisting of a set of triangle vertices with one value per vertex.
</p>


<h3>Slots</h3>


<dl>
<dt><code>source</code></dt><dd><p>the data source for the surface</p>
</dd>
<dt><code>mesh</code></dt><dd><p>the underlying <code>mesh3d</code> object</p>
</dd>
<dt><code>data</code></dt><dd><p>the vector of data value at each vertex of the mesh</p>
</dd>
</dl>

<hr>
<h2 id='BrainSurfaceSource-class'>BrainSurfaceSource</h2><span id='topic+BrainSurfaceSource'></span><span id='topic+BrainSurfaceSource-class'></span>

<h3>Description</h3>

<p>A class that is used to produce a <code><a href="#topic+BrainSurface-class">BrainSurface</a></code> instance
</p>
<p>Constructor for BrainSurfaceSource
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainSurfaceSource(surfaceName, surfaceDataName, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainSurfaceSource-class_+3A_surfacename">surfaceName</code></td>
<td>
<p>the name of the file containing the surface geometry.</p>
</td></tr>
<tr><td><code id="BrainSurfaceSource-class_+3A_surfacedataname">surfaceDataName</code></td>
<td>
<p>the name of the file containing the data values to be mapped to the surface.</p>
</td></tr>
<tr><td><code id="BrainSurfaceSource-class_+3A_index">index</code></td>
<td>
<p>the integer offset into the surface data matrix</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>metaInfo</code></dt><dd><p>a <code><a href="#topic+SurfaceGeometryMetaInfo-class">SurfaceGeometryMetaInfo</a></code> instance</p>
</dd>
<dt><code>dataMetaInfo</code></dt><dd><p>a <code><a href="#topic+SurfaceDataMetaInfo-class">SurfaceDataMetaInfo</a></code> instance</p>
</dd>
<dt><code>index</code></dt><dd><p>the index offset into the surface data matrix</p>
</dd>
</dl>

<hr>
<h2 id='BrainSurfaceVector-class'>BrainSurfaceVector</h2><span id='topic+BrainSurfaceVector-class'></span>

<h3>Description</h3>

<p>a three-dimensional surface consisting of a set of triangle vertices with multiple values per vertex.
</p>


<h3>Slots</h3>


<dl>
<dt><code>source</code></dt><dd><p>the data source for the surface</p>
</dd>
<dt><code>mesh</code></dt><dd><p>the underlying <code>mesh3d</code> object</p>
</dd>
<dt><code>mat</code></dt><dd><p>a matrix of values where each column contains a vector of values over the surface nodes.</p>
</dd>
</dl>

<hr>
<h2 id='BrainSurfaceVectorSource-class'>BrainSurfaceVectorSource</h2><span id='topic+BrainSurfaceVectorSource-class'></span>

<h3>Description</h3>

<p>A class that is used to produce a <code><a href="#topic+BrainSurfaceVectorSource-class">BrainSurfaceVectorSource</a></code> instance
</p>


<h3>Slots</h3>


<dl>
<dt><code>indices</code></dt><dd><p>the index vector of the volumes to be loaded</p>
</dd>
</dl>

<hr>
<h2 id='BrainVector-class'>BrainVector</h2><span id='topic+BrainVector'></span><span id='topic+BrainVector-class'></span>

<h3>Description</h3>

<p>Four-dimensional brain image
</p>
<p>constructor function for virtual class <code><a href="#topic+BrainVector-class">BrainVector</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainVector(data, space = NULL, mask = NULL, source = NULL, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainVector-class_+3A_data">data</code></td>
<td>
<p>the image data which can be a <code>matrix</code>, a 4d <code>array</code>, or a list of <code>BrainVolumes</code>. 
If the latter, the geometric space of the data <code>BrainSpace</code> will be inferred from the constituent volumes, 
which must all be identical.</p>
</td></tr>
<tr><td><code id="BrainVector-class_+3A_space">space</code></td>
<td>
<p>a <code><a href="#topic+BrainSpace-class">BrainSpace</a></code> object. Does not ned to be included if <code>data</code> argument is a list of <code>BrainVolumes</code></p>
</td></tr>
<tr><td><code id="BrainVector-class_+3A_mask">mask</code></td>
<td>
<p>an optional <code>array</code> of type <code>logical</code></p>
</td></tr>
<tr><td><code id="BrainVector-class_+3A_source">source</code></td>
<td>
<p>an optional <code><a href="#topic+BrainSource-class">BrainSource</a></code> object</p>
</td></tr>
<tr><td><code id="BrainVector-class_+3A_label">label</code></td>
<td>
<p>a label of type <code>character</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a concrete instance of <code><a href="#topic+BrainVector-class">BrainVector</a></code> class. 
If <code>mask</code> is provided then <code><a href="#topic+SparseBrainVector-class">SparseBrainVector</a></code>, otherwise <code><a href="#topic+DenseBrainVector-class">DenseBrainVector</a></code>
</p>

<hr>
<h2 id='BrainVectorSource'>BrainVectorSource</h2><span id='topic+BrainVectorSource'></span>

<h3>Description</h3>

<p>Construct a <code><a href="#topic+BrainVectorSource-class">BrainVectorSource</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainVectorSource(fileName, indices = NULL, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainVectorSource_+3A_filename">fileName</code></td>
<td>
<p>name of the 4-dimensional image file</p>
</td></tr>
<tr><td><code id="BrainVectorSource_+3A_indices">indices</code></td>
<td>
<p>the subset of integer volume indices to load &ndash; if <code>NULL</code> then all volumes will be loaded</p>
</td></tr>
<tr><td><code id="BrainVectorSource_+3A_mask">mask</code></td>
<td>
<p>image volume indicating the subset of voxels that will be loaded. If provided, function returns <code><a href="#topic+SparseBrainVectorSource-class">SparseBrainVectorSource</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a <code>mask</code> is supplied then it should be a <code><a href="#topic+LogicalBrainVolume-class">LogicalBrainVolume</a></code> or <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instance. If the latter, then the mask will be defined by nonzero elements of the volume.
</p>


<h3>Value</h3>

<p>a instance deriving from <code><a href="#topic+BrainVectorSource-class">BrainVectorSource</a></code>
</p>

<hr>
<h2 id='BrainVectorSource-class'>BrainVectorSource</h2><span id='topic+BrainVectorSource-class'></span>

<h3>Description</h3>

<p>A class that is used to produce a <code><a href="#topic+BrainVectorSource-class">BrainVectorSource</a></code> instance
</p>


<h3>Slots</h3>


<dl>
<dt><code>indices</code></dt><dd><p>the index vector of the volumes to be loaded</p>
</dd>
</dl>

<hr>
<h2 id='BrainVolume'>BrainVolume</h2><span id='topic+BrainVolume'></span>

<h3>Description</h3>

<p>Construct a <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instance, using default (dense) implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainVolume(data, space, source = NULL, label = "", indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainVolume_+3A_data">data</code></td>
<td>
<p>a three-dimensional <code>array</code></p>
</td></tr>
<tr><td><code id="BrainVolume_+3A_space">space</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code></p>
</td></tr>
<tr><td><code id="BrainVolume_+3A_source">source</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="BrainVolume_+3A_label">label</code></td>
<td>
<p>a <code>character</code> string to identify volume</p>
</td></tr>
<tr><td><code id="BrainVolume_+3A_indices">indices</code></td>
<td>
<p>an 1D vector that gives the linear indices of the associated <code>data</code> vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code> instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(64,64,64), spacing=c(1,1,1))
dat &lt;- array(rnorm(64*64*64), c(64,64,64))
bvol &lt;- BrainVolume(dat,bspace, label="test")
print(bvol) 
</code></pre>

<hr>
<h2 id='BrainVolume-class'>Base class for image representing 3D volumetric data.</h2><span id='topic+BrainVolume-class'></span>

<h3>Description</h3>

<p>Base class for image representing 3D volumetric data.
</p>

<hr>
<h2 id='BrainVolumeSource-class'>BrainVolume
BrainVolumeSource
A class is used to produce a <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instance</h2><span id='topic+BrainVolumeSource'></span><span id='topic+BrainVolumeSource-class'></span>

<h3>Description</h3>

<p>BrainVolume
BrainVolumeSource
</p>
<p>A class is used to produce a <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instance
</p>
<p>Constructor for BrainVolumeSource
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrainVolumeSource(input, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BrainVolumeSource-class_+3A_input">input</code></td>
<td>
<p>the input file name</p>
</td></tr>
<tr><td><code id="BrainVolumeSource-class_+3A_index">index</code></td>
<td>
<p>the image subvolume index</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>index</code></dt><dd><p>the index of the volume to be read &ndash; must be of length 1.</p>
</dd>
</dl>

<hr>
<h2 id='close+2CBinaryReader-method'>close</h2><span id='topic+close+2CBinaryReader-method'></span><span id='topic+close+2CBinaryWriter-method'></span>

<h3>Description</h3>

<p>close
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BinaryReader'
close(con)

## S4 method for signature 'BinaryWriter'
close(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close+2B2CBinaryReader-method_+3A_con">con</code></td>
<td>
<p>the object to close</p>
</td></tr>
</table>

<hr>
<h2 id='clusterCenters'>clusterCenters</h2><span id='topic+clusterCenters'></span><span id='topic+clusterCenters+2CClusteredBrainVolume+2Cmatrix+2Cmissing-method'></span>

<h3>Description</h3>

<p>clusterCenters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterCenters(x, features, FUN)

## S4 method for signature 'ClusteredBrainVolume,matrix,missing'
clusterCenters(x, features)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterCenters_+3A_x">x</code></td>
<td>
<p>the object to extract cluster centers from</p>
</td></tr>
<tr><td><code id="clusterCenters_+3A_features">features</code></td>
<td>
<p>additional features</p>
</td></tr>
<tr><td><code id="clusterCenters_+3A_fun">FUN</code></td>
<td>
<p>a user-supplied function</p>
</td></tr>
</table>

<hr>
<h2 id='ClusteredBrainVolume-class'>ClusteredBrainVolume</h2><span id='topic+ClusteredBrainVolume'></span><span id='topic+ClusteredBrainVolume-class'></span>

<h3>Description</h3>

<p>Three-dimensional brain image that is divided into N disjoint partitions
</p>
<p>Construct a <code><a href="#topic+ClusteredBrainVolume-class">ClusteredBrainVolume</a></code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusteredBrainVolume(mask, clusters, labelMap = NULL, source = NULL,
  label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusteredBrainVolume-class_+3A_mask">mask</code></td>
<td>
<p>an instance of class <code><a href="#topic+LogicalBrainVolume-class">LogicalBrainVolume</a></code></p>
</td></tr>
<tr><td><code id="ClusteredBrainVolume-class_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clusters ids with length equal to number of nonzero voxels in mask <code>mask</code></p>
</td></tr>
<tr><td><code id="ClusteredBrainVolume-class_+3A_labelmap">labelMap</code></td>
<td>
<p>an optional <code>list</code> that maps from cluster id to a cluster label, e.g. (1 -&gt; &quot;FFA&quot;, 2 -&gt; &quot;PPA&quot;)</p>
</td></tr>
<tr><td><code id="ClusteredBrainVolume-class_+3A_source">source</code></td>
<td>
<p>an optional instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="ClusteredBrainVolume-class_+3A_label">label</code></td>
<td>
<p>an optional <code>character</code> string used to label of the volume</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+ClusteredBrainVolume-class">ClusteredBrainVolume</a></code> instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bspace &lt;- BrainSpace(c(16,16,16), spacing=c(1,1,1))
grid &lt;- indexToGrid(bspace, 1:(16*16*16))
kres &lt;- kmeans(grid, centers=10)
mask &lt;- BrainVolume(rep(1, 16^3),bspace)
clusvol &lt;- ClusteredBrainVolume(mask, kres$cluster)
</code></pre>

<hr>
<h2 id='ColumnReader'>ColumnReader</h2><span id='topic+ColumnReader'></span>

<h3>Description</h3>

<p>Constructor for  <code><a href="#topic+ColumnReader-class">ColumnReader</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColumnReader(nrow, ncol, reader)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ColumnReader_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows</p>
</td></tr>
<tr><td><code id="ColumnReader_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns</p>
</td></tr>
<tr><td><code id="ColumnReader_+3A_reader">reader</code></td>
<td>
<p>a function that takes a set of column indices and returns a <code>matrix</code></p>
</td></tr>
</table>

<hr>
<h2 id='ColumnReader-class'>ColumnReader</h2><span id='topic+ColumnReader-class'></span>

<h3>Description</h3>

<p>This class supports reading of data froma matrix-like stroage format
</p>


<h3>Slots</h3>


<dl>
<dt><code>nrow</code></dt><dd><p>the number of rows</p>
</dd>
<dt><code>ncol</code></dt><dd><p>the number of columns</p>
</dd>
<dt><code>reader</code></dt><dd><p>a function that takes a set of column indices and returns a <code>matrix</code></p>
</dd>
</dl>

<hr>
<h2 id='concat'>Concatenate two objects</h2><span id='topic+concat'></span><span id='topic+concat+2CBrainVector+2CBrainVector-method'></span><span id='topic+concat+2CBrainVector+2CBrainVolume-method'></span><span id='topic+concat+2CBrainVolume+2CBrainVector-method'></span><span id='topic+concat+2CDenseBrainVolume+2CDenseBrainVolume-method'></span><span id='topic+concat+2CSparseBrainVector+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>Concatenate two objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat(x, y, ...)

## S4 method for signature 'SparseBrainVector,SparseBrainVector'
concat(x, y, ...)

## S4 method for signature 'BrainVector,BrainVolume'
concat(x, y, ...)

## S4 method for signature 'BrainVolume,BrainVector'
concat(x, y, ...)

## S4 method for signature 'BrainVector,BrainVector'
concat(x, y, ...)

## S4 method for signature 'DenseBrainVolume,DenseBrainVolume'
concat(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat_+3A_x">x</code></td>
<td>
<p>the first object, typically <code>BrainVolume</code> or <code>BrainVector</code></p>
</td></tr>
<tr><td><code id="concat_+3A_y">y</code></td>
<td>
<p>the second object, typically <code>BrainVolume</code> or <code>BrainVector</code></p>
</td></tr>
<tr><td><code id="concat_+3A_...">...</code></td>
<td>
<p>additional objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>x</code> and <code>y</code> images must have compatible dimensions. a <code>BrainVolume</code> can be concatenated to <code>BrainVector</code>, and vice versa. See examples.
</p>


<h3>Note</h3>

<p>dimensions of x and y must be equal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bv1 &lt;- BrainVolume(rep(1,1000), BrainSpace(c(10,10,10), c(1,1,1)))
bv2 &lt;- BrainVolume(rep(2,1000), BrainSpace(c(10,10,10), c(1,1,1)))
bv3 &lt;- concat(bv1,bv2)
inherits(bv3, "BrainVector")

bv4 &lt;- concat(bv3, bv1)
dim(bv4)[4] == 3
bv5 &lt;- concat(bv1, bv3)
dim(bv4)[4] == 3

bv6 &lt;- concat(bv4,bv5)
dim(bv6)[4] == 6

</code></pre>

<hr>
<h2 id='connComp'>Find connected components</h2><span id='topic+connComp'></span><span id='topic+connComp+2CBrainVolume-method'></span>

<h3>Description</h3>

<p>Find connected components
</p>
<p>find connected components in BrainVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connComp(x, ...)

## S4 method for signature 'BrainVolume'
connComp(x, threshold = 0, clusterTable = TRUE,
  localMaxima = TRUE, localMaximaDistance = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connComp_+3A_x">x</code></td>
<td>
<p>the image object</p>
</td></tr>
<tr><td><code id="connComp_+3A_...">...</code></td>
<td>
<p>additonal arguments</p>
</td></tr>
<tr><td><code id="connComp_+3A_threshold">threshold</code></td>
<td>
<p>threshold defining lower intensity bound for image mask</p>
</td></tr>
<tr><td><code id="connComp_+3A_clustertable">clusterTable</code></td>
<td>
<p>return clusterTable</p>
</td></tr>
<tr><td><code id="connComp_+3A_localmaxima">localMaxima</code></td>
<td>
<p>return table of local maxima</p>
</td></tr>
<tr><td><code id="connComp_+3A_localmaximadistance">localMaximaDistance</code></td>
<td>
<p>the distance used to define minum distance between local maxima</p>
</td></tr>
</table>

<hr>
<h2 id='connComp3D'>Extract connected components from a 3D mask</h2><span id='topic+connComp3D'></span>

<h3>Description</h3>

<p>Extract connected components from a 3D mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connComp3D(mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connComp3D_+3A_mask">mask</code></td>
<td>
<p>a 3D binary array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a two-element list of the connected components (cluster <code>index</code> and cluster <code>size</code>)
The first element <code>index</code> is a 3D array containing the cluster index of the connected component for each voxel.
The second element <code>size</code> is a 3D array consisting of the size of the connected component inhabited by each voxel.
</p>

<hr>
<h2 id='coords'>Extract coordinates</h2><span id='topic+coords'></span><span id='topic+coords+2CIndexLookupVolume-method'></span><span id='topic+coords+2CROIVolume-method'></span><span id='topic+coords+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>Extract coordinates
</p>
<p>coords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(x, ...)

## S4 method for signature 'ROIVolume'
coords(x)

## S4 method for signature 'SparseBrainVector'
coords(x, i)

## S4 method for signature 'IndexLookupVolume'
coords(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p>the object to extract coordinates from</p>
</td></tr>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="coords_+3A_i">i</code></td>
<td>
<p>the index in to the lookup volume</p>
</td></tr>
</table>

<hr>
<h2 id='coordToGrid'>Generic function to convert N-dimensional real world coordinates to grid coordinates</h2><span id='topic+coordToGrid'></span><span id='topic+coordToGrid+2CBrainSpace+2Cmatrix-method'></span><span id='topic+coordToGrid+2CBrainSpace+2Cnumeric-method'></span><span id='topic+coordToGrid+2CBrainVolume+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Generic function to convert N-dimensional real world coordinates to grid coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordToGrid(x, coords)

## S4 method for signature 'BrainSpace,matrix'
coordToGrid(x, coords)

## S4 method for signature 'BrainSpace,numeric'
coordToGrid(x, coords)

## S4 method for signature 'BrainVolume,matrix'
coordToGrid(x, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordToGrid_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="coordToGrid_+3A_coords">coords</code></td>
<td>
<p>a matrix of real world coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of grid coordinates
</p>

<hr>
<h2 id='coordToIndex'>Generic function to convert N-dimensional real world coordinates to 1D indices</h2><span id='topic+coordToIndex'></span><span id='topic+coordToIndex+2CBrainSpace+2Cmatrix-method'></span><span id='topic+coordToIndex+2CBrainSpace+2Cnumeric-method'></span><span id='topic+coordToIndex+2CBrainVolume+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Generic function to convert N-dimensional real world coordinates to 1D indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordToIndex(x, coords)

## S4 method for signature 'BrainSpace,matrix'
coordToIndex(x, coords)

## S4 method for signature 'BrainSpace,numeric'
coordToIndex(x, coords)

## S4 method for signature 'BrainVolume,matrix'
coordToIndex(x, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordToIndex_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="coordToIndex_+3A_coords">coords</code></td>
<td>
<p>a matrix of real world coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices
</p>

<hr>
<h2 id='dataFile'>Generic function to get the name of the data file, given a file name and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.</h2><span id='topic+dataFile'></span><span id='topic+dataFile+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to get the name of the data file, given a file name and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataFile(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
dataFile(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataFile_+3A_x">x</code></td>
<td>
<p>descriptor instance</p>
</td></tr>
<tr><td><code id="dataFile_+3A_filename">fileName</code></td>
<td>
<p>file name to be stripped of its extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correct header name
</p>

<hr>
<h2 id='dataFileMatches'>Generic function to test whether a file name conforms to the given a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to data file only</h2><span id='topic+dataFileMatches'></span><span id='topic+dataFileMatches+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to test whether a file name conforms to the given a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to data file only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataFileMatches(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
dataFileMatches(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataFileMatches_+3A_x">x</code></td>
<td>
<p>object for which the file name is to matched to</p>
</td></tr>
<tr><td><code id="dataFileMatches_+3A_filename">fileName</code></td>
<td>
<p>file name to be matched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE for match, FALSE otherwise
</p>

<hr>
<h2 id='dataReader'>Generic function to create data reader</h2><span id='topic+dataReader'></span><span id='topic+dataReader+2CAFNIMetaInfo-method'></span><span id='topic+dataReader+2CNIMLSurfaceDataMetaInfo-method'></span><span id='topic+dataReader+2CNIfTIMetaInfo-method'></span>

<h3>Description</h3>

<p>Generic function to create data reader
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataReader(x, offset)

## S4 method for signature 'NIfTIMetaInfo'
dataReader(x, offset = 0)

## S4 method for signature 'AFNIMetaInfo'
dataReader(x, offset = 0)

## S4 method for signature 'NIMLSurfaceDataMetaInfo'
dataReader(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataReader_+3A_x">x</code></td>
<td>
<p>an object specifying the infromation required to produce the reader</p>
</td></tr>
<tr><td><code id="dataReader_+3A_offset">offset</code></td>
<td>
<p>the byte offset (number of bytes to skip before reading)</p>
</td></tr>
</table>

<hr>
<h2 id='DenseBrainVector-class'>DenseBrainVector</h2><span id='topic+DenseBrainVector'></span><span id='topic+DenseBrainVector-class'></span>

<h3>Description</h3>

<p>Four-dimensional brain image, backed by an array
</p>
<p>constructor function for class <code><a href="#topic+DenseBrainVector-class">DenseBrainVector</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenseBrainVector(data, space, source = NULL, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenseBrainVector-class_+3A_data">data</code></td>
<td>
<p>a 4-dimensional <code>array</code> or a 2-dimension <code>matrix</code> that is either nvoxels by ntime-points or ntime-points by nvoxels</p>
</td></tr>
<tr><td><code id="DenseBrainVector-class_+3A_space">space</code></td>
<td>
<p>a <code><a href="#topic+BrainSpace-class">BrainSpace</a></code> object</p>
</td></tr>
<tr><td><code id="DenseBrainVector-class_+3A_source">source</code></td>
<td>
<p>an optional <code><a href="#topic+BrainSource-class">BrainSource</a></code> object</p>
</td></tr>
<tr><td><code id="DenseBrainVector-class_+3A_label">label</code></td>
<td>
<p>a label of type <code>character</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+DenseBrainVector-class">DenseBrainVector</a></code> instance
</p>

<hr>
<h2 id='DenseBrainVolume-class'>DenseBrainVolume</h2><span id='topic+DenseBrainVolume'></span><span id='topic+DenseBrainVolume-class'></span>

<h3>Description</h3>

<p>Three-dimensional brain image, backed by an <code>array</code>
</p>
<p>Construct a <code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DenseBrainVolume(data, space, source = NULL, label = "", indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DenseBrainVolume-class_+3A_data">data</code></td>
<td>
<p>a three-dimensional <code>array</code></p>
</td></tr>
<tr><td><code id="DenseBrainVolume-class_+3A_space">space</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code></p>
</td></tr>
<tr><td><code id="DenseBrainVolume-class_+3A_source">source</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="DenseBrainVolume-class_+3A_label">label</code></td>
<td>
<p>a <code>character</code> string</p>
</td></tr>
<tr><td><code id="DenseBrainVolume-class_+3A_indices">indices</code></td>
<td>
<p>an optional 1-d index vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code> instance
</p>

<hr>
<h2 id='dim+2CBrainData-method'>dim of <code>BrainData</code> object</h2><span id='topic+dim+2CBrainData-method'></span>

<h3>Description</h3>

<p>dim of <code>BrainData</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainData'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim+2B2CBrainData-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='dim+2CBrainSpace-method'>dim</h2><span id='topic+dim+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>dim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainSpace'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim+2B2CBrainSpace-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='dim+2CFileMetaInfo-method'>dim of <code>FileMetaInfo</code></h2><span id='topic+dim+2CFileMetaInfo-method'></span>

<h3>Description</h3>

<p>dim of <code>FileMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FileMetaInfo'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim+2B2CFileMetaInfo-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='dropDim'>Generic function to drop a dimension from an object</h2><span id='topic+dropDim'></span><span id='topic+dropDim+2CAxisSet2D+2Cmissing-method'></span><span id='topic+dropDim+2CAxisSet2D+2Cnumeric-method'></span><span id='topic+dropDim+2CAxisSet3D+2Cmissing-method'></span><span id='topic+dropDim+2CAxisSet3D+2Cnumeric-method'></span><span id='topic+dropDim+2CBrainSpace+2Cmissing-method'></span><span id='topic+dropDim+2CBrainSpace+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to drop a dimension from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropDim(x, dimnum)

## S4 method for signature 'AxisSet2D,numeric'
dropDim(x, dimnum)

## S4 method for signature 'AxisSet2D,missing'
dropDim(x, dimnum)

## S4 method for signature 'AxisSet3D,numeric'
dropDim(x, dimnum)

## S4 method for signature 'AxisSet3D,missing'
dropDim(x, dimnum)

## S4 method for signature 'BrainSpace,numeric'
dropDim(x, dimnum)

## S4 method for signature 'BrainSpace,missing'
dropDim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropDim_+3A_x">x</code></td>
<td>
<p>a dimensioned object</p>
</td></tr>
<tr><td><code id="dropDim_+3A_dimnum">dimnum</code></td>
<td>
<p>the index of the dimension to drop</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = BrainSpace(c(10,10,10), c(1,1,1))
x1 &lt;- dropDim(x)
ndim(x1) == 2
dim(x1)[2] == 10
</code></pre>

<hr>
<h2 id='eachSeries'>Generic functions to apply a function to each series of a 4D image
That is, if the 4th dimension is 'time' each series is a 1D time series.</h2><span id='topic+eachSeries'></span><span id='topic+eachSeries+2CBrainVector+2Cfunction+2Cmissing-method'></span><span id='topic+eachSeries+2CSparseBrainVector+2Cfunction+2Clogical-method'></span>

<h3>Description</h3>

<p>Generic functions to apply a function to each series of a 4D image
That is, if the 4th dimension is 'time' each series is a 1D time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eachSeries(x, FUN, withIndex, ...)

## S4 method for signature 'SparseBrainVector,'function',logical'
eachSeries(x, FUN,
  withIndex = FALSE, ...)

## S4 method for signature 'BrainVector,'function',missing'
eachSeries(x, FUN,
  withIndex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eachSeries_+3A_x">x</code></td>
<td>
<p>a four dimensional image</p>
</td></tr>
<tr><td><code id="eachSeries_+3A_fun">FUN</code></td>
<td>
<p>a <code>function</code> taking one or two arguments (depending on the value of <code>withIndex</code></p>
</td></tr>
<tr><td><code id="eachSeries_+3A_withindex">withIndex</code></td>
<td>
<p>whether the index of the series is supplied as the second argument to the function</p>
</td></tr>
<tr><td><code id="eachSeries_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when <code>x</code> is a <code>SparseBrainVector</code> <code>eachSeries</code> only iterates over nonzero series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
res &lt;- eachSeries(bvec, mean)
length(res) == 24*24*24
</code></pre>

<hr>
<h2 id='eachSlice'>Generic functions to apply a function to each (2D) slice of an image</h2><span id='topic+eachSlice'></span><span id='topic+eachSlice+2CBrainVolume+2Cfunction+2Clogical-method'></span><span id='topic+eachSlice+2CBrainVolume+2Cfunction+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic functions to apply a function to each (2D) slice of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eachSlice(x, FUN, withIndex, ...)

## S4 method for signature 'BrainVolume,'function',missing'
eachSlice(x, FUN)

## S4 method for signature 'BrainVolume,'function',logical'
eachSlice(x, FUN, withIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eachSlice_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="eachSlice_+3A_fun">FUN</code></td>
<td>
<p>a <code>function</code> taking one or two arguments (depending on the value of <code>withIndex</code></p>
</td></tr>
<tr><td><code id="eachSlice_+3A_withindex">withIndex</code></td>
<td>
<p>whether the index of the slice is supplied as the second argument to the function</p>
</td></tr>
<tr><td><code id="eachSlice_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='eachVolume'>Generic function to apply a function to each volume of a four-dimensional image</h2><span id='topic+eachVolume'></span><span id='topic+eachVolume+2CBrainBucket+2Cfunction+2Clogical+2CANY-method'></span><span id='topic+eachVolume+2CBrainBucket+2Cfunction+2Cmissing+2Cmissing-method'></span><span id='topic+eachVolume+2CBrainVector+2Cfunction+2Clogical+2CANY-method'></span><span id='topic+eachVolume+2CBrainVector+2Cfunction+2Cmissing+2CBrainVolume-method'></span><span id='topic+eachVolume+2CBrainVector+2Cfunction+2Cmissing+2Cmissing-method'></span><span id='topic+eachVolume+2CSparseBrainVector+2Cfunction+2Clogical+2Cmissing-method'></span><span id='topic+eachVolume+2CSparseBrainVector+2Cfunction+2Cmissing+2CLogicalBrainVolume-method'></span><span id='topic+eachVolume+2CSparseBrainVector+2Cfunction+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function to apply a function to each volume of a four-dimensional image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eachVolume(x, FUN, withIndex, mask, ...)

## S4 method for signature 'SparseBrainVector,'function',logical,missing'
eachVolume(x, FUN,
  withIndex = FALSE, mask, ...)

## S4 method for signature 'SparseBrainVector,'function',missing,missing'
eachVolume(x, FUN,
  withIndex, mask, ...)


  ## S4 method for signature 
## 'SparseBrainVector,&lsquo;function',missing,LogicalBrainVolume&rsquo;
eachVolume(x,
  FUN, withIndex, mask, ...)

## S4 method for signature 'BrainVector,'function',missing,missing'
eachVolume(x, FUN, withIndex,
  mask, ...)

## S4 method for signature 'BrainVector,'function',missing,BrainVolume'
eachVolume(x, FUN,
  withIndex, mask, ...)

## S4 method for signature 'BrainVector,'function',missing,missing'
eachVolume(x, FUN, withIndex,
  mask, ...)

## S4 method for signature 'BrainBucket,'function',missing,missing'
eachVolume(x, FUN, withIndex,
  mask, ...)

## S4 method for signature 'BrainBucket,'function',logical,ANY'
eachVolume(x, FUN, withIndex,
  mask, ...)

## S4 method for signature 'BrainVector,'function',logical,ANY'
eachVolume(x, FUN, withIndex,
  mask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eachVolume_+3A_x">x</code></td>
<td>
<p>four-dimensional image, e.g. of class <code>BrainVector</code></p>
</td></tr>
<tr><td><code id="eachVolume_+3A_fun">FUN</code></td>
<td>
<p>a <code>function</code> taking one or two arguments (depending on the value of <code>withIndex</code>)</p>
</td></tr>
<tr><td><code id="eachVolume_+3A_withindex">withIndex</code></td>
<td>
<p>whether the index of the volume supplied as the second argument to the function</p>
</td></tr>
<tr><td><code id="eachVolume_+3A_mask">mask</code></td>
<td>
<p>an image mask indicating subset of volume elements to apply function over</p>
</td></tr>
<tr><td><code id="eachVolume_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of results of apply <code>FUN</code> to each volume.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
res &lt;- eachVolume(bvec, mean)

res &lt;- eachVolume(bvec, function(x,i) median(x), withIndex=TRUE)
</code></pre>

<hr>
<h2 id='fileMatches'>Generic function to test whether a file name conforms to the given <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to either header file or data file</h2><span id='topic+fileMatches'></span><span id='topic+fileMatches+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to test whether a file name conforms to the given <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to either header file or data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileMatches(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
fileMatches(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fileMatches_+3A_x">x</code></td>
<td>
<p>object for which the file name is to matched to</p>
</td></tr>
<tr><td><code id="fileMatches_+3A_filename">fileName</code></td>
<td>
<p>file name to be matched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE for match, FALSE otherwise
</p>

<hr>
<h2 id='FileMetaInfo-class'>FileMetaInfo</h2><span id='topic+AFNIMetaInfo-class'></span><span id='topic+FileMetaInfo-class'></span><span id='topic+NIfTIMetaInfo-class'></span>

<h3>Description</h3>

<p>This class contains meta information from an image data file
</p>
<p>This class contains meta information for a NIfTI image file
</p>
<p>This class contains meta information for a AFNI image file
</p>


<h3>Slots</h3>


<dl>
<dt><code>headerFile</code></dt><dd><p>name of the file containing meta information</p>
</dd>
<dt><code>dataFile</code></dt><dd><p>name of the file containing data</p>
</dd>
<dt><code>fileDescriptor</code></dt><dd><p>descriptor of image file format</p>
</dd>
<dt><code>endian</code></dt><dd><p>byte order of data ('little' or 'big')</p>
</dd>
<dt><code>dataOffset</code></dt><dd><p>the number of bytes preceding the start of image data in data file</p>
</dd>
<dt><code>bytesPerElement</code></dt><dd><p>number of bytes per element</p>
</dd>
<dt><code>intercept</code></dt><dd><p>constant value added to image &ndash; multiple values allowed (must equal numer of sub-images)</p>
</dd>
<dt><code>slope</code></dt><dd><p>image multiplier &ndash; multiple values allowed (must equal numer of sub-images)</p>
</dd>
<dt><code>header</code></dt><dd><p>a list of format specific attributes</p>
</dd>
<dt><code>nifti_header</code></dt><dd><p>a <code>list</code> of attributes specific to the NIfTI file format</p>
</dd>
<dt><code>afni_header</code></dt><dd><p>a list of attributes specific to the AFNI file format</p>
</dd>
<dt><code>afni_header</code></dt><dd><p>a <code>list</code> of attributes specific to the AFNI file format</p>
</dd>
</dl>

<hr>
<h2 id='fill'>Generic function to map values from one set to another using a user-supplied lookup table</h2><span id='topic+fill'></span><span id='topic+fill+2CBrainVolume+2Clist-method'></span><span id='topic+fill+2CBrainVolume+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Generic function to map values from one set to another using a user-supplied lookup table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(x, lookup)

## S4 method for signature 'BrainVolume,list'
fill(x, lookup)

## S4 method for signature 'BrainVolume,matrix'
fill(x, lookup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_x">x</code></td>
<td>
<p>the object to map values from</p>
</td></tr>
<tr><td><code id="fill_+3A_lookup">lookup</code></td>
<td>
<p>the lookup table. The first column is the &quot;key&quot; the second column is the &quot;value&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new object where the original values have been filled in with the values in the lookup table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- BrainSpace(c(10,10,10), c(1,1,1))
vol &lt;- BrainVolume(sample(1:10, 10*10*10, replace=TRUE), x)

## lookup table is list
lookup &lt;- lapply(1:10, function(i) i*10)
ovol &lt;- fill(vol, lookup)

## lookup table is matrix. First column is key, second column is value
names(lookup) &lt;- 1:length(lookup)
lookup.mat &lt;- cbind(as.numeric(names(lookup)), unlist(lookup))
ovol2 &lt;- fill(vol, lookup.mat)
all.equal(as.vector(ovol2), as.vector(ovol))

</code></pre>

<hr>
<h2 id='FreesurferAsciiSurfaceFileDescriptor-class'>FresurferAsciiSurfaceFileDescriptor</h2><span id='topic+FreesurferAsciiSurfaceFileDescriptor-class'></span>

<h3>Description</h3>

<p>This class supports the FreesurferAsciiSurfaceFileDescriptor file format for surface geometry
</p>

<hr>
<h2 id='FreesurferSurfaceGeometryMetaInfo-class'>FreeSurferSurfaceGeometryMetaInfo
This class contains meta information for brain surface geometry</h2><span id='topic+FreesurferSurfaceGeometryMetaInfo-class'></span>

<h3>Description</h3>

<p>FreeSurferSurfaceGeometryMetaInfo
</p>
<p>This class contains meta information for brain surface geometry
</p>

<hr>
<h2 id='gridToCoord'>Generic function to convert N-dimensional grid coordinate coordinates to real world coordinates
Generic function to convert N-dimensional grid coordinates to real world coordinates</h2><span id='topic+gridToCoord'></span><span id='topic+gridToCoord+2CBrainSpace+2Cmatrix-method'></span><span id='topic+gridToCoord+2CBrainVolume+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Generic function to convert N-dimensional grid coordinate coordinates to real world coordinates
Generic function to convert N-dimensional grid coordinates to real world coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridToCoord(x, coords)

## S4 method for signature 'BrainSpace,matrix'
gridToCoord(x, coords)

## S4 method for signature 'BrainVolume,matrix'
gridToCoord(x, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridToCoord_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="gridToCoord_+3A_coords">coords</code></td>
<td>
<p>a matrix of grid coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of real coordinates
</p>

<hr>
<h2 id='gridToIndex'>Generic function to convert N-dimensional grid coordinate to 1D indices</h2><span id='topic+gridToIndex'></span><span id='topic+gridToIndex+2CBrainSlice+2Cmatrix-method'></span><span id='topic+gridToIndex+2CBrainSpace+2Cmatrix-method'></span><span id='topic+gridToIndex+2CBrainSpace+2Cnumeric-method'></span><span id='topic+gridToIndex+2CBrainVolume+2Cmatrix-method'></span><span id='topic+gridToIndex+2CBrainVolume+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to convert N-dimensional grid coordinate to 1D indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridToIndex(x, coords)

## S4 method for signature 'BrainSlice,matrix'
gridToIndex(x, coords)

## S4 method for signature 'BrainSpace,matrix'
gridToIndex(x, coords)

## S4 method for signature 'BrainSpace,numeric'
gridToIndex(x, coords)

## S4 method for signature 'BrainVolume,matrix'
gridToIndex(x, coords)

## S4 method for signature 'BrainVolume,numeric'
gridToIndex(x, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridToIndex_+3A_x">x</code></td>
<td>
<p>the object, typically a <code>BrainVolume</code> or <code>BrainSpace</code> instance.</p>
</td></tr>
<tr><td><code id="gridToIndex_+3A_coords">coords</code></td>
<td>
<p>a matrix where each row is a coordinate or a vector of length equal to <code>ndim(x)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices
</p>

<hr>
<h2 id='headerFile'>Generic function to get the name of the header file, given a file name and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.</h2><span id='topic+headerFile'></span><span id='topic+headerFile+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to get the name of the header file, given a file name and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headerFile(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
headerFile(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headerFile_+3A_x">x</code></td>
<td>
<p>descriptor instance</p>
</td></tr>
<tr><td><code id="headerFile_+3A_filename">fileName</code></td>
<td>
<p>file name to be stripped of its extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correct header name
</p>

<hr>
<h2 id='headerFileMatches'>Generic function to test whether a file name conforms to the given <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to header file only</h2><span id='topic+headerFileMatches'></span><span id='topic+headerFileMatches+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to test whether a file name conforms to the given <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
Will test for match to header file only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headerFileMatches(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
headerFileMatches(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headerFileMatches_+3A_x">x</code></td>
<td>
<p>object for which the file name is to matched to</p>
</td></tr>
<tr><td><code id="headerFileMatches_+3A_filename">fileName</code></td>
<td>
<p>file name to be matched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE for match, FALSE otherwise
</p>

<hr>
<h2 id='image+2CBrainVolume-method'>image</h2><span id='topic+image+2CBrainVolume-method'></span><span id='topic+image+2CLayer-method'></span><span id='topic+image+2COverlay-method'></span>

<h3>Description</h3>

<p>image
</p>
<p>image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainVolume'
image(x, slice, col = gray((0:255)/255, alpha = 1),
  zero.col = "#000000", axis = 3, ...)

## S4 method for signature 'Overlay'
image(x, zpos, axis = 3)

## S4 method for signature 'Layer'
image(x, zpos, axis = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_x">x</code></td>
<td>
<p>the object to display</p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_slice">slice</code></td>
<td>
<p>the voxel index of the slice to display</p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_col">col</code></td>
<td>
<p>a color map</p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_zero.col">zero.col</code></td>
<td>
<p>the color to use when the value is 0 (e.g background color)</p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_axis">axis</code></td>
<td>
<p>the axis index</p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_...">...</code></td>
<td>
<p>extra arguments to passed to <code>grid.raster</code></p>
</td></tr>
<tr><td><code id="image+2B2CBrainVolume-method_+3A_zpos">zpos</code></td>
<td>
<p>the z coordinate</p>
</td></tr>
</table>

<hr>
<h2 id='imageGrid'>imageGrid</h2><span id='topic+imageGrid'></span>

<h3>Description</h3>

<p>Display a set of images slices in a 2D montage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageGrid(layer, gridDim = c(3, 3), zstart, zend, panelSize = 3,
  panelUnit = "inches", interpolate = FALSE, fontCol = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageGrid_+3A_layer">layer</code></td>
<td>
<p>the layer to display</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_griddim">gridDim</code></td>
<td>
<p>the dimensions of the 2D grid montage</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_zstart">zstart</code></td>
<td>
<p>the z coordinate of the first slice</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_zend">zend</code></td>
<td>
<p>the z coordinate of the last slice</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_panelsize">panelSize</code></td>
<td>
<p>the size of each panel in the montage (default unit is inches)</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_panelunit">panelUnit</code></td>
<td>
<p>the unit for the panel size (default is inches)</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_interpolate">interpolate</code></td>
<td>
<p>whether to interpolate pixel values</p>
</td></tr>
<tr><td><code id="imageGrid_+3A_fontcol">fontCol</code></td>
<td>
<p>color of labels indicating slice level</p>
</td></tr>
</table>

<hr>
<h2 id='IndexLookupVolume-class'>IndexLookupVolume</h2><span id='topic+IndexLookupVolume'></span><span id='topic+IndexLookupVolume-class'></span>

<h3>Description</h3>

<p>Three-dimensional brain image that can be used as a map between 1D grid indices and a table of values
Currently used in the <code><a href="#topic+SparseBrainVector-class">SparseBrainVector</a></code> class.
</p>
<p>IndexLookupVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndexLookupVolume(space, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndexLookupVolume-class_+3A_space">space</code></td>
<td>
<p>a BrainSpace object</p>
</td></tr>
<tr><td><code id="IndexLookupVolume-class_+3A_indices">indices</code></td>
<td>
<p>the set of 1-d indices defining the lookup map</p>
</td></tr>
</table>

<hr>
<h2 id='indexToCoord'>Generic function to convert 1D indices to N-dimensional real world coordinates</h2><span id='topic+indexToCoord'></span><span id='topic+indexToCoord+2CBrainSpace+2Cindex-method'></span><span id='topic+indexToCoord+2CBrainVolume+2Cindex-method'></span>

<h3>Description</h3>

<p>Generic function to convert 1D indices to N-dimensional real world coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexToCoord(x, idx)

## S4 method for signature 'BrainSpace,index'
indexToCoord(x, idx)

## S4 method for signature 'BrainVolume,index'
indexToCoord(x, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexToCoord_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="indexToCoord_+3A_idx">idx</code></td>
<td>
<p>the 1D indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of real coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvol &lt;- BrainVolume(array(0, c(10,10,10)), BrainSpace(c(10,10,10), c(1,1,1)))
idx &lt;- 1:10
g &lt;- indexToCoord(bvol, idx)
idx2 &lt;- coordToIndex(bvol, g)
all.equal(idx, idx2)
</code></pre>

<hr>
<h2 id='indexToGrid'>Generic function to convert 1D indices to N-dimensional grid coordinates</h2><span id='topic+indexToGrid'></span><span id='topic+indexToGrid+2CBrainSlice+2Cindex-method'></span><span id='topic+indexToGrid+2CBrainSpace+2Cindex-method'></span><span id='topic+indexToGrid+2CBrainVector+2Cindex-method'></span><span id='topic+indexToGrid+2CBrainVolume+2Cindex-method'></span>

<h3>Description</h3>

<p>Generic function to convert 1D indices to N-dimensional grid coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexToGrid(x, idx)

## S4 method for signature 'BrainSlice,index'
indexToGrid(x, idx)

## S4 method for signature 'BrainSpace,index'
indexToGrid(x, idx)

## S4 method for signature 'BrainVector,index'
indexToGrid(x, idx)

## S4 method for signature 'BrainVolume,index'
indexToGrid(x, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexToGrid_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="indexToGrid_+3A_idx">idx</code></td>
<td>
<p>the 1D <code>vector</code> of indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of grid coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 bvol &lt;- BrainVolume(array(0, c(10,10,10)), BrainSpace(c(10,10,10), c(1,1,1)))
 idx &lt;- 1:10
 g &lt;- indexToGrid(bvol, idx)
 bvol[g]

</code></pre>

<hr>
<h2 id='indices'>Extract indices</h2><span id='topic+indices'></span><span id='topic+indices+2CIndexLookupVolume-method'></span><span id='topic+indices+2CROIVolume-method'></span><span id='topic+indices+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>Extract indices
</p>
<p>indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indices(x)

## S4 method for signature 'ROIVolume'
indices(x)

## S4 method for signature 'SparseBrainVector'
indices(x)

## S4 method for signature 'IndexLookupVolume'
indices(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indices_+3A_x">x</code></td>
<td>
<p>the object to extract indices</p>
</td></tr>
</table>

<hr>
<h2 id='inverseTrans'>Generic getter to extract inverse image coordinate transformation</h2><span id='topic+inverseTrans'></span><span id='topic+inverseTrans+2CBrainData-method'></span><span id='topic+inverseTrans+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic getter to extract inverse image coordinate transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseTrans(x)

## S4 method for signature 'BrainSpace'
inverseTrans(x)

## S4 method for signature 'BrainData'
inverseTrans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseTrans_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(10,10,10), c(2,2,2))
itrans &lt;- inverseTrans(bspace)
identical(trans(bspace) %*% inverseTrans(bspace), diag(4))
</code></pre>

<hr>
<h2 id='Kernel'>Create a Kernel object</h2><span id='topic+Kernel'></span>

<h3>Description</h3>

<p>Create a Kernel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kernel(kerndim, vdim, FUN = dnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kernel_+3A_kerndim">kerndim</code></td>
<td>
<p>the dimensions in voxels of the kernel</p>
</td></tr>
<tr><td><code id="Kernel_+3A_vdim">vdim</code></td>
<td>
<p>the dimensions of the voxels in real units</p>
</td></tr>
<tr><td><code id="Kernel_+3A_fun">FUN</code></td>
<td>
<p>the kernel function taking as its first argument representing the distance from the center of the kernel</p>
</td></tr>
<tr><td><code id="Kernel_+3A_...">...</code></td>
<td>
<p>additional parameters to the kernel FUN</p>
</td></tr>
</table>

<hr>
<h2 id='Kernel-class'>Kernel</h2><span id='topic+Kernel-class'></span>

<h3>Description</h3>

<p>A class representing an image kernel
</p>


<h3>Slots</h3>


<dl>
<dt><code>width</code></dt><dd><p>the width in voxels of the kernel</p>
</dd>
<dt><code>weights</code></dt><dd><p>the kernel weights</p>
</dd>
<dt><code>voxels</code></dt><dd><p>the relative voxel coordinates of the kernel</p>
</dd>
<dt><code>coords</code></dt><dd><p>the relative real coordinates of the kernel</p>
</dd>
</dl>

<hr>
<h2 id='Layer'>Layer</h2><span id='topic+Layer'></span>

<h3>Description</h3>

<p>create a <code><a href="#topic+Layer-class">Layer</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Layer(vol, colorMap = gray((0:255)/255, alpha = 1), thresh = c(0, 0),
  axis = 3, zero.col = "#000000", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Layer_+3A_vol">vol</code></td>
<td>
<p>volume instance of <code><a href="#topic+BrainVolume-class">BrainVolume</a></code></p>
</td></tr>
<tr><td><code id="Layer_+3A_colormap">colorMap</code></td>
<td>
<p>a lookup table defining mapping from image intensity values to colors.</p>
</td></tr>
<tr><td><code id="Layer_+3A_thresh">thresh</code></td>
<td>
<p>a range (min,max) defining the threshold window for determining image opacity.</p>
</td></tr>
<tr><td><code id="Layer_+3A_axis">axis</code></td>
<td>
<p>the axis index of the axis perpendicular to the xy plane (options: 1,2,3; default is 3)</p>
</td></tr>
<tr><td><code id="Layer_+3A_zero.col">zero.col</code></td>
<td>
<p>the color used when the value is zero.</p>
</td></tr>
<tr><td><code id="Layer_+3A_alpha">alpha</code></td>
<td>
<p>transparency multiplier, vlaue between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>Layer</code>
</p>

<hr>
<h2 id='Layer-class'>Layer</h2><span id='topic+Layer-class'></span>

<h3>Description</h3>

<p>A class used for displaying 2D images with color maps
</p>


<h3>Slots</h3>


<dl>
<dt><code>vol</code></dt><dd><p>the <code>BrainVolume</code> that provides the data for the layer.</p>
</dd>
<dt><code>colorMap</code></dt><dd><p>a character vector of colors in hexadecimal rgb format. 
Can be generated by calls to <code>rainbow</code>, <code>heat.colors</code>, <code>topo.colors</code>, <code>terrain.colors</code> or similar functions.</p>
</dd>
<dt><code>thresh</code></dt><dd><p>cut-off value above which vlaues will be made transparent.</p>
</dd>
<dt><code>axis</code></dt><dd><p>the axis index of perpendicular to the xy plane (option: 1,2,3; default is 3)</p>
</dd>
<dt><code>zero.col</code></dt><dd><p>the color pixels with intensity of zero. This value overrides the color from the slot <code>colorMap</code></p>
</dd>
<dt><code>alpha</code></dt><dd><p>the transparency of the layer</p>
</dd>
</dl>

<hr>
<h2 id='length+2CROIVolume-method'>Get length of <code>BrainVector</code>. This is the numbe rof volumes in the volume vector (e.g. the 4th image dimension)</h2><span id='topic+length+2CBrainVector-method'></span><span id='topic+length+2CROIVolume-method'></span>

<h3>Description</h3>

<p>Get length of <code>BrainVector</code>. This is the numbe rof volumes in the volume vector (e.g. the 4th image dimension)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ROIVolume'
length(x)

## S4 method for signature 'BrainVector'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CROIVolume-method_+3A_x">x</code></td>
<td>
<p>the object to get <code>length</code></p>
</td></tr>
</table>

<hr>
<h2 id='loadBucket'>loadBucket</h2><span id='topic+loadBucket'></span>

<h3>Description</h3>

<p>load a BrainBucket object from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadBucket(fileName, pattern = NULL, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadBucket_+3A_filename">fileName</code></td>
<td>
<p>the name of the file to load</p>
</td></tr>
<tr><td><code id="loadBucket_+3A_pattern">pattern</code></td>
<td>
<p>optional regular expression used to filter the sub-volumes using associated labels</p>
</td></tr>
<tr><td><code id="loadBucket_+3A_indices">indices</code></td>
<td>
<p>optional set of sub-volume indices to load</p>
</td></tr>
</table>

<hr>
<h2 id='loadData'>Generic function to load data from a data source</h2><span id='topic+loadData'></span><span id='topic+loadData+2CBrainBucketSource-method'></span><span id='topic+loadData+2CBrainSurfaceSource-method'></span><span id='topic+loadData+2CBrainVectorSource-method'></span><span id='topic+loadData+2CBrainVolumeSource-method'></span><span id='topic+loadData+2CSparseBrainVectorSource-method'></span>

<h3>Description</h3>

<p>Generic function to load data from a data source
</p>
<p>load a BrainSurface
</p>
<p>loadData
</p>
<p>Load data from a <code><a href="#topic+BrainBucketSource-class">BrainBucketSource</a></code>
</p>
<p>load a BrainVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadData(x, ...)

## S4 method for signature 'BrainSurfaceSource'
loadData(x)

## S4 method for signature 'SparseBrainVectorSource'
loadData(x)

## S4 method for signature 'BrainVectorSource'
loadData(x, mmap = FALSE)

## S4 method for signature 'BrainBucketSource'
loadData(x, key)

## S4 method for signature 'BrainVolumeSource'
loadData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadData_+3A_x">x</code></td>
<td>
<p>a data source</p>
</td></tr>
<tr><td><code id="loadData_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="loadData_+3A_mmap">mmap</code></td>
<td>
<p>use memory-mapped file</p>
</td></tr>
<tr><td><code id="loadData_+3A_key">key</code></td>
<td>
<p>the name or index of the bucket to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+BrainVector-class">BrainVector</a></code>
</p>
<p>an instance of class <code><a href="#topic+BrainVolume-class">BrainVolume</a></code>
</p>

<hr>
<h2 id='loadFSSurface'>load Freesurfer ascii surface</h2><span id='topic+loadFSSurface'></span>

<h3>Description</h3>

<p>load Freesurfer ascii surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadFSSurface(mesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadFSSurface_+3A_mesh">mesh</code></td>
<td>
<p>file name of mesh to read in.</p>
</td></tr>
</table>

<hr>
<h2 id='loadSurface'>load an surface from a set of files</h2><span id='topic+loadSurface'></span>

<h3>Description</h3>

<p>load an surface from a set of files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSurface(surfaceName, surfaceDataName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSurface_+3A_surfacename">surfaceName</code></td>
<td>
<p>the name of the file containing the surface geometry.</p>
</td></tr>
<tr><td><code id="loadSurface_+3A_surfacedataname">surfaceDataName</code></td>
<td>
<p>the name of the file containing the values to be mapped to the surface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of the class <code><a href="#topic+BrainSurface-class">BrainSurface</a></code>
</p>

<hr>
<h2 id='loadVector'>loadVector</h2><span id='topic+loadVector'></span>

<h3>Description</h3>

<p>load an image volume from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadVector(fileName, indices = NULL, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadVector_+3A_filename">fileName</code></td>
<td>
<p>the name of the file to load</p>
</td></tr>
<tr><td><code id="loadVector_+3A_indices">indices</code></td>
<td>
<p>the indices of the sub-volumes to load (e.g. if the file is 4-dimensional)</p>
</td></tr>
<tr><td><code id="loadVector_+3A_mask">mask</code></td>
<td>
<p>a mask defining the spatial elements to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+BrainVector-class">BrainVector</a></code> object
</p>

<hr>
<h2 id='loadVolume'>Load an image volume from a file</h2><span id='topic+loadVolume'></span>

<h3>Description</h3>

<p>Load an image volume from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadVolume(fileName, index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadVolume_+3A_filename">fileName</code></td>
<td>
<p>the name of the file to load</p>
</td></tr>
<tr><td><code id="loadVolume_+3A_index">index</code></td>
<td>
<p>the index of the volume (e.g. if the file is 4-dimensional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of the class <code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname &lt;- system.file("extdata", "global_mask.nii", package="neuroim")
x &lt;- loadVolume(fname)
print(dim(x))
space(x)

</code></pre>

<hr>
<h2 id='loadVolumeList'>loadVolList</h2><span id='topic+loadVolumeList'></span>

<h3>Description</h3>

<p>load a list of image volumes and return a <code><a href="#topic+BrainVector-class">BrainVector</a></code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadVolumeList(fileNames, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadVolumeList_+3A_filenames">fileNames</code></td>
<td>
<p>a list of files to load</p>
</td></tr>
<tr><td><code id="loadVolumeList_+3A_mask">mask</code></td>
<td>
<p>an optional mask indicating subset of voxels to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+BrainVector-class">BrainVector</a></code>
</p>

<hr>
<h2 id='LogicalBrainVolume-class'>LogicalBrainVolume</h2><span id='topic+LogicalBrainVolume'></span><span id='topic+LogicalBrainVolume-class'></span>

<h3>Description</h3>

<p>Three-dimensional brain image where all values are either TRUE or FALSE
</p>
<p>Construct a <code><a href="#topic+LogicalBrainVolume-class">LogicalBrainVolume</a></code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogicalBrainVolume(data, space, source = NULL, label = "", indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogicalBrainVolume-class_+3A_data">data</code></td>
<td>
<p>a three-dimensional <code>array</code>, a 1D vector with length equal to <code>prod(dim(space))</code>, or a set of <code>indices</code> where elements are <code>TRUE</code></p>
</td></tr>
<tr><td><code id="LogicalBrainVolume-class_+3A_space">space</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code></p>
</td></tr>
<tr><td><code id="LogicalBrainVolume-class_+3A_source">source</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="LogicalBrainVolume-class_+3A_label">label</code></td>
<td>
<p>a <code>character</code> string</p>
</td></tr>
<tr><td><code id="LogicalBrainVolume-class_+3A_indices">indices</code></td>
<td>
<p>an optional 1-d index vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+LogicalBrainVolume-class">LogicalBrainVolume</a></code> instance
</p>

<hr>
<h2 id='lookup'>Index Lookup operation</h2><span id='topic+lookup'></span><span id='topic+lookup+2CIndexLookupVolume+2Cnumeric-method'></span><span id='topic+lookup+2CSparseBrainVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Index Lookup operation
</p>
<p>lookup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(x, i, ...)

## S4 method for signature 'SparseBrainVector,numeric'
lookup(x, i)

## S4 method for signature 'IndexLookupVolume,numeric'
lookup(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_x">x</code></td>
<td>
<p>the object to query</p>
</td></tr>
<tr><td><code id="lookup_+3A_i">i</code></td>
<td>
<p>the index to lookup</p>
</td></tr>
<tr><td><code id="lookup_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='makeVector'>makeVector</h2><span id='topic+makeVector'></span>

<h3>Description</h3>

<p>Construct a <code><a href="#topic+BrainVector-class">BrainVector</a></code> instance, using default (dense) implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVector(data, refdata, source = NULL, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeVector_+3A_data">data</code></td>
<td>
<p>a four-dimensional <code>array</code></p>
</td></tr>
<tr><td><code id="makeVector_+3A_refdata">refdata</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainVector-class">BrainVector</a></code> or <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> containing the reference space for the new vector.</p>
</td></tr>
<tr><td><code id="makeVector_+3A_source">source</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="makeVector_+3A_label">label</code></td>
<td>
<p>a <code>character</code> string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+DenseBrainVector-class">DenseBrainVector</a></code> instance
</p>

<hr>
<h2 id='makeVolume'>makeVolume</h2><span id='topic+makeVolume'></span>

<h3>Description</h3>

<p>Construct a <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> instance, using default (dense) implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVolume(data = NULL, refvol, source = NULL, label = "",
  indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeVolume_+3A_data">data</code></td>
<td>
<p>an optional one- or three-dimensional <code>vector</code> or <code>array</code></p>
</td></tr>
<tr><td><code id="makeVolume_+3A_refvol">refvol</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainVolume-class">BrainVolume</a></code> containing the reference space for the new volume.</p>
</td></tr>
<tr><td><code id="makeVolume_+3A_source">source</code></td>
<td>
<p>an optional instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="makeVolume_+3A_label">label</code></td>
<td>
<p>an optional <code>character</code> string</p>
</td></tr>
<tr><td><code id="makeVolume_+3A_indices">indices</code></td>
<td>
<p>an optional 1d vector of indices in to the 3d space</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+DenseBrainVolume-class">DenseBrainVolume</a></code> instance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(64,64,64), spacing=c(1,1,1))
dat &lt;- array(rnorm(64*64*64), c(64,64,64))
bvol &lt;- BrainVolume(dat,bspace, label="test")
bvol2 &lt;- makeVolume(dat, bvol)
all.equal(as.array(bvol),as.array(bvol2))
data &lt;- 1:10
indices = seq(1,1000, length.out=10)
bvol3 &lt;- makeVolume(data,bvol,indices=indices)
sum(bvol3) == sum(data)
</code></pre>

<hr>
<h2 id='map'>Generic function to apply a function to an object</h2><span id='topic+map'></span><span id='topic+map+2CBrainVolume+2CKernel-method'></span>

<h3>Description</h3>

<p>Generic function to apply a function to an object
</p>
<p>apply a kernel function to a <code><a href="#topic+BrainVolume-class">BrainVolume</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(x, m, ...)

## S4 method for signature 'BrainVolume,Kernel'
map(x, m, mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">x</code></td>
<td>
<p>the object that is mapped</p>
</td></tr>
<tr><td><code id="map_+3A_m">m</code></td>
<td>
<p>the mapping object</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="map_+3A_mask">mask</code></td>
<td>
<p>restrict application of kernel to maksed area</p>
</td></tr>
</table>

<hr>
<h2 id='mapToColors'>mapToColors</h2><span id='topic+mapToColors'></span>

<h3>Description</h3>

<p>map an matrix of intensity values to a matrix of color values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapToColors(imslice, col = heat.colors(128, alpha = 1),
  zero.col = "#00000000", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapToColors_+3A_imslice">imslice</code></td>
<td>
<p>an image matrix defining intensity values</p>
</td></tr>
<tr><td><code id="mapToColors_+3A_col">col</code></td>
<td>
<p>a color map</p>
</td></tr>
<tr><td><code id="mapToColors_+3A_zero.col">zero.col</code></td>
<td>
<p>the background color.</p>
</td></tr>
<tr><td><code id="mapToColors_+3A_alpha">alpha</code></td>
<td>
<p>transparency multiplier</p>
</td></tr>
</table>

<hr>
<h2 id='matchAnatomy2D'>given two named axes return AxisSet2D singleton</h2><span id='topic+matchAnatomy2D'></span>

<h3>Description</h3>

<p>given two named axes return AxisSet2D singleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchAnatomy2D(axis1, axis2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchAnatomy2D_+3A_axis1">axis1</code></td>
<td>
<p>the first axis</p>
</td></tr>
<tr><td><code id="matchAnatomy2D_+3A_axis2">axis2</code></td>
<td>
<p>the second axis</p>
</td></tr>
</table>

<hr>
<h2 id='matchAnatomy3D'>given three named axes return AxisSet3D singleton</h2><span id='topic+matchAnatomy3D'></span>

<h3>Description</h3>

<p>given three named axes return AxisSet3D singleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchAnatomy3D(axis1, axis2, axis3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchAnatomy3D_+3A_axis1">axis1</code></td>
<td>
<p>the first axis</p>
</td></tr>
<tr><td><code id="matchAnatomy3D_+3A_axis2">axis2</code></td>
<td>
<p>the second axis</p>
</td></tr>
<tr><td><code id="matchAnatomy3D_+3A_axis3">axis3</code></td>
<td>
<p>the third axis</p>
</td></tr>
</table>

<hr>
<h2 id='matrixToVolumeList'>matrixToVolumeList
converts a matrix to a list of BrainVolumes with values filled at grid coordinates determined by the <code>vox</code> argument.</h2><span id='topic+matrixToVolumeList'></span>

<h3>Description</h3>

<p>matrixToVolumeList
converts a matrix to a list of BrainVolumes with values filled at grid coordinates determined by the <code>vox</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToVolumeList(voxmat, mat, mask, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixToVolumeList_+3A_voxmat">voxmat</code></td>
<td>
<p>an N by 3 matrix of voxel coordinates</p>
</td></tr>
<tr><td><code id="matrixToVolumeList_+3A_mat">mat</code></td>
<td>
<p>an N by M matrix of values where M is the number of volumes to create (e.g. one volume per column in <code>mat</code>)</p>
</td></tr>
<tr><td><code id="matrixToVolumeList_+3A_mask">mask</code></td>
<td>
<p>a reference volume defining the geometry of the output volumes. This can either be of type <code>BrainSpace</code> or <code>BrainVolume</code></p>
</td></tr>
<tr><td><code id="matrixToVolumeList_+3A_default">default</code></td>
<td>
<p>the value that will be used for voxels not contained within voxmat (defualt is <code>NA</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>BrainVolume</code> instances, one for each column of <code>mat</code>
</p>

<hr>
<h2 id='mergePartitions'>mergePartitions</h2><span id='topic+mergePartitions'></span><span id='topic+mergePartitions+2CClusteredBrainVolume+2Cnumeric+2Cmatrix-method'></span>

<h3>Description</h3>

<p>mergePartitions
</p>
<p>merge partititons in a ClusteredBrainVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePartitions(x, K, features, ...)

## S4 method for signature 'ClusteredBrainVolume,numeric,matrix'
mergePartitions(x, K, features)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePartitions_+3A_x">x</code></td>
<td>
<p>the object to merge</p>
</td></tr>
<tr><td><code id="mergePartitions_+3A_k">K</code></td>
<td>
<p>the number of merged partitions</p>
</td></tr>
<tr><td><code id="mergePartitions_+3A_features">features</code></td>
<td>
<p>the features used to define the partition</p>
</td></tr>
<tr><td><code id="mergePartitions_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='MNI_SPACE_1MM'>MNI SPACE 1MM</h2><span id='topic+MNI_SPACE_1MM'></span>

<h3>Description</h3>

<p>This is a <code>BrainSpace</code> object encoding the geometry of the MNI_1MM template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MNI_SPACE_1MM)
</code></pre>


<h3>Format</h3>

<p>a <code>BrainSpace</code> instance</p>

<hr>
<h2 id='NamedAxis-class'>NamedAxis</h2><span id='topic+NamedAxis-class'></span>

<h3>Description</h3>

<p>This class represents an axis with a name attribute
</p>


<h3>Slots</h3>


<dl>
<dt><code>axis</code></dt><dd><p>the name of the axis</p>
</dd>
<dt><code>direction</code></dt><dd><p>of axis (-1,+1)</p>
</dd>
</dl>

<hr>
<h2 id='names+2CBrainBucketSource-method'>names</h2><span id='topic+names+2CBrainBucket-method'></span><span id='topic+names+2CBrainBucketSource-method'></span>

<h3>Description</h3>

<p>names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainBucketSource'
names(x)

## S4 method for signature 'BrainBucket'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2CBrainBucketSource-method_+3A_x">x</code></td>
<td>
<p>the object to get <code>names</code> of</p>
</td></tr>
</table>

<hr>
<h2 id='ndim'>Generic function to extract the number of dimensions of an object</h2><span id='topic+ndim'></span><span id='topic+ndim+2CAxisSet-method'></span><span id='topic+ndim+2CBrainData-method'></span><span id='topic+ndim+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic function to extract the number of dimensions of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndim(x, ...)

## S4 method for signature 'AxisSet'
ndim(x, ...)

## S4 method for signature 'BrainData'
ndim(x)

## S4 method for signature 'BrainSpace'
ndim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndim_+3A_x">x</code></td>
<td>
<p>n-dimensional object</p>
</td></tr>
<tr><td><code id="ndim_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x = BrainSpace(c(10,10,10), c(1,1,1))
ndim(x) == 3
x = BrainSpace(c(10,10,10,3), c(1,1,1,1))
ndim(x) == 4

</code></pre>

<hr>
<h2 id='NIfTIFileDescriptor-class'>NIfTIFileDescriptor</h2><span id='topic+NIfTIFileDescriptor-class'></span>

<h3>Description</h3>

<p>This class supports the NIfTI file format
</p>

<hr>
<h2 id='NIfTIMetaInfo'>Constructor for <code><a href="#topic+NIfTIMetaInfo-class">NIfTIMetaInfo</a></code> class</h2><span id='topic+NIfTIMetaInfo'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+NIfTIMetaInfo-class">NIfTIMetaInfo</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NIfTIMetaInfo(descriptor, nifti_header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NIfTIMetaInfo_+3A_descriptor">descriptor</code></td>
<td>
<p>an instance of class <code><a href="#topic+NIfTIFileDescriptor-class">NIfTIFileDescriptor</a></code></p>
</td></tr>
<tr><td><code id="NIfTIMetaInfo_+3A_nifti_header">nifti_header</code></td>
<td>
<p>a <code>list</code> returned by <code>readNIftiHeader</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+NIfTIMetaInfo-class">NIfTIMetaInfo</a></code>
</p>

<hr>
<h2 id='NIMLSurfaceDataMetaInfo'>Constructor for <code><a href="#topic+NIMLSurfaceDataMetaInfo-class">NIMLSurfaceDataMetaInfo</a></code> class</h2><span id='topic+NIMLSurfaceDataMetaInfo'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+NIMLSurfaceDataMetaInfo-class">NIMLSurfaceDataMetaInfo</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NIMLSurfaceDataMetaInfo(descriptor, header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NIMLSurfaceDataMetaInfo_+3A_descriptor">descriptor</code></td>
<td>
<p>the file descriptor</p>
</td></tr>
<tr><td><code id="NIMLSurfaceDataMetaInfo_+3A_header">header</code></td>
<td>
<p>a <code>list</code> containing header information</p>
</td></tr>
</table>

<hr>
<h2 id='NIMLSurfaceDataMetaInfo-class'>NIMLSurfaceDataMetaInfo
This class contains meta information for surface-based data for the NIML data format</h2><span id='topic+NIMLSurfaceDataMetaInfo-class'></span>

<h3>Description</h3>

<p>NIMLSurfaceDataMetaInfo
</p>
<p>This class contains meta information for surface-based data for the NIML data format
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>the numeric data matrix of surface values (rows = nodes, columns=surface vectors)</p>
</dd>
<dt><code>nodeIndices</code></dt><dd><p>the indices of the nodes for mapping to associated surface geometry.</p>
</dd>
</dl>

<hr>
<h2 id='NIMLSurfaceFileDescriptor-class'>NIMLSurfaceFileDescriptor</h2><span id='topic+NIMLSurfaceFileDescriptor-class'></span>

<h3>Description</h3>

<p>This class supports the NIML file format for surface-based data
</p>

<hr>
<h2 id='NullMetaInfo-class'>NullMetaInfo</h2><span id='topic+NullMetaInfo-class'></span>

<h3>Description</h3>

<p>This is class is used to denote the absense of meta information
</p>

<hr>
<h2 id='numClusters'>numClusters</h2><span id='topic+numClusters'></span><span id='topic+numClusters+2CClusteredBrainVolume-method'></span>

<h3>Description</h3>

<p>numClusters
</p>
<p>get number of clusters in a ClusteredBrainVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numClusters(x)

## S4 method for signature 'ClusteredBrainVolume'
numClusters(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numClusters_+3A_x">x</code></td>
<td>
<p>the object to extract number of clusters</p>
</td></tr>
</table>

<hr>
<h2 id='origin'>Generic getter to extract image origin</h2><span id='topic+origin'></span><span id='topic+origin+2CBrainData-method'></span><span id='topic+origin+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic getter to extract image origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>origin(x)

## S4 method for signature 'BrainSpace'
origin(x)

## S4 method for signature 'BrainData'
origin(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="origin_+3A_x">x</code></td>
<td>
<p>an object with an origin</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(10,10,10), c(2,2,2))
origin(bspace)

</code></pre>

<hr>
<h2 id='overlay'>overlay two objects</h2><span id='topic++2B+2CLayer+2CLayer-method'></span><span id='topic++2B+2COverlay+2CLayer-method'></span><span id='topic+overlay'></span><span id='topic+overlay+2CLayer+2CLayer-method'></span>

<h3>Description</h3>

<p>overlay two objects
</p>
<p>overlay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlay(x, y, ...)

## S4 method for signature 'Layer,Layer'
overlay(x, y)

## S4 method for signature 'Overlay,Layer'
e1 + e2

## S4 method for signature 'Layer,Layer'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlay_+3A_x">x</code></td>
<td>
<p>the underlay object</p>
</td></tr>
<tr><td><code id="overlay_+3A_y">y</code></td>
<td>
<p>the overlay object</p>
</td></tr>
<tr><td><code id="overlay_+3A_...">...</code></td>
<td>
<p>additional arguments for class-specific implementations</p>
</td></tr>
<tr><td><code id="overlay_+3A_e1">e1</code></td>
<td>
<p>the left operand</p>
</td></tr>
<tr><td><code id="overlay_+3A_e2">e2</code></td>
<td>
<p>the right operand</p>
</td></tr>
</table>

<hr>
<h2 id='partition'>partition</h2><span id='topic+partition'></span><span id='topic+partition+2CClusteredBrainVolume+2Cnumeric+2Cmatrix-method'></span>

<h3>Description</h3>

<p>partition
</p>
<p>partition a <code>ClusteredBrainVolume</code> into K spatial disjoint components for every existing partition in the volume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(x, K, features, ...)

## S4 method for signature 'ClusteredBrainVolume,numeric,matrix'
partition(x, K, features,
  method = "kmeans")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>the object to partition</p>
</td></tr>
<tr><td><code id="partition_+3A_k">K</code></td>
<td>
<p>the number of partitions</p>
</td></tr>
<tr><td><code id="partition_+3A_features">features</code></td>
<td>
<p>the features used to define the partition</p>
</td></tr>
<tr><td><code id="partition_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="partition_+3A_method">method</code></td>
<td>
<p>clustering method</p>
</td></tr>
</table>

<hr>
<h2 id='permMat'>Extract permutation matrix</h2><span id='topic+permMat'></span><span id='topic+permMat+2CAxisSet2D-method'></span>

<h3>Description</h3>

<p>Extract permutation matrix
</p>
<p>permMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permMat(x, ...)

## S4 method for signature 'AxisSet2D'
permMat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permMat_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="permMat_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='pick'>pick</h2><span id='topic+pick'></span>

<h3>Description</h3>

<p>pick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick(x, mask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_+3A_x">x</code></td>
<td>
<p>the object to pick from</p>
</td></tr>
<tr><td><code id="pick_+3A_mask">mask</code></td>
<td>
<p>a mask object</p>
</td></tr>
<tr><td><code id="pick_+3A_...">...</code></td>
<td>
<p>addiitonal arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print'>Generic function to print an object</h2><span id='topic+print'></span>

<h3>Description</h3>

<p>Generic function to print an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>the object to print</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print+2CAxisSet2D-method'>print a <code>AxisSet2D</code> instance</h2><span id='topic+print+2CAxisSet2D-method'></span>

<h3>Description</h3>

<p>print a <code>AxisSet2D</code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet2D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CAxisSet2D-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="print+2B2CAxisSet2D-method_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>

<hr>
<h2 id='print+2CAxisSet3D-method'>print a <code>AxisSet3D</code> instance</h2><span id='topic+print+2CAxisSet3D-method'></span>

<h3>Description</h3>

<p>print a <code>AxisSet3D</code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet3D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CAxisSet3D-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="print+2B2CAxisSet3D-method_+3A_...">...</code></td>
<td>
<p>extra args</p>
</td></tr>
</table>

<hr>
<h2 id='print+2CNamedAxis-method'>print a <code>NamedAxis</code></h2><span id='topic+print+2CNamedAxis-method'></span>

<h3>Description</h3>

<p>print a <code>NamedAxis</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NamedAxis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CNamedAxis-method_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="print+2B2CNamedAxis-method_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>

<hr>
<h2 id='RandomSearchlight'>Create an Random Searchlight iterator</h2><span id='topic+RandomSearchlight'></span>

<h3>Description</h3>

<p>Create an Random Searchlight iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomSearchlight(mask, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomSearchlight_+3A_mask">mask</code></td>
<td>
<p>an image volume containing valid central voxels for roving searchlight</p>
</td></tr>
<tr><td><code id="RandomSearchlight_+3A_radius">radius</code></td>
<td>
<p>in mm of spherical searchlight</p>
</td></tr>
</table>

<hr>
<h2 id='readAFNIHeader'>readAFNIHeader</h2><span id='topic+readAFNIHeader'></span>

<h3>Description</h3>

<p>readAFNIHeader
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAFNIHeader(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAFNIHeader_+3A_filename">fileName</code></td>
<td>
<p>the name of the AFNI header file (ending in .HEAD)</p>
</td></tr>
</table>

<hr>
<h2 id='readColumns'>Generic function to read a set of column vector from an input source (e.g. <code>ColumnReader</code>)</h2><span id='topic+readColumns'></span><span id='topic+readColumns+2CColumnReader+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to read a set of column vector from an input source (e.g. <code>ColumnReader</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readColumns(x, columnIndices)

## S4 method for signature 'ColumnReader,numeric'
readColumns(x, columnIndices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readColumns_+3A_x">x</code></td>
<td>
<p>the input channel</p>
</td></tr>
<tr><td><code id="readColumns_+3A_columnindices">columnIndices</code></td>
<td>
<p>the column indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> consisting of the requested column vectors
</p>

<hr>
<h2 id='readElements'>Generic function to read a sequence of elements from an input source</h2><span id='topic+readElements'></span><span id='topic+readElements+2CBinaryReader+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to read a sequence of elements from an input source
</p>
<p>readElements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readElements(x, numElements)

## S4 method for signature 'BinaryReader,numeric'
readElements(x, numElements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readElements_+3A_x">x</code></td>
<td>
<p>the input channel</p>
</td></tr>
<tr><td><code id="readElements_+3A_numelements">numElements</code></td>
<td>
<p>the number of elements to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the elements as a vector
</p>

<hr>
<h2 id='readHeader'>read header information of an image file</h2><span id='topic+readHeader'></span>

<h3>Description</h3>

<p>read header information of an image file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHeader(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readHeader_+3A_filename">fileName</code></td>
<td>
<p>the name of the file to read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code><a href="#topic+FileMetaInfo-class">FileMetaInfo</a></code>
</p>

<hr>
<h2 id='readMetaInfo'>Generic function to read image meta info given a file and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.</h2><span id='topic+readMetaInfo'></span><span id='topic+readMetaInfo+2CAFNIFileDescriptor-method'></span><span id='topic+readMetaInfo+2CFreesurferAsciiSurfaceFileDescriptor-method'></span><span id='topic+readMetaInfo+2CNIMLSurfaceFileDescriptor-method'></span><span id='topic+readMetaInfo+2CNIfTIFileDescriptor-method'></span>

<h3>Description</h3>

<p>Generic function to read image meta info given a file and a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMetaInfo(x, fileName)

## S4 method for signature 'NIfTIFileDescriptor'
readMetaInfo(x, fileName)

## S4 method for signature 'AFNIFileDescriptor'
readMetaInfo(x, fileName)

## S4 method for signature 'NIMLSurfaceFileDescriptor'
readMetaInfo(x, fileName)

## S4 method for signature 'FreesurferAsciiSurfaceFileDescriptor'
readMetaInfo(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMetaInfo_+3A_x">x</code></td>
<td>
<p>descriptor instance</p>
</td></tr>
<tr><td><code id="readMetaInfo_+3A_filename">fileName</code></td>
<td>
<p>file name contianing meta information</p>
</td></tr>
</table>

<hr>
<h2 id='RegionCube'>Create A Cuboid Region of Interest</h2><span id='topic+RegionCube'></span>

<h3>Description</h3>

<p>Create A Cuboid Region of Interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionCube(bvol, centroid, surround, fill = NULL, nonzero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionCube_+3A_bvol">bvol</code></td>
<td>
<p>an <code>BrainVolume</code> or <code>BrainSpace</code> instance</p>
</td></tr>
<tr><td><code id="RegionCube_+3A_centroid">centroid</code></td>
<td>
<p>the center of the cube in <em>voxel</em> coordinates</p>
</td></tr>
<tr><td><code id="RegionCube_+3A_surround">surround</code></td>
<td>
<p>the number of voxels on either side of the central voxel. A <code>vector</code> of length 3.</p>
</td></tr>
<tr><td><code id="RegionCube_+3A_fill">fill</code></td>
<td>
<p>optional value(s) to assign to data slot.</p>
</td></tr>
<tr><td><code id="RegionCube_+3A_nonzero">nonzero</code></td>
<td>
<p>keep only nonzero elements from <code>bvol</code>. If <code>bvol</code> is A <code>BrainSpace</code> then this argument is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code>ROIVolume</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sp1 &lt;- BrainSpace(c(10,10,10), c(1,1,1))
 cube &lt;- RegionCube(sp1, c(5,5,5), 3)
 vox &lt;- coords(cube)
 cube2 &lt;- RegionCube(sp1, c(5,5,5), 3, fill=5)
 
 
</code></pre>

<hr>
<h2 id='RegionSphere'>Create A Spherical Region of Interest</h2><span id='topic+RegionSphere'></span>

<h3>Description</h3>

<p>Create A Spherical Region of Interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionSphere(bvol, centroid, radius, fill = NULL, nonzero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionSphere_+3A_bvol">bvol</code></td>
<td>
<p>an <code>BrainVolume</code> or <code>BrainSpace</code> instance</p>
</td></tr>
<tr><td><code id="RegionSphere_+3A_centroid">centroid</code></td>
<td>
<p>the center of the sphere in voxel space</p>
</td></tr>
<tr><td><code id="RegionSphere_+3A_radius">radius</code></td>
<td>
<p>the radius in real units (e.g. millimeters) of the spherical ROI</p>
</td></tr>
<tr><td><code id="RegionSphere_+3A_fill">fill</code></td>
<td>
<p>optional value(s) to assign to data slot</p>
</td></tr>
<tr><td><code id="RegionSphere_+3A_nonzero">nonzero</code></td>
<td>
<p>keep only nonzero elements from <code>bvol</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code>ROIVolume</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sp1 &lt;- BrainSpace(c(10,10,10), c(1,1,1))
 cube &lt;- RegionSphere(sp1, c(5,5,5), 3.5)
 vox = coords(cube)
</code></pre>

<hr>
<h2 id='RegionSquare'>Create a square region of interest where the z-dimension is fixed at one voxel coordinate.</h2><span id='topic+RegionSquare'></span>

<h3>Description</h3>

<p>Create a square region of interest where the z-dimension is fixed at one voxel coordinate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionSquare(bvol, centroid, surround, fill = NULL, nonzero = FALSE,
  fixdim = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionSquare_+3A_bvol">bvol</code></td>
<td>
<p>an <code>BrainVolume</code> or <code>BrainSpace</code> instance.</p>
</td></tr>
<tr><td><code id="RegionSquare_+3A_centroid">centroid</code></td>
<td>
<p>the center of the cube in <em>voxel</em> coordinates.</p>
</td></tr>
<tr><td><code id="RegionSquare_+3A_surround">surround</code></td>
<td>
<p>the number of voxels on either side of the central voxel.</p>
</td></tr>
<tr><td><code id="RegionSquare_+3A_fill">fill</code></td>
<td>
<p>optional value(s) to assign to data slot.</p>
</td></tr>
<tr><td><code id="RegionSquare_+3A_nonzero">nonzero</code></td>
<td>
<p>keep only nonzero elements from <code>bvol</code>. If <code>bvol</code> is A <code>BrainSpace</code> then this argument is ignored.</p>
</td></tr>
<tr><td><code id="RegionSquare_+3A_fixdim">fixdim</code></td>
<td>
<p>the fixed dimension is the third, or z, dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code>ROIVolume</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> sp1 &lt;- BrainSpace(c(10,10,10), c(1,1,1))
 square &lt;- RegionSquare(sp1, c(5,5,5), 1)
 vox &lt;- coords(square)
 ## a 3 X 3 X 1 grid
 nrow(vox) == 9
</code></pre>

<hr>
<h2 id='render'>Render an image to create a drawable image.</h2><span id='topic+render'></span><span id='topic+render+2CBrainSlice+2Cnumeric+2Cnumeric+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Render an image to create a drawable image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render(x, width, height, colmap, ...)

## S4 method for signature 'BrainSlice,numeric,numeric,character'
render(x, width, height,
  colmap, zero.col = "#000000FF", alpha = 1, units = "mm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_+3A_x">x</code></td>
<td>
<p>the object, e.g. an instance of type <code>BrainSlice</code></p>
</td></tr>
<tr><td><code id="render_+3A_width">width</code></td>
<td>
<p>width of the rendered image</p>
</td></tr>
<tr><td><code id="render_+3A_height">height</code></td>
<td>
<p>height of the rendered image</p>
</td></tr>
<tr><td><code id="render_+3A_colmap">colmap</code></td>
<td>
<p>the colors used to map from values to RGBA colors.</p>
</td></tr>
<tr><td><code id="render_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="render_+3A_zero.col">zero.col</code></td>
<td>
<p>color used when background intensity is 0.</p>
</td></tr>
<tr><td><code id="render_+3A_alpha">alpha</code></td>
<td>
<p>transparency multiplier</p>
</td></tr>
<tr><td><code id="render_+3A_units">units</code></td>
<td>
<p>grid unit type, e.g. &quot;mm&quot;, &quot;inches&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='renderSlice'>Render a slice at z coordinate</h2><span id='topic+renderSlice'></span><span id='topic+renderSlice+2CLayer+2Cnumeric+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+renderSlice+2COverlay+2Cnumeric+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Render a slice at z coordinate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renderSlice(x, zpos, width, height, colmap, ...)

## S4 method for signature 'Overlay,numeric,numeric,numeric,missing'
renderSlice(x, zpos, width,
  height, zero.col = "#000000FF", units = "mm")

## S4 method for signature 'Layer,numeric,numeric,numeric,missing'
renderSlice(x, zpos, width,
  height, colmap, zero.col = "#000000FF", units = "mm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renderSlice_+3A_x">x</code></td>
<td>
<p>the object, e.g. an instance of type <code>Layer</code> or <code>Overlay</code></p>
</td></tr>
<tr><td><code id="renderSlice_+3A_zpos">zpos</code></td>
<td>
<p>the z coordinate to slice through.</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_width">width</code></td>
<td>
<p>width of the rendered image</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_height">height</code></td>
<td>
<p>height of the rendered image</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_colmap">colmap</code></td>
<td>
<p>the colors used to map from values to RGBA colors.</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_zero.col">zero.col</code></td>
<td>
<p>color used when background intensity is 0.</p>
</td></tr>
<tr><td><code id="renderSlice_+3A_units">units</code></td>
<td>
<p>grid unit type, e.g. &quot;mm&quot;, &quot;inches&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='ROIVolume'>Create an instance of class ROIVolume</h2><span id='topic+ROIVolume'></span>

<h3>Description</h3>

<p>Create an instance of class ROIVolume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROIVolume(vspace, coords, data = rep(length(indices), 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROIVolume_+3A_vspace">vspace</code></td>
<td>
<p>the volume <code>BrainSpace</code></p>
</td></tr>
<tr><td><code id="ROIVolume_+3A_coords">coords</code></td>
<td>
<p>matrix of voxel coordinates</p>
</td></tr>
<tr><td><code id="ROIVolume_+3A_data">data</code></td>
<td>
<p>the data values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of class <code>ROIVolume</code>
</p>

<hr>
<h2 id='ROIVolume-class'>ROIVolume</h2><span id='topic+ROIVolume-class'></span>

<h3>Description</h3>

<p>A class that representing a volumetric region of interest (ROI).
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>the <code>numeric</code> data stored in the ROI</p>
</dd>
<dt><code>coords</code></dt><dd><p>the voxel coordinates of the ROI</p>
</dd>
</dl>

<hr>
<h2 id='scaleSeries'>Generic functions to scale (center and/or normalize by standard deviation) each series of a 4D image
That is, if the 4th dimension is 'time' each series is a 1D time series.</h2><span id='topic+scaleSeries'></span><span id='topic+scaleSeries+2CBrainVector+2Clogical+2Clogical-method'></span><span id='topic+scaleSeries+2CBrainVector+2Clogical+2Cmissing-method'></span><span id='topic+scaleSeries+2CBrainVector+2Cmissing+2Clogical-method'></span><span id='topic+scaleSeries+2CBrainVector+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic functions to scale (center and/or normalize by standard deviation) each series of a 4D image
That is, if the 4th dimension is 'time' each series is a 1D time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleSeries(x, center, scale)

## S4 method for signature 'BrainVector,logical,logical'
scaleSeries(x, center, scale)

## S4 method for signature 'BrainVector,missing,logical'
scaleSeries(x, center, scale)

## S4 method for signature 'BrainVector,missing,missing'
scaleSeries(x, center, scale)

## S4 method for signature 'BrainVector,logical,missing'
scaleSeries(x, center, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleSeries_+3A_x">x</code></td>
<td>
<p>a four dimensional image</p>
</td></tr>
<tr><td><code id="scaleSeries_+3A_center">center</code></td>
<td>
<p>a <code>logical</code> value indicating whether series should be centered</p>
</td></tr>
<tr><td><code id="scaleSeries_+3A_scale">scale</code></td>
<td>
<p>a <code>logical</code> value indicating whether series should be divided by standard deviation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
res &lt;- scaleSeries(bvec, TRUE, TRUE)
</code></pre>

<hr>
<h2 id='Searchlight'>Create an exhaustive searchlight iterator</h2><span id='topic+Searchlight'></span>

<h3>Description</h3>

<p>Create an exhaustive searchlight iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Searchlight(mask, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Searchlight_+3A_mask">mask</code></td>
<td>
<p>an image volume containing valid central voxels for roving searchlight</p>
</td></tr>
<tr><td><code id="Searchlight_+3A_radius">radius</code></td>
<td>
<p>in mm of spherical searchlight</p>
</td></tr>
</table>

<hr>
<h2 id='series'>Extract vector series from object</h2><span id='topic+series'></span><span id='topic+series+2CBrainVector+2Cmatrix-method'></span><span id='topic+series+2CBrainVector+2Cnumeric-method'></span><span id='topic+series+2CSparseBrainVector+2Cmatrix-method'></span><span id='topic+series+2CSparseBrainVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extract vector series from object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series(x, i, ...)

## S4 method for signature 'SparseBrainVector,matrix'
series(x, i)

## S4 method for signature 'SparseBrainVector,numeric'
series(x, i, j, k)

## S4 method for signature 'BrainVector,matrix'
series(x, i)

## S4 method for signature 'BrainVector,numeric'
series(x, i, j, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="series_+3A_i">i</code></td>
<td>
<p>the series index</p>
</td></tr>
<tr><td><code id="series_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="series_+3A_j">j</code></td>
<td>
<p>index for 2nd dimension</p>
</td></tr>
<tr><td><code id="series_+3A_k">k</code></td>
<td>
<p>index for 3rd dimension</p>
</td></tr>
</table>

<hr>
<h2 id='seriesIter'>seriesIter</h2><span id='topic+seriesIter'></span><span id='topic+seriesIter+2CBrainVector-method'></span><span id='topic+seriesIter+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>Construct a series iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seriesIter(x)

## S4 method for signature 'SparseBrainVector'
seriesIter(x)

## S4 method for signature 'BrainVector'
seriesIter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seriesIter_+3A_x">x</code></td>
<td>
<p>the object to be iterated over. This is typically an instance of class <code><a href="#topic+BrainVector-class">BrainVector</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>iter</code> object from the <code>iterators</code> package.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>SparseBrainVector</code>: get a seriesIter for a <code><a href="#topic+SparseBrainVector-class">SparseBrainVector</a></code> instance
</p>
</li>
<li> <p><code>BrainVector</code>: get a series iterator for a <code><a href="#topic+BrainVector-class">BrainVector</a></code> instance
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
## create a BrainVector with 10X10X10X10, where the last dimension is 
## by convention the fourth dimension.
bvec &lt;- BrainVector(array(rnorm(10*10*10*10), rep(10,4)), BrainSpace(rep(10,4), c(1,1,1)))
iter &lt;- seriesIter(bvec)

## compute mean of each series
library(foreach)
library(iterators)
foreach(i=iter, .combine=c) %do% { mean(i) }
iter &lt;- seriesIter(bvec)

## combine all series into a matrix
foreach(i=iter, .combine=rbind) %do% { i }

## scale all series, add as columns in matrix.
foreach(i=seriesIter(bvec), .combine=cbind) %do% { scale(i) }
</code></pre>

<hr>
<h2 id='show+2CAxisSet1D-method'>show an <code>AxisSet1D</code></h2><span id='topic+show+2CAxisSet1D-method'></span>

<h3>Description</h3>

<p>show an <code>AxisSet1D</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet1D'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CAxisSet1D-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CAxisSet2D-method'>show an <code>AxisSet2D</code></h2><span id='topic+show+2CAxisSet2D-method'></span>

<h3>Description</h3>

<p>show an <code>AxisSet2D</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet2D'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CAxisSet2D-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CAxisSet3D-method'>show an <code>AxisSet3D</code></h2><span id='topic+show+2CAxisSet3D-method'></span>

<h3>Description</h3>

<p>show an <code>AxisSet3D</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet3D'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CAxisSet3D-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CAxisSet4D-method'>show an <code>AxisSet4D</code></h2><span id='topic+show+2CAxisSet4D-method'></span>

<h3>Description</h3>

<p>show an <code>AxisSet4D</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxisSet4D'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CAxisSet4D-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CBaseMetaInfo-method'>show a <code>BaseMetaInfo</code></h2><span id='topic+show+2CBaseMetaInfo-method'></span>

<h3>Description</h3>

<p>show a <code>BaseMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BaseMetaInfo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBaseMetaInfo-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CBrainSpace-method'>show a <code>BrainSpace</code></h2><span id='topic+show+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>show a <code>BrainSpace</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainSpace'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBrainSpace-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CBrainVector-method'>show a <code>BrainVector</code></h2><span id='topic+show+2CBrainVector-method'></span>

<h3>Description</h3>

<p>show a <code>BrainVector</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainVector'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBrainVector-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CBrainVectorSource-method'>show a <code>BrainVectorSource</code></h2><span id='topic+show+2CBrainVectorSource-method'></span>

<h3>Description</h3>

<p>show a <code>BrainVectorSource</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainVectorSource'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBrainVectorSource-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CBrainVolume-method'>show a <code>BrainVolume</code></h2><span id='topic+show+2CBrainVolume-method'></span>

<h3>Description</h3>

<p>show a <code>BrainVolume</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BrainVolume'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBrainVolume-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CFileMetaInfo-method'>show a <code>FileMetaInfo</code></h2><span id='topic+show+2CFileMetaInfo-method'></span>

<h3>Description</h3>

<p>show a <code>FileMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FileMetaInfo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CFileMetaInfo-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNamedAxis-method'>show an <code>NamedAxis</code></h2><span id='topic+show+2CNamedAxis-method'></span>

<h3>Description</h3>

<p>show an <code>NamedAxis</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NamedAxis'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNamedAxis-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CNullMetaInfo-method'>show a <code>NullMetaInfo</code></h2><span id='topic+show+2CNullMetaInfo-method'></span>

<h3>Description</h3>

<p>show a <code>NullMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NullMetaInfo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNullMetaInfo-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CROIVolume-method'>show an <code>ROIVolime</code></h2><span id='topic+show+2CROIVolume-method'></span>

<h3>Description</h3>

<p>show an <code>ROIVolime</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ROIVolume'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CROIVolume-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CSparseBrainVector-method'>show a <code>SparseBrainVector</code></h2><span id='topic+show+2CSparseBrainVector-method'></span>

<h3>Description</h3>

<p>show a <code>SparseBrainVector</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseBrainVector'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSparseBrainVector-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CSurfaceDataMetaInfo-method'>show an <code>SurfaceDataMetaInfo</code></h2><span id='topic+show+2CSurfaceDataMetaInfo-method'></span>

<h3>Description</h3>

<p>show an <code>SurfaceDataMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SurfaceDataMetaInfo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSurfaceDataMetaInfo-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='show+2CSurfaceGeometryMetaInfo-method'>show an <code>SurfaceGeometryMetaInfo</code></h2><span id='topic+show+2CSurfaceGeometryMetaInfo-method'></span>

<h3>Description</h3>

<p>show an <code>SurfaceGeometryMetaInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SurfaceGeometryMetaInfo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSurfaceGeometryMetaInfo-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
</table>

<hr>
<h2 id='slice'>Extract a 2D slice from an image volume</h2><span id='topic+slice'></span><span id='topic+slice+2CBrainVolume+2Cnumeric+2Cnumeric+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Extract a 2D slice from an image volume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(x, zlevel, along, orientation, ...)

## S4 method for signature 'BrainVolume,numeric,numeric,character'
slice(x, zlevel, along,
  orientation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="slice_+3A_zlevel">zlevel</code></td>
<td>
<p>coordinate (in voxel units) along the sliced axis</p>
</td></tr>
<tr><td><code id="slice_+3A_along">along</code></td>
<td>
<p>the axis along which to slice</p>
</td></tr>
<tr><td><code id="slice_+3A_orientation">orientation</code></td>
<td>
<p>the target orientation of the 2D slice</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='sliceData'>sliceData</h2><span id='topic+sliceData'></span>

<h3>Description</h3>

<p>extract a 2D slice from a <code>BrainVolume</code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceData(vol, slice, axis = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceData_+3A_vol">vol</code></td>
<td>
<p>an <code>BrainVolume</code> instance</p>
</td></tr>
<tr><td><code id="sliceData_+3A_slice">slice</code></td>
<td>
<p>the integer index of the slice to cut.</p>
</td></tr>
<tr><td><code id="sliceData_+3A_axis">axis</code></td>
<td>
<p>the axis number (1, 2, 3) defining fixed axis of the 2D slice.</p>
</td></tr>
</table>

<hr>
<h2 id='space'>Generic function to extract geometric properties of an image.</h2><span id='topic+space'></span><span id='topic+space+2CBrainData-method'></span><span id='topic+space+2CBrainSpace-method'></span><span id='topic+space+2CIndexLookupVolume-method'></span>

<h3>Description</h3>

<p>Generic function to extract geometric properties of an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space(x, ...)

## S4 method for signature 'BrainData'
space(x)

## S4 method for signature 'BrainSpace'
space(x)

## S4 method for signature 'IndexLookupVolume'
space(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="space_+3A_x">x</code></td>
<td>
<p>the object to query, e.g. an instance of <code>BrainVolume</code> or <code>BrainVector</code></p>
</td></tr>
<tr><td><code id="space_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object representing the geometric space of the image of type <code><a href="#topic+BrainSpace-class">BrainSpace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = BrainSpace(c(10,10,10), c(1,1,1))
vol &lt;- BrainVolume(rnorm(10*10*10), x)
identical(x,space(vol))

</code></pre>

<hr>
<h2 id='spacing'>Generic function to extract the voxel dimensions of an image</h2><span id='topic+spacing'></span><span id='topic+spacing+2CBrainData-method'></span><span id='topic+spacing+2CBrainSpace-method'></span>

<h3>Description</h3>

<p>Generic function to extract the voxel dimensions of an image
</p>
<p>spacing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacing(x)

## S4 method for signature 'BrainData'
spacing(x)

## S4 method for signature 'BrainSpace'
spacing(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spacing_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(10,10,10), c(2,2,2))
all.equal(spacing(bspace), c(2,2,2))
</code></pre>

<hr>
<h2 id='SparseBrainVector-class'>SparseBrainVector</h2><span id='topic+SparseBrainVector'></span><span id='topic+SparseBrainVector-class'></span>

<h3>Description</h3>

<p>a sparse four-dimensional brain image, backed by a <code>matrix</code>, where each column represents 
a vector spanning the fourth dimension (e.g. time)
</p>
<p>constructs a SparseBrainVector object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseBrainVector(data, space, mask, source = NULL, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseBrainVector-class_+3A_data">data</code></td>
<td>
<p>an array which can be a <code>matrix</code> or 4-D <code>array</code></p>
</td></tr>
<tr><td><code id="SparseBrainVector-class_+3A_space">space</code></td>
<td>
<p>a BrainSpace instance</p>
</td></tr>
<tr><td><code id="SparseBrainVector-class_+3A_mask">mask</code></td>
<td>
<p>a 3D <code>array</code> of type <code>logical</code></p>
</td></tr>
<tr><td><code id="SparseBrainVector-class_+3A_source">source</code></td>
<td>
<p>the data source &ndash; an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="SparseBrainVector-class_+3A_label">label</code></td>
<td>
<p>associated sub-image labels</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>mask</code></dt><dd><p>the mask defining the sparse domain</p>
</dd>
<dt><code>data</code></dt><dd><p>the matrix of series, where rows span across voxel space and columns span the fourth dimensions</p>
</dd>
<dt><code>map</code></dt><dd><p>instance of class <code><a href="#topic+IndexLookupVolume-class">IndexLookupVolume</a></code> is used to map between spatial and index/row coordinates</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
bspace &lt;- BrainSpace(c(10,10,10,100), c(1,1,1))
mask &lt;- array(rnorm(10*10*10) &gt; .5, c(10,10,10))
mat &lt;- matrix(rnorm(sum(mask)), 100, sum(mask))
svec &lt;- SparseBrainVector(mat, bspace,mask)
length(indices(svec)) == sum(mask)
</code></pre>

<hr>
<h2 id='SparseBrainVectorSource-class'>SparseBrainVectorSource</h2><span id='topic+SparseBrainVectorSource'></span><span id='topic+SparseBrainVectorSource-class'></span>

<h3>Description</h3>

<p>A class that is used to produce a <code><a href="#topic+SparseBrainVector-class">SparseBrainVector</a></code> instance
</p>
<p>constructs a SparseBrainVectorSource object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseBrainVectorSource(metaInfo, indices, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseBrainVectorSource-class_+3A_metainfo">metaInfo</code></td>
<td>
<p>an object of class <code><a href="#topic+BrainMetaInfo-class">BrainMetaInfo</a></code></p>
</td></tr>
<tr><td><code id="SparseBrainVectorSource-class_+3A_indices">indices</code></td>
<td>
<p>a vector of 1D indices</p>
</td></tr>
<tr><td><code id="SparseBrainVectorSource-class_+3A_mask">mask</code></td>
<td>
<p>a 3D <code>array</code> of type <code>logical</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>mask</code></dt><dd><p>the subset of voxels that will be stored in memory</p>
</dd>
</dl>

<hr>
<h2 id='SparseBrainVolume-class'>SparseBrainVolume</h2><span id='topic+SparseBrainVolume'></span><span id='topic+SparseBrainVolume-class'></span>

<h3>Description</h3>

<p>Three-dimensional brain image, backed by a <code>sparseVector</code> for <code>Matrix</code> package
</p>
<p>Construct a <code><a href="#topic+SparseBrainVolume-class">SparseBrainVolume</a></code> instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseBrainVolume(data, space, indices = NULL, source = NULL, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseBrainVolume-class_+3A_data">data</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="SparseBrainVolume-class_+3A_space">space</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSpace-class">BrainSpace</a></code></p>
</td></tr>
<tr><td><code id="SparseBrainVolume-class_+3A_indices">indices</code></td>
<td>
<p>a index vector indicating the 1-d coordinates of the data values</p>
</td></tr>
<tr><td><code id="SparseBrainVolume-class_+3A_source">source</code></td>
<td>
<p>an instance of class <code><a href="#topic+BrainSource-class">BrainSource</a></code></p>
</td></tr>
<tr><td><code id="SparseBrainVolume-class_+3A_label">label</code></td>
<td>
<p>a <code>character</code> string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image data is backed by <code>Matrix::sparseVector</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+SparseBrainVolume-class">SparseBrainVolume</a></code> instance
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a <code>sparseVector</code> instance</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- 1:10
indices &lt;- seq(1,1000, length.out=10)
bspace &lt;- BrainSpace(c(64,64,64), spacing=c(1,1,1))
sparsevol &lt;- SparseBrainVolume(data,bspace,indices=indices)
densevol &lt;- BrainVolume(data,bspace,indices=indices)
sum(sparsevol) == sum(densevol)



</code></pre>

<hr>
<h2 id='splitFill'>Generic function to fill disjoint sets of values with the output of a function</h2><span id='topic+splitFill'></span><span id='topic+splitFill+2CBrainVolume+2Cfactor+2Cfunction-method'></span>

<h3>Description</h3>

<p>Generic function to fill disjoint sets of values with the output of a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitFill(x, fac, FUN)

## S4 method for signature 'BrainVolume,factor,'function''
splitFill(x, fac, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitFill_+3A_x">x</code></td>
<td>
<p>the object to split</p>
</td></tr>
<tr><td><code id="splitFill_+3A_fac">fac</code></td>
<td>
<p>the factor to split by</p>
</td></tr>
<tr><td><code id="splitFill_+3A_fun">FUN</code></td>
<td>
<p>the function to summarize the the sets</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> can either return a scalar for each input vector or a vector equal to the length of the input vector. 
If it returns a scalar then every voxel in the set will be filled with that value in the output vector.
</p>


<h3>Value</h3>

<p>a new object where the original values have been replaced by the function output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## summarize with mean -- FUN returns a scalar
x = BrainSpace(c(10,10,10), c(1,1,1))
vol &lt;- BrainVolume(rnorm(10*10*10), x)
fac &lt;- factor(rep(1:10, length.out=1000))
ovol.mean &lt;- splitFill(vol, fac, mean)
identical(dim(ovol.mean), dim(vol))
length(unique(as.vector(ovol.mean))) == 10
## transform by reversing vector -- FUN returns a vector.
ovol2 &lt;- splitFill(vol, fac, rev)
</code></pre>

<hr>
<h2 id='splitReduce'>Generic function to summarize subsets of an object by first splitting by row and then &quot;reducing&quot; by a summary <code>function</code></h2><span id='topic+splitReduce'></span><span id='topic+splitReduce+2CBrainVector+2Cfactor+2Cfunction-method'></span><span id='topic+splitReduce+2CBrainVector+2Cfactor+2Cmissing-method'></span><span id='topic+splitReduce+2Cmatrix+2Cfactor+2Cfunction-method'></span><span id='topic+splitReduce+2Cmatrix+2Cfactor+2Cmissing-method'></span><span id='topic+splitReduce+2Cmatrix+2Cinteger+2Cfunction-method'></span><span id='topic+splitReduce+2Cmatrix+2Cinteger+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function to summarize subsets of an object by first splitting by row and then &quot;reducing&quot; by a summary <code>function</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitReduce(x, fac, FUN)

## S4 method for signature 'matrix,integer,'function''
splitReduce(x, fac, FUN)

## S4 method for signature 'matrix,integer,missing'
splitReduce(x, fac)

## S4 method for signature 'matrix,factor,missing'
splitReduce(x, fac)

## S4 method for signature 'matrix,factor,'function''
splitReduce(x, fac, FUN)

## S4 method for signature 'BrainVector,factor,'function''
splitReduce(x, fac, FUN)

## S4 method for signature 'BrainVector,factor,missing'
splitReduce(x, fac, FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitReduce_+3A_x">x</code></td>
<td>
<p>a numeric matrix(like) object</p>
</td></tr>
<tr><td><code id="splitReduce_+3A_fac">fac</code></td>
<td>
<p>the factor to define subsets of the object</p>
</td></tr>
<tr><td><code id="splitReduce_+3A_fun">FUN</code></td>
<td>
<p>the function to apply to each subset. if <code>FUN</code> is missing, than the mean of each sub-matrix column is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>FUN</code> is supplied it must take a vector and return a single scalar value. If it returns more than one value, an error will occur.
</p>
<p>if <code>x</code> is a <code>BrainVector</code> instance then voxels (dims 1:3) are treated as columns and time-series (dim 4) as rows. 
The summary function then is applied to groups of voxels. However, if the goal is to apply a function to groups of time-points, 
then this can be achieved as follows: 
</p>
<p><code> splitReduce(t(as.matrix(bvec)), fac) </code>
</p>


<h3>Value</h3>

<p>a new <code>matrix</code> where the original values have been reduced
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat = matrix(rnorm(100*100), 100, 100)
fac = sample(1:3, nrow(mat), replace=TRUE)
## compute column means of each sub-matrix
ms &lt;- splitReduce(mat, fac)
all.equal(row.names(ms), levels(fac))

## compute column medians of each sub-matrix
ms &lt;- splitReduce(mat, fac, median)

## compute time-series means grouped over voxels. 
## Here, \code{length(fac)} must equal the number of voxels: \code{prod(dim(bvec)[1:3]}
bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
fac &lt;- factor(sample(1:3, prod(dim(bvec)[1:3]), replace=TRUE))
ms &lt;- splitReduce(bvec, fac)
ms2 &lt;- splitReduce(bvec, fac, mean)
all.equal(row.names(ms), levels(fac))
all.equal(ms,ms2)

</code></pre>

<hr>
<h2 id='splitScale'>Generic function to center/scale row-subsets of a matrix or matrix-like object</h2><span id='topic+splitScale'></span><span id='topic+splitScale+2Cmatrix+2Cfactor+2Clogical+2Clogical-method'></span><span id='topic+splitScale+2Cmatrix+2Cfactor+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function to center/scale row-subsets of a matrix or matrix-like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitScale(x, f, center, scale)

## S4 method for signature 'matrix,factor,logical,logical'
splitScale(x, f, center = TRUE,
  scale = TRUE)

## S4 method for signature 'matrix,factor,missing,missing'
splitScale(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitScale_+3A_x">x</code></td>
<td>
<p>a numeric matrix or matrix-like object</p>
</td></tr>
<tr><td><code id="splitScale_+3A_f">f</code></td>
<td>
<p>the splitting object, typically a <code>factor</code> or set of <code>integer</code> indices. must be equal to number of rows of matrix.</p>
</td></tr>
<tr><td><code id="splitScale_+3A_center">center</code></td>
<td>
<p>should values within each submatrix be centered? (mean removed from each column of submatrix)</p>
</td></tr>
<tr><td><code id="splitScale_+3A_scale">scale</code></td>
<td>
<p>should values be scaled? (divide vector by standard deviation from each column of submatrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new matrix or matrix-like object where the original rows have been grouped by <code>f</code> and then centered and/or scaled for each grouping
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M &lt;- matrix(rnorm(1000), 10, 100)
fac &lt;- factor(rep(1:2, each=5))
Ms &lt;- splitScale(M, fac)

## correctly centered
all(abs(apply(Ms[fac == 1,], 2, mean)) &lt; .000001)
all(abs(apply(Ms[fac == 2,], 2, mean)) &lt; .000001)

# correctly scaled
all.equal(apply(Ms[fac == 1,], 2, sd), rep(1, ncol(Ms)))
all.equal(apply(Ms[fac == 2,], 2, sd), rep(1, ncol(Ms)))
</code></pre>

<hr>
<h2 id='stripExtension'>Generic function to strip extension from file name, given a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.</h2><span id='topic+stripExtension'></span><span id='topic+stripExtension+2CBrainFileDescriptor+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Generic function to strip extension from file name, given a <code><a href="#topic+BrainFileDescriptor-class">BrainFileDescriptor</a></code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stripExtension(x, fileName)

## S4 method for signature 'BrainFileDescriptor,character'
stripExtension(x, fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stripExtension_+3A_x">x</code></td>
<td>
<p>descriptor instance</p>
</td></tr>
<tr><td><code id="stripExtension_+3A_filename">fileName</code></td>
<td>
<p>file name to be stripped of its extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fileName without extension
</p>

<hr>
<h2 id='subVector'>Generic function to extract a sub-vector from a <code>BrainVector</code> object.</h2><span id='topic+subVector'></span><span id='topic+subVector+2CDenseBrainVector+2Cnumeric-method'></span><span id='topic+subVector+2CSparseBrainVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to extract a sub-vector from a <code>BrainVector</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subVector(x, i, ...)

## S4 method for signature 'SparseBrainVector,numeric'
subVector(x, i)

## S4 method for signature 'DenseBrainVector,numeric'
subVector(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subVector_+3A_x">x</code></td>
<td>
<p>four-dimensional image</p>
</td></tr>
<tr><td><code id="subVector_+3A_i">i</code></td>
<td>
<p>the indices of the volume(s) to extract</p>
</td></tr>
<tr><td><code id="subVector_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a  <code>BrainVector</code> object that is a sub-vector of the supplied object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
vec &lt;- subVector(bvec,1:2)
all.equal(2, dim(vec)[4])

vec &lt;- subVector(bvec, c(1,3,5,7))
all.equal(4, dim(vec)[4])

mask &lt;- LogicalBrainVolume(rep(TRUE, 24*24*24), BrainSpace(c(24,24,24), c(1,1,1)))
svec &lt;- SparseBrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), 
BrainSpace(c(24,24,24,24), c(1,1,1)), mask)
vec &lt;- subVector(svec, c(1,3,5))
all.equal(3, dim(vec)[4])
</code></pre>

<hr>
<h2 id='SurfaceDataMetaInfo'>Constructor for <code><a href="#topic+SurfaceDataMetaInfo-class">SurfaceDataMetaInfo</a></code> class</h2><span id='topic+SurfaceDataMetaInfo'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+SurfaceDataMetaInfo-class">SurfaceDataMetaInfo</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurfaceDataMetaInfo(descriptor, header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurfaceDataMetaInfo_+3A_descriptor">descriptor</code></td>
<td>
<p>the file descriptor</p>
</td></tr>
<tr><td><code id="SurfaceDataMetaInfo_+3A_header">header</code></td>
<td>
<p>a <code>list</code> containing header information</p>
</td></tr>
</table>

<hr>
<h2 id='SurfaceDataMetaInfo-class'>SurfaceDataMetaInfo
This class contains meta information for surface-based data (the values that map to a surface geometry)</h2><span id='topic+SurfaceDataMetaInfo-class'></span>

<h3>Description</h3>

<p>SurfaceDataMetaInfo
</p>
<p>This class contains meta information for surface-based data (the values that map to a surface geometry)
</p>


<h3>Slots</h3>


<dl>
<dt><code>headerFile</code></dt><dd><p>name of the file containing meta information</p>
</dd>
<dt><code>dataFile</code></dt><dd><p>name of the file containing data</p>
</dd>
<dt><code>fileDescriptor</code></dt><dd><p>descriptor of image file format</p>
</dd>
<dt><code>nodeCount</code></dt><dd><p>the number of nodes for which surface data exists</p>
</dd>
<dt><code>nels</code></dt><dd><p>the number of data vectors (typically the number of columns in the surface data matrix; nels = 1 for a single surface data set)</p>
</dd>
<dt><code>label</code></dt><dd><p>a label indicating the type of surface (e.g. white, pial, inflated, flat, spherical)</p>
</dd>
</dl>

<hr>
<h2 id='SurfaceGeometryMetaInfo'>Constructor for <code><a href="#topic+SurfaceGeometryMetaInfo-class">SurfaceGeometryMetaInfo</a></code> class</h2><span id='topic+SurfaceGeometryMetaInfo'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+SurfaceGeometryMetaInfo-class">SurfaceGeometryMetaInfo</a></code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurfaceGeometryMetaInfo(descriptor, header)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurfaceGeometryMetaInfo_+3A_descriptor">descriptor</code></td>
<td>
<p>the file descriptor</p>
</td></tr>
<tr><td><code id="SurfaceGeometryMetaInfo_+3A_header">header</code></td>
<td>
<p>a <code>list</code> containing header information</p>
</td></tr>
</table>

<hr>
<h2 id='SurfaceGeometryMetaInfo-class'>SurfaceGeometryMetaInfo
This class contains meta information for brain surface geometry</h2><span id='topic+SurfaceGeometryMetaInfo-class'></span>

<h3>Description</h3>

<p>SurfaceGeometryMetaInfo
</p>
<p>This class contains meta information for brain surface geometry
</p>


<h3>Slots</h3>


<dl>
<dt><code>headerFile</code></dt><dd><p>name of the file containing meta information</p>
</dd>
<dt><code>dataFile</code></dt><dd><p>name of the file containing data</p>
</dd>
<dt><code>fileDescriptor</code></dt><dd><p>descriptor of image file format</p>
</dd>
<dt><code>vertices</code></dt><dd><p>the number of surface vertices</p>
</dd>
<dt><code>faces</code></dt><dd><p>the number of faces</p>
</dd>
<dt><code>embedDimension</code></dt><dd><p>the dimensionality of the embedding</p>
</dd>
<dt><code>label</code></dt><dd><p>a label indicating the type of surface (e.g. white, pial, inflated, flat, spherical)</p>
</dd>
</dl>

<hr>
<h2 id='takeSeries'>Generic function to extract a set of series from a 4D image</h2><span id='topic+takeSeries'></span>

<h3>Description</h3>

<p>Generic function to extract a set of series from a 4D image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takeSeries(x, indices, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="takeSeries_+3A_x">x</code></td>
<td>
<p>a four dimensional image</p>
</td></tr>
<tr><td><code id="takeSeries_+3A_indices">indices</code></td>
<td>
<p>the indices of the series' to extract</p>
</td></tr>
<tr><td><code id="takeSeries_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='takeVolume'>Generic function to extract a one or more individual volumes from a four-dimensional image</h2><span id='topic+takeVolume'></span><span id='topic+takeVolume+2CBrainVector+2Cnumeric-method'></span><span id='topic+takeVolume+2CSparseBrainVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to extract a one or more individual volumes from a four-dimensional image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takeVolume(x, i, ...)

## S4 method for signature 'SparseBrainVector,numeric'
takeVolume(x, i, merge = FALSE)

## S4 method for signature 'BrainVector,numeric'
takeVolume(x, i, merge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="takeVolume_+3A_x">x</code></td>
<td>
<p>four-dimensional image</p>
</td></tr>
<tr><td><code id="takeVolume_+3A_i">i</code></td>
<td>
<p>the indices of the volume(s) to extract</p>
</td></tr>
<tr><td><code id="takeVolume_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="takeVolume_+3A_merge">merge</code></td>
<td>
<p>concatenate extracted volumes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>BrainVolume</code> elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bvec &lt;- BrainVector(array(rnorm(24*24*24*24), c(24,24,24,24)), BrainSpace(c(24,24,24,24), c(1,1,1)))
vol &lt;- takeVolume(bvec,1)
all.equal(dim(vol), c(24,24,24))

vol &lt;- takeVolume(bvec,1:3)
length(vol) == 3
class(vol) == "list"
</code></pre>

<hr>
<h2 id='tesselate'>tesselate</h2><span id='topic+tesselate'></span><span id='topic+tesselate+2CLogicalBrainVolume+2Cnumeric-method'></span>

<h3>Description</h3>

<p>tesselate
</p>
<p>tesselate a LogicalBrainVolume into K spatial disjoint components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tesselate(x, K, ...)

## S4 method for signature 'LogicalBrainVolume,numeric'
tesselate(x, K, features = NULL,
  spatialWeight = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tesselate_+3A_x">x</code></td>
<td>
<p>the object to tesselate</p>
</td></tr>
<tr><td><code id="tesselate_+3A_k">K</code></td>
<td>
<p>the number of partitions</p>
</td></tr>
<tr><td><code id="tesselate_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
<tr><td><code id="tesselate_+3A_features">features</code></td>
<td>
<p>use addiitonal feature set to tesselate volume</p>
</td></tr>
<tr><td><code id="tesselate_+3A_spatialweight">spatialWeight</code></td>
<td>
<p>weight voxels according to distance</p>
</td></tr>
</table>

<hr>
<h2 id='trans'>Generic getter to extract image coordinate transformation</h2><span id='topic+trans'></span><span id='topic+trans+2CBrainData-method'></span><span id='topic+trans+2CBrainMetaInfo-method'></span><span id='topic+trans+2CBrainSpace-method'></span><span id='topic+trans+2CNIfTIMetaInfo-method'></span>

<h3>Description</h3>

<p>Generic getter to extract image coordinate transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans(x)

## S4 method for signature 'BrainMetaInfo'
trans(x)

## S4 method for signature 'NIfTIMetaInfo'
trans(x)

## S4 method for signature 'BrainSpace'
trans(x)

## S4 method for signature 'BrainData'
trans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_+3A_x">x</code></td>
<td>
<p>an object with a transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a transformation that can be used to go from &quot;grid coordinates&quot; to &quot;real world coordinates&quot; in millimeters.
</p>
<p>This function returns a transformation that can be used to go from &quot;grid coordinates&quot; to &quot;real world coordinates&quot; in millimeters.
see <code><a href="#topic+BrainSpace-class">BrainSpace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bspace &lt;- BrainSpace(c(10,10,10), c(2,2,2))
trans(bspace)
all.equal(dim(trans(bspace)), c(4,4))
</code></pre>

<hr>
<h2 id='values'>Generic function to extract data values of object</h2><span id='topic+values'></span><span id='topic+values+2CROIVolume-method'></span>

<h3>Description</h3>

<p>Generic function to extract data values of object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>values(x, ...)

## S4 method for signature 'ROIVolume'
values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_+3A_x">x</code></td>
<td>
<p>the object to get values from</p>
</td></tr>
<tr><td><code id="values_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='voxels'>extract voxel coordinates</h2><span id='topic+voxels'></span><span id='topic+voxels+2CKernel-method'></span>

<h3>Description</h3>

<p>extract voxel coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voxels(x, ...)

## S4 method for signature 'Kernel'
voxels(x, centerVoxel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voxels_+3A_x">x</code></td>
<td>
<p>the object to extract voxels from</p>
</td></tr>
<tr><td><code id="voxels_+3A_...">...</code></td>
<td>
<p>additional arguments to function</p>
</td></tr>
<tr><td><code id="voxels_+3A_centervoxel">centerVoxel</code></td>
<td>
<p>the absolute location of the center of the voxel, default is (0,0,0)</p>
</td></tr>
</table>

<hr>
<h2 id='writeElements'>Generic function to write a sequence of elements from an input source</h2><span id='topic+writeElements'></span><span id='topic+writeElements+2CBinaryWriter+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Generic function to write a sequence of elements from an input source
</p>
<p>writeElements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeElements(x, els)

## S4 method for signature 'BinaryWriter,numeric'
writeElements(x, els)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeElements_+3A_x">x</code></td>
<td>
<p>the output channel</p>
</td></tr>
<tr><td><code id="writeElements_+3A_els">els</code></td>
<td>
<p>the elements to write</p>
</td></tr>
</table>

<hr>
<h2 id='writeVector'>Generic function to write a 4D image vector to disk</h2><span id='topic+writeVector'></span><span id='topic+writeVector+2CBrainVector+2Ccharacter+2Ccharacter+2Cmissing-method'></span><span id='topic+writeVector+2CBrainVector+2Ccharacter+2Cmissing+2Ccharacter+2CANY-method'></span><span id='topic+writeVector+2CBrainVector+2Ccharacter+2Cmissing+2Ccharacter-method'></span><span id='topic+writeVector+2CBrainVector+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function to write a 4D image vector to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeVector(x, fileName, format, dataType)

## S4 method for signature 'BrainVector,character,missing,missing'
writeVector(x, fileName)

## S4 method for signature 'BrainVector,character,character,missing'
writeVector(x, fileName,
  format)

## S4 method for signature 'BrainVector,character,missing,character'
writeVector(x, fileName,
  dataType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeVector_+3A_x">x</code></td>
<td>
<p>an image object, typically a <code>BrainVector</code> instance.</p>
</td></tr>
<tr><td><code id="writeVector_+3A_filename">fileName</code></td>
<td>
<p>output file name.</p>
</td></tr>
<tr><td><code id="writeVector_+3A_format">format</code></td>
<td>
<p>file format string. Since &quot;NIFTI&quot; is the only currently supported format, this parameter can be safely ignored and omitted.</p>
</td></tr>
<tr><td><code id="writeVector_+3A_datatype">dataType</code></td>
<td>
<p>the numeric data type. If specified should be a <code>character</code> vector of: &quot;BINARY&quot;, &quot;UBYTE&quot;, &quot;SHORT&quot;, &quot;INT&quot;, &quot;FLOAT&quot;, &quot;DOUBLE&quot;. 
Otherwise output format will be inferred from R the datatype of the image.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
bvec &lt;- BrainVector(array(0, c(10,10,10,10)), BrainSpace(c(10,10,10,10), c(1,1,1)))
## Not run: 
writeVector(bvol, "out.nii")
writeVector(bvol, "out.nii.gz")
writeVector(bvec, "out.nii")
writeVector(bvec, "out.nii.gz")

## End(Not run)
</code></pre>

<hr>
<h2 id='writeVolume'>Generic function to write a 3D image volume to disk</h2><span id='topic+writeVolume'></span><span id='topic+writeVolume+2CBrainVolume+2Ccharacter+2Ccharacter+2Cmissing-method'></span><span id='topic+writeVolume+2CBrainVolume+2Ccharacter+2Cmissing+2Ccharacter-method'></span><span id='topic+writeVolume+2CBrainVolume+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+writeVolume+2CClusteredBrainVolume+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generic function to write a 3D image volume to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeVolume(x, fileName, format, dataType)

## S4 method for signature 'BrainVolume,character,missing,missing'
writeVolume(x, fileName)

## S4 method for signature 'ClusteredBrainVolume,character,missing,missing'
writeVolume(x,
  fileName)

## S4 method for signature 'BrainVolume,character,character,missing'
writeVolume(x, fileName,
  format)

## S4 method for signature 'BrainVolume,character,missing,character'
writeVolume(x, fileName,
  dataType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeVolume_+3A_x">x</code></td>
<td>
<p>an image object, typically a <code>BrainVolume</code> instance.</p>
</td></tr>
<tr><td><code id="writeVolume_+3A_filename">fileName</code></td>
<td>
<p>output file name</p>
</td></tr>
<tr><td><code id="writeVolume_+3A_format">format</code></td>
<td>
<p>file format string. Since &quot;NIFTI&quot; is the only currently supported format, this parameter can be safely ignored and omitted.</p>
</td></tr>
<tr><td><code id="writeVolume_+3A_datatype">dataType</code></td>
<td>
<p>output data type, If specified should be a <code>character</code> vector of: &quot;BINARY&quot;, &quot;UBYTE&quot;, &quot;SHORT&quot;, &quot;INT&quot;, &quot;FLOAT&quot;, &quot;DOUBLE&quot;. 
Otherwise output format will be inferred from R the datatype of the image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output format will be inferred from file extension.
</p>
<p>The output format will be inferred from file extension.
<code>writeVolume(x, "out.nii")</code> outputs a NIFTI file.
<code>writeVolume(x, "out.nii.gz")</code> outputs a gzipped NIFTI file.
</p>
<p>No other file output formats are currently supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bvol &lt;- BrainVolume(array(0, c(10,10,10)), BrainSpace(c(10,10,10), c(1,1,1)))
## Not run: 
writeVolume(bvol, "out.nii")
writeVolume(bvol, "out.nii.gz")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
