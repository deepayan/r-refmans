<!DOCTYPE html><html><head><title>Help for package latrend</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {latrend}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#latrend-package'><p>latrend: A Framework for Clustering Longitudinal Data</p></a></li>
<li><a href='#.defineInternalDistanceMetrics'><p>Define the distance metrics for multiple types at once</p></a></li>
<li><a href='#.trajSubset'><p>Select trajectories</p></a></li>
<li><a href='#+5B+5B+2ClcMethod-method'><p>Retrieve and evaluate a lcMethod argument by name</p></a></li>
<li><a href='#APPA'><p>Average posterior probability of assignment (APPA)</p></a></li>
<li><a href='#as.data.frame.lcMethod'><p>Convert lcMethod arguments to a list of atomic types</p></a></li>
<li><a href='#as.data.frame.lcMethods'><p>Convert a list of lcMethod objects to a data.frame</p></a></li>
<li><a href='#as.data.frame.lcModels'><p>Generate a data.frame containing the argument values per method per row</p></a></li>
<li><a href='#as.lcMethods'><p>Convert a list of lcMethod objects to a lcMethods list</p></a></li>
<li><a href='#as.lcModels'><p>Convert a list of lcModels to a lcModels list</p></a></li>
<li><a href='#as.list.lcMethod'><p>Extract the method arguments as a list</p></a></li>
<li><a href='#clusterNames'><p>Get the cluster names</p></a></li>
<li><a href='#clusterNames+26lt+3B-'><p>Update the cluster names</p></a></li>
<li><a href='#clusterProportions'><p>Proportional size of each cluster</p></a></li>
<li><a href='#clusterSizes'><p>Number of trajectories per cluster</p></a></li>
<li><a href='#clusterTrajectories'><p>Extract cluster trajectories</p></a></li>
<li><a href='#clusterTrajectories+2ClcModelPartition-method'><p>function interface</p></a></li>
<li><a href='#coef.lcModel'><p>Extract lcModel coefficients</p></a></li>
<li><a href='#compose'><p><code>lcMethod</code> estimation step: compose an lcMethod object</p></a></li>
<li><a href='#confusionMatrix'><p>Compute the posterior confusion matrix</p></a></li>
<li><a href='#converged'><p>Check model convergence</p></a></li>
<li><a href='#createTestDataFold'><p>Create the test fold data for validation</p></a></li>
<li><a href='#createTestDataFolds'><p>Create all k test folds from the training data</p></a></li>
<li><a href='#createTrainDataFolds'><p>Create the training data for each of the k models in k-fold cross validation evaluation</p></a></li>
<li><a href='#defineExternalMetric'><p>Define an external metric for lcModels</p></a></li>
<li><a href='#defineInternalMetric'><p>Define an internal metric for lcModels</p></a></li>
<li><a href='#deviance.lcModel'><p>lcModel deviance</p></a></li>
<li><a href='#df.residual.lcModel'><p>Extract the residual degrees of freedom from a lcModel</p></a></li>
<li><a href='#estimationTime'><p>Estimation time</p></a></li>
<li><a href='#evaluate.lcMethod'><p>Substitute the call arguments for their evaluated values</p></a></li>
<li><a href='#externalMetric'><p>Compute external model metric(s)</p></a></li>
<li><a href='#fit'><p><code>lcMethod</code> estimation step: logic for fitting the method to the processed data</p></a></li>
<li><a href='#fitted.lcModel'><p>Extract lcModel fitted values</p></a></li>
<li><a href='#fittedTrajectories'><p>Extract the fitted trajectories</p></a></li>
<li><a href='#formula.lcMethod'><p>Extract formula</p></a></li>
<li><a href='#formula.lcModel'><p>Extract the formula of a lcModel</p></a></li>
<li><a href='#generateLongData'><p>Generate longitudinal test data</p></a></li>
<li><a href='#getArgumentDefaults'><p>Default argument values for the given method specification</p></a></li>
<li><a href='#getArgumentDefaults+2ClcMethodLcmmGMM-method'><p>lcmm interface</p></a></li>
<li><a href='#getArgumentExclusions'><p>Arguments to be excluded from the specification</p></a></li>
<li><a href='#getCall.lcModel'><p>Get the model call</p></a></li>
<li><a href='#getCitation'><p>Get citation info</p></a></li>
<li><a href='#getExternalMetricDefinition'><p>Get the external metric definition</p></a></li>
<li><a href='#getExternalMetricNames'><p>Get the names of the available external metrics</p></a></li>
<li><a href='#getInternalMetricDefinition'><p>Get the internal metric definition</p></a></li>
<li><a href='#getInternalMetricNames'><p>Get the names of the available internal metrics</p></a></li>
<li><a href='#getLabel'><p>Object label</p></a></li>
<li><a href='#getLcMethod'><p>Get the method specification</p></a></li>
<li><a href='#getName'><p>Object name</p></a></li>
<li><a href='#ids'><p>Get the trajectory ids on which the model was fitted</p></a></li>
<li><a href='#idVariable'><p>Extract the trajectory identifier variable</p></a></li>
<li><a href='#initialize+2ClcMethod-method'><p>lcMethod initialization</p></a></li>
<li><a href='#interface-akmedoids'><p>akmedoids interface</p></a></li>
<li><a href='#interface-crimCV'><p>crimCV interface</p></a></li>
<li><a href='#interface-dtwclust'><p>dtwclust interface</p></a></li>
<li><a href='#interface-featureBased'><p>featureBased interface</p></a></li>
<li><a href='#interface-flexmix'><p>flexmix interface</p></a></li>
<li><a href='#interface-funFEM'><p>funFEM interface</p></a></li>
<li><a href='#interface-kml'><p>kml interface</p></a></li>
<li><a href='#interface-mclust'><p>mclust interface</p></a></li>
<li><a href='#interface-metaMethods'><p>lcMetaMethod abstract class</p></a></li>
<li><a href='#interface-mixAK'><p>mixAK interface</p></a></li>
<li><a href='#interface-mixtools'><p>mixtools interface</p></a></li>
<li><a href='#interface-mixtvem'><p>mixtvem interface</p></a></li>
<li><a href='#isArgDefined'><p>Check whether the argument of a lcMethod has a defined value.</p></a></li>
<li><a href='#latrend'><p>Cluster longitudinal data using the specified method</p></a></li>
<li><a href='#latrend-approaches'><p>High-level approaches to longitudinal clustering</p></a></li>
<li><a href='#latrend-assert'><p>latrend-specific assertions</p></a></li>
<li><a href='#latrend-data'><p>Longitudinal dataset representation</p></a></li>
<li><a href='#latrend-estimation'><p>Overview of <strong><code>lcMethod</code></strong> estimation functions</p></a></li>
<li><a href='#latrend-generics'><p>Generics used by latrend for different classes</p></a></li>
<li><a href='#latrend-is'><p>Check if object is of Class</p></a></li>
<li><a href='#latrend-methods'><p>Supported methods for longitudinal clustering</p></a></li>
<li><a href='#latrend-metrics'><p>Metrics</p></a></li>
<li><a href='#latrend-parallel'><p>Parallel computation using latrend</p></a></li>
<li><a href='#latrendBatch'><p>Cluster longitudinal data for a list of method specifications</p></a></li>
<li><a href='#latrendBoot'><p>Cluster longitudinal data using bootstrapping</p></a></li>
<li><a href='#latrendCV'><p>Cluster longitudinal data over k folds</p></a></li>
<li><a href='#latrendData'><p>Artificial longitudinal dataset comprising three classes</p></a></li>
<li><a href='#latrendRep'><p>Cluster longitudinal data repeatedly</p></a></li>
<li><a href='#lcApproxModel-class'><p>lcApproxModel class</p></a></li>
<li><a href='#lcFitMethods'><p>Method fit modifiers</p></a></li>
<li><a href='#lcMatrixMethod-class'><p>lcMatrixMethod</p></a></li>
<li><a href='#lcMethod-class'><p>lcMethod class</p></a></li>
<li><a href='#lcMethod-estimation'><p>Longitudinal cluster method (<code>lcMethod</code>) estimation procedure</p></a></li>
<li><a href='#lcMethodAkmedoids'><p>Specify AKMedoids method</p></a></li>
<li><a href='#lcMethodCrimCV'><p>Specify a zero-inflated repeated-measures GBTM method</p></a></li>
<li><a href='#lcMethodDtwclust'><p>Specify time series clustering via dtwclust</p></a></li>
<li><a href='#lcMethodFeature'><p>Feature-based clustering</p></a></li>
<li><a href='#lcMethodFlexmix'><p>Method interface to flexmix()</p></a></li>
<li><a href='#lcMethodFlexmixGBTM'><p>Group-based trajectory modeling using flexmix</p></a></li>
<li><a href='#lcMethodFunction'><p>Specify a custom method based on a function</p></a></li>
<li><a href='#lcMethodFunFEM'><p>Specify a FunFEM method</p></a></li>
<li><a href='#lcMethodGCKM'><p>Two-step clustering through latent growth curve modeling and k-means</p></a></li>
<li><a href='#lcMethodKML'><p>Specify a longitudinal k-means (KML) method</p></a></li>
<li><a href='#lcMethodLcmmGBTM'><p>Specify GBTM method</p></a></li>
<li><a href='#lcMethodLcmmGMM'><p>Specify GMM method using lcmm</p></a></li>
<li><a href='#lcMethodLMKM'><p>Two-step clustering through linear regression modeling and k-means</p></a></li>
<li><a href='#lcMethodMclustLLPA'><p>Longitudinal latent profile analysis</p></a></li>
<li><a href='#lcMethodMixAK_GLMM'><p>Specify a GLMM iwht a normal mixture in the random effects</p></a></li>
<li><a href='#lcMethodMixtoolsGMM'><p>Specify mixed mixture regression model using mixtools</p></a></li>
<li><a href='#lcMethodMixtoolsNPRM'><p>Specify non-parametric estimation for independent repeated measures</p></a></li>
<li><a href='#lcMethodMixTVEM'><p>Specify a MixTVEM</p></a></li>
<li><a href='#lcMethodRandom'><p>Specify a random-partitioning method</p></a></li>
<li><a href='#lcMethods'><p>Generate a list of lcMethod objects</p></a></li>
<li><a href='#lcMethodStratify'><p>Specify a stratification method</p></a></li>
<li><a href='#lcModel'><p>Longitudinal cluster result (<strong><code>lcModel</code></strong>)</p></a></li>
<li><a href='#lcModel-class'><p><code>lcModel</code> class</p></a></li>
<li><a href='#lcModel-data-filters'><p>Data filters for lcModel</p></a></li>
<li><a href='#lcModel-make'><p>Cluster-handling functions for lcModel implementations.</p></a></li>
<li><a href='#lcModelPartition'><p>Create a lcModel with pre-defined partitioning</p></a></li>
<li><a href='#lcModels'><p>Construct a list of <code>lcModel</code> objects</p></a></li>
<li><a href='#lcModels-class'><p><code>lcModels</code>: a list of <code>lcModel</code> objects</p></a></li>
<li><a href='#lcModelWeightedPartition'><p>Create a lcModel with pre-defined weighted partitioning</p></a></li>
<li><a href='#logLik.lcModel'><p>Extract the log-likelihood of a lcModel</p></a></li>
<li><a href='#match.call.all'><p>Argument matching with defaults and parent ellipsis expansion</p></a></li>
<li><a href='#max.lcModels'><p>Select the lcModel with the highest metric value</p></a></li>
<li><a href='#meanNA'><p>Mean ignoring NAs</p></a></li>
<li><a href='#metric'><p>Compute internal model metric(s)</p></a></li>
<li><a href='#min.lcModels'><p>Select the lcModel with the lowest metric value</p></a></li>
<li><a href='#model.data'><p>Extract the model training data</p></a></li>
<li><a href='#model.data.lcModel'><p>Extract the model data that was used for fitting</p></a></li>
<li><a href='#model.frame.lcModel'><p>Extract model training data</p></a></li>
<li><a href='#names+2ClcMethod-method'><p>lcMethod argument names</p></a></li>
<li><a href='#nClusters'><p>Number of clusters</p></a></li>
<li><a href='#nIds'><p>Number of trajectories</p></a></li>
<li><a href='#nobs.lcModel'><p>Number of observations used for the lcModel fit</p></a></li>
<li><a href='#OCC'><p>Odds of correct classification (OCC)</p></a></li>
<li><a href='#PAP.adh'><p>Weekly Mean PAP Therapy Usage of OSA Patients in the First 3 Months</p></a></li>
<li><a href='#PAP.adh1y'><p>Biweekly Mean PAP Therapy Adherence of OSA Patients over 1 Year</p></a></li>
<li><a href='#plot-lcModel-method'><p>Plot a lcModel</p></a></li>
<li><a href='#plot-lcModels-method'><p>Grid plot for a list of models</p></a></li>
<li><a href='#plotClusterTrajectories'><p>Plot cluster trajectories</p></a></li>
<li><a href='#plotFittedTrajectories'><p>Plot the fitted trajectories</p></a></li>
<li><a href='#plotMetric'><p>Plot one or more internal metrics for all lcModels</p></a></li>
<li><a href='#plotTrajectories'><p>Plot the data trajectories</p></a></li>
<li><a href='#postFit'><p><code>lcMethod</code> estimation step: logic for post-processing the fitted lcModel</p></a></li>
<li><a href='#postprob'><p>Posterior probability per fitted trajectory</p></a></li>
<li><a href='#postprobFromAssignments'><p>Create a posterior probability matrix from a vector of cluster assignments.</p></a></li>
<li><a href='#postProbFromObs'><p>Compute the id-specific postprob matrix from a given observation-level postprob matrix</p></a></li>
<li><a href='#predict.lcModel'><p>lcModel predictions</p></a></li>
<li><a href='#predictAssignments'><p>Predict the cluster assignments for new trajectories</p></a></li>
<li><a href='#predictForCluster'><p>Predict trajectories conditional on cluster membership</p></a></li>
<li><a href='#predictPostprob'><p>Posterior probability for new data</p></a></li>
<li><a href='#preFit'><p><code>lcMethod</code> estimation step: method preparation logic</p></a></li>
<li><a href='#prepareData'><p><code>lcMethod</code> estimation step: logic for preparing the training data</p></a></li>
<li><a href='#print.lcMethod'><p>Print the arguments of an lcMethod object</p></a></li>
<li><a href='#print.lcModels'><p>Print lcModels list concisely</p></a></li>
<li><a href='#qqPlot'><p>Quantile-quantile plot</p></a></li>
<li><a href='#residuals.lcModel'><p>Extract lcModel residuals</p></a></li>
<li><a href='#responseVariable'><p>Extract response variable</p></a></li>
<li><a href='#sigma.lcModel'><p>Extract residual standard deviation from a lcModel</p></a></li>
<li><a href='#strip'><p>Reduce the memory footprint of an object for serialization</p></a></li>
<li><a href='#subset.lcModels'><p>Subsetting a lcModels list based on method arguments</p></a></li>
<li><a href='#summary.lcModel'><p>Summarize a lcModel</p></a></li>
<li><a href='#test'><p>Test a condition</p></a></li>
<li><a href='#test.latrend'><p>Test the implementation of an lcMethod and associated lcModel subclasses</p></a></li>
<li><a href='#time.lcModel'><p>Sampling times of a lcModel</p></a></li>
<li><a href='#timeVariable'><p>Extract the time variable</p></a></li>
<li><a href='#trajectories'><p>Extract the trajectories</p></a></li>
<li><a href='#trajectoryAssignments'><p>Get the cluster membership of each trajectory</p></a></li>
<li><a href='#transformFitted'><p>Helper function for custom lcModel classes implementing fitted.lcModel()</p></a></li>
<li><a href='#transformPredict'><p>Helper function for custom lcModel classes implementing predict.lcModel()</p></a></li>
<li><a href='#tsframe'><p>Convert a multiple time series matrix to a data.frame</p></a></li>
<li><a href='#tsmatrix'><p>Convert a longitudinal data.frame to a matrix</p></a></li>
<li><a href='#update.lcMethod'><p>Update a method specification</p></a></li>
<li><a href='#update.lcModel'><p>Update a lcModel</p></a></li>
<li><a href='#validate'><p><code>lcMethod</code> estimation step: method argument validation logic</p></a></li>
<li><a href='#weighted.meanNA'><p>Weighted arithmetic mean ignoring NAs</p></a></li>
<li><a href='#which.weight'><p>Sample an index of a vector weighted by the elements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-18</td>
</tr>
<tr>
<td>Title:</td>
<td>A Framework for Clustering Longitudinal Data</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for clustering longitudinal datasets in a standardized way. 
    The package provides an interface to existing R packages for clustering longitudinal univariate trajectories, facilitating reproducible and transparent analyses. 
    Additionally, standard tools are provided to support cluster analyses, including repeated estimation, model validation, and model assessment. 
    The interface enables users to compare results between methods, and to implement and evaluate new methods with ease.
    The 'akmedoids' package is available from <a href="https://github.com/MAnalytics/akmedoids">https://github.com/MAnalytics/akmedoids</a>.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Niek Den Teuling &lt;niek.den.teuling@philips.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/philips-software/latrend">https://github.com/philips-software/latrend</a>,
<a href="https://philips-software.github.io/latrend/">https://philips-software.github.io/latrend/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/philips-software/latrend/issues">https://github.com/philips-software/latrend/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, Rdpack, R.utils, assertthat (&ge; 0.2.1),
foreach, data.table (&ge; 1.12.0), magrittr, matrixStats,
rmarkdown (&ge; 1.18), rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), roxygen2 (&ge; 7.1.0), knitr (&ge; 1.24),
rcmdcheck, pkgdown, devtools, cluster, evaluate, lme4, covr,
lintr, tinytex, longitudinalData (&ge; 2.4.1), kml (&ge; 2.4.1),
lcmm (&ge; 1.9.3), mixtools, flexmix, fda, funFEM, gridExtra,
igraph, crimCV, dtwclust, mixAK, mclust, mclustcomp, clValid,
psych, qqplotr, doParallel, simTool, dplyr, ggplot2, caret,
tibble, clusterCrit (&ge; 1.3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'assert.R' 'citation.R' 'compute.R' 'data.R' 'formula.R'
'generics.R' 'latrend.R' 'make.R' 'matrix.R' 'method.R'
'meta-method.R' 'meta-fit.R' 'meta-fit-converged.R'
'meta-fit-rep.R' 'methodMatrix.R' 'methodAKMedoids.R'
'methodCrimCV.R' 'methodDtwclust.R' 'trajectories.R' 'model.R'
'modelApprox.R' 'modelPartition.R' 'methodFeature.R'
'methodFlexmix.R' 'methodFlexmixGBTM.R' 'methodFunFEM.R'
'methodFunction.R' 'methodLMKM.R' 'methodGCKM.R' 'methodKML.R'
'methodLcmmGMM.R' 'methodLcmmGBTM.R' 'methodMclustLLPA.R'
'methodMixAK_GLMM.R' 'methodMixTVEM.R' 'methodMixtoolsGMM.R'
'methodMixtoolsNPRM.R' 'methodRandom.R' 'methodStratify.R'
'methods.R' 'metrics.R' 'metricsInternal.R' 'metricsExternal.R'
'model-evaluation.R' 'model-summary.R' 'model-transform.R'
'modelCrimCV.R' 'modelDtwclust.R' 'modelFlexmix.R'
'modelFunFEM.R' 'modelKML.R' 'modelLMKM.R' 'modelLcmmGMM.R'
'modelLcmmGBTM.R' 'modelMclustLLPA.R' 'modelMixAK_GLMM.R'
'modelMixAK_GLMMlist.R' 'modelMixTVEM.R' 'modelMixtoolsGMM.R'
'modelMixtoolsRM.R' 'modelStratify.R'
'modelWeightedPartition.R' 'models.R' 'random.R' 'test.R'
'timing.R' 'verbose.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 21:58:08 UTC; 310083353</td>
</tr>
<tr>
<td>Author:</td>
<td>Niek Den Teuling <a href="https://orcid.org/0000-0003-1026-5080"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Steffen Pauws [ctb],
  Edwin van den Heuvel [ctb],
  Koninklijke Philips N.V. [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='latrend-package'>latrend: A Framework for Clustering Longitudinal Data</h2><span id='topic+latrend-package'></span>

<h3>Description</h3>

<p>A framework for clustering longitudinal datasets in a standardized way. The package provides an interface to existing R packages for clustering longitudinal univariate trajectories, facilitating reproducible and transparent analyses. Additionally, standard tools are provided to support cluster analyses, including repeated estimation, model validation, and model assessment. The interface enables users to compare results between methods, and to implement and evaluate new methods with ease. The 'akmedoids' package is available from <a href="https://github.com/MAnalytics/akmedoids">https://github.com/MAnalytics/akmedoids</a>.
</p>


<h3>Features</h3>


<ul>
<li> <p><strong>Unified cluster analysis</strong>, independent of the underlying algorithms used. Enabling users to compare the performance of various longitudinal cluster methods on the case study at hand.
</p>
</li>
<li><p> Supports <a href="#topic+latrend-methods">many different methods</a> for longitudinal clustering out of the box (see the list of supported packages below).
</p>
</li>
<li><p> The framework consists of extensible S4 methods based on an abstract <a href="#topic+lcModel-class">model class</a>, enabling <strong>rapid prototyping</strong> of new cluster methods or model specifications.
</p>
</li>
<li><p> Standard <strong>plotting</strong> tools for model evaluation across methods (e.g., <a href="#topic+trajectories">trajectories</a>, <a href="#topic+clusterTrajectories">cluster trajectories</a>, model fit, <a href="#topic+latrend-metrics">metrics</a>)
</p>
</li>
<li><p> Support for many <strong><a href="#topic+latrend-metrics">cluster metrics</a></strong> through the packages <em>clusterCrit</em>, <em>mclustcomp</em>, and <em>igraph</em>.
</p>
</li>
<li><p> The structured and unified analysis approach enables simulation studies for <strong>comparing methods</strong>.
</p>
</li>
<li><p> Standardized model validation for all methods through <a href="#topic+latrendBoot">bootstrapping</a> or <a href="#topic+latrendCV">k-fold cross-validation</a>.
</p>
</li></ul>

<p>The supported types of longitudinal datasets are described <a href="#topic+latrend-data">here</a>.
</p>


<h3>Getting started</h3>

<p>The <a href="#topic+latrendData">latrendData</a> dataset is included with the package and is used in all examples.
The <code><a href="#topic+plotTrajectories">plotTrajectories()</a></code> function can be used to visualize any longitudinal dataset, given the <code>id</code> and <code>time</code> are specified.
</p>
<pre>
data(latrendData)
head(latrendData)
options(latrend.id = "Id", latrend.time = "Time")
plotTrajectories(latrendData, response = "Y")
</pre>
<p>Discovering longitudinal clusters using the package involves the specification of the longitudinal cluster method that should be used.
</p>
<pre>
kmlMethod &lt;- lcMethodKML("Y", nClusters = 3)
kmlMethod
</pre>
<p>The specified method is then estimated on the data using the generic estimation procedure function <code><a href="#topic+latrend">latrend()</a></code>:
</p>
<pre>
model &lt;- latrend(kmlMethod, data = latrendData)
</pre>
<p>We can then investigate the fitted model using
</p>
<pre>
summary(model)
plot(model)
metric(model, c("WMAE", "BIC"))
qqPlot(model)
</pre>
<p>Create derivative method specifications for 1 to 5 clusters using the <code><a href="#topic+lcMethods">lcMethods()</a></code> function.
A series of methods can be estimated using <code><a href="#topic+latrendBatch">latrendBatch()</a></code>.
</p>
<pre>
kmlMethods &lt;- lcMethods(kmlMethod, nClusters = 1:5)
models &lt;- latrendBatch(kmlMethods, data = latrendData)
</pre>
<p>Determine the number of clusters through one or more internal cluser metrics.
This can be done visually using the <code><a href="#topic+plotMetric">plotMetric()</a></code> function.
</p>
<pre>
plotMetric(models, c("WMAE", "BIC"))
</pre>


<h3>Vignettes</h3>

<p>Further step-by-step instructions on how to use the package are described in the vignettes.
</p>

<ul>
<li><p> See <code>vignette("demo", package = "latrend")</code> for an introduction to conducting a longitudinal cluster analysis on a example case study.
</p>
</li>
<li><p> See <code>vignette("simulation", package = "latrend")</code> for an example on conducting a simulation study.
</p>
</li>
<li><p> See <code>vignette("validation", package = "latrend")</code> for examples on applying internal cluster validation.
</p>
</li>
<li><p> See <code>vignette("implement", package = "latrend")</code> for examples on constructing your own cluster models.
</p>
</li></ul>



<h3>Useful pages</h3>

<p>Data requirements and datasets:
<a href="#topic+latrend-data">latrend-data</a> <a href="#topic+latrendData">latrendData</a> <a href="#topic+PAP.adh">PAP.adh</a>
</p>
<p>High-level method recommendations and supported methods:
<a href="#topic+latrend-approaches">latrend-approaches</a> <a href="#topic+latrend-methods">latrend-methods</a>
</p>
<p>Method specification:
<a href="#topic+lcMethod-class">lcMethod</a>
<a href="#topic+lcMethods">lcMethods</a>
</p>
<p>Method estimation:
<a href="#topic+latrend">latrend</a> <a href="#topic+latrendRep">latrendRep</a> <a href="#topic+latrendBatch">latrendBatch</a> <a href="#topic+latrendBoot">latrendBoot</a> <a href="#topic+latrendCV">latrendCV</a>
<a href="#topic+latrend-parallel">latrend-parallel</a>
<a href="#topic+lcMethod-estimation">Steps performed during estimation</a>
</p>
<p>Model functions:
<a href="#topic+lcModel-class">lcModel</a>
<a href="#topic+clusterTrajectories">clusterTrajectories</a> <a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>
<a href="#topic+postprob">postprob</a> <a href="#topic+trajectoryAssignments">trajectoryAssignments</a> <a href="#topic+predictPostprob">predictPostprob</a> <a href="#topic+predictAssignments">predictAssignments</a>
<a href="#topic+predict.lcModel">predict.lcModel</a> <a href="#topic+predictForCluster">predictForCluster</a> <a href="#topic+fitted.lcModel">fitted.lcModel</a> <a href="#topic+fittedTrajectories">fittedTrajectories</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Niek Den Teuling <a href="mailto:niek.den.teuling@philips.com">niek.den.teuling@philips.com</a> (<a href="https://orcid.org/0000-0003-1026-5080">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Steffen Pauws <a href="mailto:s.c.pauws@tilburguniversity.edu">s.c.pauws@tilburguniversity.edu</a> [contributor]
</p>
</li>
<li><p> Edwin van den Heuvel <a href="mailto:e.r.v.d.heuvel@tue.nl">e.r.v.d.heuvel@tue.nl</a> [contributor]
</p>
</li>
<li><p> Koninklijke Philips N.V. [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/philips-software/latrend">https://github.com/philips-software/latrend</a>
</p>
</li>
<li> <p><a href="https://philips-software.github.io/latrend/">https://philips-software.github.io/latrend/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/philips-software/latrend/issues">https://github.com/philips-software/latrend/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.defineInternalDistanceMetrics'>Define the distance metrics for multiple types at once</h2><span id='topic+.defineInternalDistanceMetrics'></span>

<h3>Description</h3>

<p>Define the distance metrics for multiple types at once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.defineInternalDistanceMetrics(
  name,
  type = c("traj", "fit"),
  distanceFun,
  clusterAggregationFun = weighted.mean,
  assertNonEmpty = TRUE,
  assertNonSolitary = FALSE,
  assertNonIdentical = FALSE,
  ...
)
</code></pre>

<hr>
<h2 id='.trajSubset'>Select trajectories</h2><span id='topic+.trajSubset'></span>

<h3>Description</h3>

<p>Create a subset of the data with the given trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trajSubset(data, ids, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".trajSubset_+3A_data">data</code></td>
<td>
<p>The longitudinal dataset, a <code>data.frame</code></p>
</td></tr>
<tr><td><code id=".trajSubset_+3A_ids">ids</code></td>
<td>
<p>The trajectory identifiers, <code>vector</code></p>
</td></tr>
<tr><td><code id=".trajSubset_+3A_id">id</code></td>
<td>
<p>The name of the id column</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B+2ClcMethod-method'>Retrieve and evaluate a lcMethod argument by name</h2><span id='topic++5B+5B+2ClcMethod-method'></span><span id='topic++24+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Retrieve and evaluate a lcMethod argument by name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethod'
x$name

## S4 method for signature 'lcMethod'
x[[i, eval = TRUE, envir = NULL]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B2ClcMethod-method_+3A_x">x</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2ClcMethod-method_+3A_name">name</code></td>
<td>
<p>The argument name, as <code>character</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2ClcMethod-method_+3A_i">i</code></td>
<td>
<p>Name or index of the argument to retrieve.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2ClcMethod-method_+3A_eval">eval</code></td>
<td>
<p>Whether to evaluate the call argument (enabled by default).</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2ClcMethod-method_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the argument. This argument is only applicable when <code>eval = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The argument <code>call</code> or evaluation result.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 3)
method$nClusters # 3
m = lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 5)
m[["nClusters"]] # 5

k = 2
m = lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = k)
m[["nClusters", eval=FALSE]] # k
</code></pre>

<hr>
<h2 id='APPA'>Average posterior probability of assignment (APPA)</h2><span id='topic+APPA'></span>

<h3>Description</h3>

<p>Computes the average posterior probability of assignment (APPA) for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APPA(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APPA_+3A_object">object</code></td>
<td>
<p>The model, of type <code>lcModel</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The APPA per cluster, as a <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of length <code>nClusters(object)</code>.
Empty clusters will output <code>NA</code>.
</p>


<h3>References</h3>

<p>Nagin DS (2005).
<em>Group-based modeling of development</em>.
Harvard University Press.
ISBN 9780674041318, <a href="https://doi.org/10.4159/9780674041318">doi:10.4159/9780674041318</a>.
</p>
<p>Klijn SL, Weijenberg MP, Lemmens P, van den Brandt PA, Passos VL (2017).
&ldquo;Introducing the fit-criteria assessment plot - A visualisation tool to assist class enumeration in group-based trajectory modelling.&rdquo;
<em>Statistical Methods in Medical Research</em>, <b>26</b>(5), 2424-2436.
</p>
<p>van der Nest G, Lima Passos V, Candel MJ, van Breukelen GJ (2020).
&ldquo;An overview of mixture modelling for latent evolutions in longitudinal data: Modelling approaches, fit statistics and software.&rdquo;
<em>Advances in Life Course Research</em>, <b>43</b>, 100323.
ISSN 1040-2608, <a href="https://doi.org/10.1016/j.alcr.2019.100323">doi:10.1016/j.alcr.2019.100323</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+confusionMatrix">confusionMatrix</a> <a href="#topic+OCC">OCC</a>
</p>

<hr>
<h2 id='as.data.frame.lcMethod'>Convert lcMethod arguments to a list of atomic types</h2><span id='topic+as.data.frame.lcMethod'></span>

<h3>Description</h3>

<p>Converts the arguments of a <code>lcMethod</code> to a named <code>list</code> of <a href="base.html#topic+atomic">atomic</a> types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
as.data.frame(x, ..., eval = TRUE, nullValue = NA, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.lcMethod_+3A_x">x</code></td>
<td>
<p><code>lcMethod</code> to be coerced to a <code>character</code> <code>vector</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethod_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethod_+3A_eval">eval</code></td>
<td>
<p>Whether to evaluate the arguments in order to replace expression if the resulting value is of a class specified in <code>evalClasses</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethod_+3A_nullvalue">nullValue</code></td>
<td>
<p>Value to use to represent the <code>NULL</code> type. Must be of length 1.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row <code>data.frame</code> where each columns represents an argument call or evaluation.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>

<hr>
<h2 id='as.data.frame.lcMethods'>Convert a list of lcMethod objects to a data.frame</h2><span id='topic+as.data.frame.lcMethods'></span>

<h3>Description</h3>

<p>Converts a list of <code>lcMethod</code> objects to a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethods'
as.data.frame(x, ..., eval = TRUE, nullValue = NA, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.lcMethods_+3A_x">x</code></td>
<td>
<p>the <code>lcMethods</code> or <code>list</code> to be coerced to a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethods_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethods_+3A_eval">eval</code></td>
<td>
<p>Whether to evaluate the arguments in order to replace expression if the resulting value is of a class specified in <code>evalClasses</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethods_+3A_nullvalue">nullValue</code></td>
<td>
<p>Value to use to represent the <code>NULL</code> type. Must be of length 1.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcMethods_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with each row containing the argument values of a method object.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>

<hr>
<h2 id='as.data.frame.lcModels'>Generate a data.frame containing the argument values per method per row</h2><span id='topic+as.data.frame.lcModels'></span>

<h3>Description</h3>

<p>Generate a data.frame containing the argument values per method per row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModels'
as.data.frame(x, ..., excludeShared = FALSE, eval = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.lcModels_+3A_x">x</code></td>
<td>
<p><code>lcModels</code> or a list of <code>lcModel</code></p>
</td></tr>
<tr><td><code id="as.data.frame.lcModels_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcModels_+3A_excludeshared">excludeShared</code></td>
<td>
<p>Whether to exclude columns which have the same value across all methods.</p>
</td></tr>
<tr><td><code id="as.data.frame.lcModels_+3A_eval">eval</code></td>
<td>
<p>Whether to evaluate the arguments in order to replace expression if the resulting value is of a class specified in <code>evalClasses</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>


<hr>
<h2 id='as.lcMethods'>Convert a list of lcMethod objects to a lcMethods list</h2><span id='topic+as.lcMethods'></span>

<h3>Description</h3>

<p>Convert a list of lcMethod objects to a lcMethods list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lcMethods(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lcMethods_+3A_x">x</code></td>
<td>
<p>A <code>list</code> of <code>lcMethod</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcMethods</code> object.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>

<hr>
<h2 id='as.lcModels'>Convert a list of lcModels to a lcModels list</h2><span id='topic+as.lcModels'></span>

<h3>Description</h3>

<p>Convert a list of lcModels to a lcModels list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lcModels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lcModels_+3A_x">x</code></td>
<td>
<p>A <code>list</code> of <code>lcModel</code> objects, an <code>lcModels</code> object, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcModels</code> object.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>lcModels
</p>
<p>Other lcModels functions: 
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>

<hr>
<h2 id='as.list.lcMethod'>Extract the method arguments as a list</h2><span id='topic+as.list.lcMethod'></span>

<h3>Description</h3>

<p>Extract the method arguments as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
as.list(x, ..., args = names(x), eval = TRUE, expand = FALSE, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.lcMethod_+3A_x">x</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="as.list.lcMethod_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="as.list.lcMethod_+3A_args">args</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> of argument names to select. Only available arguments are returned.
Alternatively, a <code>function</code> or <code>list</code> of <code>function</code>s, whose formal arguments will be selected from the method.</p>
</td></tr>
<tr><td><code id="as.list.lcMethod_+3A_eval">eval</code></td>
<td>
<p>Whether to evaluate the arguments.</p>
</td></tr>
<tr><td><code id="as.list.lcMethod_+3A_expand">expand</code></td>
<td>
<p>Whether to return all method arguments when <code>"..."</code> is present among the requested argument names.</p>
</td></tr>
<tr><td><code id="as.list.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the argument <code>call</code>s or evaluated results depending on the value for <code>eval</code>.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
as.list(method)

as.list(method, args = c("id", "time"))

if (require("kml")) {
  method &lt;- lcMethodKML("Y", id = "Id", time = "Time")
  as.list(method)

  # select arguments used by kml()
  as.list(method, args = kml::kml)

  # select arguments used by either kml() or parALGO()
  as.list(method, args = c(kml::kml, kml::parALGO))
}
</code></pre>

<hr>
<h2 id='clusterNames'>Get the cluster names</h2><span id='topic+clusterNames'></span>

<h3>Description</h3>

<p>Get the cluster names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterNames(object, factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterNames_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="clusterNames_+3A_factor">factor</code></td>
<td>
<p>Whether to return the cluster names as a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> of the cluster names.
</p>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
clusterNames(model) # A, B
</code></pre>

<hr>
<h2 id='clusterNames+26lt+3B-'>Update the cluster names</h2><span id='topic+clusterNames+3C-'></span>

<h3>Description</h3>

<p>Update the cluster names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterNames(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterNames+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object to update.</p>
</td></tr>
<tr><td><code id="clusterNames+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The <code>character</code> with the new names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>lcModel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 2)
clusterNames(model) &lt;- c("Group 1", "Group 2")
</code></pre>

<hr>
<h2 id='clusterProportions'>Proportional size of each cluster</h2><span id='topic+clusterProportions'></span><span id='topic+clusterProportions+2ClcModel-method'></span>

<h3>Description</h3>

<p>Obtain the proportional size per cluster, between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterProportions(object, ...)

## S4 method for signature 'lcModel'
clusterProportions(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterProportions_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="clusterProportions_+3A_...">...</code></td>
<td>
<p>For <code>lcModel</code> objects: Additional arguments passed to <code><a href="#topic+postprob">postprob()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;named numeric vector&#8288;</code> of length <code>nClusters(object)</code> with the proportional size of each cluster.
</p>


<h3>lcModel</h3>

<p>By default, the cluster proportions are determined from the cluster-averaged posterior probabilities of the fitted data (as computed by the <code><a href="#topic+postprob">postprob()</a></code> function).
</p>
<p>Classes extending <code>lcModel</code> can override this method to return, for example, the exact estimated mixture proportions based on the model coefficients.
</p>
<pre>
setMethod("clusterProportions", "lcModelExt", function(object, ...) {
  # return cluster proportion vector
})
</pre>


<h3>See Also</h3>

<p><a href="#topic+nClusters">nClusters</a> <a href="#topic+clusterNames">clusterNames</a>
</p>
<p><a href="#topic+clusterSizes">clusterSizes</a> <a href="#topic+postprob">postprob</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 2)
clusterProportions(model)
</code></pre>

<hr>
<h2 id='clusterSizes'>Number of trajectories per cluster</h2><span id='topic+clusterSizes'></span>

<h3>Description</h3>

<p>Obtain the size of each cluster, where the size is determined by the number of assigned trajectories to each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterSizes(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterSizes_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="clusterSizes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cluster sizes are computed from the trajectory cluster membership as decided by the <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code> function.
</p>


<h3>Value</h3>

<p>A named <code style="white-space: pre;">&#8288;integer vector&#8288;</code> of length <code>nClusters(object)</code> with the number of assigned trajectories per cluster.
</p>


<h3>See Also</h3>

<p><a href="#topic+clusterProportions">clusterProportions</a> <a href="#topic+trajectoryAssignments">trajectoryAssignments</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 2)
clusterSizes(model)
</code></pre>

<hr>
<h2 id='clusterTrajectories'>Extract cluster trajectories</h2><span id='topic+clusterTrajectories'></span><span id='topic+clusterTrajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Extracts a <code>data.frame</code> of the cluster trajectories associated with the given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTrajectories(object, ...)

## S4 method for signature 'lcModel'
clusterTrajectories(object, at = time(object), what = "mu", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTrajectories_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="clusterTrajectories_+3A_...">...</code></td>
<td>
<p>For <code>lcModel</code> objects: Arguments passed to <a href="#topic+predict.lcModel">predict.lcModel</a>.</p>
</td></tr>
<tr><td><code id="clusterTrajectories_+3A_at">at</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the times at which to compute the cluster trajectories.</p>
</td></tr>
<tr><td><code id="clusterTrajectories_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of the estimated values at the specified times.
The first column should be named &quot;Cluster&quot;.
The second column should be time, with the name matching the <code>timeVariable(object)</code>.
The third column should be the expected value of the observations, named after the <code>responseVariable(object)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

clusterTrajectories(model)

clusterTrajectories(model, at = c(0, .5, 1))
</code></pre>

<hr>
<h2 id='clusterTrajectories+2ClcModelPartition-method'>function interface</h2><span id='topic+clusterTrajectories+2ClcModelPartition-method'></span><span id='topic+converged+2ClcModelPartition-method'></span><span id='topic+getName+2ClcModelPartition-method'></span><span id='topic+getShortName+2ClcModelPartition-method'></span><span id='topic+postprob+2ClcModelPartition-method'></span><span id='topic+interface-custom'></span><span id='topic+getArgumentDefaults+2ClcMethodFunction-method'></span><span id='topic+getName+2ClcMethodFunction-method'></span><span id='topic+getShortName+2ClcMethodFunction-method'></span><span id='topic+prepareData+2ClcMethodFunction-method'></span><span id='topic+fit+2ClcMethodFunction-method'></span><span id='topic+getArgumentDefaults+2ClcMethodRandom-method'></span><span id='topic+getName+2ClcMethodRandom-method'></span><span id='topic+getShortName+2ClcMethodRandom-method'></span><span id='topic+fit+2ClcMethodRandom-method'></span><span id='topic+converged+2ClcModelStratify-method'></span><span id='topic+predictPostprob+2ClcModelStratify-method'></span><span id='topic+clusterTrajectories+2ClcModelWeightedPartition-method'></span><span id='topic+converged+2ClcModelWeightedPartition-method'></span><span id='topic+getName+2ClcModelWeightedPartition-method'></span><span id='topic+getShortName+2ClcModelWeightedPartition-method'></span><span id='topic+postprob+2ClcModelWeightedPartition-method'></span>

<h3>Description</h3>

<p>function interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcModelPartition'
clusterTrajectories(
  object,
  at = time(object),
  center = object@center,
  approxFun = approx,
  ...
)

## S4 method for signature 'lcModelPartition'
converged(object, ...)

## S4 method for signature 'lcModelPartition'
getName(object, ...)

## S4 method for signature 'lcModelPartition'
getShortName(object, ...)

## S4 method for signature 'lcModelPartition'
postprob(object, ...)

## S4 method for signature 'lcMethodFunction'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodFunction'
getName(object)

## S4 method for signature 'lcMethodFunction'
getShortName(object)

## S4 method for signature 'lcMethodFunction'
prepareData(method, data, verbose)

## S4 method for signature 'lcMethodFunction'
fit(method, data, envir, verbose)

## S4 method for signature 'lcMethodRandom'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodRandom'
getName(object)

## S4 method for signature 'lcMethodRandom'
getShortName(object)

## S4 method for signature 'lcMethodRandom'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelStratify'
converged(object, ...)

## S4 method for signature 'lcModelStratify'
predictPostprob(object, newdata = NULL, ...)

## S4 method for signature 'lcModelWeightedPartition'
clusterTrajectories(
  object,
  at = time(object),
  center = weighted.meanNA,
  approxFun = approx,
  ...
)

## S4 method for signature 'lcModelWeightedPartition'
converged(object, ...)

## S4 method for signature 'lcModelWeightedPartition'
getName(object, ...)

## S4 method for signature 'lcModelWeightedPartition'
getShortName(object, ...)

## S4 method for signature 'lcModelWeightedPartition'
postprob(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_center">center</code></td>
<td>
<p>The function to use to compute the cluster trajectory center at the respective moment in time.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="clusterTrajectories+2B2ClcModelPartition-method_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> for which to compute the posterior probability. If omitted, the model training data is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodRandom">lcMethodRandom</a> <a href="#topic+lcMethodStratify">lcMethodStratify</a> <a href="#topic+lcModelPartition">lcModelPartition</a> <a href="#topic+lcModelWeightedPartition">lcModelWeightedPartition</a>
</p>

<hr>
<h2 id='coef.lcModel'>Extract lcModel coefficients</h2><span id='topic+coef.lcModel'></span>

<h3>Description</h3>

<p>Extract the coefficients of the <code>lcModel</code> object, if defined.
The returned set of coefficients depends on the underlying type of <code>lcModel</code>.
The default implementation checks for the existence of a <code>coef()</code> function for the internal model as defined in the <code style="white-space: pre;">&#8288;@model&#8288;</code> slot, returning the output if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="coef.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> with all coefficients, or a <code>matrix</code> with each column containing the cluster-specific coefficients. If <code>coef()</code> is not defined for the given model, an empty <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> is returned.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> can override this method to return model-specific coefficients.
</p>
<pre>
coef.lcModelExt &lt;- function(object, ...) {
  # return model coefficients
}
</pre>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 2)
coef(model)
</code></pre>

<hr>
<h2 id='compose'><code>lcMethod</code> estimation step: compose an lcMethod object</h2><span id='topic+compose'></span><span id='topic+compose+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>compose()</code> function of the <code>lcMethod</code> object evaluates and finalizes the <code>lcMethod</code> arguments.
</p>
<p>The default implementation returns an updated object with all arguments having been evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose(method, envir, ...)

## S4 method for signature 'lcMethod'
compose(method, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_+3A_method">method</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="compose_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which the <code>lcMethod</code> should be evaluated</p>
</td></tr>
<tr><td><code id="compose_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The evaluated and finalized <code>lcMethod</code> object.
</p>


<h3>Implementation</h3>

<p>In general, there is no need to extend this method for a specific method, as all arguments are automatically evaluated by the <code style="white-space: pre;">&#8288;compose,lcMethod&#8288;</code> method.
</p>
<p>However, in case there is a need to extend processing or to prevent evaluation of specific arguments (e.g., for handling errors), the method can be overridden for the specific <code>lcMethod</code> subclass.
</p>
<pre>
setMethod("compose", "lcMethodExample", function(method, envir = NULL) {
  newMethod &lt;- callNextMethod()
  # further processing
  return(newMethod)
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>


<h3>See Also</h3>

<p><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>
</p>

<hr>
<h2 id='confusionMatrix'>Compute the posterior confusion matrix</h2><span id='topic+confusionMatrix'></span>

<h3>Description</h3>

<p>Compute the posterior confusion matrix (PCM).
The entry <code class="reqn">(i,j)</code> represents the probability (or number, in case of  <code>scale = TRUE</code>) of a trajectory
belonging to cluster <code class="reqn">i</code> is assigned to cluster <code class="reqn">j</code> under the specified trajectory cluster assignment strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusionMatrix(object, strategy = which.max, scale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confusionMatrix_+3A_object">object</code></td>
<td>
<p>The model, of type <code>lcModel</code>.</p>
</td></tr>
<tr><td><code id="confusionMatrix_+3A_strategy">strategy</code></td>
<td>
<p>The strategy for assigning trajectories to a specific cluster, see <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code>.
If <code>strategy = NULL</code>, the posterior probabilities are used as weights (analogous to a repeated evaluation of <code>strategy = which.weight</code>).</p>
</td></tr>
<tr><td><code id="confusionMatrix_+3A_scale">scale</code></td>
<td>
<p>Whether to express the confusion in probabilities (<code>scale = TRUE</code>), or in terms of the number of trajectories.</p>
</td></tr>
<tr><td><code id="confusionMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A K-by-K confusion <code>matrix</code> with <code>K = nClusters(object)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+postprob">postprob</a> <a href="#topic+clusterProportions">clusterProportions</a> <a href="#topic+trajectoryAssignments">trajectoryAssignments</a> <a href="#topic+APPA">APPA</a> <a href="#topic+OCC">OCC</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (rlang::is_installed("lcmm")) {
  method &lt;- lcMethodLcmmGMM(
    fixed = Y ~ Time,
    mixture = ~ Time,
    random = ~ 1,
    id = "Id",
    time = "Time"
  )
  model &lt;- latrend(method, latrendData)
  confusionMatrix(model)
}
</code></pre>

<hr>
<h2 id='converged'>Check model convergence</h2><span id='topic+converged'></span><span id='topic+converged+2ClcModel-method'></span>

<h3>Description</h3>

<p>Check whether the fitted object converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>converged(object, ...)

## S4 method for signature 'lcModel'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="converged_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="converged_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>logical</code> indicating convergence, or a <code>numeric</code> status code.
</p>
<p>The default <code>lcModel</code> implementation returns <code>NA</code>.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> can override this method to return a convergence status or code.
</p>
<pre>
setMethod("converged", "lcModelExt", function(object, ...) {
  # return convergence code
})
</pre>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 2)
converged(model)
</code></pre>

<hr>
<h2 id='createTestDataFold'>Create the test fold data for validation</h2><span id='topic+createTestDataFold'></span>

<h3>Description</h3>

<p>Create the test fold data for validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTestDataFold(data, trainData, id = getOption("latrend.id"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTestDataFold_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the complete dataset.</p>
</td></tr>
<tr><td><code id="createTestDataFold_+3A_traindata">trainData</code></td>
<td>
<p>A <code>data.frame</code> representing the training data, which should be a subset of <code>data</code>.</p>
</td></tr>
<tr><td><code id="createTestDataFold_+3A_id">id</code></td>
<td>
<p>The trajectory identifier variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>createTrainDataFolds
</p>
<p>Other validation methods: 
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+lcModel-data-filters">lcModel-data-filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("caret")) {
  trainDataList &lt;- createTrainDataFolds(latrendData, id = "Id", folds = 10)
  testData1 &lt;- createTestDataFold(latrendData, trainDataList[[1]], id = "Id")
}
</code></pre>

<hr>
<h2 id='createTestDataFolds'>Create all k test folds from the training data</h2><span id='topic+createTestDataFolds'></span>

<h3>Description</h3>

<p>Create all k test folds from the training data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTestDataFolds(data, trainDataList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTestDataFolds_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the complete dataset.</p>
</td></tr>
<tr><td><code id="createTestDataFolds_+3A_traindatalist">trainDataList</code></td>
<td>
<p>A <code>list</code> of <code>data.frame</code> representing each of the data training folds. These should be derived from <code>data</code>.</p>
</td></tr>
<tr><td><code id="createTestDataFolds_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="#topic+createTestDataFold">createTestDataFold</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+lcModel-data-filters">lcModel-data-filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("caret")) {
  trainDataList &lt;- createTrainDataFolds(latrendData, folds = 10, id = "Id")
  testDataList &lt;- createTestDataFolds(latrendData, trainDataList)
}
</code></pre>

<hr>
<h2 id='createTrainDataFolds'>Create the training data for each of the k models in k-fold cross validation evaluation</h2><span id='topic+createTrainDataFolds'></span>

<h3>Description</h3>

<p>Create the training data for each of the k models in k-fold cross validation evaluation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTrainDataFolds(
  data,
  folds = 10L,
  id = getOption("latrend.id"),
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTrainDataFolds_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the complete dataset.</p>
</td></tr>
<tr><td><code id="createTrainDataFolds_+3A_folds">folds</code></td>
<td>
<p>The number of folds. By default, a 10-fold scheme is used.</p>
</td></tr>
<tr><td><code id="createTrainDataFolds_+3A_id">id</code></td>
<td>
<p>The trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="createTrainDataFolds_+3A_seed">seed</code></td>
<td>
<p>The seed to use, in order to ensure reproducible fold generation at a later moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>data.frame</code> of the <code>folds</code> training datasets.
</p>


<h3>See Also</h3>

<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+lcModel-data-filters">lcModel-data-filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")

if (require("caret")) {
  trainFolds &lt;- createTrainDataFolds(latrendData, folds = 5, id = "Id", seed = 1)

  foldModels &lt;- latrendBatch(method, data = trainFolds)
  testDataFolds &lt;- createTestDataFolds(latrendData, trainFolds)
}
</code></pre>

<hr>
<h2 id='defineExternalMetric'>Define an external metric for lcModels</h2><span id='topic+defineExternalMetric'></span>

<h3>Description</h3>

<p>Define an external metric for lcModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineExternalMetric(
  name,
  fun,
  warnIfExists = getOption("latrend.warnMetricOverride", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineExternalMetric_+3A_name">name</code></td>
<td>
<p>The name of the metric.</p>
</td></tr>
<tr><td><code id="defineExternalMetric_+3A_fun">fun</code></td>
<td>
<p>The function to compute the metric, accepting a lcModel object as input.</p>
</td></tr>
<tr><td><code id="defineExternalMetric_+3A_warnifexists">warnIfExists</code></td>
<td>
<p>Whether to output a warning when the metric is already defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>

<hr>
<h2 id='defineInternalMetric'>Define an internal metric for lcModels</h2><span id='topic+defineInternalMetric'></span>

<h3>Description</h3>

<p>Define an internal metric for lcModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineInternalMetric(
  name,
  fun,
  warnIfExists = getOption("latrend.warnMetricOverride", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineInternalMetric_+3A_name">name</code></td>
<td>
<p>The name of the metric.</p>
</td></tr>
<tr><td><code id="defineInternalMetric_+3A_fun">fun</code></td>
<td>
<p>The function to compute the metric, accepting a lcModel object as input.</p>
</td></tr>
<tr><td><code id="defineInternalMetric_+3A_warnifexists">warnIfExists</code></td>
<td>
<p>Whether to output a warning when the metric is already defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>defineInternalMetric("BIC", fun = BIC)

mae &lt;- function(object) {
  mean(abs(residuals(object)))
}
defineInternalMetric("MAE", fun = mae)
</code></pre>

<hr>
<h2 id='deviance.lcModel'>lcModel deviance</h2><span id='topic+deviance.lcModel'></span>

<h3>Description</h3>

<p>Get the deviance of the fitted <code>lcModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="deviance.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default implementation checks for the existence of the <code>deviance()</code> function for the internal model, and returns the output, if available.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> with the deviance value. If unavailable, <code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+deviance">stats::deviance</a> <a href="#topic+metric">metric</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='df.residual.lcModel'>Extract the residual degrees of freedom from a lcModel</h2><span id='topic+df.residual.lcModel'></span>

<h3>Description</h3>

<p>Extract the residual degrees of freedom from a lcModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.residual.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="df.residual.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> with the residual degrees of freedom. If unavailable, <code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+df.residual">stats::df.residual</a> <a href="stats.html#topic+nobs">nobs</a> <a href="stats.html#topic+residuals">residuals</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='estimationTime'>Estimation time</h2><span id='topic+estimationTime'></span><span id='topic+estimationTime+2ClcModel-method'></span><span id='topic+estimationTime+2ClcModels-method'></span><span id='topic+estimationTime+2Clist-method'></span>

<h3>Description</h3>

<p>Get the elapsed time for estimating the given model.
</p>
<p>For <code>lcModel</code>: Get the estimation time of the model, determined by the time taken for the associated <code><a href="#topic+fit">fit()</a></code> function to finish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimationTime(object, unit = "secs", ...)

## S4 method for signature 'lcModel'
estimationTime(object, unit = "secs", ...)

## S4 method for signature 'lcModels'
estimationTime(object, unit = "secs", ...)

## S4 method for signature 'list'
estimationTime(object, unit = "secs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimationTime_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="estimationTime_+3A_unit">unit</code></td>
<td>
<p>The time unit in which the estimation time should be outputted.
By default, estimation time is in seconds.
For accepted units, see <a href="base.html#topic+difftime">base::difftime</a>.</p>
</td></tr>
<tr><td><code id="estimationTime_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A non-negative <code style="white-space: pre;">&#8288;scalar numeric&#8288;</code> representing the estimation time in the specified unit..
</p>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

estimationTime(model)
estimationTime(model, unit = 'mins')
estimationTime(model, unit = 'days')
</code></pre>

<hr>
<h2 id='evaluate.lcMethod'>Substitute the call arguments for their evaluated values</h2><span id='topic+evaluate.lcMethod'></span>

<h3>Description</h3>

<p>Substitutes the call arguments if they can be evaluated without error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
evaluate(
  object,
  classes = "ANY",
  try = TRUE,
  exclude = character(),
  envir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.lcMethod_+3A_object">object</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="evaluate.lcMethod_+3A_classes">classes</code></td>
<td>
<p>Substitute only arguments with specific class types. By default, all types are substituted.</p>
</td></tr>
<tr><td><code id="evaluate.lcMethod_+3A_try">try</code></td>
<td>
<p>Whether to try to evaluate arguments and ignore errors (the default), or to fail on any argument evaluation error.</p>
</td></tr>
<tr><td><code id="evaluate.lcMethod_+3A_exclude">exclude</code></td>
<td>
<p>Arguments to exclude from evaluation.</p>
</td></tr>
<tr><td><code id="evaluate.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
<tr><td><code id="evaluate.lcMethod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>lcMethod</code> object with the substituted arguments.
</p>


<h3>See Also</h3>

<p><a href="#topic+compose">compose</a>
</p>
<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>

<hr>
<h2 id='externalMetric'>Compute external model metric(s)</h2><span id='topic+externalMetric'></span><span id='topic+externalMetric+2ClcModel+2ClcModel-method'></span><span id='topic+externalMetric+2ClcModels+2Cmissing-method'></span><span id='topic+externalMetric+2ClcModels+2Ccharacter-method'></span><span id='topic+externalMetric+2ClcModels+2ClcModel-method'></span><span id='topic+externalMetric+2ClcModels+2ClcModels-method'></span><span id='topic+externalMetric+2Clist+2ClcModel-method'></span>

<h3>Description</h3>

<p>Compute one or more external metrics for two or more objects.
</p>
<p>Note that there are many external metrics available, and there exists no external metric that works best in all scenarios.
It is recommended to carefully consider which metric is most appropriate for your use case.
</p>
<p>Many of the external metrics depend on implementations in other packages:
</p>

<ul>
<li><p> clusterCrit  (Desgraupes 2018)
</p>
</li>
<li><p> mclustcomp  (You 2018)
</p>
</li>
<li><p> igraph  (Csardi and Nepusz 2006)
</p>
</li>
<li><p> psych  (Revelle 2019)
</p>
</li></ul>

<p>See <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> for a grouped overview of similarity metrics.
</p>
<p>Call <code><a href="#topic+getInternalMetricNames">getInternalMetricNames()</a></code> to retrieve the names of the defined internal metrics.
Call <code><a href="#topic+getExternalMetricNames">getExternalMetricNames()</a></code> to retrieve the names of the defined internal metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcModel,lcModel'
externalMetric(
  object,
  object2,
  name = getOption("latrend.externalMetric"),
  ...
)

## S4 method for signature 'lcModels,missing'
externalMetric(object, object2, name = "adjustedRand")

## S4 method for signature 'lcModels,character'
externalMetric(object, object2 = "adjustedRand")

## S4 method for signature 'lcModels,lcModel'
externalMetric(object, object2, name, drop = TRUE)

## S4 method for signature 'list,lcModel'
externalMetric(object, object2, name, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="externalMetric_+3A_object">object</code></td>
<td>
<p>The object to compare to the second object</p>
</td></tr>
<tr><td><code id="externalMetric_+3A_object2">object2</code></td>
<td>
<p>The second object</p>
</td></tr>
<tr><td><code id="externalMetric_+3A_name">name</code></td>
<td>
<p>The name(s) of the external metric(s) to compute. If no names are given, the names specified in the <code>latrend.externalMetric</code> option (none by default) are used.</p>
</td></tr>
<tr><td><code id="externalMetric_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="externalMetric_+3A_drop">drop</code></td>
<td>
<p>Whether to return a <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> instead of a <code>data.frame</code>
in case of a single metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>externalMetric(lcModel, lcModel)</code>: A <code>numeric</code> vector of the computed metrics.
</p>
<p>For <code>externalMetric(lcModels)</code>: A distance matrix of class <a href="stats.html#topic+dist">dist</a> representing
the pairwise comparisons.
</p>
<p>For <code>externalMetric(lcModels, name)</code>: A distance matrix of class <a href="stats.html#topic+dist">dist</a> representing
the pairwise comparisons.
</p>
<p>For <code>externalMetric(lcModels, lcModel)</code>: A named <code>numeric</code> vector or <code>data.frame</code>
containing the computed model metrics.
</p>
<p>For <code>externalMetric(list, lcModel)</code>: A named <code>numeric</code> vector or <code>data.frame</code>
containing the computed model metrics.
</p>


<h3>Supported external metrics</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Metric name</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Function / Reference</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>adjustedRand</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Rand_index">Adjusted Rand index</a>. Based on the Rand index, but adjusted for agreements occurring by chance. A score of 1 indicates a perfect agreement, whereas a score of 0 indicates an agreement no better than chance. </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code>, (Hubert and Arabie 1985) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CohensKappa</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen's kappa</a>. A partitioning agreement metric correcting for random chance. A score of 1 indicates a perfect agreement, whereas a score of 0 indicates an agreement no better than chance. </td><td style="text-align: left;"> <code><a href="psych.html#topic+kappa">psych::cohen.kappa()</a></code>, (Cohen 1960) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>F</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/F-score">F-score</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>F1</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/F-score">F1-score</a>, also referred to as the <a href="https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient">Sørensen–Dice Coefficient</a>, or Dice similarity coefficient </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>FolkesMallows</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Fowlkes%E2%80%93Mallows_index">Fowlkes-Mallows index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Hubert</code> </td><td style="text-align: left;"> Hubert index </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Jaccard</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>jointEntropy</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Joint_entropy">Joint entropy</a> between model assignments </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Kulczynski</code> </td><td style="text-align: left;"> Kulczynski index </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MaximumMatch</code> </td><td style="text-align: left;"> Maximum match measure </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>McNemar</code> </td><td style="text-align: left;"> McNemar statistic </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MeilaHeckerman</code> </td><td style="text-align: left;"> Meila-Heckerman measure </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Mirkin</code> </td><td style="text-align: left;"> Mirkin metric </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MI</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mutual_information">Mutual information</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NMI</code> </td><td style="text-align: left;"> Normalized mutual information </td><td style="text-align: left;"> <code><a href="igraph.html#topic+compare">igraph::compare()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NSJ</code> </td><td style="text-align: left;"> Normalized version of <code>splitJoin</code>. The proportion of edits relative to the maximum changes (twice the number of ids) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NVI</code> </td><td style="text-align: left;"> Normalized variation of information </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Overlap</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Overlap_coefficient">Overlap coefficient</a>, also referred to as the Szymkiewicz–Simpson coefficient </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> (M K and K 2016) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>PD</code> </td><td style="text-align: left;"> Partition difference </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Phi</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Phi_coefficient">Phi coefficient</a>. </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>precision</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Precision_and_recall">precision</a> </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Rand</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Rand_index">Rand index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>recall</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Precision_and_recall">recall</a> </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RogersTanimoto</code> </td><td style="text-align: left;"> Rogers-Tanimoto dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RusselRao</code> </td><td style="text-align: left;"> Russell-Rao dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SMC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Simple_matching_coefficient">Simple matching coefficient</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>splitJoin</code> </td><td style="text-align: left;"> total split-join index </td><td style="text-align: left;"> <code><a href="igraph.html#topic+split_join_distance">igraph::split_join_distance()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>splitJoin.ref</code> </td><td style="text-align: left;"> Split-join index of the first model to the second model. In other words, it is the edit-distance between the two partitionings. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SokalSneath1</code> </td><td style="text-align: left;"> Type-1 Sokal-Sneath dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SokalSneath2</code> </td><td style="text-align: left;"> Type-2 Sokal-Sneath dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>VI</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Variation_of_information">Variation of information</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Wallace1</code> </td><td style="text-align: left;"> Type-1 Wallace criterion </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Wallace2</code> </td><td style="text-align: left;"> Type-2 Wallace criterion </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMSSE</code> </td><td style="text-align: left;"> Weighted minimum sum of squared errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMMSE</code> </td><td style="text-align: left;"> Weighted minimum mean of squared errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMMAE</code> </td><td style="text-align: left;"> Weighted minimum mean of absolute errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Implementation</h3>

<p>See the documentation of the <code><a href="#topic+defineExternalMetric">defineExternalMetric()</a></code> function for details on how to define your own external metrics.
</p>


<h3>References</h3>

<p>Cohen J (1960).
&ldquo;A Coefficient of Agreement for Nominal Scales.&rdquo;
<em>Educational and Psychological Measurement</em>, <b>20</b>(1), 37-46.<br /><br /> Csardi G, Nepusz T (2006).
&ldquo;The igraph software package for complex network research.&rdquo;
<em>InterJournal</em>, <b>Complex Systems</b>, 1695.
<a href="https://igraph.org">https://igraph.org</a>.<br /><br /> Desgraupes B (2018).
<em>clusterCrit: Clustering Indices</em>.
R package version 1.2.8, <a href="https://CRAN.R-project.org/package=clusterCrit">https://CRAN.R-project.org/package=clusterCrit</a>.<br /><br /> Hubert L, Arabie P (1985).
&ldquo;Comparing Partitions.&rdquo;
<em>Journal of Classification</em>, <b>2</b>(1), 193&ndash;218.
ISSN 1432-1343, <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.<br /><br /> M K V, K K (2016).
&ldquo;A Survey on Similarity Measures in Text Mining.&rdquo;
<em>Machine Learning and Applications: An International Journal</em>, <b>3</b>, 19-28.
<a href="https://doi.org/10.5121/mlaij.2016.3103">doi:10.5121/mlaij.2016.3103</a>.<br /><br /> Revelle W (2019).
<em>psych: Procedures for Psychological, Psychometric, and Personality Research</em>.
Northwestern University, Evanston, Illinois.
R package version 1.9.12, <a href="https://CRAN.R-project.org/package=psych">https://CRAN.R-project.org/package=psych</a>.<br /><br /> You K (2018).
<em>mclustcomp: Measures for Comparing Clusters</em>.
R package version 0.3.1, <a href="https://CRAN.R-project.org/package=mclustcomp">https://CRAN.R-project.org/package=mclustcomp</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+metric">metric</a>
</p>
<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model2 &lt;- latrend(method, latrendData, nClusters = 2)
model3 &lt;- latrend(method, latrendData, nClusters = 3)

if (require("mclustcomp")) {
  externalMetric(model2, model3, "adjustedRand")
}
</code></pre>

<hr>
<h2 id='fit'><code>lcMethod</code> estimation step: logic for fitting the method to the processed data</h2><span id='topic+fit'></span><span id='topic+fit+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>fit()</code> function of the <code>lcMethod</code> object estimates the model with the evaluated method specification, processed training data, and prepared environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethod'
fit(method, data, envir, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="fit_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="fit_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted object, inheriting from <code>lcModel</code>.
</p>


<h3>Implementation</h3>

<p>This method should be implemented for all <code>lcMethod</code> subclasses.
</p>
<pre>
setMethod("fit", "lcMethodExample", function(method, data, envir, verbose) {
  # estimate the model or cluster parameters
  coefs &lt;- FIT_CODE

  # create the lcModel object
  new("lcModelExample",
    method = method,
    data = data,
    model = coefs,
    clusterNames = make.clusterNames(method$nClusters)
  )
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>

<hr>
<h2 id='fitted.lcModel'>Extract lcModel fitted values</h2><span id='topic+fitted.lcModel'></span>

<h3>Description</h3>

<p>Returns the cluster-specific fitted values for the given <code>lcModel</code> object.
The default implementation calls <code><a href="stats.html#topic+predict">predict()</a></code> with <code>newdata = NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
fitted(object, ..., clusters = trajectoryAssignments(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="fitted.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="fitted.lcModel_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of the fitted values for the respective class, or a <code>matrix</code> of fitted values for each cluster.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> can override this method to adapt the computation of the predicted values for the training data.
Note that the implementation of this function is only needed when <code><a href="stats.html#topic+predict">predict()</a></code> and <code><a href="#topic+predictForCluster">predictForCluster()</a></code> are not defined for the <code>lcModel</code> subclass.
</p>
<pre>
fitted.lcModelExt &lt;- function(object, ..., clusters = trajectoryAssignments(object)) {
  pred = predict(object, newdata = NULL)
  transformFitted(pred = pred, model = object, clusters = clusters)
}
</pre>
<p>The <code><a href="#topic+transformFitted">transformFitted()</a></code> function takes care of transforming the prediction input to the right output format.
</p>


<h3>See Also</h3>

<p><a href="#topic+fittedTrajectories">fittedTrajectories</a> <a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a> <a href="stats.html#topic+fitted.values">stats::fitted</a> <a href="#topic+predict.lcModel">predict.lcModel</a> <a href="#topic+trajectoryAssignments">trajectoryAssignments</a> <a href="#topic+transformFitted">transformFitted</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
fitted(model)
</code></pre>

<hr>
<h2 id='fittedTrajectories'>Extract the fitted trajectories</h2><span id='topic+fittedTrajectories'></span><span id='topic+fittedTrajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Extract the fitted trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fittedTrajectories(object, ...)

## S4 method for signature 'lcModel'
fittedTrajectories(
  object,
  at = time(object),
  what = "mu",
  clusters = trajectoryAssignments(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fittedTrajectories_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="fittedTrajectories_+3A_...">...</code></td>
<td>
<p>For <code>lcModel</code>: Additional arguments passed to <a href="#topic+fitted.lcModel">fitted.lcModel</a>.</p>
</td></tr>
<tr><td><code id="fittedTrajectories_+3A_at">at</code></td>
<td>
<p>The time points at which to compute the id-specific trajectories.
The default implementation merely filters the output, i.e., fitted values can only be outputted for times at which the model was trained.</p>
</td></tr>
<tr><td><code id="fittedTrajectories_+3A_what">what</code></td>
<td>
<p>The distributional parameter to compute the response for.</p>
</td></tr>
<tr><td><code id="fittedTrajectories_+3A_clusters">clusters</code></td>
<td>
<p>The cluster assignments for the strata to base the trajectories on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>lcModel</code> implementation uses the output of <code>fitted()</code> of the respective model.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> representing the fitted response per trajectory per moment in time for the respective cluster.
</p>
<p>For <code>lcModel</code>: A <code>data.frame</code> with columns id, time, response, and &quot;Cluster&quot;.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
# Note: not a great example because the fitted trajectories
# are identical to the respective cluster trajectory
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
fittedTrajectories(model)

fittedTrajectories(model, at = time(model)[c(1, 2)])
</code></pre>

<hr>
<h2 id='formula.lcMethod'>Extract formula</h2><span id='topic+formula.lcMethod'></span>

<h3>Description</h3>

<p>Extracts the associated <code>formula</code> for the given distributional parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
formula(x, what = "mu", envir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.lcMethod_+3A_x">x</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="formula.lcMethod_+3A_what">what</code></td>
<td>
<p>The distributional parameter to which this formula applies. By default, the formula specifies <code>"mu"</code>.</p>
</td></tr>
<tr><td><code id="formula.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
<tr><td><code id="formula.lcMethod_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>formula</code> for the given distributional parameter.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
formula(method) # Y ~ Time
</code></pre>

<hr>
<h2 id='formula.lcModel'>Extract the formula of a lcModel</h2><span id='topic+formula.lcModel'></span>

<h3>Description</h3>

<p>Get the formula associated with the fitted <code>lcModel</code> object.
This is determined by the <code>formula</code> argument of the <code>lcMethod</code> specification that was used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
formula(x, what = "mu", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.lcModel_+3A_x">x</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="formula.lcModel_+3A_what">what</code></td>
<td>
<p>The distributional parameter.</p>
</td></tr>
<tr><td><code id="formula.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the associated <code>formula</code>, or <code>response ~ 0</code> if not specified.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+formula">stats::formula</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)
formula(model) # Y ~ Time
</code></pre>

<hr>
<h2 id='generateLongData'>Generate longitudinal test data</h2><span id='topic+generateLongData'></span>

<h3>Description</h3>

<p>Generate longitudinal test data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateLongData(
  sizes = c(40, 60),
  fixed = Value ~ 1,
  cluster = ~1 + Time,
  random = ~1,
  id = getOption("latrend.id"),
  data = data.frame(Time = seq(0, 1, by = 0.1)),
  fixedCoefs = 0,
  clusterCoefs = cbind(c(-2, 1), c(2, -1)),
  randomScales = cbind(0.1, 0.1),
  rrandom = rnorm,
  noiseScales = c(0.1, 0.1),
  rnoise = rnorm,
  clusterNames = LETTERS[seq_along(sizes)],
  shuffle = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateLongData_+3A_sizes">sizes</code></td>
<td>
<p>Number of strata per cluster.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_fixed">fixed</code></td>
<td>
<p>Fixed effects formula.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_cluster">cluster</code></td>
<td>
<p>Cluster effects formula.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_random">random</code></td>
<td>
<p>Random effects formula.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_id">id</code></td>
<td>
<p>Name of the strata.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_data">data</code></td>
<td>
<p>Data with covariates to use for generation. Stratified data may be specified by
adding a grouping column.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_fixedcoefs">fixedCoefs</code></td>
<td>
<p>Coefficients matrix for the fixed effects.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_clustercoefs">clusterCoefs</code></td>
<td>
<p>Coefficients matrix for the cluster effects.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_randomscales">randomScales</code></td>
<td>
<p>Standard deviations matrix for the size of the variance components (random effects).</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_rrandom">rrandom</code></td>
<td>
<p>Random sampler for generating the variance components at location 0.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_noisescales">noiseScales</code></td>
<td>
<p>Scale of the random noise passed to rnoise. Either scalar or defined per cluster.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_rnoise">rnoise</code></td>
<td>
<p>Random sampler for generating noise at location 0 with the respective scale.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_clusternames">clusterNames</code></td>
<td>
<p>A <code>character</code> vector denoting the names of the generated clusters.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to randomly reorder the strata in which they appear in the data.frame.</p>
</td></tr>
<tr><td><code id="generateLongData_+3A_seed">seed</code></td>
<td>
<p>Optional seed to set for the PRNG. The set PRNG state persists after the function completes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+latrend-data">latrend-data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>longdata &lt;- generateLongData(
  sizes = c(40, 70), id = "Id",
  cluster = ~poly(Time, 2, raw = TRUE),
  clusterCoefs = cbind(c(1, 2, 5), c(-3, 4, .2))
)

if (require("ggplot2")) {
  plotTrajectories(longdata, response = "Value", id = "Id", time = "Time")
}
</code></pre>

<hr>
<h2 id='getArgumentDefaults'>Default argument values for the given method specification</h2><span id='topic+getArgumentDefaults'></span><span id='topic+getArgumentDefaults+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Returns the default arguments associated with the respective <code>lcMethod</code> subclass.
These arguments are automatically included into the <code>lcMethod</code> object during initialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArgumentDefaults(object, ...)

## S4 method for signature 'lcMethod'
getArgumentDefaults(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArgumentDefaults_+3A_object">object</code></td>
<td>
<p>The method specification object.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;named list&#8288;</code> of argument values.
</p>


<h3>Implementation</h3>

<p>Although implementing this method is optional, it prevents users from
having to specify all arguments every time they want to create a method specification.
</p>
<p>In this example, most of the default arguments are defined as arguments of the function
<code>lcMethodExample</code>, which we can include in the list by calling <a href="base.html#topic+formals">formals</a>. Copying the arguments from functions
is especially useful when your method implementation is based on an existing function.
</p>
<pre>
setMethod("getArgumentDefaults", "lcMethodExample", function(object) {
  list(
    formals(lcMethodExample),
    formals(funFEM::funFEM),
    extra = Value ~ 1,
    tol = 1e-4,
    callNextMethod()
  )
})
</pre>
<p>It is recommended to add <code>callNextMethod()</code> to the end of the list.
This enables inheriting the default arguments from superclasses.
</p>


<h3>See Also</h3>

<p><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>
</p>
<p><a href="#topic+lcMethod">lcMethod</a>
</p>
<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>

<hr>
<h2 id='getArgumentDefaults+2ClcMethodLcmmGMM-method'>lcmm interface</h2><span id='topic+getArgumentDefaults+2ClcMethodLcmmGMM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodLcmmGMM-method'></span><span id='topic+getCitation+2ClcMethodLcmmGMM-method'></span><span id='topic+getName+2ClcMethodLcmmGMM-method'></span><span id='topic+getShortName+2ClcMethodLcmmGMM-method'></span><span id='topic+validate+2ClcMethodLcmmGMM-method'></span><span id='topic+preFit+2ClcMethodLcmmGMM-method'></span><span id='topic+fit+2ClcMethodLcmmGMM-method'></span><span id='topic+responseVariable+2ClcMethodLcmmGMM-method'></span><span id='topic+interface-lcmm'></span><span id='topic+getArgumentDefaults+2ClcMethodLcmmGBTM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodLcmmGBTM-method'></span><span id='topic+getCitation+2ClcMethodLcmmGBTM-method'></span><span id='topic+getName+2ClcMethodLcmmGBTM-method'></span><span id='topic+getShortName+2ClcMethodLcmmGBTM-method'></span><span id='topic+preFit+2ClcMethodLcmmGBTM-method'></span><span id='topic+fit+2ClcMethodLcmmGBTM-method'></span><span id='topic+responseVariable+2ClcMethodLcmmGBTM-method'></span><span id='topic+fitted.lcModelLcmmGMM'></span><span id='topic+predictForCluster+2ClcModelLcmmGMM-method'></span><span id='topic+model.matrix.lcModelLcmmGMM'></span><span id='topic+logLik.lcModelLcmmGMM'></span><span id='topic+sigma.lcModelLcmmGMM'></span><span id='topic+nobs.lcModelLcmmGMM'></span><span id='topic+postprob+2ClcModelLcmmGMM-method'></span><span id='topic+converged+2ClcModelLcmmGMM-method'></span>

<h3>Description</h3>

<p>lcmm interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodLcmmGMM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodLcmmGMM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodLcmmGMM'
getCitation(object, ...)

## S4 method for signature 'lcMethodLcmmGMM'
getName(object)

## S4 method for signature 'lcMethodLcmmGMM'
getShortName(object)

## S4 method for signature 'lcMethodLcmmGMM'
validate(method, data, envir = NULL, ...)

## S4 method for signature 'lcMethodLcmmGMM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLcmmGMM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLcmmGMM'
responseVariable(object, ...)

## S4 method for signature 'lcMethodLcmmGBTM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodLcmmGBTM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodLcmmGBTM'
getCitation(object, ...)

## S4 method for signature 'lcMethodLcmmGBTM'
getName(object)

## S4 method for signature 'lcMethodLcmmGBTM'
getShortName(object)

## S4 method for signature 'lcMethodLcmmGBTM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLcmmGBTM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLcmmGBTM'
responseVariable(object, ...)

## S3 method for class 'lcModelLcmmGMM'
fitted(object, ..., clusters = trajectoryAssignments(object))

## S4 method for signature 'lcModelLcmmGMM'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S3 method for class 'lcModelLcmmGMM'
model.matrix(object, ..., what = "mu")

## S3 method for class 'lcModelLcmmGMM'
logLik(object, ...)

## S3 method for class 'lcModelLcmmGMM'
sigma(object, ...)

## S3 method for class 'lcModelLcmmGMM'
nobs(object, ...)

## S4 method for signature 'lcModelLcmmGMM'
postprob(object, ...)

## S4 method for signature 'lcModelLcmmGMM'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="getArgumentDefaults+2B2ClcMethodLcmmGMM-method_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a> <a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a> <a href="lcmm.html#topic+lcmm-package">lcmm-package</a>
</p>

<hr>
<h2 id='getArgumentExclusions'>Arguments to be excluded from the specification</h2><span id='topic+getArgumentExclusions'></span><span id='topic+getArgumentExclusions+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Returns the names of arguments that should be excluded during instantiation of the specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArgumentExclusions(object, ...)

## S4 method for signature 'lcMethod'
getArgumentExclusions(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArgumentExclusions_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="getArgumentExclusions_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> of argument names.
</p>


<h3>Implementation</h3>

<p>This function only needs to be implemented if you want to avoid users from specifying
redundant arguments or arguments that are set automatically or conditionally on other arguments.
</p>
<pre>
setMethod("getArgumentExclusions", "lcMethodExample", function(object) {
  c(
    "doPlot",
    "verbose",
    callNextMethod()
  )
})

Adding `callNextMethod()` to the end of the return vector enables inheriting exclusions from superclasses.
</pre>


<h3>See Also</h3>

<p><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>
</p>
<p><a href="#topic+lcMethod">lcMethod</a> <a href="#topic+getArgumentExclusions">getArgumentExclusions</a>
</p>
<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>

<hr>
<h2 id='getCall.lcModel'>Get the model call</h2><span id='topic+getCall.lcModel'></span>

<h3>Description</h3>

<p>Extract the <code>call</code> that was used to fit the given <code>lcModel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
getCall(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCall.lcModel_+3A_x">x</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="getCall.lcModel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>call</code> to <code><a href="#topic+latrend">latrend()</a></code> with the necessary arguments and data.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+update">stats::getCall</a> <a href="#topic+getLcMethod">getLcMethod</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
getCall(model)
</code></pre>

<hr>
<h2 id='getCitation'>Get citation info</h2><span id='topic+getCitation'></span><span id='topic+getCitation+2ClcMethod-method'></span><span id='topic+getCitation+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get a citation object indicating how to cite the underlying R packages used for estimating or representing the given method or model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCitation(object, ...)

## S4 method for signature 'lcMethod'
getCitation(object, ...)

## S4 method for signature 'lcModel'
getCitation(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCitation_+3A_object">object</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="getCitation_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="utils.html#topic+citation">utils::citation</a> object.
</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+citation">utils::citation</a>
</p>

<hr>
<h2 id='getExternalMetricDefinition'>Get the external metric definition</h2><span id='topic+getExternalMetricDefinition'></span>

<h3>Description</h3>

<p>Get the external metric definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExternalMetricDefinition(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExternalMetricDefinition_+3A_name">name</code></td>
<td>
<p>The name of the metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The metric function, or NULL if not defined.
</p>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>

<hr>
<h2 id='getExternalMetricNames'>Get the names of the available external metrics</h2><span id='topic+getExternalMetricNames'></span>

<h3>Description</h3>

<p>Get the names of the available external metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExternalMetricNames()
</code></pre>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>

<hr>
<h2 id='getInternalMetricDefinition'>Get the internal metric definition</h2><span id='topic+getInternalMetricDefinition'></span>

<h3>Description</h3>

<p>Get the internal metric definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInternalMetricDefinition(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInternalMetricDefinition_+3A_name">name</code></td>
<td>
<p>The name of the metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The metric function, or NULL if not defined.
</p>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>

<hr>
<h2 id='getInternalMetricNames'>Get the names of the available internal metrics</h2><span id='topic+getInternalMetricNames'></span>

<h3>Description</h3>

<p>Get the names of the available internal metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInternalMetricNames()
</code></pre>


<h3>See Also</h3>

<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>
</p>

<hr>
<h2 id='getLabel'>Object label</h2><span id='topic+getLabel'></span><span id='topic+getLabel+2ClcMethod-method'></span><span id='topic+getLabel+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the object label, if any.
</p>
<p>Extracts the assigned label from the given <code>lcMethod</code> or <code>lcModel</code> object.
By default, the label is determined from the <code>"label"</code> argument of the <code>lcMethod</code> object.
The label of an <code>lcModel</code> object is set upon estimation by <code><a href="#topic+latrend">latrend()</a></code> to the label of its associated <code>lcMethod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLabel(object, ...)

## S4 method for signature 'lcMethod'
getLabel(object, ...)

## S4 method for signature 'lcModel'
getLabel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLabel_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="getLabel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;scalar character&#8288;</code>. The empty string is returned if there is no label.
</p>


<h3>See Also</h3>

<p><a href="#topic+getName">getName</a>
</p>
<p><a href="#topic+getName">getName</a> <a href="#topic+getShortName">getShortName</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, time = "Time")
getLabel(method) # ""

getLabel(update(method, label = "v2")) # "v2"
</code></pre>

<hr>
<h2 id='getLcMethod'>Get the method specification</h2><span id='topic+getLcMethod'></span><span id='topic+getLcMethod+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the <code>lcMethod</code> specification that was used for fitting the given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLcMethod(object, ...)

## S4 method for signature 'lcModel'
getLcMethod(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLcMethod_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="getLcMethod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>lcMethod</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+getCall.lcModel">getCall.lcModel</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
getLcMethod(model)
</code></pre>

<hr>
<h2 id='getName'>Object name</h2><span id='topic+getName'></span><span id='topic+getShortName'></span><span id='topic+getName+2ClcMethod-method'></span><span id='topic+getName+2CNULL-method'></span><span id='topic+getShortName+2ClcMethod-method'></span><span id='topic+getShortName+2CNULL-method'></span><span id='topic+getName+2ClcModel-method'></span><span id='topic+getShortName+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the name associated with the given object.
</p>
<p><code>getShortName()</code>: Extracts the short object name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getName(object, ...)

getShortName(object, ...)

## S4 method for signature 'lcMethod'
getName(object, ...)

## S4 method for signature 'NULL'
getName(object, ...)

## S4 method for signature 'lcMethod'
getShortName(object, ...)

## S4 method for signature 'NULL'
getShortName(object, ...)

## S4 method for signature 'lcModel'
getName(object)

## S4 method for signature 'lcModel'
getShortName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getName_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="getName_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>lcModel</code>: The name is determined by its associated <code>lcMethod</code> name and label, unless specified otherwise.
</p>


<h3>Value</h3>

<p>A nonempty string, as <code>character</code>.
</p>


<h3>Implementation</h3>

<p>When implementing your own <code>lcMethod</code> subclass, override these methods to provide full and abbreviated names.
</p>
<pre>
setMethod("getName", "lcMethodExample", function(object) "example name")

setMethod("getShortName", "lcMethodExample", function(object) "EX")
</pre>
<p>Similar methods can be implemented for your <code>lcModel</code> subclass,
however in practice this is not needed as the names are determined by default from the <code>lcMethod</code> object that was used to fit the <code>lcModel</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+getShortName">getShortName</a> <a href="#topic+getLabel">getLabel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time)
getName(method) # "lm-kmeans"
method &lt;- lcMethodLMKM(Y ~ Time)
getShortName(method) # "LMKM"
</code></pre>

<hr>
<h2 id='ids'>Get the trajectory ids on which the model was fitted</h2><span id='topic+ids'></span>

<h3>Description</h3>

<p>Get the trajectory ids on which the model was fitted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ids_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order returned by <code>ids(object)</code> determines the id order for any output involving id-specific values, such as in <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code> or <code><a href="#topic+postprob">postprob()</a></code>.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> or <code style="white-space: pre;">&#8288;integer vector&#8288;</code> of the identifier for every fitted trajectory.
</p>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
ids(model) # 1, 2, ..., 200
</code></pre>

<hr>
<h2 id='idVariable'>Extract the trajectory identifier variable</h2><span id='topic+idVariable'></span><span id='topic+idVariable+2ClcMethod-method'></span><span id='topic+idVariable+2ClcModel-method'></span>

<h3>Description</h3>

<p>Extracts the trajectory identifier variable (i.e., column name) from the given <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idVariable(object, ...)

## S4 method for signature 'lcMethod'
idVariable(object, ...)

## S4 method for signature 'lcModel'
idVariable(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idVariable_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="idVariable_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nonempty string, as <code>character</code>.
</p>


<h3>See Also</h3>

<p>Other variables: 
<code><a href="#topic+responseVariable">responseVariable</a>()</code>,
<code><a href="#topic+timeVariable">timeVariable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Traj")
idVariable(method) # "Traj"

method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
idVariable(model) # "Id"
</code></pre>

<hr>
<h2 id='initialize+2ClcMethod-method'>lcMethod initialization</h2><span id='topic+initialize+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Initialization of <code>lcMethod</code> objects, converting arbitrary arguments to arguments as part of an <code>lcMethod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethod'
initialize(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2ClcMethod-method_+3A_.object">.Object</code></td>
<td>
<p>The newly allocated <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="initialize+2B2ClcMethod-method_+3A_...">...</code></td>
<td>
<p>Other method arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>new("lcMethodLMKM", formula = Y ~ Time, id = "Id", time = "Time")
</code></pre>

<hr>
<h2 id='interface-akmedoids'>akmedoids interface</h2><span id='topic+interface-akmedoids'></span><span id='topic+getArgumentDefaults+2ClcMethodAkmedoids-method'></span><span id='topic+getArgumentExclusions+2ClcMethodAkmedoids-method'></span><span id='topic+getCitation+2ClcMethodAkmedoids-method'></span><span id='topic+getName+2ClcMethodAkmedoids-method'></span><span id='topic+getShortName+2ClcMethodAkmedoids-method'></span><span id='topic+fit+2ClcMethodAkmedoids-method'></span>

<h3>Description</h3>

<p>akmedoids interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodAkmedoids'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodAkmedoids'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodAkmedoids'
getCitation(object, ...)

## S4 method for signature 'lcMethodAkmedoids'
getName(object)

## S4 method for signature 'lcMethodAkmedoids'
getShortName(object)

## S4 method for signature 'lcMethodAkmedoids'
fit(method, data, envir, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-akmedoids_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-akmedoids_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-akmedoids_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-akmedoids_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-akmedoids_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a> <code>akmedoids::akclustr</code>
</p>

<hr>
<h2 id='interface-crimCV'>crimCV interface</h2><span id='topic+interface-crimCV'></span><span id='topic+getArgumentDefaults+2ClcMethodCrimCV-method'></span><span id='topic+getArgumentExclusions+2ClcMethodCrimCV-method'></span><span id='topic+getCitation+2ClcMethodCrimCV-method'></span><span id='topic+getName+2ClcMethodCrimCV-method'></span><span id='topic+getShortName+2ClcMethodCrimCV-method'></span><span id='topic+prepareData+2ClcMethodCrimCV-method'></span><span id='topic+fit+2ClcMethodCrimCV-method'></span><span id='topic+predictForCluster+2ClcModelCrimCV-method'></span><span id='topic+postprob+2ClcModelCrimCV-method'></span><span id='topic+logLik.lcModelCrimCV'></span><span id='topic+coef.lcModelCrimCV'></span><span id='topic+converged+2ClcModelCrimCV-method'></span>

<h3>Description</h3>

<p>crimCV interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodCrimCV'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodCrimCV'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodCrimCV'
getCitation(object, ...)

## S4 method for signature 'lcMethodCrimCV'
getName(object)

## S4 method for signature 'lcMethodCrimCV'
getShortName(object)

## S4 method for signature 'lcMethodCrimCV'
prepareData(method, data, verbose, ...)

## S4 method for signature 'lcMethodCrimCV'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelCrimCV'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S4 method for signature 'lcModelCrimCV'
postprob(object)

## S3 method for class 'lcModelCrimCV'
logLik(object, ...)

## S3 method for class 'lcModelCrimCV'
coef(object, ...)

## S4 method for signature 'lcModelCrimCV'
converged(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-crimCV_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-crimCV_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a> <a href="crimCV.html#topic+crimCV">crimCV</a>
</p>

<hr>
<h2 id='interface-dtwclust'>dtwclust interface</h2><span id='topic+interface-dtwclust'></span><span id='topic+getArgumentDefaults+2ClcMethodDtwclust-method'></span><span id='topic+getArgumentExclusions+2ClcMethodDtwclust-method'></span><span id='topic+getCitation+2ClcMethodDtwclust-method'></span><span id='topic+getName+2ClcMethodDtwclust-method'></span><span id='topic+getShortName+2ClcMethodDtwclust-method'></span><span id='topic+preFit+2ClcMethodDtwclust-method'></span><span id='topic+fit+2ClcMethodDtwclust-method'></span><span id='topic+converged+2ClcModelDtwclust-method'></span><span id='topic+postprob+2ClcModelDtwclust-method'></span><span id='topic+predictForCluster+2ClcModelDtwclust-method'></span>

<h3>Description</h3>

<p>dtwclust interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodDtwclust'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodDtwclust'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodDtwclust'
getCitation(object, ...)

## S4 method for signature 'lcMethodDtwclust'
getName(object)

## S4 method for signature 'lcMethodDtwclust'
getShortName(object)

## S4 method for signature 'lcMethodDtwclust'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodDtwclust'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelDtwclust'
converged(object, ...)

## S4 method for signature 'lcModelDtwclust'
postprob(object, ...)

## S4 method for signature 'lcModelDtwclust'
predictForCluster(object, newdata, cluster, what = "mu", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-dtwclust_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-dtwclust_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a> <a href="dtwclust.html#topic+dtwclust-package">dtwclust-package</a>
</p>

<hr>
<h2 id='interface-featureBased'>featureBased interface</h2><span id='topic+interface-featureBased'></span><span id='topic+getArgumentDefaults+2ClcMethodFeature-method'></span><span id='topic+getName+2ClcMethodFeature-method'></span><span id='topic+getShortName+2ClcMethodFeature-method'></span><span id='topic+prepareData+2ClcMethodFeature-method'></span><span id='topic+fit+2ClcMethodFeature-method'></span><span id='topic+getArgumentDefaults+2ClcMethodLMKM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodLMKM-method'></span><span id='topic+getName+2ClcMethodLMKM-method'></span><span id='topic+getShortName+2ClcMethodLMKM-method'></span><span id='topic+prepareData+2ClcMethodLMKM-method'></span><span id='topic+fit+2ClcMethodLMKM-method'></span><span id='topic+validate+2ClcMethodLMKM-method'></span><span id='topic+getArgumentDefaults+2ClcMethodGCKM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodGCKM-method'></span><span id='topic+getName+2ClcMethodGCKM-method'></span><span id='topic+getShortName+2ClcMethodGCKM-method'></span><span id='topic+prepareData+2ClcMethodGCKM-method'></span><span id='topic+getArgumentDefaults+2ClcMethodStratify-method'></span><span id='topic+getName+2ClcMethodStratify-method'></span><span id='topic+getShortName+2ClcMethodStratify-method'></span><span id='topic+compose+2ClcMethodStratify-method'></span><span id='topic+fit+2ClcMethodStratify-method'></span><span id='topic+coef.lcModelLMKM'></span><span id='topic+logLik.lcModelLMKM'></span><span id='topic+converged+2ClcModelLMKM-method'></span><span id='topic+postprob+2ClcModelLMKM-method'></span>

<h3>Description</h3>

<p>featureBased interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodFeature'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodFeature'
getName(object)

## S4 method for signature 'lcMethodFeature'
getShortName(object)

## S4 method for signature 'lcMethodFeature'
prepareData(method, data, verbose, ...)

## S4 method for signature 'lcMethodFeature'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLMKM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodLMKM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodLMKM'
getName(object)

## S4 method for signature 'lcMethodLMKM'
getShortName(object)

## S4 method for signature 'lcMethodLMKM'
prepareData(method, data, verbose)

## S4 method for signature 'lcMethodLMKM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodLMKM'
validate(method, data, envir = NULL, ...)

## S4 method for signature 'lcMethodGCKM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodGCKM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodGCKM'
getName(object)

## S4 method for signature 'lcMethodGCKM'
getShortName(object)

## S4 method for signature 'lcMethodGCKM'
prepareData(method, data, verbose)

## S4 method for signature 'lcMethodStratify'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodStratify'
getName(object)

## S4 method for signature 'lcMethodStratify'
getShortName(object)

## S4 method for signature 'lcMethodStratify'
compose(method, envir = NULL, ...)

## S4 method for signature 'lcMethodStratify'
fit(method, data, envir, verbose, ...)

## S3 method for class 'lcModelLMKM'
coef(object, ..., cluster = NULL)

## S3 method for class 'lcModelLMKM'
logLik(object, ...)

## S4 method for signature 'lcModelLMKM'
converged(object, ...)

## S4 method for signature 'lcModelLMKM'
postprob(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-featureBased_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-featureBased_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodFeature">lcMethodFeature</a> <a href="#topic+lcMethodGCKM">lcMethodGCKM</a> <a href="#topic+lcMethodLMKM">lcMethodLMKM</a>
</p>

<hr>
<h2 id='interface-flexmix'>flexmix interface</h2><span id='topic+interface-flexmix'></span><span id='topic+getArgumentDefaults+2ClcMethodFlexmix-method'></span><span id='topic+getArgumentExclusions+2ClcMethodFlexmix-method'></span><span id='topic+getCitation+2ClcMethodFlexmix-method'></span><span id='topic+getName+2ClcMethodFlexmix-method'></span><span id='topic+getShortName+2ClcMethodFlexmix-method'></span><span id='topic+preFit+2ClcMethodFlexmix-method'></span><span id='topic+fit+2ClcMethodFlexmix-method'></span><span id='topic+getArgumentDefaults+2ClcMethodFlexmixGBTM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodFlexmixGBTM-method'></span><span id='topic+getName+2ClcMethodFlexmixGBTM-method'></span><span id='topic+getShortName+2ClcMethodFlexmixGBTM-method'></span><span id='topic+preFit+2ClcMethodFlexmixGBTM-method'></span><span id='topic+fitted.lcModelFlexmix'></span><span id='topic+predictForCluster+2ClcModelFlexmix-method'></span><span id='topic+postprob+2ClcModelFlexmix-method'></span><span id='topic+logLik.lcModelFlexmix'></span><span id='topic+coef.lcModelFlexmix'></span><span id='topic+converged+2ClcModelFlexmix-method'></span>

<h3>Description</h3>

<p>flexmix interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodFlexmix'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodFlexmix'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodFlexmix'
getCitation(object, ...)

## S4 method for signature 'lcMethodFlexmix'
getName(object)

## S4 method for signature 'lcMethodFlexmix'
getShortName(object)

## S4 method for signature 'lcMethodFlexmix'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodFlexmix'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodFlexmixGBTM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodFlexmixGBTM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodFlexmixGBTM'
getName(object)

## S4 method for signature 'lcMethodFlexmixGBTM'
getShortName(object)

## S4 method for signature 'lcMethodFlexmixGBTM'
preFit(method, data, envir, verbose)

## S3 method for class 'lcModelFlexmix'
fitted(object, ..., clusters = trajectoryAssignments(object))

## S4 method for signature 'lcModelFlexmix'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S4 method for signature 'lcModelFlexmix'
postprob(object, ...)

## S3 method for class 'lcModelFlexmix'
logLik(object, ...)

## S3 method for class 'lcModelFlexmix'
coef(object, ...)

## S4 method for signature 'lcModelFlexmix'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-flexmix_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-flexmix_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodFlexmix">lcMethodFlexmix</a> <a href="flexmix.html#topic+flexmix">flexmix</a>
</p>

<hr>
<h2 id='interface-funFEM'>funFEM interface</h2><span id='topic+interface-funFEM'></span><span id='topic+getArgumentDefaults+2ClcMethodFunFEM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodFunFEM-method'></span><span id='topic+getCitation+2ClcMethodFunFEM-method'></span><span id='topic+getName+2ClcMethodFunFEM-method'></span><span id='topic+getShortName+2ClcMethodFunFEM-method'></span><span id='topic+preFit+2ClcMethodFunFEM-method'></span><span id='topic+fit+2ClcMethodFunFEM-method'></span><span id='topic+fitted.lcModelFunFEM'></span><span id='topic+predictForCluster+2ClcModelFunFEM-method'></span><span id='topic+postprob+2ClcModelFunFEM-method'></span><span id='topic+coef.lcModelFunFEM'></span><span id='topic+logLik.lcModelFunFEM'></span><span id='topic+converged+2ClcModelFunFEM-method'></span>

<h3>Description</h3>

<p>funFEM interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodFunFEM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodFunFEM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodFunFEM'
getCitation(object, ...)

## S4 method for signature 'lcMethodFunFEM'
getName(object)

## S4 method for signature 'lcMethodFunFEM'
getShortName(object)

## S4 method for signature 'lcMethodFunFEM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodFunFEM'
fit(method, data, envir, verbose, ...)

## S3 method for class 'lcModelFunFEM'
fitted(object, ..., clusters = trajectoryAssignments(object))

## S4 method for signature 'lcModelFunFEM'
predictForCluster(
  object,
  newdata,
  cluster,
  what = "mu",
  approxFun = approx,
  ...
)

## S4 method for signature 'lcModelFunFEM'
postprob(object, ...)

## S3 method for class 'lcModelFunFEM'
coef(object, ...)

## S3 method for class 'lcModelFunFEM'
logLik(object, ...)

## S4 method for signature 'lcModelFunFEM'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-funFEM_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="interface-funFEM_+3A_approxfun">approxFun</code></td>
<td>
<p>Function to interpolate between measurement moments, <a href="stats.html#topic+approx">approx</a>() by default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a> <a href="funFEM.html#topic+funFEM-package">funFEM-package</a>
</p>

<hr>
<h2 id='interface-kml'>kml interface</h2><span id='topic+interface-kml'></span><span id='topic+getArgumentDefaults+2ClcMethodKML-method'></span><span id='topic+getArgumentExclusions+2ClcMethodKML-method'></span><span id='topic+getCitation+2ClcMethodKML-method'></span><span id='topic+getName+2ClcMethodKML-method'></span><span id='topic+getShortName+2ClcMethodKML-method'></span><span id='topic+preFit+2ClcMethodKML-method'></span><span id='topic+fit+2ClcMethodKML-method'></span><span id='topic+lcModelKML-class'></span><span id='topic+clusterTrajectories+2ClcModelKML-method'></span><span id='topic+converged+2ClcModelKML-method'></span><span id='topic+logLik.lcModelKML'></span><span id='topic+postprob+2ClcModelKML-method'></span><span id='topic+predictPostprob+2ClcModelKML-method'></span>

<h3>Description</h3>

<p>kml interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodKML'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodKML'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodKML'
getCitation(object, ...)

## S4 method for signature 'lcMethodKML'
getName(object)

## S4 method for signature 'lcMethodKML'
getShortName(object)

## S4 method for signature 'lcMethodKML'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodKML'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelKML'
clusterTrajectories(object, at = time(object), ...)

## S4 method for signature 'lcModelKML'
converged(object)

## S3 method for class 'lcModelKML'
logLik(object, ...)

## S4 method for signature 'lcModelKML'
postprob(object)

## S4 method for signature 'lcModelKML'
predictPostprob(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-kml_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing additional data variables returned by <code><a href="#topic+prepareData">prepareData()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_at">at</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the times at which to compute the cluster trajectories.</p>
</td></tr>
<tr><td><code id="interface-kml_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> for which to compute the posterior probability. If omitted, the model training data is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodKML">lcMethodKML</a> <a href="kml.html#topic+kml">kml</a>
</p>

<hr>
<h2 id='interface-mclust'>mclust interface</h2><span id='topic+interface-mclust'></span><span id='topic+getArgumentDefaults+2ClcMethodMclustLLPA-method'></span><span id='topic+getArgumentExclusions+2ClcMethodMclustLLPA-method'></span><span id='topic+getCitation+2ClcMethodMclustLLPA-method'></span><span id='topic+getName+2ClcMethodMclustLLPA-method'></span><span id='topic+getShortName+2ClcMethodMclustLLPA-method'></span><span id='topic+prepareData+2ClcMethodMclustLLPA-method'></span><span id='topic+compose+2ClcMethodMclustLLPA-method'></span><span id='topic+fit+2ClcMethodMclustLLPA-method'></span><span id='topic+clusterTrajectories+2ClcModelMclustLLPA-method'></span><span id='topic+postprob+2ClcModelMclustLLPA-method'></span><span id='topic+predictPostprob+2ClcModelMclustLLPA-method'></span><span id='topic+converged+2ClcModelMclustLLPA-method'></span>

<h3>Description</h3>

<p>mclust interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodMclustLLPA'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodMclustLLPA'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodMclustLLPA'
getCitation(object, ...)

## S4 method for signature 'lcMethodMclustLLPA'
getName(object)

## S4 method for signature 'lcMethodMclustLLPA'
getShortName(object)

## S4 method for signature 'lcMethodMclustLLPA'
prepareData(method, data, verbose, ...)

## S4 method for signature 'lcMethodMclustLLPA'
compose(method, envir = NULL)

## S4 method for signature 'lcMethodMclustLLPA'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelMclustLLPA'
clusterTrajectories(object, at = time(object), ...)

## S4 method for signature 'lcModelMclustLLPA'
postprob(object, ...)

## S4 method for signature 'lcModelMclustLLPA'
predictPostprob(object, newdata = NULL, ...)

## S4 method for signature 'lcModelMclustLLPA'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-mclust_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_at">at</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the times at which to compute the cluster trajectories.</p>
</td></tr>
<tr><td><code id="interface-mclust_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a> <a href="mclust.html#topic+mclust-package">mclust-package</a>
</p>

<hr>
<h2 id='interface-metaMethods'>lcMetaMethod abstract class</h2><span id='topic+interface-metaMethods'></span><span id='topic+lcMetaMethod-class'></span><span id='topic+compose+2ClcMetaMethod-method'></span><span id='topic+getLcMethod+2ClcMetaMethod-method'></span><span id='topic+getName+2ClcMetaMethod-method'></span><span id='topic+getShortName+2ClcMetaMethod-method'></span><span id='topic+idVariable+2ClcMetaMethod-method'></span><span id='topic+preFit+2ClcMetaMethod-method'></span><span id='topic+prepareData+2ClcMetaMethod-method'></span><span id='topic+fit+2ClcMetaMethod-method'></span><span id='topic+postFit+2ClcMetaMethod-method'></span><span id='topic+responseVariable+2ClcMetaMethod-method'></span><span id='topic+timeVariable+2ClcMetaMethod-method'></span><span id='topic+validate+2ClcMetaMethod-method'></span><span id='topic+update.lcMetaMethod'></span><span id='topic+fit+2ClcFitConverged-method'></span><span id='topic+validate+2ClcFitConverged-method'></span><span id='topic+fit+2ClcFitRep-method'></span><span id='topic+validate+2ClcFitRep-method'></span>

<h3>Description</h3>

<p>Virtual class for internal use. Do not use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMetaMethod'
compose(method, envir = NULL)

## S4 method for signature 'lcMetaMethod'
getLcMethod(object, ...)

## S4 method for signature 'lcMetaMethod'
getName(object, ...)

## S4 method for signature 'lcMetaMethod'
getShortName(object, ...)

## S4 method for signature 'lcMetaMethod'
idVariable(object, ...)

## S4 method for signature 'lcMetaMethod'
preFit(method, data, envir, verbose)

## S4 method for signature 'lcMetaMethod'
prepareData(method, data, verbose)

## S4 method for signature 'lcMetaMethod'
fit(method, data, envir, verbose)

## S4 method for signature 'lcMetaMethod'
postFit(method, data, model, envir, verbose)

## S4 method for signature 'lcMetaMethod'
responseVariable(object, ...)

## S4 method for signature 'lcMetaMethod'
timeVariable(object, ...)

## S4 method for signature 'lcMetaMethod'
validate(method, data, envir = NULL, ...)

## S3 method for class 'lcMetaMethod'
update(object, ...)

## S4 method for signature 'lcFitConverged'
fit(method, data, envir, verbose)

## S4 method for signature 'lcFitConverged'
validate(method, data, envir = NULL, ...)

## S4 method for signature 'lcFitRep'
fit(method, data, envir, verbose)

## S4 method for signature 'lcFitRep'
validate(method, data, envir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-metaMethods_+3A_method">method</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which the <code>lcMethod</code> should be evaluated</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-metaMethods_+3A_model">model</code></td>
<td>
<p>The <code>lcModel</code> object returned by <code><a href="#topic+fit">fit()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='interface-mixAK'>mixAK interface</h2><span id='topic+interface-mixAK'></span><span id='topic+getArgumentDefaults+2ClcMethodMixAK_GLMM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodMixAK_GLMM-method'></span><span id='topic+getCitation+2ClcMethodMixAK_GLMM-method'></span><span id='topic+getName+2ClcMethodMixAK_GLMM-method'></span><span id='topic+getShortName+2ClcMethodMixAK_GLMM-method'></span><span id='topic+responseVariable+2ClcMethodMixAK_GLMM-method'></span><span id='topic+preFit+2ClcMethodMixAK_GLMM-method'></span><span id='topic+fit+2ClcMethodMixAK_GLMM-method'></span><span id='topic+postprob+2ClcModelMixAK_GLMM-method'></span><span id='topic+predictForCluster+2ClcModelMixAK_GLMM-method'></span><span id='topic+coef.lcModelMixAK_GLMM'></span><span id='topic+deviance.lcModelMixAK_GLMM'></span><span id='topic+postprob+2ClcModelMixAK_GLMMlist-method'></span><span id='topic+predictForCluster+2ClcModelMixAK_GLMMlist-method'></span>

<h3>Description</h3>

<p>mixAK interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodMixAK_GLMM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodMixAK_GLMM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodMixAK_GLMM'
getCitation(object, ...)

## S4 method for signature 'lcMethodMixAK_GLMM'
getName(object)

## S4 method for signature 'lcMethodMixAK_GLMM'
getShortName(object)

## S4 method for signature 'lcMethodMixAK_GLMM'
responseVariable(object)

## S4 method for signature 'lcMethodMixAK_GLMM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodMixAK_GLMM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelMixAK_GLMM'
postprob(object, ...)

## S4 method for signature 'lcModelMixAK_GLMM'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S4 method for signature 'lcModelMixAK_GLMM'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S3 method for class 'lcModelMixAK_GLMM'
coef(object, ..., stat = "Mean")

## S3 method for class 'lcModelMixAK_GLMM'
deviance(object, ...)

## S4 method for signature 'lcModelMixAK_GLMMlist'
postprob(object, ...)

## S4 method for signature 'lcModelMixAK_GLMMlist'
predictForCluster(object, newdata, cluster, what = "mu", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-mixAK_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="interface-mixAK_+3A_stat">stat</code></td>
<td>
<p>The aggregate statistic to extract. The mean is used by default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a> <a href="mixAK.html#topic+GLMMMCMC">mixAK::GLMM_MCMC</a>
</p>

<hr>
<h2 id='interface-mixtools'>mixtools interface</h2><span id='topic+interface-mixtools'></span><span id='topic+getArgumentDefaults+2ClcMethodMixtoolsGMM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodMixtoolsGMM-method'></span><span id='topic+getCitation+2ClcMethodMixtoolsGMM-method'></span><span id='topic+getName+2ClcMethodMixtoolsGMM-method'></span><span id='topic+getShortName+2ClcMethodMixtoolsGMM-method'></span><span id='topic+preFit+2ClcMethodMixtoolsGMM-method'></span><span id='topic+fit+2ClcMethodMixtoolsGMM-method'></span><span id='topic+getArgumentDefaults+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+getCitation+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+getName+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+getShortName+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+fit+2ClcMethodMixtoolsNPRM-method'></span><span id='topic+predictForCluster+2ClcModelMixtoolsGMM-method'></span><span id='topic+postprob+2ClcModelMixtoolsGMM-method'></span><span id='topic+logLik.lcModelMixtoolsGMM'></span><span id='topic+coef.lcModelMixtoolsGMM'></span><span id='topic+sigma.lcModelMixtoolsGMM'></span><span id='topic+clusterTrajectories+2ClcModelMixtoolsRM-method'></span><span id='topic+postprob+2ClcModelMixtoolsRM-method'></span><span id='topic+logLik.lcModelMixtoolsRM'></span><span id='topic+converged+2ClcModelMixtoolsRM-method'></span>

<h3>Description</h3>

<p>mixtools interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodMixtoolsGMM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodMixtoolsGMM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodMixtoolsGMM'
getCitation(object, ...)

## S4 method for signature 'lcMethodMixtoolsGMM'
getName(object)

## S4 method for signature 'lcMethodMixtoolsGMM'
getShortName(object)

## S4 method for signature 'lcMethodMixtoolsGMM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodMixtoolsGMM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodMixtoolsNPRM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodMixtoolsNPRM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodMixtoolsNPRM'
getCitation(object, ...)

## S4 method for signature 'lcMethodMixtoolsNPRM'
getName(object)

## S4 method for signature 'lcMethodMixtoolsNPRM'
getShortName(object)

## S4 method for signature 'lcMethodMixtoolsNPRM'
fit(method, data, envir, verbose, ...)

## S4 method for signature 'lcModelMixtoolsGMM'
predictForCluster(object, newdata, cluster, what = "mu", ...)

## S4 method for signature 'lcModelMixtoolsGMM'
postprob(object, ...)

## S3 method for class 'lcModelMixtoolsGMM'
logLik(object, ...)

## S3 method for class 'lcModelMixtoolsGMM'
coef(object, ...)

## S3 method for class 'lcModelMixtoolsGMM'
sigma(object, ...)

## S4 method for signature 'lcModelMixtoolsRM'
clusterTrajectories(
  object,
  at = time(object),
  what = "mu",
  se = TRUE,
  ci = c(0.025, 0.975),
  ...
)

## S4 method for signature 'lcModelMixtoolsRM'
postprob(object, ...)

## S3 method for class 'lcModelMixtoolsRM'
logLik(object, ...)

## S4 method for signature 'lcModelMixtoolsRM'
converged(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-mixtools_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_at">at</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the times at which to compute the cluster trajectories.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_se">se</code></td>
<td>
<p>Whether to compute the standard error of the prediction.</p>
</td></tr>
<tr><td><code id="interface-mixtools_+3A_ci">ci</code></td>
<td>
<p>The confidence interval to compute.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a> <a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a> <a href="mixtools.html#topic+regmixEM.mixed">regmixEM.mixed</a> <a href="mixtools.html#topic+npEM">npEM</a>
</p>

<hr>
<h2 id='interface-mixtvem'>mixtvem interface</h2><span id='topic+interface-mixtvem'></span><span id='topic+getArgumentDefaults+2ClcMethodMixTVEM-method'></span><span id='topic+getArgumentExclusions+2ClcMethodMixTVEM-method'></span><span id='topic+getCitation+2ClcMethodMixTVEM-method'></span><span id='topic+getName+2ClcMethodMixTVEM-method'></span><span id='topic+getShortName+2ClcMethodMixTVEM-method'></span><span id='topic+preFit+2ClcMethodMixTVEM-method'></span><span id='topic+fit+2ClcMethodMixTVEM-method'></span><span id='topic+predict.lcModelMixTVEM'></span><span id='topic+postprob+2ClcModelMixTVEM-method'></span><span id='topic+converged+2ClcModelMixTVEM-method'></span><span id='topic+logLik.lcModelMixTVEM'></span><span id='topic+sigma.lcModelMixTVEM'></span><span id='topic+coef.lcModelMixTVEM'></span>

<h3>Description</h3>

<p>mixtvem interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethodMixTVEM'
getArgumentDefaults(object)

## S4 method for signature 'lcMethodMixTVEM'
getArgumentExclusions(object)

## S4 method for signature 'lcMethodMixTVEM'
getCitation(object, ...)

## S4 method for signature 'lcMethodMixTVEM'
getName(object)

## S4 method for signature 'lcMethodMixTVEM'
getShortName(object)

## S4 method for signature 'lcMethodMixTVEM'
preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethodMixTVEM'
fit(method, data, envir, verbose, ...)

## S3 method for class 'lcModelMixTVEM'
predict(object, ..., newdata = NULL, what = "mu")

## S4 method for signature 'lcModelMixTVEM'
postprob(object, ...)

## S4 method for signature 'lcModelMixTVEM'
converged(object, ...)

## S3 method for class 'lcModelMixTVEM'
logLik(object, ...)

## S3 method for class 'lcModelMixTVEM'
sigma(object, ...)

## S3 method for class 'lcModelMixTVEM'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interface-mixtvem_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> for which to compute the model predictions. If omitted, the model training data is used.
Cluster trajectory predictions are made when ids are not specified.</p>
</td></tr>
<tr><td><code id="interface-mixtvem_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lcMethodMixTVEM">lcMethodMixTVEM</a>
</p>

<hr>
<h2 id='isArgDefined'>Check whether the argument of a lcMethod has a defined value.</h2><span id='topic+isArgDefined'></span>

<h3>Description</h3>

<p>Determines whether the associated argument value is defined. If the argument value is of type <code>language</code>, the argument is evaluated to see if it can be resolved within its <code>environment</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isArgDefined(object, name, envir = environment(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isArgDefined_+3A_object">object</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="isArgDefined_+3A_name">name</code></td>
<td>
<p>The name of the argument, as <code>character</code>.</p>
</td></tr>
<tr><td><code id="isArgDefined_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> to evaluate the arguments in. If <code>NULL</code>, the argument is not evaluated.</p>
</td></tr>
</table>

<hr>
<h2 id='latrend'>Cluster longitudinal data using the specified method</h2><span id='topic+latrend'></span>

<h3>Description</h3>

<p><a href="#topic+latrend-package">An overview of the latrend package and its capabilities can be found here</a>.
</p>
<p>The <code>latrend()</code> function fits a specified longitudinal cluster <a href="#topic+lcMethod">method</a> to the given data comprising the trajectories.
</p>
<p>This function runs all steps of the standardized <a href="#topic+lcMethod-estimation">method estimation procedure</a>, as implemented by the given <code>lcMethod</code> object.
The result of this procedure is the estimated <a href="#topic+lcModel">lcModel</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrend(
  method,
  data,
  ...,
  envir = NULL,
  verbose = getOption("latrend.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrend_+3A_method">method</code></td>
<td>
<p>An <a href="#topic+lcMethod">lcMethod</a> object specifying the longitudinal cluster method to apply, or the name (as <code>character</code>) of the <code>lcMethod</code> subclass to instantiate.</p>
</td></tr>
<tr><td><code id="latrend_+3A_data">data</code></td>
<td>
<p>The data of the trajectories to which to estimate the method for.
Any inputs supported by <code><a href="#topic+trajectories">trajectories()</a></code> can be used, including <code>data.frame</code> and <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="latrend_+3A_...">...</code></td>
<td>
<p>Any other arguments to update the <code>lcMethod</code> definition with.</p>
</td></tr>
<tr><td><code id="latrend_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the method arguments via <code><a href="#topic+compose">compose()</a></code>.
If the <code>data</code> argument is of type <code>call</code> then this environment is also used to evaluate the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="latrend_+3A_verbose">verbose</code></td>
<td>
<p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a seed value is specified in the <code>lcMethod</code> object or arguments to <code>latrend</code>, this seed is set using <code>set.seed</code> prior to the <a href="#topic+preFit">preFit</a> step.
</p>


<h3>Value</h3>

<p>A <a href="#topic+lcModel">lcModel</a> object representing the fitted solution.
</p>


<h3>See Also</h3>

<p>Other longitudinal cluster fit functions: 
<code><a href="#topic+latrendBatch">latrendBatch</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+latrendRep">latrendRep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)

model &lt;- latrend("lcMethodLMKM", formula = Y ~ Time, id = "Id", time = "Time", data = latrendData)

model &lt;- latrend(method, data = latrendData, nClusters = 3, seed = 1)
</code></pre>

<hr>
<h2 id='latrend-approaches'>High-level approaches to longitudinal clustering</h2><span id='topic+latrend-approaches'></span>

<h3>Description</h3>

<p>This page provides high-level guidelines on which methods are applicable to your dataset.
Note that this is intended as a quick-start.
</p>
<p>Recommended overview and comparison papers:
</p>

<ul>
<li> <p>(Den Teuling et al. 2021): A tutorial and overview on methods for longitudinal clustering.
</p>
</li>
<li> <p>Den Teuling et al. (2021) compared KmL, MixTVEM, GBTM, GMM, and GCKM.
</p>
</li>
<li> <p>Twisk and Hoekstra (2012) compared KmL, GCKM, LLCA, GBTM and GMM.
</p>
</li>
<li> <p>Verboon and Pat-El (2022) compared the <em>kml</em>, <em>traj</em> and <em>lcmm</em> packages in R.
</p>
</li>
<li> <p>Martin and von Oertzen (2015) compared KmL, LCA, and GMM.
</p>
</li></ul>



<h3>Approaches</h3>

<p>Disclaimer: The table below has been adapted from a pre-print of (Den Teuling et al. 2021).</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Approach</strong> </td><td style="text-align: left;"> <strong>Strengths</strong> </td><td style="text-align: left;"> <strong>Limitations</strong> </td><td style="text-align: left;"> <strong>Methods</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Cross-sectional clustering</strong> </td><td style="text-align: left;"> Suitable for large datasets — Many available algorithms — Non-parametric cluster trajectory representation </td><td style="text-align: left;"> Requires time-aligned complete data — Sensitive to measurement noise </td><td style="text-align: left;"> <a href="#topic+lcMethodKML">lcMethodKML</a> <a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a> <a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Distance-based clustering</strong> </td><td style="text-align: left;"> Suitable for medium-sized datasets — Many distance metrics — Distance matrix only needs to be computed once </td><td style="text-align: left;"> Scales poorly with number of trajectories — No robust cluster trajectory representation — Some distance metrics require aligned observations </td><td style="text-align: left;"> <a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Feature-based clustering</strong> </td><td style="text-align: left;"> Suitable for large datasets — Configurable — Features only needs to be computed once — Compact trajectory representation </td><td style="text-align: left;"> Generally requires intensive longitudinal data — Sensitive to outliers </td><td style="text-align: left;"> <a href="#topic+lcMethodFeature">lcMethodFeature</a> <a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a> <a href="#topic+lcMethodLMKM">lcMethodLMKM</a> <a href="#topic+lcMethodGCKM">lcMethodGCKM</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>Model-based clustering</strong> </td><td style="text-align: left;"> Parametric cluster trajectory — Incorporate (domain) assumptions — Low sample size requirements </td><td style="text-align: left;"> Computationally intensive — Scales poorly with number of clusters — Convergence challenges </td><td style="text-align: left;"> <a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a> <a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a> <a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a> <a href="#topic+lcMethodFlexmix">lcMethodFlexmix</a> <a href="#topic+lcMethodFlexmixGBTM">lcMethodFlexmixGBTM</a> <a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a> <a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a> <a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a> <a href="#topic+lcMethodMixTVEM">lcMethodMixTVEM</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>It is strongly encouraged to <a href="#topic+latrend-metrics">evaluate and compare</a> several candidate methods in order to identify the most suitable method.
</p>


<h3>References</h3>

<p>Den Teuling N, Pauws S, Heuvel Evd (2021).
&ldquo;Clustering of longitudinal data: A tutorial on a variety of approaches.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2111.05469">doi:10.48550/ARXIV.2111.05469</a>, <a href="https://arxiv.org/abs/2111.05469">https://arxiv.org/abs/2111.05469</a>.<br /><br /> Den Teuling NGP, Pauws SC, van den Heuvel ER (2021).
&ldquo;A comparison of methods for clustering longitudinal data with slowly changing trends.&rdquo;
<em>Communications in Statistics - Simulation and Computation</em>.
<a href="https://doi.org/10.1080/03610918.2020.1861464">doi:10.1080/03610918.2020.1861464</a>.<br /><br /> Martin DP, von Oertzen T (2015).
&ldquo;Growth mixture models outperform simpler clustering algorithms when detecting longitudinal heterogeneity, even with small sample sizes.&rdquo;
<em>Struct. Equ. Model.</em>, <b>22</b>(2), 264&ndash;275.
ISSN 1070-5511, <a href="https://doi.org/10.1080/10705511.2014.936340">doi:10.1080/10705511.2014.936340</a>.<br /><br /> Twisk J, Hoekstra T (2012).
&ldquo;Classifying developmental trajectories over time should be done with great caution: A comparison between methods.&rdquo;
<em>Journal of Clinical Epidemiology</em>, <b>65</b>(10), 1078&ndash;1087.
ISSN 0895-4356, <a href="https://doi.org/10.1016/j.jclinepi.2012.04.010">doi:10.1016/j.jclinepi.2012.04.010</a>.<br /><br /> Verboon P, Pat-El R (2022).
&ldquo;Clustering Longitudinal Data Using R: A Monte Carlo Study.&rdquo;
<em>Methodology</em>, <b>18</b>(2), 144-163.
<a href="https://doi.org/10.5964/meth.7143">doi:10.5964/meth.7143</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-methods">latrend-methods</a> <a href="#topic+latrend-estimation">latrend-estimation</a> <a href="#topic+latrend-metrics">latrend-metrics</a>
</p>

<hr>
<h2 id='latrend-assert'>latrend-specific assertions</h2><span id='topic+latrend-assert'></span><span id='topic+has_lcMethod_args'></span><span id='topic+is_valid_postprob'></span><span id='topic+no_empty_trajectories'></span><span id='topic+is_data'></span><span id='topic+no_trajectories_duplicate_time'></span><span id='topic+are_trajectories_length'></span><span id='topic+are_trajectories_equal_length'></span><span id='topic+have_trajectories_noNA'></span><span id='topic+no_trajectories_allNA'></span>

<h3>Description</h3>

<p>Assertions and checks that may be of use for custom model implementations.
</p>
<p>Check whether the input is a valid posterior probability matrix (for the given model).
</p>
<p>Check whether the dataset does not contain trajectories without any observations.
Requires Id column to be factor.
</p>
<p>Check whether the provided <code>data.frame</code> represents a longitudinal dataset
</p>
<p>Check whether the dataset does not contain trajectories with duplicate observation moments.
</p>
<p>Check the number of observation moments for each trajectory
</p>
<p>Check whether all trajectories have the same number of observation moments, and are observed at the same moments in time.
</p>
<p>Check whether all trajectories don't contain any NA observations.
</p>
<p>Check whether there are no trajectories that are only comprised of NA observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_lcMethod_args(object, which)

is_valid_postprob(pp, model = NULL)

no_empty_trajectories(data, id, ids)

is_data(data, id, time, response)

no_trajectories_duplicate_time(data, id, time)

are_trajectories_length(data, min = 1, id, time)

are_trajectories_equal_length(data, id, time)

have_trajectories_noNA(data, id, response)

no_trajectories_allNA(data, id, response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrend-assert_+3A_object">object</code></td>
<td>
<p>The object to test.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_which">which</code></td>
<td>
<p>The argument names. Ellipsis (<code>...</code>) will be ignored.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_pp">pp</code></td>
<td>
<p>The posterior probability <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_model">model</code></td>
<td>
<p>The <code>lcModel</code> object. Optional.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_id">id</code></td>
<td>
<p>The id variable</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_ids">ids</code></td>
<td>
<p>Optional <code style="white-space: pre;">&#8288;character vector&#8288;</code> of trajectory identifiers that are expected to be present in the data.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_time">time</code></td>
<td>
<p>The time variable</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_response">response</code></td>
<td>
<p>The response column name. Optional.</p>
</td></tr>
<tr><td><code id="latrend-assert_+3A_min">min</code></td>
<td>
<p>The minimum required number.</p>
</td></tr>
</table>

<hr>
<h2 id='latrend-data'>Longitudinal dataset representation</h2><span id='topic+latrend-data'></span>

<h3>Description</h3>

<p>The <a href="#topic+latrend-estimation">latrend estimation functions</a> expect univariate
longitudinal data that can be represented in a <code>data.frame</code> with one row per trajectory observation:
</p>

<ul>
<li><p> Trajectory identifier: <code>numeric</code>, <code>character</code>, or <code>factor</code>
</p>
</li>
<li><p> Observation time: <code>numeric</code>
</p>
</li>
<li><p> Observation value: <code>numeric</code>
</p>
</li></ul>

<p>In principle, any type of longitudinal data structure is supported,
given that it can be transformed to the required <code>data.frame</code> format using the generic <a href="#topic+trajectories">trajectories</a> function.
Support can be added by implementing the <a href="#topic+trajectories">trajectories</a> function for the respective signature.
This means that users can implement their own data adapters as needed.
</p>


<h3>Included longitudinal datasets</h3>

<p>The following datasets are included with the package:
</p>

<ul>
<li> <p><a href="#topic+latrendData">latrendData</a>
</p>
</li>
<li> <p><a href="#topic+PAP.adh">PAP.adh</a>
</p>
</li>
<li> <p><a href="#topic+PAP.adh1y">PAP.adh1y</a>
</p>
</li></ul>


<hr>
<h2 id='latrend-estimation'>Overview of <strong><code>lcMethod</code></strong> estimation functions</h2><span id='topic+latrend-estimation'></span>

<h3>Description</h3>

<p>This page presents an overview of the different functions that are available for estimating one or more <a href="#topic+lcMethod">longitudinal cluster methods</a>.
All functions are prefixed by <em>&quot;latrend&quot;</em>.
</p>


<h3><em>latrend</em> estimation functions</h3>


<ul>
<li> <p><strong><code><a href="#topic+latrend">latrend()</a></code></strong>: estimate a <a href="#topic+lcMethod">method</a> on a <a href="#topic+latrend-data">longitudinal dataset</a>, returning the resulting <a href="#topic+lcModel">model</a>.
</p>
</li>
<li> <p><strong><code><a href="#topic+latrendBatch">latrendBatch()</a></code></strong>: estimate multiple <a href="#topic+lcMethod">methods</a> on multiple <a href="#topic+latrend-data">longitudinal datasets</a>, returning a <a href="#topic+lcModels-class">list of models</a>.
</p>
</li>
<li> <p><strong><code><a href="#topic+latrendRep">latrendRep()</a></code></strong>: repeatedly estimate a <a href="#topic+lcMethod">method</a> on a <a href="#topic+latrend-data">longitudinal dataset</a>, returning a <a href="#topic+lcModels-class">list of models</a>.
</p>
</li>
<li> <p><strong><code><a href="#topic+latrendBoot">latrendBoot()</a></code></strong>: repeatedly estimate a <a href="#topic+lcMethod">method</a> on bootstrapped <a href="#topic+latrend-data">longitudinal dataset</a>, returning a <a href="#topic+lcModels-class">list of models</a>.
</p>
</li>
<li> <p><strong><code><a href="#topic+latrendCV">latrendCV()</a></code></strong>: repeatedly estimate a <a href="#topic+lcMethod">method</a> using cross-validation on a <a href="#topic+latrend-data">longitudinal dataset</a>, returning a <a href="#topic+lcModels-class">list of models</a>.
</p>
</li></ul>



<h3>Parallel estimation</h3>

<p>The functions involving repeated estimation support parallel computation. <a href="#topic+latrend-parallel">See here.</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-package">latrend-package</a> <a href="#topic+lcMethod-estimation">lcMethod-estimation</a>
</p>

<hr>
<h2 id='latrend-generics'>Generics used by latrend for different classes</h2><span id='topic+latrend-generics'></span>

<h3>Description</h3>

<p>Generics used by latrend for different classes
</p>

<hr>
<h2 id='latrend-is'>Check if object is of Class</h2><span id='topic+latrend-is'></span><span id='topic+is.lcMethod'></span><span id='topic+is.lcModel'></span><span id='topic+is.lcModels'></span>

<h3>Description</h3>

<p>Check if object is of Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.lcMethod(x)

is.lcModel(x)

is.lcModels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrend-is_+3A_x">x</code></td>
<td>
<p>The object to check the class of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;scalar logical&#8288;</code>
</p>

<hr>
<h2 id='latrend-methods'>Supported methods for longitudinal clustering</h2><span id='topic+latrend-methods'></span>

<h3>Description</h3>

<p>This page provides an overview of the currently supported methods for longitudinal clustering.
For general recommendations on which method to apply to your dataset, <a href="#topic+latrend-approaches">see here</a>.
</p>


<h3>Supported methods</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Method</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Source</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a> </td><td style="text-align: left;"> Anchored <em>k</em>-medoids (Adepeju et al. 2020) </td><td style="text-align: left;"> <code>akmedoids</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a> </td><td style="text-align: left;"> Group-based trajectory modeling of count data (Nielsen 2018) </td><td style="text-align: left;"> <code>crimCV</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a> </td><td style="text-align: left;"> Methods for distance-based clustering, including dynamic time warping (Sardá-Espinosa 2019) </td><td style="text-align: left;"> <code>dtwclust</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodFeature">lcMethodFeature</a> </td><td style="text-align: left;"> Feature-based clustering </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodFlexmix">lcMethodFlexmix</a> </td><td style="text-align: left;"> Interface to the FlexMix framework (Grün and Leisch 2008) </td><td style="text-align: left;"> <code>flexmix</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodFlexmixGBTM">lcMethodFlexmixGBTM</a> </td><td style="text-align: left;"> Group-based trajectory modeling </td><td style="text-align: left;"> <code>flexmix</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a> </td><td style="text-align: left;"> Model-based clustering using funFEM (Bouveyron 2015) </td><td style="text-align: left;"> <code>funFEM</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodGCKM">lcMethodGCKM</a> </td><td style="text-align: left;"> Growth-curve modeling and <em>k</em>-means </td><td style="text-align: left;"> <code>lme4</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodKML">lcMethodKML</a> </td><td style="text-align: left;"> Longitudinal <em>k</em>-means (Genolini et al. 2015) </td><td style="text-align: left;"> <code>kml</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a> </td><td style="text-align: left;"> Group-based trajectory modeling (Proust-Lima et al. 2017) </td><td style="text-align: left;"> <code>lcmm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a> </td><td style="text-align: left;"> Growth mixture modeling (Proust-Lima et al. 2017) </td><td style="text-align: left;"> <code>lcmm</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodLMKM">lcMethodLMKM</a> </td><td style="text-align: left;"> Feature-based clustering using linear regression and <em>k</em>-means </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a> </td><td style="text-align: left;"> Longitudinal latent profile analysis (Scrucca et al. 2016) </td><td style="text-align: left;"> <code>mclust</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a> </td><td style="text-align: left;"> Mixture of generalized linear mixed models </td><td style="text-align: left;"> <code>mixAK</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a> </td><td style="text-align: left;"> Growth mixture modeling </td><td style="text-align: left;"> <code>mixtools</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a> </td><td style="text-align: left;"> Non-parametric repeated measures clustering (Benaglia et al. 2009) </td><td style="text-align: left;"> <code>mixtools</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodMixTVEM">lcMethodMixTVEM</a> </td><td style="text-align: left;"> Mixture of time-varying effects models </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodRandom">lcMethodRandom</a> </td><td style="text-align: left;"> Random partitioning </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <a href="#topic+lcMethodStratify">lcMethodStratify</a> </td><td style="text-align: left;"> Stratification rule </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In addition, the functionality of any method can be extended via <a href="#topic+lcMetaMethods">meta methods</a>.
This is used for extending the estimation procedure of a method, such as <a href="#topic+lcFitRep">repeated fitting</a> and selecting the best result, or <a href="#topic+lcFitConverged">fitting until convergence</a>.
</p>
<p>It is strongly encouraged to <a href="#topic+latrend-metrics">evaluate and compare</a> several candidate methods in order to identify the most suitable method.
</p>


<h3>References</h3>

<p>Adepeju M, Langton S, Bannister J (2020).
<em>akmedoids: Anchored Kmedoids for Longitudinal Data Clustering</em>.
R package version 0.1.5, <a href="https://CRAN.R-project.org/package=akmedoids">https://CRAN.R-project.org/package=akmedoids</a>.<br /><br /> Benaglia T, Chauveau D, Hunter DR, Young D (2009).
&ldquo;mixtools: An R Package for Analyzing Finite Mixture Models.&rdquo;
<em>Journal of Statistical Software</em>, <b>32</b>(6), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v032.i06">doi:10.18637/jss.v032.i06</a>.<br /><br /> Bouveyron C (2015).
<em>funFEM: Clustering in the Discriminative Functional Subspace</em>.
R package version 1.1, <a href="https://CRAN.R-project.org/package=funFEM">https://CRAN.R-project.org/package=funFEM</a>.<br /><br /> Genolini C, Alacoque X, Sentenac M, Arnaud C (2015).
&ldquo;kml and kml3d: R Packages to Cluster Longitudinal Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>65</b>(4), 1&ndash;34.
<a href="https://doi.org/10.18637/jss.v065.i04">doi:10.18637/jss.v065.i04</a>.<br /><br /> Grün B, Leisch F (2008).
&ldquo;FlexMix Version 2: Finite Mixtures with Concomitant Variables and Varying and Constant Parameters.&rdquo;
<em>Journal of Statistical Software</em>, <b>28</b>(4), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v028.i04">doi:10.18637/jss.v028.i04</a>.<br /><br /> Nielsen JD (2018).
<em>crimCV: Group-Based Modelling of Longitudinal Data</em>.
R package version 0.9.6, <a href="https://CRAN.R-project.org/package=crimCV">https://CRAN.R-project.org/package=crimCV</a>.<br /><br /> Proust-Lima C, Philipps V, Liquet B (2017).
&ldquo;Estimation of Extended Mixed Models Using Latent Classes and Latent Processes: The R Package lcmm.&rdquo;
<em>Journal of Statistical Software</em>, <b>78</b>(2), 1&ndash;56.
<a href="https://doi.org/10.18637/jss.v078.i02">doi:10.18637/jss.v078.i02</a>.<br /><br /> Sardá-Espinosa A (2019).
&ldquo;Time-Series Clustering in R Using the dtwclust Package.&rdquo;
<em>The R Journal</em>.
<a href="https://doi.org/10.32614/RJ-2019-023">doi:10.32614/RJ-2019-023</a>.<br /><br /> Scrucca L, Fop M, Murphy TB, Raftery AE (2016).
&ldquo;mclust 5: clustering, classification and density estimation using Gaussian finite mixture models.&rdquo;
<em>The R Journal</em>, <b>8</b>(1), 205&ndash;233.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-approaches">latrend-approaches</a> <a href="#topic+latrend-estimation">latrend-estimation</a> <a href="#topic+latrend-metrics">latrend-metrics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)
</code></pre>

<hr>
<h2 id='latrend-metrics'>Metrics</h2><span id='topic+latrend-metrics'></span>

<h3>Description</h3>

<p>The package supports a variety of metrics that help to evaluate and compare <a href="#topic+lcModel">estimated models</a>.
</p>

<ul>
<li> <p><a href="#topic+metric">Internal metrics</a>: metrics that assess the adequacy of the model with respect to the data.
</p>
</li>
<li> <p><a href="#topic+externalMetric">External metrics</a>: metrics that compare two models.
</p>
</li></ul>

<p>Users can implement new metrics through <code><a href="#topic+defineInternalMetric">defineInternalMetric()</a></code> and <code><a href="#topic+defineExternalMetric">defineExternalMetric()</a></code>.
Custom-defined metrics are accessible using the same by-name mechanism as the other metrics.
</p>


<h3>Supported internal metrics</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Metric name</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Function / Reference</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>AIC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">Akaike information criterion</a>. A goodness-of-fit estimator that adjusts for model complexity (i.e., the number of parameters). Only available for models that support the computation of the model log-likelihood through <a href="stats.html#topic+logLik">logLik</a>. </td><td style="text-align: left;"> <code><a href="stats.html#topic+AIC">stats::AIC()</a></code>, (Akaike 1974) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>APPA.mean</code> </td><td style="text-align: left;"> Mean of the average posterior probability of assignment (APPA) across clusters. A measure of the precision of the trajectory classifications. A score of 1 indicates perfect classification. </td><td style="text-align: left;"> <code><a href="#topic+APPA">APPA()</a></code>, (Nagin 2005) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>APPA.min</code> </td><td style="text-align: left;"> Lowest APPA among the clusters </td><td style="text-align: left;"> <code><a href="#topic+APPA">APPA()</a></code>, (Nagin 2005) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ASW</code> </td><td style="text-align: left;"> Average <a href="https://en.wikipedia.org/wiki/Silhouette_(clustering)">silhouette</a> width based on the Euclidean distance </td><td style="text-align: left;"> (Rousseeuw 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>BIC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian information criterion</a>. A goodness-of-fit estimator that corrects for the degrees of freedom (i.e., the number of parameters) and sample size. Only available for models that support the computation of the model log-likelihood through <a href="stats.html#topic+logLik">logLik</a>. </td><td style="text-align: left;"> <code><a href="stats.html#topic+AIC">stats::BIC()</a></code>, (Schwarz 1978) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CAIC</code> </td><td style="text-align: left;"> Consistent Akaike information criterion </td><td style="text-align: left;"> (Bozdogan 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CLC</code> </td><td style="text-align: left;"> Classification likelihood criterion </td><td style="text-align: left;"> (McLachlan and Peel 2000) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>converged</code> </td><td style="text-align: left;"> Whether the model converged during estimation </td><td style="text-align: left;"> <code><a href="#topic+converged">converged()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>deviance</code> </td><td style="text-align: left;"> The model <a href="https://en.wikipedia.org/wiki/Deviance_(statistics)">deviance</a> </td><td style="text-align: left;"> <code><a href="stats.html#topic+deviance">stats::deviance()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Dunn</code> </td><td style="text-align: left;"> The <a href="https://en.wikipedia.org/wiki/Dunn_index">Dunn index</a> </td><td style="text-align: left;"> (Dunn 1974) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>entropy</code> </td><td style="text-align: left;"> Entropy of the posterior probabilities </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>estimationTime</code> </td><td style="text-align: left;"> The time needed for fitting the model </td><td style="text-align: left;"> <code><a href="#topic+estimationTime">estimationTime()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ED</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ED.fit</code> </td><td style="text-align: left;"> Euclidean distance between the cluster trajectories and the assigned fitted trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ICL.BIC</code> </td><td style="text-align: left;"> Integrated classification likelihood (ICL) approximated using the BIC </td><td style="text-align: left;"> (Biernacki et al. 2000) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>logLik</code> </td><td style="text-align: left;"> Model log-<a href="https://en.wikipedia.org/wiki/Likelihood_function">likelihood</a> </td><td style="text-align: left;"> <code><a href="stats.html#topic+logLik">stats::logLik()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MAE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mean_absolute_error">Mean absolute error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Mahalanobis</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mahalanobis_distance">Mahalanobis distance</a> between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;"> (Mahalanobis 1936) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MSE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mean_squared_error">Mean squared error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>relativeEntropy</code>, <code>RE</code> </td><td style="text-align: left;"> A measure of the precision of the trajectory classification. A value of 1 indicates perfect classification, whereas a value of 0 indicates a non-informative uniform classification. It is the normalized version of <code>entropy</code>, scaled between [0, 1]. </td><td style="text-align: left;"> (Ramaswamy et al. 1993), (Muthén 2004) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RMSE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">Root mean squared error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RSS</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">Residual sum of squares</a> under most likely cluster allocation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>scaledEntropy</code> </td><td style="text-align: left;"> See <code>relativeEntropy</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>sigma</code> </td><td style="text-align: left;"> The residual standard deviation </td><td style="text-align: left;"> <code><a href="stats.html#topic+sigma">stats::sigma()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ssBIC</code> </td><td style="text-align: left;"> Sample-size adjusted BIC </td><td style="text-align: left;"> (Sclove 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SED</code> </td><td style="text-align: left;"> Standardized Euclidean distance between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SED.fit</code> </td><td style="text-align: left;"> The cluster-weighted standardized Euclidean distance between the cluster trajectories and the assigned fitted trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMAE</code> </td><td style="text-align: left;"> <code>MAE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMSE</code> </td><td style="text-align: left;"> <code>MSE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WRMSE</code> </td><td style="text-align: left;"> <code>RMSE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WRSS</code> </td><td style="text-align: left;"> <code>RSS</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Supported external metrics</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Metric name</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Function / Reference</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>adjustedRand</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Rand_index">Adjusted Rand index</a>. Based on the Rand index, but adjusted for agreements occurring by chance. A score of 1 indicates a perfect agreement, whereas a score of 0 indicates an agreement no better than chance. </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code>, (Hubert and Arabie 1985) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CohensKappa</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen's kappa</a>. A partitioning agreement metric correcting for random chance. A score of 1 indicates a perfect agreement, whereas a score of 0 indicates an agreement no better than chance. </td><td style="text-align: left;"> <code><a href="psych.html#topic+kappa">psych::cohen.kappa()</a></code>, (Cohen 1960) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>F</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/F-score">F-score</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>F1</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/F-score">F1-score</a>, also referred to as the <a href="https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient">Sørensen–Dice Coefficient</a>, or Dice similarity coefficient </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>FolkesMallows</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Fowlkes%E2%80%93Mallows_index">Fowlkes-Mallows index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Hubert</code> </td><td style="text-align: left;"> Hubert index </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Jaccard</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>jointEntropy</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Joint_entropy">Joint entropy</a> between model assignments </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Kulczynski</code> </td><td style="text-align: left;"> Kulczynski index </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MaximumMatch</code> </td><td style="text-align: left;"> Maximum match measure </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>McNemar</code> </td><td style="text-align: left;"> McNemar statistic </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MeilaHeckerman</code> </td><td style="text-align: left;"> Meila-Heckerman measure </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Mirkin</code> </td><td style="text-align: left;"> Mirkin metric </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MI</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mutual_information">Mutual information</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NMI</code> </td><td style="text-align: left;"> Normalized mutual information </td><td style="text-align: left;"> <code><a href="igraph.html#topic+compare">igraph::compare()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NSJ</code> </td><td style="text-align: left;"> Normalized version of <code>splitJoin</code>. The proportion of edits relative to the maximum changes (twice the number of ids) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>NVI</code> </td><td style="text-align: left;"> Normalized variation of information </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Overlap</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Overlap_coefficient">Overlap coefficient</a>, also referred to as the Szymkiewicz–Simpson coefficient </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> (M K and K 2016) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>PD</code> </td><td style="text-align: left;"> Partition difference </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Phi</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Phi_coefficient">Phi coefficient</a>. </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>precision</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Precision_and_recall">precision</a> </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Rand</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Rand_index">Rand index</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>recall</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Precision_and_recall">recall</a> </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RogersTanimoto</code> </td><td style="text-align: left;"> Rogers-Tanimoto dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RusselRao</code> </td><td style="text-align: left;"> Russell-Rao dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SMC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Simple_matching_coefficient">Simple matching coefficient</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>splitJoin</code> </td><td style="text-align: left;"> total split-join index </td><td style="text-align: left;"> <code><a href="igraph.html#topic+split_join_distance">igraph::split_join_distance()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>splitJoin.ref</code> </td><td style="text-align: left;"> Split-join index of the first model to the second model. In other words, it is the edit-distance between the two partitionings. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SokalSneath1</code> </td><td style="text-align: left;"> Type-1 Sokal-Sneath dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SokalSneath2</code> </td><td style="text-align: left;"> Type-2 Sokal-Sneath dissimilarity </td><td style="text-align: left;"> <code><a href="clusterCrit.html#topic+extCriteria">clusterCrit::extCriteria()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>VI</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Variation_of_information">Variation of information</a> </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Wallace1</code> </td><td style="text-align: left;"> Type-1 Wallace criterion </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Wallace2</code> </td><td style="text-align: left;"> Type-2 Wallace criterion </td><td style="text-align: left;"> <code><a href="mclustcomp.html#topic+mclustcomp">mclustcomp::mclustcomp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMSSE</code> </td><td style="text-align: left;"> Weighted minimum sum of squared errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMMSE</code> </td><td style="text-align: left;"> Weighted minimum mean of squared errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMMAE</code> </td><td style="text-align: left;"> Weighted minimum mean of absolute errors between cluster trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+metric">metric</a> <a href="#topic+externalMetric">externalMetric</a>
</p>

<hr>
<h2 id='latrend-parallel'>Parallel computation using latrend</h2><span id='topic+latrend-parallel'></span>

<h3>Description</h3>

<p>The model estimation functions support parallel computation through the use of the <a href="foreach.html#topic+foreach">foreach</a> mechanism.
In order to make use of parallel execution, a parallel back-end must be registered.
</p>


<h3>Windows</h3>

<p>On Windows, the <a href="parallel.html#topic+parallel-package">parallel-package</a> can be used to define parallel socket workers.
</p>
<pre>
nCores &lt;- parallel::detectCores(logical = FALSE)
cl &lt;- parallel::makeCluster(nCores)
</pre>
<p>Then, register the cluster as the parallel back-end using the <code>doParallel</code> package:
</p>
<pre>
doParallel::registerDoParallel(cl)
</pre>
<p>If you defined your own <code>lcMethod</code> or <code>lcModel</code> extension classes, make sure to load them on the workers as well.
This can be done, for example, using:
</p>
<pre>
parallel::clusterEvalQ(cl,
  expr = setClass('lcMethodMyImpl', contains = "lcMethod"))
</pre>


<h3>Unix</h3>

<p>On Unix systems, it is easier to setup parallelization as the R process is forked.
In this example we use the <code>doMC</code> package:
</p>
<pre>
nCores &lt;- parallel::detectCores(logical = FALSE)
doMC::registerDoMC(nCores)
</pre>


<h3>See Also</h3>

<p><a href="#topic+latrendRep">latrendRep</a>, <a href="#topic+latrendBatch">latrendBatch</a>, <a href="#topic+latrendBoot">latrendBoot</a>, <a href="#topic+latrendCV">latrendCV</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(latrendData)

# parallel latrendRep()
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
models &lt;- latrendRep(method, data = latrendData, .rep = 5, parallel = TRUE)

# parallel latrendBatch()
methods &lt;- lcMethods(method, nClusters = 1:3)
models &lt;- latrendBatch(methods, data = latrendData, parallel = TRUE)

</code></pre>

<hr>
<h2 id='latrendBatch'>Cluster longitudinal data for a list of method specifications</h2><span id='topic+latrendBatch'></span>

<h3>Description</h3>

<p>Fit a list of longitudinal cluster methods on one or more datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrendBatch(
  methods,
  data,
  cartesian = TRUE,
  seed = NULL,
  parallel = FALSE,
  errorHandling = "stop",
  envir = NULL,
  verbose = getOption("latrend.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrendBatch_+3A_methods">methods</code></td>
<td>
<p>A <code>list</code> of <code>lcMethod</code> objects.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_data">data</code></td>
<td>
<p>The dataset(s) to which to fit the respective <code>lcMethod</code> on.
Either a <code>data.frame</code>, <code>matrix</code>, <code>list</code> or an expression evaluating to one of the supported types.
Multiple datasets can be supplied by encapsulating the datasets using <code>data = .(df1, df2, ..., dfN)</code>.
Doing this results in a more readable <code>call</code> associated with each fitted <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_cartesian">cartesian</code></td>
<td>
<p>Whether to fit the provided methods on each of the datasets. If <code>cartesian=FALSE</code>, only a single dataset may be provided or a list of data matching the length of <code>methods</code>.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_seed">seed</code></td>
<td>
<p>Sets the seed for generating a seed number for the methods.
Seeds are only set for methods without a seed argument or <code>NULL</code> seed.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_parallel">parallel</code></td>
<td>
<p>Whether to enable parallel evaluation. See <a href="#topic+latrend-parallel">latrend-parallel</a>. Method evaluation and dataset transformation is done on the calling thread.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_errorhandling">errorHandling</code></td>
<td>
<p>Whether to <code>"stop"</code> on an error, or to <code style="white-space: pre;">&#8288;"remove'&#8288;</code> evaluations that raised an error.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the <code>lcMethod</code> arguments.</p>
</td></tr>
<tr><td><code id="latrendBatch_+3A_verbose">verbose</code></td>
<td>
<p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods and datasets are evaluated and validated prior to any fitting. This ensures that the batch estimation fails as early as possible in case of errors.
</p>


<h3>Value</h3>

<p>A <code>lcModels</code> object.
In case of a model fit error under <code>errorHandling = pass</code>, a <code>list</code> is returned.
</p>


<h3>See Also</h3>

<p>lcMethods
</p>
<p>Other longitudinal cluster fit functions: 
<code><a href="#topic+latrend">latrend</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+latrendRep">latrendRep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
refMethod &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
methods &lt;- lcMethods(refMethod, nClusters = 1:2)
models &lt;- latrendBatch(methods, data = latrendData)

# different dataset per method
models &lt;- latrendBatch(
   methods,
   data = .(
     subset(latrendData, Time &gt; .5),
     subset(latrendData, Time &lt; .5)
   )
)

</code></pre>

<hr>
<h2 id='latrendBoot'>Cluster longitudinal data using bootstrapping</h2><span id='topic+latrendBoot'></span>

<h3>Description</h3>

<p>Performs bootstrapping, generating samples from the given data at the id level, fitting a lcModel to each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrendBoot(
  method,
  data,
  samples = 50,
  seed = NULL,
  parallel = FALSE,
  errorHandling = "stop",
  envir = NULL,
  verbose = getOption("latrend.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrendBoot_+3A_method">method</code></td>
<td>
<p>An <a href="#topic+lcMethod">lcMethod</a> object specifying the longitudinal cluster method to apply, or the name (as <code>character</code>) of the <code>lcMethod</code> subclass to instantiate.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_samples">samples</code></td>
<td>
<p>The number of bootstrap samples to evaluate.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_seed">seed</code></td>
<td>
<p>The seed to use. Optional.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_parallel">parallel</code></td>
<td>
<p>Whether to enable parallel evaluation. See <a href="#topic+latrend-parallel">latrend-parallel</a>. Method evaluation and dataset transformation is done on the calling thread.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_errorhandling">errorHandling</code></td>
<td>
<p>Whether to <code>"stop"</code> on an error, or to <code style="white-space: pre;">&#8288;"remove'&#8288;</code> evaluations that raised an error.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the method arguments via <code><a href="#topic+compose">compose()</a></code>.
If the <code>data</code> argument is of type <code>call</code> then this environment is also used to evaluate the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="latrendBoot_+3A_verbose">verbose</code></td>
<td>
<p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcModels</code> object of length <code>samples</code>.
</p>


<h3>See Also</h3>

<p>Other longitudinal cluster fit functions: 
<code><a href="#topic+latrend">latrend</a>()</code>,
<code><a href="#topic+latrendBatch">latrendBatch</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+latrendRep">latrendRep</a>()</code>
</p>
<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>,
<code><a href="#topic+lcModel-data-filters">lcModel-data-filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
bootModels &lt;- latrendBoot(method, latrendData, samples = 10)

bootMAE &lt;- metric(bootModels, name = "MAE")
mean(bootMAE)
sd(bootMAE)
</code></pre>

<hr>
<h2 id='latrendCV'>Cluster longitudinal data over k folds</h2><span id='topic+latrendCV'></span>

<h3>Description</h3>

<p>Apply k-fold cross validation for internal cluster validation.
Creates k random subsets (&quot;folds&quot;) from the data, estimating a model for each of the k-1 combined folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrendCV(
  method,
  data,
  folds = 10,
  seed = NULL,
  parallel = FALSE,
  errorHandling = "stop",
  envir = NULL,
  verbose = getOption("latrend.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrendCV_+3A_method">method</code></td>
<td>
<p>An <a href="#topic+lcMethod">lcMethod</a> object specifying the longitudinal cluster method to apply, or the name (as <code>character</code>) of the <code>lcMethod</code> subclass to instantiate.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_folds">folds</code></td>
<td>
<p>The number of folds. Ten folds by default.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_seed">seed</code></td>
<td>
<p>The seed to use. Optional.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_parallel">parallel</code></td>
<td>
<p>Whether to enable parallel evaluation. See <a href="#topic+latrend-parallel">latrend-parallel</a>. Method evaluation and dataset transformation is done on the calling thread.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_errorhandling">errorHandling</code></td>
<td>
<p>Whether to <code>"stop"</code> on an error, or to <code style="white-space: pre;">&#8288;"remove'&#8288;</code> evaluations that raised an error.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the method arguments via <code><a href="#topic+compose">compose()</a></code>.
If the <code>data</code> argument is of type <code>call</code> then this environment is also used to evaluate the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="latrendCV_+3A_verbose">verbose</code></td>
<td>
<p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcModels</code> object of containing the <code>folds</code> training models.
</p>


<h3>See Also</h3>

<p>Other longitudinal cluster fit functions: 
<code><a href="#topic+latrend">latrend</a>()</code>,
<code><a href="#topic+latrendBatch">latrendBatch</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendRep">latrendRep</a>()</code>
</p>
<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+lcModel-data-filters">lcModel-data-filters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")

if (require("caret")) {
  model &lt;- latrendCV(method, latrendData, folds = 5, seed = 1)

  model &lt;- latrendCV(method, subset(latrendData, Time &lt; .5), folds = 5)
}
</code></pre>

<hr>
<h2 id='latrendData'>Artificial longitudinal dataset comprising three classes</h2><span id='topic+latrendData'></span>

<h3>Description</h3>

<p>An artificial longitudinal dataset comprising 200 trajectories belonging to one of 3 classes.
Each trajectory deviates in intercept and slope from its respective class trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrendData
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> comprising longitudinal observations from 200 trajectories.
Each row represents the observed value of a trajectory at a specific moment in time.
</p>

<dl>
<dt>Id</dt><dd><p><code>integer</code>: The trajectory identifier.</p>
</dd>
<dt>Time</dt><dd><p><code>numeric</code>: The measurement time, between 0 and 2.</p>
</dd>
<dt>Y</dt><dd><p><code>numeric</code>: The observed value at the respective time <code>Time</code> for trajectory <code>Id</code>.</p>
</dd>
<dt>Class</dt><dd><p><code>factor</code>: The reference class.</p>
</dd>
</dl>

<div class="sourceCode r"><pre>data(latrendData)
head(latrendData)
#&gt;   Id      Time           Y   Class
#&gt; 1  1 0.0000000 -1.08049205 Class 1
#&gt; 2  1 0.2222222 -0.68024151 Class 1
#&gt; 3  1 0.4444444 -0.65148373 Class 1
#&gt; 4  1 0.6666667 -0.39115398 Class 1
#&gt; 5  1 0.8888889 -0.19407876 Class 1
#&gt; 6  1 1.1111111 -0.02991783 Class 1
</pre></div>


<h3>Source</h3>

<p>This dataset was generated using <a href="#topic+generateLongData">generateLongData</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-data">latrend-data</a> <a href="#topic+generateLongData">generateLongData</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("ggplot2")) {
  plotTrajectories(latrendData, id = "Id", time = "Time", response = "Y")

  # plot according to the reference class
  plotTrajectories(latrendData, id = "Id", time = "Time", response = "Y", cluster = "Class")
}
</code></pre>

<hr>
<h2 id='latrendRep'>Cluster longitudinal data repeatedly</h2><span id='topic+latrendRep'></span>

<h3>Description</h3>

<p>Performs a repeated fit of the specified latrend model on the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latrendRep(
  method,
  data,
  .rep = 10,
  ...,
  .errorHandling = "stop",
  .seed = NULL,
  .parallel = FALSE,
  envir = NULL,
  verbose = getOption("latrend.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latrendRep_+3A_method">method</code></td>
<td>
<p>An <a href="#topic+lcMethod">lcMethod</a> object specifying the longitudinal cluster method to apply, or the name (as <code>character</code>) of the <code>lcMethod</code> subclass to instantiate.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_data">data</code></td>
<td>
<p>The data of the trajectories to which to estimate the method for.
Any inputs supported by <code><a href="#topic+trajectories">trajectories()</a></code> can be used, including <code>data.frame</code> and <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_.rep">.rep</code></td>
<td>
<p>The number of repeated fits.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_...">...</code></td>
<td>
<p>Any other arguments to update the <code>lcMethod</code> definition with.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_.errorhandling">.errorHandling</code></td>
<td>
<p>Whether to <code>"stop"</code> on an error, or to <code style="white-space: pre;">&#8288;"remove'&#8288;</code> evaluations that raised an error.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_.seed">.seed</code></td>
<td>
<p>Set the seed for generating the respective seed for each of the repeated fits.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_.parallel">.parallel</code></td>
<td>
<p>Whether to use parallel evaluation. See <a href="#topic+latrend-parallel">latrend-parallel</a>.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the method arguments via <code><a href="#topic+compose">compose()</a></code>.
If the <code>data</code> argument is of type <code>call</code> then this environment is also used to evaluate the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="latrendRep_+3A_verbose">verbose</code></td>
<td>
<p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is faster than repeatedly calling <a href="#topic+latrend">latrend</a> as it only prepares the data via <code>prepareData()</code> once.
</p>


<h3>Value</h3>

<p>A <code>lcModels</code> object containing the resulting models.
</p>


<h3>See Also</h3>

<p>Other longitudinal cluster fit functions: 
<code><a href="#topic+latrend">latrend</a>()</code>,
<code><a href="#topic+latrendBatch">latrendBatch</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
models &lt;- latrendRep(method, data = latrendData, .rep = 5) # 5 repeated runs

models &lt;- latrendRep(method, data = latrendData, .seed = 1, .rep = 3)
</code></pre>

<hr>
<h2 id='lcApproxModel-class'>lcApproxModel class</h2><span id='topic+lcApproxModel-class'></span><span id='topic+lcApproxModel'></span><span id='topic+fitted.lcApproxModel'></span><span id='topic+predictForCluster+2ClcApproxModel-method'></span>

<h3>Description</h3>

<p>approx models have defined cluster trajectories at fixed moments in time, which should be interpolated
For a correct implementation, <code>lcApproxModel</code> requires the extending class to implement <code>clusterTrajectories(at=NULL)</code>
to return the fixed cluster trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcApproxModel'
fitted(object, ..., clusters = trajectoryAssignments(object))

## S4 method for signature 'lcApproxModel'
predictForCluster(
  object,
  newdata,
  cluster,
  what = "mu",
  approxFun = approx,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcApproxModel-class_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="lcApproxModel-class_+3A_approxfun">approxFun</code></td>
<td>
<p>Function to interpolate between measurement moments, <a href="stats.html#topic+approx">approx</a>() by default.</p>
</td></tr>
</table>

<hr>
<h2 id='lcFitMethods'>Method fit modifiers</h2><span id='topic+lcFitMethods'></span><span id='topic+lcMetaMethods'></span><span id='topic+lcFitConverged-class'></span><span id='topic+lcFitConverged'></span><span id='topic+lcFitRep-class'></span><span id='topic+lcFitRep'></span><span id='topic+lcFitRepMin'></span><span id='topic+lcFitRepMax'></span>

<h3>Description</h3>

<p>A collection of special methods that adapt the fitting procedure of the underlying longitudinal cluster method.
</p>
<p>NOTE: the underlying implementation is experimental and may change in the future.
</p>
<p>Supported fit methods:
</p>

<ul>
<li> <p><code>lcFitConverged</code>: Fit a method until a converged result is obtained.
</p>
</li>
<li> <p><code>lcFitRep</code>: Repeatedly fit a method and return the best result based on a given internal metric.
</p>
</li>
<li> <p><code>lcFitRepMin</code>: Repeatedly fit a method and return the best result that minimizes the given internal metric.
</p>
</li>
<li> <p><code>lcFitRepMax</code>: Repeatedly fit a method and return the best result that maximizes the given internal metric.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lcFitConverged(method, maxRep = Inf)

lcFitRep(method, rep = 10, metric, maximize)

lcFitRepMin(method, rep = 10, metric)

lcFitRepMax(method, rep = 10, metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcFitMethods_+3A_method">method</code></td>
<td>
<p>The <code>lcMethod</code> to use for fitting.</p>
</td></tr>
<tr><td><code id="lcFitMethods_+3A_maxrep">maxRep</code></td>
<td>
<p>The maximum number of fit attempts</p>
</td></tr>
<tr><td><code id="lcFitMethods_+3A_rep">rep</code></td>
<td>
<p>The number of fits</p>
</td></tr>
<tr><td><code id="lcFitMethods_+3A_metric">metric</code></td>
<td>
<p>The internal metric to assess the fit.</p>
</td></tr>
<tr><td><code id="lcFitMethods_+3A_maximize">maximize</code></td>
<td>
<p>Whether to maximize the metric. Otherwise, it is minimized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meta methods are immutable and cannot be updated after instantiation. Calling <code><a href="stats.html#topic+update">update()</a></code> on a meta method is only used to update arguments of the underlying <a href="#topic+lcMethod">lcMethod</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 2)
metaMethod &lt;- lcFitConverged(method, maxRep = 10)
metaMethod
model &lt;- latrend(metaMethod, latrendData)

data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 2)
repMethod &lt;- lcFitRep(method, rep = 10, metric = "RSS", maximize = FALSE)
repMethod
model &lt;- latrend(repMethod, latrendData)

minMethod &lt;- lcFitRepMin(method, rep = 10, metric = "RSS")

maxMethod &lt;- lcFitRepMax(method, rep = 10, metric = "ASW")
</code></pre>

<hr>
<h2 id='lcMatrixMethod-class'>lcMatrixMethod</h2><span id='topic+lcMatrixMethod-class'></span><span id='topic+getName+2ClcMatrixMethod-method'></span><span id='topic+getShortName+2ClcMatrixMethod-method'></span><span id='topic+prepareData+2ClcMatrixMethod-method'></span>

<h3>Description</h3>

<p>lcMatrixMethod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMatrixMethod'
getName(object, ...)

## S4 method for signature 'lcMatrixMethod'
getShortName(object, ...)

## S4 method for signature 'lcMatrixMethod'
prepareData(method, data, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMatrixMethod-class_+3A_object">object</code></td>
<td>
<p>The data or model or extract the trajectories from.</p>
</td></tr>
<tr><td><code id="lcMatrixMethod-class_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="lcMatrixMethod-class_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="lcMatrixMethod-class_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="lcMatrixMethod-class_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
</table>

<hr>
<h2 id='lcMethod-class'>lcMethod class</h2><span id='topic+lcMethod-class'></span><span id='topic+lcMethod'></span>

<h3>Description</h3>

<p><code>lcMethod</code> objects represent the specification of a method for longitudinal clustering.
Furthermore, the object class contains the logic for estimating the respective method.
</p>
<p>You can specify a longitudinal cluster method through one of the method-specific constructor functions,
e.g., <code><a href="#topic+lcMethodKML">lcMethodKML()</a></code>, <code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM()</a></code>, or <code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust()</a></code>.
Alternatively, you can instantiate methods through <code><a href="methods.html#topic+new">methods::new()</a></code>, e.g., by calling <code>new("lcMethodKML", response = "Value")</code>.
In both cases, default values are specified for omitted arguments.
</p>


<h3>Details</h3>

<p>Because the <code>lcMethod</code> arguments may be unevaluated, argument retrieval functions such as <code>[[</code> accept an <code>envir</code> argument.
A default <code>environment</code> can be assigned or obtained from a <code>lcMethod</code> object using the <code>environment()</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>arguments</code></dt><dd><p>A <code>list</code> representing the arguments of the <code>lcMethod</code> object.
Arguments are not evaluated upon creation of the method object.
Instead, arguments are stored similar to a <code>call</code> object, and are only evaluated when a method is fitted.
Do not modify or access.</p>
</dd>
<dt><code>sourceCalls</code></dt><dd><p>A list of calls for tracking the original call after substitution.
Used for printing objects which require too many characters (e.g. ,function definitions, matrices).
Do not modify or access.</p>
</dd>
</dl>


<h3>Method arguments</h3>

<p>An <code>lcMethod</code> objects represent the specification of a method with a set of configurable parameters (referred to as arguments).
</p>
<p>Arguments can be of any type.
It is up to the <code>lcMethod</code> implementation of <code><a href="#topic+validate">validate()</a></code> to ensure that the required arguments are present and are of the expected type.
</p>
<p>Arguments can have almost any name. Exceptions include the names <code>"data"</code>, <code>"envir"</code>, and <code>"verbose"</code>.
Furthermore, argument names may not start with a period (<code>"."</code>).
</p>
<p>Arguments cannot be directly modified, i.e., <code>lcMethod</code> objects are immutable.
Modifying an argument involves creating an altered copy through the <a href="#topic+update.lcMethod">update.lcMethod</a> method.
</p>


<h3>Implementation</h3>

<p>The base class <code>lcMethod</code> provides the logic for storing, evaluating, and printing the method parameters.
</p>
<p>Subclasses of <code>lcMethod</code> differ only in the <a href="#topic+lcMethod-estimation">fitting procedure logic</a>.
</p>
<p>To implement your own <code>lcMethod</code> subclass, you'll want to implement at least the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+fit">fit()</a></code>: The main function for estimating your method.
</p>
</li>
<li> <p><code><a href="#topic+getName">getName()</a></code>: The name of your method.
</p>
</li>
<li> <p><code><a href="#topic+getShortName">getShortName()</a></code>: The abbreviated name of your method.
</p>
</li>
<li> <p><code><a href="#topic+getArgumentDefaults">getArgumentDefaults()</a></code>: Sensible default argument values to your method.
</p>
</li></ul>

<p>For more complex methods, the additional functions as part of the <a href="#topic+lcMethod-estimation">fitting procedure</a> will be of use.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+environment">environment</a>
</p>
<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>
<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 2)
method

method &lt;- new("lcMethodLMKM", formula = Y ~ Time, id = "Id", time = "Time", nClusters = 2)

# get argument names
names(method)

# evaluate argument
method$nClusters

# create a copy with updated nClusters argument
method3 &lt;- update(method, nClusters = 3)
</code></pre>

<hr>
<h2 id='lcMethod-estimation'>Longitudinal cluster method (<code>lcMethod</code>) estimation procedure</h2><span id='topic+lcMethod-estimation'></span><span id='topic+latrend-procedure'></span><span id='topic+lcMethod-steps'></span>

<h3>Description</h3>

<p>Each longitudinal cluster method represented by a <a href="#topic+lcMethod-class">lcMethod class</a> implements a series of standardized steps that produce the estimated method as its output.
These steps, as part of the estimation procedure, are executed by the <code><a href="#topic+latrend">latrend()</a></code> function and other functions prefixed by <em>&quot;latrend&quot;</em> (e.g., <code><a href="#topic+latrendRep">latrendRep()</a></code>, <code><a href="#topic+latrendBoot">latrendBoot()</a></code>, <code><a href="#topic+latrendCV">latrendCV()</a></code>).
</p>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>


<h3>See Also</h3>

<p><a href="#topic+lcMethod-class">lcMethod</a> <a href="#topic+latrend">latrend</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)
summary(model)
</code></pre>

<hr>
<h2 id='lcMethodAkmedoids'>Specify AKMedoids method</h2><span id='topic+lcMethodAkmedoids'></span>

<h3>Description</h3>

<p>Specify AKMedoids method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodAkmedoids(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 3,
  clusterCenter = median,
  crit = "Calinski_Harabasz",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodAkmedoids_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_clustercenter">clusterCenter</code></td>
<td>
<p>A function for computing the cluster center representation.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_crit">crit</code></td>
<td>
<p>Criterion to apply for internal model selection. Not applicable.</p>
</td></tr>
<tr><td><code id="lcMethodAkmedoids_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>akmedoids::akclustr</code>.
The following external arguments are ignored: traj, id_field, k</p>
</td></tr>
</table>


<h3>References</h3>

<p>Adepeju M, Langton S, Bannister J (2020).
<em>akmedoids: Anchored Kmedoids for Longitudinal Data Clustering</em>.
R package version 0.1.5, <a href="https://CRAN.R-project.org/package=akmedoids">https://CRAN.R-project.org/package=akmedoids</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
if (rlang::is_installed("akmedoids")) {
  method &lt;- lcMethodAkmedoids(response = "Y", time = "Time", id = "Id", nClusters = 3)
  model &lt;- latrend(method, data = latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodCrimCV'>Specify a zero-inflated repeated-measures GBTM method</h2><span id='topic+lcMethodCrimCV'></span>

<h3>Description</h3>

<p>Specify a zero-inflated repeated-measures GBTM method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodCrimCV(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodCrimCV_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodCrimCV_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodCrimCV_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodCrimCV_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodCrimCV_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="crimCV.html#topic+crimCV">crimCV::crimCV</a>.
The following external arguments are ignored: Dat, ng.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nielsen JD (2018).
<em>crimCV: Group-Based Modelling of Longitudinal Data</em>.
R package version 0.9.6, <a href="https://CRAN.R-project.org/package=crimCV">https://CRAN.R-project.org/package=crimCV</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not tested because crimCV sometimes fails
# to converge and throws the error "object 'Frtr' not found"
## Not run: 
data(latrendData)
if (require("crimCV")) {
  method &lt;- lcMethodCrimCV("Y", id = "Id", time = "Time", nClusters = 3, dpolyp = 1, init = 2)
  model &lt;- latrend(method, data = subset(latrendData, Time &gt; .5))

  if (require("ggplot2")) {
    plot(model)
  }

  data(TO1adj)
  method &lt;- lcMethodCrimCV(response = "Offenses", time = "Offense", id = "Subject",
    nClusters = 2, dpolyp = 1, init = 2)
  model &lt;- latrend(method, data = TO1adj[1:100, ])
}

## End(Not run)
</code></pre>

<hr>
<h2 id='lcMethodDtwclust'>Specify time series clustering via dtwclust</h2><span id='topic+lcMethodDtwclust'></span>

<h3>Description</h3>

<p>Specify time series clustering via dtwclust
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodDtwclust(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodDtwclust_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodDtwclust_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodDtwclust_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodDtwclust_+3A_nclusters">nClusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="lcMethodDtwclust_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="dtwclust.html#topic+tsclust">dtwclust::tsclust</a>.
The following arguments are ignored: series, k, trace.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sardá-Espinosa A (2019).
&ldquo;Time-Series Clustering in R Using the dtwclust Package.&rdquo;
<em>The R Journal</em>.
<a href="https://doi.org/10.32614/RJ-2019-023">doi:10.32614/RJ-2019-023</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("dtwclust")) {
  method &lt;- lcMethodDtwclust("Y", id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodFeature'>Feature-based clustering</h2><span id='topic+lcMethodFeature'></span>

<h3>Description</h3>

<p>Feature-based clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodFeature(
  response,
  representationStep,
  clusterStep,
  standardize = scale,
  center = meanNA,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodFeature_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_representationstep">representationStep</code></td>
<td>
<p>A <code>function</code> with signature <code style="white-space: pre;">&#8288;function(method, data)&#8288;</code> that computes the representation per strata, returned as a <code>matrix</code>.
Alternatively, <code>representationStep</code> is a pre-computed representation <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_clusterstep">clusterStep</code></td>
<td>
<p>A <code>function</code> with signature <code style="white-space: pre;">&#8288;function(repdata)&#8288;</code> that outputs a <code>lcModel</code>.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_standardize">standardize</code></td>
<td>
<p>A <code>function</code> to standardize the output <code>matrix</code> of the representation step. By default, the output is shifted and rescaled to ensure zero mean and unit variance.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_center">center</code></td>
<td>
<p>The <code>function</code> for computing the longitudinal cluster centers, used for representing the cluster trajectories.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodFeature_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Linear regresion &amp; k-means example</h3>

<p>In this example we define a feature-based approach where each trajectory is represented using a linear regression model.
The coefficients of the trajectories are then clustered using k-means.
</p>
<p>Note that this method is already implemented as <code><a href="#topic+lcMethodLMKM">lcMethodLMKM()</a></code>.
</p>
<p>Representation step:
</p>
<pre>
repStep &lt;- function(method, data, verbose) {
  library(data.table)
  library(magrittr)
  xdata = as.data.table(data)
  coefdata &lt;- xdata[,
    lm(method$formula, .SD) 
    keyby = c(method$id)
  ]
  # exclude the id column
  coefmat &lt;- subset(coefdata, select = -1) 
  rownames(coefmat) &lt;- coefdata[[method$id]]
  return(coefmat)
}
</pre>
<p>Cluster step:
</p>
<pre>
clusStep &lt;- function(method, data, repMat, envir, verbose) {
  km &lt;- kmeans(repMat, centers = method$nClusters)

  lcModelPartition(
    response = method$response,
    data = data,
    trajectoryAssignments = km$cluster
  )
}
</pre>
<p>Now specify the method and fit the model:
</p>
<pre>
data(latrendData)
method &lt;- lcMethodFeature(
  formula = Y ~ Time,
  response = "Y",
  id = "Id",
  time = "Time",
  representationStep = repStep,
  clusterStep = clusStep

model &lt;- latrend(method, data = latrendData)
)
</pre>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>

<hr>
<h2 id='lcMethodFlexmix'>Method interface to flexmix()</h2><span id='topic+lcMethodFlexmix'></span>

<h3>Description</h3>

<p>Wrapper to the <code>flexmix()</code> method from the <code>flexmix</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodFlexmix(
  formula,
  formula.mb = ~1,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodFlexmix_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> specifying the model.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmix_+3A_formula.mb">formula.mb</code></td>
<td>
<p>A <code>formula</code> specifying the class membership model. By default, an intercept-only model is used.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmix_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmix_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmix_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmix_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="flexmix.html#topic+flexmix">flexmix::flexmix</a>.
The following arguments are ignored: data, concomitant, k.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grün B, Leisch F (2008).
&ldquo;FlexMix Version 2: Finite Mixtures with Concomitant Variables and Varying and Constant Parameters.&rdquo;
<em>Journal of Statistical Software</em>, <b>28</b>(4), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v028.i04">doi:10.18637/jss.v028.i04</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod package interfaces: 
<code><a href="#topic+lcMethodFlexmixGBTM">lcMethodFlexmixGBTM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
if (require("flexmix")) {
  method &lt;- lcMethodFlexmix(Y ~ Time, id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodFlexmixGBTM'>Group-based trajectory modeling using flexmix</h2><span id='topic+lcMethodFlexmixGBTM'></span>

<h3>Description</h3>

<p>Fits a GBTM based on the <a href="flexmix.html#topic+FLXglm">flexmix::FLXMRglm</a> driver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodFlexmixGBTM(
  formula,
  formula.mb = ~1,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> specifying the model.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_formula.mb">formula.mb</code></td>
<td>
<p>A <code>formula</code> specifying the class membership model. By default, an intercept-only model is used.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodFlexmixGBTM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="flexmix.html#topic+flexmix">flexmix::flexmix</a> or <a href="flexmix.html#topic+FLXglm">flexmix::FLXMRglm</a>.
The following arguments are ignored: data, k, trace.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grün B, Leisch F (2008).
&ldquo;FlexMix Version 2: Finite Mixtures with Concomitant Variables and Varying and Constant Parameters.&rdquo;
<em>Journal of Statistical Software</em>, <b>28</b>(4), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v028.i04">doi:10.18637/jss.v028.i04</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod package interfaces: 
<code><a href="#topic+lcMethodFlexmix">lcMethodFlexmix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
if (require("flexmix")) {
  method &lt;- lcMethodFlexmixGBTM(Y ~ Time, id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodFunction'>Specify a custom method based on a function</h2><span id='topic+lcMethodFunction'></span>

<h3>Description</h3>

<p>Specify a custom method based on a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodFunction(
  response,
  fun,
  center = meanNA,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  name = "custom"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodFunction_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunction_+3A_fun">fun</code></td>
<td>
<p>The cluster <code>function</code> with signature <code style="white-space: pre;">&#8288;(method, data)&#8288;</code> that returns a <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="lcMethodFunction_+3A_center">center</code></td>
<td>
<p>Optional <code>function</code> for computing the longitudinal cluster centers, with signature <code>(x)</code>.</p>
</td></tr>
<tr><td><code id="lcMethodFunction_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunction_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunction_+3A_name">name</code></td>
<td>
<p>The name of the method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
# Stratification based on the mean response level
clusfun &lt;- function(data, response, id, time, ...) {
  clusters &lt;- data.table::as.data.table(data)[, mean(Y) &gt; 0, by = Id]$V1
  lcModelPartition(
    data = data,
    trajectoryAssignments = factor(
      clusters,
      levels = c(FALSE, TRUE),
      labels = c("Low", "High")
    ),
    response = response,
    time = time,
    id = id
  )
}
method &lt;- lcMethodFunction(response = "Y", fun = clusfun, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)
</code></pre>

<hr>
<h2 id='lcMethodFunFEM'>Specify a FunFEM method</h2><span id='topic+lcMethodFunFEM'></span>

<h3>Description</h3>

<p>Specify a FunFEM method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodFunFEM(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  basis = function(time) fda::create.bspline.basis(time, nbasis = 10, norder = 4),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodFunFEM_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunFEM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunFEM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodFunFEM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodFunFEM_+3A_basis">basis</code></td>
<td>
<p>The basis function. By default, a 3rd-order B-spline with 10 breaks is used.</p>
</td></tr>
<tr><td><code id="lcMethodFunFEM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="funFEM.html#topic+funFEM">funFEM::funFEM</a>.
The following external arguments are ignored: fd, K, disp, graph.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bouveyron C (2015).
<em>funFEM: Clustering in the Discriminative Functional Subspace</em>.
R package version 1.1, <a href="https://CRAN.R-project.org/package=funFEM">https://CRAN.R-project.org/package=funFEM</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("funFEM") &amp;&amp; require("fda")) {
  method &lt;- lcMethodFunFEM("Y", id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)

  method &lt;- lcMethodFunFEM("Y",
   basis = function(time) {
      create.bspline.basis(time, nbasis = 10, norder = 4)
   }
  )
}
</code></pre>

<hr>
<h2 id='lcMethodGCKM'>Two-step clustering through latent growth curve modeling and k-means</h2><span id='topic+lcMethodGCKM'></span>

<h3>Description</h3>

<p>Two-step clustering through latent growth curve modeling and k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodGCKM(
  formula,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  center = meanNA,
  standardize = scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodGCKM_+3A_formula">formula</code></td>
<td>
<p>Formula, including a random effects component for the trajectory. See <a href="lme4.html#topic+lmer">lme4::lmer</a> formula syntax.</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_time">time</code></td>
<td>
<p>The name of the time variable..</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_center">center</code></td>
<td>
<p>A  <code>function</code> that computes the cluster center based on the original trajectories associated with the respective cluster.
By default, the mean is computed.</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_standardize">standardize</code></td>
<td>
<p>A <code>function</code> to standardize the output <code>matrix</code> of the representation step. By default, the output is shifted and rescaled to ensure zero mean and unit variance.</p>
</td></tr>
<tr><td><code id="lcMethodGCKM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="lme4.html#topic+lmer">lme4::lmer</a>.
The following external arguments are ignored: data, centers, trace.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("lme4")) {
  method &lt;- lcMethodGCKM(Y ~ (Time | Id), id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodKML'>Specify a longitudinal k-means (KML) method</h2><span id='topic+lcMethodKML'></span>

<h3>Description</h3>

<p>Specify a longitudinal k-means (KML) method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodKML(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodKML_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodKML_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodKML_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodKML_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodKML_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="kml.html#topic+parKml">kml::parALGO</a> and <a href="kml.html#topic+kml">kml::kml</a>.
</p>
<p>The following external arguments are ignored: object, nbClusters, parAlgo, toPlot, saveFreq</p>
</td></tr>
</table>


<h3>References</h3>

<p>Genolini C, Alacoque X, Sentenac M, Arnaud C (2015).
&ldquo;kml and kml3d: R Packages to Cluster Longitudinal Data.&rdquo;
<em>Journal of Statistical Software</em>, <b>65</b>(4), 1&ndash;34.
<a href="https://doi.org/10.18637/jss.v065.i04">doi:10.18637/jss.v065.i04</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("kml")) {
  method &lt;- lcMethodKML("Y", id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodLcmmGBTM'>Specify GBTM method</h2><span id='topic+lcMethodLcmmGBTM'></span>

<h3>Description</h3>

<p>Group-based trajectory modeling through fixed-effects modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodLcmmGBTM(
  fixed,
  mixture = ~1,
  classmb = ~1,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  init = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodLcmmGBTM_+3A_fixed">fixed</code></td>
<td>
<p>The fixed effects formula.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_mixture">mixture</code></td>
<td>
<p>The mixture-specific effects formula. See <a href="lcmm.html#topic+hlme">lcmm::hlme</a> for details.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_classmb">classmb</code></td>
<td>
<p>The cluster membership formula for the multinomial logistic model. See <a href="lcmm.html#topic+hlme">lcmm::hlme</a> for details.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable. This replaces the <code>subject</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to fit. This replaces the <code>ng</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_init">init</code></td>
<td>
<p>Alternative for the <code>B</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>, for initializing the hlme fitting procedure.
This is only applicable for <code>nClusters &gt; 1</code>.
Options:
</p>

<ul>
<li> <p><code>"lme.random"</code> (default): random initialization through a standard linear mixed model. Assigns a fitted standard linear mixed model enclosed in a call to random() to the <code>B</code> argument.
</p>
</li>
<li> <p><code>"lme"</code>, fits a standard linear mixed model and passes this to the <code>B</code> argument.
</p>
</li>
<li> <p><code>"gridsearch"</code>, a gridsearch is used with initialization from <code>"lme.random"</code>, following the approach used by <a href="lcmm.html#topic+gridsearch">lcmm::gridsearch</a>. To use this initalization, specify arguments <code>gridsearch.maxiter</code> (max number of iterations during search), <code>gridsearch.rep</code> (number of fits during search), and <code>gridsearch.parallel</code> (whether to enable <a href="#topic+latrend-parallel">parallel computation</a>).
</p>
</li>
<li> <p><code>NULL</code> or <code>"default"</code>, the default <a href="lcmm.html#topic+hlme">lcmm::hlme</a> input for <code>B</code> is used.
</p>
</li></ul>

<p>The argument is ignored if the <code>B</code> argument is specified, or <code>nClusters = 1</code>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGBTM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.
The following arguments are ignored: data, fixed, random, mixture, subject, classmb, returndata, ng, verbose, subset.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017).
&ldquo;Estimation of Extended Mixed Models Using Latent Classes and Latent Processes: The R Package lcmm.&rdquo;
<em>Journal of Statistical Software</em>, <b>78</b>(2), 1&ndash;56.
<a href="https://doi.org/10.18637/jss.v078.i02">doi:10.18637/jss.v078.i02</a>.
</p>
<p>Proust-Lima C, Philipps V, Diakite A, Liquet B (2019).
<em>lcmm: Extended Mixed Models Using Latent Classes and Latent Processes</em>.
R package version: 1.8.1, <a href="https://cran.r-project.org/package=lcmm">https://cran.r-project.org/package=lcmm</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
if (rlang::is_installed("lcmm")) {
  method &lt;- lcMethodLcmmGBTM(
    fixed = Y ~ Time,
    mixture = ~ 1,
   id = "Id",
   time = "Time",
   nClusters = 3
  )
  gbtm &lt;- latrend(method, data = latrendData)
  summary(gbtm)

  method &lt;- lcMethodLcmmGBTM(
    fixed = Y ~ Time,
    mixture = ~ Time,
    id = "Id",
    time = "Time",
    nClusters = 3
  )
}
</code></pre>

<hr>
<h2 id='lcMethodLcmmGMM'>Specify GMM method using lcmm</h2><span id='topic+lcMethodLcmmGMM'></span>

<h3>Description</h3>

<p>Growth mixture modeling through latent-class linear mixed modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodLcmmGMM(
  fixed,
  mixture = ~1,
  random = ~1,
  classmb = ~1,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  init = "lme",
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodLcmmGMM_+3A_fixed">fixed</code></td>
<td>
<p>The fixed effects formula.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_mixture">mixture</code></td>
<td>
<p>The mixture-specific effects formula. See <a href="lcmm.html#topic+hlme">lcmm::hlme</a> for details.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_random">random</code></td>
<td>
<p>The random effects formula. See <a href="lcmm.html#topic+hlme">lcmm::hlme</a> for details.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_classmb">classmb</code></td>
<td>
<p>The cluster membership formula for the multinomial logistic model. See <a href="lcmm.html#topic+hlme">lcmm::hlme</a> for details.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable. This replaces the <code>subject</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_init">init</code></td>
<td>
<p>Alternative for the <code>B</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>, for initializing the hlme fitting procedure.
This is only applicable for <code>nClusters &gt; 1</code>.
Options:
</p>

<ul>
<li> <p><code>"lme.random"</code> (default): random initialization through a standard linear mixed model. Assigns a fitted standard linear mixed model enclosed in a call to random() to the <code>B</code> argument.
</p>
</li>
<li> <p><code>"lme"</code>, fits a standard linear mixed model and passes this to the <code>B</code> argument.
</p>
</li>
<li> <p><code>"gridsearch"</code>, a gridsearch is used with initialization from <code>"lme.random"</code>, following the approach used by <a href="lcmm.html#topic+gridsearch">lcmm::gridsearch</a>. To use this initalization, specify arguments <code>gridsearch.maxiter</code> (max number of iterations during search), <code>gridsearch.rep</code> (number of fits during search), and <code>gridsearch.parallel</code> (whether to enable <a href="#topic+latrend-parallel">parallel computation</a>).
</p>
</li>
<li> <p><code>NULL</code> or <code>"default"</code>, the default <a href="lcmm.html#topic+hlme">lcmm::hlme</a> input for <code>B</code> is used.
</p>
</li></ul>

<p>The argument is ignored if the <code>B</code> argument is specified, or <code>nClusters = 1</code>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to fit. This replaces the <code>ng</code> argument of <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.</p>
</td></tr>
<tr><td><code id="lcMethodLcmmGMM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="lcmm.html#topic+hlme">lcmm::hlme</a>.
The following arguments are ignored: data, fixed, random, mixture, subject, classmb, returndata, ng, verbose, subset.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017).
&ldquo;Estimation of Extended Mixed Models Using Latent Classes and Latent Processes: The R Package lcmm.&rdquo;
<em>Journal of Statistical Software</em>, <b>78</b>(2), 1&ndash;56.
<a href="https://doi.org/10.18637/jss.v078.i02">doi:10.18637/jss.v078.i02</a>.
</p>
<p>Proust-Lima C, Philipps V, Diakite A, Liquet B (2019).
<em>lcmm: Extended Mixed Models Using Latent Classes and Latent Processes</em>.
R package version: 1.8.1, <a href="https://cran.r-project.org/package=lcmm">https://cran.r-project.org/package=lcmm</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (rlang::is_installed("lcmm")) {
  method &lt;- lcMethodLcmmGMM(
    fixed = Y ~ Time,
    mixture = ~ Time,
    random = ~ 1,
    id = "Id",
    time = "Time",
    nClusters = 2
  )
  gmm &lt;- latrend(method, data = latrendData)
  summary(gmm)

  # define method with gridsearch
  method &lt;- lcMethodLcmmGMM(
    fixed = Y ~ Time,
    mixture = ~ Time,
    random = ~ 1,
    id = "Id",
    time = "Time",
    nClusters = 3,
    init = "gridsearch",
    gridsearch.maxiter = 10,
    gridsearch.rep = 50,
    gridsearch.parallel = TRUE
  )
}
</code></pre>

<hr>
<h2 id='lcMethodLMKM'>Two-step clustering through linear regression modeling and k-means</h2><span id='topic+lcMethodLMKM'></span>

<h3>Description</h3>

<p>Two-step clustering through linear regression modeling and k-means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodLMKM(
  formula,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  center = meanNA,
  standardize = scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodLMKM_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> specifying the linear trajectory model.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_center">center</code></td>
<td>
<p>A  <code>function</code> that computes the cluster center based on the original trajectories associated with the respective cluster.
By default, the mean is computed.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_standardize">standardize</code></td>
<td>
<p>A <code>function</code> to standardize the output <code>matrix</code> of the representation step. By default, the output is shifted and rescaled to ensure zero mean and unit variance.</p>
</td></tr>
<tr><td><code id="lcMethodLMKM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="stats.html#topic+lm">stats::lm</a>.
The following external arguments are ignored: x, data, control, centers, trace.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 3)
model &lt;- latrend(method, latrendData)
</code></pre>

<hr>
<h2 id='lcMethodMclustLLPA'>Longitudinal latent profile analysis</h2><span id='topic+lcMethodMclustLLPA'></span>

<h3>Description</h3>

<p>Latent profile analysis or finite Gaussian mixture modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodMclustLLPA(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodMclustLLPA_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodMclustLLPA_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodMclustLLPA_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodMclustLLPA_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodMclustLLPA_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="mclust.html#topic+Mclust">mclust::Mclust</a>.
The following external arguments are ignored: data, G, verbose.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Scrucca L, Fop M, Murphy TB, Raftery AE (2016).
&ldquo;mclust 5: clustering, classification and density estimation using Gaussian finite mixture models.&rdquo;
<em>The R Journal</em>, <b>8</b>(1), 205&ndash;233.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
if (require("mclust")) {
  method &lt;- lcMethodMclustLLPA("Y", id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodMixAK_GLMM'>Specify a GLMM iwht a normal mixture in the random effects</h2><span id='topic+lcMethodMixAK_GLMM'></span>

<h3>Description</h3>

<p>Specify a GLMM iwht a normal mixture in the random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodMixAK_GLMM(
  fixed,
  random,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_fixed">fixed</code></td>
<td>
<p>A <code>formula</code> specifying the fixed effects of the model, including the response. Creates the <code>y</code> and <code>x</code> arguments for the call to <a href="mixAK.html#topic+GLMMMCMC">mixAK::GLMM_MCMC</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_random">random</code></td>
<td>
<p>A <code>formula</code> specifying the random effects of the model, including the random intercept. Creates the <code>z</code> and <code>random.intercept</code> arguments for the call to <a href="mixAK.html#topic+GLMMMCMC">mixAK::GLMM_MCMC</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable. This is used to generate the <code>id</code> vector argument for the call to <a href="mixAK.html#topic+GLMMMCMC">mixAK::GLMM_MCMC</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="lcMethodMixAK_GLMM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="mixAK.html#topic+GLMMMCMC">mixAK::GLMM_MCMC</a>.
The following external arguments are ignored: y, x, z, random.intercept, silent.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method currently does not appear to work under R 4.2 due to an error triggered by the mixAK package during fitting.
</p>


<h3>References</h3>

<p>Komárek A (2009).
&ldquo;A New R Package for Bayesian Estimation of Multivariate Normal Mixtures Allowing for Selection of the Number of Components and Interval-Censored Data.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>53</b>(12), 3932&ndash;3947.
<a href="https://doi.org/10.1016/j.csda.2009.05.006">doi:10.1016/j.csda.2009.05.006</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
# this example only runs when the mixAK package is installed
try({
 method &lt;- lcMethodMixAK_GLMM(fixed = Y ~ 1, random = ~ Time,
  id = "Id", time = "Time", nClusters = 3)
 model &lt;- latrend(method, latrendData)
 summary(model)
})
</code></pre>

<hr>
<h2 id='lcMethodMixtoolsGMM'>Specify mixed mixture regression model using mixtools</h2><span id='topic+lcMethodMixtoolsGMM'></span>

<h3>Description</h3>

<p>Specify mixed mixture regression model using mixtools
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodMixtoolsGMM(
  formula,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodMixtoolsGMM_+3A_formula">formula</code></td>
<td>
<p>Formula, including a random effects component for the trajectory. See <a href="lme4.html#topic+lmer">lme4::lmer</a> formula syntax.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsGMM_+3A_time">time</code></td>
<td>
<p>The name of the time variable..</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsGMM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsGMM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsGMM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="mixtools.html#topic+regmixEM.mixed">mixtools::regmixEM.mixed</a>.
The following arguments are ignored: data, y, x, w, k, addintercept.fixed, verb.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Benaglia T, Chauveau D, Hunter DR, Young D (2009).
&ldquo;mixtools: An R Package for Analyzing Finite Mixture Models.&rdquo;
<em>Journal of Statistical Software</em>, <b>32</b>(6), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v032.i06">doi:10.18637/jss.v032.i06</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(latrendData)

if (require("mixtools")) {
  method &lt;- lcMethodMixtoolsGMM(
    formula = Y ~ Time + (1 | Id),
    id = "Id", time = "Time",
    nClusters = 3,
    arb.R = FALSE
  )
}

</code></pre>

<hr>
<h2 id='lcMethodMixtoolsNPRM'>Specify non-parametric estimation for independent repeated measures</h2><span id='topic+lcMethodMixtoolsNPRM'></span>

<h3>Description</h3>

<p>Specify non-parametric estimation for independent repeated measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodMixtoolsNPRM(
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  blockid = NULL,
  bw = NULL,
  h = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters to estimate.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_blockid">blockid</code></td>
<td>
<p>See <a href="mixtools.html#topic+npEM">mixtools::npEM</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_bw">bw</code></td>
<td>
<p>See <a href="mixtools.html#topic+npEM">mixtools::npEM</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_h">h</code></td>
<td>
<p>See <a href="mixtools.html#topic+npEM">mixtools::npEM</a>.</p>
</td></tr>
<tr><td><code id="lcMethodMixtoolsNPRM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <a href="mixtools.html#topic+npEM">mixtools::npEM</a>.
The following optional arguments are ignored: data, x, mu0, verb.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Benaglia T, Chauveau D, Hunter DR, Young D (2009).
&ldquo;mixtools: An R Package for Analyzing Finite Mixture Models.&rdquo;
<em>Journal of Statistical Software</em>, <b>32</b>(6), 1&ndash;29.
<a href="https://doi.org/10.18637/jss.v032.i06">doi:10.18637/jss.v032.i06</a>.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("mixtools")) {
  method &lt;- lcMethodMixtoolsNPRM("Y", id = "Id", time = "Time", nClusters = 3)
  model &lt;- latrend(method, latrendData)
}
</code></pre>

<hr>
<h2 id='lcMethodMixTVEM'>Specify a MixTVEM</h2><span id='topic+lcMethodMixTVEM'></span>

<h3>Description</h3>

<p>Specify a MixTVEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodMixTVEM(
  formula,
  formula.mb = ~1,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodMixTVEM_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> excluding the time component. Time-invariant covariates are detected automatically as these are a special case in MixTVEM.</p>
</td></tr>
<tr><td><code id="lcMethodMixTVEM_+3A_formula.mb">formula.mb</code></td>
<td>
<p>A <code>formula</code> for cluster-membership prediction. Covariates must be time-invariant. Furthermore, the formula must contain an intercept.</p>
</td></tr>
<tr><td><code id="lcMethodMixTVEM_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixTVEM_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identifier variable.</p>
</td></tr>
<tr><td><code id="lcMethodMixTVEM_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters. This replaces the <code>numClasses</code> argument of the <code>TVEMMixNormal</code> function call.</p>
</td></tr>
<tr><td><code id="lcMethodMixTVEM_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>TVEMMixNormal()</code> function.
The following optional arguments are ignored: doPlot, getSEs, numClasses.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In order to use this method, you must download and source MixTVEM.R. See the reference below.
</p>


<h3>References</h3>

<p><a href="https://github.com/dziakj1/MixTVEM">https://github.com/dziakj1/MixTVEM</a>
</p>
<p>Dziak JJ, Li R, Tan X, Shiffman S, Shiyko MP (2015).
&ldquo;Modeling intensive longitudinal data with mixtures of nonparametric trajectories and time-varying effects.&rdquo;
<em>Psychological Methods</em>, <b>20</b>(4), 444&ndash;469.
ISSN 1939-1463.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this example only runs if you download and place MixTVEM.R in your wd
try({
  source("MixTVEM.R")
  method = lcMethodMixTVEM(
    Value ~ time(1) - 1,
    time = 'Assessment',
    id = "Id",
    nClusters = 3
  )
})

</code></pre>

<hr>
<h2 id='lcMethodRandom'>Specify a random-partitioning method</h2><span id='topic+lcMethodRandom'></span>

<h3>Description</h3>

<p>Creates a model with random cluster assignments according to the random cluster proportions drawn from a Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodRandom(
  response,
  alpha = 10,
  center = meanNA,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  nClusters = 2,
  name = "random",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodRandom_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_alpha">alpha</code></td>
<td>
<p>The Dirichlet parameters. Either <code>scalar</code> or of length <code>nClusters</code>. The higher alpha, the more uniform the clusters will be.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_center">center</code></td>
<td>
<p>Optional <code>function</code> for computing the longitudinal cluster centers, with signature <code>(x)</code>.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_name">name</code></td>
<td>
<p>The name of the method.</p>
</td></tr>
<tr><td><code id="lcMethodRandom_+3A_...">...</code></td>
<td>
<p>Additional arguments, such as the seed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Frigyik BA, Kapila A, Gupta MR (2010).
&ldquo;Introduction to the Dirichlet distribution and related processes.&rdquo;
Technical Report UWEETR-2010-0006, Department of Electrical Engineering, University of Washington.
</p>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodStratify">lcMethodStratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodRandom(response = "Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

# uniform clusters
method &lt;- lcMethodRandom(
  alpha = 1e3,
  nClusters = 3,
  response = "Y",
  id = "Id",
  time = "Time"
)

# single large cluster
method &lt;- lcMethodRandom(
  alpha = c(100, 1, 1, 1),
  nClusters = 4,
  response = "Y",
  id = "Id",
  time = "Time"
)
</code></pre>

<hr>
<h2 id='lcMethods'>Generate a list of lcMethod objects</h2><span id='topic+lcMethods'></span>

<h3>Description</h3>

<p>Generates a list of <code>lcMethod</code> objects for all combinations of the provided argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethods(method, ..., envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethods_+3A_method">method</code></td>
<td>
<p>The <code>lcMethod</code> to use as the template, which will be updated for each of the other arguments.</p>
</td></tr>
<tr><td><code id="lcMethods_+3A_...">...</code></td>
<td>
<p>Any other arguments to update the <code>lcMethod</code> definition with. Values must be <code>scalar</code>, <code>vector</code>, <code>list</code>, or encapsulated in a <code>.()</code> call.
Arguments wrapped in <code>.()</code> are passed as-is to the model call, ensuring a readable method.
Arguments comprising a single <code>symbol</code> (e.g. a variable name) are interpreted as a constant. To force evaluation, specify <code>arg=(var)</code> or <code>arg=force(var)</code>.
Arguments of type <code>vector</code> or <code>list</code> are split across a series of method fit calls.
Arguments of type <code>scalar</code> are constant across the method fits.
If a <code>list</code> is intended to be passed as a constant argument, then specifying <code>arg=.(listObject)</code> results in it being treated as such.</p>
</td></tr>
<tr><td><code id="lcMethods_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the method arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>lcMethod</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
baseMethod &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
methods &lt;- lcMethods(baseMethod, nClusters = 1:6)

nclus &lt;- 1:6
methods &lt;- lcMethods(baseMethod, nClusters = nclus)

# list notation, useful for providing functions
methods &lt;- lcMethods(baseMethod, nClusters = .(1, 3, 5))
length(methods) # 3
</code></pre>

<hr>
<h2 id='lcMethodStratify'>Specify a stratification method</h2><span id='topic+lcMethodStratify'></span>

<h3>Description</h3>

<p>Specify a stratification method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcMethodStratify(
  response,
  stratify,
  center = meanNA,
  nClusters = NaN,
  clusterNames = NULL,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  name = "stratify"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcMethodStratify_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_stratify">stratify</code></td>
<td>
<p>An <code>expression</code> returning a <code>number</code> or <code>factor</code> value per trajectory, representing the cluster assignment. Alternatively, a <code>function</code> can be provided that takes separate trajectory <code>data.frame</code> as input.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_center">center</code></td>
<td>
<p>The <code>function</code> for computing the longitudinal cluster centers, used for representing the cluster trajectories.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters. This is optional, as this can be derived from the largest assignment number by default, or the number of <code>factor</code> levels.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_clusternames">clusterNames</code></td>
<td>
<p>The names of the clusters. If a <code>factor</code> assignment is returned, the levels are used as the cluster names.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcMethodStratify_+3A_name">name</code></td>
<td>
<p>The name of the method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lcMethod implementations: 
<code><a href="#topic+getArgumentDefaults">getArgumentDefaults</a>()</code>,
<code><a href="#topic+getArgumentExclusions">getArgumentExclusions</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+lcMethodAkmedoids">lcMethodAkmedoids</a></code>,
<code><a href="#topic+lcMethodCrimCV">lcMethodCrimCV</a></code>,
<code><a href="#topic+lcMethodDtwclust">lcMethodDtwclust</a></code>,
<code><a href="#topic+lcMethodFeature">lcMethodFeature</a></code>,
<code><a href="#topic+lcMethodFunFEM">lcMethodFunFEM</a></code>,
<code><a href="#topic+lcMethodFunction">lcMethodFunction</a></code>,
<code><a href="#topic+lcMethodGCKM">lcMethodGCKM</a></code>,
<code><a href="#topic+lcMethodKML">lcMethodKML</a></code>,
<code><a href="#topic+lcMethodLMKM">lcMethodLMKM</a></code>,
<code><a href="#topic+lcMethodLcmmGBTM">lcMethodLcmmGBTM</a></code>,
<code><a href="#topic+lcMethodLcmmGMM">lcMethodLcmmGMM</a></code>,
<code><a href="#topic+lcMethodMclustLLPA">lcMethodMclustLLPA</a></code>,
<code><a href="#topic+lcMethodMixAK_GLMM">lcMethodMixAK_GLMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsGMM">lcMethodMixtoolsGMM</a></code>,
<code><a href="#topic+lcMethodMixtoolsNPRM">lcMethodMixtoolsNPRM</a></code>,
<code><a href="#topic+lcMethodRandom">lcMethodRandom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
# Stratification based on the mean response level
method &lt;- lcMethodStratify(
  "Y",
  mean(Y) &gt; 0,
  clusterNames = c("Low", "High"),
  id = "Id",
  time = "Time"
)
model &lt;- latrend(method, latrendData)
summary(model)

# Stratification function
stratfun &lt;- function(trajdata) {
   trajmean &lt;- mean(trajdata$Y)
   factor(
     trajmean &gt; 1.7,
     levels = c(FALSE, TRUE),
     labels = c("Low", "High")
   )
}
method &lt;- lcMethodStratify("Y", stratfun, id = "Id", time = "Time")

# Multiple clusters
stratfun3 &lt;- function(trajdata) {
   trajmean &lt;- mean(trajdata$Y)
   cut(
     trajmean,
     c(-Inf, .5, 2, Inf),
     labels = c("Low", "Medium", "High")
   )
}
method &lt;- lcMethodStratify("Y", stratfun3, id = "Id", time = "Time")
</code></pre>

<hr>
<h2 id='lcModel'>Longitudinal cluster result (<strong><code>lcModel</code></strong>)</h2><span id='topic+lcModel'></span>

<h3>Description</h3>

<p>A longitudinal cluster model (<code>[lcModel][lcModel-class]</code>) describes the clustered representation of a certain longitudinal dataset.
</p>
<p>A <code>lcModel</code> is obtained by estimating a specified <a href="#topic+lcMethod">longitudinal cluster method</a> on a <a href="#topic+latrend-data">longitudinal dataset</a>.
The estimation is done via one of the <a href="#topic+latrend-estimation">latrend estimation functions</a>.
</p>
<p>A longitudinal cluster result represents the dataset in terms of a partitioning of the trajectories into a number of clusters.
The <code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code> function outputs the most likely membership for the respective trajectories.
Each cluster has a longitudinal representation, obtained via <code><a href="#topic+clusterTrajectories">clusterTrajectories()</a></code>, and can be plotted via <code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories()</a></code>.
</p>


<h3>Functionality</h3>

<p><strong>Clusters and partitioning:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+nClusters">nClusters()</a></code>: The number of clusters this model represents.
</p>
</li>
<li> <p><code><a href="#topic+clusterNames">clusterNames()</a></code>: The names of the clusters.
</p>
</li>
<li> <p><code><a href="#topic+clusterSizes">clusterSizes()</a></code>: The respective number of trajectories assigned to each cluster.
</p>
</li>
<li> <p><code><a href="#topic+clusterProportions">clusterProportions()</a></code>: The respective proportional size of each cluster.
</p>
</li>
<li> <p><code><a href="#topic+trajectoryAssignments">trajectoryAssignments()</a></code>: The most likely cluster membership of each trajectory.
</p>
</li>
<li> <p><code><a href="#topic+postprob">postprob()</a></code>: The posterior probability of each trajectory to each cluster.
</p>
</li></ul>

<p><strong>Longitudinal cluster representation (i.e., trends):</strong>
</p>

<ul>
<li> <p><code><a href="#topic+clusterTrajectories">clusterTrajectories()</a></code>: A <code>data.frame</code> containing the longitudinal representation of each cluster.
</p>
</li>
<li> <p><code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories()</a></code>: Plots the longitudinal representation of each cluster.
</p>
</li>
<li> <p><code><a href="#topic+fittedTrajectories">fittedTrajectories()</a></code>: A <code>data.frame</code> containing the longitudinal representation of each trajectory. For many methods, this is the cluster center.
</p>
</li>
<li> <p><code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories()</a></code>: Plot the trajectory representation.
</p>
</li></ul>

<p><strong>Training data:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+nIds">nIds()</a></code>: The number of trajectories used for estimation.
</p>
</li>
<li> <p><code><a href="#topic+ids">ids()</a></code>: A vector of identifiers of the trajectories that were used for estimation.
</p>
</li>
<li> <p><code><a href="stats.html#topic+nobs">nobs()</a></code>: The number of observations used for estimation, across trajectories.
</p>
</li>
<li> <p><code><a href="stats.html#topic+time">time()</a></code>: Moments in time on which observations are present.
</p>
</li>
<li> <p><code><a href="#topic+trajectories">trajectories()</a></code>: The trajectories that were used for estimation.
</p>
</li>
<li> <p><code><a href="#topic+plotTrajectories">plotTrajectories()</a></code>: Plot the trajectories that were used for estimation.
</p>
</li></ul>

<p><strong>Model evaluation:</strong>
</p>

<ul>
<li> <p><code><a href="base.html#topic+summary">summary()</a></code>: Obtain a summary of the model.
</p>
</li>
<li> <p><code><a href="#topic+metric">metric()</a></code>: Compute an internal metric.
</p>
</li>
<li> <p><code><a href="#topic+externalMetric">externalMetric()</a></code>: Compute an external metric in relation to a second <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+converged">converged()</a></code>: Whether the estimation procedure converged.
</p>
</li>
<li> <p><code><a href="#topic+estimationTime">estimationTime()</a></code>: Total time that was needed for the fitting steps.
</p>
</li>
<li> <p><code><a href="stats.html#topic+sigma">sigma()</a></code>: Residual error scale.
</p>
</li>
<li> <p><code><a href="#topic+qqPlot">qqPlot()</a></code>: QQ plot of the model residuals.
</p>
</li></ul>

<p><strong>Model prediction:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+predictForCluster">predictForCluster()</a></code>: Cluster-specific prediction on new data. Not supported for all methods.
</p>
</li>
<li> <p><code><a href="#topic+predictPostprob">predictPostprob()</a></code>: Predict posterior probability for new data. Not supported for all methods.
</p>
</li>
<li> <p><code><a href="#topic+predictAssignments">predictAssignments()</a></code>: Predict cluster membership for new data. Not supported for all methods.
</p>
</li></ul>

<p><strong>Other functionality:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+getLcMethod">getLcMethod()</a></code>: Get the <a href="#topic+lcMethod">method specification</a> by which this model was estimated.
</p>
</li>
<li> <p><code><a href="stats.html#topic+update">update()</a></code>: Retrain a model with altered method arguments.
</p>
</li>
<li> <p><code><a href="#topic+strip">strip()</a></code>: Removes non-essential (meta) data and environments from the model to facilitate efficient serialization.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+lcModel-class">lcModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
# define the method
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
# estimate the method, giving the model
model &lt;- latrend(method, data = latrendData)

if (require("ggplot2")) {
  plotClusterTrajectories(model)
}
</code></pre>

<hr>
<h2 id='lcModel-class'><code>lcModel</code> class</h2><span id='topic+lcModel-class'></span>

<h3>Description</h3>

<p>Abstract class for defining estimated longitudinal cluster models.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModel-class_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="lcModel-class_+3A_...">...</code></td>
<td>
<p>Any additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An extending class must implement the following methods to ensure basic functionality:
</p>

<ul>
<li> <p><code>predict.lcModelExt</code>: Used to obtain the fitted cluster trajectories and trajectories.
</p>
</li>
<li> <p><code>postprob(lcModelExt)</code>: The posterior probability matrix is used to determine the cluster assignments of the trajectories.
</p>
</li></ul>

<p>For predicting the posterior probability for unseen data, the <code>predictPostprob()</code> should be implemented.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method</code></dt><dd><p>The <a href="#topic+lcMethod-class">lcMethod-class</a> object specifying the arguments under which the model was fitted.</p>
</dd>
<dt><code>call</code></dt><dd><p>The <code>call</code> that was used to create this <code>lcModel</code> object. Typically, this is the call to <code>latrend()</code> or any of the other fitting functions.</p>
</dd>
<dt><code>model</code></dt><dd><p>An arbitrary underlying model representation.</p>
</dd>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> object, or an expression to resolves to the <code>data.frame</code> object.</p>
</dd>
<dt><code>date</code></dt><dd><p>The date-time when the model estimation was initiated.</p>
</dd>
<dt><code>id</code></dt><dd><p>The name of the trajectory identifier column.</p>
</dd>
<dt><code>time</code></dt><dd><p>The name of the time variable.</p>
</dd>
<dt><code>response</code></dt><dd><p>The name of the response variable.</p>
</dd>
<dt><code>label</code></dt><dd><p>The label assigned to this model.</p>
</dd>
<dt><code>ids</code></dt><dd><p>The trajectory identifier values the model was fitted on.</p>
</dd>
<dt><code>times</code></dt><dd><p>The exact times on which the model has been trained</p>
</dd>
<dt><code>clusterNames</code></dt><dd><p>The names of the clusters.</p>
</dd>
<dt><code>estimationTime</code></dt><dd><p>The time, in seconds, that it took to fit the model.</p>
</dd>
<dt><code>tag</code></dt><dd><p>An arbitrary user-specified data structure. This slot may be accessed and updated directly.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='lcModel-data-filters'>Data filters for lcModel</h2><span id='topic+lcModel-data-filters'></span><span id='topic+bootSample'></span><span id='topic+trainFold'></span><span id='topic+testFold'></span>

<h3>Description</h3>

<p>The data filters are applied by <a href="#topic+latrend">latrend</a> prior to model estimation. These filters are used in <a href="#topic+latrendBoot">latrendBoot</a> and <a href="#topic+latrendCV">latrendCV</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootSample(data, id, seed = NULL)

trainFold(data, fold, id, folds, seed)

testFold(data, fold, id, folds, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModel-data-filters_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> representing the model dataset.</p>
</td></tr>
<tr><td><code id="lcModel-data-filters_+3A_id">id</code></td>
<td>
<p>The identifier variable name, see <a href="#topic+idVariable">idVariable</a>.</p>
</td></tr>
<tr><td><code id="lcModel-data-filters_+3A_seed">seed</code></td>
<td>
<p>Optional seed for ensuring reproducibility.</p>
</td></tr>
<tr><td><code id="lcModel-data-filters_+3A_fold">fold</code></td>
<td>
<p>The fold to select.</p>
</td></tr>
<tr><td><code id="lcModel-data-filters_+3A_folds">folds</code></td>
<td>
<p>Total number of folds to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of <code>data</code> of type <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>
</p>
<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>
</p>
<p>Other validation methods: 
<code><a href="#topic+createTestDataFold">createTestDataFold</a>()</code>,
<code><a href="#topic+createTestDataFolds">createTestDataFolds</a>()</code>,
<code><a href="#topic+createTrainDataFolds">createTrainDataFolds</a>()</code>,
<code><a href="#topic+latrendBoot">latrendBoot</a>()</code>,
<code><a href="#topic+latrendCV">latrendCV</a>()</code>
</p>

<hr>
<h2 id='lcModel-make'>Cluster-handling functions for lcModel implementations.</h2><span id='topic+lcModel-make'></span><span id='topic+make.trajectoryAssignments'></span><span id='topic+make.clusterIndices'></span><span id='topic+make.clusterNames'></span><span id='topic+make.clusterSizeLabels'></span><span id='topic+make.clusterPropLabels'></span>

<h3>Description</h3>

<p>Ensures a proper cluster assignments factor vector
</p>
<p>Generates the requested number of cluster names. Uses the vector returned by <code>getOption("latrend.clusterNames")</code>, which returns the alphabet by default.
</p>
<p><code>make.clusterSizeLabels</code> generates cluster labels for the given input
</p>
<p><code>make.clusterPropLabels</code> generates cluster labels for the given input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.trajectoryAssignments(object, clusters)

make.clusterIndices(object, clusters)

make.clusterNames(n)

make.clusterSizeLabels(clusterNames, sizes)

make.clusterPropLabels(clusterNames, sizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModel-make_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="lcModel-make_+3A_clusters">clusters</code></td>
<td>
<p>The unprocessed trajectory cluster assignment vector.</p>
</td></tr>
<tr><td><code id="lcModel-make_+3A_n">n</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="lcModel-make_+3A_clusternames">clusterNames</code></td>
<td>
<p>Names of the clusters</p>
</td></tr>
<tr><td><code id="lcModel-make_+3A_sizes">sizes</code></td>
<td>
<p>Sizes of the respective clusters; the number of ids</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>latrend.clusterNames</code> option may also return a function with signature <code>(n)</code>, returning a vector of names of the correct length.
</p>


<h3>Value</h3>

<p>Factor cluster assignments.
</p>
<p>A cluster assignments index vector of type <code>integer</code>.
</p>
<p>A <code>character</code> vector length <code>n</code> with the cluster names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.clusterSizeLabels(c('A', 'B'), c(10, 20))
make.clusterPropLabels(c('A', 'B'), c(10, 20))
</code></pre>

<hr>
<h2 id='lcModelPartition'>Create a lcModel with pre-defined partitioning</h2><span id='topic+lcModelPartition'></span>

<h3>Description</h3>

<p>Represents an arbitrary partitioning of a set of trajectories.
As such, this model has no predictive capabilities. The cluster trajectories are represented by the specified center function (mean by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcModelPartition(
  data,
  response,
  trajectoryAssignments,
  nClusters = NA,
  clusterNames = character(),
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  name = "part",
  center = meanNA,
  method = NULL,
  converged = TRUE,
  model = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModelPartition_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the trajectory data.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_trajectoryassignments">trajectoryAssignments</code></td>
<td>
<p>A <code>vector</code> of cluster membership per trajectory, a <code>data.frame</code> with an id column and <code>"Cluster"</code> column, or the name of the cluster membership column in the <code>data</code> argument..
For <code>vector</code> input, the type must be <code>factor</code>, <code>character</code>, or <code>integer</code> (<code>1</code> to <code>nClusters</code>).
The order of the trajectory, and thus the respective assignments, is determined by the id column of the data.
Provide a <code>factor</code> id column for the input data to ensure that the ordering is as you aspect.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_nclusters">nClusters</code></td>
<td>
<p>The number of clusters. Should be <code>NA</code> for trajectory assignments of type <code>factor</code>.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_clusternames">clusterNames</code></td>
<td>
<p>The names of the clusters, or a function with input <code>n</code> outputting a <code style="white-space: pre;">&#8288;character vector&#8288;</code> of names.
If unspecified, the names are determined from the <code>trajectoryAssignments</code> argument.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_name">name</code></td>
<td>
<p>The name of the method.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_center">center</code></td>
<td>
<p>The <code>function</code> for computing the longitudinal cluster centers, used for representing the cluster trajectories.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_method">method</code></td>
<td>
<p>Optional <code>lcMethod</code> object that was used for fitting this model to the data.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_converged">converged</code></td>
<td>
<p>Set the converged state.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_model">model</code></td>
<td>
<p>An optional object to attach to the <code>lcModelPartition</code> object, representing the internal model that was used for obtaining the partition.</p>
</td></tr>
<tr><td><code id="lcModelPartition_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> associated with the model. Used for evaluating the assigned <code>data</code> object by <a href="#topic+model.data.lcModel">model.data.lcModel</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># comparing a model to the ground truth using the adjusted Rand index
data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 3)

# extract the reference class from the Class column
trajLabels &lt;- aggregate(Class ~ Id, head, 1, data = latrendData)
trajLabels$Cluster &lt;- trajLabels$Class
refModel &lt;- lcModelPartition(latrendData, response = "Y", trajectoryAssignments = trajLabels)

if (require("mclustcomp")) {
  externalMetric(model, refModel, "adjustedRand")
}
</code></pre>

<hr>
<h2 id='lcModels'>Construct a list of <code>lcModel</code> objects</h2><span id='topic+lcModels'></span>

<h3>Description</h3>

<p><a href="#topic+lcModels-class">A general overview of the lcModels class can be found here</a>.
</p>
<p>The <code>lcModels()</code> function creates a flat (named) list of <code>lcModel</code> objects. Duplicates are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcModels(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModels_+3A_...">...</code></td>
<td>
<p><code>lcModel</code>, <code>lcModels</code>, or a recursive <code>list</code> of <code>lcModel</code> objects. Arguments may be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcModels</code> object containing all specified <code>lcModel</code> objects.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lmkmMethod &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
lmkmModel &lt;- latrend(lmkmMethod, latrendData)
rngMethod &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
rngModel &lt;- latrend(rngMethod, latrendData)

lcModels(lmkmModel, rngModel)

lcModels(defaults = c(lmkmModel, rngModel))
</code></pre>

<hr>
<h2 id='lcModels-class'><code>lcModels</code>: a list of <code>lcModel</code> objects</h2><span id='topic+lcModels-class'></span>

<h3>Description</h3>

<p>The <code>lcModels</code> <code>S3</code> class represents a <code>list</code> of one or more <code>lcModel</code> objects.
This makes it easier to work with a collection of models in a more structured manner.
</p>
<p>A list of models is outputted from the repeated estimation functions such as <code><a href="#topic+latrendRep">latrendRep()</a></code>, <code><a href="#topic+latrendBatch">latrendBatch()</a></code>, and <a href="#topic+latrend-estimation">others</a>.
You can construct a list of models using the <code><a href="#topic+lcModels">lcModels()</a></code> function.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
models &lt;- latrendRep(method, data = latrendData, .rep = 5) # 5 repeated runs

bestModel &lt;- min(models, "MAE")
</code></pre>

<hr>
<h2 id='lcModelWeightedPartition'>Create a lcModel with pre-defined weighted partitioning</h2><span id='topic+lcModelWeightedPartition'></span>

<h3>Description</h3>

<p>Create a lcModel with pre-defined weighted partitioning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcModelWeightedPartition(
  data,
  response,
  weights,
  clusterNames = colnames(weights),
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  name = "wpart"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcModelWeightedPartition_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the trajectory data.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_response">response</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_weights">weights</code></td>
<td>
<p>A <code>numIds</code> x <code>numClusters</code> matrix of partition probabilities.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_clusternames">clusterNames</code></td>
<td>
<p>The names of the clusters, or a function with input <code>n</code> outputting a <code style="white-space: pre;">&#8288;character vector&#8288;</code> of names.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_time">time</code></td>
<td>
<p>The name of the time variable.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_id">id</code></td>
<td>
<p>The name of the trajectory identification variable.</p>
</td></tr>
<tr><td><code id="lcModelWeightedPartition_+3A_name">name</code></td>
<td>
<p>The name of the method.</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.lcModel'>Extract the log-likelihood of a lcModel</h2><span id='topic+logLik.lcModel'></span>

<h3>Description</h3>

<p>Extract the log-likelihood of a lcModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="logLik.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default implementation checks for the existence of the <code>logLik()</code> function for the internal model, and returns the output, if available.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> with the computed log-likelihood. If unavailable, <code>NA</code> is returned.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+logLik">stats::logLik</a> <a href="#topic+metric">metric</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (rlang::is_installed("lcmm")) {
  method &lt;- lcMethodLcmmGBTM(
    fixed = Y ~ Time,
    mixture = ~ 1,
    id = "Id",
    time = "Time",
    nClusters = 3
  )
  gbtm &lt;- latrend(method, data = latrendData)
  logLik(gbtm)
}
</code></pre>

<hr>
<h2 id='match.call.all'>Argument matching with defaults and parent ellipsis expansion</h2><span id='topic+match.call.all'></span>

<h3>Description</h3>

<p>Returns a call containing all arguments in specified form, including default arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.call.all(n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.call.all_+3A_n">n</code></td>
<td>
<p>The number of frames to go back on the calling stack. See <a href="base.html#topic+sys.parent">base::sys.parent</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>call</code>
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+match.call">base::match.call</a> <a href="base.html#topic+sys.parent">base::sys.parent</a>
</p>

<hr>
<h2 id='max.lcModels'>Select the lcModel with the highest metric value</h2><span id='topic+max.lcModels'></span>

<h3>Description</h3>

<p>Select the lcModel with the highest metric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModels'
max(x, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max.lcModels_+3A_x">x</code></td>
<td>
<p>The <code>lcModels</code> object.</p>
</td></tr>
<tr><td><code id="max.lcModels_+3A_name">name</code></td>
<td>
<p>The name of the internal metric.</p>
</td></tr>
<tr><td><code id="max.lcModels_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lcModel with the highest metric value
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+min.lcModels">min.lcModels</a> <a href="#topic+externalMetric">externalMetric</a>
</p>
<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")

model1 &lt;- latrend(method, latrendData, nClusters = 1)
model2 &lt;- latrend(method, latrendData, nClusters = 2)
model3 &lt;- latrend(method, latrendData, nClusters = 3)

models &lt;- lcModels(model1, model2, model3)

if (require("clusterCrit")) {
  max(models, "Dunn")
}
</code></pre>

<hr>
<h2 id='meanNA'>Mean ignoring NAs</h2><span id='topic+meanNA'></span>

<h3>Description</h3>

<p>Mean ignoring NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanNA(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanNA_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.  Currently there are methods for
numeric/logical vectors and <a href="base.html#topic+Dates">date</a>,
<a href="base.html#topic+date-time">date-time</a> and <a href="base.html#topic+time+20interval">time interval</a> objects.  Complex vectors
are allowed for <code>trim = 0</code>, only.</p>
</td></tr>
<tr><td><code id="meanNA_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='metric'>Compute internal model metric(s)</h2><span id='topic+metric'></span><span id='topic+metric+2ClcModel-method'></span><span id='topic+internalMetric'></span><span id='topic+metric+2Clist-method'></span><span id='topic+metric+2ClcModels-method'></span>

<h3>Description</h3>

<p>Compute one or more internal metrics for the given <code>lcModel</code> object.
</p>
<p>Note that there are many metrics available, and there exists no metric that works best in all scenarios.
It is recommended to carefully consider which metric is most appropriate for your use case.
</p>
<p>Recommended overview papers:
</p>

<ul>
<li> <p>Arbelaitz et al. (2013) provide an extensive overview validity indices for cluster algorithms.
</p>
</li>
<li> <p>van der Nest et al. (2020) provide an overview of metrics for mixture models (GBTM, GMM); primarily likelihood-based or posterior probability-based metrics.
</p>
</li>
<li> <p>Henson et al. (2007) provide an overview of likelihood-based metrics for mixture models.
</p>
</li></ul>

<p>Call <code><a href="#topic+getInternalMetricNames">getInternalMetricNames()</a></code> to retrieve the names of the defined internal metrics.
</p>
<p>See the <em>Details</em> section below for a list of supported metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric(object, name = getOption("latrend.metric", c("WRSS", "APPA.mean")), ...)

## S4 method for signature 'lcModel'
metric(object, name = getOption("latrend.metric", c("WRSS", "APPA.mean")), ...)

## S4 method for signature 'list'
metric(object, name, drop = TRUE)

## S4 method for signature 'lcModels'
metric(object, name, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code>, <code>lcModels</code>, or <code>list</code> of <code>lcModel</code> objects to compute the metrics for.</p>
</td></tr>
<tr><td><code id="metric_+3A_name">name</code></td>
<td>
<p>The name(s) of the metric(s) to compute. If no names are given, the names specified in the <code>latrend.metric</code> option (WRSS, APPA, AIC, BIC) are used.</p>
</td></tr>
<tr><td><code id="metric_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="metric_+3A_drop">drop</code></td>
<td>
<p>Whether to return a <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> instead of a <code>data.frame</code>
in case of a single metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>metric(lcModel)</code>: A named <code>numeric</code> vector with the computed model metrics.
</p>
<p>For <code>metric(list)</code>: A <code>data.frame</code> with a metric per column.
</p>
<p>For <code>metric(lcModels)</code>: A <code>data.frame</code> with a metric per column.
</p>


<h3>Supported internal metrics</h3>


<table>
<tr>
 <td style="text-align: left;">
   <strong>Metric name</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Function / Reference</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>AIC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">Akaike information criterion</a>. A goodness-of-fit estimator that adjusts for model complexity (i.e., the number of parameters). Only available for models that support the computation of the model log-likelihood through <a href="stats.html#topic+logLik">logLik</a>. </td><td style="text-align: left;"> <code><a href="stats.html#topic+AIC">stats::AIC()</a></code>, (Akaike 1974) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>APPA.mean</code> </td><td style="text-align: left;"> Mean of the average posterior probability of assignment (APPA) across clusters. A measure of the precision of the trajectory classifications. A score of 1 indicates perfect classification. </td><td style="text-align: left;"> <code><a href="#topic+APPA">APPA()</a></code>, (Nagin 2005) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>APPA.min</code> </td><td style="text-align: left;"> Lowest APPA among the clusters </td><td style="text-align: left;"> <code><a href="#topic+APPA">APPA()</a></code>, (Nagin 2005) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ASW</code> </td><td style="text-align: left;"> Average <a href="https://en.wikipedia.org/wiki/Silhouette_(clustering)">silhouette</a> width based on the Euclidean distance </td><td style="text-align: left;"> (Rousseeuw 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>BIC</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian information criterion</a>. A goodness-of-fit estimator that corrects for the degrees of freedom (i.e., the number of parameters) and sample size. Only available for models that support the computation of the model log-likelihood through <a href="stats.html#topic+logLik">logLik</a>. </td><td style="text-align: left;"> <code><a href="stats.html#topic+AIC">stats::BIC()</a></code>, (Schwarz 1978) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CAIC</code> </td><td style="text-align: left;"> Consistent Akaike information criterion </td><td style="text-align: left;"> (Bozdogan 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>CLC</code> </td><td style="text-align: left;"> Classification likelihood criterion </td><td style="text-align: left;"> (McLachlan and Peel 2000) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>converged</code> </td><td style="text-align: left;"> Whether the model converged during estimation </td><td style="text-align: left;"> <code><a href="#topic+converged">converged()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>deviance</code> </td><td style="text-align: left;"> The model <a href="https://en.wikipedia.org/wiki/Deviance_(statistics)">deviance</a> </td><td style="text-align: left;"> <code><a href="stats.html#topic+deviance">stats::deviance()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Dunn</code> </td><td style="text-align: left;"> The <a href="https://en.wikipedia.org/wiki/Dunn_index">Dunn index</a> </td><td style="text-align: left;"> (Dunn 1974) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>entropy</code> </td><td style="text-align: left;"> Entropy of the posterior probabilities </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>estimationTime</code> </td><td style="text-align: left;"> The time needed for fitting the model </td><td style="text-align: left;"> <code><a href="#topic+estimationTime">estimationTime()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ED</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ED.fit</code> </td><td style="text-align: left;"> Euclidean distance between the cluster trajectories and the assigned fitted trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ICL.BIC</code> </td><td style="text-align: left;"> Integrated classification likelihood (ICL) approximated using the BIC </td><td style="text-align: left;"> (Biernacki et al. 2000) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>logLik</code> </td><td style="text-align: left;"> Model log-<a href="https://en.wikipedia.org/wiki/Likelihood_function">likelihood</a> </td><td style="text-align: left;"> <code><a href="stats.html#topic+logLik">stats::logLik()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MAE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mean_absolute_error">Mean absolute error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Mahalanobis</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mahalanobis_distance">Mahalanobis distance</a> between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;"> (Mahalanobis 1936) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MSE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Mean_squared_error">Mean squared error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>relativeEntropy</code>, <code>RE</code> </td><td style="text-align: left;"> A measure of the precision of the trajectory classification. A value of 1 indicates perfect classification, whereas a value of 0 indicates a non-informative uniform classification. It is the normalized version of <code>entropy</code>, scaled between [0, 1]. </td><td style="text-align: left;"> (Ramaswamy et al. 1993), (Muthén 2004) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RMSE</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">Root mean squared error</a> of the fitted trajectories (assigned to the most likely respective cluster) to the observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>RSS</code> </td><td style="text-align: left;"> <a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">Residual sum of squares</a> under most likely cluster allocation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>scaledEntropy</code> </td><td style="text-align: left;"> See <code>relativeEntropy</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>sigma</code> </td><td style="text-align: left;"> The residual standard deviation </td><td style="text-align: left;"> <code><a href="stats.html#topic+sigma">stats::sigma()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ssBIC</code> </td><td style="text-align: left;"> Sample-size adjusted BIC </td><td style="text-align: left;"> (Sclove 1987) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SED</code> </td><td style="text-align: left;"> Standardized Euclidean distance between the cluster trajectories and the assigned observed trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>SED.fit</code> </td><td style="text-align: left;"> The cluster-weighted standardized Euclidean distance between the cluster trajectories and the assigned fitted trajectories </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMAE</code> </td><td style="text-align: left;"> <code>MAE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WMSE</code> </td><td style="text-align: left;"> <code>MSE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WRMSE</code> </td><td style="text-align: left;"> <code>RMSE</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>WRSS</code> </td><td style="text-align: left;"> <code>RSS</code> weighted by cluster-assignment probability </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Implementation</h3>

<p>See the documentation of the <code><a href="#topic+defineInternalMetric">defineInternalMetric()</a></code> function for details on how to define your own metrics.
</p>


<h3>References</h3>

<p>Akaike H (1974).
&ldquo;A new look at the statistical model identification.&rdquo;
<em>IEEE Transactions on Automatic Control</em>, <b>19</b>(6), 716-723.
<a href="https://doi.org/10.1109/TAC.1974.1100705">doi:10.1109/TAC.1974.1100705</a>.<br /><br /> Arbelaitz O, Gurrutxaga I, Muguerza J, Pérez JM, Perona I (2013).
&ldquo;An extensive comparative study of cluster validity indices.&rdquo;
<em>Pattern recognition</em>, <b>46</b>(1), 243&ndash;256.
ISSN 0031-3203, <a href="https://doi.org/10.1016/j.patcog.2012.07.021">doi:10.1016/j.patcog.2012.07.021</a>.<br /><br /> Biernacki C, Celeux G, Govaert G (2000).
&ldquo;Assessing a mixture model for clustering with the integrated completed likelihood.&rdquo;
<em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, <b>22</b>(7), 719-725.
<a href="https://doi.org/10.1109/34.865189">doi:10.1109/34.865189</a>.<br /><br /> Bozdogan H (1987).
&ldquo;Model Selection and Akaike's Information Criterion (AIC): The General Theory and Its Analytical Extensions.&rdquo;
<em>Psychometrika</em>, <b>52</b>, 345&ndash;370.
<a href="https://doi.org/10.1007/BF02294361">doi:10.1007/BF02294361</a>.<br /><br /> Dunn JC (1974).
&ldquo;Well-Separated Clusters and Optimal Fuzzy Partitions.&rdquo;
<em>Journal of Cybernetics</em>, <b>4</b>(1), 95-104.
<a href="https://doi.org/10.1080/01969727408546059">doi:10.1080/01969727408546059</a>.<br /><br /> Henson JM, Reise SP, Kim KH (2007).
&ldquo;Detecting Mixtures From Structural Model Differences Using Latent Variable Mixture Modeling: A Comparison of Relative Model Fit Statistics.&rdquo;
<em>Structural Equation Modeling: A Multidisciplinary Journal</em>, <b>14</b>(2), 202&ndash;226.
<a href="https://doi.org/10.1080/10705510709336744">doi:10.1080/10705510709336744</a>.<br /><br /> Mahalanobis PC (1936).
&ldquo;On the generalized distance in statistics.&rdquo;
<em>Proceedings of the National Institute of Sciences (Calcutta)</em>, <b>2</b>(1), 49&ndash;55.<br /><br /> McLachlan G, Peel D (2000).
<em>Finite Mixture Models</em>.
John Wiley &amp; Sons, Inc.
ISBN 9780471006268.<br /><br /> Muthén B (2004).
&ldquo;Latent variable analysis: Growth mixture modeling and related techniques for longitudinal data.&rdquo;
In <em>The SAGE Handbook of Quantitative Methodology for the Social Sciences</em>, 346&ndash;369.
SAGE Publications, Inc.
<a href="https://doi.org/10.4135/9781412986311.n19">doi:10.4135/9781412986311.n19</a>.<br /><br /> Nagin DS (2005).
<em>Group-based modeling of development</em>.
Harvard University Press.
ISBN 9780674041318, <a href="https://doi.org/10.4159/9780674041318">doi:10.4159/9780674041318</a>.<br /><br /> Ramaswamy V, Desarbo W, Reibstein D, Robinson W (1993).
&ldquo;An Empirical Pooling Approach for Estimating Marketing Mix Elasticities with PIMS Data.&rdquo;
<em>Marketing Science</em>, <b>12</b>(1), 103-124.
<a href="https://doi.org/10.1287/mksc.12.1.103">doi:10.1287/mksc.12.1.103</a>.<br /><br /> Rousseeuw PJ (1987).
&ldquo;Silhouettes: A graphical aid to the interpretation and validation of cluster analysis.&rdquo;
<em>Journal of Computational and Applied Mathematics</em>, <b>20</b>, 53-65.
ISSN 0377-0427, <a href="https://doi.org/10.1016/0377-0427%2887%2990125-7">doi:10.1016/0377-0427(87)90125-7</a>.<br /><br /> Schwarz G (1978).
&ldquo;Estimating the Dimension of a Model.&rdquo;
<em>The Annals of Statistics</em>, <b>6</b>(2), 461 &ndash; 464.<br /><br /> Sclove SL (1987).
&ldquo;Application of model-selection criteria to some problems in multivariate analysis.&rdquo;
<em>Psychometrika</em>, <b>52</b>(3), 333&ndash;343.
<a href="https://doi.org/10.1007/BF02294360">doi:10.1007/BF02294360</a>.<br /><br /> van der Nest G, Lima Passos V, Candel MJ, van Breukelen GJ (2020).
&ldquo;An overview of mixture modelling for latent evolutions in longitudinal data: Modelling approaches, fit statistics and software.&rdquo;
<em>Advances in Life Course Research</em>, <b>43</b>, 100323.
ISSN 1040-2608, <a href="https://doi.org/10.1016/j.alcr.2019.100323">doi:10.1016/j.alcr.2019.100323</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+externalMetric">externalMetric</a> <a href="#topic+min.lcModels">min.lcModels</a> <a href="#topic+max.lcModels">max.lcModels</a>
</p>
<p>Other metric functions: 
<code><a href="#topic+defineExternalMetric">defineExternalMetric</a>()</code>,
<code><a href="#topic+defineInternalMetric">defineInternalMetric</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+getExternalMetricDefinition">getExternalMetricDefinition</a>()</code>,
<code><a href="#topic+getExternalMetricNames">getExternalMetricNames</a>()</code>,
<code><a href="#topic+getInternalMetricDefinition">getInternalMetricDefinition</a>()</code>,
<code><a href="#topic+getInternalMetricNames">getInternalMetricNames</a>()</code>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
metric(model, "WMAE")

if (require("clusterCrit")) {
  metric(model, c("WMAE", "Dunn"))
}
</code></pre>

<hr>
<h2 id='min.lcModels'>Select the lcModel with the lowest metric value</h2><span id='topic+min.lcModels'></span>

<h3>Description</h3>

<p>Select the lcModel with the lowest metric value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModels'
min(x, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min.lcModels_+3A_x">x</code></td>
<td>
<p>The <code>lcModels</code> object</p>
</td></tr>
<tr><td><code id="min.lcModels_+3A_name">name</code></td>
<td>
<p>The name of the internal metric.</p>
</td></tr>
<tr><td><code id="min.lcModels_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lcModel with the lowest metric value
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+max.lcModels">max.lcModels</a> <a href="#topic+externalMetric">externalMetric</a>
</p>
<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")

model1 &lt;- latrend(method, latrendData, nClusters = 1)
model2 &lt;- latrend(method, latrendData, nClusters = 2)
model3 &lt;- latrend(method, latrendData, nClusters = 3)

models &lt;- lcModels(model1, model2, model3)

min(models, "WMAE")
</code></pre>

<hr>
<h2 id='model.data'>Extract the model training data</h2><span id='topic+model.data'></span>

<h3>Description</h3>

<p>Extract the model training data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.data(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.data_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="model.data_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='model.data.lcModel'>Extract the model data that was used for fitting</h2><span id='topic+model.data.lcModel'></span>

<h3>Description</h3>

<p>Evaluates the data call in the environment that the model was trained in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
model.data(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.data.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="model.data.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full <code>data.frame</code> that was used for fitting the <code>lcModel</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+model.frame.lcModel">model.frame.lcModel</a> <a href="#topic+time.lcModel">time.lcModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
model.data(model)
</code></pre>

<hr>
<h2 id='model.frame.lcModel'>Extract model training data</h2><span id='topic+model.frame.lcModel'></span>

<h3>Description</h3>

<p>See <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.lcModel_+3A_formula">formula</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="model.frame.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the variables used by the model.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+model.frame">stats::model.frame</a> <a href="#topic+model.data.lcModel">model.data.lcModel</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, data = latrendData)
model.frame(model)
</code></pre>

<hr>
<h2 id='names+2ClcMethod-method'>lcMethod argument names</h2><span id='topic+names+2ClcMethod-method'></span><span id='topic+length+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Extract the argument names or number of arguments from an <code>lcMethod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcMethod'
length(x)

## S4 method for signature 'lcMethod'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2ClcMethod-method_+3A_x">x</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of arguments, as <code style="white-space: pre;">&#8288;scalar integer&#8288;</code>.
</p>
<p>A <code style="white-space: pre;">&#8288;character vector&#8288;</code> of argument names.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+update.lcMethod">update.lcMethod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time)
names(method)
length(method)
</code></pre>

<hr>
<h2 id='nClusters'>Number of clusters</h2><span id='topic+nClusters'></span><span id='topic+nClusters+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the number of clusters estimated by the given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nClusters(object, ...)

## S4 method for signature 'lcModel'
nClusters(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nClusters_+3A_object">object</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="nClusters_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of clusters: a scalar <code>numeric</code> non-zero count.
</p>


<h3>See Also</h3>

<p><a href="#topic+nIds">nIds</a> <a href="stats.html#topic+nobs">nobs</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time", nClusters = 3)
model &lt;- latrend(method, latrendData)
nClusters(model) # 3
</code></pre>

<hr>
<h2 id='nIds'>Number of trajectories</h2><span id='topic+nIds'></span>

<h3>Description</h3>

<p>Get the number of trajectories (strata) that were used for fitting the given <code>lcModel</code> object.
The number of trajectories is determined from the number of unique identifiers in the training data. In case the trajectory ids were supplied using a <code>factor</code> column, the number of trajectories is determined by the number of levels instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nIds(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nIds_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>integer</code> with the number of trajectories on which the <code>lcModel</code> was fitted.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+nobs">nobs</a> <a href="#topic+nClusters">nClusters</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
nIds(model)
</code></pre>

<hr>
<h2 id='nobs.lcModel'>Number of observations used for the lcModel fit</h2><span id='topic+nobs.lcModel'></span>

<h3>Description</h3>

<p>Extracts the number of observations that contributed information towards fitting the cluster trajectories of the respective <code>lcModel</code> object.
Therefore, only non-missing response observations count towards the number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="nobs.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+nIds">nIds</a> <a href="#topic+nClusters">nClusters</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
nobs(model)
</code></pre>

<hr>
<h2 id='OCC'>Odds of correct classification (OCC)</h2><span id='topic+OCC'></span>

<h3>Description</h3>

<p>Computes the odds of correct classification (OCC) for each cluster.
In other words, it computes the proportion of trajectories that can be expected to be correctly classified by the model for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCC_+3A_object">object</code></td>
<td>
<p>The model, of type <code>lcModel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An OCC of 1 indicates that the cluster assignment is no better than by random chance.
</p>


<h3>Value</h3>

<p>The OCC per cluster, as a <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of length <code>nClusters(object)</code>.
Empty clusters will output <code>NA</code>.
</p>


<h3>References</h3>

<p>Nagin DS (2005).
<em>Group-based modeling of development</em>.
Harvard University Press.
ISBN 9780674041318, <a href="https://doi.org/10.4159/9780674041318">doi:10.4159/9780674041318</a>.
Klijn SL, Weijenberg MP, Lemmens P, van den Brandt PA, Passos VL (2017).
&ldquo;Introducing the fit-criteria assessment plot - A visualisation tool to assist class enumeration in group-based trajectory modelling.&rdquo;
<em>Statistical Methods in Medical Research</em>, <b>26</b>(5), 2424-2436.
van der Nest G, Lima Passos V, Candel MJ, van Breukelen GJ (2020).
&ldquo;An overview of mixture modelling for latent evolutions in longitudinal data: Modelling approaches, fit statistics and software.&rdquo;
<em>Advances in Life Course Research</em>, <b>43</b>, 100323.
ISSN 1040-2608, <a href="https://doi.org/10.1016/j.alcr.2019.100323">doi:10.1016/j.alcr.2019.100323</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+confusionMatrix">confusionMatrix</a> <a href="#topic+APPA">APPA</a>
</p>

<hr>
<h2 id='PAP.adh'>Weekly Mean PAP Therapy Usage of OSA Patients in the First 3 Months</h2><span id='topic+PAP.adh'></span>

<h3>Description</h3>

<p>A simulated longitudinal dataset comprising 301 patients with obstructive sleep apnea (OSA)
during their first 91 days (13 weeks) of PAP therapy.
The longitudinal patterns were inspired by the adherence patterns reported by Yi et al. (2022),
interpolated to weekly hours of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PAP.adh
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> comprising longitudinal data of 500 patients, each having 26 observations
over a period of 1 year.
Each row represents a patient observation interval (two weeks), with columns:
</p>

<dl>
<dt>Patient</dt><dd><p><code>integer</code>: The patient identifier, where each level represents a simulated patient.</p>
</dd>
<dt>Week</dt><dd><p><code>integer</code>: The week number, starting from 1.</p>
</dd>
<dt>UsageHours</dt><dd><p><code>numeric</code>: The mean hours of usage in the respective week.
Greater than or equal to zero, and typically around 4-6 hours.</p>
</dd>
<dt>Group</dt><dd><p><code>factor</code>: The reference group (i.e., adherence pattern) from which this patient was generated.</p>
</dd>
</dl>

<p>Yi H, Dong X, Shang S, Zhang C, Xu L, Han F (2022).
&ldquo;Identifying longitudinal patterns of CPAP treatment in OSA using growth mixture modeling: Disease characteristics and psychological determinants.&rdquo;
<em>Frontiers in Neurology</em>, <b>13</b>, 1063461.
<a href="https://doi.org/10.3389/fneur.2022.1063461">doi:10.3389/fneur.2022.1063461</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-data">latrend-data</a> <a href="#topic+PAP.adh1y">PAP.adh1y</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PAP.adh)

if (require("ggplot2")) {
  plotTrajectories(PAP.adh, id = "Patient", time = "Week", response = "UsageHours")

  # plot according to cluster ground truth
  plotTrajectories(
    PAP.adh,
    id = "Patient",
    time = "Week",
    response = "UsageHours",
    cluster = "Group"
  )
}
</code></pre>

<hr>
<h2 id='PAP.adh1y'>Biweekly Mean PAP Therapy Adherence of OSA Patients over 1 Year</h2><span id='topic+PAP.adh1y'></span>

<h3>Description</h3>

<p>A simulated longitudinal dataset comprising 500 patients with obstructive sleep apnea (OSA)
during their first year on CPAP therapy.
The dataset contains the patient usage hours, averaged over 2-week periods.
</p>
<p>The daily usage data underlying the downsampled dataset was simulated based on 7 different adherence patterns.
The defined adherence patterns were inspired by the adherence patterns identified by Aloia et al. (2008),
with slight adjustments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PAP.adh1y
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> comprising longitudinal data of 500 patients, each having 26 observations over a period of 1 year.
Each row represents a patient observation interval (two weeks), with columns:
</p>

<dl>
<dt>Patient</dt><dd><p><code>factor</code>: The patient identifier, where each level represents a simulated patient.</p>
</dd>
<dt>Biweek</dt><dd><p><code>integer</code>: Two-week interval index. Starts from 1.</p>
</dd>
<dt>MaxDay</dt><dd><p><code>integer</code>: The last day used for the aggregation of the respective interval, <code>integer</code></p>
</dd>
<dt>UsageHours</dt><dd><p><code>numeric</code>: The mean hours of usage in the respective week.
Greater than or equal to zero, and typically around 4-6 hours.</p>
</dd>
<dt>Group</dt><dd><p><code>factor</code>: The reference group (i.e., adherence pattern) from which this patient was generated.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This dataset is only intended for demonstration purposes.
While the data format will remain the same, the data content is subject to change in future versions.
</p>


<h3>Source</h3>

<p>This dataset was generated based on the cluster-specific descriptive statistics table
provided in Aloia et al. (2008),
with some adjustments made in order to improve cluster separation for demonstration purposes.
</p>
<p>Aloia MS, Goodwin MS, Velicer WF, Arnedt JT, Zimmerman M, Skrekas J, Harris S, Millman RP (2008).
&ldquo;Time series analysis of treatment adherence patterns in individuals with obstructive sleep apnea.&rdquo;
<em>Annals of Behavioral Medicine</em>, <b>36</b>(1), 44&ndash;53.
ISSN 0883-6612, <a href="https://doi.org/10.1007/s12160-008-9052-9">doi:10.1007/s12160-008-9052-9</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend-data">latrend-data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PAP.adh1y)

if (require("ggplot2")) {
  plotTrajectories(PAP.adh1y, id = "Patient", time = "Biweek", response = "UsageHours")

  # plot according to cluster ground truth
  plotTrajectories(
    PAP.adh1y,
    id = "Patient",
    time = "Biweek",
    response = "UsageHours",
    cluster = "Group"
  )
}
</code></pre>

<hr>
<h2 id='plot-lcModel-method'>Plot a lcModel</h2><span id='topic+plot-lcModel-method'></span><span id='topic+plot+2ClcModel+2CANY-method'></span><span id='topic+plot+2ClcModel-method'></span>

<h3>Description</h3>

<p>Plot a <code>lcModel</code> object. By default, this plots the cluster trajectories of the model, along with the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcModel'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-lcModel-method_+3A_x">x</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="plot-lcModel-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot-lcModel-method_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a></code>
</p>

<dl>
<dt><code>object</code></dt><dd><p>The (cluster) trajectory data.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a> <a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a> <a href="#topic+plotTrajectories">plotTrajectories</a> <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 3)

if (require("ggplot2")) {
  plot(model)
}
</code></pre>

<hr>
<h2 id='plot-lcModels-method'>Grid plot for a list of models</h2><span id='topic+plot-lcModels-method'></span><span id='topic+plot+2ClcModels+2CANY-method'></span><span id='topic+plot+2ClcModels-method'></span>

<h3>Description</h3>

<p>Grid plot for a list of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'lcModels'
plot(x, y, ..., subset, gridArgs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-lcModels-method_+3A_x">x</code></td>
<td>
<p>The <code>lcModels</code> object.</p>
</td></tr>
<tr><td><code id="plot-lcModels-method_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot-lcModels-method_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code>plot()</code> call for each <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="plot-lcModels-method_+3A_subset">subset</code></td>
<td>
<p>Logical expression based on the <code>lcModel</code> method arguments, indicating
which <code>lcModel</code> objects to keep.</p>
</td></tr>
<tr><td><code id="plot-lcModels-method_+3A_gridargs">gridArgs</code></td>
<td>
<p>Named list of parameters passed to <a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotClusterTrajectories'>Plot cluster trajectories</h2><span id='topic+plotClusterTrajectories'></span><span id='topic+plotClusterTrajectories+2Cdata.frame-method'></span><span id='topic+plotClusterTrajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Plot the cluster trajectories associated with the given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterTrajectories(object, ...)

## S4 method for signature 'data.frame'
plotClusterTrajectories(
  object,
  response,
  cluster = "Cluster",
  clusterOrder = character(),
  clusterLabeler = make.clusterPropLabels,
  time = getOption("latrend.time"),
  center = meanNA,
  trajectories = c(FALSE, "sd", "se", "80pct", "90pct", "95pct", "range"),
  facet = !isFALSE(as.logical(trajectories[1])),
  id = getOption("latrend.id"),
  ...
)

## S4 method for signature 'lcModel'
plotClusterTrajectories(
  object,
  what = "mu",
  at = time(object),
  clusterOrder = character(),
  clusterLabeler = make.clusterPropLabels,
  trajectories = FALSE,
  facet = !isFALSE(as.logical(trajectories[1])),
  trajAssignments = trajectoryAssignments(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterTrajectories_+3A_object">object</code></td>
<td>
<p>The (cluster) trajectory data.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+clusterTrajectories">clusterTrajectories</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_response">response</code></td>
<td>
<p>The response variable name, see <a href="#topic+responseVariable">responseVariable</a>.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_cluster">cluster</code></td>
<td>
<p>The cluster assignment column</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_clusterorder">clusterOrder</code></td>
<td>
<p>Specify which clusters to plot and the order.
Can be the cluster names or index.
By default, all clusters are shown.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_clusterlabeler">clusterLabeler</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;function(clusterNames, clusterSizes)&#8288;</code> that generates plot labels for the clusters.
By default the cluster name with the proportional size is shown, see <a href="#topic+make.clusterPropLabels">make.clusterPropLabels</a>.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_time">time</code></td>
<td>
<p>The time variable name, see <a href="#topic+timeVariable">timeVariable</a>.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_center">center</code></td>
<td>
<p>A function for aggregating multiple points at the same point in time</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_trajectories">trajectories</code></td>
<td>
<p>Whether to additionally plot the original trajectories (<code>TRUE</code>),
or to show the expected interval (standard deviation, standard error, range, or percentile range)
of the observations at the respective moment in time.
</p>
<p>Note that visualizing the expected intervals is currently only supported for time-aligned trajectories,
as the interval is computed at each unique moment in time.
By default (<code>FALSE</code>), no information on the underlying trajectories is shown.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_facet">facet</code></td>
<td>
<p>Whether to facet by cluster. This is done by default when <code>trajectories</code> is enabled.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_id">id</code></td>
<td>
<p>Id column. Only needed when <code>trajectories = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_at">at</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the times at which to compute the cluster trajectories.</p>
</td></tr>
<tr><td><code id="plotClusterTrajectories_+3A_trajassignments">trajAssignments</code></td>
<td>
<p>The cluster assignments for the fitted trajectories. Only used when <code>trajectories = TRUE</code> and <code>facet = TRUE</code>. See <a href="#topic+trajectoryAssignments">trajectoryAssignments</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+clusterTrajectories">clusterTrajectories</a>
</p>
<p><a href="#topic+plotTrajectories">plotTrajectories</a> <a href="base.html#topic+plot">plot</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 3)

if (require("ggplot2")) {
  plotClusterTrajectories(model)

  # show cluster sizes in labels
  plotClusterTrajectories(model, clusterLabeler = make.clusterSizeLabels)

  # change cluster order
  plotClusterTrajectories(model, clusterOrder = c('B', 'C', 'A'))

  # sort clusters by decreasing size
  plotClusterTrajectories(model, clusterOrder = order(-clusterSizes(model)))

  # show only specific clusters
  plotClusterTrajectories(model, clusterOrder = c('B', 'C'))

  # show assigned trajectories
  plotClusterTrajectories(model, trajectories = TRUE)

  # show 95th percentile observation interval
  plotClusterTrajectories(model, trajectories = "95pct")

  # show observation standard deviation
  plotClusterTrajectories(model, trajectories = "sd")

  # show observation standard error
  plotClusterTrajectories(model, trajectories = "se")

  # show observation range
  plotClusterTrajectories(model, trajectories = "range")
}
</code></pre>

<hr>
<h2 id='plotFittedTrajectories'>Plot the fitted trajectories</h2><span id='topic+plotFittedTrajectories'></span><span id='topic+plotFittedTrajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Plot the fitted trajectories as represented by the given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFittedTrajectories(object, ...)

## S4 method for signature 'lcModel'
plotFittedTrajectories(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFittedTrajectories_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="plotFittedTrajectories_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+fittedTrajectories">fittedTrajectories</a></code>, <code><a href="#topic+plotTrajectories">plotTrajectories</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+fittedTrajectories">fittedTrajectories</a>
</p>
<p><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a> <a href="#topic+plotTrajectories">plotTrajectories</a> <a href="base.html#topic+plot">plot</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 3)

if (require("ggplot2")) {
  plotFittedTrajectories(model)
}
</code></pre>

<hr>
<h2 id='plotMetric'>Plot one or more internal metrics for all lcModels</h2><span id='topic+plotMetric'></span>

<h3>Description</h3>

<p>Plot one or more internal metrics for all lcModels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMetric(models, name, by = "nClusters", subset, group = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMetric_+3A_models">models</code></td>
<td>
<p>A <code>lcModels</code> or list of <code>lcModel</code> objects to compute and plot the metrics of.</p>
</td></tr>
<tr><td><code id="plotMetric_+3A_name">name</code></td>
<td>
<p>The name(s) of the metric(s) to compute. If no names are given, the names specified in the <code>latrend.metric</code> option (WRSS, APPA, AIC, BIC) are used.</p>
</td></tr>
<tr><td><code id="plotMetric_+3A_by">by</code></td>
<td>
<p>The argument name along which methods are plotted.</p>
</td></tr>
<tr><td><code id="plotMetric_+3A_subset">subset</code></td>
<td>
<p>Logical expression based on the <code>lcModel</code> method arguments, indicating
which <code>lcModel</code> objects to keep.</p>
</td></tr>
<tr><td><code id="plotMetric_+3A_group">group</code></td>
<td>
<p>The argument names to use for determining groups of different models. By default,
all arguments are included.
Specifying <code>group = character()</code> disables grouping.
Specifying a single argument for grouping uses that specific column as the grouping column.
In all other cases, groupings are represented by a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
methods &lt;- lcMethods(method, nClusters = 1:3)
models &lt;- latrendBatch(methods, latrendData)

if (require("ggplot2")) {
  plotMetric(models, "WMAE")
}

if (require("ggplot2") &amp;&amp; require("clusterCrit")) {
  plotMetric(models, c("WMAE", "Dunn"))
}
</code></pre>

<hr>
<h2 id='plotTrajectories'>Plot the data trajectories</h2><span id='topic+plotTrajectories'></span><span id='topic+plotTrajectories+2Cdata.frame-method'></span><span id='topic+plotTrajectories+2CANY-method'></span><span id='topic+plotTrajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Plots the output of <a href="#topic+trajectories">trajectories</a> for the given object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrajectories(object, ...)

## S4 method for signature 'data.frame'
plotTrajectories(
  object,
  response,
  time = getOption("latrend.time"),
  id = getOption("latrend.id"),
  cluster = NULL,
  facet = TRUE,
  ...
)

## S4 method for signature 'ANY'
plotTrajectories(object, ...)

## S4 method for signature 'lcModel'
plotTrajectories(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrajectories_+3A_object">object</code></td>
<td>
<p>The data or model or extract the trajectories from.</p>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+trajectories">trajectories</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_response">response</code></td>
<td>
<p>Response variable <code>character</code> name or a <code>call</code>.</p>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_time">time</code></td>
<td>
<p>The time variable name, see <a href="#topic+timeVariable">timeVariable</a>.</p>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_id">id</code></td>
<td>
<p>The identifier variable name, see <a href="#topic+idVariable">idVariable</a>.</p>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_cluster">cluster</code></td>
<td>
<p>Cluster variable name. If unspecified, trajectories are not grouped.
Alternatively, cluster is a vector indicating cluster membership per id.</p>
</td></tr>
<tr><td><code id="plotTrajectories_+3A_facet">facet</code></td>
<td>
<p>Whether to facet by cluster.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+trajectories">trajectories</a>
</p>
<p><a href="#topic+trajectories">trajectories</a> <a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a> <a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>
</p>
<p><a href="#topic+trajectories">trajectories</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)

if (require("ggplot2")) {
  plotTrajectories(latrendData, response = "Y", id = "Id", time = "Time")

  plotTrajectories(
    latrendData,
    response = quote(exp(Y)),
    id = "Id",
    time = "Time"
  )

  plotTrajectories(
    latrendData,
    response = "Y",
    id = "Id",
    time = "Time",
    cluster = "Class"
  )

  # compute cluster membership based on the mean being below 0
  assignments &lt;- aggregate(Y ~ Id, latrendData, mean)$Y &lt; 0
  plotTrajectories(
    latrendData,
    response = "Y",
    id = "Id",
    time = "Time",
    cluster = assignments
  )
}
data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData, nClusters = 3)

if (require("ggplot2")) {
  plotTrajectories(model)
}
</code></pre>

<hr>
<h2 id='postFit'><code>lcMethod</code> estimation step: logic for post-processing the fitted lcModel</h2><span id='topic+postFit'></span><span id='topic+postFit+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>postFit()</code> function of the <code>lcMethod</code> object defines how the <code>lcModel</code> object returned by <code><a href="#topic+fit">fit()</a></code> should be post-processed.
This can be used, for example, to:
</p>

<ul>
<li><p> Resolve label switching.
</p>
</li>
<li><p> Clean up the internal model representation.
</p>
</li>
<li><p> Correct estimation errors.
</p>
</li>
<li><p> Compute additional metrics.
</p>
</li></ul>

<p>By default, this method does not do anything. It merely returns the original <code>lcModel</code> object.
</p>
<p>This is the last step in the <code>lcMethod</code> fitting procedure. The <code>postFit</code> method may be called again on fitted <code>lcModel</code> objects, allowing post-processing to be updated for existing models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postFit(method, data, model, envir, verbose, ...)

## S4 method for signature 'lcMethod'
postFit(method, data, model, envir, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postFit_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="postFit_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="postFit_+3A_model">model</code></td>
<td>
<p>The <code>lcModel</code> object returned by <code><a href="#topic+fit">fit()</a></code>.</p>
</td></tr>
<tr><td><code id="postFit_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing variables generated by <code><a href="#topic+prepareData">prepareData()</a></code> and <code><a href="#topic+preFit">preFit()</a></code>.</p>
</td></tr>
<tr><td><code id="postFit_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="postFit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>lcModel</code> object.
</p>


<h3>Implementation</h3>

<p>The method is intended to be able to be called on previously fitted <code>lcModel</code> objects as well, allowing for potential bugfixes or additions to previously fitted models.
Therefore, when implementing this method, ensure that you do not discard information from the model which would prevent the method from being run a second time on the object.
</p>
<p>In this example, the <code>lcModelExample</code> class is assumed to be defined with a slot named <code>"centers"</code>:
</p>
<pre>
setMethod("postFit", "lcMethodExample", function(method, data, model, envir, verbose) {
  # compute and store the cluster centers
  model@centers &lt;- INTENSIVE_COMPUTATION
  return(model)
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>

<hr>
<h2 id='postprob'>Posterior probability per fitted trajectory</h2><span id='topic+postprob'></span><span id='topic+postprob+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the posterior probability matrix with element <code class="reqn">(i,j)</code> indicating the probability of trajectory <code class="reqn">i</code> belonging to cluster <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postprob(object, ...)

## S4 method for signature 'lcModel'
postprob(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postprob_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="postprob_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method should be extended by <code>lcModel</code> implementations. The default implementation returns uniform probabilities for all observations.
</p>


<h3>Value</h3>

<p>An I-by-K <code style="white-space: pre;">&#8288;numeric matrix&#8288;</code> with <code>I = nIds(object)</code> and <code>K = nClusters(object)</code>.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> should override this method.
</p>
<pre>
setMethod("postprob", "lcModelExt", function(object, ...) {
  # return trajectory-specific posterior probability matrix
})
</pre>


<h3>Troubleshooting</h3>

<p>If you are getting errors about undefined model signatures when calling postprob(model),
check whether the postprob() function is still the one defined by the latrend package.
It may have been overridden when attaching another package (e.g., lcmm). If you need to attach conflicting packages, load them first.
</p>


<h3>See Also</h3>

<p><a href="#topic+trajectoryAssignments">trajectoryAssignments</a> <a href="#topic+predictPostprob">predictPostprob</a> <a href="#topic+predictAssignments">predictAssignments</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

postprob(model)

if (rlang::is_installed("lcmm")) {
  gmmMethod = lcMethodLcmmGMM(
    fixed = Y ~ Time,
    mixture = ~ Time,
    id = "Id",
    time = "Time",
    idiag = TRUE,
    nClusters = 2
  )
  gmmModel &lt;- latrend(gmmMethod, data = latrendData)
  postprob(gmmModel)
}
</code></pre>

<hr>
<h2 id='postprobFromAssignments'>Create a posterior probability matrix from a vector of cluster assignments.</h2><span id='topic+postprobFromAssignments'></span>

<h3>Description</h3>

<p>For each trajectory, the probability of the assigned cluster is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postprobFromAssignments(assignments, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postprobFromAssignments_+3A_assignments">assignments</code></td>
<td>
<p>Integer vector indicating cluster assignment per trajectory</p>
</td></tr>
<tr><td><code id="postprobFromAssignments_+3A_k">k</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
</table>

<hr>
<h2 id='postProbFromObs'>Compute the id-specific postprob matrix from a given observation-level postprob matrix</h2><span id='topic+postProbFromObs'></span>

<h3>Description</h3>

<p>Compute the id-specific postprob matrix from a given observation-level postprob matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postProbFromObs(mat, rowIds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postProbFromObs_+3A_mat">mat</code></td>
<td>
<p>A posterior probability <code>matrix</code> at the observation level.</p>
</td></tr>
<tr><td><code id="postProbFromObs_+3A_rowids">rowIds</code></td>
<td>
<p>The row trajectory identifier <code>integer</code> vector.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.lcModel'>lcModel predictions</h2><span id='topic+predict.lcModel'></span>

<h3>Description</h3>

<p>Predicts the expected trajectory observations at the given time for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
predict(object, newdata = NULL, what = "mu", ..., useCluster = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="predict.lcModel_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> for which to compute the model predictions. If omitted, the model training data is used.
Cluster trajectory predictions are made when ids are not specified.</p>
</td></tr>
<tr><td><code id="predict.lcModel_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
<tr><td><code id="predict.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="predict.lcModel_+3A_usecluster">useCluster</code></td>
<td>
<p>Whether to use the &quot;Cluster&quot; column in the newdata argument for computing predictions conditional on the respective cluster.
For <code>useCluster = NA</code> (the default), the feature is enabled if newdata contains the &quot;Cluster&quot; column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>newdata</code> specifies the cluster membership; a <code>data.frame</code> of cluster-specific predictions. Otherwise, a <code>list</code> of <code>data.frame</code> of cluster-specific predictions is returned.
</p>


<h3>Implementation</h3>

<p>Note: Subclasses of <code>lcModel</code> should preferably implement <code><a href="#topic+predictForCluster">predictForCluster()</a></code> instead of overriding <code>predict.lcModel</code> as that function is designed to be easier to implement because it is single-purpose.
</p>
<p>The <code>predict.lcModelExt</code> function should be able to handle the case where <code>newdata = NULL</code> by returning the fitted values.
After post-processing the non-NULL newdata input, the observation- and cluster-specific predictions can be computed.
Lastly, the output logic is handled by the <code><a href="#topic+transformPredict">transformPredict()</a></code> function. It converts the computed predictions (e.g., <code>matrix</code> or <code>data.frame</code>) to the appropriate output format.
</p>
<pre>
predict.lcModelExt &lt;- function(object, newdata = NULL, what = "mu", ...) {
  if (is.null(newdata)) {
    newdata = model.data(object)
    if (hasName(newdata, 'Cluster')) {
      # allowing the Cluster column to remain would break the fitted() output.
      newdata[['Cluster']] = NULL
    }
  }

  # compute cluster-specific predictions for the given newdata
  pred &lt;- NEWDATA_COMPUTATIONS_HERE
  transformPredict(pred = pred, model = object, newdata = newdata)
})
</pre>


<h3>See Also</h3>

<p><a href="#topic+predictForCluster">predictForCluster</a> <a href="stats.html#topic+predict">stats::predict</a> <a href="#topic+fitted.lcModel">fitted.lcModel</a> <a href="#topic+clusterTrajectories">clusterTrajectories</a> <a href="#topic+trajectories">trajectories</a> <a href="#topic+predictPostprob">predictPostprob</a> <a href="#topic+predictAssignments">predictAssignments</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

predFitted &lt;- predict(model) # same result as fitted(model)

# Cluster trajectory of cluster A
predCluster &lt;- predict(model, newdata = data.frame(Cluster = "A", Time = time(model)))

# Prediction for id S1 given cluster A membership
predId &lt;- predict(model, newdata = data.frame(Cluster = "A", Id = "S1", Time = time(model)))

# Prediction matrix for id S1 for all clusters
predIdAll &lt;- predict(model, newdata = data.frame(Id = "S1", Time = time(model)))
</code></pre>

<hr>
<h2 id='predictAssignments'>Predict the cluster assignments for new trajectories</h2><span id='topic+predictAssignments'></span><span id='topic+predictAssignments+2ClcModel-method'></span>

<h3>Description</h3>

<p>Predict the most likely cluster membership for each trajectory in the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictAssignments(object, newdata = NULL, ...)

## S4 method for signature 'lcModel'
predictAssignments(object, newdata = NULL, strategy = which.max, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictAssignments_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="predictAssignments_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="predictAssignments_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="predictAssignments_+3A_strategy">strategy</code></td>
<td>
<p>A function returning the cluster index based on the given <code>vector</code> of membership probabilities.
By default (<code>strategy = which.max</code>), trajectories are assigned to the most likely cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default implementation uses <a href="#topic+predictPostprob">predictPostprob</a> to determine the cluster membership.
</p>


<h3>Value</h3>

<p>A <code>factor</code> of length <code>nrow(newdata)</code> that indicates the assigned cluster per trajectory per observation.
</p>


<h3>See Also</h3>

<p><a href="#topic+predictPostprob">predictPostprob</a> <a href="#topic+predict.lcModel">predict.lcModel</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(latrendData)
if (require("kml")) {
  model &lt;- latrend(method = lcMethodKML("Y", id = "Id", time = "Time"), latrendData)
  predictAssignments(model, newdata = data.frame(Id = 999, Y = 0, Time = 0))
}

## End(Not run)
</code></pre>

<hr>
<h2 id='predictForCluster'>Predict trajectories conditional on cluster membership</h2><span id='topic+predictForCluster'></span><span id='topic+predictForCluster+2ClcModel-method'></span>

<h3>Description</h3>

<p>Predicts the expected trajectory observations at the given time under the assumption that the trajectory belongs to the specified cluster.
</p>
<p>For <code>lcModel</code> objects, the same result can be obtained by calling <code><a href="#topic+predict.lcModel">predict()</a></code> with the <code>newdata</code> <code>data.frame</code> having a <code>"Cluster"</code> assignment column.
The main purpose of this function is to make it easier to implement the prediction computations for custom <code>lcModel</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictForCluster(object, newdata = NULL, cluster, ...)

## S4 method for signature 'lcModel'
predictForCluster(object, newdata = NULL, cluster, ..., what = "mu")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictForCluster_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="predictForCluster_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> of trajectory data for which to compute trajectory assignments.</p>
</td></tr>
<tr><td><code id="predictForCluster_+3A_cluster">cluster</code></td>
<td>
<p>The cluster name (as <code>character</code>) to predict for.</p>
</td></tr>
<tr><td><code id="predictForCluster_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+predict.lcModel">predict.lcModel</a></code>
</p>

<dl>
<dt><code>useCluster</code></dt><dd><p>Whether to use the &quot;Cluster&quot; column in the newdata argument for computing predictions conditional on the respective cluster.
For <code>useCluster = NA</code> (the default), the feature is enabled if newdata contains the &quot;Cluster&quot; column.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predictForCluster_+3A_what">what</code></td>
<td>
<p>The distributional parameter to predict. By default, the mean response 'mu' is predicted. The cluster membership predictions can be obtained by specifying <code>what = 'mb'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>predictForCluster(lcModel)</code> method makes use of <code><a href="#topic+predict.lcModel">predict.lcModel()</a></code>, and vice versa. For this to work, any extending <code>lcModel</code> classes, e.g., <code>lcModelExample</code>, should implement either <code>predictForCluster(lcModelExample)</code> or <code>predict.lcModelExample()</code>. When implementing new models, it is advisable to implement <code>predictForCluster</code> as the cluster-specific computation generally results in shorter and simpler code.
</p>


<h3>Value</h3>

<p>A <code>vector</code> with the predictions per <code>newdata</code> observation, or a <code>data.frame</code> with the predictions and newdata alongside.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> should override this method, unless <code><a href="#topic+predict.lcModel">predict.lcModel()</a></code> is preferred.
</p>
<pre>
setMethod("predictForCluster", "lcModelExt",
 function(object, newdata = NULL, cluster, ..., what = "mu") {
  # return model predictions for the given data under the
  # assumption of the data belonging to the given cluster
})
</pre>


<h3>See Also</h3>

<p><a href="#topic+predict.lcModel">predict.lcModel</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)

predictForCluster(
  model,
  newdata = data.frame(Time = c(0, 1)),
  cluster = "B"
)

# all fitted values under cluster B
predictForCluster(model, cluster = "B")
</code></pre>

<hr>
<h2 id='predictPostprob'>Posterior probability for new data</h2><span id='topic+predictPostprob'></span><span id='topic+predictPostprob+2ClcModel-method'></span>

<h3>Description</h3>

<p>Returns the observation-specific posterior probabilities for the given data.
</p>
<p>For <code>lcModel</code>: The default implementation returns a uniform probability matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictPostprob(object, newdata = NULL, ...)

## S4 method for signature 'lcModel'
predictPostprob(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictPostprob_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="predictPostprob_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> for which to compute the posterior probability. If omitted, the model training data is used.</p>
</td></tr>
<tr><td><code id="predictPostprob_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+postprob">postprob</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A N-by-K <code>matrix</code> indicating the posterior probability per trajectory per measurement on each row, for each cluster (the columns).
Here, <code>N = nrow(newdata)</code> and <code>K = nClusters(object)</code>.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> should override this method to enable posterior probability predictions for new data.
</p>
<pre>
setMethod("predictPostprob", "lcModelExt", function(object, newdata = NULL, ...) {
  # return observation-specific posterior probability matrix
})
</pre>


<h3>See Also</h3>

<p><a href="#topic+postprob">postprob</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='preFit'><code>lcMethod</code> estimation step: method preparation logic</h2><span id='topic+preFit'></span><span id='topic+preFit+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>preFit()</code> function of the <code>lcMethod</code> object performs preparatory work that is needed for fitting the method but should not be counted towards the method estimation time.
The work is added to the provided <code>environment</code>, allowing the <code><a href="#topic+fit">fit()</a></code> function to make use of the prepared work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preFit(method, data, envir, verbose, ...)

## S4 method for signature 'lcMethod'
preFit(method, data, envir, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preFit_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="preFit_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="preFit_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> containing additional data variables returned by <code><a href="#topic+prepareData">prepareData()</a></code>.</p>
</td></tr>
<tr><td><code id="preFit_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="preFit_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated <code>environment</code> that will be passed to <code><a href="#topic+fit">fit()</a></code>.
</p>


<h3>Implementation</h3>

<pre>
setMethod("preFit", "lcMethodExample", function(method, data, envir, verbose) {
  # update envir with additional computed work
  envir$x &lt;- INTENSIVE_OPERATION
  return(envir)
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>

<hr>
<h2 id='prepareData'><code>lcMethod</code> estimation step: logic for preparing the training data</h2><span id='topic+prepareData'></span><span id='topic+prepareData+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>prepareData()</code> function of the <code>lcMethod</code> object processes the training data prior to fitting the method.
Example uses:
</p>

<ul>
<li><p> Transforming the data to another format, e.g., a matrix.
</p>
</li>
<li><p> Truncating the response variable.
</p>
</li>
<li><p> Computing derived covariates.
</p>
</li>
<li><p> Creating additional data objects.
</p>
</li></ul>

<p>The computed variables are stored in an <code>environment</code> which is passed to the <code><a href="#topic+preFit">preFit()</a></code> function for further processing.
</p>
<p>By default, this method does not do anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(method, data, verbose, ...)

## S4 method for signature 'lcMethod'
prepareData(method, data, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareData_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_verbose">verbose</code></td>
<td>
<p>A <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> object indicating the level of verbosity.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>environment</code>.
</p>
<p>An <code>environment</code> with the prepared data variable(s) that will be passed to <code><a href="#topic+preFit">preFit()</a></code>.
</p>


<h3>Implementation</h3>

<p>A common use case for this method is when the internal method fitting procedure expects the data in a different format.
In this example, the method converts the training data <code>data.frame</code> to a <code>matrix</code> of repeated and aligned trajectory measurements.
</p>
<pre>
setMethod("prepareData", "lcMethodExample", function(method, data, verbose) {
  envir = new.env()
  # transform the data to matrix
  envir$dataMat = tsmatrix(data,
    id = idColumn, time = timeColumn, response = valueColumn)
  return(envir)
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>

<hr>
<h2 id='print.lcMethod'>Print the arguments of an lcMethod object</h2><span id='topic+print.lcMethod'></span>

<h3>Description</h3>

<p>Print the arguments of an lcMethod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
print(x, ..., eval = FALSE, width = 40, envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lcMethod_+3A_x">x</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="print.lcMethod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="print.lcMethod_+3A_eval">eval</code></td>
<td>
<p>Whether to print the evaluated argument values.</p>
</td></tr>
<tr><td><code id="print.lcMethod_+3A_width">width</code></td>
<td>
<p>Maximum number of characters per argument.</p>
</td></tr>
<tr><td><code id="print.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The environment in which to evaluate the arguments when <code>eval = TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.lcModels'>Print lcModels list concisely</h2><span id='topic+print.lcModels'></span>

<h3>Description</h3>

<p>Print lcModels list concisely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModels'
print(
  x,
  ...,
  summary = FALSE,
  excludeShared = !getOption("latrend.printSharedModelArgs")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lcModels_+3A_x">x</code></td>
<td>
<p>The <code>lcModels</code> object.</p>
</td></tr>
<tr><td><code id="print.lcModels_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="print.lcModels_+3A_summary">summary</code></td>
<td>
<p>Whether to print the complete summary per model. This may be slow for long lists!</p>
</td></tr>
<tr><td><code id="print.lcModels_+3A_excludeshared">excludeShared</code></td>
<td>
<p>Whether to exclude model arguments which are identical across all models.</p>
</td></tr>
</table>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+subset.lcModels">subset.lcModels</a>()</code>
</p>

<hr>
<h2 id='qqPlot'>Quantile-quantile plot</h2><span id='topic+qqPlot'></span>

<h3>Description</h3>

<p>Plot the quantile-quantile (Q-Q) plot for the fitted <code>lcModel</code> object. This function is based on the <span class="pkg">qqplotr</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqPlot(model, byCluster = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqPlot_+3A_model">model</code></td>
<td>
<p><code>lcModel</code></p>
</td></tr>
<tr><td><code id="qqPlot_+3A_bycluster">byCluster</code></td>
<td>
<p>Whether to plot the Q-Q line per cluster</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="#topic+residuals.lcModel">residuals.lcModel</a>, <code><a href="qqplotr.html#topic+stat_qq_band">qqplotr::geom_qq_band()</a></code>, <code><a href="qqplotr.html#topic+stat_qq_line">qqplotr::stat_qq_line()</a></code>, and <code><a href="qqplotr.html#topic+stat_qq_point">qqplotr::stat_qq_point()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+residuals.lcModel">residuals.lcModel</a> <a href="#topic+metric">metric</a> <a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time", nClusters = 3)
model &lt;- latrend(method, latrendData)

if (require("ggplot2") &amp;&amp; require("qqplotr")) {
  qqPlot(model)
}
</code></pre>

<hr>
<h2 id='residuals.lcModel'>Extract lcModel residuals</h2><span id='topic+residuals.lcModel'></span>

<h3>Description</h3>

<p>Extract the residuals for a fitted <code>lcModel</code> object.
By default, residuals are computed under the most likely cluster assignment for each trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
residuals(object, ..., clusters = trajectoryAssignments(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="residuals.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="residuals.lcModel_+3A_clusters">clusters</code></td>
<td>
<p>Optional cluster assignments per id. If unspecified, a <code>matrix</code> is returned containing the cluster-specific predictions per column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of residuals for the cluster assignments specified by clusters.
If the <code>clusters</code> argument is unspecified, a <code>matrix</code> of cluster-specific residuals per observations is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+fitted.lcModel">fitted.lcModel</a> <a href="#topic+trajectories">trajectories</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='responseVariable'>Extract response variable</h2><span id='topic+responseVariable'></span><span id='topic+responseVariable+2ClcMethod-method'></span><span id='topic+responseVariable+2ClcModel-method'></span>

<h3>Description</h3>

<p>Extracts the response variable from the given <code>object</code>.
</p>
<p>Get the response variable, i.e., the dependent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>responseVariable(object, ...)

## S4 method for signature 'lcMethod'
responseVariable(object, ...)

## S4 method for signature 'lcModel'
responseVariable(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="responseVariable_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="responseVariable_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>lcMethod</code> object specifies a <code>formula</code> argument, then the response is extracted from the response term of the formula.
</p>


<h3>Value</h3>

<p>A nonempty string, as <code>character</code>.
</p>


<h3>See Also</h3>

<p>Other variables: 
<code><a href="#topic+idVariable">idVariable</a>()</code>,
<code><a href="#topic+timeVariable">timeVariable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time)
responseVariable(method) # "Y"
data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
responseVariable(model) # "Y"
</code></pre>

<hr>
<h2 id='sigma.lcModel'>Extract residual standard deviation from a lcModel</h2><span id='topic+sigma.lcModel'></span>

<h3>Description</h3>

<p>Extracts or estimates the residual standard deviation. If <code><a href="stats.html#topic+sigma">sigma()</a></code> is not defined for a model, it is estimated from the residual error vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="sigma.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> indicating the residual standard deviation.
</p>


<h3>See Also</h3>

<p><a href="#topic+coef.lcModel">coef.lcModel</a> <a href="#topic+metric">metric</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='strip'>Reduce the memory footprint of an object for serialization</h2><span id='topic+strip'></span><span id='topic+strip+2ClcMethod-method'></span><span id='topic+strip+2CANY-method'></span><span id='topic+strip+2ClcModel-method'></span>

<h3>Description</h3>

<p>Reduce the (serialized) memory footprint of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip(object, ...)

## S4 method for signature 'lcMethod'
strip(object, ..., classes = "formula")

## S4 method for signature 'ANY'
strip(object, ..., classes = "formula")

## S4 method for signature 'lcModel'
strip(object, ..., classes = "formula")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="strip_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="strip_+3A_classes">classes</code></td>
<td>
<p>The object classes for which to remove their assigned environment. By default, only environments from <code>formula</code> are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Serializing references to environments results in the serialization of the object
together with any associated environments and references. This method removes those environments
and references, greatly reducing the serialized object size.
</p>


<h3>Value</h3>

<p>The stripped (i.e., updated) object.
</p>


<h3>Implementation</h3>

<p>Classes extending <code>lcModel</code> can override this method to remove additional non-essentials.
</p>
<pre>
setMethod("strip", "lcModelExt", function(object, ..., classes = "formula") {
  object &lt;- callNextMethod()
  # further process the object
  return(object)
})
</pre>


<h3>See Also</h3>

<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
newModel &lt;- strip(model)
</code></pre>

<hr>
<h2 id='subset.lcModels'>Subsetting a lcModels list based on method arguments</h2><span id='topic+subset.lcModels'></span>

<h3>Description</h3>

<p>Subsetting a lcModels list based on method arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModels'
subset(x, subset, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.lcModels_+3A_x">x</code></td>
<td>
<p>The <code>lcModels</code> or list of <code>lcModel</code> to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.lcModels_+3A_subset">subset</code></td>
<td>
<p>Logical expression based on the <code>lcModel</code> method arguments, indicating
which <code>lcModel</code> objects to keep.</p>
</td></tr>
<tr><td><code id="subset.lcModels_+3A_drop">drop</code></td>
<td>
<p>Whether to return a <code>lcModel</code> object if the result is length 1.</p>
</td></tr>
<tr><td><code id="subset.lcModels_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lcModels</code> list with the subset of <code>lcModel</code> objects.
</p>


<h3>Functionality</h3>


<ul>
<li> <p><a href="#topic+print.lcModels">Print</a> an argument summary for each of the models.
</p>
</li>
<li> <p><a href="#topic+as.data.frame.lcModels">Convert</a> to a <code>data.frame</code> of method arguments.
</p>
</li>
<li> <p><a href="#topic+subset.lcModels">Subset</a> the list.
</p>
</li>
<li><p> Compute an <a href="#topic+metric">internal metric</a> or <a href="#topic+externalMetric">external metric</a>.
</p>
</li>
<li><p> Obtain the best model according to <a href="#topic+min.lcModels">minimizing</a> or <a href="#topic+max.lcModels">maximizing</a> a <a href="#topic+latrend-metrics">metric</a>.
</p>
</li>
<li><p> Obtain the summed <a href="#topic+estimationTime">estimation time</a>.
</p>
</li>
<li> <p><a href="#topic+plotMetric">Plot a metric</a> across a variable.
</p>
</li>
<li> <p><a href="#topic+plotClusterTrajectories">Plot the cluster trajectories</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other lcModels functions: 
<code><a href="#topic+as.lcModels">as.lcModels</a>()</code>,
<code><a href="#topic+lcModels">lcModels</a></code>,
<code><a href="#topic+lcModels-class">lcModels-class</a></code>,
<code><a href="#topic+max.lcModels">max.lcModels</a>()</code>,
<code><a href="#topic+min.lcModels">min.lcModels</a>()</code>,
<code><a href="#topic+plotMetric">plotMetric</a>()</code>,
<code><a href="#topic+print.lcModels">print.lcModels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")

model1 &lt;- latrend(method, latrendData, nClusters = 1)
model2 &lt;- latrend(method, latrendData, nClusters = 2)
model3 &lt;- latrend(method, latrendData, nClusters = 3)

rngMethod &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
rngModel &lt;- latrend(rngMethod, latrendData)

models &lt;- lcModels(model1, model2, model3, rngModel)

subset(models, nClusters &gt; 1 &amp; .method == 'lmkm')
</code></pre>

<hr>
<h2 id='summary.lcModel'>Summarize a lcModel</h2><span id='topic+summary.lcModel'></span>

<h3>Description</h3>

<p>Extracts all relevant information from the underlying model into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="summary.lcModel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='test'>Test a condition</h2><span id='topic+test'></span>

<h3>Description</h3>

<p>Evaluate or compare an expression based on a reference expression, or test for errors.
The comparison of expression values is done using <code><a href="base.html#topic+all.equal">base::all.equal()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test(
  key = "test",
  x,
  y = TRUE,
  error = FALSE,
  warning = FALSE,
  runOnly = FALSE,
  text = "",
  onFail = c("fail", "warn", "ignore", "skip"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_+3A_key">key</code></td>
<td>
<p>Identifier for the test condition.</p>
</td></tr>
<tr><td><code id="test_+3A_x">x</code></td>
<td>
<p>The expression to test.</p>
</td></tr>
<tr><td><code id="test_+3A_y">y</code></td>
<td>
<p>The reference value or expression.</p>
</td></tr>
<tr><td><code id="test_+3A_error">error</code></td>
<td>
<p>Whether to expect an error, or the pattern that the error message should match.</p>
</td></tr>
<tr><td><code id="test_+3A_warning">warning</code></td>
<td>
<p>Whether to expect a warning, or the pattern that the warning message should match.</p>
</td></tr>
<tr><td><code id="test_+3A_runonly">runOnly</code></td>
<td>
<p>Whether to skip the comparison to <code>y</code>. If disabled, an error is raised when <code>y</code> is not <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="test_+3A_text">text</code></td>
<td>
<p>Human-readable description of what this test condition is testing.</p>
</td></tr>
<tr><td><code id="test_+3A_onfail">onFail</code></td>
<td>
<p>How to handle a failure of the test condition. By default, this is recorded as a test failure.
If <code>onFail = "skip"</code>, the condition is not tested.</p>
</td></tr>
<tr><td><code id="test_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+all.equal">base::all.equal()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by the <code>data.table</code> package test mechanism.
The original motivation for this function is the lack of R support for a proper stack trace with line numbers when sourcing files,
which made it practically impossible to identify the offending line in a sourced file.
</p>


<h3>Value</h3>

<p>Whether the test condition has passed successfully. In case of <code>onFail = "skip"</code>, <code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test('gt', 2 &gt; 1)
test('eq', 1 + 1, 2)
test('lt', 2 &lt; 1, onFail = "warn")

## End(Not run)
</code></pre>

<hr>
<h2 id='test.latrend'>Test the implementation of an lcMethod and associated lcModel subclasses</h2><span id='topic+test.latrend'></span>

<h3>Description</h3>

<p>Test a <code>lcMethod</code> subclass implementation and its resulting <code>lcModel</code> implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.latrend(
  class = "lcMethodKML",
  instantiator = NULL,
  data = NULL,
  args = list(),
  tests = c("method", "basic", "fitted", "predict", "cluster-single", "cluster-three"),
  maxFails = 5L,
  errorOnFail = FALSE,
  clusterRecovery = c("warn", "ignore", "fail"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.latrend_+3A_class">class</code></td>
<td>
<p>The name of the <code>lcMethod</code> subclass to test.
The class should inherit from <code>lcMethod</code>.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_instantiator">instantiator</code></td>
<td>
<p>A <code>function</code> with signature <code style="white-space: pre;">&#8288;(id, time, response, ...)&#8288;</code>,
returning an object inheriting from the <code>lcMethod</code> specified by the <code>class</code> argument.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_data">data</code></td>
<td>
<p>An optional dataset comprising three highly distinct constant clusters that will be used for testing, represented by a <code>data.frame</code>.
The <code>data.frame</code> must contain the columns <code style="white-space: pre;">&#8288;"Id", "Time", "Value", "Cluster"&#8288;</code> of types <code>character</code>, <code>numeric</code>, <code>numeric</code>, and <code>character</code>, respectively.
All trajectories should be of equal length and have observations at the same moments in time.
Trajectory observations are assumed to be independent of time, i.e., all trajectories are constant.
This enables tests to insert additional observations as needed by sampling from the available observations.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_args">args</code></td>
<td>
<p>Other arguments passed to the instantiator function.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_tests">tests</code></td>
<td>
<p>A <code>character</code> vector indicating the type of tests to run, as defined in the <code style="white-space: pre;">&#8288;*.Rraw&#8288;</code> files inside the <code style="white-space: pre;">&#8288;/test/&#8288;</code> folder.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_maxfails">maxFails</code></td>
<td>
<p>The maximum number of allowed test condition failures before testing is ended prematurely.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_erroronfail">errorOnFail</code></td>
<td>
<p>Whether to throw the test errors as an error. This is always enabled while running package tests.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_clusterrecovery">clusterRecovery</code></td>
<td>
<p>Whether to test for correct recovery/identification of the original clusters in the test data.
By default, a warning is outputted.</p>
</td></tr>
<tr><td><code id="test.latrend_+3A_verbose">verbose</code></td>
<td>
<p>Whether the output testing results. This is always disabled while running package tests.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is an experimental function that is subject to large changes in the future.
The default dataset used for testing is subject to change.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.latrend("lcMethodRandom", tests = c("method", "basic"), clusterRecovery = "skip")
</code></pre>

<hr>
<h2 id='time.lcModel'>Sampling times of a lcModel</h2><span id='topic+time.lcModel'></span>

<h3>Description</h3>

<p>Extract the sampling times on which the <code>lcModel</code> was fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
time(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time.lcModel_+3A_x">x</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="time.lcModel_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of the unique times at which observations occur, in increasing order.
</p>


<h3>See Also</h3>

<p><a href="#topic+timeVariable">timeVariable</a> <a href="#topic+model.data">model.data</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+trajectoryAssignments">trajectoryAssignments</a>()</code>
</p>

<hr>
<h2 id='timeVariable'>Extract the time variable</h2><span id='topic+timeVariable'></span><span id='topic+timeVariable+2ClcMethod-method'></span><span id='topic+timeVariable+2ClcModel-method'></span>

<h3>Description</h3>

<p>Extracts the time variable (i.e., column name) from the given <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeVariable(object, ...)

## S4 method for signature 'lcMethod'
timeVariable(object, ...)

## S4 method for signature 'lcModel'
timeVariable(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeVariable_+3A_object">object</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="timeVariable_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The time variable name, as <code>character</code>.
</p>


<h3>See Also</h3>

<p>Other variables: 
<code><a href="#topic+idVariable">idVariable</a>()</code>,
<code><a href="#topic+responseVariable">responseVariable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
timeVariable(method) # "Time"
data(latrendData)
method &lt;- lcMethodRandom("Y", id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
timeVariable(model) # "Time"
</code></pre>

<hr>
<h2 id='trajectories'>Extract the trajectories</h2><span id='topic+trajectories'></span><span id='topic+trajectories+2Cdata.frame-method'></span><span id='topic+trajectories+2Cmatrix-method'></span><span id='topic+trajectories+2Ccall-method'></span><span id='topic+trajectories+2ClcModel-method'></span>

<h3>Description</h3>

<p>Transform or extract the trajectories from the given object to a standardized format.
</p>
<p>The standardized data format is for method estimation by <a href="#topic+latrend">latrend</a>, and for plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectories(
  object,
  id = idVariable(object),
  time = timeVariable(object),
  response = responseVariable(object),
  ...
)

## S4 method for signature 'data.frame'
trajectories(
  object,
  id = idVariable(object),
  time = timeVariable(object),
  response = responseVariable(object),
  ...
)

## S4 method for signature 'matrix'
trajectories(
  object,
  id = idVariable(object),
  time = timeVariable(object),
  response = responseVariable(object),
  ...
)

## S4 method for signature 'call'
trajectories(object, ..., envir)

## S4 method for signature 'lcModel'
trajectories(
  object,
  id = idVariable(object),
  time = timeVariable(object),
  response = responseVariable(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectories_+3A_object">object</code></td>
<td>
<p>The data or model or extract the trajectories from.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_id">id</code></td>
<td>
<p>The identifier variable name, see <a href="#topic+idVariable">idVariable</a>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_time">time</code></td>
<td>
<p>The time variable name, see <a href="#topic+timeVariable">timeVariable</a>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_response">response</code></td>
<td>
<p>The response variable name, see <a href="#topic+responseVariable">responseVariable</a>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> used to evaluate the data object in (e.g., in case <code>object</code> is of type <code>call</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function removes unused factor levels in the Id column, and any trajectories which are only comprised of NAs in the response.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns matching the <code>id</code>, <code>time</code>, and <code>response</code> name arguments.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotTrajectories">plotTrajectories</a> <a href="#topic+latrend">latrend</a>
</p>

<hr>
<h2 id='trajectoryAssignments'>Get the cluster membership of each trajectory</h2><span id='topic+trajectoryAssignments'></span><span id='topic+trajectoryAssignments+2Cmatrix-method'></span><span id='topic+trajectoryAssignments+2ClcModel-method'></span>

<h3>Description</h3>

<p>Get the cluster membership of each trajectory associated with the given model.
</p>
<p>For <code>lcModel</code>: Classify the fitted trajectories based on the posterior probabilities computed by <code><a href="#topic+postprob">postprob()</a></code>, according to a given classification strategy.
</p>
<p>By default, trajectories are assigned based on the highest posterior probability using <code><a href="base.html#topic+which.max">which.max()</a></code>.
In cases where identical probabilities are expected between clusters, it is preferable to use <a href="nnet.html#topic+which.is.max">which.is.max</a> instead, as this function breaks ties at random.
Another strategy to consider is the function <code><a href="#topic+which.weight">which.weight()</a></code>, which enables weighted sampling of cluster assignments based on the trajectory-specific probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectoryAssignments(object, ...)

## S4 method for signature 'matrix'
trajectoryAssignments(
  object,
  strategy = which.max,
  clusterNames = colnames(object),
  ...
)

## S4 method for signature 'lcModel'
trajectoryAssignments(object, strategy = which.max, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trajectoryAssignments_+3A_object">object</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="trajectoryAssignments_+3A_...">...</code></td>
<td>
<p>Any additional arguments passed to the strategy function.</p>
</td></tr>
<tr><td><code id="trajectoryAssignments_+3A_strategy">strategy</code></td>
<td>
<p>A function returning the cluster index based on the given vector of membership probabilities. By default, ids are assigned to the cluster with the highest probability.</p>
</td></tr>
<tr><td><code id="trajectoryAssignments_+3A_clusternames">clusterNames</code></td>
<td>
<p>Optional <code style="white-space: pre;">&#8288;character vector&#8288;</code> with the cluster names.
If <code>clusterNames = NULL</code>, <code><a href="#topic+make.clusterNames">make.clusterNames()</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case <code>object</code> is a <code>matrix</code>: the posterior probability <code>matrix</code>,
with the <code class="reqn">k</code>th column containing the observation- or trajectory-specific probability for cluster <code class="reqn">k</code>.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;factor vector&#8288;</code> indicating the cluster membership for each trajectory.
</p>


<h3>See Also</h3>

<p><a href="#topic+postprob">postprob</a> <a href="#topic+clusterSizes">clusterSizes</a> <a href="#topic+predictAssignments">predictAssignments</a>
</p>
<p>Other lcModel functions: 
<code><a href="#topic+clusterNames">clusterNames</a>()</code>,
<code><a href="#topic+clusterProportions">clusterProportions</a>()</code>,
<code><a href="#topic+clusterSizes">clusterSizes</a>()</code>,
<code><a href="#topic+clusterTrajectories">clusterTrajectories</a>()</code>,
<code><a href="#topic+coef.lcModel">coef.lcModel</a>()</code>,
<code><a href="#topic+converged">converged</a>()</code>,
<code><a href="#topic+deviance.lcModel">deviance.lcModel</a>()</code>,
<code><a href="#topic+df.residual.lcModel">df.residual.lcModel</a>()</code>,
<code><a href="#topic+estimationTime">estimationTime</a>()</code>,
<code><a href="#topic+externalMetric">externalMetric</a>()</code>,
<code><a href="#topic+fitted.lcModel">fitted.lcModel</a>()</code>,
<code><a href="#topic+fittedTrajectories">fittedTrajectories</a>()</code>,
<code><a href="#topic+getCall.lcModel">getCall.lcModel</a>()</code>,
<code><a href="#topic+getLcMethod">getLcMethod</a>()</code>,
<code><a href="#topic+ids">ids</a>()</code>,
<code><a href="#topic+lcModel-class">lcModel-class</a></code>,
<code><a href="#topic+metric">metric</a>()</code>,
<code><a href="#topic+model.frame.lcModel">model.frame.lcModel</a>()</code>,
<code><a href="#topic+nClusters">nClusters</a>()</code>,
<code><a href="#topic+nIds">nIds</a>()</code>,
<code><a href="#topic+nobs.lcModel">nobs.lcModel</a>()</code>,
<code><a href="#topic+plot-lcModel-method">plot-lcModel-method</a></code>,
<code><a href="#topic+plotClusterTrajectories">plotClusterTrajectories</a>()</code>,
<code><a href="#topic+plotFittedTrajectories">plotFittedTrajectories</a>()</code>,
<code><a href="#topic+postprob">postprob</a>()</code>,
<code><a href="#topic+predict.lcModel">predict.lcModel</a>()</code>,
<code><a href="#topic+predictAssignments">predictAssignments</a>()</code>,
<code><a href="#topic+predictForCluster">predictForCluster</a>()</code>,
<code><a href="#topic+predictPostprob">predictPostprob</a>()</code>,
<code><a href="#topic+qqPlot">qqPlot</a>()</code>,
<code><a href="#topic+residuals.lcModel">residuals.lcModel</a>()</code>,
<code><a href="#topic+sigma.lcModel">sigma.lcModel</a>()</code>,
<code><a href="#topic+strip">strip</a>()</code>,
<code><a href="#topic+time.lcModel">time.lcModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model &lt;- latrend(method, latrendData)
trajectoryAssignments(model)

# assign trajectories at random using weighted sampling
trajectoryAssignments(model, strategy = which.weight)
</code></pre>

<hr>
<h2 id='transformFitted'>Helper function for custom lcModel classes implementing fitted.lcModel()</h2><span id='topic+transformFitted'></span><span id='topic+transformFitted+2CNULL+2ClcModel-method'></span><span id='topic+transformFitted+2Cmatrix+2ClcModel-method'></span><span id='topic+transformFitted+2Clist+2ClcModel-method'></span><span id='topic+transformFitted+2Cdata.frame+2ClcModel-method'></span>

<h3>Description</h3>

<p>A helper function for implementing the <code><a href="#topic+fitted.lcModel">fitted.lcModel()</a></code> method as part of your own <code>lcModel</code> class, ensuring the correct output type and format (see the Value section).
Note that this function has no use outside of implementing <code>fitted.lcModel</code>.
</p>
<p>The function makes it easier to implement <code>fitted.lcModel</code> based on existing implementations that may output their results in different data formats. Furthermore, the function checks whether the input data is valid.
</p>
<p>The prediction ordering depends on the ordering of the data observations that was used for fitting the <code>lcModel</code>.
</p>
<p>By default, <code>transformFitted()</code> accepts one of the following inputs:
</p>

<dl>
<dt><code>data.frame</code></dt><dd><p>A <code>data.frame</code> in long format providing a cluster-specific prediction for each observation per row, with column names <code>"Fit"</code> and <code>"Cluster"</code>. This <code>data.frame</code> therefore has <code>nobs(object) * nClusters(object)</code> rows.</p>
</dd>
<dt><code>matrix</code></dt><dd><p>An N-by-K <code>matrix</code> where each row provides the cluster-specific predictions for the respective observation. Here, <code>N = nrow(model.data(object))</code> and <code>K = nClusters(object)</code>.</p>
</dd>
<dt><code>list</code></dt><dd><p>A <code>list</code> of cluster-specific prediction <code>vector</code>s. Each prediction vector should be of length <code>nrow(model.data(object))</code>. The overall (named) list of cluster-specific prediction vectors is of length <code>nClusters(object)</code>.</p>
</dd>
</dl>

<p>Users can implement support for other prediction formats by defining the <code>transformFitted</code> method with other signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformFitted(pred, model, clusters)

## S4 method for signature 'NULL,lcModel'
transformFitted(pred, model, clusters = NULL)

## S4 method for signature 'matrix,lcModel'
transformFitted(pred, model, clusters = NULL)

## S4 method for signature 'list,lcModel'
transformFitted(pred, model, clusters = NULL)

## S4 method for signature 'data.frame,lcModel'
transformFitted(pred, model, clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformFitted_+3A_pred">pred</code></td>
<td>
<p>The cluster-specific predictions for each observation</p>
</td></tr>
<tr><td><code id="transformFitted_+3A_model">model</code></td>
<td>
<p>The <code>lcModel</code> by which the prediction was made.</p>
</td></tr>
<tr><td><code id="transformFitted_+3A_clusters">clusters</code></td>
<td>
<p>The trajectory cluster assignment per observation. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>clusters</code> argument was specified, a <code>vector</code> of fitted values conditional on the given cluster assignment. Else, a <code>matrix</code> with the fitted values per cluster per column.
</p>


<h3>Example implementation</h3>

<p>A typical implementation of <code><a href="#topic+fitted.lcModel">fitted.lcModel()</a></code> for your own <code>lcModel</code> class would have the following format:
</p>
<pre>
fitted.lcModelExample &lt;- function(object,
 clusters = trajectoryAssignments(object)) {
  # computations of the fitted values per cluster here
  predictionMatrix &lt;- CODE_HERE
  transformFitted(pred = predictionMatrix, model = object, clusters = clusters)
}
</pre>
<p>For a complete and runnable example, see the custom models vignette accessible via <code>vignette("custom", package = "latrend")</code>.
</p>

<hr>
<h2 id='transformPredict'>Helper function for custom lcModel classes implementing predict.lcModel()</h2><span id='topic+transformPredict'></span><span id='topic+transformPredict+2CNULL+2ClcModel-method'></span><span id='topic+transformPredict+2Cvector+2ClcModel-method'></span><span id='topic+transformPredict+2Cmatrix+2ClcModel-method'></span><span id='topic+transformPredict+2Cdata.frame+2ClcModel-method'></span>

<h3>Description</h3>

<p>A helper function for implementing the <a href="#topic+predict.lcModel">predict.lcModel()</a> method as part of your own <code>lcModel</code> class, ensuring the correct output type and format (see the Value section).
Note that this function has no use outside of ensuring valid output for <code>predict.lcModel</code>.
For implementing <code>lcModel</code> predictions from scratch, it is advisable to implement <a href="#topic+predictForCluster">predictForCluster</a> instead of <a href="#topic+predict.lcModel">predict.lcModel</a>.
</p>
<p>The prediction ordering corresponds to the observation ordering of the <code>newdata</code> argument.
</p>
<p>By default, <code>transformPredict()</code> accepts one of the following inputs:
</p>

<dl>
<dt><code>data.frame</code></dt><dd><p>A <code>data.frame</code> in long format providing a cluster-specific prediction for each observation per row, with column names <code>"Fit"</code> and <code>"Cluster"</code>.
This <code>data.frame</code> therefore has <code>nrow(model.data(object)) * nClusters(object)</code> rows.</p>
</dd>
<dt><code>matrix</code></dt><dd><p>An N-by-K <code>matrix</code> where each row provides the cluster-specific predictions for the respective observations in <code>newdata</code>.
Here, <code>N = nrow(newdata)</code> and <code>K = nClusters(object)</code>.</p>
</dd>
<dt><code>vector</code></dt><dd><p>A <code>vector</code> of length <code>nrow(newdata)</code> with predictions corresponding to the rows of <code>newdata</code>.</p>
</dd>
</dl>

<p>Users can implement support for other prediction formats by defining the <code>transformPredict()</code> method with other signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformPredict(pred, model, newdata)

## S4 method for signature 'NULL,lcModel'
transformPredict(pred, model, newdata)

## S4 method for signature 'vector,lcModel'
transformPredict(pred, model, newdata)

## S4 method for signature 'matrix,lcModel'
transformPredict(pred, model, newdata)

## S4 method for signature 'data.frame,lcModel'
transformPredict(pred, model, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformPredict_+3A_pred">pred</code></td>
<td>
<p>The (per-cluster) predictions for <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="transformPredict_+3A_model">model</code></td>
<td>
<p>The <code>lcModel</code> for which the prediction was made.</p>
</td></tr>
<tr><td><code id="transformPredict_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing the input data to predict for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the predictions, or a list of cluster-specific prediction <code>data.frame</code>s.
</p>


<h3>Example implementation</h3>

<p>In case we have a custom <code>lcModel</code> class based on an existing internal model representation with a <code>predict()</code> function,
we can use <code>transformPredict()</code> to easily transform the internal model predictions to the right format.
A common output is a <code>matrix</code> with the cluster-specific predictions.
</p>
<pre>
predict.lcModelExample &lt;- function(object, newdata) {
  predictionMatrix &lt;- predict(object@model, newdata)
  transformPredict(
    pred = predictionMatrix,
    model = object,
    newdata = newdata
  )
}
</pre>
<p>However, for ease of implementation it is generally advisable to implement <a href="#topic+predictForCluster">predictForCluster</a> instead of <a href="#topic+predict.lcModel">predict.lcModel</a>.
</p>
<p>For a complete and runnable example, see the custom models vignette accessible via <code>vignette("custom", package = "latrend")</code>.
</p>


<h3>See Also</h3>

<p>predictForCluster, predict.lcModel
</p>

<hr>
<h2 id='tsframe'>Convert a multiple time series matrix to a data.frame</h2><span id='topic+tsframe'></span><span id='topic+meltRepeatedMeasures'></span>

<h3>Description</h3>

<p>Convert a multiple time series matrix to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsframe(
  data,
  response,
  id = getOption("latrend.id"),
  time = getOption("latrend.time"),
  ids = rownames(data),
  times = colnames(data),
  as.data.table = FALSE
)

meltRepeatedMeasures(
  data,
  response,
  id = getOption("latrend.id"),
  time = getOption("latrend.time"),
  ids = rownames(data),
  times = colnames(data),
  as.data.table = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsframe_+3A_data">data</code></td>
<td>
<p>The <code>matrix</code> containing a trajectory on each row.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_response">response</code></td>
<td>
<p>The response column name.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_id">id</code></td>
<td>
<p>The id column name.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_time">time</code></td>
<td>
<p>The time column name.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_ids">ids</code></td>
<td>
<p>A <code>vector</code> specifying the id names. Should match the number of rows of <code>data</code>.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_times">times</code></td>
<td>
<p>A <code>numeric</code> <code>vector</code> specifying the times of the measurements.
Should match the number of columns of <code>data</code>.</p>
</td></tr>
<tr><td><code id="tsframe_+3A_as.data.table">as.data.table</code></td>
<td>
<p>Whether to return the result as a <code>data.table</code>, or a <code>data.frame</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code> containing the repeated measures.
</p>


<h3>Note</h3>

<p>The <code>meltRepeatedMeasures()</code> function is deprecated and will be removed in a future version,
please use <code>tsframe()</code> instead.
</p>


<h3>See Also</h3>

<p><a href="#topic+tsmatrix">tsmatrix</a>
</p>

<hr>
<h2 id='tsmatrix'>Convert a longitudinal data.frame to a matrix</h2><span id='topic+tsmatrix'></span><span id='topic+dcastRepeatedMeasures'></span>

<h3>Description</h3>

<p>Converts a longitudinal <code>data.frame</code> comprising trajectories with an equal number of observations,
measured at identical moments in time, to a <code>matrix</code>. Each row of the matrix represents a trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsmatrix(
  data,
  response,
  id = getOption("latrend.id"),
  time = getOption("latrend.time"),
  fill = NA
)

dcastRepeatedMeasures(
  data,
  response,
  id = getOption("latrend.id"),
  time = getOption("latrend.time"),
  fill = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsmatrix_+3A_data">data</code></td>
<td>
<p>The <code>matrix</code> containing a trajectory on each row.</p>
</td></tr>
<tr><td><code id="tsmatrix_+3A_response">response</code></td>
<td>
<p>The response column name.</p>
</td></tr>
<tr><td><code id="tsmatrix_+3A_id">id</code></td>
<td>
<p>The id column name.</p>
</td></tr>
<tr><td><code id="tsmatrix_+3A_time">time</code></td>
<td>
<p>The time column name.</p>
</td></tr>
<tr><td><code id="tsmatrix_+3A_fill">fill</code></td>
<td>
<p>A <code>scalar</code> value.
If <code>FALSE</code>, an error is thrown when time series observations are missing in the data frame.
Otherwise, the value used for representing missing observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with a trajectory per row.
</p>


<h3>Note</h3>

<p>The <code>dcastRepeatedMeasures()</code> function is deprecated and will be removed in a future version.
Please use <code>tsmatrix()</code> instead.
</p>


<h3>See Also</h3>

<p><a href="#topic+tsframe">tsframe</a>
</p>

<hr>
<h2 id='update.lcMethod'>Update a method specification</h2><span id='topic+update.lcMethod'></span>

<h3>Description</h3>

<p>Update a method specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcMethod'
update(object, ..., .eval = FALSE, .remove = character(), envir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.lcMethod_+3A_object">object</code></td>
<td>
<p>The <code>lcMethod</code> object.</p>
</td></tr>
<tr><td><code id="update.lcMethod_+3A_...">...</code></td>
<td>
<p>The new or updated method argument values.</p>
</td></tr>
<tr><td><code id="update.lcMethod_+3A_.eval">.eval</code></td>
<td>
<p>Whether to assign the evaluated argument values to the method. By default (<code>FALSE</code>), the argument expression is preserved.</p>
</td></tr>
<tr><td><code id="update.lcMethod_+3A_.remove">.remove</code></td>
<td>
<p>Names of arguments that should be removed.</p>
</td></tr>
<tr><td><code id="update.lcMethod_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which to evaluate the arguments. If <code>NULL</code>, the environment associated with the object is used. If not available, the <code>parent.frame()</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Updates or adds arguments to a <code>lcMethod</code> object. The inputs are evaluated in order to determine the presence of <code>formula</code> objects, which are updated accordingly.
</p>


<h3>Value</h3>

<p>The new <code>lcMethod</code> object with the additional or updated arguments.
</p>


<h3>See Also</h3>

<p>Other lcMethod functions: 
<code><a href="#topic++5B+5B+2ClcMethod-method">[[,lcMethod-method</a></code>,
<code><a href="#topic+as.data.frame.lcMethod">as.data.frame.lcMethod</a>()</code>,
<code><a href="#topic+as.data.frame.lcMethods">as.data.frame.lcMethods</a>()</code>,
<code><a href="#topic+as.lcMethods">as.lcMethods</a>()</code>,
<code><a href="#topic+as.list.lcMethod">as.list.lcMethod</a>()</code>,
<code><a href="#topic+evaluate.lcMethod">evaluate.lcMethod</a>()</code>,
<code><a href="#topic+formula.lcMethod">formula.lcMethod</a>()</code>,
<code><a href="#topic+lcMethod-class">lcMethod-class</a></code>,
<code><a href="#topic+names+2ClcMethod-method">names,lcMethod-method</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>method &lt;- lcMethodLMKM(Y ~ 1, nClusters = 2)
method2 &lt;- update(method, formula = ~ . + Time)

method3 &lt;- update(method2, nClusters = 3)

k &lt;- 2
method4 &lt;- update(method, nClusters = k) # nClusters: k

method5 &lt;- update(method, nClusters = k, .eval = TRUE) # nClusters: 2

</code></pre>

<hr>
<h2 id='update.lcModel'>Update a lcModel</h2><span id='topic+update.lcModel'></span>

<h3>Description</h3>

<p>Fit a new model with modified arguments from the current model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcModel'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.lcModel_+3A_object">object</code></td>
<td>
<p>The <code>lcModel</code> object.</p>
</td></tr>
<tr><td><code id="update.lcModel_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+latrend">latrend</a></code>
</p>

<dl>
<dt><code>method</code></dt><dd><p>An <a href="#topic+lcMethod">lcMethod</a> object specifying the longitudinal cluster method to apply, or the name (as <code>character</code>) of the <code>lcMethod</code> subclass to instantiate.</p>
</dd>
<dt><code>data</code></dt><dd><p>The data of the trajectories to which to estimate the method for.
Any inputs supported by <code><a href="#topic+trajectories">trajectories()</a></code> can be used, including <code>data.frame</code> and <code>matrix</code>.</p>
</dd>
<dt><code>envir</code></dt><dd><p>The <code>environment</code> in which to evaluate the method arguments via <code><a href="#topic+compose">compose()</a></code>.
If the <code>data</code> argument is of type <code>call</code> then this environment is also used to evaluate the <code>data</code> argument.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>The level of verbosity. Either an object of class <code>Verbose</code> (see <a href="R.utils.html#topic+Verbose">R.utils::Verbose</a> for details),
a <code>logical</code> indicating whether to show basic computation information,
a <code>numeric</code> indicating the verbosity level (see <a href="R.utils.html#topic+Verbose">Verbose</a>),
or one of <code>c('info', 'fine', 'finest')</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The refitted <code>lcModel</code> object, of the same type as the <code>object</code> argument.
</p>


<h3>See Also</h3>

<p><a href="#topic+latrend">latrend</a> <a href="stats.html#topic+getCall">getCall</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latrendData)
method &lt;- lcMethodLMKM(Y ~ Time, id = "Id", time = "Time")
model2 &lt;- latrend(method, latrendData, nClusters = 2)

# fit for a different number of clusters
model3 &lt;- update(model2, nClusters = 3)
</code></pre>

<hr>
<h2 id='validate'><code>lcMethod</code> estimation step: method argument validation logic</h2><span id='topic+validate'></span><span id='topic+validate+2ClcMethod-method'></span>

<h3>Description</h3>

<p>Note: this function should not be called directly, as it is part of the <code>lcMethod</code> <a href="#topic+lcMethod-estimation">estimation procedure</a>.
For fitting an <code>lcMethod</code> object to a dataset, use the <code><a href="#topic+latrend">latrend()</a></code> function or <a href="#topic+latrend-estimation">one of the other standard estimation functions</a>.
</p>
<p>The <code>validate()</code> function of the <code>lcMethod</code> object validates the method with respect to the training data.
This enables a method to verify, for example:
</p>

<ul>
<li><p> whether the formula covariates are present.
</p>
</li>
<li><p> whether the argument combination settings are valid.
</p>
</li>
<li><p> whether the data is suitable for training.
</p>
</li></ul>

<p>By default, the <code>validate()</code> function checks whether the id, time, and response variables are present as columns in the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(method, data, envir, ...)

## S4 method for signature 'lcMethod'
validate(method, data, envir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_method">method</code></td>
<td>
<p>An object inheriting from <code>lcMethod</code> with all its arguments having been evaluated and finalized.</p>
</td></tr>
<tr><td><code id="validate_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> representing the transformed training data.</p>
</td></tr>
<tr><td><code id="validate_+3A_envir">envir</code></td>
<td>
<p>The <code>environment</code> in which the <code>lcMethod</code> should be evaluated</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>TRUE</code> if all validation checks passed,
or a <code style="white-space: pre;">&#8288;scalar character&#8288;</code> containing a description of the failed validation checks.
</p>


<h3>Implementation</h3>

<p>An example implementation checking for the existence of specific arguments and type:
</p>
<pre>

library(assertthat)
setMethod("validate", "lcMethodExample", function(method, data, envir = NULL, ...) {
  validate_that(
    hasName(method, "myArgument"),
    hasName(method, "anotherArgument"),
    is.numeric(method$myArgument)
  )
})
</pre>


<h3>Estimation procedure</h3>

<p>The steps for estimating a <code>lcMethod</code> object are defined and executed as follows:
</p>

<ol>
<li> <p><code><a href="#topic+compose">compose()</a></code>: Evaluate and finalize the method argument values.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code>: Check the validity of the method argument values in relation to the dataset.
</p>
</li>
<li> <p><code><a href="#topic+prepareData">prepareData()</a></code>: Process the training data for fitting.
</p>
</li>
<li> <p><code><a href="#topic+preFit">preFit()</a></code>: Prepare environment for estimation, independent of training data.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Estimate the specified method on the training data, outputting an object inheriting from <code>lcModel</code>.
</p>
</li>
<li> <p><code><a href="#topic+postFit">postFit()</a></code>: Post-process the outputted <code>lcModel</code> object.
</p>
</li></ol>

<p>The result of the fitting procedure is an <a href="#topic+lcModel-class">lcModel</a> object that inherits from the <code>lcModel</code> class.
</p>


<h3>See Also</h3>

<p><a href="assertthat.html#topic+validate_that">assertthat::validate_that</a>
</p>

<hr>
<h2 id='weighted.meanNA'>Weighted arithmetic mean ignoring NAs</h2><span id='topic+weighted.meanNA'></span>

<h3>Description</h3>

<p>Weighted arithmetic mean ignoring NAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.meanNA(x, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.meanNA_+3A_x">x</code></td>
<td>
<p>an object containing the values whose weighted mean is to be
computed.</p>
</td></tr>
<tr><td><code id="weighted.meanNA_+3A_w">w</code></td>
<td>
<p>a numerical vector of weights the same length as <code>x</code> giving
the weights to use for elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="weighted.meanNA_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='which.weight'>Sample an index of a vector weighted by the elements</h2><span id='topic+which.weight'></span>

<h3>Description</h3>

<p>Returns a random index, weighted by the element magnitudes. This function is intended to be used as an optional strategy for <a href="#topic+trajectoryAssignments">trajectoryAssignments</a>, resulting in randomly sampled cluster membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.weight(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.weight_+3A_x">x</code></td>
<td>
<p>A positive <code style="white-space: pre;">&#8288;numeric vector&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>integer</code> giving the index of the sampled element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(.01, .69, .3)
which.weight(x) #1, 2, or 3
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
