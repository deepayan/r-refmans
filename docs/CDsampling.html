<!DOCTYPE html><html lang="en"><head><title>Help for package CDsampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDsampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approxtoexact_constrained_func'><p>Convert the approximate allocation (proportion) to exact allocation (integer) with bounded constraint (ni &lt;= Ni)</p></a></li>
<li><a href='#approxtoexact_func'><p>Convert the approximate allocation (proportion) to exact allocation (integer) without constraint</p></a></li>
<li><a href='#bounded_uniform'><p>Find (constrained) uniform exact allocation of the study for bounded design</p></a></li>
<li><a href='#F_func_GLM'><p>Fisher information matrix of generalized linear model (GLM)</p></a></li>
<li><a href='#F_func_MLM'><p>The Fisher information matrix of multinomial logistic model (MLM)</p></a></li>
<li><a href='#Fdet_func_GLM'><p>Determinant of Fisher information matrix for GLM</p></a></li>
<li><a href='#Fdet_func_MLM'><p>Determinant of Fisher information matrix of multinomial logistic model (MLM)</p></a></li>
<li><a href='#Fdet_func_unif'><p>Determinant function to be used for finding constrained uniform samplings</p></a></li>
<li><a href='#Fi_func_MLM'><p>Generate Fisher information matrix F_x at a design point x_i for Multinomial logistic regression model</p></a></li>
<li><a href='#iset_func_trauma'><p>trauma_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint</p>
Used in approxtoexact_constrained_func()</a></li>
<li><a href='#iset_func_trial'><p>trial_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint</p>
Used in approxtoexact_constrained_func()</a></li>
<li><a href='#liftone_constrained_GLM'><p>Find constrained D-optimal approximate design for generalized linear models (GLM)</p></a></li>
<li><a href='#liftone_constrained_MLM'><p>Find constrained D-optimal designs for Multinomial Logit Models (MLM)</p></a></li>
<li><a href='#liftone_GLM'><p>Unconstrained lift-one algorithm to find D-optimal allocations for GLM</p></a></li>
<li><a href='#liftone_MLM'><p>Unconstrained lift-one algorithm to find D-optimal allocations for MLM</p></a></li>
<li><a href='#print.list_output'><p>Print Method for list_output Objects</p></a></li>
<li><a href='#print.matrix_list'><p>Print Method for matrix_list Objects</p></a></li>
<li><a href='#print.matrix_output'><p>Print Method for matrix_output Objects</p></a></li>
<li><a href='#trauma_data'><p>Trauma data with multinomial response</p></a></li>
<li><a href='#trial_data'><p>Generated clinical trial data with binary response</p></a></li>
<li><a href='#W_func_GLM'><p>Calculate the diagonal elements nu of Fisher information matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'CDsampling': Constraint Sampling in Paid Research Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yifei Huang &lt;yhuan39@uic.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In the context of paid research studies and clinical trials, budget considerations and patient sampling from available populations are subject to inherent constraints. We introduce the 'CDsampling' package, which integrates optimal design theories within the framework of constrained sampling. This package offers the possibility to find both D-optimal approximate and exact allocations for samplings with or without constraints. Additionally, it provides functions to find constrained uniform sampling as a robust sampling strategy with limited model information. Our package offers functions for the computation of the Fisher information matrix under generalized linear models (including regular linear regression model) and multinomial logistic models.To demonstrate the applications, we also provide a simulated dataset and a real dataset embedded in the package. Yifei Huang, Liping Tong, and Jie Yang (2025)&lt;<a href="https://doi.org/10.5705%2Fss.202022.0414">doi:10.5705/ss.202022.0414</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolve, Rglpk, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 22:55:28 UTC; yifeih</td>
</tr>
<tr>
<td>Author:</td>
<td>Yifei Huang [aut, cre],
  Liping Tong [aut],
  Jie Yang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-11 09:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='approxtoexact_constrained_func'>Convert the approximate allocation (proportion) to exact allocation (integer) with bounded constraint (ni &lt;= Ni)</h2><span id='topic+approxtoexact_constrained_func'></span>

<h3>Description</h3>

<p>Convert the approximate allocation (proportion) to exact allocation (integer) with bounded constraint (ni &lt;= Ni)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxtoexact_constrained_func(
  n,
  w,
  m,
  beta = NULL,
  link = NULL,
  X = NULL,
  Fdet_func = Fdet_func_GLM,
  iset_func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxtoexact_constrained_func_+3A_n">n</code></td>
<td>
<p>Sample size, must be a positive integer</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_w">w</code></td>
<td>
<p>Approximate allocation/proportion, must be a real-valued vector, can get from running liftone_constrained_GLM or liftone_constrained_MLM</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_m">m</code></td>
<td>
<p>The number of sampling groups</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_beta">beta</code></td>
<td>
<p>Model parameter coefficients, default to be NULL for use in constrained uniform sampling</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_link">link</code></td>
<td>
<p>Link function of GLM or MLM, if used for GLM model (GLM_T is T), options are &quot;identity&quot;, &quot;logit&quot;, &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;. If used for MLM (GLM_T is F), options are &quot;continuation&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, and &quot;baseline&quot;</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_x">X</code></td>
<td>
<p>Design matrix of the model for GLM or MLM, default to be NULL for use in constrained uniform sampling</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_fdet_func">Fdet_func</code></td>
<td>
<p>determinant of Fisher information matrix function, Fdet_func can be self-defined, or use &quot;Fdet_func_GLM&quot;, &quot;Fdet_func_MLM&quot; in the package, default is Fdet_func_GLM</p>
</td></tr>
<tr><td><code id="approxtoexact_constrained_func_+3A_iset_func">iset_func</code></td>
<td>
<p>self-defined function for checking which index of sampling group fall within constraint if add 1 more subject (I set, see Algorithm 2 in Huang, Tong, Yang (2023)), two example functions are provided in the package, iset_func_trial and iset_func_trauma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>allocation is the exact allocation or integer value of the number of subjects sampled from the group
</p>
<p>allocation.real is the proportion or the approximate allocation of the number of subjects sampled from the group
</p>
<p>det.maximum is the maximum of |F| from the current exact allocation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
beta = c(0, 3, 3, 3) #main effect model beta_0, beta_1, beta_21, beta_22
X.liftone=matrix(data=c(1,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1), ncol=4, byrow=TRUE)
exact_design = approxtoexact_constrained_func(n=200, w=c(0.25, 0.20, 0.05, 0.50, 0.00, 0.00),
m=6, beta=beta, link='logit', X=X.liftone, Fdet_func=Fdet_func_GLM, iset_func=iset_func_trial)

</code></pre>

<hr>
<h2 id='approxtoexact_func'>Convert the approximate allocation (proportion) to exact allocation (integer) without constraint</h2><span id='topic+approxtoexact_func'></span>

<h3>Description</h3>

<p>Convert the approximate allocation (proportion) to exact allocation (integer) without constraint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxtoexact_func(n, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxtoexact_func_+3A_n">n</code></td>
<td>
<p>Sample size, must be a positive integer</p>
</td></tr>
<tr><td><code id="approxtoexact_func_+3A_w">w</code></td>
<td>
<p>Approximate allocation/proportion, must be a real-valued vector, can get from running liftone_constrained_GLM or liftone_constrained_MLM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>allocation is the exact allocation or integer value of the number of subjects sampled from the group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exact_design = approxtoexact_func(n=600, w=c(0.2593526, 0.0000000, 0.0000000,
0.1565024, 0.2891565, 0.0000000, 0.0000000, 0.2949885))


</code></pre>

<hr>
<h2 id='bounded_uniform'>Find (constrained) uniform exact allocation of the study for bounded design</h2><span id='topic+bounded_uniform'></span>

<h3>Description</h3>

<p>Find (constrained) uniform exact allocation of the study for bounded design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounded_uniform(Ni, nsample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounded_uniform_+3A_ni">Ni</code></td>
<td>
<p>a vector with size m, upper bound for exact design of each category/stratification group, if unconstrained, use Inf vector, the function will return unbounded uniform allocation</p>
</td></tr>
<tr><td><code id="bounded_uniform_+3A_nsample">nsample</code></td>
<td>
<p>a number, the sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n is the constrained/unconstrained uniform exact allocation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bounded_uniform(Ni=c(50, 40, 10, 200, 150, 50), nsample=200)

</code></pre>

<hr>
<h2 id='F_func_GLM'>Fisher information matrix of generalized linear model (GLM)</h2><span id='topic+F_func_GLM'></span>

<h3>Description</h3>

<p>Fisher information matrix of generalized linear model (GLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_func_GLM(w, beta, X, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_func_GLM_+3A_w">w</code></td>
<td>
<p>allocation (can be exact or approximate)</p>
</td></tr>
<tr><td><code id="F_func_GLM_+3A_beta">beta</code></td>
<td>
<p>GLM model covariate coefficient</p>
</td></tr>
<tr><td><code id="F_func_GLM_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="F_func_GLM_+3A_link">link</code></td>
<td>
<p>link function, default&quot;logit&quot;, choose from &quot;logit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;probit&quot;, and &quot;identity&quot;(for regular linear regression)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class &quot;matrix_output&quot;, Fisher information matrix given X and model parameter beta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = c(1/3,1/3, 1/3)
beta = c(0.5, 0.5, 0.5)
X = matrix(data=c(1,-1,-1,1,-1,1,1,1,-1), byrow=TRUE, nrow=3)
F_func_GLM(w=w, beta=beta, X=X, link='logit')

</code></pre>

<hr>
<h2 id='F_func_MLM'>The Fisher information matrix of multinomial logistic model (MLM)</h2><span id='topic+F_func_MLM'></span>

<h3>Description</h3>

<p>The Fisher information matrix of multinomial logistic model (MLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_func_MLM(w, beta, X, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_func_MLM_+3A_w">w</code></td>
<td>
<p>allocation (can be exact or approximate)</p>
</td></tr>
<tr><td><code id="F_func_MLM_+3A_beta">beta</code></td>
<td>
<p>MLM model covariate coefficient</p>
</td></tr>
<tr><td><code id="F_func_MLM_+3A_x">X</code></td>
<td>
<p>MLM model matrix</p>
</td></tr>
<tr><td><code id="F_func_MLM_+3A_link">link</code></td>
<td>
<p>link function of Multinomial logistic regression model, options are &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or &quot;continuation&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Fisher information matrix of MLM model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = rep(1/8, 8)
Xi=rep(0,5*12*8) #response levels * num of parameters * num of design points
dim(Xi)=c(5,12,8)
#design matrix
Xi[,,1] = rbind(c( 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,2] = rbind(c( 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,3] = rbind(c( 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,4] = rbind(c( 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,5] = rbind(c( 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,6] = rbind(c( 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,7] = rbind(c( 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,8] = rbind(c( 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
bvec_temp = c(-4.047, -2.225, -0.302, 1.386, 4.214, 3.519, 2.420,
1.284, -0.131, -0.376, -0.237, -0.120)
link_temp = "cumulative"

F_func_MLM(w=w, beta=bvec_temp, X=Xi, link=link_temp)



</code></pre>

<hr>
<h2 id='Fdet_func_GLM'>Determinant of Fisher information matrix for GLM</h2><span id='topic+Fdet_func_GLM'></span>

<h3>Description</h3>

<p>Determinant of Fisher information matrix for GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdet_func_GLM(w, beta, X, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fdet_func_GLM_+3A_w">w</code></td>
<td>
<p>allocation (can be exact or approximate)</p>
</td></tr>
<tr><td><code id="Fdet_func_GLM_+3A_beta">beta</code></td>
<td>
<p>GLM model covariate coefficient</p>
</td></tr>
<tr><td><code id="Fdet_func_GLM_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id="Fdet_func_GLM_+3A_link">link</code></td>
<td>
<p>link function, default&quot;logit&quot;, choose from &quot;logit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;probit&quot;, and &quot;identity&quot;(for regular linear regression)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the determinant of Fisher information matrix given X and model parameter beta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = c(1/3,1/3, 1/3)
beta = c(0.5, 0.5, 0.5)
X = matrix(data=c(1,-1,-1,1,-1,1,1,1,-1), byrow=TRUE, nrow=3)
Fdet_func_GLM(w=w, beta=beta, X=X, link='logit')

</code></pre>

<hr>
<h2 id='Fdet_func_MLM'>Determinant of Fisher information matrix of multinomial logistic model (MLM)</h2><span id='topic+Fdet_func_MLM'></span>

<h3>Description</h3>

<p>Determinant of Fisher information matrix of multinomial logistic model (MLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdet_func_MLM(w, beta, X, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fdet_func_MLM_+3A_w">w</code></td>
<td>
<p>allocation (can be exact or approximate)</p>
</td></tr>
<tr><td><code id="Fdet_func_MLM_+3A_beta">beta</code></td>
<td>
<p>MLM model covariate coefficient</p>
</td></tr>
<tr><td><code id="Fdet_func_MLM_+3A_x">X</code></td>
<td>
<p>MLM model matrix</p>
</td></tr>
<tr><td><code id="Fdet_func_MLM_+3A_link">link</code></td>
<td>
<p>link function of Multinomial logistic regression model, options are &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or &quot;continuation&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Determinant of the Fisher information matrix of MLM model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w = rep(1/8, 8)
Xi=rep(0,5*12*8) #response levels * num of parameters * num of design points
dim(Xi)=c(5,12,8)
#design matrix
Xi[,,1] = rbind(c( 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,2] = rbind(c( 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,3] = rbind(c( 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,4] = rbind(c( 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,5] = rbind(c( 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,6] = rbind(c( 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,7] = rbind(c( 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,8] = rbind(c( 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
bvec_temp = c(-4.047, -2.225, -0.302, 1.386, 4.214, 3.519,
2.420, 1.284, -0.131, -0.376, -0.237, -0.120)
link_temp = "cumulative"

Fdet_func_MLM(w=w, beta=bvec_temp, X=Xi, link=link_temp)



</code></pre>

<hr>
<h2 id='Fdet_func_unif'>Determinant function to be used for finding constrained uniform samplings</h2><span id='topic+Fdet_func_unif'></span>

<h3>Description</h3>

<p>Determinant function to be used for finding constrained uniform samplings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdet_func_unif(w, beta = NULL, X = NULL, link = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fdet_func_unif_+3A_w">w</code></td>
<td>
<p>allocation (can be exact or approximate)</p>
</td></tr>
<tr><td><code id="Fdet_func_unif_+3A_beta">beta</code></td>
<td>
<p>use NULL (default to be NULL)</p>
</td></tr>
<tr><td><code id="Fdet_func_unif_+3A_x">X</code></td>
<td>
<p>use NULL (default to be NULL)</p>
</td></tr>
<tr><td><code id="Fdet_func_unif_+3A_link">link</code></td>
<td>
<p>use NULL (default to be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>product of all allocation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fdet_func_unif(w=c(0.2,0.2,0.2,0.2,0.2))


</code></pre>

<hr>
<h2 id='Fi_func_MLM'>Generate Fisher information matrix F_x at a design point x_i for Multinomial logistic regression model</h2><span id='topic+Fi_func_MLM'></span>

<h3>Description</h3>

<p>Generate Fisher information matrix F_x at a design point x_i for Multinomial logistic regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fi_func_MLM(X_x, beta, link)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fi_func_MLM_+3A_x_x">X_x</code></td>
<td>
<p>model matrix given design point x_i (for example, X_x = h.func(x_i), where h.func transforms a design point to a model matrix)</p>
</td></tr>
<tr><td><code id="Fi_func_MLM_+3A_beta">beta</code></td>
<td>
<p>parameter coefficients in the Multinomial logistic regression model, the order of coefficients in bvec and the order of design points in X_x should be consistent</p>
</td></tr>
<tr><td><code id="Fi_func_MLM_+3A_link">link</code></td>
<td>
<p>link function of Multinomial logistic regression model, options are &quot;baseline&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, or &quot;continuation&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>F_x is the Fisher information matrix at design point x_i (with model matrix X_x);
</p>
<p>U_x is a middle step matrix for calculation of F_x, details see Corollary 3.1 in Bu, X., Majumdar, D., &amp; Yang, J. (2020). D-optimal designs for multinomial logistic models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X_x_temp = rbind(c( 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
bvec_temp = c(-4.047, -2.225, -0.302, 1.386, 4.214, 3.519,
2.420, 1.284, -0.131, -0.376, -0.237, -0.120)
link_temp = "cumulative"
Fi_func_MLM(X_x=X_x_temp, beta=bvec_temp, link=link_temp)
</code></pre>

<hr>
<h2 id='iset_func_trauma'>trauma_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint
Used in approxtoexact_constrained_func()</h2><span id='topic+iset_func_trauma'></span>

<h3>Description</h3>

<p>trauma_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint
Used in approxtoexact_constrained_func()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iset_func_trauma(allocation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iset_func_trauma_+3A_allocation">allocation</code></td>
<td>
<p>the exact allocation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of TRUE and FALSE, if TRUE, it means the allocation of this index will fall out of the constraint with more subject; if TURE, it means the allocation of this index can add more subjects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iset_func_trauma(allocation=c(50,30,10,10,100,100,200,10))



</code></pre>

<hr>
<h2 id='iset_func_trial'>trial_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint
Used in approxtoexact_constrained_func()</h2><span id='topic+iset_func_trial'></span>

<h3>Description</h3>

<p>trial_data example (see Huang, Tong, Yang (2023)) specific function for finding index set that if allocation of that index add &quot;1&quot;, the new allocation still falls within the constraint
Used in approxtoexact_constrained_func()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iset_func_trial(allocation)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iset_func_trial_+3A_allocation">allocation</code></td>
<td>
<p>the exact allocation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of TRUE and FALSE, if TRUE, it means the allocation of this index will fall out of the constraint with more subject; if TURE, it means the allocation of this index can add more subjects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iset_func_trial(allocation=c(50,30,10,100,100,40))

</code></pre>

<hr>
<h2 id='liftone_constrained_GLM'>Find constrained D-optimal approximate design for generalized linear models (GLM)</h2><span id='topic+liftone_constrained_GLM'></span>

<h3>Description</h3>

<p>Find constrained D-optimal approximate design for generalized linear models (GLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftone_constrained_GLM(
  X,
  W,
  g.con,
  g.dir,
  g.rhs,
  lower.bound,
  upper.bound,
  reltol = 1e-05,
  maxit = 500,
  random = TRUE,
  nram = 3,
  w00 = NULL,
  epsilon = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftone_constrained_GLM_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_w">W</code></td>
<td>
<p>Diagonal of W matrix in Fisher information matrix, can be calculated from W_func_GLM in package</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_g.con">g.con</code></td>
<td>
<p>A matrix of numeric constraint coefficients, one row per constraint, on column per variable (to be used in as const.mat lp() and mat in Rglpk_solve_LP())</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_g.dir">g.dir</code></td>
<td>
<p>Vector of character strings giving the direction of the constraint: each value should be one of &quot;&lt;,&quot; &quot;&lt;=,&quot; &quot;=,&quot; &quot;==,&quot; &quot;&gt;,&quot; or &quot;&gt;=&quot;. (In each pair the two values are identical.) to be used as const.dir in lp() and dir in Rglpk_solve_LP()</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_g.rhs">g.rhs</code></td>
<td>
<p>Vector of numeric values for the right-hand sides of the constraints. to be used as const.rhs in lp() and rhs in Rglpk_solve_LP().</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_lower.bound">lower.bound</code></td>
<td>
<p>A function to determine lower bound r_i1 in Step 3 of Constrained lift-one algorithm from Yifei, H., Liping, T., Yang, J. (2023) Constrained D-optimal design for paid research study</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_upper.bound">upper.bound</code></td>
<td>
<p>A function to determine upper bound r_i2 in Step 3 of Constrained lift-one algorithm from Yifei, H., Liping, T., Yang, J. (2023) Constrained D-optimal design for paid research study</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 500</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of random initial points, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_w00">w00</code></td>
<td>
<p>Specified initial design proportion; default to be NULL, this will generate a random initial design</p>
</td></tr>
<tr><td><code id="liftone_constrained_GLM_+3A_epsilon">epsilon</code></td>
<td>
<p>A very small number, for comparison of &gt;0, &lt;0, ==0, to reduce errors, default 1e-12</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w is the approximate D-optimal design
</p>
<p>w0 is the initial design used to get optimal design w
</p>
<p>maximum is the maximized |F| value
</p>
<p>itmax is the number of iterations
</p>
<p>convergence is TRUE or FALSE, if TRUE means the reported design is converged
</p>
<p>deriv.ans is the derivative from step 6 of constrained lift-one algorithm
</p>
<p>gmax is the maximum g function in step 8 of constrained lift-one algorithm
</p>
<p>reason is the lift-one loops break reason, either &quot;all derivatives &lt;=0&quot; or &quot;gmax &lt;=0&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 6 in Section 3.4 of Yifei, H., Liping, T., Yang, J. (2025)
#Constrained D-optimal design for paid research study

#main effect model beta_0, beta_1, beta_21, beta_22
beta = c(0, -0.1, -0.5, -2)

#gives the 6 categories (0,0,0), (0,1,0),(0,0,1),(1,0,0),(1,1,0),(1,0,1)
X.liftone=matrix(data=c(1,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1),
ncol=4, byrow=TRUE)

#calculate W matrix based on beta's under logit link
W_matrix=W_func_GLM(X= X.liftone, b=beta)

m=6 #number of categories
nsample = 200
rc = c(50, 40, 10, 200, 150, 50)/nsample
g.con = matrix(0,nrow=(2*m+1), ncol=m)
g.con[1,] = rep(1, m)
g.con[2:(m+1),] = diag(m)
g.con[(m+2):(2*m+1), ] = diag(m)
g.dir = c("==", rep("&lt;=", m), rep("&gt;=", m))
g.rhs = c(1, rc, rep(0, m))

lower.bound=function(i, w){
  nsample = 200
  rc = c(50, 40, 10, 200, 150, 50)/nsample
  m=length(w) #num of categories
  temp = rep(0,m)
  temp[w&gt;0]=1-pmin(1,rc[w&gt;0])*(1-w[i])/w[w&gt;0];
  temp[i]=0;
  max(0,temp);
}
upper.bound=function(i, w){
  nsample = 200
  rc = c(50, 40, 10, 200, 150, 50)/nsample
  m=length(w) #num of categories
  rc[i];
  min(1,rc[i]);
}

approximate_design = liftone_constrained_GLM(X=X.liftone, W=W_matrix,
g.con=g.con, g.dir=g.dir, g.rhs=g.rhs, lower.bound=lower.bound,
upper.bound=upper.bound, reltol=1e-10, maxit=100, random=TRUE, nram=4,
w00=NULL, epsilon = 1e-8)



</code></pre>

<hr>
<h2 id='liftone_constrained_MLM'>Find constrained D-optimal designs for Multinomial Logit Models (MLM)</h2><span id='topic+liftone_constrained_MLM'></span>

<h3>Description</h3>

<p>Find constrained D-optimal designs for Multinomial Logit Models (MLM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftone_constrained_MLM(
  m,
  p,
  Xi,
  J,
  beta,
  lower.bound,
  upper.bound,
  g.con,
  g.dir,
  g.rhs,
  w00 = NULL,
  link = "cumulative",
  Fi.func = Fi_func_MLM,
  reltol = 1e-05,
  maxit = 500,
  delta = 1e-06,
  epsilon = 1e-08,
  random = TRUE,
  nram = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftone_constrained_MLM_+3A_m">m</code></td>
<td>
<p>The number of design points; it is usually the number of combinations of all the stratification factors</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_p">p</code></td>
<td>
<p>The number of parameters in the MLM model</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_xi">Xi</code></td>
<td>
<p>Model matrix, a J by p by m 3D array of predictors for separate response category at all design points(input to determine ppo,npo,po)</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_j">J</code></td>
<td>
<p>The number of response levels</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_beta">beta</code></td>
<td>
<p>A p*1 vector, parameter coefficients for MLM, the order of beta should be consistent with Xi</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_lower.bound">lower.bound</code></td>
<td>
<p>A function to determine lower bound r_i1 in Step 3 of Constrained lift-one algorithm from Yifei, H., Liping, T., Yang, J. (2023) Constrained D-optimal design for paid research study</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_upper.bound">upper.bound</code></td>
<td>
<p>A function to determine upper bound r_i2 in Step 3 of Constrained lift-one algorithm from Yifei, H., Liping, T., Yang, J. (2023) Constrained D-optimal design for paid research study</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_g.con">g.con</code></td>
<td>
<p>A matrix of numeric constraint coefficients, one row per constraint, on column per variable (to be used in as const.mat lp() and mat in Rglpk_solve_LP())</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_g.dir">g.dir</code></td>
<td>
<p>Vector of character strings giving the direction of the constraint: each value should be one of &quot;&lt;,&quot; &quot;&lt;=,&quot; &quot;=,&quot; &quot;==,&quot; &quot;&gt;,&quot; or &quot;&gt;=&quot;. (In each pair the two values are identical.) to be used as const.dir in lp() and dir in Rglpk_solve_LP()</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_g.rhs">g.rhs</code></td>
<td>
<p>Vector of numeric values for the right-hand sides of the constraints. to be used as const.rhs in lp() and rhs in Rglpk_solve_LP()</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_w00">w00</code></td>
<td>
<p>Specified initial design proportion; default to be NULL, this will generate a random initial design</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_link">link</code></td>
<td>
<p>Link function of MLM, default to be &quot;cumulative&quot;, options from &quot;continuation&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, and &quot;baseline&quot;</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_fi.func">Fi.func</code></td>
<td>
<p>A function for calculating Fisher information at a specific design point, default to be Fi_func_MLM function in the package</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 500</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_delta">delta</code></td>
<td>
<p>A very small number, used in alpha_star calculation, default to be 1e-6.</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_epsilon">epsilon</code></td>
<td>
<p>A very small number, for comparison of &gt;0, &lt;0, ==0, to reduce errors, default 1e-12</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of random initial points, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftone_constrained_MLM_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w is the approximate D-optimal design
</p>
<p>w0 is the initial design used to get optimal design w
</p>
<p>Maximum is the maximized |F| value
</p>
<p>itmax is the number of iterations
</p>
<p>convergence is TRUE or FALSE, if TRUE means the reported design is converged
</p>
<p>deriv.ans is the derivative from step 6 of constrained lift-one algorithm
</p>
<p>gmax is the maximum g function in step 8 of constrained lift-one algorithm
</p>
<p>reason is the lift-one loops break reason, either &quot;all derivatives &lt;=0&quot; or &quot;gmax &lt;=0&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 8 of Trauma data example in Yifei, H., Liping, T., Yang, J. (2025)
#Constrained D-optimal design for paid research study

J = 5    # number of categories,  &gt;= 3
p = 12    # number of parameters
m = 8    # number of design points
nsample=600 #collect 600 samples finally from the 802 subjects
lower.bound &lt;- function(i, w0){
n = 600
constraint = c(392,410)
if(i &lt;= 4){
  a.lower &lt;- (sum(w0[5:8])-(constraint[2]/n)*(1-w0[i]))/(sum(w0[5:8]))
}
else{
  a.lower &lt;- (sum(w0[1:4])-(constraint[1]/n)*(1-w0[i]))/(sum(w0[1:4]))
}
a.lower
}
upper.bound &lt;- function(i, w0){
  n = 600
  constraint = c(392,410)
  if(i &lt;= 4){
    b.upper &lt;- ((constraint[1]/n)*(1-w0[i]) - (sum(w0[1:4])-w0[i]))/(1-sum(w0[1:4]))
  }
  else{
    b.upper &lt;- ((constraint[2]/n)*(1-w0[i]) - (sum(w0[5:8])-w0[i]))/(1-sum(w0[5:8]))
  }
  b.upper
}


constraint = c(392,410)
g.con = matrix(0,nrow=length(constraint)+1+m, ncol=m)
g.con[2:3,] = matrix(data=c(1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1), ncol = m, byrow=TRUE)
g.con[1,] = rep(1, m)
g.con[4:(length(constraint)+1+m), ] = diag(1, nrow=m)
g.dir = c("==", "&lt;=","&lt;=", rep("&gt;=",m))
g.rhs = c(1, ifelse((constraint/nsample&lt;1),constraint/nsample,1), rep(0, m))
Xi=rep(0,J*p*m)
dim(Xi)=c(J,p,m)
Xi[,,1] = rbind(c( 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,2] = rbind(c( 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,3] = rbind(c( 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,4] = rbind(c( 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 0),
              c( 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,5] = rbind(c( 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,6] = rbind(c( 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,7] = rbind(c( 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
Xi[,,8] = rbind(c( 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))
thetavec = c(-4.3050, -0.0744,  4.3053, -2.3334, -0.3290, 3.4773,
-0.1675, -0.3609, 2.7358, 1.2935, -0.1612, 1.4899)
set.seed(123)
liftone_constrained_MLM(m=m, p=p, Xi=Xi, J=J, beta=thetavec, lower.bound=lower.bound,
upper.bound=upper.bound, g.con=g.con,g.dir=g.dir, g.rhs=g.rhs, w00=NULL,
link='cumulative', Fi.func = Fi_func_MLM, reltol=1e-5, maxit=500,
delta = 1e-6, epsilon=1e-8, random=TRUE, nram=1)

</code></pre>

<hr>
<h2 id='liftone_GLM'>Unconstrained lift-one algorithm to find D-optimal allocations for GLM</h2><span id='topic+liftone_GLM'></span>

<h3>Description</h3>

<p>Unconstrained lift-one algorithm to find D-optimal allocations for GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftone_GLM(
  X,
  W,
  reltol = 1e-05,
  maxit = 500,
  random = TRUE,
  nram = 3,
  w00 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftone_GLM_+3A_x">X</code></td>
<td>
<p>Model matrix, with nrow = num of design points and ncol = num of parameters</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_w">W</code></td>
<td>
<p>Diagonal of W matrix in Fisher information matrix, can be calculated from W_func_GLM in package</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 500</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of random initial points, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
<tr><td><code id="liftone_GLM_+3A_w00">w00</code></td>
<td>
<p>Specified initial design proportion; default to be NULL, this will generate a random initial design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w is the approximate D-optimal design
</p>
<p>w0 is the initial design used to get optimal design w
</p>
<p>Maximum is the maximized |F| value
</p>
<p>itmax is the number of iterations
</p>
<p>convergence is TRUE or FALSE, if TRUE means the reported design is converged
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta = c(0.5, 0.5, 0.5)
X = matrix(data=c(1,-1,-1,1,-1,1,1,1,-1), byrow=TRUE, nrow=3)
W_matrix = W_func_GLM(X=X, beta=beta)
w00 = c(1/6, 1/6, 2/3)
approximate_design = liftone_GLM(X=X, W=W_matrix, reltol=1e-10, maxit=100,
random=FALSE, nram=3, w00=w00)

</code></pre>

<hr>
<h2 id='liftone_MLM'>Unconstrained lift-one algorithm to find D-optimal allocations for MLM</h2><span id='topic+liftone_MLM'></span>

<h3>Description</h3>

<p>Unconstrained lift-one algorithm to find D-optimal allocations for MLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liftone_MLM(
  m,
  p,
  Xi,
  J,
  beta,
  link = "continuation",
  Fi.func = Fi_func_MLM,
  reltol = 1e-05,
  maxit = 500,
  w00 = NULL,
  random = TRUE,
  nram = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="liftone_MLM_+3A_m">m</code></td>
<td>
<p>The number of design points; it is usually the number of combinations of all the stratification factors</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_p">p</code></td>
<td>
<p>The number of parameters in the MLM model</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_xi">Xi</code></td>
<td>
<p>Model matrix, a J by p by m 3D array of predictors for separate response category at all design points(input to determine ppo,npo,po)</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_j">J</code></td>
<td>
<p>The number of response levels</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_beta">beta</code></td>
<td>
<p>A p*1 vector, parameter coefficients for MLM, the order of beta should be consistent with Xi</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_link">link</code></td>
<td>
<p>Link function of MLM, default to be &quot;cumulative&quot;, options from &quot;continuation&quot;, &quot;cumulative&quot;, &quot;adjacent&quot;, and &quot;baseline&quot;</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_fi.func">Fi.func</code></td>
<td>
<p>A function for calculating Fisher information at a specific design point, default to be Fi_func_MLM function in the package</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_reltol">reltol</code></td>
<td>
<p>The relative convergence tolerance, default value 1e-5</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations, default value 500</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_w00">w00</code></td>
<td>
<p>Specified initial design proportion; default to be NULL, this will generate a random initial design</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_random">random</code></td>
<td>
<p>TRUE or FALSE, if TRUE then the function will run with additional &quot;nram&quot; number of random initial points, default to be TRUE</p>
</td></tr>
<tr><td><code id="liftone_MLM_+3A_nram">nram</code></td>
<td>
<p>When random == TRUE, the function will generate nram number of initial points, default is 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>w is the approximate D-optimal design
</p>
<p>w0 is the initial design used to get optimal design
</p>
<p>Maximum is the maximized |F| value
</p>
<p>itmax is the number of iterations
</p>
<p>convergence is TRUE or FALSE, if TRUE means the reported design is converged
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J = 5    # number of categories,  &gt;= 3
p = 12    # number of parameters
m = 8    # number of design points
Xi=rep(0,J*p*m) #J*p*m=5*12*8
dim(Xi)=c(J,p,m)
#design matrix
Xi[,,1] = rbind(c( 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,2] = rbind(c( 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,3] = rbind(c( 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,4] = rbind(c( 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,5] = rbind(c( 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,6] = rbind(c( 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,7] = rbind(c( 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1),
               c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

Xi[,,8] = rbind(c( 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1),
                c( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0))

thetavec = c(-4.047, -0.131, 4.214, -2.225, -0.376, 3.519,
-0.302, -0.237,  2.420, 1.386,  -0.120,  1.284)

liftone_MLM(m=m, p=p, Xi=Xi, J=J, beta=thetavec, link = "cumulative",
Fi.func=Fi_func_MLM, reltol=1e-5, maxit=5000, w00=NULL, random=TRUE, nram=3)


</code></pre>

<hr>
<h2 id='print.list_output'>Print Method for list_output Objects</h2><span id='topic+print.list_output'></span>

<h3>Description</h3>

<p>Custom print method for objects of class 'list_output'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.list_output_+3A_x">x</code></td>
<td>
<p>An object of class 'list_output'.</p>
</td></tr>
<tr><td><code id="print.list_output_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns 'x' (the input object).
</p>

<hr>
<h2 id='print.matrix_list'>Print Method for matrix_list Objects</h2><span id='topic+print.matrix_list'></span>

<h3>Description</h3>

<p>Custom print method for objects of class 'matrix_list'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.matrix_list_+3A_x">x</code></td>
<td>
<p>An object of class 'matrix_list'.</p>
</td></tr>
<tr><td><code id="print.matrix_list_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns 'x' (the input object).
</p>

<hr>
<h2 id='print.matrix_output'>Print Method for matrix_output Objects</h2><span id='topic+print.matrix_output'></span>

<h3>Description</h3>

<p>Custom print method for objects of class 'matrix_output'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.matrix_output_+3A_x">x</code></td>
<td>
<p>An object of class 'matrix_output'.</p>
</td></tr>
<tr><td><code id="print.matrix_output_+3A_...">...</code></td>
<td>
<p>Additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns 'x' (the input object).
</p>

<hr>
<h2 id='trauma_data'>Trauma data with multinomial response</h2><span id='topic+trauma_data'></span>

<h3>Description</h3>

<p>The data frame saves data from the trauma trial data from Chuang-Stein and Agresti (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trauma_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 802 rows and 5 variables:
</p>

<dl>
<dt>Severity</dt><dd><p>severity of the trauma symptoms, mild or moderate/severe</p>
</dd>
<dt>Dose</dt><dd><p>dose levels applied to the patients, 4 levels, placebo, low, medium and high</p>
</dd>
<dt>Label</dt><dd><p>stratification group in terms of severity and dose</p>
</dd>
<dt>Outcome</dt><dd><p>treatment outcome, 5 levels, death, vegetative state, major disability, minor disability and good recovery</p>
</dd>
<dt>ID</dt><dd><p>patient ID, 1-802</p>
</dd>
</dl>



<h3>Source</h3>

<p>Chuang-Stein and Agresti (1997)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trauma_data) #lazy loading
</code></pre>

<hr>
<h2 id='trial_data'>Generated clinical trial data with binary response</h2><span id='topic+trial_data'></span>

<h3>Description</h3>

<p>Generated with logistic regression model:
</p>
<p style="text-align: center;"><code class="reqn">logit(P(Y_{ij} = 1 | gender_i, age_{i1}, age_{i2})) = 3*gender_i +3*age_{i1} +3*age_{i2}</code>
</p>

<p>The data frame can be used to run GLM clinical trial example in Huang, Tong, Yang (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trial_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 6 variables:
</p>

<dl>
<dt>gender</dt><dd><p>gender of the patients</p>
</dd>
<dt>age_1</dt><dd><p>1 or 0, whether or not the patient belongs to 18-25 age group</p>
</dd>
<dt>age_2</dt><dd><p>1 or 0, whether or not the patient belongs to 26-64 age group</p>
</dd>
<dt>label</dt><dd><p>stratification group in terms of gender and age, 1 to 6</p>
</dd>
<dt>Y</dt><dd><p>treatment effective or not, Y=1 means treatment is effective to the patient</p>
</dd>
<dt>ID</dt><dd><p>patient ID, 1-500</p>
</dd>
</dl>



<h3>Source</h3>

<p>Generated pseudo clinical trial data to serve as an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(trial_data) #lazy loading

</code></pre>

<hr>
<h2 id='W_func_GLM'>Calculate the diagonal elements nu of Fisher information matrix</h2><span id='topic+W_func_GLM'></span>

<h3>Description</h3>

<p>Calculate the diagonal elements nu of Fisher information matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_func_GLM(X, beta, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_func_GLM_+3A_x">X</code></td>
<td>
<p>Model matrix</p>
</td></tr>
<tr><td><code id="W_func_GLM_+3A_beta">beta</code></td>
<td>
<p>Parameters of GLM model</p>
</td></tr>
<tr><td><code id="W_func_GLM_+3A_link">link</code></td>
<td>
<p>GLM link function, default is &quot;logit&quot;, options are &quot;logit&quot;, &quot;probit&quot;, &quot;cloglog&quot;, &quot;loglog&quot;, &quot;identity&quot;, identity is the same as ordinary linear regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the diagonal element nu of GLM Fisher information matrix, can be used as w in liftone_constrained_GLM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta = c(0, 3, 3, 3) #main effect model beta_0, beta_1, beta_21, beta_22
#gives the 6 categories (0,0,0), (0,1,0),(0,0,1),(1,0,0),(1,1,0),(1,0,1)
X.liftone=matrix(data=c(1,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,1), ncol=4, byrow=TRUE)
#calculate diagonal elements of W based on beta's under logit link
W=W_func_GLM(X= X.liftone, beta=beta, link="logit")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
