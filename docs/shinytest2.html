<!DOCTYPE html><html><head><title>Help for package shinytest2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinytest2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AppDriver'><p>Drive a Shiny application</p></a></li>
<li><a href='#compare_screenshot_threshold'><p>Compare screenshots given threshold value</p></a></li>
<li><a href='#load_app_env'><p>Load the Shiny application's support environment</p></a></li>
<li><a href='#migrate_from_shinytest'><p>Migrate <span class="pkg">shinytest</span> tests</p></a></li>
<li><a href='#platform_variant'><p>Platform specific variant</p></a></li>
<li><a href='#record_test'><p>Launch test event recorder for a Shiny app</p></a></li>
<li><a href='#register_input_processor'><p>Register an input processor for the test recorder</p></a></li>
<li><a href='#test_app'><p>Test Shiny applications with <span class="pkg">testthat</span></p></a></li>
<li><a href='#use_shinytest2'><p>Use <span class="pkg">shinytest2</span> with your Shiny application</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Testing for Shiny Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Automated unit testing of Shiny applications through a headless 'Chromium' browser.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/shinytest2/">https://rstudio.github.io/shinytest2/</a>,
<a href="https://github.com/rstudio/shinytest2">https://github.com/rstudio/shinytest2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/shinytest2/issues">https://github.com/rstudio/shinytest2/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>testthat (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6 (&ge; 2.4.0), callr, checkmate (&ge; 2.0.0), chromote (&ge;
0.1.2), crayon, ellipsis, fs, globals (&ge; 0.14.0), httr,
jsonlite, pingr, rlang (&ge; 0.3.0), rmarkdown, shiny, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deSolve, diffobj, ggplot2, knitr, plotly, png, rstudioapi,
shinyWidgets, shinytest (&ge; 1.5.1), shinyvalidate (&ge; 0.1.2),
showimage, usethis, vdiffr (&ge; 1.0.0), spelling</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>rstudio/shiny</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'R6-helper.R' 'app-driver-chromote.R' 'app-driver-dir.R'
'app-driver-expect-download.R' 'app-driver-expect-js.R'
'app-driver-expect-screenshot.R'
'app-driver-expect-unique-names.R' 'app-driver-expect-values.R'
'app-driver-get-log.R' 'app-driver-initialize.R'
'app-driver-log-message.R' 'app-driver-message.R'
'app-driver-node.R' 'app-driver-set-inputs.R'
'app-driver-start.R' 'app-driver-stop.R' 'app-driver-timeout.R'
'app-driver-upload-file.R' 'app-driver-variant.R'
'app-driver-wait.R' 'app-driver-window.R' 'app-driver.R'
'chromote-methods.R' 'compare-screenshot-threshold.R' 'cpp11.R'
'expect-snapshot.R' 'expr-recurse.R' 'httr.R' 'migrate.R'
'missing-value.R' 'utils.R' 'platform.R'
'record-test-unique-name.R' 'record-test.R' 'rstudio.R'
'save-app.R' 'shiny-browser.R' 'shinytest2-logs.R'
'shinytest2-package.R' 'test-app.R' 'use.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 20:23:52 UTC; cpsievert</td>
</tr>
<tr>
<td>Author:</td>
<td>Barret Schloerke <a href="https://orcid.org/0000-0001-9986-114X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Posit Software, PBC [cph, fnd],
  Winston Chang [ctb] (Original author to rstudio/shinytest),
  Gábor Csárdi [ctb] (Original author to rstudio/shinytest),
  Hadley Wickham [ctb] (Original author to rstudio/shinytest),
  Mango Solutions [cph, ccp] (Original author to rstudio/shinytest)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barret Schloerke &lt;barret@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-26 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AppDriver'>Drive a Shiny application</h2><span id='topic+AppDriver'></span>

<h3>Description</h3>

<p>This class starts a Shiny app in a new R session, along with <span class="pkg">chromote</span>'s
headless browser that can be used to simulate user actions. This provides
a full simulation of a Shiny app so that you can test user interactions
with a live app.
</p>
<p>Methods described below are ordered by perceived popularity.
<em>Expect</em> methods are grouped next to their corresponding <em>get</em> methods.
</p>


<h3>Vignettes</h3>

<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/in-depth.html">Testing in depth</a>
for more details about the different expectation methods.
</p>
<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/robust.html">Robust testing</a>
for more details about the cost / benefits for each expectation method.
</p>


<h3>Test mode</h3>

<p>To have your <code>AppDriver</code> retrieve values from your Shiny app, be sure to
set <code>shiny::runApp(test.mode = TRUE)</code> when running your Shiny app.
</p>
<p>If you are deploying your Shiny app where you do not have control over
the call to <code>shiny::runApp()</code>, you can set <code>options(shiny.testmode = TRUE)</code> in
a <code>.Rprofile</code> file within your Shiny app directory.
</p>


<h3>Start-up failure</h3>

<p>If the app throws an error during initialization, the <code>AppDriver</code> will
be stored in <code>rlang::last_error()$app</code>. This allows for the &quot;failure
to initialize&quot; to be signaled while also allowing for the <code>app</code> to be
retrieved after any initialization error has been thrown.
</p>


<h3>Exporting reactive values</h3>

<p>Reactive values from within your Shiny application can be exported using the
method:
<a href="https://shiny.rstudio.com/reference/shiny/latest/exportTestValues.html"><code>shiny::exportTestValues()</code></a>.
This underutilized method exposes internal values of your app
without needing to create a corresponding input value or output value.
</p>
<p>For example:
</p>
<div class="sourceCode r"><pre>library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Pythagorean theorem"),
    numericInput("A", "A", 3),
    numericInput("B", "B", 4),
    verbatimTextOutput("C"),
  ),
  function(input, output) {
    a_squared &lt;- reactive({ req(input$A); input$A * input$A })
    b_squared &lt;- reactive({ req(input$B); input$B * input$B })
    c_squared &lt;- reactive({ a_squared() + b_squared() })
    c_value &lt;- reactive({ sqrt(c_squared()) })
    output$C &lt;- renderText({ c_value() })

    exportTestValues(
      a_squared = { a_squared() },
      b_squared = { b_squared() },
      c_squared = { c_squared() }
    )
  }
)

app &lt;- AppDriver$new(shiny_app)

init_vals &lt;- app$get_values()
str(init_vals)
#&gt; List of 3
#&gt; $ input :List of 2
#&gt; ..$ A: int 3
#&gt; ..$ B: int 4
#&gt; $ output:List of 1
#&gt; ..$ C: chr "5"
#&gt; $ export:List of 3
#&gt; ..$ a_squared: int 9
#&gt; ..$ b_squared: int 16
#&gt; ..$ c_squared: int 25
</pre></div>
<p>These exported test values are only exposed when <code>shiny::runApp(test.mode = TRUE)</code>
is set.  <span class="pkg">shinytest2</span> sets this variable when running Shiny based app or
document.
</p>


<h3><span class="pkg">testthat</span> wrappers</h3>

<p>The two main expectation methods: <code style="white-space: pre;">&#8288;$expect_values()&#8288;</code> and <code style="white-space: pre;">&#8288;$expect_screenshot()&#8288;</code>
eventually wrap <code><a href="testthat.html#topic+expect_snapshot_file">testthat::expect_snapshot_file()</a></code>.
</p>
<p>Their underlying logic is similar to:
</p>
<div class="sourceCode r"><pre>## Expect values
tmpfile &lt;- tempfile(fileext = ".json")
jsonlite::write_json(app$get_values(), tmpfile)
expect_snapshot_file(
  tmpfile,
  variant = app$get_variant(),
  compare = testthat::compare_file_text,
  cran = cran
)


## Expect screenshot
tmpfile &lt;- tempfile(fileext = ".png")
app$get_screenshot(tmpfile)
expect_snapshot_file(
  tmpfile,
  variant = app$get_variant(),
  compare = testthat::compare_file_binary,
  cran = cran
)
</pre></div>
<p>To update the snapshot values, you will need to run a variation of
<code><a href="testthat.html#topic+snapshot_accept">testthat::snapshot_review()</a></code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AppDriver-new"><code>AppDriver$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-view"><code>AppDriver$view()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-click"><code>AppDriver$click()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-set_inputs"><code>AppDriver$set_inputs()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-upload_file"><code>AppDriver$upload_file()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_values"><code>AppDriver$expect_values()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_value"><code>AppDriver$get_value()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_values"><code>AppDriver$get_values()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_download"><code>AppDriver$expect_download()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_download"><code>AppDriver$get_download()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_text"><code>AppDriver$expect_text()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_text"><code>AppDriver$get_text()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_html"><code>AppDriver$expect_html()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_html"><code>AppDriver$get_html()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_js"><code>AppDriver$expect_js()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_js"><code>AppDriver$get_js()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-run_js"><code>AppDriver$run_js()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_screenshot"><code>AppDriver$expect_screenshot()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_screenshot"><code>AppDriver$get_screenshot()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-wait_for_idle"><code>AppDriver$wait_for_idle()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-wait_for_value"><code>AppDriver$wait_for_value()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-wait_for_js"><code>AppDriver$wait_for_js()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-expect_unique_names"><code>AppDriver$expect_unique_names()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_dir"><code>AppDriver$get_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_url"><code>AppDriver$get_url()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_window_size"><code>AppDriver$get_window_size()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-set_window_size"><code>AppDriver$set_window_size()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_chromote_session"><code>AppDriver$get_chromote_session()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_variant"><code>AppDriver$get_variant()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-get_logs"><code>AppDriver$get_logs()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-log_message"><code>AppDriver$log_message()</code></a>
</p>
</li>
<li> <p><a href="#method-AppDriver-stop"><code>AppDriver$stop()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AppDriver-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize an <code>AppDriver</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$new(
  app_dir = testthat::test_path("../../"),
  ...,
  name = NULL,
  variant = missing_arg(),
  seed = NULL,
  load_timeout = missing_arg(),
  timeout = missing_arg(),
  wait = TRUE,
  screenshot_args = missing_arg(),
  expect_values_screenshot_args = TRUE,
  check_names = TRUE,
  view = missing_arg(),
  height = NULL,
  width = NULL,
  clean_logs = TRUE,
  shiny_args = list(),
  render_args = NULL,
  options = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>app_dir</code></dt><dd><p>This value can be many different things:
</p>

<ul>
<li><p> A directory containing your Shiny application or a run-time Shiny R
Markdown document.
</p>
</li>
<li><p> A URL pointing to your shiny application. (Don't forget to set
<code>testmode = TRUE</code> when running your application!)
</p>
</li>
<li><p> A Shiny application object which inherits from <code>"shiny.appobj"</code>.
</p>
</li></ul>

<p>By default, <code>app_dir</code> is set to <code>test_path("../../")</code> to work in both
interactive and testing usage.
</p>
<p>If a file path is not provided to <code>app_dir</code>, snapshots will be saved as
if the root of the Shiny application was the current directory.</p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>name</code></dt><dd><p>Prefix value to use when saving testthat snapshot files. Ex:
<code style="white-space: pre;">&#8288;NAME-001.json&#8288;</code>. Name <strong>must</strong> be unique when saving multiple snapshots
from within the same testing file. Otherwise, two different <code>AppDriver</code>
objects will be referencing the same files.</p>
</dd>
<dt><code>variant</code></dt><dd><p>If not-<code>NULL</code>, results will be saved in
_snaps/variant/test.md<code style="white-space: pre;">&#8288;, so &#8288;</code>variant' must be a single
string of alphanumeric characters suitable for use as a
directory name.
</p>
<p>You can variants to deal with cases where the snapshot output
varies and you want to capture and test the variations.
Common use cases include variations for operating system, R
version, or version of key dependency. For example usage,
see <code><a href="#topic+platform_variant">platform_variant()</a></code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>An optional random seed to use before starting the application.
For apps that use R's random number generator, this can make their
behavior repeatable.</p>
</dd>
<dt><code>load_timeout</code></dt><dd><p>How long to wait for the app to load, in ms.
This includes the time to start R. Defaults to 15s.
</p>
<p>If <code>load_timeout</code> is missing, the first numeric value found will be used:
</p>

<ul>
<li><p> R option <code>options(shinytest2.load_timeout=)</code>
</p>
</li>
<li><p> System environment variable <code>SHINYTEST2_LOAD_TIMEOUT</code>
</p>
</li>
<li> <p><code>15 * 1000</code> (15 seconds)
</p>
</li></ul>
</dd>
<dt><code>timeout</code></dt><dd><p>Default number of milliseconds for any <code>timeout</code> or
<code>timeout_</code> parameter in the <code>AppDriver</code> class. Defaults to 4s.
</p>
<p>If <code>timeout</code> is missing, the first numeric value found will be used:
</p>

<ul>
<li><p> R option <code>options(shinytest2.timeout=)</code>
</p>
</li>
<li><p> System environment variable <code>SHINYTEST2_TIMEOUT</code>
</p>
</li>
<li> <p><code>4 * 1000</code> (4 seconds)
</p>
</li></ul>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, <code style="white-space: pre;">&#8288;$wait_for_idle(duration = 200, timeout = load_timeout)&#8288;</code>
will be called once the app has connected a new session, blocking until the
Shiny app is idle for 200ms.</p>
</dd>
<dt><code>screenshot_args</code></dt><dd><p>Default set of arguments to pass in to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method when taking
screenshots within <code style="white-space: pre;">&#8288;$expect_screenshot()&#8288;</code>. To disable screenshots by
default, set to <code>FALSE</code>.</p>
</dd>
<dt><code>expect_values_screenshot_args</code></dt><dd><p>The value for <code>screenshot_args</code> when
producing a debug screenshot for <code style="white-space: pre;">&#8288;$expect_values()&#8288;</code>. To disable debug
screenshots by default, set to <code>FALSE</code>.</p>
</dd>
<dt><code>check_names</code></dt><dd><p>Check if widget names are unique once the application
initially loads? If duplicate names are found on initialization, a
warning will be displayed.</p>
</dd>
<dt><code>view</code></dt><dd><p>Opens the <code><a href="chromote.html#topic+ChromoteSession">ChromoteSession</a></code> in an interactive browser tab
before attempting to navigate to the Shiny app.</p>
</dd>
<dt><code>height, width</code></dt><dd><p>Window size to use when opening the
<code><a href="chromote.html#topic+ChromoteSession">ChromoteSession</a></code>. Both <code>height</code> and <code>width</code> values must be non-null
values to be used.</p>
</dd>
<dt><code>clean_logs</code></dt><dd><p>Whether to remove the <code>stdout</code> and <code>stderr</code> Shiny app
logs when the <code>AppDriver</code> object is garbage collected.</p>
</dd>
<dt><code>shiny_args</code></dt><dd><p>A list of options to pass to <code><a href="shiny.html#topic+runApp">shiny::runApp()</a></code>. Ex:
<code>list(port = 8080)</code>.</p>
</dd>
<dt><code>render_args</code></dt><dd><p>Passed to <code>rmarkdown::run(render_args=)</code> for
interactive <code>.Rmd</code>s. Ex: <code>list(quiet = TRUE)</code></p>
</dd>
<dt><code>options</code></dt><dd><p>A list of <code><a href="base.html#topic+options">base::options()</a></code> to set in the Shiny
application's child R process. See <code><a href="shiny.html#topic+shinyOptions">shiny::shinyOptions()</a></code> for
inspiration. If <code>shiny.trace = TRUE</code>, then all WebSocket traffic will
be captured by <code>chromote</code> and time-stamped for logging purposes.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object with class <code>AppDriver</code> and the many methods described in this documentation.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# Create an AppDriver from the Shiny app in the current directory
app &lt;- AppDriver()

# Create an AppDriver object from a different Shiny app directory
example_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver(example_app)

# Expect consistent inital values
app$expect_values()
}
</pre>
</div>


<hr>
<a id="method-AppDriver-view"></a>



<h4>Method <code>view()</code></h4>

<p>View the Shiny application
</p>
<p>Calls <code style="white-space: pre;">&#8288;$view()&#8288;</code> on the <code><a href="chromote.html#topic+ChromoteSession">ChromoteSession</a></code> object to <em>view</em> your Shiny
application in a Chrome browser.
</p>
<p>This method is very helpful for debugging while writing your tests.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$view()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# Open app in Chrome
app$view()
}
</pre>
</div>


<hr>
<a id="method-AppDriver-click"></a>



<h4>Method <code>click()</code></h4>

<p>Click an element
</p>
<p>Find a Shiny input/output value or DOM CSS selector and click it using
the <a href="https://www.w3schools.com/jsref/met_html_click.asp">DOM method <code>TAG.click()</code></a>.
</p>
<p>This method can be used to click input buttons and other elements that
need to simulate a click action.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$click(
  input = missing_arg(),
  output = missing_arg(),
  selector = missing_arg(),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input, output, selector</code></dt><dd><p>A name of an Shiny <code>input</code>/<code>output</code> value or
a DOM CSS selector. Only one of these may be used.</p>
</dd>
<dt><code>...</code></dt><dd><p>If <code>input</code> is used, all extra arguments are passed to
<code style="white-space: pre;">&#8288;$set_inputs(!!input := "click", ...)&#8288;</code>. This means that the
<code>AppDriver</code> will wait until an output has been updated within the
specified <code>timeout_</code>. When clicking any other content, <code>...</code> must be empty.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

tmpfile &lt;- write.csv(cars, "cars.csv")
app$upload_file(file1 = tmpfile)
cat(app$get_text("#view"))
app$set_inputs(dataset = "cars", obs = 6)
app$click("update")
cat(app$get_text("#view"))
}
</pre>
</div>


<hr>
<a id="method-AppDriver-set_inputs"></a>



<h4>Method <code>set_inputs()</code></h4>

<p>Set input values
</p>
<p>Set Shiny inputs by sending the value to the Chrome browser and
programmatically updating the values. Given <code>wait_ = TRUE</code>, the method will
not return until an output value has been updated.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$set_inputs(
  ...,
  wait_ = TRUE,
  timeout_ = missing_arg(),
  allow_no_input_binding_ = FALSE,
  priority_ = c("input", "event")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Name-value pairs, <code style="white-space: pre;">&#8288;component_name_1 = value_1, component_name_2 = value_2&#8288;</code> etc.
Input with name <code>component_name_1</code> will be assigned value <code>value_1</code>.</p>
</dd>
<dt><code>wait_</code></dt><dd><p>Wait until all reactive updates have completed?</p>
</dd>
<dt><code>timeout_</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
<dt><code>allow_no_input_binding_</code></dt><dd><p>When setting the value of an input, allow
it to set the value of an input even if that input does not have an
input binding. This is useful to replicate behavior like hovering over
a <span class="pkg">plotly</span> plot.</p>
</dd>
<dt><code>priority_</code></dt><dd><p>Sets the event priority. For expert use only: see
<a href="https://shiny.rstudio.com/articles/communicating-with-js.html#values-vs-events">https://shiny.rstudio.com/articles/communicating-with-js.html#values-vs-events</a> for details.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

cat(app$get_text("#view"))
app$set_inputs(dataset = "cars", obs = 6)
app$click("update")
cat(app$get_text("#view"))
}
</pre>
</div>


<hr>
<a id="method-AppDriver-upload_file"></a>



<h4>Method <code>upload_file()</code></h4>

<p>Upload a file
</p>
<p>Uploads a file to the specified file input.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$upload_file(..., wait_ = TRUE, timeout_ = missing_arg())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Name-path pair, e.g. <code>component_name = file_path</code>. The file located at
<code>file_path</code> will be uploaded to file input with name <code>component_name</code>.</p>
</dd>
<dt><code>wait_</code></dt><dd><p>Wait until all reactive updates have completed?</p>
</dd>
<dt><code>timeout_</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/09_upload", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save example file
tmpfile &lt;- tempfile(fileext = ".csv")
write.csv(cars, tmpfile, row.names = FALSE)

# Upload file to input named: file1
app$upload_file(file1 = tmpfile)
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_values"></a>



<h4>Method <code>expect_values()</code></h4>

<p>Expect <code>input</code>, <code>output</code>, and <code>export</code> values
</p>
<p>A JSON snapshot is saved of given the results from the underlying call to <code style="white-space: pre;">&#8288;$get_values()&#8288;</code>.
</p>
<p>Note, values that contain environments or other values that will have
trouble serializing may not work well. Instead, these objects should be
manually inspected and have their components tested individually.
</p>
<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/robust.html">Robust testing</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_values(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  screenshot_args = missing_arg(),
  name = NULL,
  cran = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>input, output, export</code></dt><dd><p>Depending on which parameters are supplied, different return values can occur:
* If <code>input</code>, <code>output</code>, and <code>export</code> are all missing, then all values are included in the snapshot.
* If at least one <code>input</code>, <code>output</code>, or <code>export</code> is specified, then only the requested values are included in the snapshot.
</p>
<p>The values supplied to each variable can be:
* A character vector of specific names to only include in the snapshot.
* <code>TRUE</code> to request that all values of that type are included in the snapshot.
* Anything else (e.g. <code>NULL</code> or <code>FALSE</code>) will result in the parameter being ignored.</p>
</dd>
<dt><code>screenshot_args</code></dt><dd><p>This value is passed along to
<code style="white-space: pre;">&#8288;$expect_screenshot()&#8288;</code> where the resulting snapshot expectation is ignored. If
missing, the default value will be
<code style="white-space: pre;">&#8288;$new(expect_values_screenshot_args=)&#8288;</code>.
</p>
<p>The final value can either be:
</p>

<ul>
<li> <p><code>TRUE</code>: A screenshot of the browser's scrollable area will be taken with no delay
</p>
</li>
<li> <p><code>FALSE</code>: No screenshot will be taken
</p>
</li>
<li><p> A named list of arguments. These arguments are passed directly to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method. The <code>selector</code>
and <code>delay</code> will default to <code>"html"</code> and <code>0</code> respectively.
</p>
</li></ul>
</dd>
<dt><code>name</code></dt><dd><p>The file name to be used for the snapshot. The file extension
will be overwritten to <code>.json</code>. By default, the <code>name</code> supplied to
<code>app</code> on initialization with a counter will be used (e.g. <code>"NAME-001.json"</code>).</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The result of the snapshot expectation
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Pythagorean theorem"),
    numericInput("A", "A", 3),
    numericInput("B", "B", 4),
    verbatimTextOutput("C"),
  ),
  function(input, output) {
    a_squared &lt;- reactive({ req(input$A); input$A * input$A })
    b_squared &lt;- reactive({ req(input$B); input$B * input$B })
    c_squared &lt;- reactive({ a_squared() + b_squared() })
    c_value &lt;- reactive({ sqrt(c_squared()) })
    output$C &lt;- renderText({ c_value() })

    exportTestValues(
      a_squared = { a_squared() },
      b_squared = { b_squared() },
      c_squared = { c_squared() }
    )
  }
)

app &lt;- AppDriver$new(shiny_app)

# Snapshot all known values
app$expect_values()

# Snapshot only `export` values
app$expect_values(export = TRUE)

# Snapshot values `"A"` from `input` and `"C"` from `output`
app$expect_values(input = "A", output = "C")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_value"></a>



<h4>Method <code>get_value()</code></h4>

<p>Get a single <code>input</code>, <code>output</code>, or <code>export</code> value
</p>
<p>This is a helper function around <code style="white-space: pre;">&#8288;$get_values()&#8288;</code> to retrieve a single
<code>input</code>, <code>output</code>, or <code>export</code> value. Only a single <code>input</code>, <code>output</code>, or
<code>export</code> value can be used.
</p>
<p>Note, values that contain environments or other values that will have
trouble serializing to RDS may not work well.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_value(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  hash_images = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>input, output, export</code></dt><dd><p>One of these variable should contain a single
string value. If more than one value is specified or no values are
specified, an error will be thrown.</p>
</dd>
<dt><code>hash_images</code></dt><dd><p>If <code>TRUE</code>, images will be hashed before being returned.
Otherwise, all images will return their full data64 encoded value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The requested <code>input</code>, <code>output</code>, or <code>export</code> value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/04_mpg", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Retrieve a single value
app$get_value(output = "caption")
#&gt; [1] "mpg ~ cyl"
# Equivalent code using `$get_values()`
app$get_values(output = "caption")$output$caption
#&gt; [1] "mpg ~ cyl"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_values"></a>



<h4>Method <code>get_values()</code></h4>

<p>Get <code>input</code>, <code>output</code>, and <code>export</code> values
</p>
<p>Retrieves a list of all known <code>input</code>, <code>output</code>, or <code>export</code> values. This
method is a core method when inspecting your Shiny app.
</p>
<p>Note, values that contain environments or other values that will have
trouble serializing may not work well.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_values(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  hash_images = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>input, output, export</code></dt><dd><p>Depending on which parameters are supplied, different return values can occur:
* If <code>input</code>, <code>output</code>, and <code>export</code> are all missing, then all values are included in the snapshot.
* If at least one <code>input</code>, <code>output</code>, or <code>export</code> is specified, then only the requested values are included in the snapshot.
</p>
<p>The values supplied to each variable can be:
* A character vector of specific names to only include in the snapshot.
* <code>TRUE</code> to request that all values of that type are included in the snapshot.
* Anything else (e.g. <code>NULL</code> or <code>FALSE</code>) will result in the parameter being ignored.</p>
</dd>
<dt><code>hash_images</code></dt><dd><p>If <code>TRUE</code>, images will be hashed before being returned.
Otherwise, all images will return their full data64 encoded value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A named list of all inputs, outputs, and export values.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Pythagorean theorem"),
    numericInput("A", "A", 3),
    numericInput("B", "B", 4),
    verbatimTextOutput("C"),
  ),
  function(input, output) {
    a_squared &lt;- reactive({ req(input$A); input$A * input$A })
    b_squared &lt;- reactive({ req(input$B); input$B * input$B })
    c_squared &lt;- reactive({ a_squared() + b_squared() })
    c_value &lt;- reactive({ sqrt(c_squared()) })
    output$C &lt;- renderText({ c_value() })

    exportTestValues(
      a_squared = { a_squared() },
      b_squared = { b_squared() },
      c_squared = { c_squared() }
    )
  }
)

app &lt;- AppDriver$new(shiny_app)

# Show all known values
str(app$get_values())
#&gt; List of 3
#&gt; $ input :List of 2
#&gt; ..$ A: int 3
#&gt; ..$ B: int 4
#&gt; $ output:List of 1
#&gt; ..$ C: chr "5"
#&gt; $ export:List of 3
#&gt; ..$ a_squared: int 9
#&gt; ..$ b_squared: int 16
#&gt; ..$ c_squared: int 25

# Get only `export` values
str(app$get_values(export = TRUE))
#&gt; List of 1
#&gt; $ export:List of 3
#&gt; ..$ a_squared: int 9
#&gt; ..$ b_squared: int 16
#&gt; ..$ c_squared: int 25

# Get values `"A"` from `input` and `"C"` from `output`
str(app$get_values(input = "A", output = "C"))
#&gt; List of 2
#&gt; $ input :List of 1
#&gt; ..$ A: int 3
#&gt; $ output:List of 1
#&gt; ..$ C: chr "5"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_download"></a>



<h4>Method <code>expect_download()</code></h4>

<p>Expect a downloadable file
</p>
<p>Given a <code><a href="shiny.html#topic+downloadButton">shiny::downloadButton()</a></code>/<code><a href="shiny.html#topic+downloadButton">shiny::downloadLink()</a></code> <code>output</code> ID, the corresponding
file will be downloaded and saved as a snapshot file.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_download(
  output,
  ...,
  compare = NULL,
  name = NULL,
  cran = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output</code></dt><dd><p><code>output</code> ID of <code><a href="shiny.html#topic+downloadButton">shiny::downloadButton()</a></code>/<code><a href="shiny.html#topic+downloadButton">shiny::downloadLink()</a></code></p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>compare</code></dt><dd><p>This value is passed through to <code><a href="testthat.html#topic+expect_snapshot_file">testthat::expect_snapshot_file()</a></code>.
By default it is set to <code>NULL</code> which will default to <code>testthat::compare_file_text</code> if <code>name</code>
has extension <code>.r</code>, <code>.R</code>, <code>.Rmd</code>, <code>.md</code>, or <code>.txt</code>, and otherwise uses
<code>testthat::compare_file_binary</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>File name to save file to (including file name extension). The default, <code>NULL</code>,
generates an ascending sequence of names: <code style="white-space: pre;">&#8288;001.download&#8288;</code>,
<code style="white-space: pre;">&#8288;002.download&#8288;</code>, etc.</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/10_download", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save snapshot of rock.csv as 001.download
# Save snapshot value of `rock.csv` to capture default file name
app$expect_download("downloadData", compare = testthat::compare_file_text)
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_download"></a>



<h4>Method <code>get_download()</code></h4>

<p>Get downloadable file
</p>
<p>Given a <code><a href="shiny.html#topic+downloadButton">shiny::downloadButton()</a></code>/<code><a href="shiny.html#topic+downloadButton">shiny::downloadLink()</a></code> <code>output</code> ID, the corresponding
file will be downloaded and saved as a file.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_download(output, filename = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output</code></dt><dd><p><code>output</code> ID of <code><a href="shiny.html#topic+downloadButton">shiny::downloadButton()</a></code>/<code><a href="shiny.html#topic+downloadButton">shiny::downloadLink()</a></code></p>
</dd>
<dt><code>filename</code></dt><dd><p>File path to save the downloaded file to.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code style="white-space: pre;">&#8288;$get_download()&#8288;</code> will return the final save location of the file. This
location can change depending on the value of <code>filename</code> and response
headers.
</p>
<p>Location logic:
</p>

<ul>
<li><p> If <code>filename</code> is not NULL, <code>filename</code> will be returned.
</p>
</li>
<li><p> If a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition"><code>content-disposition</code> <code>filename</code></a> is provided,
then a temp file containing this <code>filename</code> will be
returned.
</p>
</li>
<li><p> Otherwise, a temp file ending in <code>.download</code> will be returned.
</p>
</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/10_download", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Get rock.csv as a tempfile
app$get_download("downloadData")
#&gt; [1] "/TEMP/PATH/rock.csv"

# Get rock.csv as a "./myfile.csv"
app$get_download("downloadData", filename = "./myfile.csv")
#&gt; [1] "./myfile.csv"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_text"></a>



<h4>Method <code>expect_text()</code></h4>

<p>Expect snapshot of UI text
</p>
<p><code style="white-space: pre;">&#8288;$expect_text()&#8288;</code> will extract the text value of all matching elements via
<code>TAG.textContent</code> and store them in a snapshot file. This method is more
robust to internal package change as only the text values will be
maintained. Note, this method will not retrieve any <code style="white-space: pre;">&#8288;&lt;input /&gt;&#8288;</code> value's
text content, e.g. text inputs or text areas, as the input values are not
stored in the live HTML.
</p>
<p>When possible, use <code style="white-space: pre;">&#8288;$expect_text()&#8288;</code> over <code style="white-space: pre;">&#8288;$expect_html()&#8288;</code> to allow
package authors room to alter their HTML structures. The resulting array
of <code>TAG.textContent</code> values found will be stored in a snapshot file.
</p>
<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/robust.html">Robust testing</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_text(selector, ..., cran = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selector</code></dt><dd><p>A DOM CSS selector to be passed into <code>document.querySelectorAll()</code></p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
hello_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(hello_app)

# Make a snapshot of `"Hello Shiny!"`
app$expect_text("h2")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_text"></a>



<h4>Method <code>get_text()</code></h4>

<p>Get UI text
</p>
<p><code style="white-space: pre;">&#8288;$get_text()&#8288;</code> will extract the text value of all matching elements via
<code>TAG.textContent</code>. Note, this method will not retrieve any <code style="white-space: pre;">&#8288;&lt;input /&gt;&#8288;</code>
value's text content, e.g. text inputs or text areas, as the input values
are not stored in the live HTML.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_text(selector)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selector</code></dt><dd><p>A DOM CSS selector to be passed into <code>document.querySelectorAll()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of character values
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
hello_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(hello_app)

app$get_text("h2")
#&gt; [1] "Hello Shiny!"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_html"></a>



<h4>Method <code>expect_html()</code></h4>

<p>Expect snapshot of UI HTML
</p>
<p><code style="white-space: pre;">&#8288;$expect_html()&#8288;</code> will extract the full DOM structures of each matching
element and store them in a snapshot file. This method captures internal
DOM structure which may be brittle to changes by external authors or
dependencies.
</p>
<p>Note, this method will not retrieve any <code style="white-space: pre;">&#8288;&lt;input /&gt;&#8288;</code> value's
text content, e.g. text inputs or text areas, as the input values are not
stored in the live HTML.
</p>
<p>When possible, use <code style="white-space: pre;">&#8288;$expect_text()&#8288;</code> over <code style="white-space: pre;">&#8288;$expect_html()&#8288;</code> to allow
package authors room to alter their HTML structures. The resulting array
of <code>TAG.textContent</code> values found will be stored in a snapshot file.
</p>
<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/robust.html">Robust testing</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_html(selector, ..., outer_html = TRUE, cran = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selector</code></dt><dd><p>A DOM selector to be passed into <code>document.querySelectorAll()</code></p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>outer_html</code></dt><dd><p>If <code>TRUE</code> (default), the full DOM structure will be returned (<code>TAG.outerHTML</code>).
If <code>FALSE</code>, the full DOM structure of the child elements will be returned (<code>TAG.innerHTML</code>).</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/04_mpg", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save a snapshot of the `caption` output
app$expect_html("#caption")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_html"></a>



<h4>Method <code>get_html()</code></h4>

<p>Get UI HTML
</p>
<p><code style="white-space: pre;">&#8288;$get()&#8288;</code> will extract the full DOM structures of each matching
element. This method captures internal
DOM structure which may be brittle to changes by external authors or
dependencies.
</p>
<p>Note, this method will not retrieve any <code style="white-space: pre;">&#8288;&lt;input /&gt;&#8288;</code> value's
text content, e.g. text inputs or text areas, as the input values are not
stored in the live HTML.
</p>
<p>Please see <a href="https://rstudio.github.io/shinytest2/articles/robust.html">Robust testing</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_html(selector, ..., outer_html = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selector</code></dt><dd><p>A DOM selector to be passed into <code>document.querySelectorAll()</code></p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>outer_html</code></dt><dd><p>If <code>TRUE</code>, the full DOM structure will be returned (<code>TAG.outerHTML</code>).
If <code>FALSE</code>, the full DOM structure of the child elements will be returned (<code>TAG.innerHTML</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/03_reactivity", package = "shiny")
app &lt;- AppDriver$new(app_path, check_names = FALSE)

app$set_inputs(caption = "Custom value!")
cat(app$get_html(".shiny-input-container")[1])
#&gt; &lt;div class="form-group shiny-input-container"&gt;
#&gt;   &lt;label class="control-label" id="caption-label" for="caption"&gt;Caption:&lt;/label&gt;
#&gt;   &lt;input id="caption" type="text" class="form-control shiny-bound-input" value="Data Summary"&gt;
#&gt; &lt;/div&gt;
## ^^ No update to the DOM of `caption`
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_js"></a>



<h4>Method <code>expect_js()</code></h4>

<p>Expect snapshot of JavaScript script output
</p>
<p>This is a building block function that may be called by other functions.
For example, <code style="white-space: pre;">&#8288;$expect_text()&#8288;</code> and <code style="white-space: pre;">&#8288;$expect_html()&#8288;</code> are thin wrappers around this function.
</p>
<p>Once the <code>script</code> has executed, the JSON result will be saved to a snapshot file.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_js(
  script = missing_arg(),
  ...,
  file = missing_arg(),
  timeout = missing_arg(),
  pre_snapshot = NULL,
  cran = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>script</code></dt><dd><p>A string containing the JavaScript script to be executed.</p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>file</code></dt><dd><p>A file containing JavaScript code to be read and used as the <code>script</code>. Only one of <code>script</code> or <code>file</code> can be specified.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
<dt><code>pre_snapshot</code></dt><dd><p>A function to be called on the result of the script before taking the snapshot.
<code style="white-space: pre;">&#8288;$expect_html()&#8288;</code> and <code style="white-space: pre;">&#8288;$expect_text()&#8288;</code> both use <code><a href="base.html#topic+unlist">unlist()</a></code>.</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Track how many clicks are given to `#update` button
app$run_js("
  window.test_counter = 0;
  $('#update').click(() =&gt; window.test_counter++);
")
app$set_inputs(obs = 20)
# Click the update button, incrementing the counter
app$click("update")
# Save a snapshot of number of clicks (1)
app$expect_js("window.test_counter;")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_js"></a>



<h4>Method <code>get_js()</code></h4>

<p>Execute JavaScript code in the browser and return the result
</p>
<p>This function will block the local R session until the code has finished
executing its <em>tick</em> in the browser. If a <code>Promise</code> is returned from the
script, <code style="white-space: pre;">&#8288;$get_js()&#8288;</code> will wait for the promise to resolve. To have
JavaScript code execute asynchronously, wrap the code in a Promise object
and have the script return an atomic value.
</p>
<p>Arguments will have to be inserted into the script as there is not access
to <code>arguments</code>. This can be done with commands like <code>paste()</code>. If using
<code>glue::glue()</code>, be sure to use uncommon <code>.open</code> and <code>.close</code> values to
avoid having to double all <code style="white-space: pre;">&#8288;{&#8288;</code> and <code style="white-space: pre;">&#8288;}&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_js(
  script = missing_arg(),
  ...,
  file = missing_arg(),
  timeout = missing_arg()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>script</code></dt><dd><p>JavaScript to execute. If a JavaScript Promise is returned,
the R session will block until the promise has been resolved and return
the value.</p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>file</code></dt><dd><p>A (local) file containing JavaScript code to be read and used
as the <code>script</code>. Only one of <code>script</code> or <code>file</code> can be specified.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Result of the <code>script</code> (or <code>file</code> contents)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
library(shiny)
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Execute JavaScript code in the app's browser
app$get_js("1 + 1;")
#&gt; [1] 2

# Execute a JavaScript Promise. Return the resolved value.
app$get_js("
  new Promise((resolve) =&gt; {
    setTimeout(() =&gt; resolve(1 + 1), 1000)
  }).
  then((value) =&gt; value + 1);
")
#&gt; [1] 3

# With escaped arguments
loc_field &lt;- "hostname"
js_txt &lt;- paste0("window.location[", jsonlite::toJSON(loc_field, auto_unbox = TRUE), "]")
app$get_js(js_txt)
#&gt; [1] "127.0.0.1"

# With `glue::glue()`
js_txt &lt;- glue::glue_data(
  lapply(
    list(x = 40, y = 2),
    jsonlite::toJSON,
    auto_unbox = TRUE
  ),
  .open = "&lt;", .close = "&gt;",
  "let answer = function(a, b) {\n",
  "  return a + b;\n",
  "};\n",
  "answer(&lt;x&gt;, &lt;y&gt;);\n"
)
app$get_js(js_txt)
#&gt; [1] 42
}
</pre>
</div>


<hr>
<a id="method-AppDriver-run_js"></a>



<h4>Method <code>run_js()</code></h4>

<p>Execute JavaScript code in the browser
</p>
<p>This function will block the local R session until the code has finished
executing its <em>tick</em> in the browser.
</p>
<p>The final result of the code will be ignored and not returned to the R session.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$run_js(
  script = missing_arg(),
  ...,
  file = missing_arg(),
  timeout = missing_arg()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>script</code></dt><dd><p>JavaScript to execute.</p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>file</code></dt><dd><p>A (local) file containing JavaScript code to be read and used
as the <code>script</code>. Only one of <code>script</code> or <code>file</code> can be specified.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
library(shiny)
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Get JavaScript answer from the app's browser
app$get_js("1 + 1")
#&gt; [1] 2
# Execute JavaScript code in the app's browser
app$run_js("1 + 1")
# (Returns `app` invisibly)

# With escaped arguments
loc_field &lt;- "hostname"
js_txt &lt;- paste0("window.location[", jsonlite::toJSON(loc_field, auto_unbox = TRUE), "]")
app$run_js(js_txt)
app$get_js(js_txt)
#&gt; [1] "127.0.0.1"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_screenshot"></a>



<h4>Method <code>expect_screenshot()</code></h4>

<p>Expect a screenshot of the Shiny application
</p>
<p>This method takes a screenshot of the application (of only the <code>selector</code>
area) and compares the image to the expected image.
</p>
<p>Please be aware that this method is very brittle to changes outside of your Shiny application.
These changes can include:
</p>

<ul>
<li><p> running on a different R version
</p>
</li>
<li><p> running on a different in operating system
</p>
</li>
<li><p> using a different default system font
</p>
</li>
<li><p> using different package versions
These differences are explicitly clear when working with plots.
</p>
</li></ul>

<p>Unless absolutely necessary for application consistency, it is strongly
recommended to use other expectation methods.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_screenshot(
  ...,
  threshold = NULL,
  kernel_size = 5,
  screenshot_args = missing_arg(),
  delay = missing_arg(),
  selector = missing_arg(),
  compare = missing_arg(),
  quiet = FALSE,
  name = NULL,
  cran = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>Parameter supplied to <code><a href="#topic+compare_screenshot_threshold">compare_screenshot_threshold()</a></code>
when using the default <code>compare</code> method. If the value of <code>threshold</code> is
<code>NULL</code>, <code><a href="#topic+compare_screenshot_threshold">compare_screenshot_threshold()</a></code> will act like
<code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary</a></code>. However, if <code>threshold</code> is a positive number,
it will be compared against the largest convolution value found if the
two images fail a <code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary</a></code> comparison.
</p>
<p>Which value should I use? Threshold values values below 5 help deter
false-positive screenshot comparisons (such as inconsistent rounded
corners). Larger values in the 10s and 100s will help find <em>real</em>
changes. However, not all values are one size fits all and you will need
to play with a threshold that fits your needs.</p>
</dd>
<dt><code>kernel_size</code></dt><dd><p>Parameter supplied to <code><a href="#topic+compare_screenshot_threshold">compare_screenshot_threshold()</a></code>
when using the default <code>compare</code> method. The <code>kernel_size</code> represents the
height and width of the convolution kernel applied to the pixel
differences. This integer-like value should be relatively small.</p>
</dd>
<dt><code>screenshot_args</code></dt><dd><p>This named list of arguments is passed along to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method. If missing, the
value will default to <code style="white-space: pre;">&#8288;$new(screenshot_args=)&#8288;</code>.
</p>
<p>If <code>screenshot_args</code> is:
</p>

<ul>
<li> <p><code>TRUE</code>: A screenshot of the browser's scrollable area will be taken with no delay
</p>
</li>
<li><p> A named list of arguments: Arguments passed directly to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method. The <code>delay</code>
argument will default to <code>0</code> seconds. The <code>selector</code> argument can take two
special values in addition to being a CSS DOM selector.
</p>

<ul>
<li> <p><code>"scrollable_area"</code> (default): The entire scrollable area will be
captured. Typically this is your browser's viewport size, but it
can be larger if the page is scrollable. This value works well with
Apps that contain elements whose calculated dimensions may be
different than their presented size.
</p>
</li>
<li> <p><code>"viewport"</code>: This value will capture the browser's viewport in its
current viewing location, height, and width. It will only capture
what is currently being seen with <code style="white-space: pre;">&#8288;$view()&#8288;</code>.
</p>
</li></ul>

<p>In <code>v0.3.0</code>, the default <code>selector</code> value was changed from the HTML DOM
selector (<code>"html"</code>) to entire scrollable area (<code>"scrollable_area"</code>).
</p>
</li></ul>
</dd>
<dt><code>delay</code></dt><dd><p>The number of <strong>seconds</strong> to wait before taking the screenshot.
This value can be supplied as <code>delay</code> or <code>screenshot_args$delay</code>, with the
<code>delay</code> parameter having preference.</p>
</dd>
<dt><code>selector</code></dt><dd><p>The selector is a CSS selector that will be used to select a
portion of the page to be captured. This value can be supplied as
<code>selector</code> or <code>screenshot_args$selector</code>, with the <code>selector</code> parameter
having preference.
</p>
<p>In <code>v0.3.0</code>, two special <code>selector</code> values were added:
</p>

<ul>
<li> <p><code>"scrollable_area"</code> (default): The entire scrollable area will be
captured. Typically this is your browser's viewport size, but it can be
larger if the page is scrollable. This value works well with Apps that
contain elements whose calculated dimensions may be different than their
presented size.
</p>
</li>
<li> <p><code>"viewport"</code>: This value will capture the browser's viewport in its
current viewing location, height, and width. It will only capture
what is currently being seen with <code style="white-space: pre;">&#8288;$view()&#8288;</code>.
</p>
</li></ul>

<p>In <code>v0.3.0</code>, the default <code>selector</code> value was changed from the HTML DOM
selector (<code>"html"</code>) to entire scrollable area (<code>"scrollable_area"</code>).</p>
</dd>
<dt><code>compare</code></dt><dd><p>A function used to compare the screenshot snapshot files.
The function should take two inputs, the paths to the <code>old</code> and <code>new</code>
snapshot, and return either <code>TRUE</code> or <code>FALSE</code>.
</p>
<p><code>compare</code> defaults to a function that wraps around
<code>compare_screenshot_threshold(old, new, threshold = threshold, kernel_size = kernel_size, quiet = quiet)</code>. Note: if <code>threshold</code> is
<code>NULL</code> (default), <code>compare</code> will behave as if
<code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary()</a></code> was provided, comparing the two
images byte-by-byte.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>Parameter supplied to <code><a href="#topic+compare_screenshot_threshold">compare_screenshot_threshold()</a></code>
when using the default <code>compare</code> method. If <code>FALSE</code>, diagnostic
information will be presented when the computed value is larger than a
non-<code>NULL</code> <code>threshold</code> value.</p>
</dd>
<dt><code>name</code></dt><dd><p>The file name to be used for the snapshot. The file extension
will overwritten to <code>.png</code>. By default, the <code>name</code> supplied to
<code>app</code> on initialization with a counter will be used (e.g. <code>"NAME-001.png"</code>).</p>
</dd>
<dt><code>cran</code></dt><dd><p>Should these expectations be verified on CRAN? By default,
they are not because snapshot tests tend to be fragile
because they often rely on minor details of dependencies.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# These example lines should be performed in a `./tests/testthat`
# test file so that snapshot files can be properly saved

app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path, variant = platform_variant())

# Expect a full size screenshot to be pixel perfect
app$expect_screenshot()

# Images are brittle when containing plots
app$expect_screenshot(selector = "#distPlot")

# Test with more threshold in pixel value differences
# Helps with rounded corners
app$expect_screenshot(threshold = 10)

# Equivalent expectations
app$expect_screenshot() # default
app$expect_screenshot(threshold = NULL)
app$expect_screenshot(compare = testthat::compare_file_binary)
expect_snapshot_file(
  app$get_screenshot(),
  variant = app$get_variant(),
  compare = testthat::compare_file_binary
)

# Equivalent expectations
app$expect_screenshot(threshold = 3, kernel_size = 5)
app$expect_screenshot(compare = function(old, new) {
  compare_screenshot_threshold(
    old, new,
    threshold = 3,
    kernel_size = 5
  )
})
expect_screenshot_file(
  app$get_screenshot(),
  variant = app$get_variant(),
  compare = function(old, new) {
    compare_screenshot_threshold(
      old, new,
      threshold = 3,
      kernel_size = 5
    )
  }
)

# Take a screenshot of the entire scrollable area
app$expect_screenshot()
app$expect_screenshot(selector = "scrollable_area")

## Take a screenshot of the current viewport
# Shrink the window to be smaller than the app
app$set_window_size(400, 500)
# Scroll the viewport just a bit
app$run_js("window.scroll(30, 70)")
# Take screenshot of browser viewport
app$expect_screenshot(selector = "viewport")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_screenshot"></a>



<h4>Method <code>get_screenshot()</code></h4>

<p>Take a screenshot
</p>
<p>Take a screenshot of the Shiny application.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_screenshot(
  file = NULL,
  ...,
  screenshot_args = missing_arg(),
  delay = missing_arg(),
  selector = missing_arg()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>If <code>NULL</code>, then the image will be displayed to the current
Graphics Device. If a file path, then the screenshot will be saved to
that file.</p>
</dd>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>screenshot_args</code></dt><dd><p>This named list of arguments is passed along to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method. If missing, the
value will default to <code style="white-space: pre;">&#8288;$new(screenshot_args=)&#8288;</code>.
</p>
<p>If <code>screenshot_args</code> is:
</p>

<ul>
<li> <p><code>TRUE</code>: A screenshot of the browser's scrollable area will be taken with no delay
</p>
</li>
<li><p> A named list of arguments: Arguments passed directly to
<code><a href="chromote.html#topic+ChromoteSession">chromote::ChromoteSession</a></code>'s <code style="white-space: pre;">&#8288;$get_screenshot()&#8288;</code> method. The <code>delay</code>
argument will default to <code>0</code> seconds. The <code>selector</code> argument can take two
special values in addition to being a CSS DOM selector.
</p>

<ul>
<li> <p><code>"scrollable_area"</code> (default): The entire scrollable area will be
captured. Typically this is your browser's viewport size, but it can be
larger if the page is scrollable. This value works well with Apps that
contain elements whose calculated dimensions may be different than
their presented size.
</p>
</li>
<li> <p><code>"viewport"</code>: This value will capture the browser's viewport in its
current viewing location, height, and width. It will only capture
what is currently being seen with <code style="white-space: pre;">&#8288;$view()&#8288;</code>.
</p>
</li></ul>

<p>In <code>v0.3.0</code>, the default <code>selector</code> value was changed from the HTML DOM
selector (<code>"html"</code>) to entire scrollable area (<code>"scrollable_area"</code>).
</p>
</li></ul>

<p>If <code>screenshot_args=FALSE</code> is provided, the parameter will be ignored and a
screenshot will be taken with default behavior.</p>
</dd>
<dt><code>delay</code></dt><dd><p>The number of <strong>seconds</strong> to wait before taking the screenshot.
This value can be supplied as <code>delay</code> or <code>screenshot_args$delay</code>, with the
<code>delay</code> parameter having preference.</p>
</dd>
<dt><code>selector</code></dt><dd><p>The selector is a CSS selector that will be used to select a
portion of the page to be captured. This value can be supplied as
<code>selector</code> or <code>screenshot_args$selector</code>, with the <code>selector</code> parameter
having preference.
</p>
<p>In <code>v0.3.0</code>, two special <code>selector</code> values were added:
</p>

<ul>
<li> <p><code>"scrollable_area"</code> (default): The entire scrollable area will be
captured. Typically this is your browser's viewport size, but it can be
larger if the page is scrollable. This value works well with Apps that
contain elements whose calculated dimensions may be different than their
presented size.
</p>
</li>
<li> <p><code>"viewport"</code>: This value will capture the browser's viewport in its
current viewing location, height, and width. It will only capture
what is currently being seen with <code style="white-space: pre;">&#8288;$view()&#8288;</code>.
</p>
</li></ul>

<p>In <code>v0.3.0</code>, the default <code>selector</code> value was changed from the HTML DOM
selector (<code>"html"</code>) to entire scrollable area (<code>"scrollable_area"</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Display in graphics device
app$get_screenshot()

# Update bins then display `"disPlot"` in graphics device
app$set_inputs(bins = 10)
app$get_screenshot(selector = "#distPlot")

# Save screenshot to file and view it
tmpfile &lt;- tempfile(fileext = ".png")
app$get_screenshot(tmpfile)
showimage::show_image(tmpfile)
}
</pre>
</div>


<hr>
<a id="method-AppDriver-wait_for_idle"></a>



<h4>Method <code>wait_for_idle()</code></h4>

<p>Wait for Shiny to not be busy (idle) for a set amount of time
</p>
<p>Waits until Shiny has not been busy for a set duration of time, e.g. no
reactivity is updating or has occurred.
</p>
<p>This is useful, for example, when waiting for your application to
initialize or if you've resized the window with <code style="white-space: pre;">&#8288;$set_window_size()&#8288;</code> and
want to make sure all plot redrawing is complete before take a
screenshot.
</p>
<p>By default,
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$new(wait = TRUE)&#8288;</code> waits for Shiny to not be busy after initializing
the application
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$set_window_size(wait = TRUE)&#8288;</code> waits for Shiny to not be busy after
resizing the window.)
</p>
</li></ul>



<h5>Usage</h5>

<div class="r"><pre>AppDriver$wait_for_idle(duration = 500, timeout = missing_arg())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>duration</code></dt><dd><p>How long Shiny must be idle (in ms) before unblocking the
R session.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>invisible(self)</code> if Shiny stabilizes within the <code>timeout</code>.
Otherwise an error will be thrown
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

pre_value &lt;- app$get_value(output = "distPlot")
# Update bins value
app$set_inputs(bins = 10, wait_ = FALSE)
middle_value &lt;- app$get_value(output = "distPlot")
app$wait_for_idle()
post_value &lt;- app$get_value(output = "distPlot")

# No guarantee that these values are different
identical(pre_value, middle_value)
# Will not be equal
identical(pre_value, post_value)

# ---------------------
## Change the screen size to trigger a plot update
pre_value &lt;- app$get_value(output = "distPlot")
app$set_window_size(height = 1080, width = 1920, wait = FALSE)
middle_value &lt;- app$get_value(output = "distPlot")
app$wait_for_idle()
post_value &lt;- app$get_value(output = "distPlot")

# No guarantee that these values are different
identical(pre_value, middle_value)
# Will not be equal
identical(pre_value, post_value)
}
</pre>
</div>


<hr>
<a id="method-AppDriver-wait_for_value"></a>



<h4>Method <code>wait_for_value()</code></h4>

<p>Wait for a new Shiny value
</p>
<p>Waits until an <code>input</code>, <code>output</code>, or <code>export</code> Shiny value is not one of
<code>ignore</code>d values, or the <code>timeout</code> is reached.
</p>
<p>Only a single <code>input</code>, <code>output</code>, or <code>export</code> value may be used.
</p>
<p>This function can be useful in helping determine if an application
has finished processing a complex reactive situation.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$wait_for_value(
  ...,
  input = missing_arg(),
  output = missing_arg(),
  export = missing_arg(),
  ignore = list(NULL, ""),
  timeout = missing_arg(),
  interval = 400
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Must be empty. Allows for parameter expansion.</p>
</dd>
<dt><code>input, output, export</code></dt><dd><p>A name of an input, output, or export value.
Only one of these parameters may be used.</p>
</dd>
<dt><code>ignore</code></dt><dd><p>List of possible values to ignore when checking for
updates.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>Amount of time to wait before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
<dt><code>interval</code></dt><dd><p>How often to check for the condition, in ms.</p>
</dd>
<dt><code>timeout_</code></dt><dd><p>Amount of time to wait for a new <code>output</code> value before giving up (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Newly found value
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Dynamic output"),
    actionButton("display", "Display UI"),
    uiOutput("dym1"),
  ),
  function(input, output) {
    output$dym1 &lt;- renderUI({
      req(input$display)
      Sys.sleep(runif(1, max = 2)) # Artificial calculations
      tagList(
        sliderInput("slider1", "Slider #1", 0, 100, 25),
        uiOutput("dym2")
      )
    })
    output$dym2 &lt;- renderUI({
      Sys.sleep(runif(1, max = 2)) # Artificial calculations
      tagList(
        sliderInput("slider2", "Slider #2", 0, 100, 50),
        "Total:", verbatimTextOutput("total")
      )
    })
    output$total &lt;- renderText({
      req(input$slider1, input$slider2)
      input$slider1 + input$slider2
    })
  }
)

app &lt;- AppDriver$new(shiny_app)

# Create UI / output values
app$click("display")
# Wait for total to be calculated (or have a non-NULL value)
new_total_value &lt;- app$wait_for_value(output = "total")
#&gt; [1] "75"
app$get_value(output = "total")
#&gt; [1] "75"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-wait_for_js"></a>



<h4>Method <code>wait_for_js()</code></h4>

<p>Wait for a JavaScript expression to be true
</p>
<p>Waits until a JavaScript <code>expr</code>ession evaluates to <code>true</code> or the
<code>timeout</code> is exceeded.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$wait_for_js(script, timeout = missing_arg(), interval = 100)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>script</code></dt><dd><p>A string containing JavaScript code. This code must
eventually return a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy"><code>true</code>thy value</a> or a
timeout error will be thrown.</p>
</dd>
<dt><code>timeout</code></dt><dd><p>How long the script has to return a <code>true</code>thy value (milliseconds).
Defaults to the resolved <code>timeout</code> value during the <code>AppDriver</code> initialization.</p>
</dd>
<dt><code>interval</code></dt><dd><p>How often to check for the condition (milliseconds).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>invisible(self)</code> if expression evaluates to <code>true</code> without error
within the timeout. Otherwise an error will be thrown
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Contrived example:
# Wait until `Date.now()` returns a number that ends in a 5. (0 - 10 seconds)
system.time(
  app$wait_for_js("Math.floor((Date.now() / 1000) % 10) == 5;")
)

## A second example where we run the contents of a JavaScript file
## and use the result to wait for a condition
app$run_js(file = "complicated_file.js")
app$wait_for_js("complicated_condition();")
}
</pre>
</div>


<hr>
<a id="method-AppDriver-expect_unique_names"></a>



<h4>Method <code>expect_unique_names()</code></h4>

<p>Expect unique input and output names.
</p>
<p>If the HTML has duplicate input or output elements with matching <code>id</code>
values, this function will throw an error. It is similar to
<code>AppDriver$new(check_names = TRUE)</code>, but asserts that no warnings are
displayed.
</p>
<p>This method will not throw if a single input and a single output have the
same name.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$expect_unique_names()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
shiny_app &lt;- shinyApp(
  ui = fluidPage(
    # Duplicate input IDs: `"text"`
    textInput("text", "Text 1"),
    textInput("text", "Text 2")
  ),
  server = function(input, output) {
    # empty
  }
)
# Initial checking for unique names (default behavior)
app &lt;- AppDriver$new(shiny_app, check_names = TRUE)
#&gt; Warning:
#&gt; ! Shiny inputs should have unique HTML id values.
#&gt; i The following HTML id values are not unique:
#&gt; • text
app$stop()

# Manually assert that all names are unique
app &lt;- AppDriver$new(shiny_app, check_names = FALSE)
app$expect_unique_names()
#&gt; Error: `app_check_unique_names(self, private)` threw an unexpected warning.
#&gt; Message: ! Shiny inputs should have unique HTML id values.
#&gt; i The following HTML id values are not unique:
#&gt;   • text
#&gt; Class:   rlang_warning/warning/condition
app$stop()
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_dir"></a>



<h4>Method <code>get_dir()</code></h4>

<p>Retrieve the Shiny app path
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_dir()</pre></div>



<h5>Returns</h5>

<p>The directory containing the Shiny application or Shiny runtime
document. If a URL was provided to <code>app_dir</code> during initialization, the
current directory will be returned.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

identical(app$get_dir(), app_path)
#&gt; [1] TRUE
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_url"></a>



<h4>Method <code>get_url()</code></h4>

<p>Retrieve the Shiny app URL
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_url()</pre></div>



<h5>Returns</h5>

<p>URL where the Shiny app is being hosted
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

browseURL(app$get_url())
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_window_size"></a>



<h4>Method <code>get_window_size()</code></h4>

<p>Get window size
</p>
<p>Get current size of the browser window, as list of numeric scalars
named <code>width</code> and <code>height</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_window_size()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

app$get_window_size()
#&gt; $width
#&gt; [1] 992
#&gt;
#&gt; $height
#&gt; [1] 1323
}
</pre>
</div>


<hr>
<a id="method-AppDriver-set_window_size"></a>



<h4>Method <code>set_window_size()</code></h4>

<p>Sets size of the browser window.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$set_window_size(width, height, wait = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>width, height</code></dt><dd><p>Height and width of browser, in pixels.</p>
</dd>
<dt><code>wait</code></dt><dd><p>If <code>TRUE</code>, <code style="white-space: pre;">&#8288;$wait_for_idle()&#8288;</code> will be called after setting
the window size. This will block until any width specific items (such
as plots) that need to be re-rendered.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
# Set init window size
app &lt;- AppDriver$new(app_path, height = 1400, width = 1000)

app$get_window_size()
#&gt; $width
#&gt; [1] 1000
#&gt;
#&gt; $height
#&gt; [1] 1400

# Manually set the window size
app$set_window_size(height = 1080, width = 1920)
app$get_window_size()
#&gt; $width
#&gt; [1] 1920
#&gt;
#&gt; $height
#&gt; [1] 1080
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_chromote_session"></a>



<h4>Method <code>get_chromote_session()</code></h4>

<p>Get Chromote Session
</p>
<p>Get the <code><a href="chromote.html#topic+ChromoteSession">ChromoteSession</a></code> object from the <span class="pkg">chromote</span> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_chromote_session()</pre></div>



<h5>Returns</h5>

<p><code><a href="chromote.html#topic+ChromoteSession">ChromoteSession</a></code> R6 object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

b &lt;- app$get_chromote_session()
b$Runtime$evaluate("1 + 1")
#&gt; $result
#&gt; $result$type
#&gt; [1] "number"
#&gt;
#&gt; $result$value
#&gt; [1] 2
#&gt;
#&gt; $result$description
#&gt; [1] "2"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_variant"></a>



<h4>Method <code>get_variant()</code></h4>

<p>Get the variant
</p>
<p>Get the <code>variant</code> supplied during initialization
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_variant()</pre></div>



<h5>Returns</h5>

<p>The <code>variant</code> value supplied during initialization or <code>NULL</code> if
no value was supplied.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")

app &lt;- AppDriver$new(app_path)

app$get_variant()
#&gt; NULL

app &lt;- AppDriver$new(app_path, variant = platform_variant())
app$get_variant()
#&gt; [1] "mac-4.1"
}
</pre>
</div>


<hr>
<a id="method-AppDriver-get_logs"></a>



<h4>Method <code>get_logs()</code></h4>

<p>Get all logs
</p>
<p>Retrieve all of the debug logs that have been recorded.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$get_logs()</pre></div>



<h5>Returns</h5>

<p>A data.frame with the following columns:
</p>

<ul>
<li> <p><code>workerid</code>: The shiny worker ID found within the browser
</p>
</li>
<li> <p><code>timestamp</code>: POSIXct timestamp of the message
</p>
</li>
<li> <p><code>location</code>: The location of the message was found. One of three values:
</p>

<ul>
<li> <p><code>"shinytest2"</code>: Occurs when <code style="white-space: pre;">&#8288;$log_message()&#8288;</code> is called
</p>
</li>
<li> <p><code>"shiny"</code>: <code>stdin</code> and <code>stdout</code> messages from the Shiny server. Note <code>message()</code> output is sent to <code>stdout</code>.
</p>
</li>
<li> <p><code>"chromote"</code>: Captured by the <span class="pkg">chromote</span> event handlers. See
<a href="https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#event-consoleAPICalled">console API</a>,
<a href="https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#event-exceptionThrown">exception thrown</a>,
<a href="https://chromedevtools.github.io/devtools-protocol/1-3/Network/#event-webSocketFrameSent">websocket sent</a>, and
<a href="https://chromedevtools.github.io/devtools-protocol/1-3/Network/#event-webSocketFrameReceived">websocket received</a>
for more details
</p>
</li></ul>

</li>
<li> <p><code>level</code>: For a given location, there are different types of log levels.
</p>

<ul>
<li> <p><code>"shinytest2"</code>: <code>"log"</code>; Only log messages are captured.
</p>
</li>
<li> <p><code>"shiny"</code>: <code>"stdout"</code> or <code>"stderr"</code>; Note, <code>message()</code> output is sent
to <code>stderr</code>.
</p>
</li>
<li> <p><code>"chromote"</code>: Correspond to any level of a JavaScript
<code>console.LEVEL()</code> function call. Typically, these are &quot;log&quot;<code>and</code>&quot;error&quot;<code style="white-space: pre;">&#8288;but can include&#8288;</code>&quot;info&quot;<code style="white-space: pre;">&#8288;, &#8288;</code>&quot;debug&quot;<code style="white-space: pre;">&#8288;, and &#8288;</code>&quot;warn&quot;<code style="white-space: pre;">&#8288;. If &#8288;</code>options(shiny.trace = TRUE)<code style="white-space: pre;">&#8288;, then the level will recorded as &#8288;</code>&quot;websocket&quot;'.
</p>
</li></ul>

</li></ul>




<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app1 &lt;- AppDriver$new(system.file("examples/01_hello", package = "shiny"))

app1$get_logs()
#&gt; {shinytest2} R  info   10:00:28.86 Start AppDriver initialization
#&gt; {shinytest2} R  info   10:00:28.86 Starting Shiny app
#&gt; {shinytest2} R  info   10:00:29.76 Creating new ChromoteSession
#&gt; {shinytest2} R  info   10:00:30.56 Navigating to Shiny app
#&gt; {shinytest2} R  info   10:00:30.70 Injecting shiny-tracer.js
#&gt; {chromote}   JS info   10:00:30.75 shinytest2; jQuery found
#&gt; {chromote}   JS info   10:00:30.77 shinytest2; Waiting for shiny session to connect
#&gt; {chromote}   JS info   10:00:30.77 shinytest2; Loaded
#&gt; {shinytest2} R  info   10:00:30.77 Waiting for Shiny to become ready
#&gt; {chromote}   JS info   10:00:30.90 shinytest2; Connected
#&gt; {chromote}   JS info   10:00:30.95 shinytest2; shiny:busy
#&gt; {shinytest2} R  info   10:00:30.98 Waiting for Shiny to become idle for 200ms within 15000ms
#&gt; {chromote}   JS info   10:00:30.98 shinytest2; Waiting for Shiny to be stable
#&gt; {chromote}   JS info   10:00:31.37 shinytest2; shiny:idle
#&gt; {chromote}   JS info   10:00:31.38 shinytest2; shiny:value distPlot
#&gt; {chromote}   JS info   10:00:31.57 shinytest2; Shiny has been idle for 200ms
#&gt; {shinytest2} R  info   10:00:31.57 Shiny app started
#&gt; {shiny}      R  stderr ----------- Loading required package: shiny
#&gt; {shiny}      R  stderr ----------- Running application in test mode.
#&gt; {shiny}      R  stderr -----------
#&gt; {shiny}      R  stderr ----------- Listening on http://127.0.0.1:4679


# To capture all websocket traffic, set `options = list(shiny.trace = TRUE)`
app2 &lt;- AppDriver$new(
  system.file("examples/01_hello", package = "shiny"),
  options = list(shiny.trace = TRUE)
)

app2$get_logs()
## (All WebSocket messages have been replaced with `WEBSOCKET_MSG` in example below)
#&gt; {shinytest2} R  info      10:01:57.49 Start AppDriver initialization
#&gt; {shinytest2} R  info      10:01:57.50 Starting Shiny app
#&gt; {shinytest2} R  info      10:01:58.20 Creating new ChromoteSession
#&gt; {shinytest2} R  info      10:01:58.35 Navigating to Shiny app
#&gt; {shinytest2} R  info      10:01:58.47 Injecting shiny-tracer.js
#&gt; {chromote}   JS info      10:01:58.49 shinytest2; jQuery not found
#&gt; {chromote}   JS info      10:01:58.49 shinytest2; Loaded
#&gt; {shinytest2} R  info      10:01:58.50 Waiting for Shiny to become ready
#&gt; {chromote}   JS info      10:01:58.55 shinytest2; jQuery found
#&gt; {chromote}   JS info      10:01:58.55 shinytest2; Waiting for shiny session to connect
#&gt; {chromote}   JS websocket 10:01:58.64 send WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.67 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.67 shinytest2; Connected
#&gt; {chromote}   JS websocket 10:01:58.71 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.72 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.72 shinytest2; shiny:busy
#&gt; {chromote}   JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {shinytest2} R  info      10:01:58.75 Waiting for Shiny to become idle for 200ms within 15000ms
#&gt; {chromote}   JS info      10:01:58.75 shinytest2; Waiting for Shiny to be stable
#&gt; {chromote}   JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.81 shinytest2; shiny:idle
#&gt; {chromote}   JS websocket 10:01:58.82 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.82 shinytest2; shiny:value distPlot
#&gt; {chromote}   JS info      10:01:59.01 shinytest2; Shiny has been idle for 200ms
#&gt; {shinytest2} R  info      10:01:59.01 Shiny app started
#&gt; {shiny}      R  stderr    ----------- Loading required package: shiny
#&gt; {shiny}      R  stderr    ----------- Running application in test mode.
#&gt; {shiny}      R  stderr    -----------
#&gt; {shiny}      R  stderr    ----------- Listening on http://127.0.0.1:4560
#&gt; {shiny}      R  stderr    ----------- SEND {"config":{"workerId":"","sessionId"|truncated
#&gt; {shiny}      R  stderr    ----------- RECV {"method":"init","data":{"bins":30,|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"custom":{"showcase-src":{"srcref":|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"busy":"busy"}
#&gt; {shiny}      R  stderr    ----------- SEND {"custom":{"showcase-src":{"srcref":|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"recalculating":{"name":"distPlot",|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"recalculating":{"name":"distPlot",|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"busy":"idle"}
#&gt; {shiny}      R  stderr    ----------- SEND {"errors":{},"values":{"distPlot":|truncated

# The log that is returned is a `data.frame()`.
log &lt;- app2$get_logs()
tibble::glimpse(log)
#&gt; Rows: 43
#&gt; Columns: 5
#&gt; $ workerid  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …
#&gt; $ timestamp &lt;dttm&gt; 2022-09-19 10:01:57, 2022-09-19 10:01:57, 2022-09-19 10:01:58, 2022…
#&gt; $ location  &lt;chr&gt; "shinytest2", "shinytest2", "shinytest2", "shinytest2", "shinytest2"…
#&gt; $ level     &lt;chr&gt; "info", "info", "info", "info", "info", "info", "info", "info", "inf…
#&gt; $ message   &lt;chr&gt; "Start AppDriver initialization", "Starting Shiny app", "Creating ne…
#&gt; $ workerid  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …
#&gt; $ timestamp &lt;dttm&gt; 2022-03-16 11:09:57, 2022-03-16 11:09:57, 2022-03-16 11:09:…
#&gt; $ location  &lt;chr&gt; "shinytest2", "shinytest2", "shinytest2", "shinytest2", "shi…
#&gt; $ level     &lt;chr&gt; "info", "info", "info", "info", "info", "info", "info", "inf…
#&gt; $ message   &lt;chr&gt; "Start AppDriver initialization", "Starting Shiny app", "Cre…

# It may be filtered to find desired logs
subset(log, level == "websocket")
## (All WebSocket messages have been replaced with `WEBSOCKET_MSG` in example below)
#&gt; {chromote} JS websocket 10:01:58.64 send WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.67 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.71 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.72 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.82 recv WEBSOCKET_MSG
}
</pre>
</div>


<hr>
<a id="method-AppDriver-log_message"></a>



<h4>Method <code>log_message()</code></h4>

<p>Add a message to the <span class="pkg">shinytest2</span> log.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$log_message(message)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>message</code></dt><dd><p>Single message to store in log</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

app$log_message("Setting bins to smaller value")
app$set_inputs(bins = 10)
app$get_logs()
}
</pre>
</div>


<hr>
<a id="method-AppDriver-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop the Shiny application driver
</p>
<p>This method stops all known processes:
</p>

<ul>
<li><p> The Shiny application in the background R process,
</p>
</li>
<li><p> the background R process hosting the Shiny application, and
</p>
</li>
<li><p> the Chromote Session instance.
</p>
</li></ul>

<p>To stop your shiny application and return a value from <code style="white-space: pre;">&#8288;$stop()&#8288;</code>, see
<code><a href="shiny.html#topic+stopApp">shiny::stopApp()</a></code>. This is useful in testing to return context
information.
</p>
<p>Typically, this can be paired with a button that when clicked will call
<code>shiny::stopApp(info)</code> to return <code>info</code> from the test app back to the
main R session.
</p>


<h5>Usage</h5>

<div class="r"><pre>AppDriver$stop(signal_timeout = missing_arg())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>signal_timeout</code></dt><dd><p>Milliseconds to wait between sending a <code>SIGINT</code>,
<code>SIGTERM</code>, and <code>SIGKILL</code> to the Shiny process. Defaults to 500ms and does
not utilize the resolved value from <code>AppDriver$new(timeout=)</code>. However,
if <span class="pkg">covr</span> is currently executing, then the <code>timeout</code> is set to
20,000ms to allow for the coverage report to be generated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The result of the background process if the Shiny application has
already been terminated.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
rlang::check_installed("reactlog")

library(shiny)
shiny_app &lt;- shinyApp(
  ui = fluidPage(
    actionButton("button", "Stop app and return Reactlog"),
    "Click count:", textOutput("count")
  ),
  server = function(input, output) {
    output$count &lt;- renderText({ input$button })
    observe({
      req(input$button)
      stopApp(shiny::reactlog())
    })
  }
)

app &lt;- AppDriver$new(
  shiny_app,
  # Enable reactlog in background R session
  options = list(shiny.reactlog = TRUE)
)

app$click("button")
rlog &lt;- app$stop()
str(head(rlog, 2))
#&gt; List of 2
#&gt; $ :List of 7
#&gt; ..$ action : chr "define"
#&gt; ..$ reactId: chr "r3"
#&gt; ..$ label  : chr "Theme Counter"
#&gt; ..$ type   : chr "reactiveVal"
#&gt; ..$ value  : chr " num 0"
#&gt; ..$ session: chr "bdc7417f2fc8c84fc05c9518e36fdc44"
#&gt; ..$ time   : num 1.65e+09
#&gt; $ :List of 7
#&gt; ..$ action : chr "define"
#&gt; ..$ reactId: chr "r4"
#&gt; ..$ label  : chr "output$count"
#&gt; .. ..- attr(*, "srcref")= int [1:6] 7 32 7 45 32 45
#&gt; .. ..- attr(*, "srcfile")= chr ""
#&gt; ..$ type   : chr "observer"
#&gt; ..$ value  : chr " NULL"
#&gt; ..$ session: chr "bdc7417f2fc8c84fc05c9518e36fdc44"
#&gt; ..$ time   : num 1.65e+09
}
</pre>
</div>




<h3>See Also</h3>

<p><code><a href="#topic+platform_variant">platform_variant()</a></code>, <code><a href="#topic+use_shinytest2_test">use_shinytest2_test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `AppDriver$new`
## ------------------------------------------------

## Not run: 
# Create an AppDriver from the Shiny app in the current directory
app &lt;- AppDriver()

# Create an AppDriver object from a different Shiny app directory
example_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver(example_app)

# Expect consistent inital values
app$expect_values()

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$view`
## ------------------------------------------------

## Not run: 
# Open app in Chrome
app$view()

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$click`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

tmpfile &lt;- write.csv(cars, "cars.csv")
app$upload_file(file1 = tmpfile)
cat(app$get_text("#view"))
app$set_inputs(dataset = "cars", obs = 6)
app$click("update")
cat(app$get_text("#view"))

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$set_inputs`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

cat(app$get_text("#view"))
app$set_inputs(dataset = "cars", obs = 6)
app$click("update")
cat(app$get_text("#view"))

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$upload_file`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/09_upload", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save example file
tmpfile &lt;- tempfile(fileext = ".csv")
write.csv(cars, tmpfile, row.names = FALSE)

# Upload file to input named: file1
app$upload_file(file1 = tmpfile)

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_values`
## ------------------------------------------------

## Not run: 
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Pythagorean theorem"),
    numericInput("A", "A", 3),
    numericInput("B", "B", 4),
    verbatimTextOutput("C"),
  ),
  function(input, output) {
    a_squared &lt;- reactive({ req(input$A); input$A * input$A })
    b_squared &lt;- reactive({ req(input$B); input$B * input$B })
    c_squared &lt;- reactive({ a_squared() + b_squared() })
    c_value &lt;- reactive({ sqrt(c_squared()) })
    output$C &lt;- renderText({ c_value() })

    exportTestValues(
      a_squared = { a_squared() },
      b_squared = { b_squared() },
      c_squared = { c_squared() }
    )
  }
)

app &lt;- AppDriver$new(shiny_app)

# Snapshot all known values
app$expect_values()

# Snapshot only `export` values
app$expect_values(export = TRUE)

# Snapshot values `"A"` from `input` and `"C"` from `output`
app$expect_values(input = "A", output = "C")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_value`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/04_mpg", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Retrieve a single value
app$get_value(output = "caption")
#&gt; [1] "mpg ~ cyl"
# Equivalent code using `$get_values()`
app$get_values(output = "caption")$output$caption
#&gt; [1] "mpg ~ cyl"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_values`
## ------------------------------------------------

## Not run: 
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Pythagorean theorem"),
    numericInput("A", "A", 3),
    numericInput("B", "B", 4),
    verbatimTextOutput("C"),
  ),
  function(input, output) {
    a_squared &lt;- reactive({ req(input$A); input$A * input$A })
    b_squared &lt;- reactive({ req(input$B); input$B * input$B })
    c_squared &lt;- reactive({ a_squared() + b_squared() })
    c_value &lt;- reactive({ sqrt(c_squared()) })
    output$C &lt;- renderText({ c_value() })

    exportTestValues(
      a_squared = { a_squared() },
      b_squared = { b_squared() },
      c_squared = { c_squared() }
    )
  }
)

app &lt;- AppDriver$new(shiny_app)

# Show all known values
str(app$get_values())
#&gt; List of 3
#&gt; $ input :List of 2
#&gt; ..$ A: int 3
#&gt; ..$ B: int 4
#&gt; $ output:List of 1
#&gt; ..$ C: chr "5"
#&gt; $ export:List of 3
#&gt; ..$ a_squared: int 9
#&gt; ..$ b_squared: int 16
#&gt; ..$ c_squared: int 25

# Get only `export` values
str(app$get_values(export = TRUE))
#&gt; List of 1
#&gt; $ export:List of 3
#&gt; ..$ a_squared: int 9
#&gt; ..$ b_squared: int 16
#&gt; ..$ c_squared: int 25

# Get values `"A"` from `input` and `"C"` from `output`
str(app$get_values(input = "A", output = "C"))
#&gt; List of 2
#&gt; $ input :List of 1
#&gt; ..$ A: int 3
#&gt; $ output:List of 1
#&gt; ..$ C: chr "5"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_download`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/10_download", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save snapshot of rock.csv as 001.download
# Save snapshot value of `rock.csv` to capture default file name
app$expect_download("downloadData", compare = testthat::compare_file_text)

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_download`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/10_download", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Get rock.csv as a tempfile
app$get_download("downloadData")
#&gt; [1] "/TEMP/PATH/rock.csv"

# Get rock.csv as a "./myfile.csv"
app$get_download("downloadData", filename = "./myfile.csv")
#&gt; [1] "./myfile.csv"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_text`
## ------------------------------------------------

## Not run: 
hello_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(hello_app)

# Make a snapshot of `"Hello Shiny!"`
app$expect_text("h2")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_text`
## ------------------------------------------------

## Not run: 
hello_app &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(hello_app)

app$get_text("h2")
#&gt; [1] "Hello Shiny!"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_html`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/04_mpg", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Save a snapshot of the `caption` output
app$expect_html("#caption")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_html`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/03_reactivity", package = "shiny")
app &lt;- AppDriver$new(app_path, check_names = FALSE)

app$set_inputs(caption = "Custom value!")
cat(app$get_html(".shiny-input-container")[1])
#&gt; &lt;div class="form-group shiny-input-container"&gt;
#&gt;   &lt;label class="control-label" id="caption-label" for="caption"&gt;Caption:&lt;/label&gt;
#&gt;   &lt;input id="caption" type="text" class="form-control shiny-bound-input" value="Data Summary"&gt;
#&gt; &lt;/div&gt;
## ^^ No update to the DOM of `caption`

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_js`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/07_widgets", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Track how many clicks are given to `#update` button
app$run_js("
  window.test_counter = 0;
  $('#update').click(() =&gt; window.test_counter++);
")
app$set_inputs(obs = 20)
# Click the update button, incrementing the counter
app$click("update")
# Save a snapshot of number of clicks (1)
app$expect_js("window.test_counter;")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_js`
## ------------------------------------------------

## Not run: 
library(shiny)
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Execute JavaScript code in the app's browser
app$get_js("1 + 1;")
#&gt; [1] 2

# Execute a JavaScript Promise. Return the resolved value.
app$get_js("
  new Promise((resolve) =&gt; {
    setTimeout(() =&gt; resolve(1 + 1), 1000)
  }).
  then((value) =&gt; value + 1);
")
#&gt; [1] 3

# With escaped arguments
loc_field &lt;- "hostname"
js_txt &lt;- paste0("window.location[", jsonlite::toJSON(loc_field, auto_unbox = TRUE), "]")
app$get_js(js_txt)
#&gt; [1] "127.0.0.1"

# With `glue::glue()`
js_txt &lt;- glue::glue_data(
  lapply(
    list(x = 40, y = 2),
    jsonlite::toJSON,
    auto_unbox = TRUE
  ),
  .open = "&lt;", .close = "&gt;",
  "let answer = function(a, b) {\n",
  "  return a + b;\n",
  "};\n",
  "answer(&lt;x&gt;, &lt;y&gt;);\n"
)
app$get_js(js_txt)
#&gt; [1] 42

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$run_js`
## ------------------------------------------------

## Not run: 
library(shiny)
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Get JavaScript answer from the app's browser
app$get_js("1 + 1")
#&gt; [1] 2
# Execute JavaScript code in the app's browser
app$run_js("1 + 1")
# (Returns `app` invisibly)

# With escaped arguments
loc_field &lt;- "hostname"
js_txt &lt;- paste0("window.location[", jsonlite::toJSON(loc_field, auto_unbox = TRUE), "]")
app$run_js(js_txt)
app$get_js(js_txt)
#&gt; [1] "127.0.0.1"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_screenshot`
## ------------------------------------------------

## Not run: 
# These example lines should be performed in a `./tests/testthat`
# test file so that snapshot files can be properly saved

app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path, variant = platform_variant())

# Expect a full size screenshot to be pixel perfect
app$expect_screenshot()

# Images are brittle when containing plots
app$expect_screenshot(selector = "#distPlot")

# Test with more threshold in pixel value differences
# Helps with rounded corners
app$expect_screenshot(threshold = 10)

# Equivalent expectations
app$expect_screenshot() # default
app$expect_screenshot(threshold = NULL)
app$expect_screenshot(compare = testthat::compare_file_binary)
expect_snapshot_file(
  app$get_screenshot(),
  variant = app$get_variant(),
  compare = testthat::compare_file_binary
)

# Equivalent expectations
app$expect_screenshot(threshold = 3, kernel_size = 5)
app$expect_screenshot(compare = function(old, new) {
  compare_screenshot_threshold(
    old, new,
    threshold = 3,
    kernel_size = 5
  )
})
expect_screenshot_file(
  app$get_screenshot(),
  variant = app$get_variant(),
  compare = function(old, new) {
    compare_screenshot_threshold(
      old, new,
      threshold = 3,
      kernel_size = 5
    )
  }
)

# Take a screenshot of the entire scrollable area
app$expect_screenshot()
app$expect_screenshot(selector = "scrollable_area")

## Take a screenshot of the current viewport
# Shrink the window to be smaller than the app
app$set_window_size(400, 500)
# Scroll the viewport just a bit
app$run_js("window.scroll(30, 70)")
# Take screenshot of browser viewport
app$expect_screenshot(selector = "viewport")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_screenshot`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

# Display in graphics device
app$get_screenshot()

# Update bins then display `"disPlot"` in graphics device
app$set_inputs(bins = 10)
app$get_screenshot(selector = "#distPlot")

# Save screenshot to file and view it
tmpfile &lt;- tempfile(fileext = ".png")
app$get_screenshot(tmpfile)
showimage::show_image(tmpfile)

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$wait_for_idle`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

pre_value &lt;- app$get_value(output = "distPlot")
# Update bins value
app$set_inputs(bins = 10, wait_ = FALSE)
middle_value &lt;- app$get_value(output = "distPlot")
app$wait_for_idle()
post_value &lt;- app$get_value(output = "distPlot")

# No guarantee that these values are different
identical(pre_value, middle_value)
# Will not be equal
identical(pre_value, post_value)

# ---------------------
## Change the screen size to trigger a plot update
pre_value &lt;- app$get_value(output = "distPlot")
app$set_window_size(height = 1080, width = 1920, wait = FALSE)
middle_value &lt;- app$get_value(output = "distPlot")
app$wait_for_idle()
post_value &lt;- app$get_value(output = "distPlot")

# No guarantee that these values are different
identical(pre_value, middle_value)
# Will not be equal
identical(pre_value, post_value)

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$wait_for_value`
## ------------------------------------------------

## Not run: 
library(shiny)
shiny_app &lt;- shinyApp(
  fluidPage(
    h1("Dynamic output"),
    actionButton("display", "Display UI"),
    uiOutput("dym1"),
  ),
  function(input, output) {
    output$dym1 &lt;- renderUI({
      req(input$display)
      Sys.sleep(runif(1, max = 2)) # Artificial calculations
      tagList(
        sliderInput("slider1", "Slider #1", 0, 100, 25),
        uiOutput("dym2")
      )
    })
    output$dym2 &lt;- renderUI({
      Sys.sleep(runif(1, max = 2)) # Artificial calculations
      tagList(
        sliderInput("slider2", "Slider #2", 0, 100, 50),
        "Total:", verbatimTextOutput("total")
      )
    })
    output$total &lt;- renderText({
      req(input$slider1, input$slider2)
      input$slider1 + input$slider2
    })
  }
)

app &lt;- AppDriver$new(shiny_app)

# Create UI / output values
app$click("display")
# Wait for total to be calculated (or have a non-NULL value)
new_total_value &lt;- app$wait_for_value(output = "total")
#&gt; [1] "75"
app$get_value(output = "total")
#&gt; [1] "75"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$wait_for_js`
## ------------------------------------------------

## Not run: 
shiny_app &lt;- shinyApp(h1("Empty App"), function(input, output) { })
app &lt;- AppDriver$new(shiny_app)

# Contrived example:
# Wait until `Date.now()` returns a number that ends in a 5. (0 - 10 seconds)
system.time(
  app$wait_for_js("Math.floor((Date.now() / 1000) % 10) == 5;")
)

## A second example where we run the contents of a JavaScript file
## and use the result to wait for a condition
app$run_js(file = "complicated_file.js")
app$wait_for_js("complicated_condition();")

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$expect_unique_names`
## ------------------------------------------------

## Not run: 
shiny_app &lt;- shinyApp(
  ui = fluidPage(
    # Duplicate input IDs: `"text"`
    textInput("text", "Text 1"),
    textInput("text", "Text 2")
  ),
  server = function(input, output) {
    # empty
  }
)
# Initial checking for unique names (default behavior)
app &lt;- AppDriver$new(shiny_app, check_names = TRUE)
#&gt; Warning:
#&gt; ! Shiny inputs should have unique HTML id values.
#&gt; i The following HTML id values are not unique:
#&gt; • text
app$stop()

# Manually assert that all names are unique
app &lt;- AppDriver$new(shiny_app, check_names = FALSE)
app$expect_unique_names()
#&gt; Error: `app_check_unique_names(self, private)` threw an unexpected warning.
#&gt; Message: ! Shiny inputs should have unique HTML id values.
#&gt; i The following HTML id values are not unique:
#&gt;   • text
#&gt; Class:   rlang_warning/warning/condition
app$stop()

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_dir`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

identical(app$get_dir(), app_path)
#&gt; [1] TRUE

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_url`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

browseURL(app$get_url())

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_window_size`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

app$get_window_size()
#&gt; $width
#&gt; [1] 992
#&gt;
#&gt; $height
#&gt; [1] 1323

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$set_window_size`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
# Set init window size
app &lt;- AppDriver$new(app_path, height = 1400, width = 1000)

app$get_window_size()
#&gt; $width
#&gt; [1] 1000
#&gt;
#&gt; $height
#&gt; [1] 1400

# Manually set the window size
app$set_window_size(height = 1080, width = 1920)
app$get_window_size()
#&gt; $width
#&gt; [1] 1920
#&gt;
#&gt; $height
#&gt; [1] 1080

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_chromote_session`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

b &lt;- app$get_chromote_session()
b$Runtime$evaluate("1 + 1")
#&gt; $result
#&gt; $result$type
#&gt; [1] "number"
#&gt;
#&gt; $result$value
#&gt; [1] 2
#&gt;
#&gt; $result$description
#&gt; [1] "2"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_variant`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")

app &lt;- AppDriver$new(app_path)

app$get_variant()
#&gt; NULL

app &lt;- AppDriver$new(app_path, variant = platform_variant())
app$get_variant()
#&gt; [1] "mac-4.1"

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$get_logs`
## ------------------------------------------------

## Not run: 
app1 &lt;- AppDriver$new(system.file("examples/01_hello", package = "shiny"))

app1$get_logs()
#&gt; {shinytest2} R  info   10:00:28.86 Start AppDriver initialization
#&gt; {shinytest2} R  info   10:00:28.86 Starting Shiny app
#&gt; {shinytest2} R  info   10:00:29.76 Creating new ChromoteSession
#&gt; {shinytest2} R  info   10:00:30.56 Navigating to Shiny app
#&gt; {shinytest2} R  info   10:00:30.70 Injecting shiny-tracer.js
#&gt; {chromote}   JS info   10:00:30.75 shinytest2; jQuery found
#&gt; {chromote}   JS info   10:00:30.77 shinytest2; Waiting for shiny session to connect
#&gt; {chromote}   JS info   10:00:30.77 shinytest2; Loaded
#&gt; {shinytest2} R  info   10:00:30.77 Waiting for Shiny to become ready
#&gt; {chromote}   JS info   10:00:30.90 shinytest2; Connected
#&gt; {chromote}   JS info   10:00:30.95 shinytest2; shiny:busy
#&gt; {shinytest2} R  info   10:00:30.98 Waiting for Shiny to become idle for 200ms within 15000ms
#&gt; {chromote}   JS info   10:00:30.98 shinytest2; Waiting for Shiny to be stable
#&gt; {chromote}   JS info   10:00:31.37 shinytest2; shiny:idle
#&gt; {chromote}   JS info   10:00:31.38 shinytest2; shiny:value distPlot
#&gt; {chromote}   JS info   10:00:31.57 shinytest2; Shiny has been idle for 200ms
#&gt; {shinytest2} R  info   10:00:31.57 Shiny app started
#&gt; {shiny}      R  stderr ----------- Loading required package: shiny
#&gt; {shiny}      R  stderr ----------- Running application in test mode.
#&gt; {shiny}      R  stderr -----------
#&gt; {shiny}      R  stderr ----------- Listening on http://127.0.0.1:4679


# To capture all websocket traffic, set `options = list(shiny.trace = TRUE)`
app2 &lt;- AppDriver$new(
  system.file("examples/01_hello", package = "shiny"),
  options = list(shiny.trace = TRUE)
)

app2$get_logs()
## (All WebSocket messages have been replaced with `WEBSOCKET_MSG` in example below)
#&gt; {shinytest2} R  info      10:01:57.49 Start AppDriver initialization
#&gt; {shinytest2} R  info      10:01:57.50 Starting Shiny app
#&gt; {shinytest2} R  info      10:01:58.20 Creating new ChromoteSession
#&gt; {shinytest2} R  info      10:01:58.35 Navigating to Shiny app
#&gt; {shinytest2} R  info      10:01:58.47 Injecting shiny-tracer.js
#&gt; {chromote}   JS info      10:01:58.49 shinytest2; jQuery not found
#&gt; {chromote}   JS info      10:01:58.49 shinytest2; Loaded
#&gt; {shinytest2} R  info      10:01:58.50 Waiting for Shiny to become ready
#&gt; {chromote}   JS info      10:01:58.55 shinytest2; jQuery found
#&gt; {chromote}   JS info      10:01:58.55 shinytest2; Waiting for shiny session to connect
#&gt; {chromote}   JS websocket 10:01:58.64 send WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.67 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.67 shinytest2; Connected
#&gt; {chromote}   JS websocket 10:01:58.71 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.72 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.72 shinytest2; shiny:busy
#&gt; {chromote}   JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {shinytest2} R  info      10:01:58.75 Waiting for Shiny to become idle for 200ms within 15000ms
#&gt; {chromote}   JS info      10:01:58.75 shinytest2; Waiting for Shiny to be stable
#&gt; {chromote}   JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote}   JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.81 shinytest2; shiny:idle
#&gt; {chromote}   JS websocket 10:01:58.82 recv WEBSOCKET_MSG
#&gt; {chromote}   JS info      10:01:58.82 shinytest2; shiny:value distPlot
#&gt; {chromote}   JS info      10:01:59.01 shinytest2; Shiny has been idle for 200ms
#&gt; {shinytest2} R  info      10:01:59.01 Shiny app started
#&gt; {shiny}      R  stderr    ----------- Loading required package: shiny
#&gt; {shiny}      R  stderr    ----------- Running application in test mode.
#&gt; {shiny}      R  stderr    -----------
#&gt; {shiny}      R  stderr    ----------- Listening on http://127.0.0.1:4560
#&gt; {shiny}      R  stderr    ----------- SEND {"config":{"workerId":"","sessionId"|truncated
#&gt; {shiny}      R  stderr    ----------- RECV {"method":"init","data":{"bins":30,|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"custom":{"showcase-src":{"srcref":|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"busy":"busy"}
#&gt; {shiny}      R  stderr    ----------- SEND {"custom":{"showcase-src":{"srcref":|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"recalculating":{"name":"distPlot",|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"recalculating":{"name":"distPlot",|truncated
#&gt; {shiny}      R  stderr    ----------- SEND {"busy":"idle"}
#&gt; {shiny}      R  stderr    ----------- SEND {"errors":{},"values":{"distPlot":|truncated

# The log that is returned is a `data.frame()`.
log &lt;- app2$get_logs()
tibble::glimpse(log)
#&gt; Rows: 43
#&gt; Columns: 5
#&gt; $ workerid  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …
#&gt; $ timestamp &lt;dttm&gt; 2022-09-19 10:01:57, 2022-09-19 10:01:57, 2022-09-19 10:01:58, 2022…
#&gt; $ location  &lt;chr&gt; "shinytest2", "shinytest2", "shinytest2", "shinytest2", "shinytest2"…
#&gt; $ level     &lt;chr&gt; "info", "info", "info", "info", "info", "info", "info", "info", "inf…
#&gt; $ message   &lt;chr&gt; "Start AppDriver initialization", "Starting Shiny app", "Creating ne…
#&gt; $ workerid  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …
#&gt; $ timestamp &lt;dttm&gt; 2022-03-16 11:09:57, 2022-03-16 11:09:57, 2022-03-16 11:09:…
#&gt; $ location  &lt;chr&gt; "shinytest2", "shinytest2", "shinytest2", "shinytest2", "shi…
#&gt; $ level     &lt;chr&gt; "info", "info", "info", "info", "info", "info", "info", "inf…
#&gt; $ message   &lt;chr&gt; "Start AppDriver initialization", "Starting Shiny app", "Cre…

# It may be filtered to find desired logs
subset(log, level == "websocket")
## (All WebSocket messages have been replaced with `WEBSOCKET_MSG` in example below)
#&gt; {chromote} JS websocket 10:01:58.64 send WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.67 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.71 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.72 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.73 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.81 recv WEBSOCKET_MSG
#&gt; {chromote} JS websocket 10:01:58.82 recv WEBSOCKET_MSG

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$log_message`
## ------------------------------------------------

## Not run: 
app_path &lt;- system.file("examples/01_hello", package = "shiny")
app &lt;- AppDriver$new(app_path)

app$log_message("Setting bins to smaller value")
app$set_inputs(bins = 10)
app$get_logs()

## End(Not run)

## ------------------------------------------------
## Method `AppDriver$stop`
## ------------------------------------------------

## Not run: 
rlang::check_installed("reactlog")

library(shiny)
shiny_app &lt;- shinyApp(
  ui = fluidPage(
    actionButton("button", "Stop app and return Reactlog"),
    "Click count:", textOutput("count")
  ),
  server = function(input, output) {
    output$count &lt;- renderText({ input$button })
    observe({
      req(input$button)
      stopApp(shiny::reactlog())
    })
  }
)

app &lt;- AppDriver$new(
  shiny_app,
  # Enable reactlog in background R session
  options = list(shiny.reactlog = TRUE)
)

app$click("button")
rlog &lt;- app$stop()
str(head(rlog, 2))
#&gt; List of 2
#&gt; $ :List of 7
#&gt; ..$ action : chr "define"
#&gt; ..$ reactId: chr "r3"
#&gt; ..$ label  : chr "Theme Counter"
#&gt; ..$ type   : chr "reactiveVal"
#&gt; ..$ value  : chr " num 0"
#&gt; ..$ session: chr "bdc7417f2fc8c84fc05c9518e36fdc44"
#&gt; ..$ time   : num 1.65e+09
#&gt; $ :List of 7
#&gt; ..$ action : chr "define"
#&gt; ..$ reactId: chr "r4"
#&gt; ..$ label  : chr "output$count"
#&gt; .. ..- attr(*, "srcref")= int [1:6] 7 32 7 45 32 45
#&gt; .. ..- attr(*, "srcfile")= chr ""
#&gt; ..$ type   : chr "observer"
#&gt; ..$ value  : chr " NULL"
#&gt; ..$ session: chr "bdc7417f2fc8c84fc05c9518e36fdc44"
#&gt; ..$ time   : num 1.65e+09

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_screenshot_threshold'>Compare screenshots given threshold value</h2><span id='topic+compare_screenshot_threshold'></span><span id='topic+screenshot_max_difference'></span>

<h3>Description</h3>

<p><span class="pkg">chromote</span> can sometimes produce screenshot images with non-deterministic
(yet close) color values. This can happen in locations such as rounded
corners of <code>div</code>s or <code>textarea</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_screenshot_threshold(
  old,
  new,
  ...,
  threshold = NULL,
  kernel_size = 5,
  quiet = FALSE
)

screenshot_max_difference(old, new = missing_arg(), ..., kernel_size = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_screenshot_threshold_+3A_old">old</code></td>
<td>
<p>Current screenshot file path</p>
</td></tr>
<tr><td><code id="compare_screenshot_threshold_+3A_new">new</code></td>
<td>
<p>New screenshot file path</p>
</td></tr>
<tr><td><code id="compare_screenshot_threshold_+3A_...">...</code></td>
<td>
<p>Must be empty. Allows for parameter expansion.</p>
</td></tr>
<tr><td><code id="compare_screenshot_threshold_+3A_threshold">threshold</code></td>
<td>
<p>If the value of <code>threshold</code> is <code>NULL</code>,
<code>compare_screenshot_threshold()</code> will act like
<code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary</a></code>. However, if <code>threshold</code> is a positive
number, it will be compared against the largest convolution value found if
the two images fail a <code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary</a></code> comparison. The max
value that can be found is <code>4 * kernel_size ^ 2</code>.
</p>
<p>Threshold values values below 5 help deter
false-positive screenshot comparisons (such as inconsistent rounded
corners). Larger values in the 10s and 100s will help find <em>real</em>
changes. However, not all values are one size fits all and you will need
to play with a threshold that fits your needs.
</p>
<p>To find the current difference between two images, use
<code>screenshot_max_difference()</code>.</p>
</td></tr>
<tr><td><code id="compare_screenshot_threshold_+3A_kernel_size">kernel_size</code></td>
<td>
<p>The <code>kernel_size</code> represents the height and width of the
convolution kernel applied to the matrix of pixel differences. This
integer-like value should be relatively small, such as 5.</p>
</td></tr>
<tr><td><code id="compare_screenshot_threshold_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code> and the value is larger than <code>threshold</code>, then a
message is printed to the console. This is helpful when getting a failing
image and being informed about how different the <code>new</code> image is from the
<code>old</code> image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These differences make comparing screenshots impractical using traditional
expectation methods as false-positives are produced often over time. To
mitigate this, we can use a <em>fuzzy matching</em> algorithm that can tolerate
small regional differences throughout the image. If the local changes found
are larger than the <code>threshold</code>, then the images are determined to be
different. Both the screenshot difference <code>threshold</code> and the size of the
kernel (<code>kernel_size</code>) can be set to tune the false positive rate.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>compare_screenshot_threshold()</code>: Compares two images and allows for a <code>threshold</code> difference of <em>so many</em>
units in each RGBA color channel.
</p>
<p>It is suggested to use this method with
<code><a href="#topic+AppDriver">AppDriver</a></code><code style="white-space: pre;">&#8288;$expect_screenshot(threshold=, kernel_size=)&#8288;</code> to make
expectations on screenshots given particular <code>threshold</code> and <code>kernel_size</code>
values.
</p>
</li>
<li> <p><code>screenshot_max_difference()</code>: Finds the difference between two screenshots.
</p>
<p>This value can be used in <code>compare_screenshot_threshold(threshold=)</code>. It is
recommended that the value used for <code>compare_screenshot_threshold(threshold=)</code>
is larger than the immediate max difference found. This allows for random
fluctuations when rounding sub pixels.
</p>
<p>If <code>new</code> is missing, it will use the file value of <code>old</code> (<code>FILE.png</code>) and
default to <code>FILE.new.png</code>
</p>
</li></ul>


<h3>Algorithm for the difference between two screenshots</h3>


<ol>
<li><p> First the two images are compared using
<code><a href="testthat.html#topic+expect_snapshot_file">testthat::compare_file_binary()</a></code>. If the files are identical, return
<code>TRUE</code> that the screenshot images are the same.
</p>
</li>
<li><p> If <code>threshold</code> is <code>NULL</code>, return <code>FALSE</code> as the convolution will not
occur.
</p>
</li>
<li><p> Prepare the screenshot difference matrix by reading the RGBA channels of
each image and find their respective absolute differences
</p>
</li>
<li><p> Sum the screenshot difference matrix channels at each pixel location
</p>
</li>
<li><p> Perform a convolution using a small square kernel matrix that is
<code>kernel_size</code> big and filled with <code>1</code>s.
</p>
</li>
<li><p> Find the largest value in the resulting convolution matrix.
</p>
</li>
<li><p> If this max convolution value is larger than <code>threshold</code>, return <code>FALSE</code>,
images are different.
</p>
</li>
<li><p> Otherwise, return <code>TRUE</code>, images are the same.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>img_folder &lt;- system.file("example/imgs/", package = "shinytest2")
slider_old &lt;- fs::path(img_folder, "slider-old.png")
slider_new &lt;- fs::path(img_folder, "slider-new.png")

# Can you see the differences between these two images?
showimage::show_image(slider_old)
showimage::show_image(slider_new)

# You might have caught the difference between the two images!
slider_diff &lt;- fs::path(img_folder, "slider-diff.png")
showimage::show_image(slider_diff)

# Let's find the difference between the two images
screenshot_max_difference(slider_old, slider_new)
# ~ 28

# Using different threshold values...
compare_screenshot_threshold(slider_old, slider_new, threshold = NULL)
#&gt; FALSE # Images are not identical
compare_screenshot_threshold(slider_old, slider_new, threshold = 25)
#&gt; FALSE # Images are more different than 25 units
compare_screenshot_threshold(slider_old, slider_new, threshold = 30)
#&gt; TRUE # Images are not as different as 30 units

#########################

# Now let's look at two fairly similar images
bookmark_old &lt;- fs::path(img_folder, "bookmark-old.png")
bookmark_new &lt;- fs::path(img_folder, "bookmark-new.png")

# Can you see the difference between these two images?
# (Hint: Focused corners)
showimage::show_image(bookmark_old)
showimage::show_image(bookmark_new)

# Can you find the red pixels showing the differences?
# Hint: Look in the corners of the focused text
bookmark_diff &lt;- fs::path(img_folder, "bookmark-diff.png")
showimage::show_image(bookmark_diff)

# Let's find the difference between the two images
screenshot_max_difference(bookmark_old, bookmark_new)
# ~ 0.25

# Using different threshold values...
compare_screenshot_threshold(bookmark_old, bookmark_new, threshold = NULL)
#&gt; FALSE # Images are not identical
compare_screenshot_threshold(bookmark_old, bookmark_new, threshold = 5)
#&gt; TRUE # Images are not as different than 5 units
</code></pre>

<hr>
<h2 id='load_app_env'>Load the Shiny application's support environment</h2><span id='topic+load_app_env'></span>

<h3>Description</h3>

<p>Executes all <code>./R</code> files and <code>global.R</code> into the current environment.
This is useful when wanting access to functions or values created in the <code>./R</code> folder for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_app_env(
  app_dir = "../../",
  renv = rlang::caller_env(),
  globalrenv = rlang::caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_app_env_+3A_app_dir">app_dir</code></td>
<td>
<p>The base directory for the Shiny application.</p>
</td></tr>
<tr><td><code id="load_app_env_+3A_renv">renv</code></td>
<td>
<p>The environment in which the files in the 'R/&ldquo; directory should be evaluated.</p>
</td></tr>
<tr><td><code id="load_app_env_+3A_globalrenv">globalrenv</code></td>
<td>
<p>The environment in which <code>global.R</code> should be evaluated. If
<code>NULL</code>, <code>global.R</code> will not be evaluated at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loading these files is not automatically performed by <code>test_app()</code> and must
be called in <code>./tests/testthat/setup-shinytest2.R</code> if access to support file objects is
desired.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_shinytest2">use_shinytest2()</a></code> for creating a testing setup file that
loads your Shiny app support environment into the testing environment.
</p>

<hr>
<h2 id='migrate_from_shinytest'>Migrate <span class="pkg">shinytest</span> tests</h2><span id='topic+migrate_from_shinytest'></span>

<h3>Description</h3>

<p>This function will migrate standard shinytest test files to the new <span class="pkg">shinytest2</span> + <span class="pkg">testthat</span> ed 3 snapshot format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>migrate_from_shinytest(
  app_dir,
  ...,
  clean = TRUE,
  include_expect_screenshot = missing_arg(),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="migrate_from_shinytest_+3A_app_dir">app_dir</code></td>
<td>
<p>Directory containing the Shiny application or Shiny Rmd file</p>
</td></tr>
<tr><td><code id="migrate_from_shinytest_+3A_...">...</code></td>
<td>
<p>Must be empty. Allows for parameter expansion.</p>
</td></tr>
<tr><td><code id="migrate_from_shinytest_+3A_clean">clean</code></td>
<td>
<p>If TRUE, then the shinytest test directory and runner will be deleted after the migration to use <span class="pkg">shinytest2</span>.</p>
</td></tr>
<tr><td><code id="migrate_from_shinytest_+3A_include_expect_screenshot">include_expect_screenshot</code></td>
<td>
<p>If <code>TRUE</code>, <code>ShinyDriver$snapshot()</code> will turn into both <code>AppDriver$expect_values()</code> and <code>AppDriver$expect_screenshot()</code>. If <code>FALSE</code>, <code>ShinyDriver$snapshot()</code> will only turn into <code>AppDriver$expect_values()</code>. If missing, <code>include_expect_screenshot</code> will behave as <code>FALSE</code> if <code>shinytest::testApp(compareImages = FALSE)</code> or <code>ShinyDriver$snapshotInit(screenshot = FALSE)</code> is called.</p>
</td></tr>
<tr><td><code id="migrate_from_shinytest_+3A_quiet">quiet</code></td>
<td>
<p>Logical that determines if migration information and steps should be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">shinytest</span> file contents will be traversed and converted to the new <span class="pkg">shinytest2</span> format. If the <span class="pkg">shinytest</span> code can not be directly seen in the code, then it will not be converted.
</p>


<h3>Value</h3>

<p>Invisible <code>TRUE</code>
</p>

<hr>
<h2 id='platform_variant'>Platform specific variant</h2><span id='topic+platform_variant'></span>

<h3>Description</h3>

<p>Returns a string to be used within <span class="pkg">testthat</span>'s' snapshot testing. Currently, the Operating System
and R Version (major, minor, no patch version) are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>platform_variant(..., os_name = TRUE, r_version = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="platform_variant_+3A_...">...</code></td>
<td>
<p>Must be empty. Allows for parameter expansion.</p>
</td></tr>
<tr><td><code id="platform_variant_+3A_os_name">os_name</code></td>
<td>
<p>if <code>TRUE</code>, include the OS name in the output</p>
</td></tr>
<tr><td><code id="platform_variant_+3A_r_version">r_version</code></td>
<td>
<p>if <code>TRUE</code>, include the major and minor version of the R version, no patch version</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more information is needed in the future to distinguish standard testing environments, this function
will be updated accordingly.
</p>


<h3>See Also</h3>

<p><code><a href="testthat.html#topic+test_dir">testthat::test_dir()</a></code>
</p>

<hr>
<h2 id='record_test'>Launch test event recorder for a Shiny app</h2><span id='topic+record_test'></span>

<h3>Description</h3>

<p>Once a recording is completed, it will create or append a new
<span class="pkg">shinytest2</span> test to the <span class="pkg">testthat</span> <code>test_file</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_test(
  app = ".",
  ...,
  name = NULL,
  seed = NULL,
  load_timeout = NULL,
  shiny_args = list(),
  test_file = "test-shinytest2.R",
  open_test_file = rlang::is_interactive(),
  allow_no_input_binding = NULL,
  record_screen_size = TRUE,
  run_test = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_test_+3A_app">app</code></td>
<td>
<p>A <code><a href="#topic+AppDriver">AppDriver</a></code> object, or path to a Shiny
application.</p>
</td></tr>
<tr><td><code id="record_test_+3A_...">...</code></td>
<td>
<p>Must be empty. Allows for parameter expansion.</p>
</td></tr>
<tr><td><code id="record_test_+3A_name">name</code></td>
<td>
<p>Name provided to <code><a href="#topic+AppDriver">AppDriver</a></code>. This value should be unique between all tests within a test file. If it is not unique, different expect methods may overwrite each other.</p>
</td></tr>
<tr><td><code id="record_test_+3A_seed">seed</code></td>
<td>
<p>A random seed to set before running the app. This seed will also
be used in the test script.</p>
</td></tr>
<tr><td><code id="record_test_+3A_load_timeout">load_timeout</code></td>
<td>
<p>Maximum time to wait for the Shiny application to load, in
milliseconds. If a value is provided, it will be saved in the test script.</p>
</td></tr>
<tr><td><code id="record_test_+3A_shiny_args">shiny_args</code></td>
<td>
<p>A list of options to pass to <code>runApp()</code>. If a value
is provided, it will be saved in the test script.</p>
</td></tr>
<tr><td><code id="record_test_+3A_test_file">test_file</code></td>
<td>
<p>Base file name of the <span class="pkg">testthat</span> test file.</p>
</td></tr>
<tr><td><code id="record_test_+3A_open_test_file">open_test_file</code></td>
<td>
<p>If <code>TRUE</code>, the test file will be opened in an editor
via <code><a href="utils.html#topic+file.edit">file.edit()</a></code> before executing.</p>
</td></tr>
<tr><td><code id="record_test_+3A_allow_no_input_binding">allow_no_input_binding</code></td>
<td>
<p>This value controls if events without input
bindings are recorded.
</p>

<ul>
<li><p> If <code>TRUE</code>, events without input bindings are recorded.
</p>
</li>
<li><p> If <code>FALSE</code>, events without input bindings are not recorded.
</p>
</li>
<li><p> If <code>NULL</code> (default), if an updated input does not have a corresponding
</p>
</li>
<li><p> input, a modal dialog will be shown asking if unbound input events should
</p>
</li>
<li><p> be recorded.
</p>
</li></ul>

<p>See <code><a href="#topic+AppDriver">AppDriver</a></code><code style="white-space: pre;">&#8288;$set_inputs()&#8288;</code> for more information.</p>
</td></tr>
<tr><td><code id="record_test_+3A_record_screen_size">record_screen_size</code></td>
<td>
<p>If <code>TRUE</code>, the screen size will be recorded when initialized and changed.</p>
</td></tr>
<tr><td><code id="record_test_+3A_run_test">run_test</code></td>
<td>
<p>If <code>TRUE</code>, <code>test_file</code> will be executed after saving the recording.</p>
</td></tr>
</table>


<h3>Uploading files</h3>

<p>Files that are uploaded to your Shiny app must be located somewhere within
the <code>tests/testthat</code> subdirectory or available via <code>system.file()</code>.
</p>
<p>Files that are uploaded during recording that do not have a valid path will
have a warning inserted into the code. Please fix the file path by moving the
file to the <code>tests/testthat</code> subdirectory or by using <code>system.file()</code>. After
fixing the path, remove the line of warning code.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_app">test_app()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
record_test("path/to/app")

## End(Not run)
</code></pre>

<hr>
<h2 id='register_input_processor'>Register an input processor for the test recorder</h2><span id='topic+register_input_processor'></span><span id='topic+get_input_processors'></span>

<h3>Description</h3>

<p><code>register_input_processor()</code> registers an input processor which will be used by
the test recorder. The input processor function should take one parameter,
<code>value</code>, and return a string of R code which returns the desired value.
</p>
<p><code>get_input_processors()</code> returns a named list of all registered input processor
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_input_processor(input_type, processor)

get_input_processors()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_input_processor_+3A_input_type">input_type</code></td>
<td>
<p>The name of an input type, for example,
<code>"mypkg.numberinput"</code>.</p>
</td></tr>
<tr><td><code id="register_input_processor_+3A_processor">processor</code></td>
<td>
<p>An input processor function.</p>
</td></tr>
</table>

<hr>
<h2 id='test_app'>Test Shiny applications with <span class="pkg">testthat</span></h2><span id='topic+test_app'></span>

<h3>Description</h3>

<p>This is a helper method that wraps around <code><a href="testthat.html#topic+test_dir">testthat::test_dir()</a></code> to test
your Shiny application or Shiny runtime document.  This is similar to how
<code><a href="testthat.html#topic+test_package">testthat::test_check()</a></code> tests your R package but for your app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_app(
  app_dir = missing_arg(),
  ...,
  name = missing_arg(),
  check_setup = TRUE,
  reporter = testthat::get_reporter(),
  stop_on_failure = missing_arg()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_app_+3A_app_dir">app_dir</code></td>
<td>
<p>The base directory for the Shiny application.
</p>

<ul>
<li><p> If <code>app_dir</code> is missing and <code>test_app()</code> is called within the
<code>./tests/testthat.R</code> file, the parent directory (<code>"../"</code>) is used.
</p>
</li>
<li><p> Otherwise, the default path of <code>"."</code> is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="test_app_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="testthat.html#topic+test_dir">testthat::test_dir()</a></code></p>
</td></tr>
<tr><td><code id="test_app_+3A_name">name</code></td>
<td>
<p>Name to display in the middle of the test name. This value is only used
when calling <code>test_app()</code> inside of <span class="pkg">testhat</span> test. The final testing context will
have the format of <code>"{test_context} - {name} - {app_test_context}"</code>.</p>
</td></tr>
<tr><td><code id="test_app_+3A_check_setup">check_setup</code></td>
<td>
<p>If <code>TRUE</code>, the app will be checked for the presence of
<code>./tests/testthat/setup-shinytest2.R</code>. This file must contain a call to
<code><a href="#topic+load_app_env">load_app_env()</a></code>.</p>
</td></tr>
<tr><td><code id="test_app_+3A_reporter">reporter</code></td>
<td>
<p>Reporter to pass through to <code><a href="testthat.html#topic+test_dir">testthat::test_dir()</a></code>.</p>
</td></tr>
<tr><td><code id="test_app_+3A_stop_on_failure">stop_on_failure</code></td>
<td>
<p>If missing, the default value of <code>TRUE</code> will be used. However, if missing and currently testing, <code>FALSE</code> will be used to seamlessly integrate the app reporter to <code>reporter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example usage:
</p>
<div class="sourceCode r"><pre>## Interactive usage
# Test Shiny app in current working directory
shinytest2::test_app()

# Test Shiny app in another directory
path_to_app &lt;- "path/to/app"
shinytest2::test_app(path_to_app)

## File: ./tests/testthat.R
# Will find Shiny app in "../"
shinytest2::test_app()

## File: ./tests/testthat/test-shinytest2.R
# Test a shiny application within your own {testthat} code
test_that("Testing a Shiny app in a package", {
  shinytest2::test_app(path_to_app)
})
</pre></div>


<h3>Uploading files</h3>

<p>When testing an application, all non-temp files that are uploaded should be
located in the <code>./tests/testthat</code> directory. This allows for tests to be more
portable and self contained.
</p>
<p>When recording a test with <code><a href="#topic+record_test">record_test()</a></code>, for every uploaded file that is
located outside of <code>./tests/testthat</code>, a warning will be thrown. Once the
file path has be fixed, you may remove the warning statement.
</p>


<h3>Different ways to test</h3>

<p><code>test_app()</code> is an opinionated testing function that will only execute
<span class="pkg">testthat</span> tests in the <code>./tests/testthat</code> folder. If (for some rare
reason) you have other non-<span class="pkg">testthat</span> tests to execute, you can call
<code><a href="shiny.html#topic+runTests">shiny::runTests()</a></code>. This method will generically run all test runners and
their associated tests.
</p>
<div class="sourceCode r"><pre># Execute a single Shiny app's {testthat} file such as `./tests/testthat/test-shinytest2.R`
test_app(filter = "shinytest2")

# Execute all {testthat} tests
test_app()

# Execute all tests for all test runners
shiny::runTests()
</pre></div>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+record_test">record_test()</a></code> to create tests to record against your Shiny application.
</p>
</li>
<li> <p><code><a href="testthat.html#topic+snapshot_accept">testthat::snapshot_review()</a></code> and <code><a href="testthat.html#topic+snapshot_accept">testthat::snapshot_accept()</a></code> if
you want to compare or update snapshots after testing.
</p>
</li>
<li> <p><code><a href="#topic+load_app_env">load_app_env()</a></code> to load the Shiny application's helper files.
This is only necessary if you want access to the values while testing.
</p>
</li></ul>


<hr>
<h2 id='use_shinytest2'>Use <span class="pkg">shinytest2</span> with your Shiny application</h2><span id='topic+use_shinytest2'></span><span id='topic+use_shinytest2_test'></span>

<h3>Description</h3>

<p>Use <span class="pkg">shinytest2</span> with your Shiny application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_shinytest2(
  app_dir = ".",
  runner = missing_arg(),
  setup = missing_arg(),
  ignore = missing_arg(),
  package = missing_arg(),
  ...,
  quiet = FALSE,
  overwrite = FALSE
)

use_shinytest2_test(
  app_dir = ".",
  open = rlang::is_interactive(),
  quiet = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_shinytest2_+3A_app_dir">app_dir</code></td>
<td>
<p>The base directory for the Shiny application</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_runner">runner</code></td>
<td>
<p>If <code>TRUE</code>, creates a <span class="pkg">shinytest2</span> test runner at <code>./tests/testthat.R</code></p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_setup">setup</code></td>
<td>
<p>If <code>TRUE</code>, creates a setup file called
<code>./tests/testthat/setup-shinytest2.R</code> containing a call to <code><a href="#topic+load_app_env">load_app_env()</a></code></p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_ignore">ignore</code></td>
<td>
<p>If <code>TRUE</code>, adds entries to <code>.Rbuildignore</code> and <code>.gitignore</code> to
ignore new debug screenshots. (<code style="white-space: pre;">&#8288;*_.new.png&#8288;</code>)</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_package">package</code></td>
<td>
<p>If <code>TRUE</code>, adds <span class="pkg">shinytest2</span> to <code>Suggests</code> in the <code>DESCRIPTION</code> file.</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_...">...</code></td>
<td>
<p>Must be empty. Allows for parameter expansion.</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, console output will be suppressed.</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, the test file or test runner will be overwritten.</p>
</td></tr>
<tr><td><code id="use_shinytest2_+3A_open">open</code></td>
<td>
<p>If <code>TRUE</code>, the test file will be opened in an editor via
<code><a href="utils.html#topic+file.edit">file.edit()</a></code> after saving.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>use_shinytest2()</code>: This <span class="pkg">usethis</span>-style method initializes many different useful features when using
<span class="pkg">shinytest2</span>:
</p>

<ul>
<li> <p><code>runner</code>: Creates a <span class="pkg">shinytest2</span> test runner at <code>./tests/testthat.R</code>. This file
will contain a call to <code><a href="#topic+test_app">test_app()</a></code>.
</p>
</li>
<li> <p><code>setup</code>: Creates <code>./tests/testthat/setup-shinytest2.R</code> to add your Shiny <code>./R</code> objects and functions into the testing environment. This file will run before testing begins.
</p>
</li>
<li> <p><code>ignore</code>: Add an entry to <code>./Rbuildignore</code> (if it exists) and <code>.gitignore</code> to ignore new debug screenshots. (<code style="white-space: pre;">&#8288;*_.new.png&#8288;</code>)
</p>
</li>
<li> <p><code>package</code>: Adds <code>shinytest</code> to the <code>Suggests</code> packages in the <code>DESCRIPTION</code> file (if it exists).
</p>
</li></ul>

<p>If any of these values are <em>not</em> missing, the remaining missing values will be set to <code>FALSE</code>. This allows <code>use_shinytest2()</code> to add more flags in future versions without opting into all changes inadvertently.
</p>
</li>
<li> <p><code>use_shinytest2_test()</code>: Creates a test file called <code>./tests/testthat/test-shinytest2.R</code>. By
default, this file's template test will initialize your Shiny application and
expect the initial values.
</p>
<p>This method will also set up a test runner if it does not exist.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Set up shinytest2 testing configs
## Not run: use_shinytest2()
# Set up a shinytest2 test
## Not run: use_shinytest2_test()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
