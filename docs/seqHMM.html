<!DOCTYPE html><html><head><title>Help for package seqHMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqHMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biofam3c'><p>Three-channel biofam data</p></a></li>
<li><a href='#build_hmm'><p>Build a Hidden Markov Model</p></a></li>
<li><a href='#build_lcm'><p>Build a Latent Class Model</p></a></li>
<li><a href='#build_mhmm'><p>Build a Mixture Hidden Markov Model</p></a></li>
<li><a href='#build_mm'><p>Build a Markov Model</p></a></li>
<li><a href='#build_mmm'><p>Build a Mixture Markov Model</p></a></li>
<li><a href='#cluster_names'><p>Get cluster names from mhmm object</p></a></li>
<li><a href='#cluster_names&lt;-'><p>Set cluster names for mhmm object</p></a></li>
<li><a href='#colorpalette'><p>Color palettes</p></a></li>
<li><a href='#estimate_coef'><p>Estimate Regression Coefficients of Mixture Hidden Markov Models</p></a></li>
<li><a href='#fit_model'><p>Estimate Parameters of (Mixture) Hidden Markov Models and Their Restricted</p>
Variants</a></li>
<li><a href='#forward_backward'><p>Forward and Backward Probabilities for Hidden Markov Model</p></a></li>
<li><a href='#gridplot'><p>Plot Multidimensional Sequence Plots in a Grid</p></a></li>
<li><a href='#hidden_paths'><p>Most Probable Paths of Hidden States</p></a></li>
<li><a href='#hmm_biofam'><p>Hidden Markov model for the biofam data</p></a></li>
<li><a href='#hmm_mvad'><p>Hidden Markov model for the mvad data</p></a></li>
<li><a href='#logLik.hmm'><p>Log-likelihood of the Hidden Markov Model</p></a></li>
<li><a href='#logLik.mhmm'><p>Log-likelihood of the Mixture Hidden Markov Model</p></a></li>
<li><a href='#mc_to_sc'><p>Transform a Multichannel Hidden Markov Model into a Single Channel Representation</p></a></li>
<li><a href='#mc_to_sc_data'><p>Merge Multiple Sequence Objects into One (from Multichannel to Single Channel Data)</p></a></li>
<li><a href='#mhmm_biofam'><p>Mixture hidden Markov model for the biofam data</p></a></li>
<li><a href='#mhmm_mvad'><p>Mixture hidden Markov model for the mvad data</p></a></li>
<li><a href='#mssplot'><p>Interactive Stacked Plots of Multichannel Sequences and/or Most Probable</p>
Paths for Mixture Hidden Markov Models</a></li>
<li><a href='#plot_colors'><p>Plot Colorpalettes</p></a></li>
<li><a href='#plot.hmm'><p>Plot hidden Markov models</p></a></li>
<li><a href='#plot.mhmm'><p>Interactive Plotting for Mixed Hidden Markov Model (mhmm)</p></a></li>
<li><a href='#plot.ssp'><p>Stack Multichannel Sequence Plots and/or Most Probable Paths Plots from Hidden Markov</p>
Models</a></li>
<li><a href='#posterior_probs'><p>Posterior Probabilities for (Mixture) Hidden Markov Models</p></a></li>
<li><a href='#print.hmm'><p>Print Method for a Hidden Markov Model</p></a></li>
<li><a href='#separate_mhmm'><p>Reorganize a mixture hidden Markov model to a list of separate hidden Markov models</p>
(covariates ignored)</a></li>
<li><a href='#seqdef'><p>Imported Functions from <code>TraMineR</code></p></a></li>
<li><a href='#seqHMM'><p>The seqHMM package</p></a></li>
<li><a href='#seqHMM-deprecated'><p>Deprecated function(s) in the seqHMM package</p></a></li>
<li><a href='#simulate_hmm'><p>Simulate hidden Markov models</p></a></li>
<li><a href='#simulate_initial_probs'><p>Simulate Parameters of Hidden Markov Models</p></a></li>
<li><a href='#simulate_mhmm'><p>Simulate Mixture Hidden Markov Models</p></a></li>
<li><a href='#ssp'><p>Define Arguments for Plotting Multichannel Sequences and/or Most Probable</p>
Paths from Hidden Markov Models</a></li>
<li><a href='#ssplot'><p>Stacked Plots of Multichannel Sequences and/or Most Probable</p>
Paths from Hidden Markov Models</a></li>
<li><a href='#state_names'><p>Get state names from hmm or mhmm object</p></a></li>
<li><a href='#state_names&lt;-'><p>Set state names for hmm or mhmm object</p></a></li>
<li><a href='#summary.mhmm'><p>Summary method for mixture hidden Markov models</p></a></li>
<li><a href='#trim_model'><p>Trim Small Probabilities of Hidden Markov Model</p></a></li>
<li><a href='#vcov.mhmm'><p>Variance-Covariance Matrix for Coefficients of Covariates of Mixture Hidden Markov Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mixture Hidden Markov Models for Social Sequence Data and Other
Multivariate, Multichannel Categorical Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-7</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for fitting hidden (latent) Markov models and mixture
    hidden Markov models for social sequence data and other categorical time series.
    Also some more restricted versions of these type of models are available: Markov
    models, mixture Markov models, and latent class models. The package supports
    models for one or multiple subjects with one or multiple parallel sequences
    (channels). External covariates can be added to explain cluster membership in
    mixture models. The package provides functions for evaluating and comparing
    models, as well as functions for visualizing of multichannel sequence data and
    hidden Markov models. Models are estimated using maximum likelihood via the EM
    algorithm and/or direct numerical maximization with analytical gradients. All
    main algorithms are written in C++ with support for parallel computation. 
    Documentation is available via several vignettes in this page, and the  
    paper by Helske and Helske (2019, &lt;<a href="https://doi.org/10.18637%2Fjss.v088.i03">doi:10.18637/jss.v088.i03</a>&gt;).</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gridBase, igraph, Matrix, nloptr, numDeriv, Rcpp (&ge; 0.11.3),
TraMineR (&ge; 1.8-8), graphics, grDevices, grid, methods, stats,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, nnet, knitr, testthat (&ge; 3.0.0), covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/helske/seqHMM/issues">https://github.com/helske/seqHMM/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-05 10:58:56 UTC; jovetale</td>
</tr>
<tr>
<td>Author:</td>
<td>Jouni Helske <a href="https://orcid.org/0000-0001-7130-793X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Satu Helske <a href="https://orcid.org/0000-0003-0532-0153"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jouni Helske &lt;jouni.helske@iki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-06 00:10:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='biofam3c'>Three-channel biofam data</h2><span id='topic+biofam3c'></span>

<h3>Description</h3>

<p>Biofam data from the TraMineR package converted into three channels.
</p>


<h3>Format</h3>

<p>A list including three sequence data sets for 2000 individuals with
16 state variables, and a separate data frame with 1 id variable,
8 covariates, and 2 weight variables.
</p>


<h3>Details</h3>

<p>This data is constructed from the <code><a href="TraMineR.html#topic+biofam">biofam</a></code>
data in the TraMineR package. Here the original state sequences are
converted into three separate data sets: <code>children</code>, <code>married</code>,
and <code>left</code>. These include the corresponding life states from age 15 to
30: <code>childless</code> or (having) <code>children</code>; <code>single</code>,
<code>married</code>, or <code>divorced</code>; and (living) <code>with parents</code> or
<code>left home</code>.
</p>
<p>Note that the <code>divorced</code> state does not give information on parenthood
or residence, so a guess is made based on preceeding states.
</p>
<p>The fourth data frame <code>covariates</code> is a collection of
additional variables from the original data:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>idhous </code></td><td style="text-align: left;"> id</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>sex </code></td><td style="text-align: left;"> sex</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>birthyr </code></td><td style="text-align: left;"> birth year</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>nat_1_02 </code></td><td style="text-align: left;"> first nationality</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>plingu02 </code></td><td style="text-align: left;"> language of questionnaire</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>p02r01 </code></td><td style="text-align: left;"> religion</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>p02r04 </code></td><td style="text-align: left;"> religious participation</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>cspfaj </code></td><td style="text-align: left;"> father's social status</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>cspmoj </code></td><td style="text-align: left;"> mother's social status</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>wp00tbgp </code></td><td style="text-align: left;"> weights inflating to the Swiss population</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>wp00tbgs </code></td><td style="text-align: left;"> weights respecting sample size
 </td>
</tr>

</table>

<p>The data is loaded by calling <code>data(biofam3c)</code>. It was built using
following code:
</p>
<pre>
data("biofam" , package = "TraMineR")
biofam3c &lt;- with(biofam, {

## Building one channel per type of event left, children or married
bf &lt;- as.matrix(biofam[, 10:25])
children &lt;- bf == 4 | bf == 5 | bf == 6
married &lt;- bf == 2 | bf == 3 | bf == 6
left &lt;- bf == 1 | bf == 3 | bf == 5 | bf == 6 | bf == 7

children[children == TRUE] &lt;- "children"
children[children == FALSE] &lt;- "childless"
# Divorced parents
div &lt;- bf[(rowSums(bf == 7) &gt; 0 &amp; rowSums(bf == 5) &gt; 0) |
            (rowSums(bf == 7) &gt; 0 &amp; rowSums(bf == 6) &gt; 0),]
children[rownames(bf) %in% rownames(div) &amp; bf == 7] &lt;- "children"

married[married == TRUE] &lt;- "married"
married[married == FALSE] &lt;- "single"
married[bf == 7] &lt;- "divorced"

left[left == TRUE] &lt;- "left home"
left[left == FALSE] &lt;- "with parents"
# Divorced living with parents (before divorce)
wp &lt;- bf[(rowSums(bf == 7) &gt; 0 &amp; rowSums(bf == 2) &gt; 0 &amp;
          rowSums(bf == 3) == 0 &amp; rowSums(bf == 5) == 0 &amp;
          rowSums(bf == 6) == 0) |
         (rowSums(bf == 7) &gt; 0 &amp; rowSums(bf == 4) &gt; 0 &amp;
          rowSums(bf == 3) == 0 &amp; rowSums(bf == 5) == 0 &amp;
          rowSums(bf == 6) == 0), ]
left[rownames(bf) %in% rownames(wp) &amp; bf == 7] &lt;- "with parents"

list("children" = children, "married" = married, "left" = left,
  "covariates" = biofam[, c(1:9, 26:27)])
})
</pre>


<h3>Source</h3>

<p><code><a href="TraMineR.html#topic+biofam">biofam</a></code> data constructed from the Swiss
Household Panel
<a href="https://forscenter.ch/projects/swiss-household-panel/">https://forscenter.ch/projects/swiss-household-panel/</a>
</p>


<h3>References</h3>

<p>Müller, N. S., M. Studer, G. Ritschard (2007). Classification de
parcours de vie à l'aide de l'optimal matching. In <em>XIVe Rencontre de l
a Société francophone de classification (SFC 2007), Paris, 5 - 7 septembre
2007</em>, pp. 157–160.
</p>

<hr>
<h2 id='build_hmm'>Build a Hidden Markov Model</h2><span id='topic+build_hmm'></span>

<h3>Description</h3>

<p>Function <code>build_hmm</code> constructs a hidden Markov model object of class <code>hmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_hmm(
  observations,
  n_states,
  transition_probs,
  emission_probs,
  initial_probs,
  state_names = NULL,
  channel_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_hmm_+3A_observations">observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) containing
the sequences, or a list of such objects (one for each channel).</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_n_states">n_states</code></td>
<td>
<p>A scalar giving the number of hidden states. Not used if starting values for model parameters
are given with <code>initial_probs</code>, <code>transition_probs</code>, or <code>emission_probs</code>.</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_transition_probs">transition_probs</code></td>
<td>
<p>A matrix of transition probabilities.</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_emission_probs">emission_probs</code></td>
<td>
<p>A matrix of emission probabilities or a list of such
objects (one for each channel). Emission probabilities should follow the
ordering of the alphabet of observations (<code>alphabet(observations)</code>, returned as <code>symbol_names</code>).</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_initial_probs">initial_probs</code></td>
<td>
<p>A vector of initial state probabilities.</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_state_names">state_names</code></td>
<td>
<p>A list of optional labels for the hidden states. If <code>NULL</code>,
the state names are taken from the row names of the transition matrix. If this is
also <code>NULL</code>, numbered states are used.</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_channel_names">channel_names</code></td>
<td>
<p>A vector of optional names for the channels.</p>
</td></tr>
<tr><td><code id="build_hmm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>simulate_transition_probs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned model contains some attributes such as <code>nobs</code> and <code>df</code>,
which define the number of observations in the  model and the number of estimable
model parameters, used in computing BIC.
When computing <code>nobs</code> for a multichannel model with <code class="reqn">C</code> channels,
each observed value in a single channel amounts to <code class="reqn">1/C</code> observation,
i.e. a fully observed time point for a single sequence amounts to one observation.
For the degrees of freedom <code>df</code>, zero probabilities of the initial model are
defined as structural zeroes.
</p>


<h3>Value</h3>

<p>Object of class <code>hmm</code> with the following elements:
</p>

<dl>
<dt><code>observations</code></dt><dd><p>State sequence object or a list of such objects containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt><dd><p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt><dd><p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt><dd><p>A vector of initial probabilities.</p>
</dd>
<dt><code>state_names</code></dt><dd><p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt><dd><p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt><dd><p>Names for channels of sequence data.</p>
</dd>
<dt><code>length_of_sequences</code></dt><dd><p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt><dd><p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt><dd><p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt><dd><p>Number of channels.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code> for estimating model parameters; and
<code><a href="#topic+plot.hmm">plot.hmm</a></code> for plotting <code>hmm</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Single-channel data

data("mvad", package = "TraMineR")

mvad_alphabet &lt;- c(
  "employment", "FE", "HE", "joblessness", "school",
  "training"
)
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet, states = mvad_scodes,
  labels = mvad_labels, xtstep = 6
)

# Initializing an HMM with 4 hidden states, random starting values
init_hmm_mvad1 &lt;- build_hmm(observations = mvad_seq, n_states = 4)

# Starting values for the emission matrix
emiss &lt;- matrix(NA, nrow = 4, ncol = 6)
emiss[1, ] &lt;- seqstatf(mvad_seq[, 1:12])[, 2] + 1
emiss[2, ] &lt;- seqstatf(mvad_seq[, 13:24])[, 2] + 1
emiss[3, ] &lt;- seqstatf(mvad_seq[, 25:48])[, 2] + 1
emiss[4, ] &lt;- seqstatf(mvad_seq[, 49:70])[, 2] + 1
emiss &lt;- emiss / rowSums(emiss)

# Starting values for the transition matrix

tr &lt;- matrix(
  c(
    0.80, 0.10, 0.05, 0.05,
    0.05, 0.80, 0.10, 0.05,
    0.05, 0.05, 0.80, 0.10,
    0.05, 0.05, 0.10, 0.80
  ),
  nrow = 4, ncol = 4, byrow = TRUE
)

# Starting values for initial state probabilities
init &lt;- c(0.3, 0.3, 0.2, 0.2)

# HMM with own starting values
init_hmm_mvad2 &lt;- build_hmm(
  observations = mvad_seq, transition_probs = tr,
  emission_probs = emiss, initial_probs = init
)

#########################################


# Multichannel data

# Three-state three-channel hidden Markov model
# See ?hmm_biofam for a five-state version

data("biofam3c")

# Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

# Define colors
attr(marr_seq, "cpal") &lt;- c("violetred2", "darkgoldenrod2", "darkmagenta")
attr(child_seq, "cpal") &lt;- c("darkseagreen1", "coral3")
attr(left_seq, "cpal") &lt;- c("lightblue", "red3")

# Left-to-right HMM with 3 hidden states and random starting values
set.seed(1010)
init_hmm_bf1 &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  n_states = 3, left_right = TRUE, diag_c = 2
)


# Starting values for emission matrices

emiss_marr &lt;- matrix(NA, nrow = 3, ncol = 3)
emiss_marr[1, ] &lt;- seqstatf(marr_seq[, 1:5])[, 2] + 1
emiss_marr[2, ] &lt;- seqstatf(marr_seq[, 6:10])[, 2] + 1
emiss_marr[3, ] &lt;- seqstatf(marr_seq[, 11:16])[, 2] + 1
emiss_marr &lt;- emiss_marr / rowSums(emiss_marr)

emiss_child &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_child[1, ] &lt;- seqstatf(child_seq[, 1:5])[, 2] + 1
emiss_child[2, ] &lt;- seqstatf(child_seq[, 6:10])[, 2] + 1
emiss_child[3, ] &lt;- seqstatf(child_seq[, 11:16])[, 2] + 1
emiss_child &lt;- emiss_child / rowSums(emiss_child)

emiss_left &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_left[1, ] &lt;- seqstatf(left_seq[, 1:5])[, 2] + 1
emiss_left[2, ] &lt;- seqstatf(left_seq[, 6:10])[, 2] + 1
emiss_left[3, ] &lt;- seqstatf(left_seq[, 11:16])[, 2] + 1
emiss_left &lt;- emiss_left / rowSums(emiss_left)

# Starting values for transition matrix
trans &lt;- matrix(
  c(
    0.9, 0.07, 0.03,
    0, 0.9, 0.1,
    0, 0, 1
  ),
  nrow = 3, ncol = 3, byrow = TRUE
)

# Starting values for initial state probabilities
inits &lt;- c(0.9, 0.09, 0.01)

# HMM with own starting values
init_hmm_bf2 &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  transition_probs = trans,
  emission_probs = list(emiss_marr, emiss_child, emiss_left),
  initial_probs = inits
)

</code></pre>

<hr>
<h2 id='build_lcm'>Build a Latent Class Model</h2><span id='topic+build_lcm'></span>

<h3>Description</h3>

<p>Function <code>build_lcm</code> is a shortcut for constructing a latent class model
as a restricted case of an <code>mhmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_lcm(
  observations,
  n_clusters,
  emission_probs,
  formula = NULL,
  data = NULL,
  coefficients = NULL,
  cluster_names = NULL,
  channel_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_lcm_+3A_observations">observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) containing
the sequences, or a list of such objects (one for each channel).</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_n_clusters">n_clusters</code></td>
<td>
<p>A scalar giving the number of clusters/submodels
(not used if starting values for model parameters are given with <code>emission_probs</code>).</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_emission_probs">emission_probs</code></td>
<td>
<p>A matrix containing emission probabilities for each class by rows,
or in case of multichannel data a list of such matrices.
Note that the matrices must have dimensions k x s where k is the number of
latent classes and s is the number of unique symbols (observed states) in the
data. Emission probabilities should follow the ordering of the alphabet of
observations (<code>alphabet(observations)</code>, returned as <code>symbol_names</code>).</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_formula">formula</code></td>
<td>
<p>Optional formula of class <code><a href="stats.html#topic+formula">formula</a></code> for the
mixture probabilities. Left side omitted.</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables used in the formula.
Ignored if no formula is provided.</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_coefficients">coefficients</code></td>
<td>
<p>An optional <code class="reqn">k x l</code> matrix of regression coefficients for
time-constant covariates for mixture probabilities, where <code class="reqn">l</code> is the number
of clusters and <code class="reqn">k</code> is the number of covariates. A logit-link is used for
mixture probabilities. The first column is set to zero.</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_cluster_names">cluster_names</code></td>
<td>
<p>A vector of optional names for the classes/clusters.</p>
</td></tr>
<tr><td><code id="build_lcm_+3A_channel_names">channel_names</code></td>
<td>
<p>A vector of optional names for the channels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mhmm</code> with the following elements:
</p>

<dl>
<dt><code>observations</code></dt><dd><p>State sequence object or a list of such containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt><dd><p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt><dd><p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt><dd><p>A vector of initial probabilities.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>A matrix of parameter coefficients for covariates (covariates in rows, clusters in columns).</p>
</dd>
<dt><code>X</code></dt><dd><p>Covariate values for each subject.</p>
</dd>
<dt><code>cluster_names</code></dt><dd><p>Names for clusters.</p>
</dd>
<dt><code>state_names</code></dt><dd><p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt><dd><p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt><dd><p>Names for channels of sequence data</p>
</dd>
<dt><code>length_of_sequences</code></dt><dd><p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt><dd><p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt><dd><p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt><dd><p>Number of channels.</p>
</dd>
<dt><code>n_covariates</code></dt><dd><p>Number of covariates.</p>
</dd>
<dt><code>n_clusters</code></dt><dd><p>Number of clusters.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code> for estimating model parameters;
<code><a href="#topic+summary.mhmm">summary.mhmm</a></code> for a summary of a mixture model;
<code><a href="#topic+separate_mhmm">separate_mhmm</a></code> for organizing an <code>mhmm</code> object into a list of
separate <code>hmm</code> objects; and <code><a href="#topic+plot.mhmm">plot.mhmm</a></code> for plotting
mixture models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate observations from two classes
set.seed(123)
obs &lt;- seqdef(rbind(
  matrix(sample(letters[1:3], 500, TRUE, prob = c(0.1, 0.6, 0.3)), 50, 10),
  matrix(sample(letters[1:3], 200, TRUE, prob = c(0.4, 0.4, 0.2)), 20, 10)
))

# Initialize the model
set.seed(9087)
model &lt;- build_lcm(obs, n_clusters = 2)

# Estimate model parameters
fit &lt;- fit_model(model)

# How many of the observations were correctly classified:
sum(summary(fit$model)$most_probable_cluster == rep(c("Class 2", "Class 1"), times = c(500, 200)))

############################################################
## Not run: 
# LCM for longitudinal data

# Define sequence data
data("mvad", package = "TraMineR")
mvad_alphabet &lt;- c(
  "employment", "FE", "HE", "joblessness", "school",
  "training"
)
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet, states = mvad_scodes,
  labels = mvad_labels, xtstep = 6
)

# Initialize the LCM with random starting values
set.seed(7654)
init_lcm_mvad1 &lt;- build_lcm(
  observations = mvad_seq,
  n_clusters = 2, formula = ~male, data = mvad
)

# Own starting values for emission probabilities
emiss &lt;- rbind(rep(1 / 6, 6), rep(1 / 6, 6))

# LCM with own starting values
init_lcm_mvad2 &lt;- build_lcm(
  observations = mvad_seq,
  emission_probs = emiss, formula = ~male, data = mvad
)

# Estimate model parameters (EM algorithm with random restarts)
lcm_mvad &lt;- fit_model(init_lcm_mvad1,
  control_em = list(restart = list(times = 5))
)$model

# Plot the LCM
plot(lcm_mvad, interactive = FALSE, ncol = 2)

###################################################################

# Binomial regression (comparison to glm)

require("MASS")
data("birthwt")

model &lt;- build_lcm(
  observations = seqdef(birthwt$low), emission_probs = diag(2),
  formula = ~ age + lwt + smoke + ht, data = birthwt
)
fit &lt;- fit_model(model)
summary(fit$model)
summary(glm(low ~ age + lwt + smoke + ht, binomial, data = birthwt))


# Multinomial regression (comparison to multinom)

require("nnet")

set.seed(123)
n &lt;- 100
X &lt;- cbind(1, x1 = runif(n, 0, 1), x2 = runif(n, 0, 1))
coefs &lt;- cbind(0, c(-2, 5, -2), c(0, -2, 2))
pr &lt;- exp(X %*% coefs) + rnorm(n * 3)
pr &lt;- pr / rowSums(pr)
y &lt;- apply(pr, 1, which.max)
table(y)

model &lt;- build_lcm(
  observations = seqdef(y), emission_probs = diag(3),
  formula = ~ x1 + x2, data = data.frame(X[, -1])
)
fit &lt;- fit_model(model)
summary(fit$model)
summary(multinom(y ~ x1 + x2, data = data.frame(X[, -1])))

## End(Not run)
</code></pre>

<hr>
<h2 id='build_mhmm'>Build a Mixture Hidden Markov Model</h2><span id='topic+build_mhmm'></span>

<h3>Description</h3>

<p>Function <code>build_mhmm</code> constructs a mixture hidden Markov model object of class <code>mhmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_mhmm(
  observations,
  n_states,
  transition_probs,
  emission_probs,
  initial_probs,
  formula = NULL,
  data = NULL,
  coefficients = NULL,
  cluster_names = NULL,
  state_names = NULL,
  channel_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_mhmm_+3A_observations">observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) containing
the sequences, or a list of such objects (one for each channel).</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_n_states">n_states</code></td>
<td>
<p>A numerical vector giving the number of hidden states in each submodel
(not used if starting values for model parameters are given with
<code>initial_probs</code>, <code>transition_probs</code>, or <code>emission_probs</code>).</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_transition_probs">transition_probs</code></td>
<td>
<p>A list of matrices of transition
probabilities for the submodel of each cluster.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_emission_probs">emission_probs</code></td>
<td>
<p>A list which contains matrices of emission probabilities or
a list of such objects (one for each channel) for the submodel of each cluster.
Note that the matrices must have dimensions <code class="reqn">m x s</code> where <code class="reqn">m</code> is the number of
hidden states and <code class="reqn">s</code> is the number of unique symbols (observed states) in the
data. Emission probabilities should follow the ordering of the alphabet of
observations (<code>alphabet(observations)</code>, returned as <code>symbol_names</code>).</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_initial_probs">initial_probs</code></td>
<td>
<p>A list which contains vectors of initial state
probabilities for the submodel of each cluster.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_formula">formula</code></td>
<td>
<p>Optional formula of class <code><a href="stats.html#topic+formula">formula</a></code> for the
mixture probabilities. Left side omitted.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables used in the formula.
Ignored if no formula is provided.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_coefficients">coefficients</code></td>
<td>
<p>An optional <code class="reqn">k x l</code> matrix of regression coefficients for
time-constant covariates for mixture probabilities, where <code class="reqn">l</code> is the number
of clusters and <code class="reqn">k</code> is the number of covariates. A logit-link is used for
mixture probabilities. The first column is set to zero.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_cluster_names">cluster_names</code></td>
<td>
<p>A vector of optional names for the clusters.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_state_names">state_names</code></td>
<td>
<p>A list of optional labels for the hidden states. If <code>NULL</code>,
the state names are taken as row names of transition matrices. If this is also <code>NULL</code>,
numbered states are used.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_channel_names">channel_names</code></td>
<td>
<p>A vector of optional names for the channels.</p>
</td></tr>
<tr><td><code id="build_mhmm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>simulate_transition_probs</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned model contains some attributes such as <code>nobs</code> and <code>df</code>,
which define the number of observations in the  model and the number of estimable
model parameters, used in computing BIC.
When computing <code>nobs</code> for a multichannel model with <code class="reqn">C</code> channels,
each observed value in a single channel amounts to <code class="reqn">1/C</code> observation,
i.e. a fully observed time point for a single sequence amounts to one observation.
For the degrees of freedom <code>df</code>, zero probabilities of the initial model are
defined as structural zeroes.
</p>


<h3>Value</h3>

<p>Object of class <code>mhmm</code> with following elements:
</p>

<dl>
<dt><code>observations</code></dt><dd><p>State sequence object or a list of such containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt><dd><p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt><dd><p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt><dd><p>A vector of initial probabilities.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>A matrix of parameter coefficients for covariates (covariates in rows, clusters in columns).</p>
</dd>
<dt><code>X</code></dt><dd><p>Covariate values for each subject.</p>
</dd>
<dt><code>cluster_names</code></dt><dd><p>Names for clusters.</p>
</dd>
<dt><code>state_names</code></dt><dd><p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt><dd><p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt><dd><p>Names for channels of sequence data</p>
</dd>
<dt><code>length_of_sequences</code></dt><dd><p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt><dd><p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt><dd><p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt><dd><p>Number of channels.</p>
</dd>
<dt><code>n_covariates</code></dt><dd><p>Number of covariates.</p>
</dd>
<dt><code>n_clusters</code></dt><dd><p>Number of clusters.</p>
</dd>
</dl>



<h3>References</h3>

<p>Helske S. and Helske J. (2019). Mixture Hidden Markov Models for Sequence Data: The seqHMM Package in R,
Journal of Statistical Software, 88(3), 1-32. doi:10.18637/jss.v088.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code> for fitting mixture Hidden Markov models;
<code><a href="#topic+summary.mhmm">summary.mhmm</a></code> for a summary of a MHMM; <code><a href="#topic+separate_mhmm">separate_mhmm</a></code> for
reorganizing a MHMM into a list of separate hidden Markov models; and
<code><a href="#topic+plot.mhmm">plot.mhmm</a></code> for plotting <code>mhmm</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("biofam3c")

## Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

## Choosing colors
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")

## MHMM with random starting values, no covariates
set.seed(468)
init_mhmm_bf1 &lt;- build_mhmm(
  observations = list(marr_seq, child_seq, left_seq),
  n_states = c(4, 4, 6),
  channel_names = c("Marriage", "Parenthood", "Residence")
)


## Starting values for emission probabilities

# Cluster 1
B1_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.3, 0.6, 0.1, # High probability for married
    0.3, 0.3, 0.4
  ), # High probability for divorced
  nrow = 4, ncol = 3, byrow = TRUE
)

B1_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.9, 0.1
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

B1_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9, # High probability for having left home
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

# Cluster 2

B2_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.7, 0.2, 0.1
  ),
  nrow = 4, ncol = 3, byrow = TRUE
)

B2_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

B2_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

# Cluster 3
B3_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.3, 0.4, 0.3,
    0.1, 0.1, 0.8
  ), # High probability for divorced
  nrow = 6, ncol = 3, byrow = TRUE
)

B3_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.5, 0.5,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9
  ),
  nrow = 6, ncol = 2, byrow = TRUE
)


B3_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 6, ncol = 2, byrow = TRUE
)

# Starting values for transition matrices
A1 &lt;- matrix(
  c(
    0.80, 0.16, 0.03, 0.01,
    0, 0.90, 0.07, 0.03,
    0, 0, 0.90, 0.10,
    0, 0, 0, 1
  ),
  nrow = 4, ncol = 4, byrow = TRUE
)

A2 &lt;- matrix(
  c(
    0.80, 0.10, 0.05, 0.03, 0.01, 0.01,
    0, 0.70, 0.10, 0.10, 0.05, 0.05,
    0, 0, 0.85, 0.01, 0.10, 0.04,
    0, 0, 0, 0.90, 0.05, 0.05,
    0, 0, 0, 0, 0.90, 0.10,
    0, 0, 0, 0, 0, 1
  ),
  nrow = 6, ncol = 6, byrow = TRUE
)

# Starting values for initial state probabilities
initial_probs1 &lt;- c(0.9, 0.07, 0.02, 0.01)
initial_probs2 &lt;- c(0.9, 0.04, 0.03, 0.01, 0.01, 0.01)

# Birth cohort
biofam3c$covariates$cohort &lt;- cut(biofam3c$covariates$birthyr, c(1908, 1935, 1945, 1957))
biofam3c$covariates$cohort &lt;- factor(
  biofam3c$covariates$cohort,
  labels = c("1909-1935", "1936-1945", "1946-1957")
)

## MHMM with own starting values and covariates
init_mhmm_bf2 &lt;- build_mhmm(
  observations = list(marr_seq, child_seq, left_seq),
  initial_probs = list(initial_probs1, initial_probs1, initial_probs2),
  transition_probs = list(A1, A1, A2),
  emission_probs = list(
    list(B1_marr, B1_child, B1_left),
    list(B2_marr, B2_child, B2_left),
    list(B3_marr, B3_child, B3_left)
  ),
  formula = ~ sex + cohort, data = biofam3c$covariates,
  cluster_names = c("Cluster 1", "Cluster 2", "Cluster 3"),
  channel_names = c("Marriage", "Parenthood", "Residence"),
  state_names = list(
    paste("State", 1:4), paste("State", 1:4),
    paste("State", 1:6)
  )
)

</code></pre>

<hr>
<h2 id='build_mm'>Build a Markov Model</h2><span id='topic+build_mm'></span>

<h3>Description</h3>

<p>Function <code>build_mm</code> builds and automatically estimates a Markov model. It is also a shortcut for
constructing a Markov model as a restricted case of an <code>hmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_mm(observations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_mm_+3A_observations">observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) containing
the sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the other build functions in <code>seqHMM</code>, the <code>build_mm</code> function
automatically estimates the model parameters. In case of no missing values,
initial and transition probabilities are
directly estimated from the observed initial state probabilities and transition counts.
In case of missing values, the EM algorithm is run once.
</p>
<p>Note that it is possible that the data contains a symbol from which there are
no transitions anywhere (even to itself), which would lead to a row in
transition matrix full of zeros. In this case the 'build_mm'
(as well as the EM algorithm) assumes that the
the state is absorbing in a way that probability of staying in this state is 1.
</p>


<h3>Value</h3>

<p>Object of class <code>hmm</code> with following elements:
</p>

<dl>
<dt><code>observations</code></dt><dd><p>State sequence object or a list of such containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt><dd><p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt><dd><p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt><dd><p>A vector of initial probabilities.</p>
</dd>
<dt><code>state_names</code></dt><dd><p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt><dd><p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt><dd><p>Names for channels of sequence data.</p>
</dd>
<dt><code>length_of_sequences</code></dt><dd><p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt><dd><p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt><dd><p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt><dd><p>Number of channels.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+plot.hmm">plot.hmm</a></code> for plotting the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct sequence data
data("mvad", package = "TraMineR")

mvad_alphabet &lt;-
  c("employment", "FE", "HE", "joblessness", "school", "training")
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet,
  states = mvad_scodes, labels = mvad_labels, xtstep = 6
)

# Define a color palette for the sequence data
attr(mvad_seq, "cpal") &lt;- colorpalette[[6]]

# Estimate the Markov model
mm_mvad &lt;- build_mm(observations = mvad_seq)

</code></pre>

<hr>
<h2 id='build_mmm'>Build a Mixture Markov Model</h2><span id='topic+build_mmm'></span>

<h3>Description</h3>

<p>Function <code>build_mmm</code> is a shortcut for constructing a mixture Markov
model as a restricted case of an <code>mhmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_mmm(
  observations,
  n_clusters,
  transition_probs,
  initial_probs,
  formula = NULL,
  data = NULL,
  coefficients = NULL,
  cluster_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_mmm_+3A_observations">observations</code></td>
<td>
<p>An <code>stslist</code> object (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) containing
the sequences.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_n_clusters">n_clusters</code></td>
<td>
<p>A scalar giving the number of clusters/submodels
(not used if starting values for model parameters are given with
<code>initial_probs</code> and <code>transition_probs</code>).</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_transition_probs">transition_probs</code></td>
<td>
<p>A list of matrices of transition
probabilities for submodels of each cluster.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_initial_probs">initial_probs</code></td>
<td>
<p>A list which contains vectors of initial state
probabilities for submodels of each cluster.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_formula">formula</code></td>
<td>
<p>Optional formula of class <code><a href="stats.html#topic+formula">formula</a></code> for the
mixture probabilities. Left side omitted.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables used in the formula.
Ignored if no formula is provided.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_coefficients">coefficients</code></td>
<td>
<p>An optional <code class="reqn">k x l</code> matrix of regression coefficients for
time-constant covariates for mixture probabilities, where <code class="reqn">l</code> is the number
of clusters and <code class="reqn">k</code> is the number of covariates. A logit-link is used for
mixture probabilities. The first column is set to zero.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_cluster_names">cluster_names</code></td>
<td>
<p>A vector of optional names for the clusters.</p>
</td></tr>
<tr><td><code id="build_mmm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>simulate_transition_probs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>mhmm</code> with following elements:
</p>

<dl>
<dt><code>observations</code></dt><dd><p>State sequence object or a list of such containing the data.</p>
</dd>
<dt><code>transition_probs</code></dt><dd><p>A matrix of transition probabilities.</p>
</dd>
<dt><code>emission_probs</code></dt><dd><p>A matrix or a list of matrices of emission probabilities.</p>
</dd>
<dt><code>initial_probs</code></dt><dd><p>A vector of initial probabilities.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>A matrix of parameter coefficients for covariates (covariates in rows, clusters in columns).</p>
</dd>
<dt><code>X</code></dt><dd><p>Covariate values for each subject.</p>
</dd>
<dt><code>cluster_names</code></dt><dd><p>Names for clusters.</p>
</dd>
<dt><code>state_names</code></dt><dd><p>Names for hidden states.</p>
</dd>
<dt><code>symbol_names</code></dt><dd><p>Names for observed states.</p>
</dd>
<dt><code>channel_names</code></dt><dd><p>Names for channels of sequence data</p>
</dd>
<dt><code>length_of_sequences</code></dt><dd><p>(Maximum) length of sequences.</p>
</dd>
<dt><code>n_sequences</code></dt><dd><p>Number of sequences.</p>
</dd>
<dt><code>n_symbols</code></dt><dd><p>Number of observed states (in each channel).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of hidden states.</p>
</dd>
<dt><code>n_channels</code></dt><dd><p>Number of channels.</p>
</dd>
<dt><code>n_covariates</code></dt><dd><p>Number of covariates.</p>
</dd>
<dt><code>n_clusters</code></dt><dd><p>Number of clusters.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code> for estimating model parameters;
<code><a href="#topic+summary.mhmm">summary.mhmm</a></code> for a summary of a mixture model;
<code><a href="#topic+separate_mhmm">separate_mhmm</a></code> for organizing an <code>mhmm</code> object into a list of
separate <code>hmm</code> objects; and <code><a href="#topic+plot.mhmm">plot.mhmm</a></code> for plotting
mixture models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Define sequence data
data("mvad", package = "TraMineR")
mvad_alphabet &lt;- c(
  "employment", "FE", "HE", "joblessness", "school",
  "training"
)
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet, states = mvad_scodes,
  labels = mvad_labels, xtstep = 6
)

# Initialize the MMM
set.seed(123)
mmm_mvad &lt;- build_mmm(
  observations = mvad_seq,
  n_clusters = 2,
  formula = ~male, data = mvad
)

## Not run: 
# Estimate model parameters
mmm_mvad &lt;- fit_model(mmm_mvad)$model

# Plot model (both clusters in the same plot)
require(igraph)
plot(mmm_mvad,
  interactive = FALSE,
  # Modify legend position and properties
  with.legend = "right", legend.prop = 0.3, cex.legend = 1.2,
  # Define vertex layout
  layout = layout_as_star,
  # Modify edge properties
  edge.label = NA, edge.arrow.size = 0.8, edge.curved = 0.2,
  # Modify vertex label positions (initial probabilities)
  vertex.label.pos = c("left", "right", "right", "left", "left", "right")
)

# Summary of the MMM
summary(mmm_mvad)

## End(Not run)
</code></pre>

<hr>
<h2 id='cluster_names'>Get cluster names from mhmm object</h2><span id='topic+cluster_names'></span>

<h3>Description</h3>

<p>Get cluster names from mhmm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_names(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_names_+3A_object">object</code></td>
<td>
<p>An object of class 'mhmm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the cluster names.
</p>

<hr>
<h2 id='cluster_names+26lt+3B-'>Set cluster names for mhmm object</h2><span id='topic+cluster_names+3C-'></span>

<h3>Description</h3>

<p>Set cluster names for mhmm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_names(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_names+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>An object of class 'mhmm'.</p>
</td></tr>
<tr><td><code id="cluster_names+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A character vector containing the new cluster names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object with updated cluster names.
</p>

<hr>
<h2 id='colorpalette'>Color palettes</h2><span id='topic+colorpalette'></span>

<h3>Description</h3>

<p>A list containing ready defined color palettes with distinct colors using
iWantHue. By default, <code>seqHMM</code> uses these palettes when assigning colors.
</p>


<h3>Format</h3>

<p>A list with 200 color palettes.
</p>


<h3>Source</h3>

<p>iWantHue web page <a href="https://medialab.github.io/iwanthue/">https://medialab.github.io/iwanthue/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_colors">plot_colors</a></code> for visualization of color palettes.
Implementations of iWantHue for R:
</p>

<ul>
<li> <p><a href="https://github.com/hoesler/rwantshue">https://github.com/hoesler/rwantshue</a>
</p>
</li>
<li> <p><a href="https://github.com/johnbaums/hues">https://github.com/johnbaums/hues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("colorpalette")
# Color palette with 9 colors
colorpalette[[9]]
# Color palette with 24 colors
colorpalette[[24]]

</code></pre>

<hr>
<h2 id='estimate_coef'>Estimate Regression Coefficients of Mixture Hidden Markov Models</h2><span id='topic+estimate_coef'></span>

<h3>Description</h3>

<p>Function <code>estimate_coef</code> estimates the regression coefficients of mixture hidden
Markov models and its restricted variants while keeping other parameters fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_coef(model, threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_coef_+3A_model">model</code></td>
<td>
<p>An object of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="estimate_coef_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. The default is 1.</p>
</td></tr>
</table>

<hr>
<h2 id='fit_model'>Estimate Parameters of (Mixture) Hidden Markov Models and Their Restricted
Variants</h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>Function <code>fit_model</code> estimates the parameters of mixture hidden
Markov models and its restricted variants using maximimum likelihood.
Initial values for estimation are taken from the corresponding components
of the model with preservation of original zero probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  model,
  em_step = TRUE,
  global_step = FALSE,
  local_step = FALSE,
  control_em = list(),
  control_global = list(),
  control_local = list(),
  lb,
  ub,
  threads = 1,
  log_space = FALSE,
  constraints = NULL,
  fixed_inits = NULL,
  fixed_emissions = NULL,
  fixed_transitions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_+3A_model">model</code></td>
<td>
<p>An object of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_em_step">em_step</code></td>
<td>
<p>Logical. Whether or not to use the EM algorithm at the start
of the parameter estimation. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_global_step">global_step</code></td>
<td>
<p>Logical. Whether or not to use global optimization via
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> (possibly after the EM step). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_local_step">local_step</code></td>
<td>
<p>Logical. Whether or not to use local optimization via
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> (possibly after the EM and/or global steps). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_control_em">control_em</code></td>
<td>
<p>Optional list of control parameters for the EM algorithm.
Possible arguments are </p>

<dl>
<dt>maxeval</dt><dd><p>The maximum number of iterations, the default is 1000.
Note that iteration counter starts with -1 so with <code>maxeval=1</code> you get already two iterations.
This is for backward compatibility reasons.</p>
</dd>
<dt>print_level</dt><dd><p>The level of printing. Possible values are 0
(prints nothing), 1 (prints information at the start and the end of the algorithm),
2 (prints at every iteration),
and for mixture models 3 (print also during optimization of coefficients).</p>
</dd>
<dt>reltol</dt><dd><p>Relative tolerance for convergence defined as
<code class="reqn">(logLik_new - logLik_old)/(abs(logLik_old) + 0.1)</code>.
The default is 1e-10.</p>
</dd>
<dt>restart</dt><dd><p>A list containing options for possible EM restarts with the
following components:
</p>

<dl>
<dt>times</dt><dd><p>Number of restarts of the EM algorithm using random initial values. The default is 0, i.e. no restarts. </p>
</dd>
<dt>transition</dt><dd><p>Logical. Should the original transition probabilities be varied? The default is <code>TRUE</code>. </p>
</dd>
<dt>emission</dt><dd><p>Logical. Should the original emission probabilities be varied? The default is <code>TRUE</code>. </p>
</dd>
<dt>sd</dt><dd><p>Standard deviation for <code>rnorm</code> used in randomization. The default is 0.25.</p>
</dd>
<dt>maxeval</dt><dd><p>Maximum number of iterations, the default is <code>control_em$maxeval</code></p>
</dd>
<dt>print_level</dt><dd><p>Level of printing in restarted EM steps. The default is <code>control_em$print_level</code>. </p>
</dd>
<dt>reltol</dt><dd><p>Relative tolerance for convergence at restarted EM steps. The default is <code>control_em$reltol</code>.
If the relative change of the final model of the restart phase is larger than the tolerance
for the original EM phase, the final model is re-estimated with the original <code>reltol</code>
and <code>maxeval</code> at the end of the EM step.</p>
</dd>
<dt>n_optimum</dt><dd><p>Save the log-likelihood values of the <code>n_optimum</code> best
models (from all estimated models including the the first EM run.).
The default is <code>min(times + 1, 25)</code>.</p>
</dd>
<dt>use_original</dt><dd><p>If <code>TRUE</code>. Use the initial values of the input model as starting
points for the permutations. Otherwise permute the results of the first EM run.</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="fit_model_+3A_control_global">control_global</code></td>
<td>
<p>Optional list of additional arguments for
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> argument <code>opts</code>. The default values are
</p>

<dl>
<dt>algorithm</dt><dd><p><code>"NLOPT_GD_MLSL_LDS"</code></p>
</dd>
<dt>local_opts</dt><dd><p><code>list(algorithm = "NLOPT_LD_LBFGS", ftol_rel = 1e-6, xtol_rel = 1e-4)</code></p>
</dd>
<dt>maxeval</dt><dd><p><code>10000</code> (maximum number of iterations in global optimization algorithm.)</p>
</dd>
<dt>maxtime</dt><dd><p><code>60</code> (maximum time for global optimization. Set to 0 for unlimited time.)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_model_+3A_control_local">control_local</code></td>
<td>
<p>Optional list of additional arguments for
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> argument <code>opts</code>. The default values are
</p>

<dl>
<dt>algorithm</dt><dd><p><code>"NLOPT_LD_LBFGS"</code></p>
</dd>
<dt>ftol_rel</dt><dd><p><code>1e-10</code></p>
</dd>
<dt>xtol_rel</dt><dd><p><code>1e-8</code></p>
</dd>
<dt>maxeval</dt><dd><p><code>10000</code> (maximum number of iterations)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fit_model_+3A_lb">lb</code>, <code id="fit_model_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds for parameters in Softmax parameterization.
The default interval is <code class="reqn">[pmin(-25, 2*initialvalues), pmax(25, 2*initialvalues)]</code>,
except for gamma coefficients,
where the scale of covariates is taken into account.
Note that it might still be a good idea to scale covariates around unit scale.
Bounds are used only in the global optimization step.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. The default is 1.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at a cost of decreased computational performance. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_constraints">constraints</code></td>
<td>
<p>Integer vector defining equality constraints for emission distributions.
Not supported for EM algorithm. See details.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fixed_inits">fixed_inits</code></td>
<td>
<p>Can be used to fix some of the probabilities to their initial values.
Should have same structure as <code>model$initial_probs</code>, where each element
is either TRUE (fixed) or FALSE (to be estimated). Note that zero probabilities are always fixed to 0.
Not supported for EM algorithm. See details.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fixed_emissions">fixed_emissions</code></td>
<td>
<p>Can be used to fix some of the probabilities to their initial values.
Should have same structure as <code>model$emission_probs</code>, where each element
is either TRUE (fixed) or FALSE (to be estimated). Note that zero probabilities are always fixed to 0.
Not supported for EM algorithm. See details.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fixed_transitions">fixed_transitions</code></td>
<td>
<p>Can be used to fix some of the probabilities to their initial values.
Should have same structure as <code>model$transition_probs</code>, where each element
is either TRUE (fixed) or FALSE (to be estimated). Note that zero probabilities are always fixed to 0.
Not supported for EM algorithm. See details.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>nloptr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting function provides three estimation steps: 1) EM algorithm,
2) global optimization, and 3) local optimization. The user can call for one method
or any combination of these steps, but should note that they are preformed in the
above-mentioned order. The results from a former step are used as starting values
in a latter, except for some of global optimization algorithms (such as MLSL and StoGO)
which only use initial values for setting up the boundaries for the optimization.
</p>
<p>It is possible to rerun the EM algorithm automatically using random starting
values based on the first run of EM. Number of restarts is defined by
the <code>restart</code> argument in <code>control_em</code>. As the EM algorithm is
relatively fast, this method might be preferred option compared to the proper
global optimization strategy of step 2.
</p>
<p>The default global optimization method (triggered via <code>global_step = TRUE</code>) is
the multilevel single-linkage method (MLSL) with the LDS modification (<code>NLOPT_GD_MLSL_LDS</code> as
<code>algorithm</code> in <code>control_global</code>), with L-BFGS as the local optimizer.
The MLSL method draws random starting points and performs a local optimization
from each. The LDS modification uses low-discrepancy sequences instead of
pseudo-random numbers as starting points and should improve the convergence rate.
In order to reduce the computation time spent on non-global optima, the
convergence tolerance of the local optimizer is set relatively large. At step 3,
a local optimization (L-BFGS by default) is run with a lower tolerance to find the
optimum with high precision.
</p>
<p>There are some theoretical guarantees that the MLSL method used as the default
optimizer in step 2 shoud find all local optima in a finite number of local
optimizations. Of course, it might not always succeed in a reasonable time.
The EM algorithm can help in finding good boundaries for the search, especially
with good starting values, but in some cases it can mislead. A good strategy is to
try a couple of different fitting options with different combinations of the methods:
e.g. all steps, only global and local steps, and a few evaluations of EM followed by
global and local optimization.
</p>
<p>By default, the estimation time is limited to 60 seconds in global optimization step, so it is
advisable to change the default settings for the proper global optimization.
</p>
<p>Any algorithm available in the <code>nloptr</code> function can be used for the global and
local steps.
</p>
<p>Equality constraints for emission distributions can be defined using the argument
<code>constraints</code>. This should be a vector with length equal to the number of states,
with numbers starting from 1 and increasing for each unique row of the emission probability matrix.
For example in case of five states with emissions of first and third states being equal,
<code>constraints = c(1, 2, 1, 3, 4)</code>. Similarly, some of the model parameters can be fixed to their
initial values by using arguments <code>fixed_inits</code>, <code>fixed_emissions</code>,
and <code>fixed_transitions</code>, where the structure of the arguments should be
same as the corresponding model components, so that TRUE value means that
the parameter should be fixed and FALSE otherwise (it is still treated as fixed if it
is zero though). For both types of constrains, only numerical optimisation
(local or global) is available, and currently the gradients are computed numerically
(if needed) in these cases.
</p>
<p>In a case where the is no transitions from one state to anywhere (even to
itself), the state is defined as absorbing in a way that probability of
staying in this state is fixed to 1. See also 'build_mm' function.
</p>


<h3>Value</h3>


<dl>
<dt>logLik</dt><dd><p>Log-likelihood of the estimated model. </p>
</dd>
<dt>em_results</dt><dd><p>Results after the EM step: log-likelihood (<code>logLik</code>), number of iterations
(<code>iterations</code>), relative change in log-likelihoods between the last two iterations (<code>change</code>), and
the log-likelihoods of the <code>n_optimum</code> best models after the EM step (<code>best_opt_restart</code>). </p>
</dd>
<dt>global_results</dt><dd><p>Results after the global step. </p>
</dd>
<dt>local_results</dt><dd><p>Results after the local step. </p>
</dd>
<dt>call</dt><dd><p>The matched function call. </p>
</dd>
</dl>



<h3>References</h3>

<p>Helske S. and Helske J. (2019). Mixture Hidden Markov Models for Sequence Data: The seqHMM Package in R,
Journal of Statistical Software, 88(3), 1-32. doi:10.18637/jss.v088.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code>,  <code><a href="#topic+build_mhmm">build_mhmm</a></code>,
<code><a href="#topic+build_mm">build_mm</a></code>,  <code><a href="#topic+build_mmm">build_mmm</a></code>, and  <code><a href="#topic+build_lcm">build_lcm</a></code>
for constructing different types of models; <code><a href="#topic+summary.mhmm">summary.mhmm</a></code>
for a summary of a MHMM; <code><a href="#topic+separate_mhmm">separate_mhmm</a></code> for reorganizing a MHMM into
a list of separate hidden Markov models; <code><a href="#topic+plot.hmm">plot.hmm</a></code> and <code><a href="#topic+plot.mhmm">plot.mhmm</a></code>
for plotting model objects; and <code><a href="#topic+ssplot">ssplot</a></code> and <code><a href="#topic+mssplot">mssplot</a></code> for plotting
stacked sequence plots of <code>hmm</code> and <code>mhmm</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Hidden Markov model for mvad data

data("mvad", package = "TraMineR")

mvad_alphabet &lt;-
  c("employment", "FE", "HE", "joblessness", "school", "training")
mvad_labels &lt;- c(
  "employment", "further education", "higher education",
  "joblessness", "school", "training"
)
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86,
  alphabet = mvad_alphabet,
  states = mvad_scodes, labels = mvad_labels, xtstep = 6
)

attr(mvad_seq, "cpal") &lt;- colorpalette[[6]]

# Starting values for the emission matrix
emiss &lt;- matrix(
  c(
    0.05, 0.05, 0.05, 0.05, 0.75, 0.05, # SC
    0.05, 0.75, 0.05, 0.05, 0.05, 0.05, # FE
    0.05, 0.05, 0.05, 0.4, 0.05, 0.4, # JL, TR
    0.05, 0.05, 0.75, 0.05, 0.05, 0.05, # HE
    0.75, 0.05, 0.05, 0.05, 0.05, 0.05
  ), # EM
  nrow = 5, ncol = 6, byrow = TRUE
)

# Starting values for the transition matrix
trans &lt;- matrix(0.025, 5, 5)
diag(trans) &lt;- 0.9

# Starting values for initial state probabilities
initial_probs &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)

# Building a hidden Markov model
init_hmm_mvad &lt;- build_hmm(
  observations = mvad_seq,
  transition_probs = trans, emission_probs = emiss,
  initial_probs = initial_probs
)

## Not run: 
set.seed(21)
fit_hmm_mvad &lt;- fit_model(init_hmm_mvad, control_em = list(restart = list(times = 50)))
hmm_mvad &lt;- fit_hmm_mvad$model

## End(Not run)

# save time, load the previously estimated model
data("hmm_mvad")

# Markov model
# Note: build_mm estimates model parameters from observations,
# no need for estimating with fit_model unless there are missing observations

mm_mvad &lt;- build_mm(observations = mvad_seq)

# Comparing likelihoods, MM fits better
logLik(hmm_mvad)
logLik(mm_mvad)

## Not run: 
require("igraph") # for layout_in_circle

plot(mm_mvad,
  layout = layout_in_circle, legend.prop = 0.3,
  edge.curved = 0.3, edge.label = NA,
  vertex.label.pos = c(0, 0, pi, pi, pi, 0)
)

##############################################################


#' # Three-state three-channel hidden Markov model
# See ?hmm_biofam for five-state version

data("biofam3c")

# Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

# Define colors
attr(marr_seq, "cpal") &lt;- c("violetred2", "darkgoldenrod2", "darkmagenta")
attr(child_seq, "cpal") &lt;- c("darkseagreen1", "coral3")
attr(left_seq, "cpal") &lt;- c("lightblue", "red3")

# Starting values for emission matrices

emiss_marr &lt;- matrix(NA, nrow = 3, ncol = 3)
emiss_marr[1, ] &lt;- seqstatf(marr_seq[, 1:5])[, 2] + 1
emiss_marr[2, ] &lt;- seqstatf(marr_seq[, 6:10])[, 2] + 1
emiss_marr[3, ] &lt;- seqstatf(marr_seq[, 11:16])[, 2] + 1
emiss_marr &lt;- emiss_marr / rowSums(emiss_marr)

emiss_child &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_child[1, ] &lt;- seqstatf(child_seq[, 1:5])[, 2] + 1
emiss_child[2, ] &lt;- seqstatf(child_seq[, 6:10])[, 2] + 1
emiss_child[3, ] &lt;- seqstatf(child_seq[, 11:16])[, 2] + 1
emiss_child &lt;- emiss_child / rowSums(emiss_child)

emiss_left &lt;- matrix(NA, nrow = 3, ncol = 2)
emiss_left[1, ] &lt;- seqstatf(left_seq[, 1:5])[, 2] + 1
emiss_left[2, ] &lt;- seqstatf(left_seq[, 6:10])[, 2] + 1
emiss_left[3, ] &lt;- seqstatf(left_seq[, 11:16])[, 2] + 1
emiss_left &lt;- emiss_left / rowSums(emiss_left)

# Starting values for transition matrix
trans &lt;- matrix(c(
  0.9, 0.07, 0.03,
  0, 0.9, 0.1,
  0, 0, 1
), nrow = 3, ncol = 3, byrow = TRUE)

# Starting values for initial state probabilities
inits &lt;- c(0.9, 0.09, 0.01)

# Building hidden Markov model with initial parameter values
init_hmm_bf &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  transition_probs = trans,
  emission_probs = list(emiss_marr, emiss_child, emiss_left),
  initial_probs = inits
)

# Fitting the model with different optimization schemes

# Only EM with default values
hmm_1 &lt;- fit_model(init_hmm_bf)
hmm_1$logLik # -24179.1

# Only L-BFGS
hmm_2 &lt;- fit_model(init_hmm_bf, em_step = FALSE, local_step = TRUE)
hmm_2$logLik # -22267.75

# Global optimization via MLSL_LDS with L-BFGS as local optimizer and final polisher
# This can be slow, use parallel computing by adjusting threads argument
# (here threads = 1 for portability issues)
hmm_3 &lt;- fit_model(
  init_hmm_bf,
  em_step = FALSE, global_step = TRUE, local_step = TRUE,
  control_global = list(maxeval = 5000, maxtime = 0), threads = 1
)
hmm_3$logLik # -21675.42

# EM with restarts, much faster than MLSL
set.seed(123)
hmm_4 &lt;- fit_model(init_hmm_bf, control_em = list(restart = list(times = 5)))
hmm_4$logLik # -21675.4

# Global optimization via StoGO with L-BFGS as final polisher
# This can be slow, use parallel computing by adjusting threads argument
# (here threads = 1 for portability issues)
set.seed(123)
hmm_5 &lt;- fit_model(
  init_hmm_bf,
  em_step = FALSE, global_step = TRUE, local_step = TRUE,
  lb = -50, ub = 50, control_global = list(
    algorithm = "NLOPT_GD_STOGO",
    maxeval = 2500, maxtime = 0
  ), threads = 1
)
hmm_5$logLik # -21675.4

##############################################################

# Mixture HMM

data("biofam3c")

## Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

## Choosing colors
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")

## Starting values for emission probabilities
# Cluster 1
B1_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.3, 0.6, 0.1, # High probability for married
    0.3, 0.3, 0.4
  ), # High probability for divorced
  nrow = 4, ncol = 3, byrow = TRUE
)

B1_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.9, 0.1
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

B1_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9, # High probability for having left home
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

# Cluster 2

B2_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.7, 0.2, 0.1
  ),
  nrow = 4, ncol = 3, byrow = TRUE
)

B2_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

B2_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 4, ncol = 2, byrow = TRUE
)

# Cluster 3
B3_marr &lt;- matrix(
  c(
    0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.3, 0.4, 0.3,
    0.1, 0.1, 0.8
  ), # High probability for divorced
  nrow = 6, ncol = 3, byrow = TRUE
)

B3_child &lt;- matrix(
  c(
    0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.5, 0.5,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9
  ),
  nrow = 6, ncol = 2, byrow = TRUE
)


B3_left &lt;- matrix(
  c(
    0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9,
    0.1, 0.9
  ),
  nrow = 6, ncol = 2, byrow = TRUE
)

# Starting values for transition matrices
A1 &lt;- matrix(
  c(
    0.80, 0.16, 0.03, 0.01,
    0, 0.90, 0.07, 0.03,
    0, 0, 0.90, 0.10,
    0, 0, 0, 1
  ),
  nrow = 4, ncol = 4, byrow = TRUE
)

A2 &lt;- matrix(
  c(
    0.80, 0.10, 0.05, 0.03, 0.01, 0.01,
    0, 0.70, 0.10, 0.10, 0.05, 0.05,
    0, 0, 0.85, 0.01, 0.10, 0.04,
    0, 0, 0, 0.90, 0.05, 0.05,
    0, 0, 0, 0, 0.90, 0.10,
    0, 0, 0, 0, 0, 1
  ),
  nrow = 6, ncol = 6, byrow = TRUE
)

# Starting values for initial state probabilities
initial_probs1 &lt;- c(0.9, 0.07, 0.02, 0.01)
initial_probs2 &lt;- c(0.9, 0.04, 0.03, 0.01, 0.01, 0.01)

# Birth cohort
biofam3c$covariates$cohort &lt;- cut(biofam3c$covariates$birthyr, c(1908, 1935, 1945, 1957))
biofam3c$covariates$cohort &lt;- factor(
  biofam3c$covariates$cohort,
  labels = c("1909-1935", "1936-1945", "1946-1957")
)

# Build mixture HMM
init_mhmm_bf &lt;- build_mhmm(
  observations = list(marr_seq, child_seq, left_seq),
  initial_probs = list(initial_probs1, initial_probs1, initial_probs2),
  transition_probs = list(A1, A1, A2),
  emission_probs = list(
    list(B1_marr, B1_child, B1_left),
    list(B2_marr, B2_child, B2_left),
    list(B3_marr, B3_child, B3_left)
  ),
  formula = ~ sex + cohort, data = biofam3c$covariates,
  channel_names = c("Marriage", "Parenthood", "Residence")
)


# Fitting the model with different settings

# Only EM with default values
mhmm_1 &lt;- fit_model(init_mhmm_bf)
mhmm_1$logLik # -12713.08

# Only L-BFGS
mhmm_2 &lt;- fit_model(init_mhmm_bf, em_step = FALSE, local_step = TRUE)
mhmm_2$logLik # -12966.51

# Use EM with multiple restarts
set.seed(123)
mhmm_3 &lt;- fit_model(init_mhmm_bf, control_em = list(restart = list(times = 5, transition = FALSE)))
mhmm_3$logLik # -12713.08

## End(Not run)

# Left-to-right HMM with equality constraint:

set.seed(1)

# Transition matrix
# Either stay or move to next state
A &lt;- diag(c(0.9, 0.95, 0.95, 1))
A[1, 2] &lt;- 0.1
A[2, 3] &lt;- 0.05
A[3, 4] &lt;- 0.05

# Emission matrix, rows 1 and 3 equal
B &lt;- rbind(
  c(0.4, 0.2, 0.3, 0.1),
  c(0.1, 0.5, 0.1, 0.3),
  c(0.4, 0.2, 0.3, 0.1),
  c(0, 0.2, 0.4, 0.4)
)

# Start from first state
init &lt;- c(1, 0, 0, 0)

# Simulate sequences
sim &lt;- simulate_hmm(
  n_sequences = 100,
  sequence_length = 20, init, A, B
)

# initial model, use true values as inits for faster estimation here
model &lt;- build_hmm(sim$observations, init = init, trans = A, emiss = B)

# estimate the model subject to constraints:
# First and third row of emission matrix are equal (see details)
fit &lt;- fit_model(model,
  constraints = c(1, 2, 1, 3),
  em_step = FALSE, local_step = TRUE
)
fit$model

## Fix some emissions:

fixB &lt;- matrix(FALSE, 4, 4)
fixB[2, 1] &lt;- fixB[1, 3] &lt;- TRUE # these are fixed to their initial values
fit &lt;- fit_model(model,
  fixed_emissions = fixB,
  em_step = FALSE, local_step = TRUE
)
fit$model$emission_probs
</code></pre>

<hr>
<h2 id='forward_backward'>Forward and Backward Probabilities for Hidden Markov Model</h2><span id='topic+forward_backward'></span>

<h3>Description</h3>

<p>The <code>forward_backward</code> function computes scaled forward and backward probabilities of a hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward_backward(model, forward_only = FALSE, log_space = FALSE, threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_backward_+3A_model">model</code></td>
<td>
<p>Object of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="forward_backward_+3A_forward_only">forward_only</code></td>
<td>
<p>If <code>TRUE</code>, only forward probabilities are computed. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="forward_backward_+3A_log_space">log_space</code></td>
<td>
<p>Compute forward and backward probabilities in logarithmic scale instead of scaling.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="forward_backward_+3A_threads">threads</code></td>
<td>
<p>Number of threads used in parallel computing. The default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr><td><code>forward_probs</code></td>
<td>
<p>If <code>log_space = FALSE</code>, scaled forward probabilities, i.e. probability of state given
observations up to that time point. If <code>log_space = TRUE</code>,
logarithms of non-scaled forward probabilities. </p>
</td></tr>
<tr><td><code>backward_probs</code></td>
<td>
<p>Scaled backward probabilities (<code>log_space = FALSE</code>),
or logarithms of non-scaled backward probabilities(<code>log_space = TRUE</code>). </p>
</td></tr>
<tr><td><code>scaling_factors</code></td>
<td>
<p>Sum of non-scaled forward probabilities at each time point.
Only computed if <code>log_space = FALSE</code>.</p>
</td></tr>
</table>
<p>In case of multiple observations, these are computed independently for each sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a pre-defined MHMM
data("mhmm_biofam")

# Compute forward and backward probabilities
fb &lt;- forward_backward(mhmm_biofam)

# The most probable hidden state at time t
# given the observations up to time t for the first subject:
apply(fb$forward_probs[, , 1], 2, which.max)

</code></pre>

<hr>
<h2 id='gridplot'>Plot Multidimensional Sequence Plots in a Grid</h2><span id='topic+gridplot'></span>

<h3>Description</h3>

<p>Function <code>gridplot</code> plots multiple <code>ssp</code> objects to a
grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridplot(
  x,
  nrow = NA,
  ncol = NA,
  byrow = FALSE,
  with.legend = "auto",
  legend.pos = "auto",
  legend.pos2 = "center",
  title.legend = "auto",
  ncol.legend = "auto",
  with.missing.legend = "auto",
  row.prop = "auto",
  col.prop = "auto",
  cex.legend = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridplot_+3A_x">x</code></td>
<td>
<p>A list of <code><a href="#topic+ssp">ssp</a></code> objects.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_nrow">nrow</code>, <code id="gridplot_+3A_ncol">ncol</code></td>
<td>
<p>Optional arguments to arrange plots.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_byrow">byrow</code></td>
<td>
<p>Controls the order of plotting. Defaults to <code>FALSE</code>, i.e. plots
are arranged column-wise.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and how the legends for the states are plotted.
The default value <code>"auto"</code> (equivalent to <code>TRUE</code> and
<code>"many"</code>) creates separate legends for each requested plot. Other
possibilities are <code>"combined"</code> (all legends combined) and <code>FALSE</code>
(no legend).</p>
</td></tr>
<tr><td><code id="gridplot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Defines the positions of the legend boxes relative to the
whole plot. Either one of <code>"bottom"</code> (equivalent to <code>"auto"</code>) or
<code>"right"</code>, or a numerical vector of grid cells (by order) to print the
legends to (the cells must be in one row/column).</p>
</td></tr>
<tr><td><code id="gridplot_+3A_legend.pos2">legend.pos2</code></td>
<td>
<p>Defines the positions of the legend boxes relative to the
cell(s). One of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>,
<code>"left"</code>, <code>"topleft"</code>, <code>"top"</code> (the default), <code>"topright"</code>,
<code>"right"</code> and <code>"center"</code>.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_title.legend">title.legend</code></td>
<td>
<p>The titles for the legend boxes. The default <code>"auto"</code> takes
the titles from the channel labels provided by the first object in <code>x</code>.
<code>NA</code> prints no title.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>(A vector of) the number of columns for the legend(s). The
default <code>"auto"</code> creates one column for each legend.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_with.missing.legend">with.missing.legend</code></td>
<td>
<p>If set to <code>"auto"</code> (the default), a legend
for the missing state is added automatically if one or more of the
sequences in data contain missing states. With the value <code>TRUE</code> a
legend for the missing state is added in any case; equivalently
<code>FALSE</code> omits the legend for the missing state.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_row.prop">row.prop</code></td>
<td>
<p>Sets the proportions of the row heights of the grid. The default
value is <code>"auto"</code> for even row heights. Takes a vector of values from
0 to 1, with values summing to 1.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_col.prop">col.prop</code></td>
<td>
<p>Sets the proportion of the column heights of the grid. The default
value is <code>"auto"</code> for even column widths. Takes a vector of values
from 0 to 1, with values summing to 1.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ssp">ssp</a></code> for defining the plot before using
<code>gridplot</code>, and <code><a href="#topic+plot.ssp">plot.ssp</a></code> for plotting only one ssp object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("biofam3c")

# Creating sequence objects
child_seq &lt;- seqdef(biofam3c$children, start = 15)
marr_seq &lt;- seqdef(biofam3c$married, start = 15)
left_seq &lt;- seqdef(biofam3c$left, start = 15)

## Choosing colors
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")


# Preparing plot for state distribution plots of observations for women
ssp_f &lt;- ssp(
  list(
    child_seq[biofam3c$covariates$sex == "woman", ],
    marr_seq[biofam3c$covariates$sex == "woman", ],
    left_seq[biofam3c$covariates$sex == "woman", ]
  ),
  type = "d", plots = "obs", title = "Women",
  ylab = c("Children", "Married", "Left home")
)

# Preparing plot for state distribution plots of observations for men
# (Updating the previous plot, only arguments that change values)
ssp_m &lt;- update(ssp_f,
  title = "Men",
  x = list(
    child_seq[biofam3c$covariates$sex == "man", ],
    marr_seq[biofam3c$covariates$sex == "man", ],
    left_seq[biofam3c$covariates$sex == "man", ]
  )
)

# Plotting state distribution plots of observations for women and men in two columns
gridplot(list(ssp_f, ssp_m), ncol = 2, with.legend = FALSE)

# Preparing plots for women's state distributions
ssp_f2 &lt;- ssp(
  list(
    marr_seq[biofam3c$covariates$sex == "woman", ],
    child_seq[biofam3c$covariates$sex == "woman", ],
    left_seq[biofam3c$covariates$sex == "woman", ]
  ),
  type = "d", border = NA, with.legend = FALSE,
  title = "State distributions for women", title.n = FALSE, xtlab = 15:30,
  ylab.pos = c(1, 2, 1), ylab = c("Married", "Children", "Left home")
)

# The same plot with sequences instead of state distributions
ssp_f3 &lt;- update(
  ssp_f2,
  type = "I", sortv = "mds.obs", title = "Sequences for women"
)

# State distributions with men's data
ssp_m2 &lt;- update(
  ssp_f2,
  title = "State distributions for men",
  x = list(
    marr_seq[biofam3c$covariates$sex == "man", ],
    child_seq[biofam3c$covariates$sex == "man", ],
    left_seq[biofam3c$covariates$sex == "man", ]
  )
)

# Men's sequences
ssp_m3 &lt;- update(
  ssp_m2,
  type = "I", sortv = "mds.obs", title = "Sequences for men"
)

# Plotting state distributions and index plots of observations
# for women and men in two columns (+ one column for legends)
gridplot(
  list(ssp_f2, ssp_f3, ssp_m2, ssp_m3),
  ncol = 3, byrow = TRUE,
  with.legend = "combined", legend.pos = "right", col.prop = c(0.35, 0.35, 0.3)
)

# The same with different positioning and fixed cells for legends
gridplot(
  list(ssp_f2, ssp_f3, ssp_m2, ssp_m3),
  ncol = 2, nrow = 3, byrow = TRUE,
  # defining the legend positions by the cell numbers
  legend.pos = 3:4
)

## End(Not run)

</code></pre>

<hr>
<h2 id='hidden_paths'>Most Probable Paths of Hidden States</h2><span id='topic+hidden_paths'></span>

<h3>Description</h3>

<p>Function <code>hidden_paths</code> computes the most probable path of
hidden states of a (mixture) hidden Markov model given the observed sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidden_paths(model, respect_void = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidden_paths_+3A_model">model</code></td>
<td>
<p>A hidden Markov model of class <code>hmm</code> or
a mixture HMM of class <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="hidden_paths_+3A_respect_void">respect_void</code></td>
<td>
<p>If <code>TRUE</code> (default), states at the time points
corresponding to TraMineR's void in the observed sequences are set to void
in the hidden state sequences as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The most probable paths of hidden states as an <code>stslist</code> object
(see <code><a href="#topic+seqdef">seqdef</a></code>). The log-probability is included as an attribute <code>log_prob</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm_biofam">hmm_biofam</a></code> for information on the model used in the example;
and <code>seqIplot</code>, <code><a href="#topic+ssplot">ssplot</a></code>, or <code><a href="#topic+mssplot">mssplot</a></code>
for plotting hidden paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a pre-defined HMM
data("hmm_biofam")

# Compute the most probable hidden state paths given the data and the model
mpp &lt;- hidden_paths(hmm_biofam)

# Plot hidden paths for the first 100 individuals
ssplot(mpp, type = "I", tlim = 1:100)

# Because the model structure is so sparse that the posterior probabilities are
# mostly peaked to single state at each time point, the joint probability of
# observations and most probable paths of hidden states is almost identical to
# log-likelihood:

sum(attr(mpp, "log_prob"))
logLik(hmm_biofam)

</code></pre>

<hr>
<h2 id='hmm_biofam'>Hidden Markov model for the biofam data</h2><span id='topic+hmm_biofam'></span>

<h3>Description</h3>

<p>A five-state hidden Markov model (HMM) fitted for the <code><a href="TraMineR.html#topic+biofam">biofam</a></code> data.
</p>


<h3>Format</h3>

<p>A hidden Markov model of class <code>hmm</code>;
a left-to-right model with four hidden states.
</p>


<h3>Details</h3>

<p>The model is loaded by calling <code>data(hmm_biofam)</code>. It was created with the
following code:
</p>
<pre>
data("biofam3c")

# Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married, start = 15,
  alphabet = c("single", "married", "divorced"))
child_seq &lt;- seqdef(biofam3c$children, start = 15,
  alphabet = c("childless", "children"))
left_seq &lt;- seqdef(biofam3c$left, start = 15,
  alphabet = c("with parents", "left home"))

## Choosing colors
attr(marr_seq, "cpal") &lt;- c("violetred2", "darkgoldenrod2", "darkmagenta")
attr(child_seq, "cpal") &lt;- c("darkseagreen1", "coral3")
attr(left_seq, "cpal") &lt;- c("lightblue", "red3")

init &lt;- c(0.9, 0.05, 0.02, 0.02, 0.01)

# Starting values for transition matrix
trans &lt;- matrix(
  c(0.8, 0.10, 0.05, 0.03, 0.02,
    0,    0.9, 0.05, 0.03, 0.02,
    0,      0,  0.9, 0.07, 0.03,
    0,      0,    0,  0.9,  0.1,
    0,      0,    0,    0,    1),
  nrow = 5, ncol = 5, byrow = TRUE)

# Starting values for emission matrices
emiss_marr &lt;- matrix(
  c(0.9, 0.05, 0.05, # High probability for single
    0.9, 0.05, 0.05,
    0.05, 0.9, 0.05, # High probability for married
    0.05, 0.9, 0.05,
    0.3, 0.3, 0.4), # mixed group
  nrow = 5, ncol = 3, byrow = TRUE)

emiss_child &lt;- matrix(
  c(0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.1, 0.9,
    0.1, 0.9,
    0.5, 0.5),
  nrow = 5, ncol = 2, byrow = TRUE)

emiss_left &lt;- matrix(
  c(0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.1, 0.9,
    0.1, 0.9,
    0.5, 0.5),
  nrow = 5, ncol = 2, byrow = TRUE)

initmod &lt;- build_hmm(
  observations = list(marr_seq, child_seq, left_seq),
  initial_probs = init, transition_probs = trans,
  emission_probs = list(emiss_marr, emiss_child,
    emiss_left),
  channel_names = c("Marriage", "Parenthood", "Residence"))

fit_biofam &lt;- fit_model(initmod, em = FALSE, local = TRUE)
hmm_biofam &lt;- fit_biofam$model
</pre>


<h3>See Also</h3>

<p>Examples of building and fitting HMMs in <code><a href="#topic+build_hmm">build_hmm</a></code> and
<code><a href="#topic+fit_model">fit_model</a></code>; and <code><a href="TraMineR.html#topic+biofam">biofam</a></code> for the original data and
<code><a href="#topic+biofam3c">biofam3c</a></code> for the three-channel version used in this model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plotting the model
plot(hmm_biofam)

</code></pre>

<hr>
<h2 id='hmm_mvad'>Hidden Markov model for the mvad data</h2><span id='topic+hmm_mvad'></span>

<h3>Description</h3>

<p>A hidden Markov model (MMM) fitted for the <code><a href="TraMineR.html#topic+mvad">mvad</a></code> data.
</p>


<h3>Format</h3>

<p>A hidden Markov model of class <code>hmm</code>;
unrestricted model with six hidden states.
</p>


<h3>Details</h3>

<p>Model was created with the following code:
</p>
<pre>

data("mvad", package = "TraMineR")

mvad_alphabet &lt;-
  c("employment", "FE", "HE", "joblessness", "school", "training")
mvad_labels &lt;- c("employment", "further education", "higher education",
  "joblessness", "school", "training")
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86, alphabet = mvad_alphabet,
  states = mvad_scodes, labels = mvad_labels, xtstep = 6)

attr(mvad_seq, "cpal") &lt;- colorpalette[[6]]

# Starting values for the emission matrix
emiss &lt;- matrix(
  c(0.05, 0.05, 0.05, 0.05, 0.75, 0.05, # SC
    0.05, 0.75, 0.05, 0.05, 0.05, 0.05, # FE
    0.05, 0.05, 0.05, 0.4,  0.05, 0.4,  # JL, TR
    0.05, 0.05, 0.75, 0.05, 0.05, 0.05, # HE
    0.75, 0.05, 0.05, 0.05, 0.05, 0.05),# EM
  nrow = 5, ncol = 6, byrow = TRUE)

# Starting values for the transition matrix
trans &lt;- matrix(0.025, 5, 5)
diag(trans) &lt;- 0.9

# Starting values for initial state probabilities
initial_probs &lt;- c(0.2, 0.2, 0.2, 0.2, 0.2)

# Building a hidden Markov model
init_hmm_mvad &lt;- build_hmm(observations = mvad_seq,
  transition_probs = trans, emission_probs = emiss,
  initial_probs = initial_probs)

set.seed(21)
fit_hmm_mvad &lt;- fit_model(init_hmm_mvad, control_em = list(restart = list(times = 100)))
hmm_mvad &lt;- fit_hmm_mvad$model
</pre>


<h3>See Also</h3>

<p>Examples of building and fitting HMMs in <code><a href="#topic+build_hmm">build_hmm</a></code> and
<code><a href="#topic+fit_model">fit_model</a></code>; and <code><a href="TraMineR.html#topic+mvad">mvad</a></code> for more information on the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hmm_mvad")

# Plotting the model
plot(hmm_mvad)

</code></pre>

<hr>
<h2 id='logLik.hmm'>Log-likelihood of the Hidden Markov Model</h2><span id='topic+logLik.hmm'></span>

<h3>Description</h3>

<p>Function <code>logLik.hmm</code> computes the log-likelihood value of a hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm'
logLik(object, partials = FALSE, threads = 1, log_space = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.hmm_+3A_object">object</code></td>
<td>
<p>A  hidden Markov model of class <code>hmm</code>.</p>
</td></tr>
<tr><td><code id="logLik.hmm_+3A_partials">partials</code></td>
<td>
<p>Return a vector containing the individual contributions of each sequence to the total log-likelihood.
The default is <code>FALSE</code>, which returns the sum of all log-likelihood components.</p>
</td></tr>
<tr><td><code id="logLik.hmm_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. The default is 1.</p>
</td></tr>
<tr><td><code id="logLik.hmm_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at the cost of decreased computational performance.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="logLik.hmm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood of the hidden Markov model. This is an object of class
<code>logLik</code> with attributes <code>nobs</code> and <code>df</code> inherited from the model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting Hidden Markov models.
</p>

<hr>
<h2 id='logLik.mhmm'>Log-likelihood of the Mixture Hidden Markov Model</h2><span id='topic+logLik.mhmm'></span>

<h3>Description</h3>

<p>Function <code>logLik.mhmm</code> computes the log-likelihood value of a mixture hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mhmm'
logLik(object, partials = FALSE, threads = 1, log_space = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mhmm_+3A_object">object</code></td>
<td>
<p>A mixture hidden Markov model of class <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="logLik.mhmm_+3A_partials">partials</code></td>
<td>
<p>Return a vector containing the individual contributions of each sequence to the total log-likelihood.
The default is <code>FALSE</code>, which returns the sum of all log-likelihood components.</p>
</td></tr>
<tr><td><code id="logLik.mhmm_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. The default is 1.</p>
</td></tr>
<tr><td><code id="logLik.mhmm_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at the cost of decreased computational performance.
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="logLik.mhmm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log-likelihood of the mixture hidden Markov model. This is an object of class
<code>logLik</code> with attributes <code>nobs</code> and <code>df</code> inherited from the model object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting mixture Hidden Markov models.
</p>

<hr>
<h2 id='mc_to_sc'>Transform a Multichannel Hidden Markov Model into a Single Channel Representation</h2><span id='topic+mc_to_sc'></span>

<h3>Description</h3>

<p>Transforms data and parameters of a multichannel model into a single
channel model. Observed states (symbols) are combined and parameters
multiplied across channels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_to_sc(model, combine_missing = TRUE, all_combinations = FALSE, cpal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_to_sc_+3A_model">model</code></td>
<td>
<p>An object of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="mc_to_sc_+3A_combine_missing">combine_missing</code></td>
<td>
<p>Controls whether combined states of observations
at time <code class="reqn">t</code> are coded missing (coded with <code class="reqn">*</code> in <code>stslist</code>s)
if one or more of the channels include missing information at time <code class="reqn">t</code>.
Defaults to <code>TRUE</code>. <code>FALSE</code> keeps missing states
as they are, producing more states in data; e.g. <code class="reqn">single/childless/*</code>
where the observation in channel 3 is missing.</p>
</td></tr>
<tr><td><code id="mc_to_sc_+3A_all_combinations">all_combinations</code></td>
<td>
<p>Controls whether all possible combinations of
observed states are included in the single channel representation or only
combinations that are found in the data. Defaults to <code>FALSE</code>, i.e.
only actual observations are included.</p>
</td></tr>
<tr><td><code id="mc_to_sc_+3A_cpal">cpal</code></td>
<td>
<p>The color palette used for the new combined symbols. Optional in
a case where the number of symbols is less or equal to 200 (in which case
the <code>seqHMM::colorpalette</code> is used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in case of no missing observations, the log-likelihood of
the original and transformed models are identical but the AIC and BIC
can be different as the model attribute <code>df</code> is recomputed based
on the single channel representation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting Hidden Markov models; and <code><a href="#topic+hmm_biofam">hmm_biofam</a></code> for information on
the model used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a hidden Markov model of the biofam data (hmm object)
data("hmm_biofam")

# Convert the multichannel model to a single-channel model
sc &lt;- mc_to_sc(hmm_biofam)

# Likelihoods of the single-channel and the multichannel model are the same
# (Might not be true if there are missing observations)
logLik(sc)
logLik(hmm_biofam)
</code></pre>

<hr>
<h2 id='mc_to_sc_data'>Merge Multiple Sequence Objects into One (from Multichannel to Single Channel Data)</h2><span id='topic+mc_to_sc_data'></span>

<h3>Description</h3>

<p>Function <code>mc_to_sc_data</code> combines observed states of multiple
sequence objects into one, time point by time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_to_sc_data(data, combine_missing = TRUE, all_combinations = FALSE, cpal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_to_sc_data_+3A_data">data</code></td>
<td>
<p>A list of state sequence objects (<code>stslist</code>s)
created with the <code><a href="#topic+seqdef">seqdef</a></code> function.</p>
</td></tr>
<tr><td><code id="mc_to_sc_data_+3A_combine_missing">combine_missing</code></td>
<td>
<p>Controls whether combined states of observations
at time t are coded missing (coded with * in <code>stslist</code>s)
if one or more of the channels include missing information at time t.
Defaults to <code>TRUE</code>. <code>FALSE</code> keeps missing states
as they are, producing more states in data; e.g. single/childless/*
where the observation in channel 3 is missing.</p>
</td></tr>
<tr><td><code id="mc_to_sc_data_+3A_all_combinations">all_combinations</code></td>
<td>
<p>Controls whether all possible combinations of
observed states are included in the single channel representation or
only combinations that are found in the data. Defaults to <code>FALSE</code>,
i.e. only actual observations are included.</p>
</td></tr>
<tr><td><code id="mc_to_sc_data_+3A_cpal">cpal</code></td>
<td>
<p>The color palette used for the new combined symbols. Optional in
a case where the number of symbols is less or equal to 200 (in which case
the <code>seqHMM::colorpalette</code> is used).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mc_to_sc">mc_to_sc</a></code> for transforming multichannel <code>hmm</code>
or <code>mhmm</code> objects into single-channel representations;
<code><a href="#topic+ssplot">ssplot</a></code> for plotting multiple sequence data sets in the
same plot; and <code><a href="#topic+seqdef">seqdef</a></code> for creating state sequence objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load three-channel sequence data
data("biofam3c")

# Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married,
  start = 15,
  alphabet = c("single", "married", "divorced")
)
child_seq &lt;- seqdef(biofam3c$children,
  start = 15,
  alphabet = c("childless", "children")
)
left_seq &lt;- seqdef(biofam3c$left,
  start = 15,
  alphabet = c("with parents", "left home")
)

# Define colors
attr(marr_seq, "cpal") &lt;- c("violetred2", "darkgoldenrod2", "darkmagenta")
attr(child_seq, "cpal") &lt;- c("darkseagreen1", "coral3")
attr(left_seq, "cpal") &lt;- c("lightblue", "red3")

# Converting multichannel data to single-channel data
sc_data &lt;- mc_to_sc_data(list(marr_seq, child_seq, left_seq))

# 10 combined states
alphabet(sc_data)

# Colors for combined states
attr(sc_data, "cpal") &lt;- colorpalette[[14]][1:10]

# Plotting sequences for the first 10 subjects
ssplot(
  list(
    "Marriage" = marr_seq, "Parenthood" = child_seq,
    "Residence" = left_seq, "Combined" = sc_data
  ),
  type = "I",
  tlim = 1:10
)


# Including all combinations (whether or not available in data)
sc_data_all &lt;- mc_to_sc_data(list(marr_seq, child_seq, left_seq),
  all_combinations = TRUE
)

# 12 combined states, 2 with no observations in data
seqstatf(sc_data_all)

</code></pre>

<hr>
<h2 id='mhmm_biofam'>Mixture hidden Markov model for the biofam data</h2><span id='topic+mhmm_biofam'></span>

<h3>Description</h3>

<p>A mixture hidden Markov model (MHMM) fitted for the <code><a href="TraMineR.html#topic+biofam">biofam</a></code> data.
</p>


<h3>Format</h3>

<p>A mixture hidden Markov model of class <code>mhmm</code>:
three clusters with left-to-right models including 4, 4, and 6 hidden states.
Two covariates, <code>sex</code> and <code>cohort</code>, explaining the cluster membership.
</p>


<h3>Details</h3>

<p>The model was created with the  following code:
</p>
<pre>
data("biofam3c")

## Building sequence objects
marr_seq &lt;- seqdef(biofam3c$married, start = 15,
  alphabet = c("single", "married", "divorced"))
child_seq &lt;- seqdef(biofam3c$children, start = 15,
  alphabet = c("childless", "children"))
left_seq &lt;- seqdef(biofam3c$left, start = 15,
  alphabet = c("with parents", "left home"))

## Choosing colors
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")

## Starting values for emission probabilities
# Cluster 1
B1_marr &lt;- matrix(
  c(0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.3, 0.6, 0.1, # High probability for married
    0.3, 0.3, 0.4), # High probability for divorced
  nrow = 4, ncol = 3, byrow = TRUE)

B1_child &lt;- matrix(
  c(0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.9, 0.1),
  nrow = 4, ncol = 2, byrow = TRUE)

B1_left &lt;- matrix(
  c(0.9, 0.1, # High probability for living with parents
    0.1, 0.9, # High probability for having left home
    0.1, 0.9,
    0.1, 0.9),
  nrow = 4, ncol = 2, byrow = TRUE)

# Cluster 2

B2_marr &lt;- matrix(
  c(0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.7, 0.2, 0.1),
  nrow = 4, ncol = 3, byrow = TRUE)

B2_child &lt;- matrix(
  c(0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.9, 0.1,
    0.1, 0.9),
  nrow = 4, ncol = 2, byrow = TRUE)

B2_left &lt;- matrix(
  c(0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.1, 0.9,
    0.1, 0.9),
  nrow = 4, ncol = 2, byrow = TRUE)

# Cluster 3
B3_marr &lt;- matrix(
  c(0.8, 0.1, 0.1, # High probability for single
    0.8, 0.1, 0.1,
    0.8, 0.1, 0.1,
    0.1, 0.8, 0.1, # High probability for married
    0.3, 0.4, 0.3,
    0.1, 0.1, 0.8), # High probability for divorced
  nrow = 6, ncol = 3, byrow = TRUE)

B3_child &lt;- matrix(
  c(0.9, 0.1, # High probability for childless
    0.9, 0.1,
    0.5, 0.5,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9),
  nrow = 6, ncol = 2, byrow = TRUE)


B3_left &lt;- matrix(
  c(0.9, 0.1, # High probability for living with parents
    0.1, 0.9,
    0.5, 0.5,
    0.5, 0.5,
    0.1, 0.9,
    0.1, 0.9),
  nrow = 6, ncol = 2, byrow = TRUE)

# Starting values for transition matrices
A1 &lt;- matrix(
  c(0.80, 0.16, 0.03, 0.01,
    0,    0.90, 0.07, 0.03,
    0,    0,    0.90, 0.10,
    0,    0,    0,       1),
  nrow = 4, ncol = 4, byrow = TRUE)

A2 &lt;- matrix(
  c(0.80, 0.10, 0.05, 0.03, 0.01, 0.01,
    0,    0.70, 0.10, 0.10, 0.05, 0.05,
    0,    0,    0.85, 0.01, 0.10, 0.04,
    0,    0,    0,    0.90, 0.05, 0.05,
    0,    0,    0,    0,    0.90, 0.10,
    0,    0,    0,    0,    0,       1),
  nrow = 6, ncol = 6, byrow = TRUE)

# Starting values for initial state probabilities
initial_probs1 &lt;- c(0.9, 0.07, 0.02, 0.01)
initial_probs2 &lt;- c(0.9, 0.04, 0.03, 0.01, 0.01, 0.01)

# Birth cohort
biofam3c$covariates$cohort &lt;- factor(cut(biofam3c$covariates$birthyr,
    c(1908, 1935, 1945, 1957)), labels = c("1909-1935", "1936-1945", "1946-1957"))

# Build mixture HMM
init_mhmm_bf &lt;- build_mhmm(
  observations = list(marr_seq, child_seq, left_seq),
  initial_probs = list(initial_probs1, initial_probs1, initial_probs2),
  transition_probs = list(A1, A1, A2),
  emission_probs = list(list(B1_marr, B1_child, B1_left),
    list(B2_marr, B2_child, B2_left),
    list(B3_marr, B3_child, B3_left)),
  formula = ~sex + cohort, data = biofam3c$covariates,
  channel_names = c("Marriage", "Parenthood", "Residence"))

# Fitting the model
mhmm_biofam &lt;- fit_model(init_mhmm_bf)$model
</pre>


<h3>See Also</h3>

<p>Examples of building and fitting MHMMs in <code><a href="#topic+build_mhmm">build_mhmm</a></code> and
<code><a href="#topic+fit_model">fit_model</a></code>; and <code><a href="TraMineR.html#topic+biofam">biofam</a></code> for the original data and
<code><a href="#topic+biofam3c">biofam3c</a></code> for the three-channel version used in this model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mhmm_biofam")

# use conditional_se = FALSE for more accurate standard errors
# (these are considerebly slower to compute)
summary(mhmm_biofam$model)

if (interactive()) {
  # Plotting the model for each cluster (change with Enter)
  plot(mhmm_biofam)
}

</code></pre>

<hr>
<h2 id='mhmm_mvad'>Mixture hidden Markov model for the mvad data</h2><span id='topic+mhmm_mvad'></span>

<h3>Description</h3>

<p>A mixture hidden Markov model (MHMM) fitted for the <code><a href="TraMineR.html#topic+mvad">mvad</a></code> data.
</p>


<h3>Format</h3>

<p>A mixture hidden Markov model of class <code>mhmm</code>:
two clusters including 3 and 4 hidden states.
No covariates.
</p>


<h3>Details</h3>

<p>The model is loaded by calling <code>data(mhmm_mvad)</code>. It was created with the
following code:
</p>
<pre>
data("mvad", package = "TraMineR")

mvad_alphabet &lt;-
  c("employment", "FE", "HE", "joblessness", "school", "training")
mvad_labels &lt;- c("employment", "further education", "higher education",
  "joblessness", "school", "training")
mvad_scodes &lt;- c("EM", "FE", "HE", "JL", "SC", "TR")
mvad_seq &lt;- seqdef(mvad, 17:86, alphabet = mvad_alphabet,
  states = mvad_scodes, labels = mvad_labels, xtstep = 6)

attr(mvad_seq, "cpal") &lt;- colorpalette[[6]]

# Starting values for the emission matrices
emiss_1 &lt;- matrix(
  c(0.01, 0.01, 0.01, 0.01, 0.01, 0.95,
    0.95, 0.01, 0.01, 0.01, 0.01, 0.01,
    0.01, 0.01, 0.01, 0.95, 0.01, 0.01),
  nrow = 3, ncol = 6, byrow = TRUE)

emiss_2 &lt;- matrix(
  c(0.01, 0.01, 0.01, 0.06, 0.90, 0.01,
    0.01, 0.95, 0.01, 0.01, 0.01, 0.01,
    0.01, 0.01, 0.95, 0.01, 0.01, 0.01,
    0.95, 0.01, 0.01, 0.01, 0.01, 0.01),
  nrow = 4, ncol = 6, byrow = TRUE)

# Starting values for the transition matrix

trans_1 &lt;-  matrix(
  c(0.95, 0.03, 0.02,
    0.01, 0.98, 0.01,
    0.01, 0.01, 0.98),
  nrow = 3, ncol = 3, byrow = TRUE)

trans_2 &lt;-  matrix(
  c(0.97, 0.01, 0.01, 0.01,
    0.01, 0.97, 0.01, 0.01,
    0.01, 0.01, 0.97, 0.01,
    0.01, 0.01, 0.01, 0.97),
  nrow = 4, ncol = 4, byrow = TRUE)

# Starting values for initial state probabilities
initial_probs_1 &lt;- c(0.5, 0.25, 0.25)
initial_probs_2 &lt;- c(0.4, 0.4, 0.1, 0.1)

# Building a hidden Markov model with starting values
init_mhmm_mvad &lt;- build_mhmm(observations = mvad_seq,
  transition_probs = list(trans_1, trans_2),
  emission_probs = list(emiss_1, emiss_2),
  initial_probs = list(initial_probs_1, initial_probs_2))

# Fit the model
set.seed(123)
mhmm_mvad &lt;- fit_model(init_mhmm_mvad, control_em = list(restart = list(times = 25)))$model

</pre>


<h3>See Also</h3>

<p>Examples of building and fitting MHMMs in <code><a href="#topic+build_mhmm">build_mhmm</a></code> and
<code><a href="#topic+fit_model">fit_model</a></code>; and <code><a href="TraMineR.html#topic+mvad">mvad</a></code> for more information on the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mhmm_mvad")

summary(mhmm_mvad)

if (interactive()) {
  # Plotting the model for each cluster (change with Enter)
  plot(mhmm_mvad)
}

</code></pre>

<hr>
<h2 id='mssplot'>Interactive Stacked Plots of Multichannel Sequences and/or Most Probable
Paths for Mixture Hidden Markov Models</h2><span id='topic+mssplot'></span>

<h3>Description</h3>

<p>Function <code>mssplot</code> plots stacked sequence plots of observation sequences
and/or most probable hidden state paths for each model of the <code>mhmm</code>
object (model chosen according to the most probable path).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mssplot(
  x,
  ask = FALSE,
  which.plots = NULL,
  hidden.paths = NULL,
  plots = "obs",
  type = "d",
  tlim = 0,
  sortv = NULL,
  sort.channel = 1,
  dist.method = "OM",
  with.missing = FALSE,
  missing.color = NULL,
  title = NA,
  title.n = TRUE,
  cex.title = 1,
  title.pos = 1,
  with.legend = "auto",
  ncol.legend = "auto",
  with.missing.legend = "auto",
  legend.prop = 0.3,
  cex.legend = 1,
  hidden.states.colors = "auto",
  hidden.states.labels = "auto",
  xaxis = TRUE,
  xlab = NA,
  xtlab = NULL,
  xlab.pos = 1,
  ylab = "auto",
  hidden.states.title = "Hidden states",
  yaxis = FALSE,
  ylab.pos = "auto",
  cex.lab = 1,
  cex.axis = 1,
  respect_void = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mssplot_+3A_x">x</code></td>
<td>
<p>Mixture hidden Markov model object of class <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code> and <code>which.plots</code> is NULL, <code>plot.mhmm</code> operates in interactive mode, via <code><a href="utils.html#topic+menu">menu</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_which.plots">which.plots</code></td>
<td>
<p>The number(s) of the requested model(s) as an integer vector. The default <code>NULL</code> produces all plots.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_hidden.paths">hidden.paths</code></td>
<td>
<p>Output from the <code><a href="#topic+hidden_paths">hidden_paths</a></code> function. The
default value <code>NULL</code> computes hidden paths automatically, if needed.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_plots">plots</code></td>
<td>
<p>What to plot. One of <code>"obs"</code> for observations (the default),
<code>"hidden.paths"</code> for most probable paths of hidden states,
or <code>"both"</code> for observations and hidden paths together.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_type">type</code></td>
<td>
<p>The type of the plot. Available types are <code>"I"</code> for index
plots and <code>"d"</code> for state distribution plots (the default). See
<code><a href="HH.html#topic+seqplot">seqplot</a></code> for details.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_tlim">tlim</code></td>
<td>
<p>Indexes of the subjects to be plotted (the default is 0,
i.e. all subjects are plotted). For example, <code>tlim = 1:10</code> plots
the first ten subjects in data.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_sortv">sortv</code></td>
<td>
<p>A sorting variable or a sort method (one of <code>"from.start"</code>,
<code>"from.end"</code>, <code>"mds.obs"</code>, or <code>"mds.hidden"</code>) for
<code>type = "I"</code>. The value <code>"mds.hidden"</code> is only available when
<code>which = "both"</code> and <code>which = "hidden.paths"</code>. Options <code>"mds.obs"</code> and
<code>"mds.hidden"</code> automatically arrange the sequences according to the
scores of multidimensional scaling (using <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) for the
observed data or hidden states paths.
MDS scores are computed from distances/dissimilarities using a metric
defined in argument <code>dist.method</code>. See <code>plot.stslist</code> for
more details on <code>"from.start"</code> and <code>"from.end"</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_sort.channel">sort.channel</code></td>
<td>
<p>The number of the channel according to which the
<code>"from.start"</code> or <code>"from.end"</code> sorting is done. Sorting according
to hidden states is called with value 0. The default value is 1 (the first
channel).</p>
</td></tr>
<tr><td><code id="mssplot_+3A_dist.method">dist.method</code></td>
<td>
<p>The metric to be used for computing the distances of the
sequences if multidimensional scaling is used for sorting. One of &quot;OM&quot;
(optimal matching, the default), &quot;LCP&quot; (longest common prefix), &quot;RLCP&quot;
(reversed LCP, i.e. longest common suffix), &quot;LCS&quot; (longest common
subsequence), &quot;HAM&quot; (Hamming distance), and &quot;DHD&quot; (dynamic Hamming distance).
Transition rates are used for defining substitution costs if needed. See
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> for more information on the metrics.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_with.missing">with.missing</code></td>
<td>
<p>Controls whether missing states are included in state
distribution plots (<code>type = "d"</code>). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_missing.color">missing.color</code></td>
<td>
<p>Alternative color for representing missing values
in the sequences. By default, this color is taken from the <code>missing.color</code>
attribute of the sequence object.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_title">title</code></td>
<td>
<p>A vector of main titles for the graphics. The default is <code>NA</code>: if
<code>title.n = TRUE</code>, the name of the cluster and the number of subjects is plotted.
<code>FALSE</code> prints no titles, even when <code>title.n = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_title.n">title.n</code></td>
<td>
<p>Controls whether the number of subjects is printed in the main
titles of the plots. The default is <code>TRUE</code>: n is plotted if <code>title</code>
is anything but <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_cex.title">cex.title</code></td>
<td>
<p>Expansion factor for setting the size of the font for the main
titles. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_title.pos">title.pos</code></td>
<td>
<p>Controls the position of the main titles of the plots. The
default value is 1. Values greater than 1 will place the title higher.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and where the legend for the states is plotted.
The default value <code>"auto"</code> (equivalent to <code>TRUE</code> and
<code>"right"</code>) creates separate legends for each requested plot and
positiones them on the right-hand side of the plot. Other possible values
are <code>"bottom"</code>,
<code>"right.combined"</code>, and <code>"bottom.combined"</code>, of which the last
two create a combined legend in the selected position. <code>FALSE</code> prints no legend.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>(A vector of) the number of columns for the legend(s). The
default <code>"auto"</code> creates one column for each legend.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_with.missing.legend">with.missing.legend</code></td>
<td>
<p>If set to <code>"auto"</code> (the default), a legend
for the missing state is added automatically if one or more of the
sequences in the data/channel contains missing states and <code>type = "I"</code>.
If <code>type = "d"</code> missing states are omitted from the legends unless
<code>with.missing = TRUE</code>. With the value <code>TRUE</code> a
legend for the missing state is added in any case; equivalently
<code>FALSE</code> omits the legend for the missing state.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Sets the proportion of the graphic area used for plotting
the legend when <code>with.legend</code> is not <code>FALSE</code>. The default value is
0.3. Takes values from 0 to 1.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_hidden.states.colors">hidden.states.colors</code></td>
<td>
<p>A vector of colors assigned to hidden states. The default
value <code>"auto"</code> uses the colors assigned to the <code>stslist</code> object (created
with <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) if <code>hidden.paths</code> is given; otherwise colors from
<code><a href="#topic+colorpalette">colorpalette</a></code> are automatically used.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_hidden.states.labels">hidden.states.labels</code></td>
<td>
<p>Labels for the hidden states. The default value
<code>"auto"</code> uses the names provided in <code>x$state_names</code> if <code>x</code> is
an <code>hmm</code> object; otherwise the number of the hidden state.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_xaxis">xaxis</code></td>
<td>
<p>Controls whether an x-axis is plotted below the plot at the
bottom. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_xlab">xlab</code></td>
<td>
<p>An optional label for the x-axis. If set to <code>NA</code>, no label
is drawn.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_xtlab">xtlab</code></td>
<td>
<p>Optional labels for the x-axis tick labels.  If unspecified, the
column names of the <code>seqdata</code> sequence object are used (see
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="mssplot_+3A_xlab.pos">xlab.pos</code></td>
<td>
<p>Controls the position of the x-axis label. The default value
is 1. Values greater than 1 will place the label further away from the plot.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the channels shown as labels for y-axes.
A vector of names for each channel
(observations). The default value <code>"auto"</code> uses the names provided in
<code>x$channel_names</code> if <code>x</code> is an <code>hmm</code> object; otherwise the
names of the list in <code>x</code> if given, or the
number of the channel if names are not given. <code>FALSE</code> prints no labels.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_hidden.states.title">hidden.states.title</code></td>
<td>
<p>Optional label for the hidden state plot (in the
y-axis). The default is <code>"Hidden states"</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_yaxis">yaxis</code></td>
<td>
<p>Controls whether or not to plot the y-axis. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_ylab.pos">ylab.pos</code></td>
<td>
<p>Controls the position of the y axis labels (labels for
channels and/or hidden states). Either <code>"auto"</code> or a numerical vector
indicating how far away from the plots the titles are positioned. The
default value <code>"auto"</code> positions all titles on line 1.
Shorter vectors are recycled.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Expansion factor for setting the size of the font for the axis
labels. The default value is 1. Values lesser than 1 will reduce the size
of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Expansion factor for setting the size of the font for the x-axis
tick labels. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_respect_void">respect_void</code></td>
<td>
<p>If <code>TRUE</code> (default), states at the time points
corresponding to TraMineR's void in the observed sequences are set to void
in the hidden state sequences as well.</p>
</td></tr>
<tr><td><code id="mssplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to
<code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting mixture hidden Markov models, <code><a href="#topic+hidden_paths">hidden_paths</a></code> for
computing the most probable paths (Viterbi paths) of hidden states,
<code><a href="#topic+plot.mhmm">plot.mhmm</a></code> for plotting <code>mhmm</code> objects as directed graphs, and
<code><a href="#topic+colorpalette">colorpalette</a></code> for default colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading mixture hidden Markov model (mhmm object)
# of the biofam data
data("mhmm_biofam")

# Plotting the first cluster only
mssplot(mhmm_biofam, which.plots = 1)

if (interactive()) {
  # Interactive plot
  mssplot(mhmm_biofam)
}

</code></pre>

<hr>
<h2 id='plot_colors'>Plot Colorpalettes</h2><span id='topic+plot_colors'></span>

<h3>Description</h3>

<p>Function <code>plot_colors</code> plots colors and their labels for easy
visualization of a colorpalette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_colors(x, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_colors_+3A_x">x</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
<tr><td><code id="plot_colors_+3A_labels">labels</code></td>
<td>
<p>A vector of labels for colors. If omitted, given color names are used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See e.g. the <code><a href="#topic+colorpalette">colorpalette</a></code> data and <code>RColorBrewer</code>
package for ready-made color palettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_colors(colorpalette[[5]], labels = c("one", "two", "three", "four", "five"))

plot_colors(colorpalette[[10]])

plot_colors(1:7)

plot_colors(c("yellow", "orange", "red", "purple", "blue", "green"))

plot_colors(rainbow(15))
</code></pre>

<hr>
<h2 id='plot.hmm'>Plot hidden Markov models</h2><span id='topic+plot.hmm'></span>

<h3>Description</h3>

<p>Function <code>plot.hmm</code> plots a directed graph with pie charts of
emission probabilities as vertices/nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm'
plot(
  x,
  layout = "horizontal",
  pie = TRUE,
  vertex.size = 40,
  vertex.label = "initial.probs",
  vertex.label.dist = "auto",
  vertex.label.pos = "bottom",
  vertex.label.family = "sans",
  loops = FALSE,
  edge.curved = TRUE,
  edge.label = "auto",
  edge.width = "auto",
  cex.edge.width = 1,
  edge.arrow.size = 1.5,
  edge.label.family = "sans",
  label.signif = 2,
  label.scientific = FALSE,
  label.max.length = 6,
  trim = 1e-15,
  combine.slices = 0.05,
  combined.slice.color = "white",
  combined.slice.label = "others",
  with.legend = "bottom",
  ltext = NULL,
  legend.prop = 0.5,
  cex.legend = 1,
  ncol.legend = "auto",
  cpal = "auto",
  cpal.legend = "auto",
  legend.order = TRUE,
  main = NULL,
  withlegend,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hmm_+3A_x">x</code></td>
<td>
<p>A hidden Markov model object of class <code>hmm</code> created with
<code><a href="#topic+build_hmm">build_hmm</a></code> (or <code><a href="#topic+build_mm">build_mm</a></code>). Multichannel
<code>hmm</code> objects are automatically transformed into single-channel objects.
See function <code><a href="#topic+mc_to_sc">mc_to_sc</a></code> for more information on the
transformation.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_layout">layout</code></td>
<td>
<p>specifies the layout of vertices (nodes). Accepts a
numerical matrix, a <code><a href="igraph.html#topic+layout_">layout_</a></code> function (without quotation marks),
or either of the predefined options <code>"horizontal"</code> (the
default) and <code>"vertical"</code>. Options <code>"horizontal"</code> and
<code>"vertical"</code> position vertices at the same horizontal or vertical
line. A two-column numerical matrix can be used to give x and y coordinates of
the vertices. The <code><a href="igraph.html#topic+layout_">layout_</a></code> functions available in the
<code>igraph</code> package offer other automatic layouts for graphs.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_pie">pie</code></td>
<td>
<p>Are vertices plotted as pie charts of emission probabilities?
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Size of vertices, given as a scalar or numerical
vector. The default value is 40.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_vertex.label">vertex.label</code></td>
<td>
<p>Labels for vertices. Possible options include
<code>"initial.probs"</code>, <code>"names"</code>, <code>NA</code>, and a character or
numerical vector. The default <code>"initial.probs"</code> prints the initial
probabilities of the model and <code>"names"</code> prints the names of the
hidden states as labels. <code>NA</code> prints no labels.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>Distance of the label of the vertex from its
center. The default value <code>"auto"</code> places the label outside the
vertex.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_vertex.label.pos">vertex.label.pos</code></td>
<td>
<p>Positions of vertex labels, relative to
the center of the vertex. A scalar or numerical vector giving
position(s) as radians or one of <code>"bottom"</code> (<code>pi/2</code> as radians),
<code>"top"</code> (<code>-pi/2</code>), <code>"left"</code> (<code>pi</code>), or
<code>"right"</code> (<code>0</code>).</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_vertex.label.family">vertex.label.family</code>, <code id="plot.hmm_+3A_edge.label.family">edge.label.family</code></td>
<td>
<p>Font family to be used for
vertex/edge labels. See argument <code>family</code> in <code><a href="graphics.html#topic+par">par</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_loops">loops</code></td>
<td>
<p>Defines whether transitions back to same states are plotted.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_edge.curved">edge.curved</code></td>
<td>
<p>Defines whether to plot curved edges (arcs, arrows)
between vertices. A logical or numerical vector or scalar. Numerical
values specify curvatures of edges. The default value <code>TRUE</code>
gives curvature of 0.5 to all edges. See <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_edge.label">edge.label</code></td>
<td>
<p>Labels for edges. Possible options include
<code>"auto"</code>, <code>NA</code>, and a character or numerical vector. The
default <code>"auto"</code> prints transition probabilities as edge labels.
<code>NA</code> prints no labels.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_edge.width">edge.width</code></td>
<td>
<p>Width(s) for edges. The default <code>"auto"</code> determines
widths according to transition probabilities between hidden states.
Other possibilities are a scalar or a numerical vector of widths.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_cex.edge.width">cex.edge.width</code></td>
<td>
<p>An expansion factor for edge widths. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>Size of the arrow in edges (constant). Defaults to 1.5.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_label.signif">label.signif</code></td>
<td>
<p>Rounds labels of model parameters to specified number
of significant digits, 2 by default. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_label.scientific">label.scientific</code></td>
<td>
<p>Defines if scientific notation should be used to
describe small numbers. Defaults to <code>FALSE</code>, e.g. 0.0001 instead of
1e-04. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_label.max.length">label.max.length</code></td>
<td>
<p>Maximum number of digits in labels of model
parameters. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_trim">trim</code></td>
<td>
<p>Scalar between 0 and 1 giving the highest probability of
transitions that are plotted as edges, defaults to 1e-15.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_combine.slices">combine.slices</code></td>
<td>
<p>Scalar between 0 and 1 giving the highest probability
of emission probabilities that are combined into one state. The dafault
value is 0.05.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_combined.slice.color">combined.slice.color</code></td>
<td>
<p>Color of the combined slice that includes
the smallest emission probabilities (only if argument
<code>"combine.slices"</code> is greater than 0). The default color is white.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_combined.slice.label">combined.slice.label</code></td>
<td>
<p>The label for combined states (when argument
<code>"combine.slices"</code> is greater than 0) to appear in the legend.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and where the legend of state colors is
plotted. Possible values include <code>"bottom"</code> (the default),
<code>"top"</code>, <code>"left"</code>, and <code>"right"</code>. <code>FALSE</code> omits the
legend.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_ltext">ltext</code></td>
<td>
<p>Optional description of (combined) observed states to appear
in the legend. A vector of character strings.  See <code><a href="HH.html#topic+seqplot">seqplot</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Proportion used for plotting the legend. A scalar between
0 and 1, defaults to 0.5.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>The number of columns for the legend. The default value
<code>"auto"</code> sets the number of columns automatically.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_cpal">cpal</code></td>
<td>
<p>Optional color palette for (combinations of) observed states.
The default value <code>"auto"</code> uses automatic color palette. Otherwise a
vector of length <code>x$n_symbols</code> is given, i.e. the argument requires a color
specified for all (combinations of) observed states even if they are not
plotted (if the probability is less than <code>combine.slices</code>).</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_cpal.legend">cpal.legend</code></td>
<td>
<p>Optional color palette for the legend, only considered when
legend.order is FALSE. Should match ltext.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_legend.order">legend.order</code></td>
<td>
<p>Whether to use the default order in the legend, i.e., order by appearance
(first by hidden state, then by emission probability). TRUE by default.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_main">main</code></td>
<td>
<p>Main title for the plot. Omitted by default.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="plot.hmm_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> such as
<code>vertex.color</code>, <code>vertex.label.cex</code>, or <code>edge.lty</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting Hidden Markov models, <code><a href="#topic+mc_to_sc">mc_to_sc</a></code> for transforming
multistate <code>hmm</code> objects into single-channel objects,
<code><a href="#topic+hmm_biofam">hmm_biofam</a></code> and <code><a href="#topic+hmm_mvad">hmm_mvad</a></code> for information on the models
used in the examples, and
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> for the general plotting function of directed graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multichannel data, left-to-right model

# Loading a HMM of the biofam data
data("hmm_biofam")

# Plotting hmm object
plot(hmm_biofam)

# Plotting HMM with
plot(hmm_biofam,
  # varying curvature of edges
  edge.curved = c(0, -0.7, 0.6, 0.7, 0, -0.7, 0),
  # legend with two columns and less space
  ncol.legend = 2, legend.prop = 0.4,
  # new label for combined slice
  combined.slice.label = "States with probability &lt; 0.05"
)

# Plotting HMM with given coordinates
plot(hmm_biofam,
  # layout given in 2x5 matrix
  # x coordinates in the first column
  # y coordinates in the second column
  layout = matrix(c(
    1, 3, 3, 5, 3,
    0, 0, 1, 0, -1
  ), ncol = 2),
  # larger vertices
  vertex.size = 50,
  # straight edges
  edge.curved = FALSE,
  # thinner edges and arrows
  cex.edge.width = 0.5, edge.arrow.size = 1,
  # varying positions for vertex labels (initial probabilities)
  vertex.label.pos = c(pi, pi / 2, -pi / 2, 0, pi / 2),
  # different legend properties
  with.legend = "top", legend.prop = 0.3, cex.legend = 1.1,
  # Fix axes to the right scale
  xlim = c(0.5, 5.5), ylim = c(-1.5, 1.5), rescale = FALSE,
  # all states (not combining states with small probabilities)
  combine.slices = 0,
  # legend with two columns
  ncol.legend = 2
)

# Plotting HMM with own color palette
plot(hmm_biofam,
  cpal = 1:10,
  # States with emission probability less than 0.2 removed
  combine.slices = 0.2,
  # legend with two columns
  ncol.legend = 2
)

# Plotting HMM without pie graph and with a layout function
require("igraph")
# Setting the seed for a random layout
set.seed(1234)
plot(hmm_biofam,
  # Without pie graph
  pie = FALSE,
  # Using an automatic layout function from igraph
  layout = layout_nicely,
  vertex.size = 30,
  # Straight edges and probabilities of moving to the same state
  edge.curved = FALSE, loops = TRUE,
  # Labels with three significant digits
  label.signif = 3,
  # Fixed edge width
  edge.width = 1,
  # Remove edges with probability less than 0.01
  trim = 0.01,
  # Hidden state names as vertex labels
  vertex.label = "names",
  # Labels insidde vertices
  vertex.label.dist = 0,
  # Fix x-axis (more space on the right-hand side)
  xlim = c(-1, 1.3)
)


# Single-channel data, unrestricted model

# Loading a hidden Markov model of the mvad data (hmm object)
data("hmm_mvad")

# Plotting the HMM
plot(hmm_mvad)

# Checking the order of observed states (needed for the next call)
require(TraMineR)
alphabet(hmm_mvad$observations)

# Plotting the HMM with own legend (note: observation "none" nonexistent in the observations)
plot(hmm_mvad,
  # Override the default order in the legend
  legend.order = FALSE,
  # Colours in the pies (ordered by the alphabet of observations)
  cpal = c("purple", "pink", "brown", "lightblue", "orange", "green"),
  # Colours in the legend (matching to ltext)
  cpal.legend = c("orange", "pink", "brown", "green", "lightblue", "purple", "gray"),
  # Labels in the legend (matching to cpal.legend)
  ltext = c("school", "further educ", "higher educ", "training", "jobless", "employed", "none")
)

require("igraph")
plot(hmm_mvad,
  # Layout in circle (layout function from igraph)
  layout = layout_in_circle,
  # Less curved edges with smaller arrows, no labels
  edge.curved = 0.2, edge.arrow.size = 0.9, edge.label = NA,
  # Positioning vertex labels (initial probabilities)
  vertex.label.pos = c("right", "right", "left", "left", "right"),
  # Less space for the legend
  legend.prop = 0.3
)
</code></pre>

<hr>
<h2 id='plot.mhmm'>Interactive Plotting for Mixed Hidden Markov Model (mhmm)</h2><span id='topic+plot.mhmm'></span>

<h3>Description</h3>

<p>Function <code>plot.mhmm</code> plots a directed graph of the parameters of each model
with pie charts of emission probabilities as vertices/nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mhmm'
plot(
  x,
  interactive = TRUE,
  ask = FALSE,
  which.plots = NULL,
  nrow = NA,
  ncol = NA,
  byrow = FALSE,
  row.prop = "auto",
  col.prop = "auto",
  layout = "horizontal",
  pie = TRUE,
  vertex.size = 40,
  vertex.label = "initial.probs",
  vertex.label.dist = "auto",
  vertex.label.pos = "bottom",
  vertex.label.family = "sans",
  loops = FALSE,
  edge.curved = TRUE,
  edge.label = "auto",
  edge.width = "auto",
  cex.edge.width = 1,
  edge.arrow.size = 1.5,
  edge.label.family = "sans",
  label.signif = 2,
  label.scientific = FALSE,
  label.max.length = 6,
  trim = 1e-15,
  combine.slices = 0.05,
  combined.slice.color = "white",
  combined.slice.label = "others",
  with.legend = "bottom",
  ltext = NULL,
  legend.prop = 0.5,
  cex.legend = 1,
  ncol.legend = "auto",
  cpal = "auto",
  main = "auto",
  withlegend,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mhmm_+3A_x">x</code></td>
<td>
<p>A hidden Markov model object of class <code>mhmm</code> created with
<code><a href="#topic+build_mhmm">build_mhmm</a></code> (or <code><a href="#topic+build_mmm">build_mmm</a></code> or
<code><a href="#topic+build_lcm">build_lcm</a></code>). Multichannel
<code>mhmm</code> objects are automatically transformed into single-channel objects.
See function <code><a href="#topic+mc_to_sc">mc_to_sc</a></code> for more information on the
transformation.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_interactive">interactive</code></td>
<td>
<p>Whether to plot each cluster in succession or in a grid.
Defaults to <code>TRUE</code>, i.e. clusters are plotted one after another.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code> and <code>which.plots</code> is NULL,
<code>plot.mhmm</code> operates in interactive mode, via <code><a href="utils.html#topic+menu">menu</a></code>.
Defaults to <code>FALSE</code>. Ignored if <code>interactive = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_which.plots">which.plots</code></td>
<td>
<p>The number(s) of the requested cluster(s) as an integer
vector. The default <code>NULL</code> produces all plots.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_nrow">nrow</code>, <code id="plot.mhmm_+3A_ncol">ncol</code></td>
<td>
<p>Optional arguments to arrange plots in a grid. Ignored if
<code>interactive = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_byrow">byrow</code></td>
<td>
<p>Controls the order of plotting in a grid. Defaults to <code>FALSE</code>,
i.e. plots are arranged column-wise. Ignored if <code>interactive = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_row.prop">row.prop</code></td>
<td>
<p>Sets the proportions of the row heights of the grid. The default
value is <code>"auto"</code> for even row heights. Takes a vector of values from
0 to 1, with values summing to 1. Ignored if <code>interactive = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_col.prop">col.prop</code></td>
<td>
<p>Sets the proportion of the column heights of the grid. The default
value is <code>"auto"</code> for even column widths. Takes a vector of values
from 0 to 1, with values summing to 1. Ignored if <code>interactive = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_layout">layout</code></td>
<td>
<p>specifies the layout of vertices (nodes). Accepts a
numerical matrix, a <code><a href="igraph.html#topic+layout_">layout_</a></code> function (without quotation marks),
or either of the predefined options <code>"horizontal"</code> (the
default) and <code>"vertical"</code>. Options <code>"horizontal"</code> and
<code>"vertical"</code> position vertices at the same horizontal or vertical
line. A two-column numerical matrix can be used to give x and y coordinates of
the vertices. The <code><a href="igraph.html#topic+layout_">layout_</a></code> functions available in the
<code>igraph</code> package offer other automatic layouts for graphs.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_pie">pie</code></td>
<td>
<p>Are vertices plotted as pie charts of emission probabilities?
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Size of vertices, given as a scalar or numerical
vector. The default value is 40.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_vertex.label">vertex.label</code></td>
<td>
<p>Labels for vertices. Possible options include
<code>"initial.probs"</code>, <code>"names"</code>, <code>NA</code>, and a character or
numerical vector. The default <code>"initial.probs"</code> prints the initial
probabilities of the model and <code>"names"</code> prints the names of the
hidden states as labels. <code>NA</code> prints no labels.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>Distance of the label of the vertex from its
center. The default value <code>"auto"</code> places the label outside the
vertex.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_vertex.label.pos">vertex.label.pos</code></td>
<td>
<p>Positions of vertex labels, relative to
the center of the vertex. A scalar or numerical vector giving
position(s) as radians or one of <code>"bottom"</code> (<code>pi/2</code> as radians),
<code>"top"</code> (<code>-pi/2</code>), <code>"left"</code> (<code>pi</code>), or
<code>"right"</code> (<code>0</code>).</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_vertex.label.family">vertex.label.family</code>, <code id="plot.mhmm_+3A_edge.label.family">edge.label.family</code></td>
<td>
<p>Font family to be used for
vertex/edge labels. See argument <code>family</code> in <code><a href="graphics.html#topic+par">par</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_loops">loops</code></td>
<td>
<p>Defines whether transitions back to same states are plotted.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_edge.curved">edge.curved</code></td>
<td>
<p>Defines whether to plot curved edges (arcs, arrows)
between vertices. A logical or numerical vector or scalar. Numerical
values specify curvatures of edges. The default value <code>TRUE</code>
gives curvature of 0.5 to all edges. See <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_edge.label">edge.label</code></td>
<td>
<p>Labels for edges. Possible options include
<code>"auto"</code>, <code>NA</code>, and a character or numerical vector. The
default <code>"auto"</code> prints transition probabilities as edge labels.
<code>NA</code> prints no labels.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_edge.width">edge.width</code></td>
<td>
<p>Width(s) for edges. The default <code>"auto"</code> determines
widths according to transition probabilities between hidden states.
Other possibilities are a scalar or a numerical vector of widths.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_cex.edge.width">cex.edge.width</code></td>
<td>
<p>An expansion factor for edge widths. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>Size of the arrow in edges (constant). Defaults to 1.5.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_label.signif">label.signif</code></td>
<td>
<p>Rounds labels of model parameters to specified number
of significant digits, 2 by default. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_label.scientific">label.scientific</code></td>
<td>
<p>Defines if scientific notation should be used to
describe small numbers. Defaults to <code>FALSE</code>, e.g. 0.0001 instead of
1e-04. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_label.max.length">label.max.length</code></td>
<td>
<p>Maximum number of digits in labels of model
parameters. Ignored for user-given labels.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_trim">trim</code></td>
<td>
<p>Scalar between 0 and 1 giving the highest probability of
transitions that are plotted as edges, defaults to 1e-15.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_combine.slices">combine.slices</code></td>
<td>
<p>Scalar between 0 and 1 giving the highest probability
of emission probabilities that are combined into one state. The dafault
value is 0.05.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_combined.slice.color">combined.slice.color</code></td>
<td>
<p>Color of the combined slice that includes
the smallest emission probabilities (only if argument
<code>"combine.slices"</code> is greater than 0). The default color is white.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_combined.slice.label">combined.slice.label</code></td>
<td>
<p>The label for combined states (when argument
<code>"combine.slices"</code> is greater than 0) to appear in the legend.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and where the legend of state colors is
plotted. Possible values include <code>"bottom"</code> (the default),
<code>"top"</code>, <code>"left"</code>, and <code>"right"</code>. <code>FALSE</code> omits the
legend.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_ltext">ltext</code></td>
<td>
<p>Optional description of (combined) observed states to appear
in the legend. A vector of character strings. See <code><a href="HH.html#topic+seqplot">seqplot</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Proportion used for plotting the legend. A scalar between
0 and 1, defaults to 0.5.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>The number of columns for the legend. The default value
<code>"auto"</code> sets the number of columns automatically.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_cpal">cpal</code></td>
<td>
<p>Optional color palette for (combinations of) observed states.
The default value <code>"auto"</code> uses automatic color palette. Otherwise a
vector of length <code>x$n_symbols</code> is given, i.e. the argument requires a color
specified for all (combinations of) observed states even if they are not
plotted (if the probability is less than <code>combine.slices</code>).</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_main">main</code></td>
<td>
<p>Optional main titles for plots. The default <code>"auto"</code> uses
<code>cluster_names</code> as titles, <code>NULL</code> prints no titles.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="plot.mhmm_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> such as
<code>vertex.color</code>, <code>vertex.label.cex</code>, or <code>edge.lty</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Helske S. and Helske J. (2019). Mixture Hidden Markov Models for Sequence Data: The seqHMM Package in R,
Journal of Statistical Software, 88(3), 1-32. doi:10.18637/jss.v088.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting mixture hidden Markov models; <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> for plotting
directed graphs; and <code><a href="#topic+mhmm_biofam">mhmm_biofam</a></code> and <code><a href="#topic+mhmm_mvad">mhmm_mvad</a></code> for
the models used in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading mixture hidden Markov model (mhmm object)
# of the biofam data
data("mhmm_biofam")

# Plotting only the first cluster
plot(mhmm_biofam, which.plots = 1)

if (interactive()) {
  # Plotting each cluster (change with Enter)
  plot(mhmm_biofam)

  # Choosing the cluster (one at a time)
  plot(mhmm_biofam, ask = TRUE)

  # Loading MHMM of the mvad data
  data("mhmm_mvad")

  # Plotting models in the same graph (in a grid)
  # Note: the plotting window must be high enough!
  set.seed(123)
  plot(mhmm_mvad,
    interactive = FALSE,
    # automatic layout, legend on the right-hand side
    layout = layout_nicely, with.legend = "right",
    # Smaller and less curved edges
    edge.curved = 0.2, cex.edge.width = 0.5, edge.arrow.size = 0.7,
    vertex.label.pos = -4 * pi / 5, vertex.label.dist = 5
  )
}

</code></pre>

<hr>
<h2 id='plot.ssp'>Stack Multichannel Sequence Plots and/or Most Probable Paths Plots from Hidden Markov
Models</h2><span id='topic+plot.ssp'></span>

<h3>Description</h3>

<p>Function <code>plot.ssp</code> plots stacked sequence plots from <code>ssp</code> objects defined with
<code><a href="#topic+ssp">ssp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ssp_+3A_x">x</code></td>
<td>
<p>An <code>ssp</code> object.</p>
</td></tr>
<tr><td><code id="plot.ssp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Helske S. and Helske J. (2019). Mixture Hidden Markov Models for Sequence Data: The seqHMM Package in R,
Journal of Statistical Software, 88(3), 1-32. doi:10.18637/jss.v088.i03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssp">ssp</a></code> for more examples and information on defining the plot before using
<code>plot.ssp</code>; <code><a href="#topic+ssplot">ssplot</a></code> for straight plotting of <code>ssp</code> objects;
and <code><a href="#topic+gridplot">gridplot</a></code> for plotting multiple <code>ssp</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("biofam3c")

## Building sequence objects
child_seq &lt;- seqdef(biofam3c$children, start = 15)
marr_seq &lt;- seqdef(biofam3c$married, start = 15)
left_seq &lt;- seqdef(biofam3c$left, start = 15)

## Choosing colors
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")


# Plotting state distribution plots of observations
ssp1 &lt;- ssp(list(child_seq, marr_seq, left_seq))
plot(ssp1)
</code></pre>

<hr>
<h2 id='posterior_probs'>Posterior Probabilities for (Mixture) Hidden Markov Models</h2><span id='topic+posterior_probs'></span>

<h3>Description</h3>

<p>Function <code>posterior_probs</code> computes the posterior probabilities of hidden states of
a (mixture) hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_probs(model, log_space = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_probs_+3A_model">model</code></td>
<td>
<p>A (mixture) hidden Markov model of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="posterior_probs_+3A_log_space">log_space</code></td>
<td>
<p>Compute posterior probabilities in logarithmic scale. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Posterior probabilities. In case of multiple observations,
these are computed independentlsy for each sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a pre-defined MHMM
data("mhmm_biofam")

# Compute posterior probabilities
pb &lt;- posterior_probs(mhmm_biofam)

# Locally most probable states for the first subject:
pb[, , 1]
</code></pre>

<hr>
<h2 id='print.hmm'>Print Method for a Hidden Markov Model</h2><span id='topic+print.hmm'></span><span id='topic+print.mhmm'></span><span id='topic+print.summary.mhmm'></span>

<h3>Description</h3>

<p>Prints the parameters of a (mixture) hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hmm'
print(x, digits = 3, ...)

## S3 method for class 'mhmm'
print(x, digits = 3, ...)

## S3 method for class 'summary.mhmm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hmm_+3A_x">x</code></td>
<td>
<p>Hidden Markov model of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="print.hmm_+3A_digits">digits</code></td>
<td>
<p>Minimum number of significant digits to print.</p>
</td></tr>
<tr><td><code id="print.hmm_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>print.default</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting hidden Markov models.
</p>

<hr>
<h2 id='separate_mhmm'>Reorganize a mixture hidden Markov model to a list of separate hidden Markov models
(covariates ignored)</h2><span id='topic+separate_mhmm'></span>

<h3>Description</h3>

<p>The <code>separate_mhmm</code> function reorganizes the parameters of a <code>mhmm</code> object
into a list where each list component is an object of class <code>hmm</code> consisting of the
parameters of the corresponding cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_mhmm(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_mhmm_+3A_model">model</code></td>
<td>
<p>Mixture hidden Markov model of class <code>mhmm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components of class <code>hmm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code>
for building and fitting MHMMs; and <code><a href="#topic+mhmm_biofam">mhmm_biofam</a></code> for
more information on the model used in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading mixture hidden Markov model (mhmm object)
# of the biofam data
data("mhmm_biofam")

# Separate models for clusters
sep_hmm &lt;- separate_mhmm(mhmm_biofam)

# Plotting the model for the first cluster
plot(sep_hmm[[1]])
</code></pre>

<hr>
<h2 id='seqdef'>Imported Functions from <code>TraMineR</code></h2><span id='topic+seqdef'></span><span id='topic+seqstatf'></span><span id='topic+alphabet'></span>

<h3>Description</h3>

<p>Imported functions for convinience. For details, see
the corresponding help pages of <code><a href="TraMineR.html#topic+seqstatf">seqstatf</a></code>,
<code><a href="TraMineR.html#topic+alphabet">alphabet</a></code> and <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>.
</p>

<hr>
<h2 id='seqHMM'>The seqHMM package</h2><span id='topic+seqHMM'></span>

<h3>Description</h3>

<p>The seqHMM package is designed for fitting hidden (or latent) Markov models (HMMs) and
mixture hidden Markov models (MHMMs) for social sequence data and other categorical
time series. The package supports models for one or multiple subjects with one or
multiple interdependent sequences (channels). External covariates can be added to
explain cluster membership in mixture models. The package provides functions for evaluating
and comparing models, as well as functions for easy plotting of multichannel sequences
and hidden Markov models. Common restricted versions of (M)HMMs are also supported,
namely Markov models, mixture Markov models, and latent class models.
</p>


<h3>Details</h3>

<p>Maximum likelihood estimation via the EM algorithm and direct numerical maximization
with analytical gradients is supported. All main algorithms are written in C++.
Parallel computation is implemented via OpenMP.
</p>


<h3>References</h3>

<p>Helske S. and Helske J. (2019). Mixture Hidden Markov Models for Sequence Data: The seqHMM Package in R,
Journal of Statistical Software, 88(3), 1-32. doi:10.18637/jss.v088.i03
</p>

<hr>
<h2 id='seqHMM-deprecated'>Deprecated function(s) in the seqHMM package</h2><span id='topic+seqHMM-deprecated'></span><span id='topic+fit_hmm'></span><span id='topic+fit_mhmm'></span><span id='topic+trim_hmm'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older version of
the seqHMM package.  They will be eventually completely
removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hmm(
  model,
  em_step = TRUE,
  global_step = FALSE,
  local_step = FALSE,
  control_em = list(),
  control_global = list(),
  control_local = list(),
  lb,
  ub,
  threads = 1,
  log_space = FALSE,
  ...
)

fit_mhmm(
  model,
  em_step = TRUE,
  global_step = FALSE,
  local_step = FALSE,
  control_em = list(),
  control_global = list(),
  control_local = list(),
  lb,
  ub,
  threads = 1,
  log_space = FALSE,
  ...
)

trim_hmm(
  model,
  maxit = 0,
  return_loglik = FALSE,
  zerotol = 1e-08,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqHMM-deprecated_+3A_model">model</code></td>
<td>
<p>An object of class <code>hmm</code> or <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_em_step">em_step</code></td>
<td>
<p>Logical. Whether or not to use the EM algorithm at the start
of the parameter estimation. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_global_step">global_step</code></td>
<td>
<p>Logical. Whether or not to use global optimization via
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> (possibly after the EM step). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_local_step">local_step</code></td>
<td>
<p>Logical. Whether or not to use local optimization via
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> (possibly after the EM and/or global steps). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_control_em">control_em</code></td>
<td>
<p>Optional list of control parameters for the EM algorithm.
Possible arguments are </p>

<dl>
<dt>maxeval</dt><dd><p>The maximum number of iterations, the default is 1000.
Note that iteration counter starts with -1 so with <code>maxeval=1</code> you get already two iterations.
This is for backward compatibility reasons.</p>
</dd>
<dt>print_level</dt><dd><p>The level of printing. Possible values are 0
(prints nothing), 1 (prints information at the start and the end of the algorithm),
2 (prints at every iteration),
and for mixture models 3 (print also during optimization of coefficients).</p>
</dd>
<dt>reltol</dt><dd><p>Relative tolerance for convergence defined as
<code class="reqn">(logLik_new - logLik_old)/(abs(logLik_old) + 0.1)</code>.
The default is 1e-10.</p>
</dd>
<dt>restart</dt><dd><p>A list containing options for possible EM restarts with the
following components:
</p>

<dl>
<dt>times</dt><dd><p>Number of restarts of the EM algorithm using random initial values. The default is 0, i.e. no restarts. </p>
</dd>
<dt>transition</dt><dd><p>Logical. Should the original transition probabilities be varied? The default is <code>TRUE</code>. </p>
</dd>
<dt>emission</dt><dd><p>Logical. Should the original emission probabilities be varied? The default is <code>TRUE</code>. </p>
</dd>
<dt>sd</dt><dd><p>Standard deviation for <code>rnorm</code> used in randomization. The default is 0.25.</p>
</dd>
<dt>maxeval</dt><dd><p>Maximum number of iterations, the default is <code>control_em$maxeval</code></p>
</dd>
<dt>print_level</dt><dd><p>Level of printing in restarted EM steps. The default is <code>control_em$print_level</code>. </p>
</dd>
<dt>reltol</dt><dd><p>Relative tolerance for convergence at restarted EM steps. The default is <code>control_em$reltol</code>.
If the relative change of the final model of the restart phase is larger than the tolerance
for the original EM phase, the final model is re-estimated with the original <code>reltol</code>
and <code>maxeval</code> at the end of the EM step.</p>
</dd>
<dt>n_optimum</dt><dd><p>Save the log-likelihood values of the <code>n_optimum</code> best
models (from all estimated models including the the first EM run.).
The default is <code>min(times + 1, 25)</code>.</p>
</dd>
<dt>use_original</dt><dd><p>If <code>TRUE</code>. Use the initial values of the input model as starting
points for the permutations. Otherwise permute the results of the first EM run.</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_control_global">control_global</code></td>
<td>
<p>Optional list of additional arguments for
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> argument <code>opts</code>. The default values are
</p>

<dl>
<dt>algorithm</dt><dd><p><code>"NLOPT_GD_MLSL_LDS"</code></p>
</dd>
<dt>local_opts</dt><dd><p><code>list(algorithm = "NLOPT_LD_LBFGS", ftol_rel = 1e-6, xtol_rel = 1e-4)</code></p>
</dd>
<dt>maxeval</dt><dd><p><code>10000</code> (maximum number of iterations in global optimization algorithm.)</p>
</dd>
<dt>maxtime</dt><dd><p><code>60</code> (maximum time for global optimization. Set to 0 for unlimited time.)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_control_local">control_local</code></td>
<td>
<p>Optional list of additional arguments for
<code><a href="nloptr.html#topic+nloptr">nloptr</a></code> argument <code>opts</code>. The default values are
</p>

<dl>
<dt>algorithm</dt><dd><p><code>"NLOPT_LD_LBFGS"</code></p>
</dd>
<dt>ftol_rel</dt><dd><p><code>1e-10</code></p>
</dd>
<dt>xtol_rel</dt><dd><p><code>1e-8</code></p>
</dd>
<dt>maxeval</dt><dd><p><code>10000</code> (maximum number of iterations)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_lb">lb</code>, <code id="seqHMM-deprecated_+3A_ub">ub</code></td>
<td>
<p>Lower and upper bounds for parameters in Softmax parameterization.
The default interval is <code class="reqn">[pmin(-25, 2*initialvalues), pmax(25, 2*initialvalues)]</code>,
except for gamma coefficients,
where the scale of covariates is taken into account.
Note that it might still be a good idea to scale covariates around unit scale.
Bounds are used only in the global optimization step.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. The default is 1.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at a cost of decreased computational performance. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>nloptr</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_maxit">maxit</code></td>
<td>
<p>Number of iterations. After zeroing small values, the model is
refitted, and this is repeated until there is nothing to trim or <code>maxit</code>
iterations are done.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_return_loglik">return_loglik</code></td>
<td>
<p>Return the log-likelihood of the trimmed model together with
the model object. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_zerotol">zerotol</code></td>
<td>
<p>Values smaller than this are trimmed to zero.</p>
</td></tr>
<tr><td><code id="seqHMM-deprecated_+3A_verbose">verbose</code></td>
<td>
<p>Print results of trimming. The default is <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='simulate_hmm'>Simulate hidden Markov models</h2><span id='topic+simulate_hmm'></span>

<h3>Description</h3>

<p>Simulate sequences of observed and hidden states given parameters of a hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hmm(
  n_sequences,
  initial_probs,
  transition_probs,
  emission_probs,
  sequence_length
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_hmm_+3A_n_sequences">n_sequences</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simulate_hmm_+3A_initial_probs">initial_probs</code></td>
<td>
<p>A vector of initial state probabilities.</p>
</td></tr>
<tr><td><code id="simulate_hmm_+3A_transition_probs">transition_probs</code></td>
<td>
<p>A matrix of transition probabilities.</p>
</td></tr>
<tr><td><code id="simulate_hmm_+3A_emission_probs">emission_probs</code></td>
<td>
<p>A matrix of emission probabilities or a list of such objects (one for each channel).</p>
</td></tr>
<tr><td><code id="simulate_hmm_+3A_sequence_length">sequence_length</code></td>
<td>
<p>Length for simulated sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of state sequence objects of class <code>stslist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building
and fitting hidden Markov models; <code><a href="#topic+ssplot">ssplot</a></code> for plotting
multiple sequence data sets; <code><a href="#topic+seqdef">seqdef</a></code> for more
information on state sequence objects; and <code><a href="#topic+simulate_mhmm">simulate_mhmm</a></code>
for simulating mixture hidden Markov models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters for the HMM
emission_probs &lt;- matrix(c(0.5, 0.2, 0.5, 0.8), 2, 2)
transition_probs &lt;- matrix(c(5 / 6, 1 / 6, 1 / 6, 5 / 6), 2, 2)
initial_probs &lt;- c(1, 0)

# Setting the seed for simulation
set.seed(1)

# Simulating sequences
sim &lt;- simulate_hmm(
  n_sequences = 10, initial_probs = initial_probs,
  transition_probs = transition_probs,
  emission_probs = emission_probs,
  sequence_length = 20
)

ssplot(sim, sortv = "mds.obs", type = "I")
</code></pre>

<hr>
<h2 id='simulate_initial_probs'>Simulate Parameters of Hidden Markov Models</h2><span id='topic+simulate_initial_probs'></span><span id='topic+simulate_transition_probs'></span><span id='topic+simulate_emission_probs'></span>

<h3>Description</h3>

<p>These are helper functions for quick construction of initial values for various
model building functions.
Mostly useful for global optimization algorithms which do not depend on initial values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_initial_probs(n_states, n_clusters = 1)

simulate_transition_probs(
  n_states,
  n_clusters = 1,
  left_right = FALSE,
  diag_c = 0
)

simulate_emission_probs(n_states, n_symbols, n_clusters = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_initial_probs_+3A_n_states">n_states</code></td>
<td>
<p>Number of states in each cluster.</p>
</td></tr>
<tr><td><code id="simulate_initial_probs_+3A_n_clusters">n_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="simulate_initial_probs_+3A_left_right">left_right</code></td>
<td>
<p>Constrain the transition probabilities to upper triangular.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulate_initial_probs_+3A_diag_c">diag_c</code></td>
<td>
<p>A constant value to be added to diagonal of transition matrices before scaling.</p>
</td></tr>
<tr><td><code id="simulate_initial_probs_+3A_n_symbols">n_symbols</code></td>
<td>
<p>Number of distinct symbols in each channel.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code>, <code><a href="#topic+build_mhmm">build_mhmm</a></code>,
<code><a href="#topic+build_mm">build_mm</a></code>, <code><a href="#topic+build_mmm">build_mmm</a></code>, and  <code><a href="#topic+build_lcm">build_lcm</a></code>
for constructing different types of models.
</p>

<hr>
<h2 id='simulate_mhmm'>Simulate Mixture Hidden Markov Models</h2><span id='topic+simulate_mhmm'></span>

<h3>Description</h3>

<p>Simulate sequences of observed and hidden states given the parameters of a mixture
hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_mhmm(
  n_sequences,
  initial_probs,
  transition_probs,
  emission_probs,
  sequence_length,
  formula,
  data,
  coefficients
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_mhmm_+3A_n_sequences">n_sequences</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_initial_probs">initial_probs</code></td>
<td>
<p>A list containing vectors of initial state probabilities
for the submodel of each cluster.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_transition_probs">transition_probs</code></td>
<td>
<p>A list of matrices of transition probabilities
for the submodel of each cluster.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_emission_probs">emission_probs</code></td>
<td>
<p>A list which contains matrices of emission
probabilities or a list of such objects (one for each channel) for
the submodel of each cluster. Note that the matrices must have
dimensions <code class="reqn">s x m</code> where <code class="reqn">s</code> is the number of hidden states
and <code class="reqn">m</code> is the number of unique symbols (observed states) in the
data.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_sequence_length">sequence_length</code></td>
<td>
<p>The length of the simulated sequences.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_formula">formula</code></td>
<td>
<p>Covariates as an object of class <code><a href="stats.html#topic+formula">formula</a></code>,
left side omitted.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_data">data</code></td>
<td>
<p>An optional data frame, a list or an environment containing
the variables in the model. If not found in data, the variables are
taken from <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="simulate_mhmm_+3A_coefficients">coefficients</code></td>
<td>
<p>An optional <code class="reqn">k x l</code> matrix of regression
coefficients for time-constant covariates for mixture probabilities,
where <code class="reqn">l</code> is the number of clusters and <code class="reqn">k</code> is the number of
covariates. A logit-link is used for mixture probabilities. The first
column is set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of state sequence objects of class <code>stslist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building
and fitting mixture hidden Markov models; <code><a href="#topic+ssplot">ssplot</a></code> for plotting
multiple sequence data sets; <code><a href="#topic+seqdef">seqdef</a></code> for more
information on state sequence objects; and <code><a href="#topic+simulate_hmm">simulate_hmm</a></code>
for simulating hidden Markov models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emission_probs_1 &lt;- matrix(c(0.75, 0.05, 0.25, 0.95), 2, 2)
emission_probs_2 &lt;- matrix(c(0.1, 0.8, 0.9, 0.2), 2, 2)
colnames(emission_probs_1) &lt;- colnames(emission_probs_2) &lt;-
  c("heads", "tails")

transition_probs_1 &lt;- matrix(c(9, 0.1, 1, 9.9) / 10, 2, 2)
transition_probs_2 &lt;- matrix(c(35, 1, 1, 35) / 36, 2, 2)
rownames(emission_probs_1) &lt;- rownames(transition_probs_1) &lt;-
  colnames(transition_probs_1) &lt;- c("coin 1", "coin 2")
rownames(emission_probs_2) &lt;- rownames(transition_probs_2) &lt;-
  colnames(transition_probs_2) &lt;- c("coin 3", "coin 4")

initial_probs_1 &lt;- c(1, 0)
initial_probs_2 &lt;- c(1, 0)

n &lt;- 30
set.seed(123)
covariate_1 &lt;- runif(n)
covariate_2 &lt;- sample(c("A", "B"),
  size = n, replace = TRUE,
  prob = c(0.3, 0.7)
)
dataf &lt;- data.frame(covariate_1, covariate_2)

coefs &lt;- cbind(cluster_1 = c(0, 0, 0), cluster_2 = c(-1.5, 3, -0.7))
rownames(coefs) &lt;- c("(Intercept)", "covariate_1", "covariate_2B")

sim &lt;- simulate_mhmm(
  n = n, initial_probs = list(initial_probs_1, initial_probs_2),
  transition_probs = list(transition_probs_1, transition_probs_2),
  emission_probs = list(emission_probs_1, emission_probs_2),
  sequence_length = 20, formula = ~ covariate_1 + covariate_2,
  data = dataf, coefficients = coefs
)

ssplot(sim$observations,
  hidden.paths = sim$states, plots = "both",
  sortv = "from.start", sort.channel = 0, type = "I"
)

hmm &lt;- build_mhmm(sim$observations,
  initial_probs = list(initial_probs_1, initial_probs_2),
  transition_probs = list(transition_probs_1, transition_probs_2),
  emission_probs = list(emission_probs_1, emission_probs_2),
  formula = ~ covariate_1 + covariate_2,
  data = dataf
)

fit &lt;- fit_model(hmm)
fit$model

paths &lt;- hidden_paths(fit$model)

ssplot(list(estimates = paths, true = sim$states),
  sortv = "from.start",
  sort.channel = 2, ylab = c("estimated paths", "true (simulated)"),
  type = "I"
)

</code></pre>

<hr>
<h2 id='ssp'>Define Arguments for Plotting Multichannel Sequences and/or Most Probable
Paths from Hidden Markov Models</h2><span id='topic+ssp'></span>

<h3>Description</h3>

<p>Function <code>ssp</code> defines the arguments for plotting with
<code><a href="#topic+plot.ssp">plot.ssp</a></code> or <code><a href="#topic+gridplot">gridplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp(
  x,
  hidden.paths = NULL,
  plots = "obs",
  type = "d",
  tlim = 0,
  sortv = NULL,
  sort.channel = 1,
  dist.method = "OM",
  with.missing = FALSE,
  missing.color = NULL,
  title = NA,
  title.n = TRUE,
  cex.title = 1,
  title.pos = 1,
  with.legend = "auto",
  ncol.legend = "auto",
  with.missing.legend = "auto",
  legend.prop = 0.3,
  cex.legend = 1,
  hidden.states.colors = "auto",
  hidden.states.labels = "auto",
  xaxis = TRUE,
  xlab = NA,
  xtlab = NULL,
  xlab.pos = 1,
  ylab = "auto",
  hidden.states.title = "Hidden states",
  yaxis = FALSE,
  ylab.pos = "auto",
  cex.lab = 1,
  cex.axis = 1,
  withlegend,
  respect_void = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssp_+3A_x">x</code></td>
<td>
<p>Either a hidden Markov model object of class <code>hmm</code> or a state
sequence object of class <code>stslist</code> (created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>)
function) or a list of state sequence objects.</p>
</td></tr>
<tr><td><code id="ssp_+3A_hidden.paths">hidden.paths</code></td>
<td>
<p>Output from <code><a href="#topic+hidden_paths">hidden_paths</a></code> function. Optional, if
<code>x</code> is a <code>hmm</code> object or if <code>type = "obs"</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_plots">plots</code></td>
<td>
<p>What to plot. One of <code>"obs"</code> for observations (the default),
<code>"hidden.paths"</code> for most probable paths of hidden states,
or <code>"both"</code> for observations and hidden paths together.</p>
</td></tr>
<tr><td><code id="ssp_+3A_type">type</code></td>
<td>
<p>The type of the plot. Available types are <code>"I"</code> for sequence index
plots and <code>"d"</code> for state distribution plots (the default). See
<code><a href="HH.html#topic+seqplot">seqplot</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssp_+3A_tlim">tlim</code></td>
<td>
<p>Indexes of the subjects to be plotted (the default is 0,
i.e. all subjects are plotted). For example, <code>tlim = 1:10</code> plots
the first ten subjects in data.</p>
</td></tr>
<tr><td><code id="ssp_+3A_sortv">sortv</code></td>
<td>
<p>A sorting variable or a sort method (one of <code>"from.start"</code>,
<code>"from.end"</code>, <code>"mds.obs"</code>, or <code>"mds.hidden"</code>) for
<code>type = "I"</code>. The value <code>"mds.hidden"</code> is only available when
hidden paths are available. Options <code>"mds.obs"</code> and
<code>"mds.hidden"</code> automatically arrange the sequences according to the
scores of multidimensional scaling (using <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) for the
observed data or hidden states paths.
MDS scores are computed from distances/dissimilarities using a metric
defined in argument <code>dist.method</code>. See <code>plot.stslist</code> for
more details on <code>"from.start"</code> and <code>"from.end"</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_sort.channel">sort.channel</code></td>
<td>
<p>The number of the channel according to which the
<code>"from.start"</code> or <code>"from.end"</code> sorting is done. Sorting according
to hidden states is called with value 0. The default value is 1 (the first
channel).</p>
</td></tr>
<tr><td><code id="ssp_+3A_dist.method">dist.method</code></td>
<td>
<p>The metric to be used for computing the distances of the
sequences if multidimensional scaling is used for sorting. One of &quot;OM&quot;
(optimal matching, the default), &quot;LCP&quot; (longest common prefix), &quot;RLCP&quot;
(reversed LCP, i.e. longest common suffix), &quot;LCS&quot; (longest common
subsequence), &quot;HAM&quot; (Hamming distance), and &quot;DHD&quot; (dynamic Hamming distance).
Transition rates are used for defining substitution costs if needed. See
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> for more information on the metrics.</p>
</td></tr>
<tr><td><code id="ssp_+3A_with.missing">with.missing</code></td>
<td>
<p>Controls whether missing states are included in state
distribution plots (<code>type = "d"</code>). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_missing.color">missing.color</code></td>
<td>
<p>Alternative color for representing missing values
in the sequences. By default, this color is taken from the <code>missing.color</code>
attribute of the sequence object.</p>
</td></tr>
<tr><td><code id="ssp_+3A_title">title</code></td>
<td>
<p>Main title for the graphic. The default is <code>NA</code>: if
<code>title.n = TRUE</code>, only the number of subjects is plotted. <code>FALSE</code>
prints no title, even when <code>title.n = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_title.n">title.n</code></td>
<td>
<p>Controls whether the number of subjects (in the
first channel) is printed in the title of the plot. The default is
<code>TRUE</code>: n is plotted if <code>title</code>
is anything but <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_cex.title">cex.title</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
title. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssp_+3A_title.pos">title.pos</code></td>
<td>
<p>Controls the position of the main title of the plot. The
default value is 1. Values greater than 1 will place the title higher.</p>
</td></tr>
<tr><td><code id="ssp_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and where the legend for the states is plotted.
The default value <code>"auto"</code> (equivalent to <code>TRUE</code> and
<code>"right"</code>) creates separate legends for each requested plot and
positiones them on the right-hand side of the plot. Other possible values
are <code>"bottom"</code>,
<code>"right.combined"</code>, and <code>"bottom.combined"</code>, of which the last
two create a combined legend in the selected position. <code>FALSE</code> prints no legend.</p>
</td></tr>
<tr><td><code id="ssp_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>(A vector of) the number of columns for the legend(s). The
default <code>"auto"</code> determines number of columns depending on the position of
the legend.</p>
</td></tr>
<tr><td><code id="ssp_+3A_with.missing.legend">with.missing.legend</code></td>
<td>
<p>If set to <code>"auto"</code> (the default), a legend
for the missing state is added automatically if one or more of the
sequences in the data/channel contains missing states and <code>type = "I"</code>.
If <code>type = "d"</code> missing states are omitted from the legends unless
<code>with.missing = TRUE</code>. With the value <code>TRUE</code> a
legend for the missing state is added in any case; equivalently
<code>FALSE</code> omits the legend for the missing state.</p>
</td></tr>
<tr><td><code id="ssp_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Sets the proportion of the graphic area used for plotting
the legend when <code>with.legend</code> is not <code>FALSE</code>. The default value is
0.3. Takes values from 0 to 1.</p>
</td></tr>
<tr><td><code id="ssp_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssp_+3A_hidden.states.colors">hidden.states.colors</code></td>
<td>
<p>A vector of colors assigned to hidden states. The default
value <code>"auto"</code> uses the colors assigned to the <code>stslist</code> object (created
with <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) if <code>hidden.paths</code> is given; otherwise colors from
<code><a href="#topic+colorpalette">colorpalette</a></code> are automatically used.</p>
</td></tr>
<tr><td><code id="ssp_+3A_hidden.states.labels">hidden.states.labels</code></td>
<td>
<p>Labels for the hidden states. The default value
<code>"auto"</code> uses the names provided in <code>x$state_names</code> if <code>x</code> is
an <code>hmm</code> object; otherwise the number of the hidden state.</p>
</td></tr>
<tr><td><code id="ssp_+3A_xaxis">xaxis</code></td>
<td>
<p>Controls whether an x-axis is plotted below the plot at the
bottom. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_xlab">xlab</code></td>
<td>
<p>An optional label for the x-axis. If set to <code>NA</code>, no label
is drawn.</p>
</td></tr>
<tr><td><code id="ssp_+3A_xtlab">xtlab</code></td>
<td>
<p>Optional labels for the x-axis tick labels.  If unspecified, the
column names of the <code>seqdata</code> sequence object are used (see
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="ssp_+3A_xlab.pos">xlab.pos</code></td>
<td>
<p>Controls the position of the x-axis label. The default value
is 1. Values greater than 1 will place the label further away from the plot.</p>
</td></tr>
<tr><td><code id="ssp_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the channels shown as labels for y-axes.
A vector of names for each channel
(observations). The default value <code>"auto"</code> uses the names provided in
<code>x$channel_names</code> if <code>x</code> is an <code>hmm</code> object; otherwise the
names of the list in <code>x</code> if given, or the
number of the channel if names are not given. <code>FALSE</code> prints no labels.</p>
</td></tr>
<tr><td><code id="ssp_+3A_hidden.states.title">hidden.states.title</code></td>
<td>
<p>Optional label for the hidden state plot (in the
y-axis). The default is <code>"Hidden states"</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_yaxis">yaxis</code></td>
<td>
<p>Controls whether or not to plot the y-axis. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssp_+3A_ylab.pos">ylab.pos</code></td>
<td>
<p>Controls the position of the y axis labels (labels for
channels and/or hidden states). Either <code>"auto"</code> or a numerical vector
indicating how far away from the plots the titles are positioned. The
default value <code>"auto"</code> positions all titles on line 1.
Shorter vectors are recycled.</p>
</td></tr>
<tr><td><code id="ssp_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Expansion factor for setting the size of the font for the axis
labels. The default value is 1. Values lesser than 1 will reduce the size
of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssp_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Expansion factor for setting the size of the font for the x-axis
tick labels. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssp_+3A_withlegend">withlegend</code></td>
<td>
<p>Deprecated. Use <code>with.legend</code> instead.</p>
</td></tr>
<tr><td><code id="ssp_+3A_respect_void">respect_void</code></td>
<td>
<p>If <code>TRUE</code> (default), states at the time points
corresponding to TraMineR's void in the observed sequences are set to void
in the hidden state sequences as well.</p>
</td></tr>
<tr><td><code id="ssp_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to <code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>ssp</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ssp">plot.ssp</a></code> for plotting objects created with
the <code>ssp</code> function; <code><a href="#topic+gridplot">gridplot</a></code> for plotting multiple <code>ssp</code>
objects; <code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting hidden Markov models; <code><a href="#topic+hidden_paths">hidden_paths</a></code> for
computing the most probable paths of hidden states; and <code><a href="#topic+biofam3c">biofam3c</a></code> and
<code><a href="#topic+hmm_biofam">hmm_biofam</a></code> for information on the data and model used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("biofam3c")

## Building sequence objects
child_seq &lt;- seqdef(biofam3c$children, start = 15)
marr_seq &lt;- seqdef(biofam3c$married, start = 15)
left_seq &lt;- seqdef(biofam3c$left, start = 15)

## Choosing colors
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")


# Defining the plot for state distribution plots of observations
ssp1 &lt;- ssp(list(
  "Parenthood" = child_seq, "Marriage" = marr_seq,
  "Residence" = left_seq
))
# Plotting ssp1
plot(ssp1)

## Not run: 
# Defining the plot for sequence index plots of observations
ssp2 &lt;- ssp(
  list(child_seq, marr_seq, left_seq),
  type = "I", plots = "obs",
  # Sorting subjects according to the beginning of the 2nd channel (marr_seq)
  sortv = "from.start", sort.channel = 2,
  # Controlling the size, positions, and names for channel labels
  ylab.pos = c(1, 2, 1), cex.lab = 1, ylab = c("Children", "Married", "Residence"),
  # Plotting without legend
  with.legend = FALSE
)
plot(ssp2)

# Plotting hidden Markov models

# Loading data
data("hmm_biofam")

# Plotting observations and most probable hidden states paths
ssp3 &lt;- ssp(
  hmm_biofam,
  type = "I", plots = "both",
  # Sorting according to multidimensional scaling of hidden states paths
  sortv = "mds.hidden",
  # Controlling title
  title = "Biofam", cex.title = 1.5,
  # Labels for x axis and tick marks
  xtlab = 15:30, xlab = "Age"
)
plot(ssp3)

# Computing the most probable paths of hidden states
hid &lt;- hidden_paths(hmm_biofam)
# Giving names for hidden states
library(TraMineR)
alphabet(hid) &lt;- paste("Hidden state", 1:5)

# Plotting observations and hidden state paths
ssp4 &lt;- ssp(
  hmm_biofam,
  type = "I", plots = "hidden.paths",
  # Sequence object of most probable paths
  hidden.paths = hid,
  # Sorting according to the end of hidden state paths
  sortv = "from.end", sort.channel = 0,
  # Contolling legend position, type, and proportion
  with.legend = "bottom.combined", legend.prop = 0.15,
  # Plotting without title and y label
  title = FALSE, ylab = FALSE
)
plot(ssp4)

## End(Not run)
</code></pre>

<hr>
<h2 id='ssplot'>Stacked Plots of Multichannel Sequences and/or Most Probable
Paths from Hidden Markov Models</h2><span id='topic+ssplot'></span>

<h3>Description</h3>

<p>Function <code>ssplot</code> plots stacked sequence plots of sequence object
created with the <code><a href="#topic+seqdef">seqdef</a></code> function or observations and/or most
probable paths of <code>hmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssplot(
  x,
  hidden.paths = NULL,
  plots = "obs",
  type = "d",
  tlim = 0,
  sortv = NULL,
  sort.channel = 1,
  dist.method = "OM",
  with.missing = FALSE,
  missing.color = NULL,
  title = NA,
  title.n = TRUE,
  cex.title = 1,
  title.pos = 1,
  with.legend = "auto",
  ncol.legend = "auto",
  with.missing.legend = "auto",
  legend.prop = 0.3,
  cex.legend = 1,
  hidden.states.colors = "auto",
  hidden.states.labels = "auto",
  xaxis = TRUE,
  xlab = NA,
  xtlab = NULL,
  xlab.pos = 1,
  ylab = "auto",
  hidden.states.title = "Hidden states",
  yaxis = FALSE,
  ylab.pos = "auto",
  cex.lab = 1,
  cex.axis = 1,
  respect_void = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssplot_+3A_x">x</code></td>
<td>
<p>Either a hidden Markov model object of class <code>hmm</code> or a state
sequence object of class <code>stslist</code> (created with the <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>)
function) or a list of state sequence objects.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_hidden.paths">hidden.paths</code></td>
<td>
<p>Output from <code><a href="#topic+hidden_paths">hidden_paths</a></code> function. Optional, if
<code>x</code> is a <code>hmm</code> object or if <code>type = "obs"</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_plots">plots</code></td>
<td>
<p>What to plot. One of <code>"obs"</code> for observations (the default),
<code>"hidden.paths"</code> for most probable paths of hidden states,
or <code>"both"</code> for observations and hidden paths together.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_type">type</code></td>
<td>
<p>The type of the plot. Available types are <code>"I"</code> for sequence index
plots and <code>"d"</code> for state distribution plots (the default). See
<code><a href="HH.html#topic+seqplot">seqplot</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_tlim">tlim</code></td>
<td>
<p>Indexes of the subjects to be plotted (the default is 0,
i.e. all subjects are plotted). For example, <code>tlim = 1:10</code> plots
the first ten subjects in data.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_sortv">sortv</code></td>
<td>
<p>A sorting variable or a sort method (one of <code>"from.start"</code>,
<code>"from.end"</code>, <code>"mds.obs"</code>, or <code>"mds.hidden"</code>) for
<code>type = "I"</code>. The value <code>"mds.hidden"</code> is only available when
hidden paths are available. Options <code>"mds.obs"</code> and
<code>"mds.hidden"</code> automatically arrange the sequences according to the
scores of multidimensional scaling (using <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>) for the
observed data or hidden states paths.
MDS scores are computed from distances/dissimilarities using a metric
defined in argument <code>dist.method</code>. See <code>plot.stslist</code> for
more details on <code>"from.start"</code> and <code>"from.end"</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_sort.channel">sort.channel</code></td>
<td>
<p>The number of the channel according to which the
<code>"from.start"</code> or <code>"from.end"</code> sorting is done. Sorting according
to hidden states is called with value 0. The default value is 1 (the first
channel).</p>
</td></tr>
<tr><td><code id="ssplot_+3A_dist.method">dist.method</code></td>
<td>
<p>The metric to be used for computing the distances of the
sequences if multidimensional scaling is used for sorting. One of &quot;OM&quot;
(optimal matching, the default), &quot;LCP&quot; (longest common prefix), &quot;RLCP&quot;
(reversed LCP, i.e. longest common suffix), &quot;LCS&quot; (longest common
subsequence), &quot;HAM&quot; (Hamming distance), and &quot;DHD&quot; (dynamic Hamming distance).
Transition rates are used for defining substitution costs if needed. See
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> for more information on the metrics.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_with.missing">with.missing</code></td>
<td>
<p>Controls whether missing states are included in state
distribution plots (<code>type = "d"</code>). The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_missing.color">missing.color</code></td>
<td>
<p>Alternative color for representing missing values
in the sequences. By default, this color is taken from the <code>missing.color</code>
attribute of the sequence object.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_title">title</code></td>
<td>
<p>Main title for the graphic. The default is <code>NA</code>: if
<code>title.n = TRUE</code>, only the number of subjects is plotted. <code>FALSE</code>
prints no title, even when <code>title.n = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_title.n">title.n</code></td>
<td>
<p>Controls whether the number of subjects (in the
first channel) is printed in the title of the plot. The default is
<code>TRUE</code>: n is plotted if <code>title</code> is anything but <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_cex.title">cex.title</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
title. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_title.pos">title.pos</code></td>
<td>
<p>Controls the position of the main title of the plot. The
default value is 1. Values greater than 1 will place the title higher.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_with.legend">with.legend</code></td>
<td>
<p>Defines if and where the legend for the states is plotted.
The default value <code>"auto"</code> (equivalent to <code>TRUE</code> and
<code>"right"</code>) creates separate legends for each requested plot and
positiones them on the right-hand side of the plot. Other possible values
are <code>"bottom"</code>,
<code>"right.combined"</code>, and <code>"bottom.combined"</code>, of which the last
two create a combined legend in the selected position. <code>FALSE</code> prints no legend.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_ncol.legend">ncol.legend</code></td>
<td>
<p>(A vector of) the number of columns for the legend(s). The
default <code>"auto"</code> determines number of columns depending on the position of
the legend.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_with.missing.legend">with.missing.legend</code></td>
<td>
<p>If set to <code>"auto"</code> (the default), a legend
for the missing state is added automatically if one or more of the
sequences in the data/channel contains missing states and <code>type = "I"</code>.
If <code>type = "d"</code> missing states are omitted from the legends unless
<code>with.missing = TRUE</code>. With the value <code>TRUE</code> a
legend for the missing state is added in any case; equivalently
<code>FALSE</code> omits the legend for the missing state.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_legend.prop">legend.prop</code></td>
<td>
<p>Sets the proportion of the graphic area used for plotting
the legend when <code>with.legend</code> is not <code>FALSE</code>. The default value is
0.3. Takes values from 0 to 1.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Expansion factor for setting the size of the font for the
labels in the legend. The default value is 1. Values lesser than 1 will
reduce the size of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_hidden.states.colors">hidden.states.colors</code></td>
<td>
<p>A vector of colors assigned to hidden states. The default
value <code>"auto"</code> uses the colors assigned to the <code>stslist</code> object (created
with <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>) if <code>hidden.paths</code> is given; otherwise colors from
<code><a href="#topic+colorpalette">colorpalette</a></code> are automatically used.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_hidden.states.labels">hidden.states.labels</code></td>
<td>
<p>Labels for the hidden states. The default value
<code>"auto"</code> uses the names provided in <code>x$state_names</code> if <code>x</code> is
an <code>hmm</code> object; otherwise the number of the hidden state.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_xaxis">xaxis</code></td>
<td>
<p>Controls whether an x-axis is plotted below the plot at the
bottom. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_xlab">xlab</code></td>
<td>
<p>An optional label for the x-axis. If set to <code>NA</code>, no label
is drawn.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_xtlab">xtlab</code></td>
<td>
<p>Optional labels for the x-axis tick labels.  If unspecified, the
column names of the <code>seqdata</code> sequence object are used (see
<code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).</p>
</td></tr>
<tr><td><code id="ssplot_+3A_xlab.pos">xlab.pos</code></td>
<td>
<p>Controls the position of the x-axis label. The default value
is 1. Values greater than 1 will place the label further away from the plot.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the channels shown as labels for y-axes.
A vector of names for each channel
(observations). The default value <code>"auto"</code> uses the names provided in
<code>x$channel_names</code> if <code>x</code> is an <code>hmm</code> object; otherwise the
names of the list in <code>x</code> if given, or the
number of the channel if names are not given. <code>FALSE</code> prints no labels.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_hidden.states.title">hidden.states.title</code></td>
<td>
<p>Optional label for the hidden state plot (in the
y-axis). The default is <code>"Hidden states"</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_yaxis">yaxis</code></td>
<td>
<p>Controls whether or not to plot the y-axis. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_ylab.pos">ylab.pos</code></td>
<td>
<p>Controls the position of the y axis labels (labels for
channels and/or hidden states). Either <code>"auto"</code> or a numerical vector
indicating how far away from the plots the titles are positioned. The
default value <code>"auto"</code> positions all titles on line 1.
Shorter vectors are recycled.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Expansion factor for setting the size of the font for the axis
labels. The default value is 1. Values lesser than 1 will reduce the size
of the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Expansion factor for setting the size of the font for the x-axis
tick labels. The default value is 1. Values lesser than 1 will reduce the size of
the font, values greater than 1 will increase the size.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_respect_void">respect_void</code></td>
<td>
<p>If <code>TRUE</code> (default), states at the time points
corresponding to TraMineR's void in the observed sequences are set to void
in the hidden state sequences as well.</p>
</td></tr>
<tr><td><code id="ssplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to
<code><a href="TraMineR.html#topic+seqplot">seqplot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ssp">ssp</a></code> for creating <code>ssp</code> objects and <code><a href="#topic+plot.ssp">plot.ssp</a></code>
and <code><a href="#topic+gridplot">gridplot</a></code> for plotting these;
<code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting hidden Markov models; <code><a href="#topic+hidden_paths">hidden_paths</a></code> for
computing the most probable paths of hidden states; and <code><a href="#topic+biofam3c">biofam3c</a></code>
<code><a href="#topic+hmm_biofam">hmm_biofam</a></code> for information on the data and model used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("biofam3c")

# Creating sequence objects
child_seq &lt;- seqdef(biofam3c$children, start = 15)
marr_seq &lt;- seqdef(biofam3c$married, start = 15)
left_seq &lt;- seqdef(biofam3c$left, start = 15)

## Choosing colors
attr(child_seq, "cpal") &lt;- c("#66C2A5", "#FC8D62")
attr(marr_seq, "cpal") &lt;- c("#AB82FF", "#E6AB02", "#E7298A")
attr(left_seq, "cpal") &lt;- c("#A6CEE3", "#E31A1C")


# Plotting state distribution plots of observations
ssplot(list(
  "Children" = child_seq, "Marriage" = marr_seq,
  "Residence" = left_seq
))

## Not run: 
# Plotting sequence index plots of observations
ssplot(
  list(child_seq, marr_seq, left_seq),
  type = "I",
  # Sorting subjects according to the beginning of the 2nd channel (marr_seq)
  sortv = "from.start", sort.channel = 2,
  # Controlling the size, positions, and names for channel labels
  ylab.pos = c(1, 2, 1), cex.lab = 1, ylab = c("Children", "Married", "Residence"),
  # Plotting without legend
  with.legend = FALSE
)

# Plotting hidden Markov models

# Loading a ready-made HMM for the biofam data
data("hmm_biofam")

# Plotting observations and hidden states paths
ssplot(
  hmm_biofam,
  type = "I", plots = "both",
  # Sorting according to multidimensional scaling of hidden states paths
  sortv = "mds.hidden",
  ylab = c("Children", "Married", "Left home"),
  # Controlling title
  title = "Biofam", cex.title = 1.5,
  # Labels for x axis and tick marks
  xtlab = 15:30, xlab = "Age"
)

# Computing the most probable paths of hidden states
hidden.paths &lt;- hidden_paths(hmm_biofam)
hidden.paths_seq &lt;- seqdef(hidden.paths, labels = paste("Hidden state", 1:5))

# Plotting observations and hidden state paths
ssplot(
  hmm_biofam,
  type = "I", plots = "hidden.paths",
  # Sequence object of most probable paths
  hidden.paths = hidden.paths_seq,
  # Sorting according to the end of hidden state paths
  sortv = "from.end", sort.channel = 0,
  # Contolling legend position, type, and proportion
  with.legend = "bottom", legend.prop = 0.15,
  # Plotting without title and y label
  title = FALSE, ylab = FALSE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='state_names'>Get state names from hmm or mhmm object</h2><span id='topic+state_names'></span>

<h3>Description</h3>

<p>Get state names from hmm or mhmm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_names(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_names_+3A_object">object</code></td>
<td>
<p>An object of class 'hmm' or 'mhmm'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the state names, or a list of such
vectors in 'mhmm' case.
</p>

<hr>
<h2 id='state_names+26lt+3B-'>Set state names for hmm or mhmm object</h2><span id='topic+state_names+3C-'></span>

<h3>Description</h3>

<p>Set state names for hmm or mhmm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_names(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_names+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>An object of class 'hmm' or 'mhmm'.</p>
</td></tr>
<tr><td><code id="state_names+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A character vector containing the new state names, or a list of
such vectors in 'mhmm' case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified object with updated state names.
</p>

<hr>
<h2 id='summary.mhmm'>Summary method for mixture hidden Markov models</h2><span id='topic+summary.mhmm'></span>

<h3>Description</h3>

<p>Function <code>summary.mhmm</code> gives a summary of a mixture hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mhmm'
summary(
  object,
  parameters = FALSE,
  conditional_se = TRUE,
  log_space = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mhmm_+3A_object">object</code></td>
<td>
<p>Mixture hidden Markov model of class <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="summary.mhmm_+3A_parameters">parameters</code></td>
<td>
<p>Whether or not to return transition, emission, and
initial probabilities. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="summary.mhmm_+3A_conditional_se">conditional_se</code></td>
<td>
<p>Return conditional standard errors of coefficients.
See <code><a href="#topic+vcov.mhmm">vcov.mhmm</a></code> for details. <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="summary.mhmm_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at cost of decreased computational performance. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.mhmm_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="#topic+vcov.mhmm">vcov.mhmm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.mhmm</code> function computes features from a mixture hidden Markov
model and stores them as a list. A <code>print</code> method prints summaries of these:
log-likelihood and BIC, coefficients and standard errors of covariates, means of prior
cluster probabilities, and information on most probable clusters.
</p>


<h3>Value</h3>


<dl>
<dt>transition_probs</dt><dd><p>Transition probabilities. Only returned if <code>parameters = TRUE</code>.</p>
</dd>
<dt>emission_probs</dt><dd><p>Emission probabilities. Only returned if <code>parameters = TRUE</code>.</p>
</dd>
<dt>initial_probs</dt><dd><p>Initial state probabilities. Only returned if <code>parameters = TRUE</code>.</p>
</dd>
<dt>logLik</dt><dd><p>Log-likelihood.</p>
</dd>
<dt>BIC</dt><dd><p>Bayesian information criterion.</p>
</dd>
<dt>most_probable_cluster</dt><dd><p>The most probable cluster according to posterior probabilities.</p>
</dd>
<dt>coefficients</dt><dd><p>Coefficients of covariates.</p>
</dd>
<dt>vcov</dt><dd><p>Variance-covariance matrix of coefficients.</p>
</dd>
<dt>prior_cluster_probabilities</dt><dd><p>Prior cluster probabilities
(mixing proportions) given the covariates.</p>
</dd>
<dt>posterior_cluster_probabilities</dt><dd><p>Posterior cluster membership probabilities.</p>
</dd>
<dt>classification_table</dt><dd><p>Cluster probabilities (columns) by the most probable cluster (rows).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+build_mhmm">build_mhmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and
fitting mixture hidden Markov models; and
<code><a href="#topic+mhmm_biofam">mhmm_biofam</a></code> for information on the model used in examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading mixture hidden Markov model (mhmm object)
# of the biofam data
data("mhmm_biofam")

# Model summary
summary(mhmm_biofam)

</code></pre>

<hr>
<h2 id='trim_model'>Trim Small Probabilities of Hidden Markov Model</h2><span id='topic+trim_model'></span>

<h3>Description</h3>

<p>Function <code>trim_model</code> tries to set small insignificant probabilities to zero
without decreasing the likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_model(
  model,
  maxit = 0,
  return_loglik = FALSE,
  zerotol = 1e-08,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_model_+3A_model">model</code></td>
<td>
<p>Model of class <code>hmm</code> or <code>mhmm</code> for which
trimming is performed.</p>
</td></tr>
<tr><td><code id="trim_model_+3A_maxit">maxit</code></td>
<td>
<p>Number of iterations. After zeroing small values, the model is
refitted, and this is repeated until there is nothing to trim or <code>maxit</code>
iterations are done.</p>
</td></tr>
<tr><td><code id="trim_model_+3A_return_loglik">return_loglik</code></td>
<td>
<p>Return the log-likelihood of the trimmed model together with
the model object. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="trim_model_+3A_zerotol">zerotol</code></td>
<td>
<p>Values smaller than this are trimmed to zero.</p>
</td></tr>
<tr><td><code id="trim_model_+3A_verbose">verbose</code></td>
<td>
<p>Print results of trimming. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="trim_model_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code><a href="#topic+fit_model">fit_model</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+build_hmm">build_hmm</a></code> and <code><a href="#topic+fit_model">fit_model</a></code> for building and fitting
hidden Markov models; and <code><a href="#topic+hmm_biofam">hmm_biofam</a></code> for information on the model used
in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hmm_biofam")

# Testing if changing parameter values smaller than 1e-03 to zero
# leads to improved log-likelihood.
hmm_trim &lt;- trim_model(hmm_biofam, zerotol = 1e-03, maxit = 10)
</code></pre>

<hr>
<h2 id='vcov.mhmm'>Variance-Covariance Matrix for Coefficients of Covariates of Mixture Hidden Markov Model</h2><span id='topic+vcov.mhmm'></span>

<h3>Description</h3>

<p>Returns the asymptotic covariances matrix of maximum likelihood estimates of
the coefficients corresponding to the explanatory variables of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mhmm'
vcov(object, conditional = TRUE, threads = 1, log_space = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mhmm_+3A_object">object</code></td>
<td>
<p>Object of class <code>mhmm</code>.</p>
</td></tr>
<tr><td><code id="vcov.mhmm_+3A_conditional">conditional</code></td>
<td>
<p>If <code>TRUE</code> (default), the standard errors are
computed conditional on other model parameters. See details.</p>
</td></tr>
<tr><td><code id="vcov.mhmm_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use in parallel computing. Default is 1.</p>
</td></tr>
<tr><td><code id="vcov.mhmm_+3A_log_space">log_space</code></td>
<td>
<p>Make computations using log-space instead of scaling for greater
numerical stability at cost of decreased computational performance. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vcov.mhmm_+3A_...">...</code></td>
<td>
<p>Additional arguments to function <code>jacobian</code> of <code>numDeriv</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional standard errors are computed using
analytical formulas by assuming that the coefficient estimates are not correlated with
other model parameter estimates (or that the other parameters are assumed to be fixed).
This often underestimates the true standard errors, but is substantially
faster approach for preliminary analysis. The non-conditional standard errors
are based on the numerical approximation of the full Hessian of the coefficients
and the model parameters corresponding to nonzero probabilities.
Computing the non-conditional standard errors can be slow for large models as
the Jacobian of analytical gradients is computed using finite difference approximation.
</p>


<h3>Value</h3>

<p>Matrix containing the variance-covariance matrix of coefficients.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
