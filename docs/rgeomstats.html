<!DOCTYPE html><html><head><title>Help for package rgeomstats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgeomstats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgeomstats-package'><p>rgeomstats: Interface to 'Geomstats'</p></a></li>
<li><a href='#Connection'><p>Abstract Class for Connections</p></a></li>
<li><a href='#LevelSet'><p>Abstract Class for Level Set Manifolds</p></a></li>
<li><a href='#LieGroup'><p>Abstract Class for Lie Groups</p></a></li>
<li><a href='#Manifold'><p>Abstract Class for Manifolds</p></a></li>
<li><a href='#MatrixLieAlgebra'><p>Abstract Class for Matrix Lie Algebras</p></a></li>
<li><a href='#MatrixLieGroup'><p>Abstract Class for Matrix Lie Groups</p></a></li>
<li><a href='#NFoldManifold'><p>Class for N-Fold Product Manifolds</p></a></li>
<li><a href='#OpenSet'><p>Abstract Class for Open Set Manifolds</p></a></li>
<li><a href='#RiemannianMetric'><p>Abstract Class for Riemannian Metrics</p></a></li>
<li><a href='#SPDMatrices'><p>Class for the Manifold of Symmetric Positive Definite Matrices</p></a></li>
<li><a href='#SPDMatrix'><p>Class for the Manifold of Symmetric Positive Definite Matrices</p></a></li>
<li><a href='#SPDMetricAffine'><p>Class for the Affine Metric on the Manifold of Symmetric Positive Definite</p>
Matrices</a></li>
<li><a href='#SPDMetricBuresWasserstein'><p>Class for the Bures-Wasserstein Metric on the Manifold of Symmetric Positive</p>
Definite Matrices</a></li>
<li><a href='#SPDMetricEuclidean'><p>Class for the Euclidean Metric on the Manifold of Symmetric Positive Definite</p>
Matrices</a></li>
<li><a href='#SPDMetricLogEuclidean'><p>Class for the log-Euclidean Metric on the Manifold of Symmetric Positive</p>
Definite Matrices</a></li>
<li><a href='#SpecialOrthogonal'><p>Class for the Special Orthogonal Group</p></a></li>
<li><a href='#SpecialOrthogonal2Vectors'><p>Abstract Class for the 2D Special Orthogonal Group in Vector Representation</p></a></li>
<li><a href='#SpecialOrthogonal3Vectors'><p>Abstract Class for the 3D Special Orthogonal Group in Vector Representation</p></a></li>
<li><a href='#SpecialOrthogonalMatrices'><p>Abstract Class for Special Orthogonal Groups in Matrix Representation</p></a></li>
<li><a href='#SpecialOrthogonalVectors'><p>Abstract Class for Special Orthogonal Groups in Vector Representation</p></a></li>
<li><a href='#VectorSpace'><p>Abstract Class for Vector Space Manifolds</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to 'Geomstats'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface to the Python package 'Geomstats' authored by Miolane et 
    al. (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2004.04667">doi:10.48550/arXiv.2004.04667</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LMJL-Alea/rgeomstats">https://github.com/LMJL-Alea/rgeomstats</a>,
<a href="https://lmjl-alea.github.io/rgeomstats/">https://lmjl-alea.github.io/rgeomstats/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LMJL-Alea/rgeomstats/issues">https://github.com/LMJL-Alea/rgeomstats/issues</a></td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "geomstats") )
)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, purrr, R6, Rdpack, reticulate, rlang</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-03 21:11:20 UTC; stamm-a</td>
</tr>
<tr>
<td>Author:</td>
<td>Aymeric Stamm <a href="https://orcid.org/0000-0002-8725-3654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nicolas Guigui <a href="https://orcid.org/0000-0002-7901-0732"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Author of the Geomstats Python package),
  Alice Le Brigant <a href="https://orcid.org/0000-0002-8055-4753"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Author of the Geomstats Python package),
  Johan Mathe [ctb] (Author of the Geomstats Python package),
  Nina Miolane <a href="https://orcid.org/0000-0002-1200-9024"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Author of the Geomstats Python package),
  Xavier Pennec <a href="https://orcid.org/0000-0002-6617-7664"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Author of the Geomstats Python package),
  Luis Pereira [ctb] (Author of the Geomstats Python package),
  Yann Thanwerdas <a href="https://orcid.org/0000-0002-9351-6318"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Author of the Geomstats Python package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aymeric Stamm &lt;aymeric.stamm@math.cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-04 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgeomstats-package'>rgeomstats: Interface to 'Geomstats'</h2><span id='topic+rgeomstats'></span><span id='topic+rgeomstats-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides an interface to the Python package 'Geomstats' authored by Miolane et al. (2020) <a href="https://arxiv.org/abs/2004.04667">arXiv:2004.04667</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aymeric Stamm <a href="mailto:aymeric.stamm@math.cnrs.fr">aymeric.stamm@math.cnrs.fr</a> (<a href="https://orcid.org/0000-0002-8725-3654">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Nicolas Guigui (<a href="https://orcid.org/0000-0002-7901-0732">ORCID</a>) (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Alice Le Brigant (<a href="https://orcid.org/0000-0002-8055-4753">ORCID</a>) (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Johan Mathe (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Nina Miolane (<a href="https://orcid.org/0000-0002-1200-9024">ORCID</a>) (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Xavier Pennec (<a href="https://orcid.org/0000-0002-6617-7664">ORCID</a>) (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Luis Pereira (Author of the Geomstats Python package) [contributor]
</p>
</li>
<li><p> Yann Thanwerdas (<a href="https://orcid.org/0000-0002-9351-6318">ORCID</a>) (Author of the Geomstats Python package) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LMJL-Alea/rgeomstats">https://github.com/LMJL-Alea/rgeomstats</a>
</p>
</li>
<li> <p><a href="https://lmjl-alea.github.io/rgeomstats/">https://lmjl-alea.github.io/rgeomstats/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LMJL-Alea/rgeomstats/issues">https://github.com/LMJL-Alea/rgeomstats/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Connection'>Abstract Class for Connections</h2><span id='topic+Connection'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the base <code><a href="#topic+Connection">Connection</a></code>
class for affine connections.
</p>


<h3>Super class</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code>Connection</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the underlying
manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Dedaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>default_point_type</code></dt><dd><p>A string specifying the point type. Choices are
<code>vector</code> or <code>matrix</code>. It is automatically determined depending on the
manifold.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Connection-new"><code>Connection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-christoffels"><code>Connection$christoffels()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-geodesic_equation"><code>Connection$geodesic_equation()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-exp"><code>Connection$exp()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-log"><code>Connection$log()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-ladder_parallel_transport"><code>Connection$ladder_parallel_transport()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-curvature"><code>Connection$curvature()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-directional_curvature"><code>Connection$directional_curvature()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-curvature_derivative"><code>Connection$curvature_derivative()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-directional_curvature_derivative"><code>Connection$directional_curvature_derivative()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-geodesic"><code>Connection$geodesic()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-parallel_transport"><code>Connection$parallel_transport()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-injectivity_radius"><code>Connection$injectivity_radius()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-clone"><code>Connection$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Connection-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+Connection">Connection</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$new(
  dim,
  shape = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>Connection</code>. Defaults to <code>NULL</code>
in which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
<dt><code>metric</code></dt><dd><p>A <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> object specifying the metric to use
on the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+Connection">Connection</a></code>.
</p>


<hr>
<a id="method-Connection-christoffels"></a>



<h4>Method <code>christoffels()</code></h4>

<p>Christoffel symbols associated with the connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$christoffels(base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>c(dim, dim, dim)</code> storing the
Christoffel symbols, with the contravariant index on the first
dimension.
</p>


<hr>
<a id="method-Connection-geodesic_equation"></a>



<h4>Method <code>geodesic_equation()</code></h4>

<p>Computes the geodesic ODE associated with the connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$geodesic_equation(state, .time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent vector
to the manifold at the position specified by <code>.time</code>.</p>
</dd>
<dt><code>.time</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on the
manifold at which to compute the geodesic ODE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the value of the vector
field to be integrated at position.
</p>


<hr>
<a id="method-Connection-exp"></a>



<h4>Method <code>exp()</code></h4>

<p>Exponential map associated to the affine connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$exp(tangent_vec, base_point, n_steps = 100, step = "euler")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>n_steps</code></dt><dd><p>An integer value specifying the number of discrete time steps
to take in the integration. Defaults to <code>100L</code>.</p>
</dd>
<dt><code>step</code></dt><dd><p>A string specifying which numerical scheme to use for
integration. Choices are <code>euler</code> or <code>rk4</code>. Defaults to <code>euler</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Exponential map at base_point of tangent_vec computed by
integration of the geodesic equation (initial value problem), using the
christoffel symbols.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the exponential of the
input tangent vector, which lies on on the manifold.
</p>


<hr>
<a id="method-Connection-log"></a>



<h4>Method <code>log()</code></h4>

<p>Logarithm map associated to the affine connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$log(
  point,
  base_point,
  n_steps = 100,
  step = "euler",
  max_iter = 25,
  verbose = FALSE,
  tol = gs$backend$atol
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>n_steps</code></dt><dd><p>An integer value specifying the number of discrete time steps
to take in the integration. Defaults to <code>100L</code>.</p>
</dd>
<dt><code>step</code></dt><dd><p>A string specifying which numerical scheme to use for
integration. Choices are <code>euler</code> or <code>rk4</code>. Defaults to <code>euler</code>.</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>An integer value specifying the number of iterations.
Defaults to <code>25L</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A boolean specifying whether the optimizer should display
intermediate messages pertaining to its convergence. Defaults to
<code>FALSE</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>A numeric value specifying the absolute tolerance for
optimization convergence. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Solves the boundary value problem associated to the geodesic
equation using the Christoffel symbols and conjugate gradient descent.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the exponential of the
input tangent vector, which lies on on the manifold.
</p>


<hr>
<a id="method-Connection-ladder_parallel_transport"></a>



<h4>Method <code>ladder_parallel_transport()</code></h4>

<p>Approximate parallel transport using the pole ladder scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$ladder_parallel_transport(
  tangent_vec,
  base_point,
  direction,
  n_rungs = 1,
  scheme = "pole",
  alpha = 1,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Tangent vector at base point specifying the initial
speed of the geodesic along which to transport.</p>
</dd>
<dt><code>n_rungs</code></dt><dd><p>A scalar integer specifying the Number of steps of the
ladder. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>scheme</code></dt><dd><p>A string specifying the scheme to use for the construction
of the ladder at each step. Choices are either <code>pole</code> or <code>schild</code>.
Defaults to <code>pole</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A numeric value specifying the exponent for the scaling of
the vector to transport. Must be greater or equal to 1 and
Guigui and Pennec (2022) proved that <code>alpha = 2</code> is optimal. Defaults to <code>2</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to calls to <code style="white-space: pre;">&#8288;$exp()&#8288;</code> and <code style="white-space: pre;">&#8288;$log()&#8288;</code>
in auxiliary single ladder step functions.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Approximate parallel transport using either the pole ladder or
the Schild's ladder scheme
(Lorenzi and Pennec 2014). Pole ladder is exact in
symmetric spaces and of order two in general while Schild's ladder is a
first order approximation (Guigui and Pennec 2022).
Both schemes are available on any affine connection manifolds whose
exponential and logarithm maps are implemented. <code>tangent_vec</code> is
transported along the geodesic starting at the <code>base_point</code> with
initial tangent vector <code>direction</code>.
</p>


<h6>References</h6>

<p>Guigui N, Pennec X (2022).
&ldquo;Numerical accuracy of ladder schemes for parallel transport on manifolds.&rdquo;
<em>Foundations of Computational Mathematics</em>, <b>22</b>(3), 757&ndash;790.<br /><br /> Lorenzi M, Pennec X (2014).
&ldquo;Efficient parallel transport of deformations in time series of images: from Schild’s to pole ladder.&rdquo;
<em>Journal of mathematical imaging and vision</em>, <b>50</b>(1), 5&ndash;17.
</p>




<h5>Returns</h5>

<p>A named list with 3 components:
</p>

<ul>
<li> <p><code>transported_tangent_vector</code>: Approximation of the parallel transport
of the input tangent vector.
</p>
</li>
<li> <p><code>trajectory</code> : A list of length <code>n_steps</code> storing the geodesics of the
construction, only if <code>return_geodesics = TRUE</code> in the step function. The
geodesics are methods of the class connection.
</p>
</li>
<li> <p><code>end_point</code>:
</p>
</li></ul>



<hr>
<a id="method-Connection-curvature"></a>



<h4>Method <code>curvature()</code></h4>

<p>Computes the curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$curvature(tangent_vec_a, tangent_vec_b, tangent_vec_c, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_c</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For three vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code>, <code class="reqn">Z|_P =
  \mathrm{tangent\_vec\_c}</code> with tangent vector specified in argument at
the base point <code class="reqn">P</code>, the curvature is defined by </p>
<p style="text-align: center;"><code class="reqn">R(X,Y)Z =
  \nabla_{[X,Y]}Z - \nabla_X\nabla_Y Z + \nabla_Y\nabla_X Z.</code>
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-directional_curvature"></a>



<h4>Method <code>directional_curvature()</code></h4>

<p>Computes the directional curvature (tidal force operator).
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$directional_curvature(tangent_vec_a, tangent_vec_b, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For two vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code> and
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code> with tangent vector specified in
argument at the base point <code class="reqn">P</code>, the directional curvature, better
known in relativity as the tidal force operator, is defined by
</p>
<p style="text-align: center;"><code class="reqn">R_Y(X) = R(Y,X)Y.</code>
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-curvature_derivative"></a>



<h4>Method <code>curvature_derivative()</code></h4>

<p>Computes the covariant derivative of the curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$curvature_derivative(
  tangent_vec_a,
  tangent_vec_b,
  tangent_vec_c,
  tangent_vec_d,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_c</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_d</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For four vector fields <code class="reqn">H|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">X|_P = \mathrm{tangent\_vec\_b}</code>, <code class="reqn">Y|_P =
  \mathrm{tangent\_vec\_c}</code>, <code class="reqn">Z|_P = \mathrm{tangent\_vec\_d}</code> with
tangent vector value specified in argument at the base point <code class="reqn">P</code>,
the covariant derivative of the curvature <code class="reqn">(\nabla_H R)(X, Y) Z
  |_P</code> is computed at the base point <code class="reqn">P</code>.
</p>



<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-directional_curvature_derivative"></a>



<h4>Method <code>directional_curvature_derivative()</code></h4>

<p>Computes the covariant derivative of the directional
curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$directional_curvature_derivative(
  tangent_vec_a,
  tangent_vec_b,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For two vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code> with tangent vector value
specified in argument at the base point <code class="reqn">P</code>, the covariant
derivative (in the direction <code class="reqn">X</code>) <code class="reqn">(\nabla_X R_Y)(X) |_P =
  (\nabla_X R)(Y, X) Y |_P</code> of the directional curvature (in the
direction <code class="reqn">Y</code>) <code class="reqn">R_Y(X) = R(Y, X) Y</code> is a quadratic tensor in
<code class="reqn">X</code> and <code class="reqn">Y</code> that plays an important role in the computation of
the moments of the empirical Fréchet mean
(Pennec 2019).
</p>


<h6>References</h6>

<p>Pennec X (2019).
&ldquo;Curvature effects on the empirical mean in Riemannian and affine Manifolds: a non-asymptotic high concentration expansion in the small-sample regime.&rdquo;
<em>arXiv preprint arXiv:1906.07418</em>.
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-geodesic"></a>



<h4>Method <code>geodesic()</code></h4>

<p>Generates parametrized function for the geodesic curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$geodesic(
  initial_point,
  end_point = NULL,
  initial_tangent_vec = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>initial_point</code></dt><dd><p>Point on the manifold specifying the initial point
of the geodesic.</p>
</dd>
<dt><code>end_point</code></dt><dd><p>Point on the manifold specifying the end point of the
geodesic. Defaults to <code>NULL</code>, in which case an initial tangent vector
must be given.</p>
</dd>
<dt><code>initial_tangent_vec</code></dt><dd><p>Tangent vector at base point specifying the
initial speed of the geodesics. Defaults to <code>NULL</code>, in which case an
end point must be given and a logarithm is computed.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Geodesic curve defined by either:
</p>

<ul>
<li><p> an initial point and an initial tangent vector,
</p>
</li>
<li><p> an initial point and an end point.
</p>
</li></ul>




<h5>Returns</h5>

<p>A function representing the time-parametrized geodesic curve. If
a list of initial conditions is passed, the output list will contain,
for each time point, a list with the geodesic values each initial
condition.
</p>


<hr>
<a id="method-Connection-parallel_transport"></a>



<h4>Method <code>parallel_transport()</code></h4>

<p>Computes the parallel transport of a tangent vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$parallel_transport(
  tangent_vec,
  base_point,
  direction = NULL,
  end_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>direction</code></dt><dd><p>Tangent vector at base point specifying the point along
which the parallel transport is computed. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>end_point</code></dt><dd><p>Point on the manifold specifying the point to transport
to. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Closed-form solution for the parallel transport of a tangent
vector along the geodesic between two points <code>base_point</code> and
<code>end_point</code> or alternatively defined by <code class="reqn">t \mapsto
  \exp_\mathrm{base_point} (t \mathrm{direction})</code>.
</p>



<h5>Returns</h5>

<p>Tangent vector transported at <code class="reqn">t \mapsto
  \exp_\mathrm{base_point} (t \mathrm{direction})</code>.
</p>


<hr>
<a id="method-Connection-injectivity_radius"></a>



<h4>Method <code>injectivity_radius()</code></h4>

<p>Computes the radius of the injectivity domain.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$injectivity_radius(base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This is is the supremum of radii r for which the exponential
map is a diffeomorphism from the open ball of radius r centered at the
base point onto its image.
</p>



<h5>Returns</h5>

<p>A numeric value representing the injectivity radius.
</p>


<hr>
<a id="method-Connection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui
</p>

<hr>
<h2 id='LevelSet'>Abstract Class for Level Set Manifolds</h2><span id='topic+LevelSet'></span>

<h3>Description</h3>

<p>Class for manifolds embedded in a vector space by a submersion.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>LevelSet</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>embedding_space</code></dt><dd><p>An object of class <code><a href="#topic+VectorSpace">VectorSpace</a></code> specifying the
embedding space.</p>
</dd>
<dt><code>embedding_metric</code></dt><dd><p>???</p>
</dd>
<dt><code>submersion</code></dt><dd><p>???</p>
</dd>
<dt><code>value</code></dt><dd><p>???</p>
</dd>
<dt><code>tangent_submersion</code></dt><dd><p>???</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LevelSet-new"><code>LevelSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LevelSet-intrinsic_to_extrinsic_coords"><code>LevelSet$intrinsic_to_extrinsic_coords()</code></a>
</p>
</li>
<li> <p><a href="#method-LevelSet-extrinsic_to_intrinsic_coords"><code>LevelSet$extrinsic_to_intrinsic_coords()</code></a>
</p>
</li>
<li> <p><a href="#method-LevelSet-projection"><code>LevelSet$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-LevelSet-clone"><code>LevelSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LevelSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+LevelSet">LevelSet</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>LevelSet$new(
  dim,
  embedding_space,
  submersion,
  value,
  tangent_submersion,
  default_coords_type = "intrinsic",
  ...,
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>embedding_space</code></dt><dd><p>An object of class <code><a href="#topic+VectorSpace">VectorSpace</a></code> specifying the
embedding space.</p>
</dd>
<dt><code>submersion</code></dt><dd><p>???</p>
</dd>
<dt><code>value</code></dt><dd><p>???</p>
</dd>
<dt><code>tangent_submersion</code></dt><dd><p>???</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrinsic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+Manifold">Manifold</a></code> class.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>LevelSet</code>. Defaults to <code>NULL</code> in
which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+LevelSet">LevelSet</a></code>.
</p>


<hr>
<a id="method-LevelSet-intrinsic_to_extrinsic_coords"></a>



<h4>Method <code>intrinsic_to_extrinsic_coords()</code></h4>

<p>Converts from intrinsic to extrinsic coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>LevelSet$intrinsic_to_extrinsic_coords(point_intrinsic)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_intrinsic</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point
in the embedded manifold in intrinsic coordinates.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim_embedding</code> representing the same
point in the embedded manifold in extrinsic coordinates.
</p>


<hr>
<a id="method-LevelSet-extrinsic_to_intrinsic_coords"></a>



<h4>Method <code>extrinsic_to_intrinsic_coords()</code></h4>

<p>Converts from extrinsic to intrinsic coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>LevelSet$extrinsic_to_intrinsic_coords(point_extrinsic)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_extrinsic</code></dt><dd><p>A numeric array of shape <code>dim_embedding</code>
specifying a point in the embedded manifold in extrinsic coordinates,
i.E. in the coordinates of the embedding manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> representing the same point in the
embedded manifold in intrinsic coordinates.
</p>


<hr>
<a id="method-LevelSet-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Projects a point in embedding manifold on embedded manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>LevelSet$projection(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code>dim_embedding</code> specifying a point
in the embedding manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim_embedding</code> storing the projected
point.
</p>


<hr>
<a id="method-LevelSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LevelSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>

<hr>
<h2 id='LieGroup'>Abstract Class for Lie Groups</h2><span id='topic+LieGroup'></span>

<h3>Description</h3>

<p>Class for Lie groups. In this class, <code>point_type</code> (<code>'vector'</code> or
<code>'matrix'</code>) will be used to describe the format of the points on the Lie
group. If <code>point_type</code> is <code>'vector'</code>, the format of the inputs is
<code>dimension</code>, where <code>dimension</code> is the dimension of the Lie group. If
<code>point_type</code> is <code>'matrix'</code>, the format of the inputs is <code>c(n, n)</code> where <code>n</code>
is the parameter of <code class="reqn">\mathrm{GL}(n)</code> e.g. the amount of rows and
columns of the matrix.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>LieGroup</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lie_algebra</code></dt><dd><p>An object of class <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code> or <code>NULL</code>
representing the tangent space at the identity.</p>
</dd>
<dt><code>left_canonical_metric</code></dt><dd><p>An object of class <code>InvariantMetric</code>
representing the left invariant metric that corresponds to the
Euclidean inner product at the identity.</p>
</dd>
<dt><code>right_canonical_metric</code></dt><dd><p>An object of class <code>InvariantMetric</code>
representing the left invariant metric that corresponds to the
Euclidean inner product at the identity.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A list of objects of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LieGroup-new"><code>LieGroup$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-exp"><code>LieGroup$exp()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-exp_from_identity"><code>LieGroup$exp_from_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-exp_not_from_identity"><code>LieGroup$exp_not_from_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-log"><code>LieGroup$log()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-log_from_identity"><code>LieGroup$log_from_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-log_not_from_identity"><code>LieGroup$log_not_from_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-get_identity"><code>LieGroup$get_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-lie_bracket"><code>LieGroup$lie_bracket()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-tangent_translation_map"><code>LieGroup$tangent_translation_map()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-compose"><code>LieGroup$compose()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-jacobian_translation"><code>LieGroup$jacobian_translation()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-inverse"><code>LieGroup$inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-add_metric"><code>LieGroup$add_metric()</code></a>
</p>
</li>
<li> <p><a href="#method-LieGroup-clone"><code>LieGroup$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LieGroup-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+LieGroup">LieGroup</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$new(dim, shape, lie_algebra = NULL, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
Lie group.</p>
</dd>
<dt><code>lie_algebra</code></dt><dd><p>An object of class <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code> or <code>NULL</code>
specifying the tangent space at the identity.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+Manifold">Manifold</a></code> class.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>LieGroup</code>. Defaults to <code>NULL</code> in
which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+LieGroup">LieGroup</a></code>.
</p>


<hr>
<a id="method-LieGroup-exp"></a>



<h4>Method <code>exp()</code></h4>

<p>Exponentiates a left-invariant vector field from a base
point.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$exp(tangent_vec, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more tangent vectors at
corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more base points on the
manifold. Defaults to identity if <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The vector input is not an element of the Lie algebra, but of
the tangent space at <code>base_point</code>: if <code class="reqn">g</code> denotes <code>base_point</code>,
<code class="reqn">v</code> the tangent vector, and <code class="reqn">V = g^{-1} v</code> the associated Lie
algebra vector, then </p>
<p style="text-align: center;"><code class="reqn">\exp(v, g) = \mathrm{mul}(g, \exp(V))</code>
</p>
<p>.
Therefore, the Lie exponential is obtained when <code>base_point</code> is <code>NULL</code>,
or the identity.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group exponential of the input tangent
vector(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-exp_from_identity"></a>



<h4>Method <code>exp_from_identity()</code></h4>

<p>Compute the group exponential of tangent vector from the
identity.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$exp_from_identity(tangent_vec)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more tangent vectors at
corresponding base points.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group exponential of the input tangent
vector(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp_from_identity(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-exp_not_from_identity"></a>



<h4>Method <code>exp_not_from_identity()</code></h4>

<p>Calculate the group exponential at <code>base_point</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$exp_not_from_identity(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more tangent vectors at
corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more base points on the
manifold. Defaults to identity if <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group exponential of the input tangent
vector(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp_not_from_identity(rep(0, 3), rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-log"></a>



<h4>Method <code>log()</code></h4>

<p>Computes a left-invariant vector field bringing <code>base_point</code>
to <code>point</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$log(point, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more points on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more base points on the
manifold. Defaults to identity if <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The output is a vector of the tangent space at <code>base_point</code>, so
not a Lie algebra element if <code>base_point</code> is not the identity.
Furthermore, denoting <code>point</code> by <code class="reqn">g</code> and <code>base_point</code> by <code class="reqn">h</code>,
the output satisfies </p>
<p style="text-align: center;"><code class="reqn">g = \exp(\log(g, h), h)</code>
</p>
<p>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group logarithm of the input point(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-log_from_identity"></a>



<h4>Method <code>log_from_identity()</code></h4>

<p>Computes the group logarithm of <code>point</code> from the identity.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$log_from_identity(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more points on the
manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group logarithm of the input point(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log_from_identity(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-log_not_from_identity"></a>



<h4>Method <code>log_not_from_identity()</code></h4>

<p>Computes the group logarithm at <code>base_point</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$log_not_from_identity(point, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more points on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more base points on the
manifold. Defaults to identity if <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the group logarithm of the input point(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log_not_from_identity(rep(0, 3), rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-get_identity"></a>



<h4>Method <code>get_identity()</code></h4>

<p>Gets the identity of the group.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$get_identity()</pre></div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">\{ \mathrm{dim}, [n \times n] \}</code>
storing the identity of the Lie group.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$get_identity()
}
</pre>
</div>


<hr>
<a id="method-LieGroup-lie_bracket"></a>



<h4>Method <code>lie_bracket()</code></h4>

<p>Computes the lie bracket of two tangent vectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$lie_bracket(tangent_vector_a, tangent_vector_b, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vector_a</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n
  \times n]</code> specifying one or more tangent vectors at corresponding base
points.</p>
</dd>
<dt><code>tangent_vector_b</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n
  \times n]</code> specifying one or more tangent vectors at corresponding base
points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more base points on the
manifold. Defaults to identity if <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For matrix Lie groups with tangent vectors <code class="reqn">A</code> and <code class="reqn">B</code>
at the same base point <code class="reqn">P</code>, this is given by (translate to
identity, compute commutator, go back): </p>
<p style="text-align: center;"><code class="reqn">[A,B] = A_P^{-1}B -
  B_P^{-1}A</code>
</p>
<p>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> storing
the Lie bracket of the two input tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$lie_bracket(diag(0, 3), diag(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-tangent_translation_map"></a>



<h4>Method <code>tangent_translation_map()</code></h4>

<p>Computes the push-forward map by the left/right translation.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$tangent_translation_map(
  point,
  left_or_right = "left",
  inverse = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more points on the
manifold.</p>
</dd>
<dt><code>left_or_right</code></dt><dd><p>A character string specifying whether to compute the map
for the left or right translation. Choices are <code>"left"</code> or <code style="white-space: pre;">&#8288;"right&#8288;</code>.
Defaults to <code>"left"</code>.</p>
</dd>
<dt><code>inverse</code></dt><dd><p>A boolean specifying whether to inverse the Jacobian
matrix. If set to <code>TRUE</code>, the push forward by the translation by the
inverse of the point is returned. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Computes the push-forward map of the left/right translation by
the point. It corresponds to the tangent map, or differential of the
group multiplication by the point or its inverse. For groups with a
vector representation, it is only implemented at identity, but it can
be used at other points with <code>inverse = TRUE</code>. This method wraps the
Jacobian translation which actually computes the matrix representation
of the map.
</p>



<h5>Returns</h5>

<p>A function computing the tangent map of the left/right
translation by <code>point</code>. It can be applied to tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tangent_translation_map(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-compose"></a>



<h4>Method <code>compose()</code></h4>

<p>Performs function composition corresponding to the Lie
group.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$compose(point_a, point_b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_a</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more left factors in
the product.</p>
</dd>
<dt><code>point_b</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more right factors in
the product.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the product of <code>point_a</code> and <code>point_b</code> along the
first dimension.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$compose(rep(0, 3), rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-jacobian_translation"></a>



<h4>Method <code>jacobian_translation()</code></h4>

<p>Computes the Jacobian of left/right translation by a point.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$jacobian_translation(point, left_or_right = "left")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, [n \times n] \}]</code> specifying one or more points on the
manifold.</p>
</dd>
<dt><code>left_or_right</code></dt><dd><p>A character string specifying whether to compute the map
for the left or right translation. Choices are <code>"left"</code> or <code style="white-space: pre;">&#8288;"right&#8288;</code>.
Defaults to <code>"left"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \mathrm{dim} \times
  \mathrm{dim}]</code> storing the Jacobian of the left/right translation by
<code>point</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$jacobian_translation(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-inverse"></a>



<h4>Method <code>inverse()</code></h4>

<p>Computes the inverse law of the Lie group.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$inverse(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim},
[n \times n] \}]</code> specifying one or more points to be inverted.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n
  \times n] \}]</code> storing the inverted points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$inverse(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-LieGroup-add_metric"></a>



<h4>Method <code>add_metric()</code></h4>

<p>Adds a metric to the class <code style="white-space: pre;">&#8288;$metrics&#8288;</code> attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$add_metric(metric)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metric</code></dt><dd><p>An object of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The class itself invisibly.
</p>


<hr>
<a id="method-LieGroup-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LieGroup$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `LieGroup$exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$exp_from_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp_from_identity(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$exp_not_from_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$exp_not_from_identity(rep(0, 3), rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$log_from_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log_from_identity(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$log_not_from_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$log_not_from_identity(rep(0, 3), rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$get_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$get_identity()
}

## ------------------------------------------------
## Method `LieGroup$lie_bracket`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$lie_bracket(diag(0, 3), diag(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$tangent_translation_map`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tangent_translation_map(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$compose`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$compose(rep(0, 3), rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$jacobian_translation`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$jacobian_translation(rep(0, 3))
}

## ------------------------------------------------
## Method `LieGroup$inverse`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$inverse(rep(0, 3))
}
</code></pre>

<hr>
<h2 id='Manifold'>Abstract Class for Manifolds</h2><span id='topic+Manifold'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the base <code><a href="#topic+Manifold">Manifold</a></code>
class. In other words, a topological space that locally resembles Euclidean
space near each point.
</p>


<h3>Super class</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code>Manifold</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>metric</code></dt><dd><p>A <a href="#topic+RiemannianMetric">RiemannianMetric</a> object specifying the metric to use on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Dedaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>default_point_type</code></dt><dd><p>A string specifying the point type. Choices are
<code>vector</code> or <code>matrix</code>. It is automatically determined depending on the
manifold.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Manifold-new"><code>Manifold$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-belongs"><code>Manifold$belongs()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-is_tangent"><code>Manifold$is_tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-to_tangent"><code>Manifold$to_tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-random_point"><code>Manifold$random_point()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-regularize"><code>Manifold$regularize()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-set_metric"><code>Manifold$set_metric()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-random_tangent_vec"><code>Manifold$random_tangent_vec()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-clone"><code>Manifold$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Manifold-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+Manifold">Manifold</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$new(
  dim,
  shape = NULL,
  metric = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>metric</code></dt><dd><p>A <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> object specifying the metric to use
on the manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrinsic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>Manifold</code>. Defaults to <code>NULL</code> in
which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+Manifold">Manifold</a></code>.
</p>


<hr>
<a id="method-Manifold-belongs"></a>



<h4>Method <code>belongs()</code></h4>

<p>Evaluates if a point belongs to the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$belongs(point, atol = gs$backend$atol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
\{\mathrm{dim}\}]</code> specifying one or more points to be checked.</p>
</dd>
<dt><code>atol</code></dt><dd><p>A numeric value specifying the absolute tolerance for
checking. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A boolean value or vector storing whether the corresponding
points belong to the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$belongs(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-is_tangent"></a>



<h4>Method <code>is_tangent()</code></h4>

<p>Checks whether a vector is tangent at a base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$is_tangent(vector, base_point = NULL, atol = gs$backend$atol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
[\mathrm{dim}]]</code> specifying one or more vectors to be checked.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more base points on the manifold.
Defaults to <code>NULL</code> in which case the identity is used.</p>
</dd>
<dt><code>atol</code></dt><dd><p>A numeric value specifying the absolute tolerance for
checking. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A boolean value or vector storing whether the corresponding
points are tangent to the manifold at corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$is_tangent(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-to_tangent"></a>



<h4>Method <code>to_tangent()</code></h4>

<p>Projects a vector to a tangent space of the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$to_tangent(vector, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more vectors to project on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more base points on the manifold.
Defaults to <code>NULL</code> in which case the identity is used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing the corresponding projections onto the manifold at
corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$to_tangent(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-random_point"></a>



<h4>Method <code>random_point()</code></h4>

<p>Samples random points on the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$random_point(n_samples = 1, bound = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_samples</code></dt><dd><p>An integer value specifying the number of samples to be
drawn. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>bound</code></dt><dd><p>A numeric value specifying the bound of the interval in
which to sample for non-compact manifolds. Defaults to <code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If the manifold is compact, a uniform distribution is used.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing a sample of points on the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  # spd3$random_point(10) # TO DO: uncomment when bug fixed in gs
}
</pre>
</div>


<hr>
<a id="method-Manifold-regularize"></a>



<h4>Method <code>regularize()</code></h4>

<p>Regularizes a point to the canonical representation for the
manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$regularize(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
[\mathrm{dim}]]</code> specifying one or more points on the manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the corresponding
regularized points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$regularize(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-set_metric"></a>



<h4>Method <code>set_metric()</code></h4>

<p>Sets the Riemannian Metric associated to the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$set_metric(metric)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metric</code></dt><dd><p>An object of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The <a href="#topic+Manifold">Manifold</a> class itself invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$metric
  spd3$set_metric(SPDMetricBuresWasserstein$new(n = 3))
  spd3$metric
}
</pre>
</div>


<hr>
<a id="method-Manifold-random_tangent_vec"></a>



<h4>Method <code>random_tangent_vec()</code></h4>

<p>Generates a random tangent vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$random_tangent_vec(base_point, n_samples = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
\{\mathrm{dim}\}]</code> specifying one or more base points on the manifold.</p>
</dd>
<dt><code>n_samples</code></dt><dd><p>An integer value specifying the number of samples to be
drawn. Defaults to <code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing a sample of vectors that are tangent to the manifold at
corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$random_tangent_vec(diag(1, 3), 10)
}
</pre>
</div>


<hr>
<a id="method-Manifold-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Manifold$belongs`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$belongs(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$is_tangent`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$is_tangent(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$to_tangent`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$to_tangent(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$random_point`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  # spd3$random_point(10) # TO DO: uncomment when bug fixed in gs
}

## ------------------------------------------------
## Method `Manifold$regularize`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$regularize(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$set_metric`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$metric
  spd3$set_metric(SPDMetricBuresWasserstein$new(n = 3))
  spd3$metric
}

## ------------------------------------------------
## Method `Manifold$random_tangent_vec`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$random_tangent_vec(diag(1, 3), 10)
}
</code></pre>

<hr>
<h2 id='MatrixLieAlgebra'>Abstract Class for Matrix Lie Algebras</h2><span id='topic+MatrixLieAlgebra'></span>

<h3>Description</h3>

<p>There are two main forms of representation for elements of a
matrix Lie algebra implemented here. The first one is as a matrix, as
elements of <code class="reqn">R^{n \times n}</code>. The second is by choosing a basis and
remembering the coefficients of an element in that basis. This basis will
be provided in child classes (e.g. <code>SkewSymmetricMatrices</code>).
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+VectorSpace">rgeomstats::VectorSpace</a></code> -&gt; <code>MatrixLieAlgebra</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value representing the number of rows and columns in
the matrix representation of the Lie algebra.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MatrixLieAlgebra-new"><code>MatrixLieAlgebra$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieAlgebra-baker_campbell_hausdorff"><code>MatrixLieAlgebra$baker_campbell_hausdorff()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieAlgebra-basis_representation"><code>MatrixLieAlgebra$basis_representation()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieAlgebra-matrix_representation"><code>MatrixLieAlgebra$matrix_representation()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieAlgebra-clone"><code>MatrixLieAlgebra$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="VectorSpace" data-id="projection"><a href='../../rgeomstats/html/VectorSpace.html#method-VectorSpace-projection'><code>rgeomstats::VectorSpace$projection()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MatrixLieAlgebra-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieAlgebra$new(dim, n, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the Lie algebra
as a real vector space.</p>
</dd>
<dt><code>n</code></dt><dd><p>An integer value representing the number of rows and columns in
the matrix representation of the Lie algebra.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+VectorSpace">VectorSpace</a></code> and  <code><a href="#topic+Manifold">Manifold</a></code> classes.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>MatrixLieAlgebra</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code>.
</p>


<hr>
<a id="method-MatrixLieAlgebra-baker_campbell_hausdorff"></a>



<h4>Method <code>baker_campbell_hausdorff()</code></h4>

<p>Calculates the Baker-Campbell-Hausdorff approximation of
given order.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieAlgebra$baker_campbell_hausdorff(matrix_a, matrix_b, order = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>matrix_a</code></dt><dd><p>A numeric array of shape <code class="reqn">... \times n \times n</code>
specifying a matrix or a sample of matrices.</p>
</dd>
<dt><code>matrix_b</code></dt><dd><p>A numeric array of shape <code class="reqn">... \times n \times n</code>
specifying a matrix or a sample of matrices.</p>
</dd>
<dt><code>order</code></dt><dd><p>An integer value specifying the order to which the
approximation is calculated. Note that this is NOT the same as using
only <code class="reqn">e_i</code> with <code class="reqn">i &lt; \mathrm{order}</code>. Defaults to <code>2L</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The implementation is based on
Casas and Murua (2009) with the
pre-computed constants taken from
 (). Our coefficients are
truncated to enable us to calculate BCH up to order <code class="reqn">15</code>. This
represents </p>
<p style="text-align: center;"><code class="reqn">Z = \log \left( \exp(X) \exp(Y) \right)</code>
</p>
<p> as an
infinite linear combination of the form </p>
<p style="text-align: center;"><code class="reqn">Z = \sum_i z_i e_i</code>
</p>
<p> where
<code class="reqn">z_i</code> are rational numbers and <code class="reqn">e_i</code> are iterated Lie brackets
starting with <code class="reqn">e_1 = X</code>, <code class="reqn">e_2 = Y</code>, each <code class="reqn">e_i</code> is given by
some <code class="reqn">(i^\prime,i^{\prime\prime})</code> such that <code class="reqn">e_i =
  [e_i^\prime, e_i^{\prime\prime}]</code>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">... \times n \times n</code> storing a
matrix or a sample of matrices corresponding to the BCH
approximation(s) between input matrices.
</p>


<hr>
<a id="method-MatrixLieAlgebra-basis_representation"></a>



<h4>Method <code>basis_representation()</code></h4>

<p>Computes the coefficients of matrices in the given basis.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieAlgebra$basis_representation(matrix_representation)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>matrix_representation</code></dt><dd><p>A numeric array of shape <code class="reqn">... \times n
  \times n</code> specifying a matrix or a sample of matrices in its matrix
representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">... \times \mathrm{dim}</code> storing a
matrix or a sample of matrices in its basis representation.
</p>


<hr>
<a id="method-MatrixLieAlgebra-matrix_representation"></a>



<h4>Method <code>matrix_representation()</code></h4>

<p>Compute the matrix representation for the given basis
coefficients.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieAlgebra$matrix_representation(basis_representation)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>basis_representation</code></dt><dd><p>A numeric array of shape <code class="reqn">... \times
  \mathrm{dim}</code> storing a matrix or a sample of matrices in its basis
representation.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Sums the basis elements according to the coefficients given in
basis representation.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">... \times n \times n</code> specifying a
matrix or a sample of matrices in its matrix representation.
</p>


<hr>
<a id="method-MatrixLieAlgebra-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieAlgebra$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Stefan Heyder
</p>

<hr>
<h2 id='MatrixLieGroup'>Abstract Class for Matrix Lie Groups</h2><span id='topic+MatrixLieGroup'></span>

<h3>Description</h3>

<p>Class for matrix Lie groups.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>MatrixLieGroup</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lie_algebra</code></dt><dd><p>An object of class <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code> or <code>NULL</code>
representing the tangent space at the identity.</p>
</dd>
<dt><code>n</code></dt><dd><p>The size of the <code class="reqn">n \times n</code> matrix elements.</p>
</dd>
<dt><code>left_canonical_metric</code></dt><dd><p>An object of class <code>InvariantMetric</code>
representing the left invariant metric that corresponds to the
Euclidean inner product at the identity.</p>
</dd>
<dt><code>right_canonical_metric</code></dt><dd><p>An object of class <code>InvariantMetric</code>
representing the left invariant metric that corresponds to the
Euclidean inner product at the identity.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MatrixLieGroup-new"><code>MatrixLieGroup$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-exp"><code>MatrixLieGroup$exp()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-log"><code>MatrixLieGroup$log()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-get_identity"><code>MatrixLieGroup$get_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-lie_bracket"><code>MatrixLieGroup$lie_bracket()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-tangent_translation_map"><code>MatrixLieGroup$tangent_translation_map()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-compose"><code>MatrixLieGroup$compose()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-inverse"><code>MatrixLieGroup$inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-MatrixLieGroup-clone"><code>MatrixLieGroup$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MatrixLieGroup-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+MatrixLieGroup">MatrixLieGroup</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$new(dim, n, lie_algebra = NULL, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>n</code></dt><dd><p>The size of the <code class="reqn">n \times n</code> matrix elements.</p>
</dd>
<dt><code>lie_algebra</code></dt><dd><p>An object of class <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code> or <code>NULL</code>
representing the tangent space at the identity.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+Manifold">Manifold</a></code> class.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>MatrixLieGroup</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+MatrixLieGroup">MatrixLieGroup</a></code>.
</p>


<hr>
<a id="method-MatrixLieGroup-exp"></a>



<h4>Method <code>exp()</code></h4>

<p>Exponentiates a left-invariant vector field from a base
point.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$exp(tangent_vec, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times
  n]</code> specifying one or more tangent vectors at corresponding base
points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more base points on the manifold. Defaults to identity if
<code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The vector input is not an element of the Lie algebra, but of
the tangent space at <code>base_point</code>: if <code class="reqn">g</code> denotes <code>base_point</code>,
<code class="reqn">v</code> the tangent vector, and <code class="reqn">V = g^{-1} v</code> the associated Lie
algebra vector, then </p>
<p style="text-align: center;"><code class="reqn">\exp(v, g) = \mathrm{mul}(g, \exp(V))</code>
</p>
<p>.
Therefore, the Lie exponential is obtained when <code>base_point</code> is <code>NULL</code>,
or the identity.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> storing
the left multiplication of the Lie exponential of the input tangent
vectors with the corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  # so3$exp(diag(1, 3)) # TO DO: fix in gs
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-log"></a>



<h4>Method <code>log()</code></h4>

<p>Computes a left-invariant vector field bringing <code>base_point</code>
to <code>point</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$log(point, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more base points on the manifold. Defaults to identity if
<code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The output is a vector of the tangent space at <code>base_point</code>, so
not a Lie algebra element if <code>base_point</code> is not the identity.
Furthermore, denoting <code>point</code> by <code class="reqn">g</code> and <code>base_point</code> by <code class="reqn">h</code>,
the output satisfies </p>
<p style="text-align: center;"><code class="reqn">g = \exp(\log(g, h), h)</code>
</p>
<p>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> such
that its Lie exponential at corresponding base points matches
corresponding points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$log(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-get_identity"></a>



<h4>Method <code>get_identity()</code></h4>

<p>Gets the identity of the group.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$get_identity()</pre></div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">n \times n</code> storing the identity
of the Lie group.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$get_identity()
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-lie_bracket"></a>



<h4>Method <code>lie_bracket()</code></h4>

<p>Computes the lie bracket of two tangent vectors.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$lie_bracket(
  tangent_vector_a,
  tangent_vector_b,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vector_a</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n
  \times n]</code> specifying one or more tangent vectors at corresponding base
points.</p>
</dd>
<dt><code>tangent_vector_b</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n
  \times n]</code> specifying one or more tangent vectors at corresponding base
points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more base points on the manifold. Defaults to identity if
<code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For matrix Lie groups with tangent vectors <code class="reqn">A</code> and <code class="reqn">B</code>
at the same base point <code class="reqn">P</code>, this is given by (translate to
identity, compute commutator, go back): </p>
<p style="text-align: center;"><code class="reqn">[A,B] = A_P^{-1}B -
  B_P^{-1}A</code>
</p>
<p>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> storing
the Lie bracket of the two input tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$lie_bracket(diag(0, 3), diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-tangent_translation_map"></a>



<h4>Method <code>tangent_translation_map()</code></h4>

<p>Computes the push-forward map by the left/right translation.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$tangent_translation_map(
  point,
  left_or_right = "left",
  inverse = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim},
  [n \times n] \} ]</code> specifying one or more points at which to compute
the map.</p>
</dd>
<dt><code>left_or_right</code></dt><dd><p>A character string specifying whether to compute the
map for the left or right translation. Choices are <code>"left"</code> or
<code style="white-space: pre;">&#8288;"right&#8288;</code>. Defaults to <code>"left"</code>.</p>
</dd>
<dt><code>inverse</code></dt><dd><p>A boolean specifying whether to inverse the Jacobian
matrix. If set to <code>TRUE</code>, the push forward by the translation by the
inverse of the point is returned. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Computes the push-forward map of the left/right translation by
the point. It corresponds to the tangent map, or differential of the
group multiplication by the point or its inverse. For groups with a
vector representation, it is only implemented at identity, but it can
be used at other points with <code>inverse = TRUE</code>. This method wraps the
Jacobian translation which actually computes the matrix representation
of the map.
</p>



<h5>Returns</h5>

<p>A function taking as argument a numeric array <code>tangent_vec</code> of
shape <code class="reqn">[\dots \times \{ \mathrm{dim}, [n \times n] \} ]</code> specifying
one or more tangent vectors and returning a numeric array of shape
<code class="reqn">[\dots \times \{ \mathrm{dim}, [n \times n] \} ]</code> storing the
result of the tangent mapping of the left/right translation of input
tangent points by corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  tangent_map &lt;- so3$tangent_translation_map(diag(1, 3))
  tangent_map(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-compose"></a>



<h4>Method <code>compose()</code></h4>

<p>Performs function composition corresponding to the Lie
group.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$compose(point_a, point_b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_a</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, n \times n \}]</code> specifying one or more left factors in
the product.</p>
</dd>
<dt><code>point_b</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim}, n \times n \}]</code> specifying one or more right factors in
the product.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim}, n
  \times n \}]</code> storing the product of <code>point_a</code> and <code>point_b</code> along the
first dimension.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$compose(diag(1, 3), diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-inverse"></a>



<h4>Method <code>inverse()</code></h4>

<p>Computes the inverse law of the Lie group.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$inverse(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim},
n \times n \}]</code> specifying one or more points to be inverted.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the inverted points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$inverse(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-MatrixLieGroup-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MatrixLieGroup$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `MatrixLieGroup$exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  # so3$exp(diag(1, 3)) # TO DO: fix in gs
}

## ------------------------------------------------
## Method `MatrixLieGroup$log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$log(diag(1, 3))
}

## ------------------------------------------------
## Method `MatrixLieGroup$get_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$get_identity()
}

## ------------------------------------------------
## Method `MatrixLieGroup$lie_bracket`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$lie_bracket(diag(0, 3), diag(1, 3))
}

## ------------------------------------------------
## Method `MatrixLieGroup$tangent_translation_map`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  tangent_map &lt;- so3$tangent_translation_map(diag(1, 3))
  tangent_map(diag(1, 3))
}

## ------------------------------------------------
## Method `MatrixLieGroup$compose`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$compose(diag(1, 3), diag(1, 3))
}

## ------------------------------------------------
## Method `MatrixLieGroup$inverse`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$inverse(diag(1, 3))
}
</code></pre>

<hr>
<h2 id='NFoldManifold'>Class for N-Fold Product Manifolds</h2><span id='topic+NFoldManifold'></span>

<h3>Description</h3>

<p>Class for an <code class="reqn">n</code>-fold product manifold <code class="reqn">M^n</code>. It defines
a manifold as the product manifold of <code class="reqn">n</code> copies of a given base
manifold <code class="reqn">M</code>.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>NFoldManifold</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NFoldManifold-new"><code>NFoldManifold$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NFoldManifold-clone"><code>NFoldManifold$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NFoldManifold-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+NFoldManifold">NFoldManifold</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>NFoldManifold$new(
  base_manifold,
  n_copies,
  metric = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_manifold</code></dt><dd><p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> specifying the base manifold to
copy.</p>
</dd>
<dt><code>n_copies</code></dt><dd><p>An integer value specifying the number of replication of
the base manifold.</p>
</dd>
<dt><code>metric</code></dt><dd><p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> specifying the base metric to use.
Defaults to <code>NULL</code> which uses the Riemannian metric.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>"intrinsic"</code> or <code>"extrinsic"</code>. Defaults to <code>"intrinsic"</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>NFoldManifold</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+NFoldManifold">NFoldManifold</a></code> <a href="R6.html#topic+R6Class">R6::R6Class</a> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  nfm &lt;- NFoldManifold$new(
    base_manifold = SPDMatrix(n = 3),
    n_copies = 3
  )
  nfm
}
</pre>
</div>


<hr>
<a id="method-NFoldManifold-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NFoldManifold$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `NFoldManifold$new`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  nfm &lt;- NFoldManifold$new(
    base_manifold = SPDMatrix(n = 3),
    n_copies = 3
  )
  nfm
}
</code></pre>

<hr>
<h2 id='OpenSet'>Abstract Class for Open Set Manifolds</h2><span id='topic+OpenSet'></span>

<h3>Description</h3>

<p>Class for manifolds that are open sets of a vector space. In
this case, tangent vectors are identified with vectors of the ambient
space.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>OpenSet</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ambient_space</code></dt><dd><p>An object of class <code><a href="#topic+VectorSpace">VectorSpace</a></code> specifying the
ambient space.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OpenSet-new"><code>OpenSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OpenSet-projection"><code>OpenSet$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-OpenSet-clone"><code>OpenSet$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OpenSet-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+OpenSet">OpenSet</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenSet$new(dim, ambient_space, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>ambient_space</code></dt><dd><p>An object of class <code><a href="#topic+VectorSpace">VectorSpace</a></code> specifying the
ambient space.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+Manifold">Manifold</a></code> class.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>OpenSet</code>. Defaults to <code>NULL</code> in
which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+OpenSet">OpenSet</a></code>.
</p>


<hr>
<a id="method-OpenSet-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Project a point in the ambient space onto the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenSet$projection(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
  \{\mathrm{dim}\}]</code> specifying one or more vectors in the ambient space
of the manifold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the corresponding
projections onto the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$projection(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-OpenSet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OpenSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>See Also</h3>

<p>SPDMatrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `OpenSet$projection`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$projection(diag(1, 3))
}
</code></pre>

<hr>
<h2 id='RiemannianMetric'>Abstract Class for Riemannian Metrics</h2><span id='topic+RiemannianMetric'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the base
<code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> class. This is an abstract class for Riemannian and
pseudo-Riemannian metrics which are the associated Levi-Civita connection
on the tangent bundle.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Connection">rgeomstats::Connection</a></code> -&gt; <code>RiemannianMetric</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>signature</code></dt><dd><p>An integer vector specifying the signature of the
metric.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RiemannianMetric-new"><code>RiemannianMetric$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-metric_matrix"><code>RiemannianMetric$metric_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-cometric_matrix"><code>RiemannianMetric$cometric_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-inner_product_derivative_matrix"><code>RiemannianMetric$inner_product_derivative_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-inner_product"><code>RiemannianMetric$inner_product()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-inner_coproduct"><code>RiemannianMetric$inner_coproduct()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-hamiltonian"><code>RiemannianMetric$hamiltonian()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-squared_norm"><code>RiemannianMetric$squared_norm()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-norm"><code>RiemannianMetric$norm()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-normalize"><code>RiemannianMetric$normalize()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-random_unit_tangent_vec"><code>RiemannianMetric$random_unit_tangent_vec()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-squared_dist"><code>RiemannianMetric$squared_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-dist"><code>RiemannianMetric$dist()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-dist_broadcast"><code>RiemannianMetric$dist_broadcast()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-dist_pairwise"><code>RiemannianMetric$dist_pairwise()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-diameter"><code>RiemannianMetric$diameter()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-closest_neighbor_index"><code>RiemannianMetric$closest_neighbor_index()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-normal_basis"><code>RiemannianMetric$normal_basis()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-sectional_curvature"><code>RiemannianMetric$sectional_curvature()</code></a>
</p>
</li>
<li> <p><a href="#method-RiemannianMetric-clone"><code>RiemannianMetric$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="christoffels"><a href='../../rgeomstats/html/Connection.html#method-Connection-christoffels'><code>rgeomstats::Connection$christoffels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature'><code>rgeomstats::Connection$curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature_derivative'><code>rgeomstats::Connection$curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature'><code>rgeomstats::Connection$directional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature_derivative'><code>rgeomstats::Connection$directional_curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="exp"><a href='../../rgeomstats/html/Connection.html#method-Connection-exp'><code>rgeomstats::Connection$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic'><code>rgeomstats::Connection$geodesic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic_equation"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic_equation'><code>rgeomstats::Connection$geodesic_equation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="injectivity_radius"><a href='../../rgeomstats/html/Connection.html#method-Connection-injectivity_radius'><code>rgeomstats::Connection$injectivity_radius()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="ladder_parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-ladder_parallel_transport'><code>rgeomstats::Connection$ladder_parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="log"><a href='../../rgeomstats/html/Connection.html#method-Connection-log'><code>rgeomstats::Connection$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-parallel_transport'><code>rgeomstats::Connection$parallel_transport()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RiemannianMetric-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$new(
  dim,
  shape = NULL,
  signature = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt><dd><p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>signature</code></dt><dd><p>An integer vector specifying the signature of the
metric. Defaults to <code>c(dim, 0L)</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt><dd><p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>RiemannianMetric</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code>.
</p>


<hr>
<a id="method-RiemannianMetric-metric_matrix"></a>



<h4>Method <code>metric_matrix()</code></h4>

<p>Metric matrix at the tangent space at a base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$metric_matrix(base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code style="white-space: pre;">&#8288;dim x dim&#8288;</code> storing the inner-product
matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$metric_matrix()
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-cometric_matrix"></a>



<h4>Method <code>cometric_matrix()</code></h4>

<p>Inner co-product matrix at the cotangent space at a base
point. This represents the cometric matrix, i.e. the inverse of the
metric matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$cometric_matrix(base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code style="white-space: pre;">&#8288;dim x dim&#8288;</code> storing the inverse of the
inner-product matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$cometric_matrix()
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-inner_product_derivative_matrix"></a>



<h4>Method <code>inner_product_derivative_matrix()</code></h4>

<p>Compute derivative of the inner prod matrix at base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$inner_product_derivative_matrix(base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code style="white-space: pre;">&#8288;dim x dim&#8288;</code> storing the derivative of
the inverse of the inner-product matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$inner_product_derivative_matrix()
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-inner_product"></a>



<h4>Method <code>inner_product()</code></h4>

<p>Inner product between two tangent vectors at a base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$inner_product(tangent_vec_a, tangent_vec_b, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent
vector at base point.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a tangent
vector at base point.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A scalar value representing the inner product between the two
input tangent vectors at the input base point.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$inner_product(diag(0, 3), diag(1, 3), base_point = diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-inner_coproduct"></a>



<h4>Method <code>inner_coproduct()</code></h4>

<p>Computes inner coproduct between two cotangent vectors at
base point. This is the inner product associated to the cometric
matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$inner_coproduct(
  cotangent_vec_a,
  cotangent_vec_b,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cotangent_vec_a</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a
cotangent vector at base point.</p>
</dd>
<dt><code>cotangent_vec_b</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a
cotangent vector at base point.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A scalar value representing the inner coproduct between the two
input cotangent vectors at the input base point.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$inner_coproduct(diag(0, 3), diag(1, 3), base_point = diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-hamiltonian"></a>



<h4>Method <code>hamiltonian()</code></h4>

<p>Computes the Hamiltonian energy associated to the cometric.
The Hamiltonian at state <code class="reqn">(q, p)</code> is defined by </p>
<p style="text-align: center;"><code class="reqn">H(q, p) =
  \frac{1}{2} \langle p, p \rangle_q,</code>
</p>
<p> where <code class="reqn">\langle \cdot, \cdot
  \rangle_q</code> is the cometric at <code class="reqn">q</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$hamiltonian(state)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>A list with two components: (i) a numeric array of shape
<code>dim</code> specifying the <em>position</em> which is a point on the manifold and
(ii) a numeric array of shape <code>dim</code> specifying the <em>momentum</em> which is
a cotangent vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric value representing the Hamiltonian energy at <code>state</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$hamiltonian()
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-squared_norm"></a>



<h4>Method <code>squared_norm()</code></h4>

<p>Computes the square of the norm of a vector. Squared norm of
a vector associated to the inner product at the tangent space at a base
point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$squared_norm(vector, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a vector.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric value representing the squared norm of the input
vector.
</p>
<p>if (reticulate::py_module_available(&quot;geomstats&quot;)) 
mt &lt;- SPDMetricLogEuclidean$new(n = 3)
mt$squared_norm(diag(0, 3), diag(1, 3))

</p>


<hr>
<a id="method-RiemannianMetric-norm"></a>



<h4>Method <code>norm()</code></h4>

<p>Computes the norm of a vector associated to the inner
product at the tangent space at a base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$norm(vector, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a vector.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This only works for positive-definite Riemannian metrics and
inner products.
</p>



<h5>Returns</h5>

<p>A numeric value representing the norm of the input vector.
</p>
<p>if (reticulate::py_module_available(&quot;geomstats&quot;)) 
mt &lt;- SPDMetricLogEuclidean$new(n = 3)
mt$norm(diag(0, 3), diag(1, 3))

</p>


<hr>
<a id="method-RiemannianMetric-normalize"></a>



<h4>Method <code>normalize()</code></h4>

<p>Normalizes a tangent vector at a given point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$normalize(vector, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a vector.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the normalized version of
the input tangent vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$normalize(diag(2, 3), diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-random_unit_tangent_vec"></a>



<h4>Method <code>random_unit_tangent_vec()</code></h4>

<p>Generates a random unit tangent vector at a given point.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$random_unit_tangent_vec(base_point = NULL, n_vectors = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>n_vectors</code></dt><dd><p>An integer value specifying the number of vectors to be
generated at <code>base_point</code>. For vectorization purposes, <code>n_vectors</code> can
be greater than 1 <em>iff</em> <code>base_point</code> corresponds to a single point.
Defaults to <code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>c(n_vectors, dim)</code> storing random unit
tangent vectors at <code>base_point</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$random_unit_tangent_vec(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-squared_dist"></a>



<h4>Method <code>squared_dist()</code></h4>

<p>Squared geodesic distance between two points.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$squared_dist(point_a, point_b, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_a</code></dt><dd><p>A numeric array of shape <code>dim</code> on the manifold.</p>
</dd>
<dt><code>point_b</code></dt><dd><p>A numeric array of shape <code>dim</code> on the manifold.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra parameters to be passed to the <code style="white-space: pre;">&#8288;$log()&#8288;</code> method of the
parent <code><a href="#topic+Connection">Connection</a></code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric value storing the squared geodesic distance between the
two input points.
</p>
<p>if (reticulate::py_module_available(&quot;geomstats&quot;)) 
mt &lt;- SPDMetricLogEuclidean$new(n = 3)
mt$squared_dist(diag(1, 3), diag(1, 3))

</p>


<hr>
<a id="method-RiemannianMetric-dist"></a>



<h4>Method <code>dist()</code></h4>

<p>Geodesic distance between two points.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$dist(point_a, point_b, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_a</code></dt><dd><p>A numeric array of shape <code>dim</code> on the manifold.</p>
</dd>
<dt><code>point_b</code></dt><dd><p>A numeric array of shape <code>dim</code> on the manifold.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra parameters to be passed to the <code style="white-space: pre;">&#8288;$log()&#8288;</code> method of the
parent <code><a href="#topic+Connection">Connection</a></code> class.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>It only works for positive definite Riemannian metrics.
</p>



<h5>Returns</h5>

<p>A numeric value storing the geodesic distance between the two
input points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$dist(diag(1, 3), diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-dist_broadcast"></a>



<h4>Method <code>dist_broadcast()</code></h4>

<p>Computes the geodesic distance between points.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$dist_broadcast(points_a, points_b)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>points_a</code></dt><dd><p>A numeric array of shape <code>c(n_samples_a, dim)</code> specifying
a set of points on the manifold.</p>
</dd>
<dt><code>points_b</code></dt><dd><p>A numeric array of shape <code>c(n_samples_b, dim)</code> specifying
a set of points on the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>n_samples_a == n_samples_b</code> then <code>dist</code> is the element-wise
distance result of a point in <code>points_a</code> with the point from <code>points_b</code>
of the same index. If <code>n_samples_a != n_samples_b</code> then <code>dist</code> is the
result of applying geodesic distance for each point from <code>points_a</code> to
all points from <code>points_b</code>.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>c(n_samples_a, dim)</code> if <code>n_samples_a == n_samples_b</code> or of shape <code>c(n_samples_a, n_samples_b, dim)</code> if
<code>n_samples_a != n_samples_b</code> storing the geodesic distance between
points in set A and points in set B.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$dist(diag(1, 3), diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-RiemannianMetric-dist_pairwise"></a>



<h4>Method <code>dist_pairwise()</code></h4>

<p>Computes the pairwise distance between points.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$dist_pairwise(points, n_jobs = 1, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>points</code></dt><dd><p>A numeric array of shape <code>c(n_samples, dim)</code> specifying a
set of points on the manifold.</p>
</dd>
<dt><code>n_jobs</code></dt><dd><p>An integer value specifying the number of cores for
parallel computation. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra parameters to be passed tothe  <code>joblib.Parallel</code> Python
class. See <a href="https://joblib.readthedocs.io/en/latest/">joblib documentation</a> for details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric matrix of shape <code>c(n_samples, n_samples)</code> storing the
pairwise geodesic distances between all the points.
</p>


<hr>
<a id="method-RiemannianMetric-diameter"></a>



<h4>Method <code>diameter()</code></h4>

<p>Computes the diameter of set of points on a manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$diameter(points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>points</code></dt><dd><p>A numeric array of shape <code>c(n_samples, dim)</code> specifying a
set of points on the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The diameter is the maximum over all pairwise distances.
</p>



<h5>Returns</h5>

<p>A numeric value representing the largest distance between any two
points in the input set.
</p>


<hr>
<a id="method-RiemannianMetric-closest_neighbor_index"></a>



<h4>Method <code>closest_neighbor_index()</code></h4>

<p>Finds the closest neighbor to a point among a set of
neighbors.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$closest_neighbor_index(point, neighbors)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on the
manifold.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A numeric array of shape <code>c(n_neighbors, dim)</code>
specifying a set of neighboring points for the input <code>point</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An integer value representing the index of the neighbor in
<code>neighbors</code> that is closest to <code>point</code>.
</p>


<hr>
<a id="method-RiemannianMetric-normal_basis"></a>



<h4>Method <code>normal_basis()</code></h4>

<p>Normalizes the basis with respect to the metric. This
corresponds to a renormalization of each basis vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$normal_basis(basis, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>basis</code></dt><dd><p>A numeric array of shape <code>c(dim, dim)</code> specifying a basis.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>c(dim, n, n)</code> storing the normal basis.
</p>


<hr>
<a id="method-RiemannianMetric-sectional_curvature"></a>



<h4>Method <code>sectional_curvature()</code></h4>

<p>Computes the sectional curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$sectional_curvature(
  tangent_vec_a,
  tangent_vec_b,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt><dd><p>A numeric array of shape <code>c(n, n)</code> specifying a
tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt><dd><p>A numeric array of shape <code>c(n, n)</code> specifying a
tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a point on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>For two orthonormal tangent vectors <code class="reqn">x</code> and <code class="reqn">y</code> at a
base point, the sectional curvature is defined by </p>
<p style="text-align: center;"><code class="reqn">\langle R(x,
  y)x, y \rangle = \langle R_x(y), y \rangle.</code>
</p>
<p> For non-orthonormal
vectors, it is </p>
<p style="text-align: center;"><code class="reqn">\langle R(x, y)x, y \rangle / \\|x \wedge y\\|^2.</code>
</p>

<p>See also https://en.wikipedia.org/wiki/Sectional_curvature.
</p>



<h5>Returns</h5>

<p>A numeric value representing the sectional curvature at
<code>base_point</code>.
</p>


<hr>
<a id="method-RiemannianMetric-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RiemannianMetric$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `RiemannianMetric$metric_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$metric_matrix()
}

## ------------------------------------------------
## Method `RiemannianMetric$cometric_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$cometric_matrix()
}

## ------------------------------------------------
## Method `RiemannianMetric$inner_product_derivative_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$inner_product_derivative_matrix()
}

## ------------------------------------------------
## Method `RiemannianMetric$inner_product`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$inner_product(diag(0, 3), diag(1, 3), base_point = diag(1, 3))
}

## ------------------------------------------------
## Method `RiemannianMetric$inner_coproduct`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$inner_coproduct(diag(0, 3), diag(1, 3), base_point = diag(1, 3))
}

## ------------------------------------------------
## Method `RiemannianMetric$hamiltonian`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$hamiltonian()
}

## ------------------------------------------------
## Method `RiemannianMetric$normalize`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$normalize(diag(2, 3), diag(1, 3))
}

## ------------------------------------------------
## Method `RiemannianMetric$random_unit_tangent_vec`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  # mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  # mt$random_unit_tangent_vec(diag(1, 3))
}

## ------------------------------------------------
## Method `RiemannianMetric$dist`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$dist(diag(1, 3), diag(1, 3))
}

## ------------------------------------------------
## Method `RiemannianMetric$dist_broadcast`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt$dist(diag(1, 3), diag(1, 3))
}
</code></pre>

<hr>
<h2 id='SPDMatrices'>Class for the Manifold of Symmetric Positive Definite Matrices</h2><span id='topic+SPDMatrices'></span>

<h3>Description</h3>

<p>Class for the manifold of symmetric positive definite (SPD)
matrices.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+OpenSet">rgeomstats::OpenSet</a></code> -&gt; <code>SPDMatrices</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the number of rows and columns of the
matrices.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SPDMatrices-new"><code>SPDMatrices$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-cholesky_factor"><code>SPDMatrices$cholesky_factor()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-differential_cholesky_factor"><code>SPDMatrices$differential_cholesky_factor()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-expm"><code>SPDMatrices$expm()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-differential_exp"><code>SPDMatrices$differential_exp()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-inverse_differential_exp"><code>SPDMatrices$inverse_differential_exp()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-logm"><code>SPDMatrices$logm()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-differential_log"><code>SPDMatrices$differential_log()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-inverse_differential_log"><code>SPDMatrices$inverse_differential_log()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-powerm"><code>SPDMatrices$powerm()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-differential_power"><code>SPDMatrices$differential_power()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-inverse_differential_power"><code>SPDMatrices$inverse_differential_power()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMatrices-clone"><code>SPDMatrices$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="OpenSet" data-id="projection"><a href='../../rgeomstats/html/OpenSet.html#method-OpenSet-projection'><code>rgeomstats::OpenSet$projection()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SPDMatrices-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SPDMatrices">SPDMatrices</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$new(n, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the number of rows and columns of the
matrices.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+OpenSet">OpenSet</a></code> and <code><a href="#topic+Manifold">Manifold</a></code> classes.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SPDMatrices</code>. Defaults to <code>NULL</code>
in which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SPDMatrices">SPDMatrices</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-cholesky_factor"></a>



<h4>Method <code>cholesky_factor()</code></h4>

<p>Computes Cholesky factor for a symmetric positive definite
matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$cholesky_factor(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the corresponding
Cholesky factors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$cholesky_factor(A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-differential_cholesky_factor"></a>



<h4>Method <code>differential_cholesky_factor()</code></h4>

<p>Computes the differential of the Cholesky factor map.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$differential_cholesky_factor(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> storing
the differentials of the corresponding Cholesky factor maps.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_cholesky_factor(diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-expm"></a>



<h4>Method <code>expm()</code></h4>

<p>Computes the matrix exponential for a symmetric matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$expm(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the corresponding
matrix exponentials.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$expm(diag(-1, 3))
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-differential_exp"></a>



<h4>Method <code>differential_exp()</code></h4>

<p>Computes the differential of the matrix exponential.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$differential_exp(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the differentials of matrix exponential at corresponding base points
applied to corresponding tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_exp(diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-inverse_differential_exp"></a>



<h4>Method <code>inverse_differential_exp()</code></h4>

<p>Computes the inverse of the differential of the matrix
exponential.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$inverse_differential_exp(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the inverse of the differentials of matrix exponential at corresponding
base points applied to corresponding tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_exp(diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-logm"></a>



<h4>Method <code>logm()</code></h4>

<p>Computes the matrix logarithm of an SPD matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$logm(mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the logarithms of the
input SPD matrices.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$logm(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-differential_log"></a>



<h4>Method <code>differential_log()</code></h4>

<p>Computes the differential of the matrix logarithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$differential_log(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the differentials of matrix logarithm at corresponding base points
applied to corresponding tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_log(diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-inverse_differential_log"></a>



<h4>Method <code>inverse_differential_log()</code></h4>

<p>Computes the inverse of the differential of the matrix
logarithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$inverse_differential_log(tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the inverse of the differentials of matrix logarithm at corresponding
base points applied to corresponding tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_log(diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-powerm"></a>



<h4>Method <code>powerm()</code></h4>

<p>Computes the matrix power of an SPD matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$powerm(mat, power)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices.</p>
</dd>
<dt><code>power</code></dt><dd><p>A numeric value or vector specifying the desired power(s).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape as <code>mat</code> storing the
corresponding matrix powers computed as: </p>
<p style="text-align: center;"><code class="reqn">A^p = \exp(p \log(A)).</code>
</p>

<p>If <code>power</code> is a vector, a list of such arrays is returned.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$powerm(diag(1, 3), 2)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-differential_power"></a>



<h4>Method <code>differential_power()</code></h4>

<p>Computes the differential of the matrix power function.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$differential_power(power, tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>power</code></dt><dd><p>An integer value specifying the desired power.</p>
</dd>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the differential of the power function </p>
<p style="text-align: center;"><code class="reqn">A^p = \exp(p \log(A))</code>
</p>
<p> at
corresponding base points applied to corresponding tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_power(2, diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-inverse_differential_power"></a>



<h4>Method <code>inverse_differential_power()</code></h4>

<p>Computes the inverse of the differential of the matrix power
function.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$inverse_differential_power(power, tangent_vec, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>power</code></dt><dd><p>An integer value specifying the desired power.</p>
</dd>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more symmetric matrices at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more SPD matrices specifying base points for the input
tangent vectors.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times]</code> storing
the inverse of the differential of the power function </p>
<p style="text-align: center;"><code class="reqn">A^p =
  \exp(p \log(A))</code>
</p>
<p> at corresponding base points applied to corresponding
tangent vectors.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_power(2, diag(1, 3), A)
}
</pre>
</div>


<hr>
<a id="method-SPDMatrices-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMatrices$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>


<h3>See Also</h3>

<p>Other symmetric positive definite matrix classes: 
<code><a href="#topic+SPDMatrix">SPDMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SPDMatrices$new`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3
}

## ------------------------------------------------
## Method `SPDMatrices$cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$cholesky_factor(A)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_cholesky_factor`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_cholesky_factor(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$expm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$expm(diag(-1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_exp`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_exp(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$logm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$logm(diag(1, 3))
}

## ------------------------------------------------
## Method `SPDMatrices$differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_log`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_log(diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$powerm`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$powerm(diag(1, 3), 2)
}

## ------------------------------------------------
## Method `SPDMatrices$differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$differential_power(2, diag(1, 3), A)
}

## ------------------------------------------------
## Method `SPDMatrices$inverse_differential_power`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  V &lt;- cbind(
    c(sqrt(2) / 2, -sqrt(2) / 2, 0),
    c(sqrt(2) / 2, sqrt(2) / 2, 0),
    c(0, 0, 1)
  )
  A &lt;- V %*% diag(1:3) %*% t(V)
  spd3$inverse_differential_power(2, diag(1, 3), A)
}
</code></pre>

<hr>
<h2 id='SPDMatrix'>Class for the Manifold of Symmetric Positive Definite Matrices</h2><span id='topic+SPDMatrix'></span>

<h3>Description</h3>

<p>This function generates an instance of the class for the manifold of
symmetric positive definite matrices <code class="reqn">\mathrm{SPD}(n)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPDMatrix(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SPDMatrix_+3A_n">n</code></td>
<td>
<p>An integer value specifying the number of rows and columns of the
matrices.</p>
</td></tr>
<tr><td><code id="SPDMatrix_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+OpenSet">OpenSet</a></code> and <code><a href="#topic+Manifold">Manifold</a></code> classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+SPDMatrices">SPDMatrices</a></code>.
</p>


<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>


<h3>See Also</h3>

<p>Other symmetric positive definite matrix classes: 
<code><a href="#topic+SPDMatrices">SPDMatrices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3
}
</code></pre>

<hr>
<h2 id='SPDMetricAffine'>Class for the Affine Metric on the Manifold of Symmetric Positive Definite
Matrices</h2><span id='topic+SPDMetricAffine'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the <code><a href="#topic+SPDMetricAffine">SPDMetricAffine</a></code>
class. This is the class for the affine-invariant metric on the SPD
manifold (Thanwerdas and Pennec 2019).
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Connection">rgeomstats::Connection</a></code> -&gt; <code><a href="#topic+RiemannianMetric">rgeomstats::RiemannianMetric</a></code> -&gt; <code>SPDMetricAffine</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>power_affine</code></dt><dd><p>An integer value specifying the power transformation
of the classical SPD metric.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SPDMetricAffine-new"><code>SPDMetricAffine$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMetricAffine-clone"><code>SPDMetricAffine$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="christoffels"><a href='../../rgeomstats/html/Connection.html#method-Connection-christoffels'><code>rgeomstats::Connection$christoffels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature'><code>rgeomstats::Connection$curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature_derivative'><code>rgeomstats::Connection$curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature'><code>rgeomstats::Connection$directional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature_derivative'><code>rgeomstats::Connection$directional_curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="exp"><a href='../../rgeomstats/html/Connection.html#method-Connection-exp'><code>rgeomstats::Connection$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic'><code>rgeomstats::Connection$geodesic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic_equation"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic_equation'><code>rgeomstats::Connection$geodesic_equation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="injectivity_radius"><a href='../../rgeomstats/html/Connection.html#method-Connection-injectivity_radius'><code>rgeomstats::Connection$injectivity_radius()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="ladder_parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-ladder_parallel_transport'><code>rgeomstats::Connection$ladder_parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="log"><a href='../../rgeomstats/html/Connection.html#method-Connection-log'><code>rgeomstats::Connection$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-parallel_transport'><code>rgeomstats::Connection$parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="closest_neighbor_index"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-closest_neighbor_index'><code>rgeomstats::RiemannianMetric$closest_neighbor_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="cometric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-cometric_matrix'><code>rgeomstats::RiemannianMetric$cometric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="diameter"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-diameter'><code>rgeomstats::RiemannianMetric$diameter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist'><code>rgeomstats::RiemannianMetric$dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_broadcast"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_broadcast'><code>rgeomstats::RiemannianMetric$dist_broadcast()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_pairwise"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_pairwise'><code>rgeomstats::RiemannianMetric$dist_pairwise()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="hamiltonian"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-hamiltonian'><code>rgeomstats::RiemannianMetric$hamiltonian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_coproduct"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_coproduct'><code>rgeomstats::RiemannianMetric$inner_coproduct()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product'><code>rgeomstats::RiemannianMetric$inner_product()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product_derivative_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product_derivative_matrix'><code>rgeomstats::RiemannianMetric$inner_product_derivative_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="metric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-metric_matrix'><code>rgeomstats::RiemannianMetric$metric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-norm'><code>rgeomstats::RiemannianMetric$norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normal_basis"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normal_basis'><code>rgeomstats::RiemannianMetric$normal_basis()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normalize"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normalize'><code>rgeomstats::RiemannianMetric$normalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="random_unit_tangent_vec"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-random_unit_tangent_vec'><code>rgeomstats::RiemannianMetric$random_unit_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="sectional_curvature"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-sectional_curvature'><code>rgeomstats::RiemannianMetric$sectional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_dist'><code>rgeomstats::RiemannianMetric$squared_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_norm'><code>rgeomstats::RiemannianMetric$squared_norm()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SPDMetricAffine-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SPDMetricAffine">SPDMetricAffine</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricAffine$new(n, power_affine = 1, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>power_affine</code></dt><dd><p>An integer value specifying the power transformation
of the classical SPD metric. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SPDMetricAffine</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SPDMetricAffine">SPDMetricAffine</a></code>.
</p>


<hr>
<a id="method-SPDMetricAffine-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricAffine$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>


<h3>References</h3>

<p>Thanwerdas Y, Pennec X (2019).
&ldquo;Is affine-invariance well defined on SPD matrices? A principled continuum of metrics.&rdquo;
In <em>International Conference on Geometric Science of Information</em>, 502&ndash;510.
Springer.
</p>

<hr>
<h2 id='SPDMetricBuresWasserstein'>Class for the Bures-Wasserstein Metric on the Manifold of Symmetric Positive
Definite Matrices</h2><span id='topic+SPDMetricBuresWasserstein'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the
<code><a href="#topic+SPDMetricBuresWasserstein">SPDMetricBuresWasserstein</a></code> class. This is the class for the
Bures-Wasserstein metric on the SPD manifold
(Bhatia et al. 2019; Malagò et al. 2018).
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Connection">rgeomstats::Connection</a></code> -&gt; <code><a href="#topic+RiemannianMetric">rgeomstats::RiemannianMetric</a></code> -&gt; <code>SPDMetricBuresWasserstein</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SPDMetricBuresWasserstein-new"><code>SPDMetricBuresWasserstein$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMetricBuresWasserstein-clone"><code>SPDMetricBuresWasserstein$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="christoffels"><a href='../../rgeomstats/html/Connection.html#method-Connection-christoffels'><code>rgeomstats::Connection$christoffels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature'><code>rgeomstats::Connection$curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature_derivative'><code>rgeomstats::Connection$curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature'><code>rgeomstats::Connection$directional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature_derivative'><code>rgeomstats::Connection$directional_curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="exp"><a href='../../rgeomstats/html/Connection.html#method-Connection-exp'><code>rgeomstats::Connection$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic'><code>rgeomstats::Connection$geodesic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic_equation"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic_equation'><code>rgeomstats::Connection$geodesic_equation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="injectivity_radius"><a href='../../rgeomstats/html/Connection.html#method-Connection-injectivity_radius'><code>rgeomstats::Connection$injectivity_radius()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="ladder_parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-ladder_parallel_transport'><code>rgeomstats::Connection$ladder_parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="log"><a href='../../rgeomstats/html/Connection.html#method-Connection-log'><code>rgeomstats::Connection$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-parallel_transport'><code>rgeomstats::Connection$parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="closest_neighbor_index"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-closest_neighbor_index'><code>rgeomstats::RiemannianMetric$closest_neighbor_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="cometric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-cometric_matrix'><code>rgeomstats::RiemannianMetric$cometric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="diameter"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-diameter'><code>rgeomstats::RiemannianMetric$diameter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist'><code>rgeomstats::RiemannianMetric$dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_broadcast"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_broadcast'><code>rgeomstats::RiemannianMetric$dist_broadcast()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_pairwise"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_pairwise'><code>rgeomstats::RiemannianMetric$dist_pairwise()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="hamiltonian"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-hamiltonian'><code>rgeomstats::RiemannianMetric$hamiltonian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_coproduct"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_coproduct'><code>rgeomstats::RiemannianMetric$inner_coproduct()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product'><code>rgeomstats::RiemannianMetric$inner_product()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product_derivative_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product_derivative_matrix'><code>rgeomstats::RiemannianMetric$inner_product_derivative_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="metric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-metric_matrix'><code>rgeomstats::RiemannianMetric$metric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-norm'><code>rgeomstats::RiemannianMetric$norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normal_basis"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normal_basis'><code>rgeomstats::RiemannianMetric$normal_basis()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normalize"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normalize'><code>rgeomstats::RiemannianMetric$normalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="random_unit_tangent_vec"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-random_unit_tangent_vec'><code>rgeomstats::RiemannianMetric$random_unit_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="sectional_curvature"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-sectional_curvature'><code>rgeomstats::RiemannianMetric$sectional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_dist'><code>rgeomstats::RiemannianMetric$squared_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_norm'><code>rgeomstats::RiemannianMetric$squared_norm()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SPDMetricBuresWasserstein-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SPDMetricBuresWasserstein">SPDMetricBuresWasserstein</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricBuresWasserstein$new(n, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SPDMetricBuresWasserstein</code>.
Defaults to <code>NULL</code> in which case it is instantiated on the fly using
the other input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SPDMetricBuresWasserstein">SPDMetricBuresWasserstein</a></code>.
</p>


<hr>
<a id="method-SPDMetricBuresWasserstein-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricBuresWasserstein$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>


<h3>References</h3>

<p>Bhatia R, Jain T, Lim Y (2019).
&ldquo;On the Bures&ndash;Wasserstein distance between positive definite matrices.&rdquo;
<em>Expositiones Mathematicae</em>, <b>37</b>(2), 165&ndash;191.<br /><br /> Malagò L, Montrucchio L, Pistone G (2018).
&ldquo;Wasserstein Riemannian geometry of Gaussian densities.&rdquo;
<em>Information Geometry</em>, <b>1</b>(2), 137&ndash;179.
</p>

<hr>
<h2 id='SPDMetricEuclidean'>Class for the Euclidean Metric on the Manifold of Symmetric Positive Definite
Matrices</h2><span id='topic+SPDMetricEuclidean'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the <code><a href="#topic+SPDMetricEuclidean">SPDMetricEuclidean</a></code>
class. This is the class for the Euclidean metric on the SPD manifold.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Connection">rgeomstats::Connection</a></code> -&gt; <code><a href="#topic+RiemannianMetric">rgeomstats::RiemannianMetric</a></code> -&gt; <code>SPDMetricEuclidean</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>power_euclidean</code></dt><dd><p>An integer value specifying the power
transformation of the classical SPD metric.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SPDMetricEuclidean-new"><code>SPDMetricEuclidean$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMetricEuclidean-clone"><code>SPDMetricEuclidean$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="christoffels"><a href='../../rgeomstats/html/Connection.html#method-Connection-christoffels'><code>rgeomstats::Connection$christoffels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature'><code>rgeomstats::Connection$curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature_derivative'><code>rgeomstats::Connection$curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature'><code>rgeomstats::Connection$directional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature_derivative'><code>rgeomstats::Connection$directional_curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="exp"><a href='../../rgeomstats/html/Connection.html#method-Connection-exp'><code>rgeomstats::Connection$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic'><code>rgeomstats::Connection$geodesic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic_equation"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic_equation'><code>rgeomstats::Connection$geodesic_equation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="injectivity_radius"><a href='../../rgeomstats/html/Connection.html#method-Connection-injectivity_radius'><code>rgeomstats::Connection$injectivity_radius()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="ladder_parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-ladder_parallel_transport'><code>rgeomstats::Connection$ladder_parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="log"><a href='../../rgeomstats/html/Connection.html#method-Connection-log'><code>rgeomstats::Connection$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-parallel_transport'><code>rgeomstats::Connection$parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="closest_neighbor_index"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-closest_neighbor_index'><code>rgeomstats::RiemannianMetric$closest_neighbor_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="cometric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-cometric_matrix'><code>rgeomstats::RiemannianMetric$cometric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="diameter"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-diameter'><code>rgeomstats::RiemannianMetric$diameter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist'><code>rgeomstats::RiemannianMetric$dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_broadcast"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_broadcast'><code>rgeomstats::RiemannianMetric$dist_broadcast()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_pairwise"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_pairwise'><code>rgeomstats::RiemannianMetric$dist_pairwise()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="hamiltonian"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-hamiltonian'><code>rgeomstats::RiemannianMetric$hamiltonian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_coproduct"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_coproduct'><code>rgeomstats::RiemannianMetric$inner_coproduct()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product'><code>rgeomstats::RiemannianMetric$inner_product()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product_derivative_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product_derivative_matrix'><code>rgeomstats::RiemannianMetric$inner_product_derivative_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="metric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-metric_matrix'><code>rgeomstats::RiemannianMetric$metric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-norm'><code>rgeomstats::RiemannianMetric$norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normal_basis"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normal_basis'><code>rgeomstats::RiemannianMetric$normal_basis()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normalize"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normalize'><code>rgeomstats::RiemannianMetric$normalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="random_unit_tangent_vec"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-random_unit_tangent_vec'><code>rgeomstats::RiemannianMetric$random_unit_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="sectional_curvature"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-sectional_curvature'><code>rgeomstats::RiemannianMetric$sectional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_dist'><code>rgeomstats::RiemannianMetric$squared_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_norm'><code>rgeomstats::RiemannianMetric$squared_norm()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SPDMetricEuclidean-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SPDMetricEuclidean">SPDMetricEuclidean</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricEuclidean$new(n, power_euclidean = 1, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>power_euclidean</code></dt><dd><p>An integer value specifying the power
transformation of the classical SPD metric. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SPDMetricEuclidean</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SPDMetricEuclidean">SPDMetricEuclidean</a></code>.
</p>


<hr>
<a id="method-SPDMetricEuclidean-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricEuclidean$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>

<hr>
<h2 id='SPDMetricLogEuclidean'>Class for the log-Euclidean Metric on the Manifold of Symmetric Positive
Definite Matrices</h2><span id='topic+SPDMetricLogEuclidean'></span>

<h3>Description</h3>

<p>An <a href="R6.html#topic+R6Class">R6::R6Class</a> object implementing the
<code><a href="#topic+SPDMetricLogEuclidean">SPDMetricLogEuclidean</a></code> class. This is the class for the
log-Euclidean metric on the SPD manifold.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Connection">rgeomstats::Connection</a></code> -&gt; <code><a href="#topic+RiemannianMetric">rgeomstats::RiemannianMetric</a></code> -&gt; <code>SPDMetricLogEuclidean</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SPDMetricLogEuclidean-new"><code>SPDMetricLogEuclidean$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SPDMetricLogEuclidean-clone"><code>SPDMetricLogEuclidean$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="christoffels"><a href='../../rgeomstats/html/Connection.html#method-Connection-christoffels'><code>rgeomstats::Connection$christoffels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature'><code>rgeomstats::Connection$curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-curvature_derivative'><code>rgeomstats::Connection$curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature'><code>rgeomstats::Connection$directional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="directional_curvature_derivative"><a href='../../rgeomstats/html/Connection.html#method-Connection-directional_curvature_derivative'><code>rgeomstats::Connection$directional_curvature_derivative()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="exp"><a href='../../rgeomstats/html/Connection.html#method-Connection-exp'><code>rgeomstats::Connection$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic'><code>rgeomstats::Connection$geodesic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="geodesic_equation"><a href='../../rgeomstats/html/Connection.html#method-Connection-geodesic_equation'><code>rgeomstats::Connection$geodesic_equation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="injectivity_radius"><a href='../../rgeomstats/html/Connection.html#method-Connection-injectivity_radius'><code>rgeomstats::Connection$injectivity_radius()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="ladder_parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-ladder_parallel_transport'><code>rgeomstats::Connection$ladder_parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="log"><a href='../../rgeomstats/html/Connection.html#method-Connection-log'><code>rgeomstats::Connection$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Connection" data-id="parallel_transport"><a href='../../rgeomstats/html/Connection.html#method-Connection-parallel_transport'><code>rgeomstats::Connection$parallel_transport()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="closest_neighbor_index"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-closest_neighbor_index'><code>rgeomstats::RiemannianMetric$closest_neighbor_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="cometric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-cometric_matrix'><code>rgeomstats::RiemannianMetric$cometric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="diameter"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-diameter'><code>rgeomstats::RiemannianMetric$diameter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist'><code>rgeomstats::RiemannianMetric$dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_broadcast"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_broadcast'><code>rgeomstats::RiemannianMetric$dist_broadcast()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="dist_pairwise"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-dist_pairwise'><code>rgeomstats::RiemannianMetric$dist_pairwise()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="hamiltonian"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-hamiltonian'><code>rgeomstats::RiemannianMetric$hamiltonian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_coproduct"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_coproduct'><code>rgeomstats::RiemannianMetric$inner_coproduct()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product'><code>rgeomstats::RiemannianMetric$inner_product()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="inner_product_derivative_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-inner_product_derivative_matrix'><code>rgeomstats::RiemannianMetric$inner_product_derivative_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="metric_matrix"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-metric_matrix'><code>rgeomstats::RiemannianMetric$metric_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-norm'><code>rgeomstats::RiemannianMetric$norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normal_basis"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normal_basis'><code>rgeomstats::RiemannianMetric$normal_basis()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="normalize"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-normalize'><code>rgeomstats::RiemannianMetric$normalize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="random_unit_tangent_vec"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-random_unit_tangent_vec'><code>rgeomstats::RiemannianMetric$random_unit_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="sectional_curvature"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-sectional_curvature'><code>rgeomstats::RiemannianMetric$sectional_curvature()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_dist"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_dist'><code>rgeomstats::RiemannianMetric$squared_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="RiemannianMetric" data-id="squared_norm"><a href='../../rgeomstats/html/RiemannianMetric.html#method-RiemannianMetric-squared_norm'><code>rgeomstats::RiemannianMetric$squared_norm()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SPDMetricLogEuclidean-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SPDMetricLogEuclidean">SPDMetricLogEuclidean</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricLogEuclidean$new(n, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the shape of the matrices: <code class="reqn">n
\times n</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SPDMetricLogEuclidean</code>. Defaults
to <code>NULL</code> in which case it is instantiated on the fly using the other
input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SPDMetricLogEuclidean">SPDMetricLogEuclidean</a></code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt
}
</pre>
</div>


<hr>
<a id="method-SPDMetricLogEuclidean-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SPDMetricLogEuclidean$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Yann Thanwerdas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SPDMetricLogEuclidean$new`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  mt &lt;- SPDMetricLogEuclidean$new(n = 3)
  mt
}
</code></pre>

<hr>
<h2 id='SpecialOrthogonal'>Class for the Special Orthogonal Group</h2><span id='topic+SpecialOrthogonal'></span>

<h3>Description</h3>

<p>This function generates an instance of the class for the special orthogonal
group <code class="reqn">\mathrm{SO}(n)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecialOrthogonal(n, point_type = "matrix", epsilon = 0, ..., py_cls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpecialOrthogonal_+3A_n">n</code></td>
<td>
<p>An integer value representing the shape of the <code style="white-space: pre;">&#8288;n x n&#8288;</code> matrices.</p>
</td></tr>
<tr><td><code id="SpecialOrthogonal_+3A_point_type">point_type</code></td>
<td>
<p>A character string specifying how elements of the group
should be represented. Choices are either <code>"vector"</code> or <code>"matrix"</code>.
Defaults to <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="SpecialOrthogonal_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric value specifying the precision to use for
calculations involving potential division by 0 in rotations. Defaults to
<code>0.0</code>.</p>
</td></tr>
<tr><td><code id="SpecialOrthogonal_+3A_...">...</code></td>
<td>
<p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+LieGroup">LieGroup</a></code>, <code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code>, <code><a href="#topic+LevelSet">LevelSet</a></code> and <code><a href="#topic+Manifold">Manifold</a></code> classes.</p>
</td></tr>
<tr><td><code id="SpecialOrthogonal_+3A_py_cls">py_cls</code></td>
<td>
<p>A Python object of class <code>SpecialOrthogonal</code>. Defaults to
<code>NULL</code> in which case it is instantiated on the fly using the other input
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a></code> which is an instance of one
of three different <code><a href="R6.html#topic+R6Class">R6::R6Class</a></code> depending on the values of the input
arguments. Specifically:
</p>

<ul>
<li><p> if <code>n == 2</code> and <code>point_type == "vector"</code>, then the user wants to
instantiate the space of 2D rotations in vector representations and thus the
output is an instance of the <code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code> class;
</p>
</li>
<li><p> if <code>n == 3</code> and <code>point_type == "vector"</code>, then the user wants to
instantiate the space of 3D rotations in vector representations and thus the
output is an instance of the <code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code> class;
</p>
</li>
<li><p> in all other cases, either the user is dealing with rotations in matrix
representation or with rotations in dimension greater than 3 and thus the
output is an instance of the <code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code> class.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>See Also</h3>

<p>Other special orthogonal classes: 
<code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3
}
</code></pre>

<hr>
<h2 id='SpecialOrthogonal2Vectors'>Abstract Class for the 2D Special Orthogonal Group in Vector Representation</h2><span id='topic+SpecialOrthogonal2Vectors'></span>

<h3>Description</h3>

<p>Class for the special orthogonal group <code class="reqn">\mathrm{SO}(2)</code> in
vector form, i.e. the Lie group of planar rotations. This class is
specific to the vector representation of rotations. For the matrix
representation, use the <code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a></code> class and set <code>n = 2</code>.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+LieGroup">rgeomstats::LieGroup</a></code> -&gt; <code><a href="#topic+SpecialOrthogonalVectors">rgeomstats::SpecialOrthogonalVectors</a></code> -&gt; <code>SpecialOrthogonal2Vectors</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpecialOrthogonal2Vectors-new"><code>SpecialOrthogonal2Vectors$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal2Vectors-rotation_vector_from_matrix"><code>SpecialOrthogonal2Vectors$rotation_vector_from_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal2Vectors-matrix_from_rotation_vector"><code>SpecialOrthogonal2Vectors$matrix_from_rotation_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal2Vectors-random_uniform"><code>SpecialOrthogonal2Vectors$random_uniform()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal2Vectors-clone"><code>SpecialOrthogonal2Vectors$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="add_metric"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-add_metric'><code>rgeomstats::LieGroup$add_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="compose"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-compose'><code>rgeomstats::LieGroup$compose()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp'><code>rgeomstats::LieGroup$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_from_identity'><code>rgeomstats::LieGroup$exp_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_not_from_identity'><code>rgeomstats::LieGroup$exp_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="get_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-get_identity'><code>rgeomstats::LieGroup$get_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="inverse"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-inverse'><code>rgeomstats::LieGroup$inverse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="jacobian_translation"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-jacobian_translation'><code>rgeomstats::LieGroup$jacobian_translation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="lie_bracket"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-lie_bracket'><code>rgeomstats::LieGroup$lie_bracket()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log'><code>rgeomstats::LieGroup$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_from_identity'><code>rgeomstats::LieGroup$log_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_not_from_identity'><code>rgeomstats::LieGroup$log_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="tangent_translation_map"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-tangent_translation_map'><code>rgeomstats::LieGroup$tangent_translation_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="projection"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-projection'><code>rgeomstats::SpecialOrthogonalVectors$projection()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="regularize_tangent_vec"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-regularize_tangent_vec'><code>rgeomstats::SpecialOrthogonalVectors$regularize_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="regularize_tangent_vec_at_identity"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-regularize_tangent_vec_at_identity'><code>rgeomstats::SpecialOrthogonalVectors$regularize_tangent_vec_at_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="skew_matrix_from_vector"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-skew_matrix_from_vector'><code>rgeomstats::SpecialOrthogonalVectors$skew_matrix_from_vector()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="vector_from_skew_matrix"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-vector_from_skew_matrix'><code>rgeomstats::SpecialOrthogonalVectors$vector_from_skew_matrix()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpecialOrthogonal2Vectors-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal2Vectors$new(epsilon = 0, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>epsilon</code></dt><dd><p>A numeric value specifying the precision to use for
calculations involving potential division by 0 in rotations. Defaults to
<code>0</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SpecialOrthogonal2Vectors</code>.
Defaults to <code>NULL</code> in which case it is instantiated on the fly using
the other input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code>.
</p>


<hr>
<a id="method-SpecialOrthogonal2Vectors-rotation_vector_from_matrix"></a>



<h4>Method <code>rotation_vector_from_matrix()</code></h4>

<p>Converts rotation matrix (in 2D) to rotation vector
(axis-angle) getting the angle through the <code>atan2()</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal2Vectors$rotation_vector_from_matrix(rot_mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 2 \times 2]</code>
specifying one or more 2D rotation matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 1]</code> storing the
corresponding axis-angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$rotation_vector_from_matrix(diag(1, 2))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal2Vectors-matrix_from_rotation_vector"></a>



<h4>Method <code>matrix_from_rotation_vector()</code></h4>

<p>Convert a 2D rotation from vector to matrix representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal2Vectors$matrix_from_rotation_vector(rot_vec)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">... \times 1</code> specifying one
or more 2D rotations in vector representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">... \times 2 \times 2</code> storing the
corresponding 2D rotation matrices.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$matrix_from_rotation_vector(array(0))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal2Vectors-random_uniform"></a>



<h4>Method <code>random_uniform()</code></h4>

<p>Samples in <code class="reqn">\mathrm{SO}(2)</code> from a uniform distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal2Vectors$random_uniform(n_samples = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_samples</code></dt><dd><p>An integer value specifying the sample size. Defaults to
<code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">... \times 1</code> storing a sample of
2D rotations in axis-angle representation uniformly sampled in
<code class="reqn">\mathrm{SO}(2)</code>.
</p>


<hr>
<a id="method-SpecialOrthogonal2Vectors-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal2Vectors$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>See Also</h3>

<p>Other special orthogonal classes: 
<code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code>,
<code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SpecialOrthogonal2Vectors$rotation_vector_from_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$rotation_vector_from_matrix(diag(1, 2))
}

## ------------------------------------------------
## Method `SpecialOrthogonal2Vectors$matrix_from_rotation_vector`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$matrix_from_rotation_vector(array(0))
}
</code></pre>

<hr>
<h2 id='SpecialOrthogonal3Vectors'>Abstract Class for the 3D Special Orthogonal Group in Vector Representation</h2><span id='topic+SpecialOrthogonal3Vectors'></span>

<h3>Description</h3>

<p>Class for the special orthogonal group <code class="reqn">\mathrm{SO}(3)</code> in
vector form, i.e. the Lie group of 3D rotations. This class is specific to
the vector representation of rotations. For the matrix representation, use
the <code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a></code> class and set <code>n = 3</code>.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+LieGroup">rgeomstats::LieGroup</a></code> -&gt; <code><a href="#topic+SpecialOrthogonalVectors">rgeomstats::SpecialOrthogonalVectors</a></code> -&gt; <code>SpecialOrthogonal3Vectors</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>bi_invariant_metric</code></dt><dd><p>An object of class <code>BiInvariantMetric</code>
specifying the metric to equip the manifold with.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-new"><code>SpecialOrthogonal3Vectors$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-rotation_vector_from_matrix"><code>SpecialOrthogonal3Vectors$rotation_vector_from_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-matrix_from_rotation_vector"><code>SpecialOrthogonal3Vectors$matrix_from_rotation_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-quaternion_from_matrix"><code>SpecialOrthogonal3Vectors$quaternion_from_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-quaternion_from_rotation_vector"><code>SpecialOrthogonal3Vectors$quaternion_from_rotation_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-rotation_vector_from_quaternion"><code>SpecialOrthogonal3Vectors$rotation_vector_from_quaternion()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-matrix_from_quaternion"><code>SpecialOrthogonal3Vectors$matrix_from_quaternion()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-matrix_from_tait_bryan_angles"><code>SpecialOrthogonal3Vectors$matrix_from_tait_bryan_angles()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_matrix"><code>SpecialOrthogonal3Vectors$tait_bryan_angles_from_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-quaternion_from_tait_bryan_angles"><code>SpecialOrthogonal3Vectors$quaternion_from_tait_bryan_angles()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-rotation_vector_from_tait_bryan_angles"><code>SpecialOrthogonal3Vectors$rotation_vector_from_tait_bryan_angles()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_quaternion"><code>SpecialOrthogonal3Vectors$tait_bryan_angles_from_quaternion()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_rotation_vector"><code>SpecialOrthogonal3Vectors$tait_bryan_angles_from_rotation_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-random_uniform"><code>SpecialOrthogonal3Vectors$random_uniform()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonal3Vectors-clone"><code>SpecialOrthogonal3Vectors$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="add_metric"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-add_metric'><code>rgeomstats::LieGroup$add_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="compose"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-compose'><code>rgeomstats::LieGroup$compose()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp'><code>rgeomstats::LieGroup$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_from_identity'><code>rgeomstats::LieGroup$exp_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_not_from_identity'><code>rgeomstats::LieGroup$exp_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="get_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-get_identity'><code>rgeomstats::LieGroup$get_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="inverse"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-inverse'><code>rgeomstats::LieGroup$inverse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="jacobian_translation"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-jacobian_translation'><code>rgeomstats::LieGroup$jacobian_translation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="lie_bracket"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-lie_bracket'><code>rgeomstats::LieGroup$lie_bracket()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log'><code>rgeomstats::LieGroup$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_from_identity'><code>rgeomstats::LieGroup$log_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_not_from_identity'><code>rgeomstats::LieGroup$log_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="tangent_translation_map"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-tangent_translation_map'><code>rgeomstats::LieGroup$tangent_translation_map()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="projection"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-projection'><code>rgeomstats::SpecialOrthogonalVectors$projection()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="regularize_tangent_vec"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-regularize_tangent_vec'><code>rgeomstats::SpecialOrthogonalVectors$regularize_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="regularize_tangent_vec_at_identity"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-regularize_tangent_vec_at_identity'><code>rgeomstats::SpecialOrthogonalVectors$regularize_tangent_vec_at_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="skew_matrix_from_vector"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-skew_matrix_from_vector'><code>rgeomstats::SpecialOrthogonalVectors$skew_matrix_from_vector()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="SpecialOrthogonalVectors" data-id="vector_from_skew_matrix"><a href='../../rgeomstats/html/SpecialOrthogonalVectors.html#method-SpecialOrthogonalVectors-vector_from_skew_matrix'><code>rgeomstats::SpecialOrthogonalVectors$vector_from_skew_matrix()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpecialOrthogonal3Vectors-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$new(epsilon = 0, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>epsilon</code></dt><dd><p>A numeric value specifying the precision to use for
calculations involving potential division by 0 in rotations. Defaults to
<code>0</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SpecialOrthogonal3Vectors</code>.
Defaults to <code>NULL</code> in which case it is instantiated on the fly using
the other input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code>.
</p>


<hr>
<a id="method-SpecialOrthogonal3Vectors-rotation_vector_from_matrix"></a>



<h4>Method <code>rotation_vector_from_matrix()</code></h4>

<p>Converts a 3D rotation from matrix to axis-angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$rotation_vector_from_matrix(rot_mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code>
specifying one or more 3D rotation matrices.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Gets the angle <code class="reqn">\theta</code> through the trace of the rotation
matrix. The eigenvalues are: </p>
<p style="text-align: center;"><code class="reqn">\{ 1, \cos \theta + i \sin \theta,
  \cos \theta - i \sin \theta \}</code>
</p>
<p> so that </p>
<p style="text-align: center;"><code class="reqn">\mathrm{trace} = 1 + 2
  \cos \theta, \{ -1 \leq \mathrm{trace} \leq 3 \}.</code>
</p>

<p>The rotation vector is the vector associated to the skew-symmetric matrix
</p>
<p style="text-align: center;"><code class="reqn">S_r = \frac{\theta}{(2 \sin \theta) (R - R^T)}.</code>
</p>

<p>For the edge case where the angle is close to <code class="reqn">\pi</code>, the rotation
vector (up to sign) is derived by using the following equality (see the
axis-angle representation on Wikipedia): </p>
<p style="text-align: center;"><code class="reqn">\mathrm{outer}(r, r) =
\frac{1}{2} (R + I_3).</code>
</p>

<p>In nD, the rotation vector stores the <code class="reqn">n(n-1)/2</code> values of the
skew-symmetric matrix representing the rotation.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding axis-angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_matrix(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-matrix_from_rotation_vector"></a>



<h4>Method <code>matrix_from_rotation_vector()</code></h4>

<p>Converts a 3D rotation from axis-angle to matrix
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$matrix_from_rotation_vector(rot_vec)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> specifying
one or more 3D rotations in axis-angle representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code> storing
the corresponding matrix representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_rotation_vector(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-quaternion_from_matrix"></a>



<h4>Method <code>quaternion_from_matrix()</code></h4>

<p>Converts a 3D rotation from matrix to unit quaternion
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$quaternion_from_matrix(rot_mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code>
specifying one or more 3D rotations in matrix representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 4]</code> storing the
corresponding unit quaternion representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_matrix(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-quaternion_from_rotation_vector"></a>



<h4>Method <code>quaternion_from_rotation_vector()</code></h4>

<p>Converts a 3D rotation from axis-angle to unit quaternion
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$quaternion_from_rotation_vector(rot_vec)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> specifying
one or more 3D rotations in axis-angle representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 4]</code> storing the
corresponding unit quaternion representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_rotation_vector(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-rotation_vector_from_quaternion"></a>



<h4>Method <code>rotation_vector_from_quaternion()</code></h4>

<p>Converts a 3D rotation from unit quaternion to axis-angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$rotation_vector_from_quaternion(quaternion)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quaternion</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 4]</code>
specifying one or more 3D rotations in unit quaternion representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding axis-angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_quaternion(array(c(1, rep(0, 3))))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-matrix_from_quaternion"></a>



<h4>Method <code>matrix_from_quaternion()</code></h4>

<p>Converts a 3D rotation from unit quaternion to matrix
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$matrix_from_quaternion(quaternion)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quaternion</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 4]</code>
specifying one or more 3D rotations in unit quaternion representation.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code> storing
the corresponding matrix representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_quaternion(c(1, rep(0, 3)))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-matrix_from_tait_bryan_angles"></a>



<h4>Method <code>matrix_from_tait_bryan_angles()</code></h4>

<p>Converts a 3D rotation from Tait-Bryan angle to matrix
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$matrix_from_tait_bryan_angles(
  tait_bryan_angles,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tait_bryan_angles</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code>
specifying one or more 3D rotations in Tait-Bryan angle representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Converts a rotation given in terms of the Tait-Bryan angles
<code style="white-space: pre;">&#8288;[angle_1, angle_2, angle_3]&#8288;</code> in extrinsic (fixed) or intrinsic
(moving) coordinate frame in the corresponding matrix representation.
If the order is <code>zyx</code>, into the rotation matrix <code style="white-space: pre;">&#8288;rot_mat = X(angle_1) Y(angle_2) Z(angle_3)&#8288;</code> where:
</p>

<ul>
<li> <p><code>X(angle_1)</code> is a rotation of angle <code>angle_1</code> around axis <code>x</code>;
</p>
</li>
<li> <p><code>Y(angle_2)</code> is a rotation of angle <code>angle_2</code> around axis <code>y</code>;
</p>
</li>
<li> <p><code>Z(angle_3)</code> is a rotation of angle <code>angle_3</code> around axis <code>z</code>.
</p>
</li></ul>

<p>Exchanging <code>'extrinsic'</code> and <code>'intrinsic'</code> amounts to exchanging the
order.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code> storing
the corresponding matrix representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_tait_bryan_angles(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_matrix"></a>



<h4>Method <code>tait_bryan_angles_from_matrix()</code></h4>

<p>Converts a 3D rotation from matrix to Tait-Bryan angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$tait_bryan_angles_from_matrix(
  rot_mat,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3 \times 3]</code>
specifying one or more 3D rotations in matrix representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Converts a rotation given in matrix representation into its
Tait-Bryan angle representation <code style="white-space: pre;">&#8288;[angle_1, angle_2, angle_3]&#8288;</code> in
extrinsic (fixed) or intrinsic (moving) coordinate frame in the
corresponding matrix representation. If the order is <code>zyx</code>, into the
rotation matrix <code style="white-space: pre;">&#8288;rot_mat = X(angle_1) Y(angle_2) Z(angle_3)&#8288;</code> where:
</p>

<ul>
<li> <p><code>X(angle_1)</code> is a rotation of angle <code>angle_1</code> around axis <code>x</code>;
</p>
</li>
<li> <p><code>Y(angle_2)</code> is a rotation of angle <code>angle_2</code> around axis <code>y</code>;
</p>
</li>
<li> <p><code>Z(angle_3)</code> is a rotation of angle <code>angle_3</code> around axis <code>z</code>.
</p>
</li></ul>

<p>Exchanging <code>'extrinsic'</code> and <code>'intrinsic'</code> amounts to exchanging the
order.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding Tait-Bryan angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_matrix(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-quaternion_from_tait_bryan_angles"></a>



<h4>Method <code>quaternion_from_tait_bryan_angles()</code></h4>

<p>Converts a 3D rotation from Tait-Bryan angle to unit
quaternion representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$quaternion_from_tait_bryan_angles(
  tait_bryan_angles,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tait_bryan_angles</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code>
specifying one or more 3D rotations in Tait-Bryan angle representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 4]</code> storing the
corresponding unit quaternion representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_tait_bryan_angles(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-rotation_vector_from_tait_bryan_angles"></a>



<h4>Method <code>rotation_vector_from_tait_bryan_angles()</code></h4>

<p>Converts a 3D rotation from Tait-Bryan angle to axis-angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$rotation_vector_from_tait_bryan_angles(
  tait_bryan_angles,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tait_bryan_angles</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code>
specifying one or more 3D rotations in Tait-Bryan angle representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding axis-angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_tait_bryan_angles(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_quaternion"></a>



<h4>Method <code>tait_bryan_angles_from_quaternion()</code></h4>

<p>Converts a 3D rotation from matrix to Tait-Bryan angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$tait_bryan_angles_from_quaternion(
  quaternion,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quaternion</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 4]</code>
specifying one or more 3D rotations in unit quaternion representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding Tait-Bryan angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_quaternion(c(1, rep(0, 3)))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-tait_bryan_angles_from_rotation_vector"></a>



<h4>Method <code>tait_bryan_angles_from_rotation_vector()</code></h4>

<p>Converts a 3D rotation from axis-angle to Tait-Bryan angle
representation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$tait_bryan_angles_from_rotation_vector(
  rot_vec,
  extrinsic_or_intrinsic = "extrinsic",
  order = "zyx"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rot_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> specifying
one or more 3D rotations in axis-angle representation.</p>
</dd>
<dt><code>extrinsic_or_intrinsic</code></dt><dd><p>A character string specifying the
coordinate frame in which the Tait-Bryan angles are expressed. Choices
are either <code>"extrinsic"</code> (fixed frame) or <code>"intrinsic"</code> (moving frame).
Defaults to <code>"extrinsic"</code>.</p>
</dd>
<dt><code>order</code></dt><dd><p>A character string specifying the order of the rotation
composition around the three axes of the chosen coordinate frame.
Choices are either <code>"xyz"</code> or <code>"zyx"</code>. Defaults to <code>"zyx"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing the
corresponding Tait-Bryan angle representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_rotation_vector(rep(0, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-random_uniform"></a>



<h4>Method <code>random_uniform()</code></h4>

<p>Samples in <code class="reqn">\mathrm{SO}(3)</code> from a uniform distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$random_uniform(n_samples = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_samples</code></dt><dd><p>An integer value specifying the sample size. Defaults to
<code>1L</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 3]</code> storing a sample
of 3D rotations in axis-angle representation uniformly sampled in
<code class="reqn">\mathrm{SO}(3)</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$random_uniform()
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonal3Vectors-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonal3Vectors$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>See Also</h3>

<p>Other special orthogonal classes: 
<code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code>,
<code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$rotation_vector_from_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_matrix(diag(1, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$matrix_from_rotation_vector`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_rotation_vector(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$quaternion_from_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_matrix(diag(1, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$quaternion_from_rotation_vector`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_rotation_vector(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$rotation_vector_from_quaternion`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_quaternion(array(c(1, rep(0, 3))))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$matrix_from_quaternion`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_quaternion(c(1, rep(0, 3)))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$matrix_from_tait_bryan_angles`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$matrix_from_tait_bryan_angles(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$tait_bryan_angles_from_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_matrix(diag(1, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$quaternion_from_tait_bryan_angles`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$quaternion_from_tait_bryan_angles(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$rotation_vector_from_tait_bryan_angles`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$rotation_vector_from_tait_bryan_angles(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$tait_bryan_angles_from_quaternion`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_quaternion(c(1, rep(0, 3)))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$tait_bryan_angles_from_rotation_vector`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$tait_bryan_angles_from_rotation_vector(rep(0, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonal3Vectors$random_uniform`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3, point_type = "vector")
  so3$random_uniform()
}
</code></pre>

<hr>
<h2 id='SpecialOrthogonalMatrices'>Abstract Class for Special Orthogonal Groups in Matrix Representation</h2><span id='topic+SpecialOrthogonalMatrices'></span>

<h3>Description</h3>

<p>Class for special orthogonal groups in matrix representation.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+MatrixLieGroup">rgeomstats::MatrixLieGroup</a></code> -&gt; <code>SpecialOrthogonalMatrices</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>bi_invariant_metric</code></dt><dd><p>An object of class <code>BiInvariantMetric</code>
specifying the metric to equip the manifold with.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpecialOrthogonalMatrices-new"><code>SpecialOrthogonalMatrices$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalMatrices-belongs"><code>SpecialOrthogonalMatrices$belongs()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalMatrices-intrinsic_to_extrinsic_coords"><code>SpecialOrthogonalMatrices$intrinsic_to_extrinsic_coords()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalMatrices-extrinsic_to_intrinsic_coords"><code>SpecialOrthogonalMatrices$extrinsic_to_intrinsic_coords()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalMatrices-projection"><code>SpecialOrthogonalMatrices$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalMatrices-clone"><code>SpecialOrthogonalMatrices$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="compose"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-compose'><code>rgeomstats::MatrixLieGroup$compose()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="exp"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-exp'><code>rgeomstats::MatrixLieGroup$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="get_identity"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-get_identity'><code>rgeomstats::MatrixLieGroup$get_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="inverse"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-inverse'><code>rgeomstats::MatrixLieGroup$inverse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="lie_bracket"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-lie_bracket'><code>rgeomstats::MatrixLieGroup$lie_bracket()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="log"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-log'><code>rgeomstats::MatrixLieGroup$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="MatrixLieGroup" data-id="tangent_translation_map"><a href='../../rgeomstats/html/MatrixLieGroup.html#method-MatrixLieGroup-tangent_translation_map'><code>rgeomstats::MatrixLieGroup$tangent_translation_map()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpecialOrthogonalMatrices-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$new(n, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the number of rows and columns of
the matrices.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+MatrixLieAlgebra">MatrixLieAlgebra</a></code>, <code><a href="#topic+LevelSet">LevelSet</a></code> and <code><a href="#topic+Manifold">Manifold</a></code> classes.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SpecialOrthogonalMatrices</code>.
Defaults to <code>NULL</code> in which case it is instantiated on the fly using
the other input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SpecialOrthogonalMatrices">SpecialOrthogonalMatrices</a></code>.
</p>


<hr>
<a id="method-SpecialOrthogonalMatrices-belongs"></a>



<h4>Method <code>belongs()</code></h4>

<p>Evaluates if a point belongs to the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$belongs(point, atol = gs$backend$atol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times
\{\mathrm{dim}\}]</code> specifying one or more points to be checked.</p>
</dd>
<dt><code>atol</code></dt><dd><p>A numeric value specifying the absolute tolerance for
checking. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A boolean value or vector storing whether the input points belong
to the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$belongs(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalMatrices-intrinsic_to_extrinsic_coords"></a>



<h4>Method <code>intrinsic_to_extrinsic_coords()</code></h4>

<p>Converts from intrinsic to extrinsic coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$intrinsic_to_extrinsic_coords(point_intrinsic)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_intrinsic</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim} \}]</code> specifying one or more points on the embedded
manifold in intrinsic coordinates.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim_embedding} \}]</code> storing the same points on the embedded
manifold in extrinsic coordinates.
</p>


<hr>
<a id="method-SpecialOrthogonalMatrices-extrinsic_to_intrinsic_coords"></a>



<h4>Method <code>extrinsic_to_intrinsic_coords()</code></h4>

<p>Converts from extrinsic to intrinsic coordinates.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$extrinsic_to_intrinsic_coords(point_extrinsic)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_extrinsic</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \{
  \mathrm{dim_embedding} \}]</code> specifying one or more points on the
embedded manifold in extrinsic coordinates.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{ \mathrm{dim} \}]</code>
storing the same points on the embedded manifold in intrinsic
coordinates.
</p>


<hr>
<a id="method-SpecialOrthogonalMatrices-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Project a matrix on <code class="reqn">\mathrm{SO}(n)</code> by minimizing the
Frobenius norm.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$projection(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the projected matrices.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(3)
  so3$projection(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalMatrices-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalMatrices$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>See Also</h3>

<p>Other special orthogonal classes: 
<code><a href="#topic+SpecialOrthogonal2Vectors">SpecialOrthogonal2Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonal3Vectors">SpecialOrthogonal3Vectors</a></code>,
<code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SpecialOrthogonalMatrices$belongs`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(n = 3)
  so3$belongs(diag(1, 3))
}

## ------------------------------------------------
## Method `SpecialOrthogonalMatrices$projection`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so3 &lt;- SpecialOrthogonal(3)
  so3$projection(diag(1, 3))
}
</code></pre>

<hr>
<h2 id='SpecialOrthogonalVectors'>Abstract Class for Special Orthogonal Groups in Vector Representation</h2><span id='topic+SpecialOrthogonalVectors'></span>

<h3>Description</h3>

<p>Class for the special orthogonal groups
<code class="reqn">\mathrm{SO}(\{2,3\})</code> in vector form, i.e. the Lie groups of planar
and 3D rotations. This class is specific to the vector representation of
rotations. For the matrix representation, use the <code><a href="#topic+SpecialOrthogonal">SpecialOrthogonal</a></code>
class and set <code>n = 2</code> or <code>n = 3</code>.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code><a href="#topic+LieGroup">rgeomstats::LieGroup</a></code> -&gt; <code>SpecialOrthogonalVectors</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the number of rows and columns of
the matrices.</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>A numeric value specifying the precision to use for
calculations involving potential divison by 0 in rotations.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpecialOrthogonalVectors-new"><code>SpecialOrthogonalVectors$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-projection"><code>SpecialOrthogonalVectors$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-skew_matrix_from_vector"><code>SpecialOrthogonalVectors$skew_matrix_from_vector()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-vector_from_skew_matrix"><code>SpecialOrthogonalVectors$vector_from_skew_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-regularize_tangent_vec_at_identity"><code>SpecialOrthogonalVectors$regularize_tangent_vec_at_identity()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-regularize_tangent_vec"><code>SpecialOrthogonalVectors$regularize_tangent_vec()</code></a>
</p>
</li>
<li> <p><a href="#method-SpecialOrthogonalVectors-clone"><code>SpecialOrthogonalVectors$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="add_metric"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-add_metric'><code>rgeomstats::LieGroup$add_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="compose"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-compose'><code>rgeomstats::LieGroup$compose()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp'><code>rgeomstats::LieGroup$exp()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_from_identity'><code>rgeomstats::LieGroup$exp_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="exp_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-exp_not_from_identity'><code>rgeomstats::LieGroup$exp_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="get_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-get_identity'><code>rgeomstats::LieGroup$get_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="inverse"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-inverse'><code>rgeomstats::LieGroup$inverse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="jacobian_translation"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-jacobian_translation'><code>rgeomstats::LieGroup$jacobian_translation()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="lie_bracket"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-lie_bracket'><code>rgeomstats::LieGroup$lie_bracket()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log'><code>rgeomstats::LieGroup$log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_from_identity'><code>rgeomstats::LieGroup$log_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="log_not_from_identity"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-log_not_from_identity'><code>rgeomstats::LieGroup$log_not_from_identity()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="LieGroup" data-id="tangent_translation_map"><a href='../../rgeomstats/html/LieGroup.html#method-LieGroup-tangent_translation_map'><code>rgeomstats::LieGroup$tangent_translation_map()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SpecialOrthogonalVectors-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+SpecialOrthogonalVectors">SpecialOrthogonalVectors</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$new(n, epsilon = 0, py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>An integer value specifying the number of rows and columns of
the matrices.</p>
</dd>
<dt><code>epsilon</code></dt><dd><p>A numeric value specifying the precision to use for
calculations involving potential divison by 0 in rotations. Defaults to
<code>0</code>.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>SpecialOrthogonalVectors</code>.
Defaults to <code>NULL</code> in which case it is instantiated on the fly using
the other input arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SpecialOrthogonalVectors">SpecialOrthogonalVectors</a></code>.
</p>


<hr>
<a id="method-SpecialOrthogonalVectors-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Projects a matrix on <code class="reqn">\mathrm{SO}(2)</code> or
<code class="reqn">\mathrm{SO}(3)</code> using the Frobenius norm.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$projection(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying one or more matrices to be projected.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of the same shape as the input point storing the
projected matrices.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$projection(diag(1, 2))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalVectors-skew_matrix_from_vector"></a>



<h4>Method <code>skew_matrix_from_vector()</code></h4>

<p>Gets the skew-symmetric matrix derived from the vector. In
3D, computes the skew-symmetric matrix, known as the cross-product of a
vector, associated to the vector <code>vec</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$skew_matrix_from_vector(vec)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times \mathrm{dim}]</code>
specifying one or more vectors from which to compute corresponding skew
matrix representations.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code> storing
the corresponding skew matrix representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$skew_matrix_from_vector(array(0))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalVectors-vector_from_skew_matrix"></a>



<h4>Method <code>vector_from_skew_matrix()</code></h4>

<p>Derives a vector from the skew-symmetric matrix. In 3D,
computes the vector defining the cross-product associated to a
skew-symmetric matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$vector_from_skew_matrix(skew_mat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skew_mat</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times n \times n]</code>
specifying skew matrices.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \mathrm{dim}]</code>
storing the corresponding vector representations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$vector_from_skew_matrix(diag(0, 2))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalVectors-regularize_tangent_vec_at_identity"></a>



<h4>Method <code>regularize_tangent_vec_at_identity()</code></h4>

<p>Regularizes a tangent vector at the identity. In 2D,
regularizes a tangent vector by getting its norm at the identity to be
less than <code class="reqn">\pi</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$regularize_tangent_vec_at_identity(
  tangent_vec,
  metric = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 1]</code>
specifying one or more tangent vectors at base point.</p>
</dd>
<dt><code>metric</code></dt><dd><p>An object of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> specifying the
metric to compute the norm of the tangent vector or <code>NULL</code>. If it is
set to <code>NULL</code>, it defaults to using the Euclidean metric.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 1]</code> storing the
regularized tangent vector(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$regularize_tangent_vec_at_identity(array(0))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalVectors-regularize_tangent_vec"></a>



<h4>Method <code>regularize_tangent_vec()</code></h4>

<p>Regularizes a tangent vector at a base point. In 2D,
regularizes a tangent vector by getting the norm of its parallel
transport to the identity, determined by the metric, to be less than
<code class="reqn">\pi</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$regularize_tangent_vec(
  tangent_vec,
  base_point,
  metric = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 1]</code>
specifying one or more tangent vectors at corresponding base points.</p>
</dd>
<dt><code>base_point</code></dt><dd><p>A numeric array of shape <code class="reqn">[\dots \times 1]</code>
specifying one or more points on the manifold.</p>
</dd>
<dt><code>metric</code></dt><dd><p>An object of class <code><a href="#topic+RiemannianMetric">RiemannianMetric</a></code> specifying the
metric to compute the norm of the tangent vector or <code>NULL</code>. If it is
set to <code>NULL</code>, it defaults to using the Euclidean metric.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times 1]</code> storing the
regularized tangent vector(s).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$regularize_tangent_vec(array(0), array(1))
}
</pre>
</div>


<hr>
<a id="method-SpecialOrthogonalVectors-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpecialOrthogonalVectors$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SpecialOrthogonalVectors$projection`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$projection(diag(1, 2))
}

## ------------------------------------------------
## Method `SpecialOrthogonalVectors$skew_matrix_from_vector`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$skew_matrix_from_vector(array(0))
}

## ------------------------------------------------
## Method `SpecialOrthogonalVectors$vector_from_skew_matrix`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$vector_from_skew_matrix(diag(0, 2))
}

## ------------------------------------------------
## Method `SpecialOrthogonalVectors$regularize_tangent_vec_at_identity`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$regularize_tangent_vec_at_identity(array(0))
}

## ------------------------------------------------
## Method `SpecialOrthogonalVectors$regularize_tangent_vec`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  so2 &lt;- SpecialOrthogonal(n = 2, point_type = "vector")
  so2$regularize_tangent_vec(array(0), array(1))
}
</code></pre>

<hr>
<h2 id='VectorSpace'>Abstract Class for Vector Space Manifolds</h2><span id='topic+VectorSpace'></span>

<h3>Description</h3>

<p>Abstract class for vector spaces.
</p>


<h3>Super classes</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code><a href="#topic+Manifold">rgeomstats::Manifold</a></code> -&gt; <code>VectorSpace</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>basis</code></dt><dd><p>Basis of the vector space.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-VectorSpace-new"><code>VectorSpace$new()</code></a>
</p>
</li>
<li> <p><a href="#method-VectorSpace-projection"><code>VectorSpace$projection()</code></a>
</p>
</li>
<li> <p><a href="#method-VectorSpace-clone"><code>VectorSpace$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class'><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href='../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class'><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="belongs"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-belongs'><code>rgeomstats::Manifold$belongs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="is_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-is_tangent'><code>rgeomstats::Manifold$is_tangent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_point"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_point'><code>rgeomstats::Manifold$random_point()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="random_tangent_vec"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-random_tangent_vec'><code>rgeomstats::Manifold$random_tangent_vec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="regularize"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-regularize'><code>rgeomstats::Manifold$regularize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="set_metric"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-set_metric'><code>rgeomstats::Manifold$set_metric()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="Manifold" data-id="to_tangent"><a href='../../rgeomstats/html/Manifold.html#method-Manifold-to_tangent'><code>rgeomstats::Manifold$to_tangent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-VectorSpace-new"></a>



<h4>Method <code>new()</code></h4>

<p>The <code><a href="#topic+VectorSpace">VectorSpace</a></code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>VectorSpace$new(shape, ..., py_cls = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>shape</code></dt><dd><p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Extra arguments to be passed to parent class constructors. See
<code><a href="#topic+Manifold">Manifold</a></code> class.</p>
</dd>
<dt><code>py_cls</code></dt><dd><p>A Python object of class <code>VectorSpace</code>. Defaults to <code>NULL</code>
in which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+VectorSpace">VectorSpace</a></code>.
</p>


<hr>
<a id="method-VectorSpace-projection"></a>



<h4>Method <code>projection()</code></h4>

<p>Project a point onto the vector space.
</p>


<h5>Usage</h5>

<div class="r"><pre>VectorSpace$projection(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p>A numeric array of shape <code>dim</code> specifying a vector in the
ambient space onto the manifold.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method is for compatibility and returns <code>point</code>. <code>point</code>
should have the right shape.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the input <code>vector</code>
projected onto the manifold.
</p>


<hr>
<a id="method-VectorSpace-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>VectorSpace$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui and Nina Miolane
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
