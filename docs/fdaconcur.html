<!DOCTYPE html><html><head><title>Help for package fdaconcur</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdaconcur}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ConcReg_Lag'><p>Functional Concurrent Regression with Lag Model</p></a></li>
<li><a href='#ConcurReg'><p>Functional Concurrent Regression using 2D smoothing</p></a></li>
<li><a href='#fitted_ptFCReg'><p>Fitted functional responses from a <code>ptFCReg</code> object.</p></a></li>
<li><a href='#GetCI_Dense'><p>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for densely observed data.</p></a></li>
<li><a href='#GetCI_Sparse'><p>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for sparsely observed data.</p></a></li>
<li><a href='#historyIndexDense'><p>Functional History Index Model</p></a></li>
<li><a href='#historyIndexSparse'><p>Functional History Index Model</p></a></li>
<li><a href='#ptFCReg'><p>Functional concurrent regression using pointwise multiple linear regression.</p></a></li>
<li><a href='#smPtFCRegCoef'><p>Smooth the concurrent effects functions in a <code>ptFCReg</code> object using local linear regression.</p>
The local linear regression is implemented using the function <code>Lwls1D</code>.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Concurrent Regression and History Index Models for Functional
Data</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/functionaldata/tFDAconcur">https://github.com/functionaldata/tFDAconcur</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/functionaldata/tFDAconcur/issues">https://github.com/functionaldata/tFDAconcur/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Su I Iao &lt;siao@ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an implementation of concurrent or varying coefficient regression methods for 
    functional data. The implementations are done for both dense and sparsely observed functional
    data. Pointwise confidence bands can be constructed for each case. Further, the influence of
    past predictor values are modeled by a smooth history index function, 
    while the effects on the response are described by smooth varying coefficient functions, 
    which are very useful in analyzing real data such as COVID data.
    References: Yao, F., Müller, H.G., Wang, J.L. (2005) &lt;<a href="https://doi.org/10.1214%2F009053605000000660">doi:10.1214/009053605000000660</a>&gt;.
                Sentürk, D., Müller, H.G. (2010) &lt;<a href="https://doi.org/10.1198%2Fjasa.2010.tm09228">doi:10.1198/jasa.2010.tm09228</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>fdapace, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, Rcpp (&ge; 0.11.5), Matrix, pracma, numDeriv, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-07 19:08:21 UTC; suiiao</td>
</tr>
<tr>
<td>Author:</td>
<td>Su I Iao [aut, cre],
  Satarupa Bhattacharjee [aut],
  Yaqing Chen [aut],
  Changbo Zhu [aut],
  Han Chen [aut],
  Yidong Zhou [aut],
  Álvaro Gajardo [aut],
  Poorbita Kundu [aut],
  Hang Zhou [aut],
  Hans-Georg Müller [cph, ths, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-08 23:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='ConcReg_Lag'>Functional Concurrent Regression with Lag Model</h2><span id='topic+ConcReg_Lag'></span>

<h3>Description</h3>

<p>Functional concurrent regression model with lag for dense functional responses and dense functional predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConcReg_Lag(Y, X, Lag = NULL, optnsY = NULL, optnsX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConcReg_Lag_+3A_y">Y</code></td>
<td>
<p>a list which contains functional responses in the form of a list LY and the time points LT at which they are observed (i.e., list(Ly = LY,Lt = LT)).</p>
</td></tr>
<tr><td><code id="ConcReg_Lag_+3A_x">X</code></td>
<td>
<p>a list of lists which contains the observed functional predictors list Lxj and the time points list Ltj at which they are observed. It needs to be of the form <code>list(list(Ly = Lx1,Lt = Lxt1),list(Ly = Lx2,Lt = Lxt2),...)</code>.</p>
</td></tr>
<tr><td><code id="ConcReg_Lag_+3A_lag">Lag</code></td>
<td>
<p>a length <code>length(X)</code> vector denoting the lags for all predictors.</p>
</td></tr>
<tr><td><code id="ConcReg_Lag_+3A_optnsy">optnsY</code></td>
<td>
<p>a list of options control parameters for the response specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in <code>fdapace::FPCA</code>.</p>
</td></tr>
<tr><td><code id="ConcReg_Lag_+3A_optnsx">optnsX</code></td>
<td>
<p>a list of options control parameters for the predictors specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in <code>fdapace::FPCA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional concurrent regression model with lag is defined as 
</p>
<p style="text-align: center;"><code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{j=1}^p\beta_j(t)X_j(t-Lag[j])</code>
</p>
 
<p>For more details we refer to 
<cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>a vector of <code>length(workGridY)</code> representing the fitted <code class="reqn">\beta_0(t)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A matrix for the concurrent regression effects, where rows correspond to different predictors and columns to different time points.</p>
</td></tr>
<tr><td><code>workGridY</code></td>
<td>
<p>a vetor representing the working grid for the response.</p>
</td></tr>
<tr><td><code>Lag</code></td>
<td>
<p>a vector representing the lags for all predictors</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
<cite>Yao, F., Müller, H.G., Wang, J.L. (2005). Functional linear regression analysis for longitudinal data. Annals of Statistics 33, 2873&ndash;2903.</cite>
<cite>Hall, P., Horowitz, J.L. (2007). Methodology and convergence rates for functional linear regression. The Annals of Statistics, 35(1), 70&ndash;91.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi1 &lt;- function(t) sin(pi*t / 5) / sqrt(5)
phi2 &lt;- function(t) cos(pi*t / 5) / sqrt(5)
lambdaX &lt;- c(10, 5)
n &lt;- 50
N &lt;- 101
Xi &lt;- matrix(rnorm(2*n), nrow = n, ncol = 2)
denseLt &lt;- list()
denseLy &lt;- list()
t0 &lt;- seq(0, 15, length.out = N)
for (i in 1:n) {
  denseLt[[i]] &lt;- t0
  denseLy[[i]] &lt;- lambdaX[1]*Xi[i, 1]*phi1(t0) + lambdaX[2]*Xi[i, 2]*phi2(t0)
}
denseX0 &lt;- list(Ly = denseLy,Lt = denseLt)

Lag &lt;- c(3)
t0_out &lt;- t0[t0&gt;=max(Lag)]
beta_1 &lt;- function(t) 5*sin(pi*t/10)
beta_0 &lt;- function(t) t^2/2
### functional response Y(t), t in t0_out ### 
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n) {
  denseLt[[i]] &lt;- t0_out
  denseLy[[i]] &lt;- beta_0(t0_out) +  
    denseX0$Ly[[i]][1:length(t0_out)]* beta_1(t0_out) + 
    rnorm(length(t0_out), 0, 0.1) 
}
denseY &lt;- list(Ly = denseLy, Lt = denseLt)
model = ConcReg_Lag(Y=denseY, X=list(X1 = denseX0), Lag=Lag)

print(model$workGridY) # workGrid for Y between 6 to 15
plot(beta_1(model$workGridY)) # workGrid for X1 between 3 to 12 
plot(beta_0(model$workGridY))

plot(model$beta[1,])
plot(model$beta0)
</code></pre>

<hr>
<h2 id='ConcurReg'>Functional Concurrent Regression using 2D smoothing</h2><span id='topic+ConcurReg'></span>

<h3>Description</h3>

<p>Functional concurrent regression with dense or sparse functional data for scalar or functional dependent variables. Note: function-to-scalar regression can also be handled using the VCAM function in fdapace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConcurReg(
  vars,
  outGrid,
  userBwMu = NULL,
  userBwCov = NULL,
  kern = "gauss",
  measurementError = FALSE,
  diag1D = "all",
  useGAM = FALSE,
  returnCov = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConcurReg_+3A_vars">vars</code></td>
<td>
<p>A list of input functional/scalar covariates.
Each field corresponds to a functional (a list) or scalar (a vector) covariate. 
The last entry is assumed to be the response if no entry is named 'Y'.
If a field corresponds to a functional covariate, it should have two fields: 'Lt', a list of time points, and 'Ly', a list of functional values.</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_outgrid">outGrid</code></td>
<td>
<p>A vector of output time points.</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_userbwmu">userBwMu</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the mean function. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. If you only input a scalar, the function will use the same bandwidth to smooth all mean functions. &mdash; a scalar/vector of positive numeric -
default: NULL &mdash; if no scalar/vector value is provided, the bandwidth value for the smoothed mean function is chosen using 'GCV';</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_userbwcov">userBwCov</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the auto or cross-covariances. If you use 1D smoothing for the diagonal line of the covariance (diag1D=&quot;all&quot;), only one scalar input is needed. If you use 2D smoothing for the covariance (diag1D=&quot;none&quot;), a vector of bandwidth is required. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. &mdash; a scalar/vector of positive numeric - 
default: NULL &mdash; if no scalar/vector is provided, the bandwidth value for the smoothed cross-covariance function is chosen using 'GCV';</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_kern">kern</code></td>
<td>
<p>Smoothing kernel choice, common for mu and covariance; &quot;rect&quot;, &quot;gauss&quot;, &quot;epan&quot;, &quot;gausvar&quot;, &quot;quar&quot; - default: &quot;gauss&quot;.</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_measurementerror">measurementError</code></td>
<td>
<p>Assume measurement error in the data; logical - default: FALSE. If TRUE the diagonal raw covariance will be removed when smoothing.</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_diag1d">diag1D</code></td>
<td>
<p>A string specifying whether to use 1D smoothing for the diagonal line of the covariance. 
'none': don't use 1D smoothing; 'all': use 1D for both auto- and cross-covariances. (default : 'all')</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_usegam">useGAM</code></td>
<td>
<p>Use GAM smoothing instead of local linear smoothing (semi-parametric option);  logical - default: FALSE.</p>
</td></tr>
<tr><td><code id="ConcurReg_+3A_returncov">returnCov</code></td>
<td>
<p>Return the covariance surfaces, which is a four dimensional array. The first two dimensions correspond to outGrid
and the last two correspond to the covariates and the response, i.e. (i, j, k, l) entry being Cov(X_k(t_i), X_l(t_j));  logical - default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If measurement error is assumed, the diagonal elements of the raw covariance will be removed. This could result in highly unstable estimate if the design is very sparse, or strong seasonality presents. 
WARNING! For very sparse functional data, setting measurementError = TRUE is not recommended.
</p>


<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>A matrix for the concurrent regression effects, where rows correspond to different predictors and columns to different time points.</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>A vector containing the time-varying intercept.</p>
</td></tr>
<tr><td><code>outGrid</code></td>
<td>
<p>A vector of the output time points.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>A 4-dimensional array for the (cross-)covariance surfaces, with the (i, j, k, l) entry being Cov(X_k(t_i), X_l(t_j))</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>A vector of the time-varying R2.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li> <p><cite>Yao, F., Müller, H.G., Wang, J.L. &quot;Functional Linear Regression Analysis for Longitudinal Data.&quot; Annals of Statistics 33, (2005): 2873-2903.(Dense data)</cite> 
</p>
</li>
<li> <p><cite>Sentürk, D., Müller, H.G. &quot;Functional varying coefficient models for longitudinal data.&quot; J. American Statistical Association, 10, (2010): 1256&ndash;1264.</cite>
</p>
</li>
<li> <p><cite>Sentürk, D., Nguyen, D.V. &quot;Varying Coefficient Models for Sparse Noise-contaminated Longitudinal Data&quot;, Statistica Sinica 21(4), (2011): 1831-1856. (Sparse data)</cite> 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Y(t) = beta_0(t) + beta_1(t) X_1(t) + beta_2(t) Z_2 + epsilon
#
# Settings
set.seed(1)
n &lt;- 30
nGridIn &lt;- 50
sparsity &lt;- 5:10 # Sparse data sparsity
T &lt;- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw &lt;- 0.1
outGrid &lt;- round(seq(min(T), 1, by=0.05), 2)
 outGrid &lt;- seq(min(T), max(T), by=0.05)
# Simulate functional data
mu &lt;- T * 2 # mean function for X_1
sigma &lt;- 1

beta_0 &lt;- 0
beta &lt;- rbind(cos(T), 1.5 + sin(T))
beta_2 &lt;- 1

Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
  Y[i, ] &lt;- beta_0 + beta[1,]*X_1[i, ] + beta[2,]*Z[i, 2] + epsilon[i]
}

# Sparsify functional data
set.seed(1)
X_1sp &lt;- fdapace::Sparsify(X_1, T, sparsity)
set.seed(1)
Ysp &lt;- fdapace::Sparsify(Y, T, sparsity)
vars &lt;- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res2 &lt;- ConcurReg(vars, outGrid, userBwMu=c(.5,0,.5), userBwCov=c(.5,0,.5), kern='gauss',
 measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
</code></pre>

<hr>
<h2 id='fitted_ptFCReg'>Fitted functional responses from a <code>ptFCReg</code> object.</h2><span id='topic+fitted_ptFCReg'></span>

<h3>Description</h3>

<p>Fitted functional responses from a <code>ptFCReg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitted_ptFCReg(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_ptFCReg_+3A_object">object</code></td>
<td>
<p>An object of class <code>ptFCReg</code>, returned by <code><a href="#topic+ptFCReg">ptFCReg</a></code> or <code><a href="#topic+smPtFCRegCoef">smPtFCRegCoef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n</code>-by-<code class="reqn">m</code> matrix, where each row corresponds to one subject,
and each column corresponds to a time point in <code>object$tGrid</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 50
nGridIn &lt;- 101
tGrid &lt;- seq(0, 1, length.out=nGridIn) # Functional data support
muX1 &lt;- tGrid * 2 # mean function for X_1
sigma &lt;- 1
beta0 &lt;- 0
beta &lt;- rbind(cos(tGrid), 1.5 + sin(tGrid))
Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(muX1, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- t(sapply(seq_len(n), function(i) {
  beta0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}))
dat &lt;- list(X1=X_1, Z1=Z[, 2], Y=Y)
res &lt;- ptFCReg(tGrid = tGrid, dat = dat)
smres &lt;- smPtFCRegCoef(res, bw = 2.5 / (nGridIn-1), kernel_type = 'epan')
fit_res &lt;- stats::fitted(res)
fit_smres &lt;- stats::fitted(smres)
</code></pre>

<hr>
<h2 id='GetCI_Dense'>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for densely observed data.</h2><span id='topic+GetCI_Dense'></span>

<h3>Description</h3>

<p>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for densely observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCI_Dense(dat, tGrid, level = 0.95, R = 10, bw, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCI_Dense_+3A_dat">dat</code></td>
<td>
<p>A list of input functional/scalar covariates. 
Each field corresponds to a functional (a matrix) or scalar (a vector) variable. 
The last entry is assumed to be the functional response if no entry is names <code>'Y'</code>. 
If a field corresponds to a functional variable, it should be an <code class="reqn">n</code>-by-<code class="reqn">m</code> matrix,
where each row holds the observations for one subject on the common grid <code>tGrid</code>. 
If a field corresponds to a scalar covariate, it should be a vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="GetCI_Dense_+3A_tgrid">tGrid</code></td>
<td>
<p>A vector of length <code class="reqn">m</code> with the input time points.</p>
</td></tr>
<tr><td><code id="GetCI_Dense_+3A_level">level</code></td>
<td>
<p>A number taking values in [0,1] determing the confidence level. Default: 0.95.</p>
</td></tr>
<tr><td><code id="GetCI_Dense_+3A_r">R</code></td>
<td>
<p>An integer holding the number of bootstrap replicates. Default: 999.</p>
</td></tr>
<tr><td><code id="GetCI_Dense_+3A_bw">bw</code></td>
<td>
<p>Scalar holding the bandwidth.</p>
</td></tr>
<tr><td><code id="GetCI_Dense_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Character holding the kernel type (see <code><a href="fdapace.html#topic+Lwls1D">Lwls1D</a></code> for supported kernels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following fields: 
</p>

<dl>
<dt>CI_beta0</dt><dd><p>CI for the intercept function &mdash; A data frame holding three variables: 
<code>CIgrid</code> &mdash; the time grid where the CIs are evaluated;
<code>CI_beta0.lower</code> and <code>CI_beta0.upper</code> &mdash; the lower and upper bounds of the CIs
for the intercept function on <code>CIgrid</code>.</p>
</dd>
<dt>CI_beta</dt><dd><p> A list containing CIs for the slope functions &mdash; the length of
the list is same as the number of covariates. Each list contains the following fields:
A data frame holding three variables: <code>CIgrid</code> &mdash; the time grid where the CIs are evaluated,
<code>CI_beta_j.lower</code> and <code>CI_beta_j.upper</code> &mdash; the lower and upper bounds of the CIs 
for the intercept function on <code>CIgrid</code> for <code class="reqn">j = 1,2,\dots</code>.</p>
</dd>
<dt>CI_R2</dt><dd><p>CI the time-varying <code class="reqn">R^2(t)</code> &mdash; A data frame holding three variables: 
<code>CIgrid</code> &mdash; the time grid where the CIs are evaluated,
<code>CI_R2.lower</code> and <code>CI_R2.upper</code> &mdash; the lower and upper bounds of the CIs 
for the time-varying <code class="reqn">R^2(t)</code> on <code>CIgrid</code>.</p>
</dd>
<dt>level</dt><dd><p>The confidence level of the CIs.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 50
nGridIn &lt;- 101
tGrid &lt;- seq(0, 1, length.out=nGridIn) # Functional data support
muX1 &lt;- tGrid * 2 # mean function for X_1
sigma &lt;- 1
beta0 &lt;- 0
beta &lt;- rbind(cos(tGrid), 1.5 + sin(tGrid))
Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(muX1, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- t(sapply(seq_len(n), function(i) {
  beta0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}))
dat &lt;- list(X1=X_1, Z1=Z[, 2], Y=Y)
res &lt;- ptFCReg(tGrid = tGrid, dat = dat)
smres &lt;- smPtFCRegCoef(res, bw =  2.5 / (nGridIn-1), kernel_type = 'epan')
res_CI = GetCI_Dense(dat, tGrid, level = 0.95, R = 10, bw = 2.5 / (nGridIn-1), kernel_type = 'epan')
beta1 = res_CI$CI_beta[[1]] ##extracting CI for beta1
beta1a = beta1$CI_beta1.lower
beta1b = beta1$CI_beta1.upper
true_beta = beta[1,]  ##extracting true coef beta1 in the simulation setting
est_beta = smres$beta[1,] ## ##extracting estimated coef beta1 from 
###fitting the concurrent regression model
plot(beta1$CIgrid, beta1a, type= 'l', ylim = c(0,2)) ##plot of lower CI for beta1
lines(beta1$CIgrid, beta1b) ##plot of lower CI for beta1
lines(beta1$CIgrid, true_beta, col ='red')  
##plot of true coef beta1 in the simulation setting
lines(beta1$CIgrid, est_beta, col ='blue') 
##plot of estimated coef beta1 from fitting the concurrent regression model
</code></pre>

<hr>
<h2 id='GetCI_Sparse'>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for sparsely observed data.</h2><span id='topic+GetCI_Sparse'></span>

<h3>Description</h3>

<p>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for sparsely observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCI_Sparse(
  vars,
  outGrid = NULL,
  level = 0.95,
  R = 999,
  userBwMu = NULL,
  userBwCov = NULL,
  kern = "gauss",
  measurementError = FALSE,
  diag1D = "all",
  useGAM = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCI_Sparse_+3A_vars">vars</code></td>
<td>
<p>A list of input functional/scalar covariates.
Each field corresponds to a functional (a list) or scalar (a vector) covariate. 
The last entry is assumed to be the response if no entry is named 'Y'.
If a field corresponds to a functional covariate, it should have two fields: 'Lt', a list of time points, and 'Ly', a list of functional values.</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_outgrid">outGrid</code></td>
<td>
<p>A vector with the output time points, which need to be within 5% and 95% of the range of functional covariates. If NULL, outGrid will be generated from 5% to 95% of the range of functional covariates with 51 grids for fitting. Default: NULL</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_level">level</code></td>
<td>
<p>A number taking values in [0,1] determining the confidence level. Default: 0.95.</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_r">R</code></td>
<td>
<p>An integer holding the number of bootstrap replicates. Default: 999.</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_userbwmu">userBwMu</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the mean function. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. If you only input a scalar, the function will use the same bandwidth to smooth all mean functions. &mdash; a scalar/vector of positive numeric -
default: NULL &mdash; if no scalar/vector value is provided, the bandwidth value for the smoothed mean function is chosen using 'GCV';</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_userbwcov">userBwCov</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the auto or cross-covariances. If you use 1D smoothing for the diagonal line of the covariance (diag1D=&quot;all&quot;), only one scalar input is needed. If you use 2D smoothing for the covariance (diag1D=&quot;none&quot;), a vector of bandwidth is required. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. &mdash; a scalar/vector of positive numeric - 
default: NULL &mdash; if no scalar/vector is provided, the bandwidth value for the smoothed cross-covariance function is chosen using 'GCV';</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_kern">kern</code></td>
<td>
<p>Smoothing kernel choice, common for mu and covariance; 
&quot;rect&quot;, &quot;gauss&quot;, &quot;epan&quot;, &quot;gausvar&quot;, &quot;quar&quot; (default: &quot;gauss&quot;)</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_measurementerror">measurementError</code></td>
<td>
<p>Assume measurement error in the data; logical - default: FALSE. If TRUE the diagonal raw covariance will be removed when smoothing.</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_diag1d">diag1D</code></td>
<td>
<p>A string specifying whether to use 1D smoothing for the diagonal line of the covariance. 
'none': don't use 1D smoothing; 'all': use 1D for both auto- and cross-covariances. (default : 'all')</p>
</td></tr>
<tr><td><code id="GetCI_Sparse_+3A_usegam">useGAM</code></td>
<td>
<p>Use GAM smoothing instead of local linear smoothing (semi-parametric option);  logical - default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If measurement error is assumed, the diagonal elements of the raw covariance will be removed. This could result in highly unstable estimate 
if the design is very sparse, or strong seasonality presents. 
WARNING! For very sparse functional data, setting measurementError = TRUE is not recommended.
</p>


<h3>Value</h3>

<p>A list containing the following fields: 
</p>

<dl>
<dt>CI_beta0</dt><dd><p>CI for the intercept function &mdash; A data frame holding three variables: 
<code>CIgrid</code> &mdash; the time grid where the CIs are evaluated,
<code>CI_beta0.lower</code> and <code>CI_beta0.upper</code> &mdash; the lower and upper bounds of the CIs 
for the intercept function on <code>CIgrid</code>.</p>
</dd>
<dt>CI_beta</dt><dd><p> A list containing CIs for the slope functions &mdash; the length of
the list is same as the number of covariates. Each list contains the following fields:
A data frame holding three variables: <code>CIgrid</code> &mdash; the time grid where the CIs are evaluated,
<code>CI_beta_j.lower</code> and <code>CI_beta_j.upper</code> &mdash; the lower and upper bounds of the CIs 
for the coefficient functions on <code>CIgrid</code> for <code class="reqn">j = 1,2,\dots</code>.</p>
</dd>
<dt>CI_R2</dt><dd><p>CI the time-varying <code class="reqn">R^2(t)</code> &mdash; A data frame holding three variables: 
<code>CIgrid</code> &mdash; the time grid where the CIs are evaluated,
<code>CI_R2.lower</code> and <code>CI_R2.upper</code> &mdash; the lower and upper bounds of the CIs 
for the time-varying <code class="reqn">R^2(t)</code> on <code>CIgrid</code>.</p>
</dd>
<dt>level</dt><dd><p>The confidence level of the CIs.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 30
nGridIn &lt;- 100
sparsity &lt;- 5:10 # Sparse data sparsity
T &lt;- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw &lt;- 0.1
outGrid &lt;- round(seq(min(T), 1, by=0.05), 2)
# Simulate functional data
mu &lt;- T * 2 # mean function for X_1
sigma &lt;- 1

beta_0 &lt;- 0
beta &lt;- rbind(cos(T), 1.5 + sin(T))
beta_2 &lt;- 1

Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
  Y[i, ] &lt;- beta_0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}

# Sparsify functional data
set.seed(1)
X_1sp &lt;- fdapace::Sparsify(X_1, T, sparsity)
Ysp &lt;- fdapace::Sparsify(Y, T, sparsity)
vars &lt;- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res &lt;-  GetCI_Sparse(vars, outGrid[-c(1,21)], level = 0.95, R = 2,
                     userBwMu = c(.1,.1,.1), userBwCov = c(.1,.1,.1),
                     kern='gauss', measurementError=TRUE, diag1D='none',
                     useGAM = FALSE)
</code></pre>

<hr>
<h2 id='historyIndexDense'>Functional History Index Model</h2><span id='topic+historyIndexDense'></span>

<h3>Description</h3>

<p>Functional history index model for dense functional responses and dense functional predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>historyIndexDense(Y, X, Lag = NULL, optnsY = NULL, optnsX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="historyIndexDense_+3A_y">Y</code></td>
<td>
<p>a list which contains functional responses in the form of a list LY and the time points LT at which they are observed (i.e., list(Ly = LY,Lt = LT)).</p>
</td></tr>
<tr><td><code id="historyIndexDense_+3A_x">X</code></td>
<td>
<p>a list of lists which contains the observed functional predictors list Lxj and the time points list Ltj at which they are observed. It needs to be of the form <code>list(list(Ly = Lx1,Lt = Lxt1),list(Ly = Lx2,Lt = Lxt2),...)</code>.</p>
</td></tr>
<tr><td><code id="historyIndexDense_+3A_lag">Lag</code></td>
<td>
<p>a length <code>length(X)</code> vector denoting the lags for all predictors.</p>
</td></tr>
<tr><td><code id="historyIndexDense_+3A_optnsy">optnsY</code></td>
<td>
<p>a list of options control parameters for the response specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in <code>fdapace::FPCA</code>.</p>
</td></tr>
<tr><td><code id="historyIndexDense_+3A_optnsx">optnsX</code></td>
<td>
<p>a list of options control parameters for the predictors specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in <code>fdapace::FPCA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional history index model is defined as 
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{i=1}^p\beta_i(t)\int_0^{\Delta_i}\gamma_i(s)X_i(t-s)ds</code> 
for <code class="reqn">t\in[\max_i\{\Delta_i\}, T]</code> with a suitable <code class="reqn">T&gt;0</code>. 
Write <code class="reqn">\alpha_i(t, s)=\beta_i(t)\gamma_i(s)</code>. It becomes 
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{i=1}^p\int_0^{\Delta_i}\alpha_i(t, s)X_i(t-s)ds</code>. 
For more details we refer to 
<cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>a vector of <code>length(workGridY)</code> representing the fitted <code class="reqn">\beta_0(t)</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>a list of matrices with the <code class="reqn">i</code>-th element representing the fitted <code class="reqn">\alpha_i(t, s)</code></p>
</td></tr>
<tr><td><code>yHat</code></td>
<td>
<p>an n by <code>length(workGridY)</code> matrix of fitted <code class="reqn">Y_i(t)</code>'s.</p>
</td></tr>
<tr><td><code>workGridY</code></td>
<td>
<p>a vetor representing the working grid for the response.</p>
</td></tr>
<tr><td><code>workGridLag</code></td>
<td>
<p>a list of vectors with the <code class="reqn">i</code>-th element representing the working grid in <code class="reqn">[0, \Delta_i]</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
<cite>Yao, F., Müller, H.G., Wang, J.L. (2005). Functional linear regression analysis for longitudinal data. Annals of Statistics 33, 2873&ndash;2903.</cite>
<cite>Hall, P., Horowitz, J.L. (2007). Methodology and convergence rates for functional linear regression. The Annals of Statistics, 35(1), 70&ndash;91.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### functional covariate X(t) ###
phi1 &lt;- function(t) sin(pi*t / 5) / sqrt(5)
phi2 &lt;- function(t) cos(pi*t / 5) / sqrt(5)
lambdaX &lt;- c(10, 5)
n &lt;- 150
N &lt;- 101
Xi &lt;- matrix(rnorm(2*n), nrow = n, ncol = 2)
denseLt &lt;- list()
denseLy &lt;- list()
t0 &lt;- seq(0, 15, length.out = N)
for (i in 1:n) {
  denseLt[[i]] &lt;- t0
  denseLy[[i]] &lt;- lambdaX[1]*Xi[i, 1]*phi1(t0) + lambdaX[2]*Xi[i, 2]*phi2(t0)
}
denseX0 &lt;- list(Ly = denseLy, Lt = denseLt)

### generate coefficient function gamma(u), beta(u) ###
Lag &lt;- 5
u0 &lt;- t0[t0&lt;=Lag]
t0_out &lt;- t0[t0&gt;=Lag]
gamma_u &lt;- function(u) sqrt(2/5) * cos(pi * u /5)
beta_1 &lt;- function(t) 5*sin(pi*t/10)
beta_0 &lt;- function(t) t^2/2

### functional response Y(t), t in t0_out ### 
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n) {
  denseLt[[i]] &lt;- t0_out
  Xt &lt;- denseX0$Ly[[i]]
  Xtu &lt;- t(sapply((1:N)[t0&gt;=Lag], function(j){
    rev(Xt[(j-length(u0)+1):j])  #history index for X[t-u:t]
  }))
  IntGammaXtu &lt;- apply(Xtu, 1, function(v){
    fdapace::trapzRcpp(u0, gamma_u(u0) * v)
  })
  #append 0 in the first length(u0)-1 element(useless info. in our modeling)
  denseLy[[i]] &lt;- beta_0(t0_out) + IntGammaXtu * beta_1(t0_out) + rnorm(length(t0_out), 0, 0.1) 
}
denseY &lt;- list(Ly = denseLy, Lt = denseLt)

### functional predictor X(t) (adjust for t0_out) ###
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n){
  denseLt[[i]] &lt;- t0_out
  denseLy[[i]] &lt;- denseX0$Ly[[i]][t0&gt;=Lag]
}
denseX &lt;- list(Ly = denseLy,
               Lt = denseLt)
fit &lt;- historyIndexDense(Y = denseY, X = list(X = denseX), Lag = Lag)
fit$beta0
fit$alpha[[1]]
</code></pre>

<hr>
<h2 id='historyIndexSparse'>Functional History Index Model</h2><span id='topic+historyIndexSparse'></span>

<h3>Description</h3>

<p>Functional history index model for functional responses and functional predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>historyIndexSparse(Y, X, Lag = NULL, optnsY = NULL, optnsX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="historyIndexSparse_+3A_y">Y</code></td>
<td>
<p>A list which contains functional responses in the form of a list LY and the time points LT at which they are observed (i.e., list(Ly = LY,Lt = LT)).</p>
</td></tr>
<tr><td><code id="historyIndexSparse_+3A_x">X</code></td>
<td>
<p>A list of lists which contains the observed functional predictors list Lxj and the time points list Ltj at which they are observed. It needs to be of the form <code>list(list(Ly = Lx1,Lt = Lxt1),list(Ly = Lx2,Lt = Lxt2),...)</code>.</p>
</td></tr>
<tr><td><code id="historyIndexSparse_+3A_lag">Lag</code></td>
<td>
<p>A length <code>length(X)</code> vector denoting the lags for all predictors.</p>
</td></tr>
<tr><td><code id="historyIndexSparse_+3A_optnsy">optnsY</code></td>
<td>
<p>A list of options control parameters for the response specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in  <code>FPCA</code>.</p>
</td></tr>
<tr><td><code id="historyIndexSparse_+3A_optnsx">optnsX</code></td>
<td>
<p>A list of options control parameters for the predictors specified by <code>list(name=value)</code>. See &lsquo;Details&rsquo; in  <code>FPCA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional history index model is defined as 
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{j=1}^p\beta_j(t)\int_0^{\Delta_j}\gamma_j(s)X_j(t-s)ds</code> 
for <code class="reqn">t\in[\max_j\{\Delta_j\}, T]</code> with a suitable <code class="reqn">T&gt;0</code>. 
Write <code class="reqn">\alpha_j(t, s)=\beta_j(t)\gamma_j(s)</code>. It becomes 
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{j=1}^p\int_0^{\Delta_j}\alpha_j(t, s)X_j(t-s)ds</code>. 
For more details we refer to 
<cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>a vector of <code>length(workGridY)</code> representing the fitted <code class="reqn">\beta_0(t)</code>.</p>
</td></tr>
<tr><td><code>beta1</code></td>
<td>
<p>a list of vectors with the <code class="reqn">j</code>-th element representing the fitted <code class="reqn">\beta_j(t)</code>.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>a list of vectors with the <code class="reqn">j</code>-th element representing the fitted <code class="reqn">\gamma_j(s)</code>.</p>
</td></tr>
<tr><td><code>workGridY</code></td>
<td>
<p>a vetor representing the working grid for the response.</p>
</td></tr>
<tr><td><code>workGridLag</code></td>
<td>
<p>a list of vectors with the <code class="reqn">j</code>-th element representing the working grid in <code class="reqn">[0, \Delta_j]</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
<cite>Yao, F., Müller, H.G., Wang, J.L. (2005). Functional linear regression analysis for longitudinal data. Annals of Statistics 33, 2873&ndash;2903.</cite>
<cite>Hall, P., Horowitz, J.L. (2007). Methodology and convergence rates for functional linear regression. The Annals of Statistics, 35(1), 70&ndash;91.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
### functional covariate X(t) ###
phi1 &lt;- function(t) sin(pi*t / 5) / sqrt(5)
phi2 &lt;- function(t) cos(pi*t / 5) / sqrt(5)
lambdaX &lt;- c(10, 5)
n &lt;- 150
N &lt;- 101
Xi &lt;- matrix(rnorm(2*n), nrow = n, ncol = 2)
denseLt &lt;- list()
denseLy &lt;- list()
t0 &lt;- seq(0, 15, length.out = N)
for (i in 1:n) {
  denseLt[[i]] &lt;- t0
  denseLy[[i]] &lt;- lambdaX[1]*Xi[i, 1]*phi1(t0) + lambdaX[2]*Xi[i, 2]*phi2(t0)
}
denseX0 &lt;- list(Ly = denseLy,Lt = denseLt)

### generate coefficient function gamma(u), beta(u) ###
Lag &lt;- 5
u0 &lt;- t0[t0&lt;=Lag]
t0_out &lt;- t0[t0&gt;=Lag]
gamma_u &lt;- function(u) sqrt(2/5) * cos(pi * u /5)
beta_1 &lt;- function(t) 5*sin(pi*t/10)
beta_0 &lt;- function(t) t^2/2

### functional response Y(t), t in t0_out ### 
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n) {
  denseLt[[i]] &lt;- t0_out
  Xt &lt;- denseX0$Ly[[i]]
  Xtu &lt;- t(sapply((1:N)[t0&gt;=Lag], function(j){
    rev(Xt[(j-length(u0)+1):j])  #history index for X[t-u:t]
  }))
  IntGammaXtu &lt;- apply(Xtu, 1, function(v){
    fdapace::trapzRcpp(u0, gamma_u(u0) * v)
  })
  #append 0 in the first length(u0)-1 element(useless info. in our modeling)
  denseLy[[i]] &lt;- beta_0(t0_out) + IntGammaXtu * beta_1(t0_out) + rnorm(length(t0_out), 0, 0.1) 
}
denseY &lt;- list(Ly = denseLy, Lt = denseLt)

### functional predictor X(t) (adjust for t0_out) ###
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n){
  denseLt[[i]] &lt;- t0_out
  denseLy[[i]] &lt;- denseX0$Ly[[i]][t0&gt;=Lag]
}
denseX &lt;- list(Ly = denseLy,
               Lt = denseLt)
               
### sparify the dense data ###
SparseY &lt;- fdapace::Sparsify(samp = t(sapply(denseY$Ly, function(v) v)), 
                    pts = t0_out,
                    sparsity = sample(10:20, n, replace = TRUE)
)
SparseX &lt;- fdapace::Sparsify(samp = t(sapply(denseX$Ly, function(v) v)),
                    pts = t0_out,
                    sparsity = sample(10:20, n, replace = TRUE))

### model fitting for sparse case ###
Fit_result &lt;- historyIndexSparse(Y = SparseY, X = list(X = SparseX), Lag = Lag)
Fit_result$beta0
Fit_result$beta1
Fit_result$gamma
</code></pre>

<hr>
<h2 id='ptFCReg'>Functional concurrent regression using pointwise multiple linear regression.</h2><span id='topic+ptFCReg'></span>

<h3>Description</h3>

<p>Functional concurrent regression using pointwise multiple linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptFCReg(tGrid, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptFCReg_+3A_tgrid">tGrid</code></td>
<td>
<p>A vector of length <code class="reqn">m</code> with the input time points.</p>
</td></tr>
<tr><td><code id="ptFCReg_+3A_dat">dat</code></td>
<td>
<p>A list of input functional/scalar covariates. 
Each field corresponds to a functional (a matrix) or scalar (a vector) variable. 
The last entry is assumed to be the functional response if no entry is names <code>'Y'</code>. 
If a field corresponds to a functional variable, it should be an <code class="reqn">n</code>-by-<code class="reqn">m</code> matrix,
where each row holds the observations for one subject on the common grid <code>tGrid</code>. 
If a field corresponds to a scalar covariate, it should be a vector of length <code class="reqn">n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following fields: 
</p>

<dl>
<dt>beta0</dt><dd><p>A vector containing the time-varying intercept evaluated on <code>tGrid</code>.</p>
</dd>
<dt>beta</dt><dd><p>A matrix for the concurrent regression effects, 
where rows correspond to different predictors and columns to different time points in <code>tGrid</code>.</p>
</dd>
<dt>tGrid</dt><dd><p>The input <code>tGrid</code>.</p>
</dd>
<dt>R2</dt><dd><p>A vector of the time-varying <code class="reqn">R^2(t)</code>, evaluated at <code class="reqn">t</code> in <code>tGrid</code>.</p>
</dd>
<dt>Ldf</dt><dd><p>A list holding the input data, each element of which is a data frame holding 
the data observed at one element of <code>tGrid</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 50
nGridIn &lt;- 101
tGrid &lt;- seq(0, 1, length.out=nGridIn) # Functional data support
muX1 &lt;- tGrid * 2 # mean function for X_1
sigma &lt;- 1
beta0 &lt;- 0
beta &lt;- rbind(cos(tGrid), 1.5 + sin(tGrid))
Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(muX1, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- t(sapply(seq_len(n), function(i) {
  beta0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}))
dat &lt;- list(X1=X_1, Z1=Z[, 2], Y=Y)
res &lt;- ptFCReg(tGrid = tGrid, dat = dat)
</code></pre>

<hr>
<h2 id='smPtFCRegCoef'>Smooth the concurrent effects functions in a <code>ptFCReg</code> object using local linear regression.
The local linear regression is implemented using the function <code><a href="fdapace.html#topic+Lwls1D">Lwls1D</a></code>.</h2><span id='topic+smPtFCRegCoef'></span>

<h3>Description</h3>

<p>Smooth the concurrent effects functions in a <code>ptFCReg</code> object using local linear regression.
The local linear regression is implemented using the function <code><a href="fdapace.html#topic+Lwls1D">Lwls1D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smPtFCRegCoef(object, bw, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smPtFCRegCoef_+3A_object">object</code></td>
<td>
<p>An object of class <code>ptFCReg</code> returned by the function <code><a href="#topic+ptFCReg">ptFCReg</a></code>.</p>
</td></tr>
<tr><td><code id="smPtFCRegCoef_+3A_bw">bw</code></td>
<td>
<p>Scalar holding the bandwidth.</p>
</td></tr>
<tr><td><code id="smPtFCRegCoef_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Character holding the kernel type (see <code><a href="fdapace.html#topic+Lwls1D">Lwls1D</a></code> for supported kernels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ptFCReg</code>, where the fields <code>beta0</code> and <code>beta</code> 
hold the smoothed intercept functions and concurrent effects functions, respectively. 
See <code><a href="#topic+ptFCReg">ptFCReg</a></code> for a complete list of the fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 50
nGridIn &lt;- 101
tGrid &lt;- seq(0, 1, length.out=nGridIn) # Functional data support
muX1 &lt;- tGrid * 2 # mean function for X_1
sigma &lt;- 1
beta0 &lt;- 0
beta &lt;- rbind(cos(tGrid), 1.5 + sin(tGrid))
Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(muX1, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- t(sapply(seq_len(n), function(i) {
  beta0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}))
dat &lt;- list(X1=X_1, Z1=Z[, 2], Y=Y)
res &lt;- ptFCReg(tGrid = tGrid, dat = dat)
smres &lt;- smPtFCRegCoef(res, bw = 2.5 / (nGridIn-1), kernel_type = 'epan')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
