<!DOCTYPE html><html lang="en"><head><title>Help for package lori</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lori}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aravo'><p>Alpine plant communities in Aravo, France: Abundance data and covariates</p></a></li>
<li><a href='#covmat'><p>covmat</p></a></li>
<li><a href='#cv.lori'><p>The cv.lori method performs automatic selection of the</p>
regularization parameters (lambda1 and lambda2) used in
the lori function. These parameters are selected by
cross-validation. The classical procedure is to apply
cv.lori to the data to select the regularization parameters,
and to then impute and analyze the data using the lori
function (or mi.lori for multiple imputation).</a></li>
<li><a href='#lori'><p>The lori method implements a method to analyze and impute</p>
incomplete count tables. An important feature of the method
is that it can take into account main effects of rows and
columns, as well as effects of continuous or categorical
covariates, and interaction. The estimation procedure is
based on minimizing a Poisson loss penalized by a Lasso
type penalty (sparse vector of covariate effects) and a
nuclear norm penalty inducing a low-rank interaction matrix
(a few latent factors summarize the interactions).</a></li>
<li><a href='#mi.lori'><p>The mi.lori performs M multiple imputations using the</p>
lori method. Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform M multiple imputations using the mi.lori
method, and to aggregate them using the pool.lori method.</a></li>
<li><a href='#pool.lori'><p>The pool.lori method aggregates lori multiple imputation results.</p>
Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform multiple imputation using the mi.lori
method, and to aggregate them using the pool.lori method.</a></li>
<li><a href='#qut'><p>automatic selection of nuclear norm regularization parameter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation of High-Dimensional Count Data using Side Information</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Genevieve Robin &lt;genevieve.robin@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis, imputation, and multiple imputation of count data using covariates. LORI uses a log-linear Poisson model where main row and column effects, as well as effects of known covariates and interaction terms can be fitted. The estimation procedure is based on the convex optimization of the Poisson loss penalized by a Lasso type penalty and a nuclear norm. LORI returns estimates of main effects, covariate effects and interactions, as well as an imputed count table. The package also contains a multiple imputation procedure. The methods are described in Robin, Josse, Moulines and Sardy (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2019.04.004">doi:10.1016/j.jmva.2019.04.004</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/genevievelrobin/lori/issues">https://github.com/genevievelrobin/lori/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, data.table, rARPACK, svd, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-18 13:16:26 UTC; grobin</td>
</tr>
<tr>
<td>Author:</td>
<td>Genevieve Robin [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-18 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aravo'>Alpine plant communities in Aravo, France: Abundance data and covariates</h2><span id='topic+aravo'></span>

<h3>Description</h3>

<p>Originally published in Choler, P. 2005.
Consistent shifts in Alpine plant traits along a
mesotopographical gradient. Arctic, Antarctic, and
Alpine Research 37: 444–453.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aravo)
</code></pre>


<h3>Format</h3>

<p>A list with 4 attributes:
</p>

<dl>
<dt>spe</dt><dd><p>abundance table of 82 species in 75 environments</p>
</dd>
<dt>env</dt><dd><p>a matrix of 6 covariates for the 75 environments</p>
</dd>
<dt>traits</dt><dd><p>a matrix of 8 covariates for the 82 species</p>
</dd>
<dt>spe.names</dt><dd><p>a vector of 82 species names</p>
</dd>
</dl>



<h3>Details</h3>

<p>Analysed in Dray, S., Choler, P., Dolédec, S.,
Peres-Neto, P.R., Thuiler, W., Pavoine, S. &amp; ter Braak,
C.J.F. 2014. Combining the fourth-corner and the RLQ
methods for assessing trait responses to environmental
variation. Ecology 95: 14-21
</p>
<p>Description from Dray et al. (2014): Community composition of vascular
plants was determined in 75 5 × 5 m plots. Each site was
described by six environmental variables: mean snowmelt
date over the period 1997–1999, slope inclination, aspect,
index of microscale landform, index of physical disturbance
due to cryoturbation and solifluction, and an index of
zoogenic disturbance due to trampling and burrowing activities
of the Alpine marmot. All variables are quantitative except
the landform and zoogenic disturbance indices that are
categorical variables with five and three categories,
respectively. Eight quantitative functional traits (i.e.,
vegetative height, lateral spread, leaf elevation angle,
leaf area, leaf thickness, specific leaf area, mass-based
leaf nitrogen content, and seed mass) were measured on the
82 most abundant plant species (out of a total of 132
recorded species).
</p>


<h3>Source</h3>

<p><a href="http://pbil.univ-lyon1.fr/ade4/ade4-html/aravo.html">http://pbil.univ-lyon1.fr/ade4/ade4-html/aravo.html</a>
</p>

<hr>
<h2 id='covmat'>covmat</h2><span id='topic+covmat'></span>

<h3>Description</h3>

<p>covmat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat(n, p, R = NULL, C = NULL, E = NULL, center = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covmat_+3A_n">n</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="covmat_+3A_p">p</code></td>
<td>
<p>number ofcolumns</p>
</td></tr>
<tr><td><code id="covmat_+3A_r">R</code></td>
<td>
<p>nxK1 matrix of row covariates</p>
</td></tr>
<tr><td><code id="covmat_+3A_c">C</code></td>
<td>
<p>nxK2 matrix of column covariates</p>
</td></tr>
<tr><td><code id="covmat_+3A_e">E</code></td>
<td>
<p>(n+p)xK3 matrix of row-column covariates</p>
</td></tr>
<tr><td><code id="covmat_+3A_center">center</code></td>
<td>
<p>boolean indicating whether the returned covariate matrix should be centered (for identifiability)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the joint product of R and C column-binded with E, a (np)x(K1+K2+K3) matrix in order row1col1,row2col1,...,rowncol1, row1col2, row2col2,...,rowncolp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(rnorm(10), 5)
C &lt;- matrix(rnorm(9), 3)
covs &lt;- covmat(5,3,R,C)
</code></pre>

<hr>
<h2 id='cv.lori'>The cv.lori method performs automatic selection of the
regularization parameters (lambda1 and lambda2) used in
the lori function. These parameters are selected by
cross-validation. The classical procedure is to apply
cv.lori to the data to select the regularization parameters,
and to then impute and analyze the data using the lori
function (or mi.lori for multiple imputation).</h2><span id='topic+cv.lori'></span>

<h3>Description</h3>

<p>The cv.lori method performs automatic selection of the
regularization parameters (lambda1 and lambda2) used in
the lori function. These parameters are selected by
cross-validation. The classical procedure is to apply
cv.lori to the data to select the regularization parameters,
and to then impute and analyze the data using the lori
function (or mi.lori for multiple imputation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.lori(
  Y,
  cov = NULL,
  intercept = T,
  reff = T,
  ceff = T,
  rank.max = 5,
  N = 5,
  len = 20,
  prob = 0.2,
  algo = c("alt", "mcgd"),
  thresh = 1e-05,
  maxit = 10,
  trace.it = F,
  parallel = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.lori_+3A_y">Y</code></td>
<td>
<p>[matrix, data.frame] abundance table (nxp)</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_cov">cov</code></td>
<td>
<p>[matrix, data.frame] design matris (npxq)</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_intercept">intercept</code></td>
<td>
<p>[boolean] whether an intercept should be fitted, default value is FALSE</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_reff">reff</code></td>
<td>
<p>[boolean] whether row effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_ceff">ceff</code></td>
<td>
<p>[boolean] whether column effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_rank.max">rank.max</code></td>
<td>
<p>[integer] maximum rank of interaction matrix, default is 2</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_n">N</code></td>
<td>
<p>[integer] number of cross-validation folds</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_len">len</code></td>
<td>
<p>[integer] the size of the grid</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_prob">prob</code></td>
<td>
<p>[numeric in (0,1)] the proportion of entries to remove for cross-validation</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_algo">algo</code></td>
<td>
<p>type of algorithm to use, either one of &quot;mcgd&quot; (mixed coordinate gradient descent, adapted to large dimensions) or &quot;alt&quot; (alternating minimization, adapted to small dimensions)</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_thresh">thresh</code></td>
<td>
<p>[positive number] convergence threshold, default is 1e-5</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_maxit">maxit</code></td>
<td>
<p>[integer] maximum number of iterations, default is 100</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_trace.it">trace.it</code></td>
<td>
<p>[boolean] whether information about convergence should be printed</p>
</td></tr>
<tr><td><code id="cv.lori_+3A_parallel">parallel</code></td>
<td>
<p>[boolean] whether computations should be performed in parallel on multiple cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements
</p>
<table role = "presentation">
<tr><td><code>lambda1</code></td>
<td>
<p>regularization parameter estimated by cross-validation for nuclear norm penalty (interaction matrix)</p>
</td></tr>
<tr><td><code>lambda2</code></td>
<td>
<p>regularization parameter estimated by cross-validation for l1 norm penalty (main effects)</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>a table containing the prediction errors for all pairs of parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(20), 10)
Y &lt;- matrix(rpois(10, 1:10), 5)
res &lt;- cv.lori(Y, X, N=2, len=2)
</code></pre>

<hr>
<h2 id='lori'>The lori method implements a method to analyze and impute
incomplete count tables. An important feature of the method
is that it can take into account main effects of rows and
columns, as well as effects of continuous or categorical
covariates, and interaction. The estimation procedure is
based on minimizing a Poisson loss penalized by a Lasso
type penalty (sparse vector of covariate effects) and a
nuclear norm penalty inducing a low-rank interaction matrix
(a few latent factors summarize the interactions).</h2><span id='topic+lori'></span>

<h3>Description</h3>

<p>The lori method implements a method to analyze and impute
incomplete count tables. An important feature of the method
is that it can take into account main effects of rows and
columns, as well as effects of continuous or categorical
covariates, and interaction. The estimation procedure is
based on minimizing a Poisson loss penalized by a Lasso
type penalty (sparse vector of covariate effects) and a
nuclear norm penalty inducing a low-rank interaction matrix
(a few latent factors summarize the interactions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lori(
  Y,
  cov = NULL,
  lambda1 = NULL,
  lambda2 = NULL,
  intercept = T,
  reff = T,
  ceff = T,
  rank.max = 2,
  algo = c("alt", "mcgd"),
  thresh = 1e-05,
  maxit = 100,
  trace.it = F,
  parallel = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lori_+3A_y">Y</code></td>
<td>
<p>[matrix, data.frame] count table (nxp).</p>
</td></tr>
<tr><td><code id="lori_+3A_cov">cov</code></td>
<td>
<p>[matrix, data.frame] design matrix (np*q) in order row1xcol1,row2xcol2,..,rownxcol1,row1xcol2,row2xcol2,...,...,rownxcolp</p>
</td></tr>
<tr><td><code id="lori_+3A_lambda1">lambda1</code></td>
<td>
<p>[positive number] the regularization parameter for the interaction matrix.</p>
</td></tr>
<tr><td><code id="lori_+3A_lambda2">lambda2</code></td>
<td>
<p>[positive number] the regularization parameter for the covariate effects.</p>
</td></tr>
<tr><td><code id="lori_+3A_intercept">intercept</code></td>
<td>
<p>[boolean] whether an intercept should be fitted, default value is FALSE</p>
</td></tr>
<tr><td><code id="lori_+3A_reff">reff</code></td>
<td>
<p>[boolean] whether row effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="lori_+3A_ceff">ceff</code></td>
<td>
<p>[boolean] whether column effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="lori_+3A_rank.max">rank.max</code></td>
<td>
<p>[integer] maximum rank of interaction matrix (smaller than min(n-1,p-1))</p>
</td></tr>
<tr><td><code id="lori_+3A_algo">algo</code></td>
<td>
<p>type of algorithm to use, either one of &quot;mcgd&quot; (mixed coordinate gradient descent, adapted to large dimensions) or &quot;alt&quot; (alternating minimization, adapted to small dimensions)</p>
</td></tr>
<tr><td><code id="lori_+3A_thresh">thresh</code></td>
<td>
<p>[positive number] convergence tolerance of algorithm, by default <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="lori_+3A_maxit">maxit</code></td>
<td>
<p>[integer] maximum allowed number of iterations.</p>
</td></tr>
<tr><td><code id="lori_+3A_trace.it">trace.it</code></td>
<td>
<p>[boolean] whether convergence information should be printed</p>
</td></tr>
<tr><td><code id="lori_+3A_parallel">parallel</code></td>
<td>
<p>[boolean] whether computations should be performed in parallel on multiple cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>nxp matrix of log of expected counts</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>row effects</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>column effects</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>covariate effects</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>nxp matrix of row-column interactions</p>
</td></tr>
<tr><td><code>imputed</code></td>
<td>
<p>nxp matrix of imputed counts</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>nxp matrix of expected counts (exp(X))</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>npxK matrix of covariates</p>
</td></tr>
<tr><td><code>nparam</code></td>
<td>
<p>number of estimated parameters in the model</p>
</td></tr>
<tr><td><code>dfres</code></td>
<td>
<p>residual degrees of freedom</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>sum of squared deviations between observed and expected counts normalized by the expected value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='mi.lori'>The mi.lori performs M multiple imputations using the
lori method. Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform M multiple imputations using the mi.lori
method, and to aggregate them using the pool.lori method.</h2><span id='topic+mi.lori'></span>

<h3>Description</h3>

<p>The mi.lori performs M multiple imputations using the
lori method. Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform M multiple imputations using the mi.lori
method, and to aggregate them using the pool.lori method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.lori(
  Y,
  cov = NULL,
  lambda1 = NULL,
  lambda2 = NULL,
  M = 25,
  intercept = T,
  reff = T,
  ceff = T,
  rank.max = 5,
  algo = c("alt", "mcgd"),
  thresh = 1e-05,
  maxit = 1000,
  trace.it = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mi.lori_+3A_y">Y</code></td>
<td>
<p>[matrix, data.frame] count table (nxp).</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_cov">cov</code></td>
<td>
<p>[matrix, data.frame] design matrix (np*q) in order row1xcol1,row2xcol2,..,rownxcol1,row1xcol2,row2xcol2,...,...,rownxcolp</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_lambda1">lambda1</code></td>
<td>
<p>[positive number] the regularization parameter for the interaction matrix.</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_lambda2">lambda2</code></td>
<td>
<p>[positive number] the regularization parameter for the covariate effects.</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_m">M</code></td>
<td>
<p>[integer] the number of multiple imputations to perform</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_intercept">intercept</code></td>
<td>
<p>[boolean] whether an intercept should be fitted, default value is FALSE</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_reff">reff</code></td>
<td>
<p>[boolean] whether row effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_ceff">ceff</code></td>
<td>
<p>[boolean] whether column effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_rank.max">rank.max</code></td>
<td>
<p>[integer] maximum rank of interaction matrix (smaller than min(n-1,p-1))</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_algo">algo</code></td>
<td>
<p>type of algorithm to use, either one of &quot;mcgd&quot; (mixed coordinate gradient descent, adapted to large dimensions) or &quot;alt&quot; (alternating minimization, adapted to small dimensions)</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_thresh">thresh</code></td>
<td>
<p>[positive number] convergence tolerance of algorithm, by default <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_maxit">maxit</code></td>
<td>
<p>[integer] maximum allowed number of iterations.</p>
</td></tr>
<tr><td><code id="mi.lori_+3A_trace.it">trace.it</code></td>
<td>
<p>[boolean] whether convergence information should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mi.imputed</code></td>
<td>
<p>a list of length M containing the imputed count tables</p>
</td></tr>
<tr><td><code>mi.alpha</code></td>
<td>
<p>a (Mxn) matrix containing in rows the estimated row effects (one row corresponds to one single imputation)</p>
</td></tr>
<tr><td><code>mi.beta</code></td>
<td>
<p>a (Mxp) matrix containing in rows the estimated column effects (one row corresponds to one single imputation)</p>
</td></tr>
<tr><td><code>mi.epsilon</code></td>
<td>
<p>a (Mxq) matrix containing in rows the estimated effects of covariates (one row corresponds to one single imputation)</p>
</td></tr>
<tr><td><code>mi.theta</code></td>
<td>
<p>a list of length M containing the estimated interaction matrices</p>
</td></tr>
<tr><td><code>mi.mu</code></td>
<td>
<p>a list of length M containing the estimated Poisson means</p>
</td></tr>
<tr><td><code>mi.y</code></td>
<td>
<p>list of bootstrapped count tables used fot multiple imputation</p>
</td></tr>
<tr><td><code>mi.nparam</code></td>
<td>
<p>a list of length M containing the number of estimated parameters in each bootstrap sample</p>
</td></tr>
<tr><td><code>mi.dfres</code></td>
<td>
<p>a list of length M containing the residual degrees of freedom in each bootstrap sample</p>
</td></tr>
<tr><td><code>mi.chisq</code></td>
<td>
<p>a list of length M containing the sum of squared deviations between observed and expected counts normalized by the expected value in each bootstrap sample</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>original incomplete count table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(50), 25)
Y &lt;- matrix(rpois(25, 1:25), 5)
res &lt;- mi.lori(Y, X, 10, 10, 2)
</code></pre>

<hr>
<h2 id='pool.lori'>The pool.lori method aggregates lori multiple imputation results.
Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform multiple imputation using the mi.lori
method, and to aggregate them using the pool.lori method.</h2><span id='topic+pool.lori'></span>

<h3>Description</h3>

<p>The pool.lori method aggregates lori multiple imputation results.
Multiple imputation allows to produce estimates of missing
values, as well as intervals of variability. The classical
procedure is to perform multiple imputation using the mi.lori
method, and to aggregate them using the pool.lori method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool.lori(res.mi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool.lori_+3A_res.mi">res.mi</code></td>
<td>
<p>a multiple imputation result from the function mi.lori</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pool.impute</code></td>
<td>
<p>a list containing the pooled means (mean) and variance (var) of the imputed values</p>
</td></tr>
<tr><td><code>pool.alpha</code></td>
<td>
<p>a list containing the pooled means (mean) and variance (var) of the row effects</p>
</td></tr>
<tr><td><code>pool.beta</code></td>
<td>
<p>a list containing the pooled means (mean) and variance (var) of the column effects</p>
</td></tr>
<tr><td><code>pool.epsilon</code></td>
<td>
<p>a list containing the pooled means (mean) and variance (var) of the covariate effects</p>
</td></tr>
<tr><td><code>pool.theta</code></td>
<td>
<p>a list containing the pooled means (mean) and variance (var) of the interactions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(50), 25)
Y &lt;- matrix(rpois(25, 1:25), 5)
res &lt;- mi.lori(Y, X, 10, 10, 2)
poolres &lt;- pool.lori(res)
</code></pre>

<hr>
<h2 id='qut'>automatic selection of nuclear norm regularization parameter</h2><span id='topic+qut'></span>

<h3>Description</h3>

<p>automatic selection of nuclear norm regularization parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qut(Y, cov, lambda2 = 0, q = 0.95, N = 100, reff = T, ceff = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qut_+3A_y">Y</code></td>
<td>
<p>A matrix of counts (contingency table).</p>
</td></tr>
<tr><td><code id="qut_+3A_cov">cov</code></td>
<td>
<p>A (np)xK matrix of K covariates about rows and columns</p>
</td></tr>
<tr><td><code id="qut_+3A_lambda2">lambda2</code></td>
<td>
<p>A positive number, the regularization parameter for covariates main effects</p>
</td></tr>
<tr><td><code id="qut_+3A_q">q</code></td>
<td>
<p>A number between 0 and 1. The quantile of the distribution of lambdaQUT to take.</p>
</td></tr>
<tr><td><code id="qut_+3A_n">N</code></td>
<td>
<p>An integer. The number of parametric bootstrap samples to draw.</p>
</td></tr>
<tr><td><code id="qut_+3A_reff">reff</code></td>
<td>
<p>[boolean] whether row effects should be fitted, default value is TRUE</p>
</td></tr>
<tr><td><code id="qut_+3A_ceff">ceff</code></td>
<td>
<p>[boolean] whether column effects should be fitted, default value is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of lambdaQUT to use in LoRI based on QUT method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(rnorm(30), 15)
Y = matrix(rpois(15, 1:15), 5)
lambda = qut(Y,X, 10, N=10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
