<!DOCTYPE html><html lang="en"><head><title>Help for package weakARMA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {weakARMA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acf.gamma_m'><p>Computation of autocovariance and autocorrelation for an ARMA residuals.</p></a></li>
<li><a href='#acf.univ'><p>Computation of autocovariance and autocorrelation for an ARMA residuals.</p></a></li>
<li><a href='#ARMA.selec'><p>Selection of ARMA models</p></a></li>
<li><a href='#CAC40'><p>Paris stock exchange</p></a></li>
<li><a href='#CAC40return'><p>Paris stock exchange return</p></a></li>
<li><a href='#CAC40return.sq'><p>Paris stock exchange square return</p></a></li>
<li><a href='#estimation'><p>Parameters estimation of a time series.</p></a></li>
<li><a href='#gradient'><p>Computation the gradient of the residuals of an ARMA model</p></a></li>
<li><a href='#matXi'><p>Estimation of Fisher information matrix I</p></a></li>
<li><a href='#meansq'><p>Function optim will minimize</p></a></li>
<li><a href='#nl.acf'><p>Autocorrelogram</p></a></li>
<li><a href='#omega'><p>Computation of Fisher information  matrice</p></a></li>
<li><a href='#portmanteauTest'><p>Portmanteau tests</p></a></li>
<li><a href='#portmanteauTest.h'><p>Portmanteau tests for one lag.</p></a></li>
<li><a href='#signifparam'><p>Computes the parameters significance</p></a></li>
<li><a href='#sim.ARMA'><p>Simulation of ARMA(p,q) model.</p></a></li>
<li><a href='#simGARCH'><p>GARCH process</p></a></li>
<li><a href='#VARest'><p>Estimation of VAR(p) model</p></a></li>
<li><a href='#wnPT'><p>Weak white noise</p></a></li>
<li><a href='#wnPT_SQ'><p>Weak white noise</p></a></li>
<li><a href='#wnRT'><p>Weak white noise</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for the Analysis of Weak ARMA Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Numerous time series admit autoregressive moving average (ARMA)
  representations, in which the errors are uncorrelated but not necessarily
  independent.
  These models are called weak ARMA by opposition to the standard ARMA models, 
  also called strong ARMA models, in which the error terms are supposed to be 
  independent and identically distributed (iid).
  This package allows the study of nonlinear time series models through weak 
  ARMA representations.
  It determines identification, estimation and validation for ARMA models and 
  for AR and MA models in particular. 
  Functions can also be used in the strong case.
  This package also works on white noises by omitting arguments 'p', 'q', 'ar'
  and 'ma'.
  See Francq, C. and Zakoïan, J. (1998) &lt;<a href="https://doi.org/10.1016%2FS0378-3758%2897%2900139-0">doi:10.1016/S0378-3758(97)00139-0</a>&gt; and 
  Boubacar Maïnassara, Y. and Saussereau, B. (2018)
  &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1380030">doi:10.1080/01621459.2017.1380030</a>&gt; for more details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>CompQuadForm (&ge; 1.4.3), MASS (&ge; 7.3-54), matrixStats (&ge;
0.61), vars (&ge; 1.5-6)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>timeSeries, testthat, knitr, rmarkdown, renv</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Yves Rolland &lt;julien.rolland@univ-fcomte.fr&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://plmlab.math.cnrs.fr/jrolland/weakARMA">https://plmlab.math.cnrs.fr/jrolland/weakARMA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://plmlab.math.cnrs.fr/jrolland/weakARMA/-/issues">https://plmlab.math.cnrs.fr/jrolland/weakARMA/-/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-04 13:37:26 UTC; jrolland</td>
</tr>
<tr>
<td>Author:</td>
<td>Yacouba Boubacar Maïnassara
    <a href="https://orcid.org/0000-0002-8604-5407"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Julien Yves Rolland
    <a href="https://orcid.org/0000-0002-0960-6688"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Coraline Parguey [ctb],
  Vincent Mouillot [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-04 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acf.gamma_m'>Computation of autocovariance and autocorrelation for an ARMA residuals.</h2><span id='topic+acf.gamma_m'></span>

<h3>Description</h3>

<p>Computes empirical autocovariances and autocorrelations function
for an ARMA process for lag max given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf.gamma_m(ar = NULL, ma = NULL, y, h, e = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf.gamma_m_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>,  it is a MA process.</p>
</td></tr>
<tr><td><code id="acf.gamma_m_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>,  it is a AR process.</p>
</td></tr>
<tr><td><code id="acf.gamma_m_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="acf.gamma_m_+3A_h">h</code></td>
<td>
<p>Computes autocovariances and autocorrelations from lag 1 to lag h with h an integer.</p>
</td></tr>
<tr><td><code id="acf.gamma_m_+3A_e">e</code></td>
<td>
<p>Vector of residuals. If <code>NULL</code>, the function will compute it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with :
</p>

<dl>
<dt><code>gamma_m</code></dt><dd><p>Vector of the autocovariances.</p>
</dd>
<dt><code>rho_m</code></dt><dd><p>Vector of the autocorrelations.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+acf.univ">acf.univ</a></code> for autocorrelation and autocovariance for only one given lag h.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param.estim &lt;- estimation(p = 1,  q = 1, y = CAC40return.sq)
acf.gamma_m(ar = param.estim$ar, ma = param.estim$ma, y = CAC40return.sq,  h = 20)

</code></pre>

<hr>
<h2 id='acf.univ'>Computation of autocovariance and autocorrelation for an ARMA residuals.</h2><span id='topic+acf.univ'></span>

<h3>Description</h3>

<p>Computes empirical autocovariances and autocorrelations
functions for an ARMA process for only one given lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf.univ(ar = NULL, ma = NULL, y, h, e = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf.univ_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>,  it is a MA process.</p>
</td></tr>
<tr><td><code id="acf.univ_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>,  it is a AR process.</p>
</td></tr>
<tr><td><code id="acf.univ_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="acf.univ_+3A_h">h</code></td>
<td>
<p>Given lag to compute autocovariance and autocorrelation, with h an integer.</p>
</td></tr>
<tr><td><code id="acf.univ_+3A_e">e</code></td>
<td>
<p>Vector of residuals of the time series.  If <code>NULL</code>, the function will compute it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with :
</p>

<dl>
<dt><code>autocov</code></dt><dd><p>Value of the autocovariance.</p>
</dd>
<dt><code>autocor</code></dt><dd><p>Value of the autocorrelation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+acf.gamma_m">acf.gamma_m</a></code> for autocorrelation and autocovariance for all h lag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param.estim &lt;- estimation(p = 1,  q = 1, y = CAC40return.sq)
acf.univ(ar = param.estim$ar, ma = param.estim$ma, y = CAC40return.sq,  h = 20)


</code></pre>

<hr>
<h2 id='ARMA.selec'>Selection of ARMA models</h2><span id='topic+ARMA.selec'></span>

<h3>Description</h3>

<p>Identifies the orders p and q of an ARMA model according to several
information criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMA.selec(data, P, Q, c = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMA.selec_+3A_data">data</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="ARMA.selec_+3A_p">P</code></td>
<td>
<p>Integer for the maximum lag order of autoregressive component.</p>
</td></tr>
<tr><td><code id="ARMA.selec_+3A_q">Q</code></td>
<td>
<p>Integer for the maximum lag order of moving-average component.</p>
</td></tr>
<tr><td><code id="ARMA.selec_+3A_c">c</code></td>
<td>
<p>Real number &gt;1 needed to compute Hannan-Quinn information criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted model which is favored is the one corresponding to the
minimum value of the criterion. The most popular criterion is the Akaike information
criterion (<code>AIC</code>). This was designed to be an approximately unbiased
estimator of a fitted model. For small sample or when  the number of fitted
parameters is large, it is more appropriate to  manipulate a corrected AIC
version (<code>AICc</code>) which is more nearly unbiased. But these two criteria
are inconsistent for model orders selection. If you want to use a consistent
criterion, it is possible to take the Bayesian information criterion
(<code>BIC</code>) or the Hannan-Quinn information  criteria (<code>HQ</code>).
</p>
<p>For the weak ARMA, i.e under the assumption that the errors are uncorrelated
but not necessarily independant, modified criteria has been adapted :
<code>AICm</code>, <code>AICcm</code>, <code>BICm</code>, <code>HQm</code>.
</p>
<p>The criteria definitions are the following :
</p>
<p style="text-align: center;"><code class="reqn">AIC = n\log(\sigma^{2}) + 2(p + q)</code>
</p>

<p style="text-align: center;"><code class="reqn">AICm = n\log(\sigma^{2}) + \frac{Tr(IJ^{-1})}{\sigma^2}</code>
</p>

<p style="text-align: center;"><code class="reqn">AICc = n\log(\sigma^{2}) + n + \frac{n}{(n-(p + q + 1))} 2(p + q)</code>
</p>

<p style="text-align: center;"><code class="reqn">AICcm = n\log(\sigma^{2}) + \frac{n^{2}}{(n-(p + q + 1))}  + \frac{n}{(2(n-(p + q + 1)))} \frac{Tr(IJ^{-1})}{\sigma^2}</code>
</p>

<p style="text-align: center;"><code class="reqn">BIC = n\log(\sigma^{2}) + (p + q)log(n)</code>
</p>

<p style="text-align: center;"><code class="reqn">BICm = n\log(\sigma^{2}) + \frac{1}{2} \frac{Tr(IJ^{-1})}{\sigma^2}log(n)</code>
</p>

<p style="text-align: center;"><code class="reqn">HQ = n\log(\sigma^{2}) + 2c(p + q)log(log(n))</code>
</p>

<p style="text-align: center;"><code class="reqn">HQm = n\log(\sigma^{2}) + c\frac{Tr(IJ^{-1})}{\sigma^2}log(log(n))</code>
</p>



<h3>Value</h3>

<p>A list of the different criteria, each item contains the matrix of the 
computed value for the different model and the selected order with this criterion 
(corresponding to the minimum value in the previous matrix).
</p>


<h3>References</h3>

<p>Boubacar Maïnassara, Y. 2012, Selection of weak VARMA models by
modified Akaike's information  criteria, <em>Journal of Time Series
Analysis</em>, vol. 33, no. 1, pp. 121-130
</p>
<p>Boubacar Maïnassara, Y. and Kokonendji, C. C. 2016, Modified Schwarz
and Hannan-Quin information criteria for weak VARMA models, <em>Stat
Inference Stoch Process</em>, vol. 19, no. 2, pp. 199-217
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARMA.selec (CAC40return.sq, P = 3, Q = 3)

</code></pre>

<hr>
<h2 id='CAC40'>Paris stock exchange</h2><span id='topic+CAC40'></span>

<h3>Description</h3>

<p>This data set considers market index at the closure of the market from
March 1, 1990 to June 14, 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAC40
</code></pre>


<h3>Format</h3>

<p>A vector with the variable <code>Close</code>.
</p>
<p>There are 7936 observations. We removed every <code>NULL</code> values.
</p>


<h3>Source</h3>

<p>Data pulled from Yahoo Finance: &lsquo;<span class="samp">&#8288;https://fr.finance.yahoo.com/quote/%5EFCHI/history?p=%5EFCHI&#8288;</span>&rsquo;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAC40return">CAC40return</a></code> and <code><a href="#topic+CAC40return.sq">CAC40return.sq</a></code>
</p>

<hr>
<h2 id='CAC40return'>Paris stock exchange return</h2><span id='topic+CAC40return'></span>

<h3>Description</h3>

<p>This data set considers CAC40 return at the closure of the market from
March 2, 1990 to June 14, 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAC40return
</code></pre>


<h3>Format</h3>

<p>A numerical vector with 7935 observations.
</p>
<p>We computed every value from the dataset <code><a href="#topic+CAC40">CAC40</a></code>
with the following code:
</p>
<pre>
 cac&lt;-CAC40;
 n&lt;-length(cac);
 rend&lt;-rep(0,n);
 rend[2:n]&lt;-(log(cac[2:n]/cac[1:(n-1)])*100);
 CAC40return&lt;-rend[2:n]
 </pre>


<h3>See Also</h3>

<p><code><a href="#topic+CAC40">CAC40</a></code> and <code><a href="#topic+CAC40return.sq">CAC40return.sq</a></code>
</p>

<hr>
<h2 id='CAC40return.sq'>Paris stock exchange square return</h2><span id='topic+CAC40return.sq'></span>

<h3>Description</h3>

<p>This data set considers CAC40 square return at the closure of the market
from March 2, 1990 to June 14, 2021.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAC40return.sq
</code></pre>


<h3>Format</h3>

<p>A numerical vector with 7935 observations.
</p>
<p>We computed every value from the dataset <code><a href="#topic+CAC40">CAC40</a></code>
with the following code:
</p>
<pre>
 cac&lt;-CAC40;
 n&lt;-length(cac);
 rend&lt;-rep(0,n);
 rend[2:n]&lt;-(log(cac[2:n]/cac[1:(n-1)])*100);
 CAC40return.sq&lt;-rend[2:n]^2
 </pre>


<h3>See Also</h3>

<p><code><a href="#topic+CAC40">CAC40</a></code> and <code><a href="#topic+CAC40return">CAC40return</a></code>
</p>

<hr>
<h2 id='estimation'>Parameters estimation of a time series.</h2><span id='topic+estimation'></span>

<h3>Description</h3>

<p>Estimates the parameters of a time series for given orders <code>p</code> and <code>q</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimation(p = NULL, q = NULL, y, meanparam = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimation_+3A_p">p</code></td>
<td>
<p>Order of AR, if <code>NULL</code>, MA is computed.</p>
</td></tr>
<tr><td><code id="estimation_+3A_q">q</code></td>
<td>
<p>Order of MA, if <code>NULL</code>, AR is computed.</p>
</td></tr>
<tr><td><code id="estimation_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="estimation_+3A_meanparam">meanparam</code></td>
<td>
<p>Logical argument if the mean parameter has to be computed or not. If FALSE <code class="reqn">\mu</code> is not computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the algorithm BFGS in the function optim to minimize our objective function <code><a href="#topic+meansq">meansq</a></code>.
</p>


<h3>Value</h3>

<p>List of estimate coefficients:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Mean parameter</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>ar</code></dt><dd><p>Vector of AR coefficients with length is equal to <code>p</code>.</p>
</dd>
<dt><code>ma</code></dt><dd><p>Vector of MA coefficients with length is equal to <code>q</code>.</p>
</dd>
<dt><code>sigma.carre</code></dt><dd><p>Mean square residuals.</p>
</dd>
</dl>



<h3>References</h3>

<p>Francq, C. and Zakoïan, J. 1998, Estimating linear representations of nonlinear processes
<em>Journal of Statistical Planning and Inference</em>, vol. 68, no. 1, pp. 145-165.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y&lt;-sim.ARMA(1000,ar = c(0.9,-0.3), ma = 0.2, method = "product")
estimation(p = 2, q = 1, y = y)

estimation(p = 1, q = 1, y = CAC40return.sq, meanparam = TRUE)

</code></pre>

<hr>
<h2 id='gradient'>Computation the gradient of the residuals of an ARMA model</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>Computes the gradient of the residuals of an ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(ar = NULL, ma = NULL, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradient_+3A_ar">ar</code></td>
<td>
<p>Vector of <code>ar</code> coefficients.</p>
</td></tr>
<tr><td><code id="gradient_+3A_ma">ma</code></td>
<td>
<p>Vector of <code>ma</code> coefficients.</p>
</td></tr>
<tr><td><code id="gradient_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>der.eps</code></dt><dd><p>Matrix of the gradient.</p>
</dd>
<dt><code>esp</code></dt><dd><p>Vector of residuals.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>est&lt;-estimation(p = 1, q = 1, y = CAC40return.sq)
gradient(ar = est$ar, ma = est$ma, y = CAC40return.sq)

</code></pre>

<hr>
<h2 id='matXi'>Estimation of Fisher information matrix I</h2><span id='topic+matXi'></span>

<h3>Description</h3>

<p>Uses a consistent estimator of the matrix I based on an autoregressive spectral estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matXi(data, p = 0, q = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matXi_+3A_data">data</code></td>
<td>
<p>Matrix of dimension (p+q,n).</p>
</td></tr>
<tr><td><code id="matXi_+3A_p">p</code></td>
<td>
<p>Dimension of AR estimate coefficients.</p>
</td></tr>
<tr><td><code id="matXi_+3A_q">q</code></td>
<td>
<p>Dimension of MA estimate coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate Fisher information matrix <code class="reqn">I = 
\sum_{h=-\infty}^{+\infty} cov(2e_t \nabla e_t, 2e_{t-h} \nabla e_{t-h})</code> where <code class="reqn">\nabla e_t</code> 
denotes the gradient of the residuals.
</p>


<h3>References</h3>

<p>Berk, Kenneth N. 1974, Consistent autoregressive spectral estimates,
<em>The Annals of Statistics</em>, vol. 2, pp. 489-502.
</p>
<p>Boubacar Maïnassara, Y. and Francq, C. 2011, Estimating structural VARMA models with uncorrelated but 
non-independent error terms, <em>Journal of Multivariate Analysis</em>, vol. 102, no. 3, pp. 496-505.
</p>
<p>Boubacar Mainassara, Y. and Carbon, M. and Francq, C. 2012, Computing and estimating information matrices 
of weak ARMA models <em>Computational Statistics &amp; Data Analysis</em>, vol. 56, no. 2, pp. 345-361.
</p>

<hr>
<h2 id='meansq'>Function optim will minimize</h2><span id='topic+meansq'></span>

<h3>Description</h3>

<p>Computes the mean square of the time series at the point <code>x</code>, will be minimize with the <code><a href="stats.html#topic+optim">optim</a></code> function in our function <code><a href="#topic+estimation">estimation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meansq(x, dim.ar = NULL, dim.ma = NULL, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meansq_+3A_x">x</code></td>
<td>
<p>One point in <code class="reqn">\rm I\!R^{(p+q)}</code>.</p>
</td></tr>
<tr><td><code id="meansq_+3A_dim.ar">dim.ar</code></td>
<td>
<p>Length of AR vector.</p>
</td></tr>
<tr><td><code id="meansq_+3A_dim.ma">dim.ma</code></td>
<td>
<p>Length of MA vector.</p>
</td></tr>
<tr><td><code id="meansq_+3A_y">y</code></td>
<td>
<p>Vector of a time series.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>ms</code></dt><dd><p>Mean square at the point <code>x</code>.</p>
</dd>
</dl>


<hr>
<h2 id='nl.acf'>Autocorrelogram</h2><span id='topic+nl.acf'></span>

<h3>Description</h3>

<p>Plots autocorrelogram for non linear process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nl.acf(
  ar = NULL,
  ma = NULL,
  y,
  main = NULL,
  nlag = NULL,
  conflevel = 0.05,
  z = 1.2,
  aff = "both"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nl.acf_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>, we consider a MA process.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>, we consider an AR process.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_main">main</code></td>
<td>
<p>Character string representing the title for the plot.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_nlag">nlag</code></td>
<td>
<p>Maximum lag at which to calculate the acf. If <code>NULL</code>, it is
determinate by <code class="reqn">nlag = min(10log(n))</code> where n is the number of
observation.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_conflevel">conflevel</code></td>
<td>
<p>Value of the confidence level, 5% by default.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_z">z</code></td>
<td>
<p>Zoom on the graph.</p>
</td></tr>
<tr><td><code id="nl.acf_+3A_aff">aff</code></td>
<td>
<p>Specify the method between SN, M and both (see in Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the argument <code>aff</code> you have the choice between: 
<code>SN</code>, <code>M</code> and <code>both</code>.
<code>SN</code> prints the self-normalized method (see Boubacar Maïnassara and Saussereau) in green, 
<code>M</code> prints the modified method introduced by Francq, Roy and Zakoïan (see also Boubacar Maïnassara) in red 
and <code>both</code> prints both of the methods.
</p>


<h3>Value</h3>

<p>An autocorrelogram with every autocorrelations from 1 to a lag max, and 
with methods you choose to print.
</p>


<h3>Note</h3>

<p>The only value available for the argument <code>conflevel</code> are 
0.1, 0.05, 0.025, 0.01 or 0.005.
</p>


<h3>References</h3>

<p>Boubacar Maïnassara, Y. 2011, Multivariate portmanteau test for structural VARMA models
with uncorrelated but non-independent error terms <em>Journal of Statistical Planning and Inference</em>,
vol. 141, no. 8, pp. 2961-2975.
</p>
<p>Boubacar Maïnassara, Y.and Saussereau, B. 2018, Diagnostic checking in multivariate ARMA models with 
dependent errors using normalized residual autocorrelations ,
<em>Journal of the American Statistical Association</em>, vol. 113, no. 524, pp. 1813-1827.
</p>
<p>Francq, C., Roy, R. and Zakoïan, J.M. 2005, Diagnostic Checking in ARMA
Models with Uncorrelated Errors, <em>Journal of the American Statistical
Association</em>, vol. 100, no. 470, pp. 532-544.
</p>
<p>Lobato, I.N. 2001, Testing that a dependant process is
uncorrelated. J. Amer. Statist. Assos. 96, vol. 455, pp. 1066-1076.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est&lt;-estimation(p = 1, q = 1, y = CAC40return.sq)
nl.acf(ar = est$ar, ma = est$ma, y = CAC40return.sq, main = "Autocorrelation of an ARMA(1,1) 
residuals of the CAC40 return square", nlag = 20)

</code></pre>

<hr>
<h2 id='omega'>Computation of Fisher information  matrice</h2><span id='topic+omega'></span>

<h3>Description</h3>

<p>Computes matrices of Fisher information like <code class="reqn">I</code>, <code class="reqn">J</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omega(ar = NULL, ma = NULL, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omega_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>,  the simulation is a MA process.</p>
</td></tr>
<tr><td><code id="omega_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>,  the simulation is a AR process.</p>
</td></tr>
<tr><td><code id="omega_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrix containing:
</p>

<dl>
<dt><code>I</code></dt><dd><p>Matrix <code>I</code> computed in function <code><a href="#topic+matXi">matXi</a></code>.</p>
</dd>
<dt><code>J</code></dt><dd><p>Matrix <code>J</code> computed as <code class="reqn">\frac{2}{n} H(e) H(e)^t </code> where <code class="reqn">e</code> is the residuals vector.</p>
</dd>
<dt><code>J.inv</code></dt><dd><p>Inverse of the matrix <code>J</code>.</p>
</dd>
<dt><code>matOmega</code></dt><dd><p>Matrix variance-covariance in the weak case computed as <code class="reqn">J^{-1}IJ^{-1}</code>.</p>
</dd>
<dt><code>matvar.strong</code></dt><dd><p>Matrix variance-covariance in the strong case computed as 
<code class="reqn">2\sigma^2J^{-1}</code>.</p>
</dd>
<dt><code>standard.dev.Omega</code></dt><dd><p>Standard deviation of the matrix <code>matOmega</code>.</p>
</dd>
<dt><code>standard.dev.strong</code></dt><dd><p>Standard deviation of the matrix <code>matvar.strong</code>.</p>
</dd>
<dt><code>sig2</code></dt><dd><p>Innovation variance estimate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- sim.ARMA(n = 1000, ar = c(0.95,-0.8), ma = -0.6)
est&lt;-estimation(p = 2, q = 1, y = y)
omega(ar = est$ar, ma = est$ma, y = y)

estCAC&lt;-estimation(p = 1, q = 1, y = CAC40return.sq, meanparam = TRUE)
omega(ar = estCAC$ar, ma = estCAC$ma, y = CAC40return.sq)
</code></pre>

<hr>
<h2 id='portmanteauTest'>Portmanteau tests</h2><span id='topic+portmanteauTest'></span>

<h3>Description</h3>

<p>Realizes portmanteau tests of the first m lags, this function uses <code><a href="#topic+portmanteauTest.h">portmanteauTest.h</a></code>
for h in 1:m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portmanteauTest(ar = NULL, ma = NULL, y, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portmanteauTest_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>, it is a MA process.</p>
</td></tr>
<tr><td><code id="portmanteauTest_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>, it is an AR process.</p>
</td></tr>
<tr><td><code id="portmanteauTest_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="portmanteauTest_+3A_m">m</code></td>
<td>
<p>Integer for the lag.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of length <code>m</code>, corresponding to statistics and p-value for each lag, 
for standard, modified and self-normalized Ljung-Box and Box-Pierce methods.
</p>


<h3>References</h3>

<p>Boubacar Maïnassara, Y. 2011, Multivariate portmanteau test for structural VARMA models
with uncorrelated but non-independent error terms <em>Journal of Statistical Planning and Inference</em>,
vol. 141, no. 8, pp. 2961-2975.
</p>
<p>Boubacar Maïnassara, Y. and Saussereau, B. 2018, Diagnostic checking in multivariate ARMA models with 
dependent errors using normalized residual autocorrelations ,
<em>Journal of the American Statistical Association</em>, vol. 113, no. 524, pp. 1813-1827.
</p>
<p>Francq, C., Roy, R. and Zakoïan, J.M. 2005, Diagnostic Checking in ARMA
Models with Uncorrelated Errors, <em>Journal of the American Statistical
Association</em>, vol. 100, no. 470, pp. 532-544.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portmanteauTest.h">portmanteauTest.h</a></code> to obtain statistics for only one h lag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> est&lt;-estimation(p = 1, q = 1, y = CAC40return.sq)
 portmanteauTest(ar = est$ar, ma = est$ma, y = CAC40return.sq, m = 20)

</code></pre>

<hr>
<h2 id='portmanteauTest.h'>Portmanteau tests for one lag.</h2><span id='topic+portmanteauTest.h'></span>

<h3>Description</h3>

<p>Computes Box-Pierce and Ljung-Box statistics for standard, modified and 
self-normalized test procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portmanteauTest.h(ar = NULL, ma = NULL, y, h, grad = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portmanteauTest.h_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>, it is a MA process.</p>
</td></tr>
<tr><td><code id="portmanteauTest.h_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>, it is an AR process.</p>
</td></tr>
<tr><td><code id="portmanteauTest.h_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="portmanteauTest.h_+3A_h">h</code></td>
<td>
<p>Integer for the chosen lag.</p>
</td></tr>
<tr><td><code id="portmanteauTest.h_+3A_grad">grad</code></td>
<td>
<p>Gradient of the series from the function <a href="#topic+gradient">gradient</a>. If <code>NULL</code> gradient will be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Portmanteau statistics are generally used to  test the null hypothesis.
H0 : <code class="reqn">X_t</code> satisfies an ARMA(p,q) representation.
</p>
<p>The Box-Pierce (BP) and Ljung-Box (LB) statistics, defined as follows, are
based on the residual empirical autocorrelation. </p>
<p style="text-align: center;"><code class="reqn">Q_{m}^{BP} =
 n\sum_{h}^{m} \rho^{2}(h)</code>
</p>
 <p style="text-align: center;"><code class="reqn">Q_{m}^{LB} = n(n+2) \sum_{h}^{m}
 \frac{\rho^{2}(h)}{(n-h)}</code>
</p>

<p>The standard test procedure consists in rejecting the null hypothesis of an
ARMA(p,q) model if the statistic <code class="reqn">Q_m &gt; \chi^{2}(1-\alpha)</code> where
<code class="reqn">\chi^{2}(1-\alpha)</code> denotes the <code class="reqn">(1-\alpha)</code>-quantile of a
chi-squared distribution with m-(p+q) (where m &gt; p + q) degrees of freedom. The
two statistics have the same asymptotic distribution, but the LB statistic
has the reputation of doing better for small or medium sized samples.
</p>
<p>But the significance limits of the residual autocorrelation can be very
different for an ARMA models with iid noise and ARMA models with only
uncorrelated noise but dependant. The standard test is obtained under the
stronger assumption that <code class="reqn">\epsilon_{t}</code> is iid. So we give an another
way to obtain the exact asymptotic distribution of the standard portmanteau
statistics under the weak dependence assumptions.
</p>
<p>Under H0, the statistics <code class="reqn">Q_{m}^{BP}</code> and <code class="reqn">Q_{m}^{LB}</code> converge in
distribution as <code class="reqn">n \rightarrow \infty</code>, to </p>
<p style="text-align: center;"><code class="reqn">Z_m(\xi_m) :=
 \sum_{i}^{m}\xi_{i,m} Z^{2}_i</code>
</p>
<p> where <code class="reqn">\xi_m =
 (\xi_{1,m}',...,\xi_{m,m}')</code> is the eigenvalues vector of the asymptotic
covariance matrix of the residual autocorrelations vector and
<code class="reqn">Z_{1},...,Z_{m}</code> are independent <code class="reqn">\mathcal{N}(0,1)</code> variables.
</p>
<p>So when the error process is a weak white noise, the asymptotic distribution
<code class="reqn">Q_{m}^{BP}</code> and <code class="reqn">Q_{m}^{LB}</code> statistics is a weighted sum of
chi-squared. The distribution of the quadratic form <code class="reqn">Z_{m}(\xi_m)</code> can
be computed using the algorithm by Imhof available here :
<code><a href="CompQuadForm.html#topic+imhof">imhof</a></code>
</p>
<p>We propose an alternative method where we do not estimate an asymptotic
covariance matrix. It is based on a self-normalization based approach to
construct a new test-statistic which is asymptotically distribution-free
under the null hypothesis.
</p>
<p>The sample autocorrelation, at lag <code>h</code> take the form <code class="reqn">\hat{\rho}(h) =
 \frac{\hat{\Gamma}(h)}{\hat{\Gamma}(0)}</code>. 
Where <code class="reqn">\hat{\Gamma}(h) = \frac{1}{n} \sum_{t=h+1}^n \hat{e}_t\hat{e}_{t-h}</code>.
With <code class="reqn">\hat{\Gamma}_m = (\hat{\Gamma}(1),...,\hat{\Gamma}(m))   </code>
The vector of the first m sample autocorrelations is written <code class="reqn">\hat{\rho}_m = (\hat{\rho}(1),...,\hat{\rho}(m))'</code>.
</p>
<p>The normalization matrix is defined by <code class="reqn">\hat{C}_{m} =
 \frac{1}{n^{2}}\sum_{t=1}^{n} \hat{S}_t \hat{S}_t'</code> where <code class="reqn">\hat{S}_t = \sum_{j=1}^{t} (\hat{\Lambda} \hat{U}_{j} -
 \hat{\Gamma}_m)</code>.
</p>
<p>The sample autocorrelations satisfy <code class="reqn">Q_{m}^{SN}=n\hat{\sigma}^{4}\hat{\rho}_m '
 \hat{C}_m^{-1}\hat{\rho}_m \rightarrow U_{m}</code>.
</p>
<p><code class="reqn">\tilde{Q}_{m}^{SN} =
 n\hat{\sigma}^{4}\hat{\rho}_{m}' D_{n,m}^{1/2}\hat{C}_{m}^{-1} D_{n,m}^{1/2}\hat{\rho}_{m} \rightarrow U_{m} </code>
reprensating respectively the version modified of Box-Pierce (BP) and
Ljung-Box (LB) statistics. Where <code class="reqn">D_{n,m} = \left(\begin{array}{ccc} \frac{n}{n-1} &amp; &amp; 0 \\
  &amp; \ddots &amp; \\
 0 &amp; &amp; \frac{n}{n-m}
 \end{array}\right)</code>.
The critical values for <code class="reqn">U_{m}</code> have been tabulated by Lobato.
</p>


<h3>Value</h3>

<p>A list including statistics and p-value:
</p>

<dl>
<dt><code>Pm.BP</code></dt><dd><p>Standard portmanteau Box-Pierce statistics.</p>
</dd>
<dt><code>PvalBP</code></dt><dd><p>p-value corresponding at standard test where the
asymptotic distribution is approximated by a chi-squared</p>
</dd>
<dt><code>PvalBP.Imhof</code></dt><dd><p>p-value corresponding at the exact asymptotic distribution
of the standard portmanteau Box-Pierce statistics.</p>
</dd>
<dt><code>Pm.LB</code></dt><dd><p>Standard portmanteau Box-Pierce statistics. </p>
</dd>
<dt><code>PvalLB</code></dt><dd><p>p-value corresponding at standard test where the
asymptotic distribution is approximated by a chi-squared. </p>
</dd>
<dt><code>PvalLB.Imhof</code></dt><dd><p> p-value corresponding at the exact asymptotic distribution
of the standard portmanteau Ljung-Box statistics.</p>
</dd>
<dt><code>LB.modSN </code></dt><dd><p>Ljung-Box statistic with the self-normalization method. </p>
</dd>
<dt><code>BP.modSN</code></dt><dd><p>Box-Pierce statistic with the self-normalization method.</p>
</dd> </dl>



<h3>References</h3>

<p>Boubacar Maïnassara, Y. 2011, Multivariate portmanteau test for structural VARMA models
with uncorrelated but non-independent error terms <em>Journal of Statistical Planning and Inference</em>,
vol. 141, no. 8, pp. 2961-2975.
</p>
<p>Boubacar Maïnassara, Y. and Saussereau, B. 2018, Diagnostic checking in multivariate ARMA models with 
dependent errors using normalized residual autocorrelations ,
<em>Journal of the American Statistical Association</em>, vol. 113, no. 524, pp. 1813-1827.
</p>
<p>Francq, C., Roy, R. and Zakoïan, J.M. 2005, Diagnostic Checking in ARMA
Models with Uncorrelated Errors, <em>Journal of the American Statistical
Association</em>, vol. 100, no. 470 pp. 532-544
</p>
<p>Lobato, I.N. 2001, Testing that a dependant process is
uncorrelated. J. Amer. Statist. Assos. 96, vol. 455, pp. 1066-1076.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+portmanteauTest">portmanteauTest</a></code> to obtain the statistics of all m
lags.
</p>

<hr>
<h2 id='signifparam'>Computes the parameters significance</h2><span id='topic+signifparam'></span>

<h3>Description</h3>

<p>Computes a matrix with estimated coefficient and their significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signifparam(
  ar = NULL,
  ma = NULL,
  p = NULL,
  q = NULL,
  y,
  sd.strong = NULL,
  sd.weak = NULL,
  meanparam = TRUE,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signifparam_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients, if <code>NULL</code>, MA process.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients, if <code>NULL</code>, AR process.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_p">p</code></td>
<td>
<p>Order of AR, if <code>NULL</code> MA process.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_q">q</code></td>
<td>
<p>Order of MA, if <code>NULL</code> AR process.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_sd.strong">sd.strong</code></td>
<td>
<p>Standard error of time series in the strong case computed in <code><a href="#topic+omega">omega</a></code>, if not provided the function will compute it.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_sd.weak">sd.weak</code></td>
<td>
<p>Standard error of time series in the weak case computed in <code><a href="#topic+omega">omega</a></code>, if not provided the function will compute it.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_meanparam">meanparam</code></td>
<td>
<p>If <code class="reqn">\mu</code> of the time series needs to be computed.</p>
</td></tr>
<tr><td><code id="signifparam_+3A_mu">mu</code></td>
<td>
<p>Value of <code class="reqn">\mu</code>, if it is known and if the <code>meanparam</code> is <code>TRUE</code>. If not known the function will compute it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function needs at least one pair between: ar and/or ma, or p and/or q to be executed. It will be faster with all the parameters provided.
</p>


<h3>Value</h3>

<p>Matrix of the estimate coefficient with their significance.
</p>

<dl>
<dt><code>coef</code></dt><dd><p>Estimation of each coefficient.</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation in each case.</p>
</dd>
<dt><code>t-ratio</code></dt><dd><p>T-ratio corresponding to each coefficient.</p>
</dd>
<dt><code>signif</code></dt><dd><p>Significance of each parameter. 
Must be small, if not the parameter is not significant.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>signifparam(p = 1, q = 2, y = CAC40return.sq) #The last parameter is not significant.
signifparam(p = 1, q = 1, y = CAC40return.sq) #All the parameters are significant.

</code></pre>

<hr>
<h2 id='sim.ARMA'>Simulation of ARMA(p,q) model.</h2><span id='topic+sim.ARMA'></span>

<h3>Description</h3>

<p>Simulates an ARMA, AR or MA process according to the arguments
given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ARMA(
  n,
  ar = NULL,
  ma = NULL,
  sigma = 1,
  eta = NULL,
  method = "strong",
  k = 1,
  mu = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.ARMA_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_ar">ar</code></td>
<td>
<p>Vector of AR coefficients. If <code>NULL</code>,  the simulation is a MA process.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_ma">ma</code></td>
<td>
<p>Vector of MA coefficients. If <code>NULL</code>,  the simulation is a AR process.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_eta">eta</code></td>
<td>
<p>Vector of white noise sequence. Allows the user to use his own
white noise.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_method">method</code></td>
<td>
<p>Defines the kind of noise used for the simulation. By default,
the noise used is strong. See 'Details'.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_k">k</code></td>
<td>
<p>Integer used in the creation of the noise. See 'Details'.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_mu">mu</code></td>
<td>
<p>Integer for the mean of the series.</p>
</td></tr>
<tr><td><code id="sim.ARMA_+3A_...">...</code></td>
<td>
<p>Arguments needed to simulate GARCH noise. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ARMA model is of the following form : </p>
<p style="text-align: center;"><code class="reqn"> X_{t}-\mu = e_{t} + a_{1} (X_{t-1}-\mu)
+ a_{2} (X_{t-2}-\mu) + ... + a_{p} (X_{t-p}-\mu) - b_1 e_{t-1} - b_2 e_{t-2} - ... - b_{q}  e_{t-q}</code>
</p>

<p>where <code class="reqn">e_t</code> is a sequence  of uncorrelated random variables with zero
mean and common variance <code class="reqn">\sigma^{2} &gt; 0</code> . <code class="reqn">ar = (a_{1}, a_{2}, ..., a_{p})</code> are
autoregressive coefficients and <code class="reqn">ma = (b_{1}, b_{2}, ... , b_{q})</code> are moving
average coefficients. Characteristic polynomials of ar and ma must
constitute a stationary process.
</p>
<p>Method &quot;<code>strong</code>&quot; realise a simulation with gaussian white noise.
</p>
<p>Method &quot;<code>product</code>&quot;, &quot;<code>ratio</code>&quot; and &quot;<code>product.square</code>&quot;
realise a simulation with a weak white noise. These methods employ
respectively the functions  <code><a href="#topic+wnPT">wnPT</a></code>, <code><a href="#topic+wnRT">wnRT</a></code> and
<code><a href="#topic+wnPT_SQ">wnPT_SQ</a></code> to simulate nonlinear ARMA model. So, the
paramater <code>k</code> is an argument of these functions. See <code><a href="#topic+wnPT">wnPT</a></code>, <code><a href="#topic+wnRT">wnRT</a></code>
or <code><a href="#topic+wnPT_SQ">wnPT_SQ</a></code>.
</p>
<p>Method &quot;<code>GARCH</code>&quot; gives an ARMA process with a GARCH noise. See
<code><a href="#topic+simGARCH">simGARCH</a></code>.
</p>


<h3>Value</h3>

<p>Returns a vector containing the <code>n</code> simulated observations of the
time series.
</p>


<h3>References</h3>

<p>Francq, C. and Zakoïan, J.M. 1998, Estimating linear representations
of nonlinear processes, <em>Journal of Statistical Planning and
Inference</em>, vol. 68, no. 1, pp. 145-165
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima.sim">arima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- sim.ARMA(n = 100, ar = 0.95, ma = -0.6, method = "strong" )
y2 &lt;- sim.ARMA(n = 100, ar = 0.95, ma = -0.6, method = "ratio")
y3 &lt;- sim.ARMA(n = 100,  ar = 0.95, ma = -0.6, method = "GARCH", c = 1, A = 0.1, B = 0.88)
y4 &lt;- sim.ARMA(n = 100, ar = 0.95, ma = -0.6, method = "product")
y5 &lt;- sim.ARMA(n = 100, ar = 0.95, ma = -0.6, method = "product.square")

</code></pre>

<hr>
<h2 id='simGARCH'>GARCH process</h2><span id='topic+simGARCH'></span>

<h3>Description</h3>

<p>Simulates a GARCH process which is an example of a weak white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGARCH(n, c, A, B = NULL, ninit = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simGARCH_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="simGARCH_+3A_c">c</code></td>
<td>
<p>Positive number.</p>
</td></tr>
<tr><td><code id="simGARCH_+3A_a">A</code></td>
<td>
<p>Vector of ARCH coefficients &gt;=0.</p>
</td></tr>
<tr><td><code id="simGARCH_+3A_b">B</code></td>
<td>
<p>Vector of GARCH coefficients &gt;=0. If <code>NULL</code>, the
simulation is a ARCH process.</p>
</td></tr>
<tr><td><code id="simGARCH_+3A_ninit">ninit</code></td>
<td>
<p>Length of 'burn-in' period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size <code>n</code> containing  a nonlinear sequence <code class="reqn">\epsilon_t</code> such as
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{t} = H_{t}^{1 / 2}  \eta_{t}</code>
</p>
<p> where </p>
<p style="text-align: center;"><code class="reqn">H_{t} =  c +
  a_{1}\epsilon_{t - 1}^ {2}+...+a_{q}\epsilon_{t - q} ^{2} + b_{1}H_{t-1}+...+ b_{p}H_{t-p}</code>
</p>



<h3>References</h3>

<p>Francq C. and Zakoïan J.M., 2010, <em>GARCH models: structure, statistical inference and financial applications</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wnRT">wnRT</a></code>, <code><a href="#topic+wnPT">wnPT</a></code>, <code><a href="#topic+wnPT_SQ">wnPT_SQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simGARCH(100, c = 1, A = 0.25)
simGARCH(100, c = 1, A = 0.1,  B = 0.88)
</code></pre>

<hr>
<h2 id='VARest'>Estimation of VAR(p) model</h2><span id='topic+VARest'></span>

<h3>Description</h3>

<p>Estimates the coefficients of a VAR(p) model. Used in <code><a href="#topic+matXi">matXi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARest(x, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VARest_+3A_x">x</code></td>
<td>
<p>Matrix of dimension (n,p+q).</p>
</td></tr>
<tr><td><code id="VARest_+3A_p">p</code></td>
<td>
<p>Integer for the lag order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>ac</code></dt><dd><p>Coefficients data matrix.</p>
</dd>
<dt><code>p</code></dt><dd><p>Integer of the lag order.</p>
</dd>
<dt><code>k</code></dt><dd><p>Dimension of the VAR.</p>
</dd>
<dt><code>res</code></dt><dd><p>Matrix of residuals.</p>
</dd>
</dl>


<hr>
<h2 id='wnPT'>Weak white noise</h2><span id='topic+wnPT'></span>

<h3>Description</h3>

<p>Simulates an uncorrelated but dependant noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wnPT(n, sigma = 1, k = 1, ninit = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wnPT_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="wnPT_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="wnPT_+3A_k">k</code></td>
<td>
<p>Integer corresponding to the number of past observation will be used.</p>
</td></tr>
<tr><td><code id="wnPT_+3A_ninit">ninit</code></td>
<td>
<p>Length of 'burn-in' period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size <code>n</code> containing  a nonlinear sequence <code class="reqn">X_{i}</code> such as
<code class="reqn">X_{i} = Z_{i}Z_{i-1}...Z_{i-k}</code> , where <code class="reqn">Z_{i}</code> is a sequence of iid
random variables mean-zero random variable with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>References</h3>

<p>Romano, J. and Thombs, L. 1996, Inference for autocorrelation under weak assumptions,
<em>Journal of the American Statistical Association</em>, vol. 91, no. 434, pp. 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wnRT">wnRT</a></code>, <code><a href="#topic+wnPT_SQ">wnPT_SQ</a></code>, <code><a href="#topic+simGARCH">simGARCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wnPT(100)
wnPT(100, sigma = 1, k = 1)
wnPT(100, k = 0) #strong noise
</code></pre>

<hr>
<h2 id='wnPT_SQ'>Weak white noise</h2><span id='topic+wnPT_SQ'></span>

<h3>Description</h3>

<p>Simulates an uncorrelated but dependant noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wnPT_SQ(n, sigma = 1, k = 1, ninit = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wnPT_SQ_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="wnPT_SQ_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="wnPT_SQ_+3A_k">k</code></td>
<td>
<p>Integer corresponding to the number of past observation will be used.</p>
</td></tr>
<tr><td><code id="wnPT_SQ_+3A_ninit">ninit</code></td>
<td>
<p>Length of 'burn-in' period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size <code>n</code> containing  a nonlinear sequence <code class="reqn">X_{i}</code> such as
<code class="reqn">X_{i} = Z^{2}_iZ_{i-1}...Z_{i-k}</code> , where <code class="reqn">Z_{i}</code> is a sequence of iid
random variables mean-zero random variable with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>References</h3>

<p>Romano, J. and Thombs, L. 1996, Inference for autocorrelation under weak assumptions,
<em>Journal of the American Statistical Association</em>, vol. 91, no. 434, pp. 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wnRT">wnRT</a></code>, <code><a href="#topic+wnPT">wnPT</a></code>, <code><a href="#topic+simGARCH">simGARCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wnPT_SQ(100)
wnPT_SQ(100, sigma = 1, k = 1)
</code></pre>

<hr>
<h2 id='wnRT'>Weak white noise</h2><span id='topic+wnRT'></span>

<h3>Description</h3>

<p>Simulates an uncorrelated but dependant noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wnRT(n, sigma = 1, k = 1, ninit = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wnRT_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="wnRT_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code id="wnRT_+3A_k">k</code></td>
<td>
<p>Integer <code class="reqn">\neq 0</code> to prevent a zero denominator.</p>
</td></tr>
<tr><td><code id="wnRT_+3A_ninit">ninit</code></td>
<td>
<p>Length of 'burn-in' period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of size <code>n</code> containing  a nonlinear sequence <code class="reqn">X_{i}</code> such as
<code class="reqn">X_i = \frac{Z_{i}}{|Z_{i+1}| + k}</code> , where <code class="reqn">Z_{i}</code> is a sequence of iid
random variables mean-zero random variable with variance <code class="reqn">\sigma^2</code>.
</p>


<h3>References</h3>

<p>Romano, J. and Thombs, L. 1996, Inference for autocorrelation under weak assumptions,
<em>Journal of the American Statistical Association</em>, vol. 91, no. 434, pp. 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wnPT">wnPT</a></code>, <code><a href="#topic+wnPT_SQ">wnPT_SQ</a></code>, <code><a href="#topic+simGARCH">simGARCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wnRT(100)
wnRT(100, sigma = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
