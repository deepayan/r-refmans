<!DOCTYPE html><html><head><title>Help for package Matrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Matrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abIndex-class'><p>Class &quot;abIndex&quot; of Abstract Index Vectors</p></a></li>
<li><a href='#abIseq'><p>Sequence Generation of &quot;abIndex&quot;, Abstract Index Vectors</p></a></li>
<li><a href='#all.equal-methods'><p>Matrix Package Methods for Function all.equal()</p></a></li>
<li><a href='#asUniqueT'><p>Standardize a Sparse Matrix in Triplet Format</p></a></li>
<li><a href='#band-methods'><p>Extract bands of a matrix</p></a></li>
<li><a href='#bandSparse'><p>Construct Sparse Banded Matrix from (Sup-/Super-) Diagonals</p></a></li>
<li><a href='#bdiag'><p>Construct a Block Diagonal Matrix</p></a></li>
<li><a href='#boolmatmult-methods'><p>Boolean Arithmetic Matrix Products: <code>%&amp;%</code> and Methods</p></a></li>
<li><a href='#BunchKaufman-class'><p>Dense Bunch-Kaufman Factorizations</p></a></li>
<li><a href='#BunchKaufman-methods'><p>Methods for Bunch-Kaufman Factorization</p></a></li>
<li><a href='#CAex'><p>Albers' example Matrix with &quot;Difficult&quot; Eigen Factorization</p></a></li>
<li><a href='#cbind2-methods'><p>'cbind()' and 'rbind()' recursively built on cbind2/rbind2</p></a></li>
<li><a href='#CHMfactor-class'><p>Sparse Cholesky Factorizations</p></a></li>
<li><a href='#chol-methods'><p>Compute the Cholesky Factor of a Matrix</p></a></li>
<li><a href='#chol2inv-methods'><p>Inverse from Cholesky Factor</p></a></li>
<li><a href='#Cholesky-class'><p>Dense Cholesky Factorizations</p></a></li>
<li><a href='#Cholesky-methods'><p>Methods for Cholesky Factorization</p></a></li>
<li><a href='#coerce-methods-graph'><p>Conversions &quot;graph&quot; &lt;&ndash;&gt; (sparse) Matrix</p></a></li>
<li><a href='#coerce-methods-SparseM'><p>Sparse Matrix Coercion from and to those from package <span class="pkg">SparseM</span></p></a></li>
<li><a href='#colSums-methods'><p>Form Row and Column Sums and Means</p></a></li>
<li><a href='#condest'><p>Compute Approximate CONDition number and 1-Norm of (Large) Matrices</p></a></li>
<li><a href='#CsparseMatrix-class'><p>Class &quot;CsparseMatrix&quot; of Sparse Matrices in Column-compressed Form</p></a></li>
<li><a href='#ddenseMatrix-class'><p>Virtual Class &quot;ddenseMatrix&quot; of Numeric Dense Matrices</p></a></li>
<li><a href='#ddiMatrix-class'><p>Class &quot;ddiMatrix&quot; of Diagonal Numeric Matrices</p></a></li>
<li><a href='#denseLU-class'><p>Dense LU Factorizations</p></a></li>
<li><a href='#denseMatrix-class'><p>Virtual Class &quot;denseMatrix&quot; of All Dense Matrices</p></a></li>
<li><a href='#dgCMatrix-class'><p>Compressed, sparse, column-oriented numeric matrices</p></a></li>
<li><a href='#dgeMatrix-class'><p>Class &quot;dgeMatrix&quot; of Dense Numeric (S4 Class) Matrices</p></a></li>
<li><a href='#dgRMatrix-class'><p>Sparse Compressed, Row-oriented Numeric Matrices</p></a></li>
<li><a href='#dgTMatrix-class'><p>Sparse matrices in triplet form</p></a></li>
<li><a href='#Diagonal'><p>Construct a Diagonal Matrix</p></a></li>
<li><a href='#diagonalMatrix-class'><p>Class &quot;diagonalMatrix&quot; of Diagonal Matrices</p></a></li>
<li><a href='#diagU2N'><p>Transform Triangular Matrices from Unit Triangular to General Triangular and Back</p></a></li>
<li><a href='#dimScale'><p>Scale the Rows and Columns of a Matrix</p></a></li>
<li><a href='#dMatrix-class'><p>(Virtual) Class &quot;dMatrix&quot; of &quot;double&quot; Matrices</p></a></li>
<li><a href='#dmperm'><p>Dulmage-Mendelsohn Permutation / Decomposition</p></a></li>
<li><a href='#dpoMatrix-class'><p>Positive Semi-definite Dense (Packed | Non-packed) Numeric Matrices</p></a></li>
<li><a href='#drop0'><p>Drop Non-Structural Zeros from a Sparse Matrix</p></a></li>
<li><a href='#dsCMatrix-class'><p>Numeric Symmetric Sparse (column compressed) Matrices</p></a></li>
<li><a href='#dsparseMatrix-class'><p>Virtual Class &quot;dsparseMatrix&quot; of Numeric Sparse Matrices</p></a></li>
<li><a href='#dsRMatrix-class'><p>Symmetric Sparse Compressed Row Matrices</p></a></li>
<li><a href='#dsyMatrix-class'><p>Symmetric Dense (Packed or Unpacked) Numeric Matrices</p></a></li>
<li><a href='#dtCMatrix-class'><p>Triangular, (compressed) sparse column matrices</p></a></li>
<li><a href='#dtpMatrix-class'><p>Packed Triangular Dense Matrices - &quot;dtpMatrix&quot;</p></a></li>
<li><a href='#dtrMatrix-class'><p>Triangular, dense, numeric matrices</p></a></li>
<li><a href='#dtRMatrix-class'><p>Triangular Sparse Compressed Row Matrices</p></a></li>
<li><a href='#expand-methods'><p>Expand Matrix Factorizations</p></a></li>
<li><a href='#expm-methods'><p>Matrix Exponential</p></a></li>
<li><a href='#externalFormats'><p>Read and write external matrix formats</p></a></li>
<li><a href='#facmul-methods'><p>Multiplication by Factors from Matrix Factorizations</p></a></li>
<li><a href='#fastMisc'><p>&ldquo;Low Level&rdquo; Coercions and Methods</p></a></li>
<li><a href='#forceSymmetric-methods'><p>Force a Matrix to 'symmetricMatrix' Without Symmetry Checks</p></a></li>
<li><a href='#formatSparseM'><p>Formatting Sparse Numeric Matrices Utilities</p></a></li>
<li><a href='#generalMatrix-class'><p>Class &quot;generalMatrix&quot; of General Matrices</p></a></li>
<li><a href='#Hilbert'><p>Generate a Hilbert matrix</p></a></li>
<li><a href='#image-methods'><p>Methods for image() in Package 'Matrix'</p></a></li>
<li><a href='#index-class'><p>Virtual Class &ldquo;index&rdquo; of Index Vectors</p></a></li>
<li><a href='#indMatrix-class'><p>Index Matrices</p></a></li>
<li><a href='#invertPerm'><p>Utilities for Permutation Vectors</p></a></li>
<li><a href='#is.na-methods'><p>is.na(), is.finite() Methods for 'Matrix' Objects</p></a></li>
<li><a href='#is.null.DN'><p>Are the Dimnames <code>dn</code> NULL-like ?</p></a></li>
<li><a href='#isSymmetric-methods'><p>Methods for Function 'isSymmetric' in Package 'Matrix'</p></a></li>
<li><a href='#isTriangular-methods'><p>Test whether a Matrix is Triangular or Diagonal</p></a></li>
<li><a href='#KhatriRao'><p>Khatri-Rao Matrix Product</p></a></li>
<li><a href='#KNex'><p>Koenker-Ng Example Sparse Model Matrix and Response Vector</p></a></li>
<li><a href='#kronecker-methods'><p>Methods for Function 'kronecker()' in Package 'Matrix'</p></a></li>
<li><a href='#ldenseMatrix-class'><p>Virtual Class &quot;ldenseMatrix&quot; of Dense Logical Matrices</p></a></li>
<li><a href='#ldiMatrix-class'><p>Class &quot;ldiMatrix&quot; of Diagonal Logical Matrices</p></a></li>
<li><a href='#lgeMatrix-class'><p>Class &quot;lgeMatrix&quot; of General Dense Logical Matrices</p></a></li>
<li><a href='#lsparseMatrix-class'><p>Sparse logical matrices</p></a></li>
<li><a href='#lsyMatrix-class'><p>Symmetric Dense Logical Matrices</p></a></li>
<li><a href='#ltrMatrix-class'><p>Triangular Dense Logical Matrices</p></a></li>
<li><a href='#lu-methods'><p>Methods for LU Factorization</p></a></li>
<li><a href='#mat2triplet'><p>Map Matrix to its Triplet Representation</p></a></li>
<li><a href='#matmult-methods'><p>Matrix (Cross) Products (of Transpose)</p></a></li>
<li><a href='#Matrix'><p>Construct a Classed Matrix</p></a></li>
<li><a href='#Matrix-class'><p>Virtual Class &quot;Matrix&quot; of Matrices</p></a></li>
<li><a href='#Matrix-defunct'><p>Defunct Functions in Package <span class="pkg">Matrix</span></p></a></li>
<li><a href='#Matrix-deprecated'><p>Deprecated Functions in Package <span class="pkg">Matrix</span></p></a></li>
<li><a href='#Matrix-notyet'><p>Virtual Classes Not Yet Really Implemented and Used</p></a></li>
<li><a href='#MatrixClass'><p>The Matrix (Super-) Class of a Class</p></a></li>
<li><a href='#MatrixFactorization-class'><p>Virtual Class &quot;MatrixFactorization&quot; of Matrix Factorizations</p></a></li>
<li><a href='#ndenseMatrix-class'><p>Virtual Class &quot;ndenseMatrix&quot; of Dense Logical Matrices</p></a></li>
<li><a href='#nearPD'><p>Nearest Positive Definite Matrix</p></a></li>
<li><a href='#ngeMatrix-class'><p>Class &quot;ngeMatrix&quot; of General Dense Nonzero-pattern Matrices</p></a></li>
<li><a href='#nMatrix-class'><p>Class &quot;nMatrix&quot; of Non-zero Pattern Matrices</p></a></li>
<li><a href='#nnzero-methods'><p>The Number of Non-Zero Values of a Matrix</p></a></li>
<li><a href='#norm-methods'><p>Matrix Norms</p></a></li>
<li><a href='#nsparseMatrix-class'><p>Sparse &quot;pattern&quot; Matrices</p></a></li>
<li><a href='#nsyMatrix-class'><p>Symmetric Dense Nonzero-Pattern Matrices</p></a></li>
<li><a href='#ntrMatrix-class'><p>Triangular Dense Logical Matrices</p></a></li>
<li><a href='#pack-methods'><p>Representation of Packed and Unpacked Dense Matrices</p></a></li>
<li><a href='#packedMatrix-class'><p>Virtual Class <code>"packedMatrix"</code> of Packed Dense Matrices</p></a></li>
<li><a href='#pMatrix-class'><p>Permutation matrices</p></a></li>
<li><a href='#printSpMatrix'><p>Format and Print Sparse Matrices Flexibly</p></a></li>
<li><a href='#qr-methods'><p>Methods for QR Factorization</p></a></li>
<li><a href='#rankMatrix'><p>Rank of a Matrix</p></a></li>
<li><a href='#rcond-methods'><p>Estimate the Reciprocal Condition Number</p></a></li>
<li><a href='#rep2abI'><p>Replicate Vectors into 'abIndex' Result</p></a></li>
<li><a href='#rleDiff-class'><p>Class &quot;rleDiff&quot; of  rle(diff(.))  Stored Vectors</p></a></li>
<li><a href='#rsparsematrix'><p>Random Sparse Matrix</p></a></li>
<li><a href='#RsparseMatrix-class'><p>Class &quot;RsparseMatrix&quot; of Sparse Matrices in Row-compressed Form</p></a></li>
<li><a href='#Schur-class'><p>Schur Factorizations</p></a></li>
<li><a href='#Schur-methods'><p>Methods for Schur Factorization</p></a></li>
<li><a href='#solve-methods'><p>Methods in Package <span class="pkg">Matrix</span> for Function <code>solve</code></p></a></li>
<li><a href='#sparse.model.matrix'><p>Construct Sparse Design / Model Matrices</p></a></li>
<li><a href='#sparseLU-class'><p>Sparse LU Factorizations</p></a></li>
<li><a href='#sparseMatrix'><p>General Sparse Matrix Construction from Nonzero Entries</p></a></li>
<li><a href='#sparseMatrix-class'><p>Virtual Class &quot;sparseMatrix&quot; &mdash; Mother of Sparse Matrices</p></a></li>
<li><a href='#sparseQR-class'><p>Sparse QR Factorizations</p></a></li>
<li><a href='#sparseVector'><p>Sparse Vector Construction from Nonzero Entries</p></a></li>
<li><a href='#sparseVector-class'><p>Sparse Vector Classes</p></a></li>
<li><a href='#spMatrix'><p>Sparse Matrix Constructor From Triplet</p></a></li>
<li><a href='#subassign-methods'><p>Methods for &quot;[&lt;-&quot; - Assigning to Subsets for 'Matrix'</p></a></li>
<li><a href='#subscript-methods'><p>Methods for &quot;[&quot;: Extraction or Subsetting in Package 'Matrix'</p></a></li>
<li><a href='#symmetricMatrix-class'><p>Virtual Class of Symmetric Matrices in Package Matrix</p></a></li>
<li><a href='#symmpart-methods'><p>Symmetric Part and Skew(symmetric) Part of a Matrix</p></a></li>
<li><a href='#triangularMatrix-class'><p>Virtual Class of Triangular Matrices in Package Matrix</p></a></li>
<li><a href='#TsparseMatrix-class'><p>Class &quot;TsparseMatrix&quot; of Sparse Matrices in Triplet Form</p></a></li>
<li><a href='#unpackedMatrix-class'><p>Virtual Class <code>"unpackedMatrix"</code> of Unpacked Dense Matrices</p></a></li>
<li><a href='#updown-methods'><p>Updating and Downdating Sparse Cholesky Factorizations</p></a></li>
<li><a href='#USCounties'><p>Contiguity Matrix of U.S. Counties</p></a></li>
<li><a href='#wrld_1deg'><p>Contiguity Matrix of World One-Degree Grid Cells</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-0</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>do also bump src/version.h, inst/include/Matrix/version.h</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-16</td>
</tr>
<tr>
<td>Priority:</td>
<td>recommended</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse and Dense Matrix Classes and Methods</td>
</tr>
<tr>
<td>Description:</td>
<td>A rich hierarchy of sparse and dense matrix classes,
	including general, symmetric, triangular, and diagonal matrices
	with numeric, logical, or pattern entries.  Efficient methods for
	operating on such matrices, often wrapping the 'BLAS', 'LAPACK',
	and 'SuiteSparse' libraries.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://Matrix.R-forge.R-project.org">https://Matrix.R-forge.R-project.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://R-forge.R-project.org/tracker/?atid=294&amp;group_id=61">https://R-forge.R-project.org/tracker/?atid=294&amp;group_id=61</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>Matrix-authors@R-project.org</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, grid, lattice, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, datasets, sfsmisc, tools</td>
</tr>
<tr>
<td>Enhances:</td>
<td>SparseM, graph</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>LazyDataNote:</td>
<td>not possible, since we use data/*.R and our S4 classes</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 17:15:14 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Douglas Bates <a href="https://orcid.org/0000-0001-8316-9503"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mikael Jagan <a href="https://orcid.org/0000-0002-3542-2938"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Timothy A. Davis <a href="https://orcid.org/0000-0001-7614-6899"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (SuiteSparse libraries, collaborators listed in
    dir(system.file("doc", "SuiteSparse", package="Matrix"),
    pattern="License", full.names=TRUE, recursive=TRUE)),
  George Karypis <a href="https://orcid.org/0000-0003-2753-1437"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (METIS library, Copyright: Regents of the University of
    Minnesota),
  Jason Riedy <a href="https://orcid.org/0000-0002-4345-4200"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (GNU Octave's condest() and onenormest(), Copyright: Regents of the
    University of California),
  Jens Oehlschlägel [ctb] (initial nearPD()),
  R Core Team [ctb] (base R's matrix implementation)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;mmaechler+Matrix@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-26 12:03:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abIndex-class'>Class &quot;abIndex&quot; of Abstract Index Vectors</h2><span id='topic+abIndex-class'></span><span id='topic+seqMat-class'></span><span id='topic+Arith+2CabIndex+2CabIndex-method'></span><span id='topic+Arith+2CabIndex+2CnumLike-method'></span><span id='topic+Arith+2CnumLike+2CabIndex-method'></span><span id='topic+Ops+2CANY+2CabIndex-method'></span><span id='topic+Ops+2CabIndex+2CANY-method'></span><span id='topic+Ops+2CabIndex+2CabIndex-method'></span><span id='topic+Summary+2CabIndex-method'></span><span id='topic+as.integer+2CabIndex-method'></span><span id='topic+as.numeric+2CabIndex-method'></span><span id='topic+as.vector+2CabIndex-method'></span><span id='topic+coerce+2CabIndex+2Cinteger-method'></span><span id='topic+coerce+2CabIndex+2Cnumeric-method'></span><span id='topic+coerce+2CabIndex+2CseqMat-method'></span><span id='topic+coerce+2CabIndex+2Cvector-method'></span><span id='topic+coerce+2Clogical+2CabIndex-method'></span><span id='topic+coerce+2Cnumeric+2CabIndex-method'></span><span id='topic+drop+2CabIndex-method'></span><span id='topic+length+2CabIndex-method'></span><span id='topic+show+2CabIndex-method'></span><span id='topic+coerce+2Cnumeric+2CseqMat-method'></span><span id='topic+coerce+2CseqMat+2CabIndex-method'></span><span id='topic+coerce+2CseqMat+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The <code>"abIndex"</code> <code><a href="base.html#topic+class">class</a></code>, short for &ldquo;Abstract
Index Vector&rdquo;, is used for dealing with large index vectors more
efficiently, than using integer (or <code><a href="base.html#topic+numeric">numeric</a></code>) vectors of
the kind <code>2:1000000</code> or <code>c(0:1e5, 1000:1e6)</code>.
</p>
<p>Note that the current implementation details are subject to change,
and if you consider working with these classes, please contact the
package maintainers (<code>packageDescription("Matrix")$Maintainer</code>).
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("abIndex", ...)</code>,
but more easily and typically either by <code>as(x, "abIndex")</code> where
<code>x</code> is an integer (valued) vector, or directly by
<code><a href="#topic+abIseq">abIseq</a>()</code> and combination <code><a href="base.html#topic+c">c</a>(...)</code> of such.
</p>


<h3>Slots</h3>


<dl>
<dt><code>kind</code>:</dt><dd><p>a <code><a href="base.html#topic+character">character</a></code> string,
one of <code>("int32", "double", "rleDiff")</code>, denoting the
internal structure of the abIndex object.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numLike"</code>; is
used (i.e., not of length <code>0</code>) only iff the object is <em>not</em>
compressed, i.e., currently exactly when <code>kind != "rleDiff"</code>.</p>
</dd>
<dt><code>rleD</code>:</dt><dd><p>object of class <code>"<a href="#topic+rleDiff-class">rleDiff</a>"</code>,
used for compression via <code><a href="base.html#topic+rle">rle</a></code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.numeric, as.integer, as.vector</dt><dd><p><code>signature(x = "abIndex")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "abIndex", i = "index", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "numeric", to = "abIndex")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "abIndex", to = "numeric")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "abIndex", to = "integer")</code>: ... </p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "abIndex")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "numeric", e2 = "abIndex")</code>: These
and the following arithmetic and logic operations are
<b>not yet implemented</b>; see <code><a href="methods.html#topic+Ops">Ops</a></code> for a
list of these (S4) group methods.</p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "abIndex", e2 = "abIndex")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "abIndex", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "abIndex")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>("abIndex")</code>: simple <code><a href="methods.html#topic+show">show</a></code> method,
building on <code>show(&lt;rleDiff&gt;)</code>.</p>
</dd>
<dt>is.na</dt><dd><p><code>("abIndex")</code>: works analogously to regular vectors.</p>
</dd>
<dt>is.finite, is.infinite</dt><dd><p><code>("abIndex")</code>: ditto.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This is currently experimental and not yet used for our own code.
Please contact us (<code>packageDescription("Matrix")$Maintainer</code>),
if you plan to make use of this class.
</p>
<p>Partly builds on ideas and code from Jens Oehlschlaegel,
as implemented (around 2008, in the GPL'ed part of) package <span class="pkg">ff</span>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rle">rle</a></code> (<span class="pkg">base</span>) which is used here;
<code><a href="base.html#topic+numeric">numeric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("abIndex")
ii &lt;- c(-3:40, 20:70)
str(ai &lt;- as(ii, "abIndex"))# note
ai # -&gt; show() method

stopifnot(identical(-3:20,
                    as(abIseq1(-3,20), "vector")))
</code></pre>

<hr>
<h2 id='abIseq'>Sequence Generation of &quot;abIndex&quot;, Abstract Index Vectors</h2><span id='topic+abIseq'></span><span id='topic+abIseq1'></span><span id='topic+c.abIndex'></span>

<h3>Description</h3>

<p>Generation of abstract index vectors, i.e., objects of class
<code>"<a href="#topic+abIndex-class">abIndex</a>"</code>.
</p>
<p><code>abIseq()</code> is designed to work entirely like <code><a href="base.html#topic+seq">seq</a></code>,
but producing <code>"abIndex"</code> vectors.<br />
<code>abIseq1()</code> is its basic building block, where
<code>abIseq1(n,m)</code> corresponds to <code>n:m</code>.
</p>
<p><code>c(x, ...)</code> will return an <code>"abIndex"</code> vector, when <code>x</code>
is one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abIseq1(from = 1, to = 1)
abIseq (from = 1, to = 1, by = ((to - from)/(length.out - 1)),
        length.out = NULL, along.with = NULL)

## S3 method for class 'abIndex'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abIseq_+3A_from">from</code>, <code id="abIseq_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end value of the sequence.</p>
</td></tr>
<tr><td><code id="abIseq_+3A_by">by</code></td>
<td>
<p>number: increment of the sequence.</p>
</td></tr>
<tr><td><code id="abIseq_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.  A
non-negative number, which for <code>seq</code> and <code>seq.int</code> will be
rounded up if fractional.</p>
</td></tr>
<tr><td><code id="abIseq_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="abIseq_+3A_...">...</code></td>
<td>
<p>in general an arbitrary number of <span class="rlang"><b>R</b></span> objects; here,
when the first is an <code>"<a href="#topic+abIndex-class">abIndex</a>"</code> vector, these
arguments will be concatenated to a new <code>"abIndex"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An abstract index vector, i.e., object of class
<code>"<a href="#topic+abIndex-class">abIndex</a>"</code>.
</p>


<h3>See Also</h3>

<p>the class <code><a href="#topic+abIndex-class">abIndex</a></code> documentation;
<code><a href="#topic+rep2abI">rep2abI</a>()</code> for another constructor;
<code><a href="base.html#topic+rle">rle</a></code> (<span class="pkg">base</span>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(identical(-3:20,
                    as(abIseq1(-3,20), "vector")))

try( ## (arithmetic) not yet implemented
abIseq(1, 50, by = 3)
)

</code></pre>

<hr>
<h2 id='all.equal-methods'>Matrix Package Methods for Function all.equal()</h2><span id='topic+all.equal'></span><span id='topic+all.equal-methods'></span><span id='topic+all.equal+2CMatrix+2CMatrix-method'></span><span id='topic+all.equal+2CMatrix+2CsparseVector-method'></span><span id='topic+all.equal+2CMatrix+2Cvector-method'></span><span id='topic+all.equal+2CabIndex+2CabIndex-method'></span><span id='topic+all.equal+2CabIndex+2CnumLike-method'></span><span id='topic+all.equal+2CnumLike+2CabIndex-method'></span><span id='topic+all.equal+2CsparseVector+2CMatrix-method'></span><span id='topic+all.equal+2CsparseVector+2CsparseVector-method'></span><span id='topic+all.equal+2CsparseVector+2Cvector-method'></span><span id='topic+all.equal+2Cvector+2CMatrix-method'></span><span id='topic+all.equal+2Cvector+2CsparseVector-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="#topic+all.equal">all.equal</a>()</code> (from <span class="rlang"><b>R</b></span> package
<span class="pkg">base</span>) are defined for all <code><a href="#topic+Matrix-class">Matrix</a></code> classes.
</p>


<h3>Methods</h3>


<dl>
<dt>target = &quot;Matrix&quot;, current = &quot;Matrix&quot;</dt><dd><p>\ </p>
</dd>
<dt>target = &quot;ANY&quot;, current = &quot;Matrix&quot;</dt><dd><p>\ </p>
</dd>
<dt>target = &quot;Matrix&quot;, current = &quot;ANY&quot;</dt><dd><p>these three methods are
simply using <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric</a></code> directly and work via
<code><a href="base.html#topic+as.vector">as.vector</a>()</code>.</p>
</dd>
</dl>

<p>There are more methods, notably also for
<code>"<a href="#topic+sparseVector-class">sparseVector</a>"</code>'s, see <code>showMethods("all.equal")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods("all.equal")

(A &lt;- spMatrix(3,3, i= c(1:3,2:1), j=c(3:1,1:2), x = 1:5))
ex &lt;- expand(lu. &lt;- lu(A))
stopifnot( all.equal(as(A[lu.@p + 1L, lu.@q + 1L], "CsparseMatrix"),
                     lu.@L %*% lu.@U),
           with(ex, all.equal(as(P %*% A %*% t(Q), "CsparseMatrix"),
                              L %*% U)),
           with(ex, all.equal(as(A, "CsparseMatrix"),
                              t(P) %*% L %*% U %*% Q)))
</code></pre>

<hr>
<h2 id='asUniqueT'>Standardize a Sparse Matrix in Triplet Format</h2><span id='topic+anyDuplicatedT'></span><span id='topic+isUniqueT'></span><span id='topic+asUniqueT'></span><span id='topic+aggregateT'></span><span id='topic+uniqTsparse'></span>

<h3>Description</h3>

<p>Detect or standardize a <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> with
unsorted or duplicated <code class="reqn">(i,j)</code> pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anyDuplicatedT(x, ...)
isUniqueT(x, byrow = FALSE, isT = is(x, "TsparseMatrix"))
asUniqueT(x, byrow = FALSE, isT = is(x, "TsparseMatrix"))
aggregateT(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asUniqueT_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.  <code>anyDuplicatedT</code> and <code>aggregateT</code>
require <code>x</code> inheriting from <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.
<code>asUniqueT</code> requires <code>x</code> inheriting from
<code><a href="#topic+Matrix-class">Matrix</a></code> and coerces <code>x</code>
to <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> if necessary.</p>
</td></tr>
<tr><td><code id="asUniqueT_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the default method for
generic function <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>.</p>
</td></tr>
<tr><td><code id="asUniqueT_+3A_byrow">byrow</code></td>
<td>
<p>a logical indicating if <code>x</code> should be sorted
by row then by column.</p>
</td></tr>
<tr><td><code id="asUniqueT_+3A_ist">isT</code></td>
<td>
<p>a logical indicating if <code>x</code> inherits from virtual
class <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>anyDuplicatedT(x)</code> returns the index of the first duplicated
<code class="reqn">(i,j)</code> pair in <code>x</code> (0 if there are no duplicated pairs).
</p>
<p><code>isUniqueT(x)</code> returns <code>TRUE</code> if <code>x</code> is a
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> with sorted, nonduplicated
<code class="reqn">(i,j)</code> pairs and <code>FALSE</code> otherwise.
</p>
<p><code>asUniqueT(x)</code> returns the unique
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> representation of <code>x</code> with
sorted, nonduplicated <code class="reqn">(i,j)</code> pairs.  Values corresponding to
identical <code class="reqn">(i,j)</code> pairs are aggregated by addition, where in the
logical case &ldquo;addition&rdquo; refers to logical OR.
</p>
<p><code>aggregateT(x)</code> aggregates without sorting.
</p>


<h3>See Also</h3>

<p>Virtual class <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("dgTMatrix-class", echo=FALSE)
## -&gt; 'T2'  with (i,j,x) slots of length 5 each
T2u &lt;- asUniqueT(T2)
stopifnot(## They "are" the same (and print the same):
          all.equal(T2, T2u, tol=0),
          ## but not internally:
          anyDuplicatedT(T2)  == 2,
          anyDuplicatedT(T2u) == 0,
          length(T2 @x) == 5,
          length(T2u@x) == 3)

isUniqueT(T2 ) # FALSE
isUniqueT(T2u) # TRUE

T3 &lt;- T2u
T3[1, c(1,3)] &lt;- 10; T3[2, c(1,5)] &lt;- 20
T3u &lt;- asUniqueT(T3)
str(T3u) # sorted in 'j', and within j, sorted in i
stopifnot(isUniqueT(T3u))

## Logical l.TMatrix and n.TMatrix :
(L2 &lt;- T2 &gt; 0)
validObject(L2u &lt;- asUniqueT(L2))
(N2 &lt;- as(L2, "nMatrix"))
validObject(N2u &lt;- asUniqueT(N2))
stopifnot(N2u@i == L2u@i, L2u@i == T2u@i,  N2@i == L2@i, L2@i == T2@i,
          N2u@j == L2u@j, L2u@j == T2u@j,  N2@j == L2@j, L2@j == T2@j)
# now with a nasty NA  [partly failed in Matrix 1.1-5]:
L.0N &lt;- L.1N &lt;- L2
L.0N@x[1:2] &lt;- c(FALSE, NA)
L.1N@x[1:2] &lt;- c(TRUE, NA)
validObject(L.0N)
validObject(L.1N)
(m.0N &lt;- as.matrix(L.0N))
(m.1N &lt;- as.matrix(L.1N))
stopifnot(identical(10L, which(is.na(m.0N))), !anyNA(m.1N))
symnum(m.0N)
symnum(m.1N)
</code></pre>

<hr>
<h2 id='band-methods'>Extract bands of a matrix</h2><span id='topic+band'></span><span id='topic+band-methods'></span><span id='topic+triu'></span><span id='topic+triu-methods'></span><span id='topic+tril'></span><span id='topic+tril-methods'></span><span id='topic+band+2CCsparseMatrix-method'></span><span id='topic+band+2CRsparseMatrix-method'></span><span id='topic+band+2CTsparseMatrix-method'></span><span id='topic+band+2CdenseMatrix-method'></span><span id='topic+band+2CdiagonalMatrix-method'></span><span id='topic+band+2CindMatrix-method'></span><span id='topic+band+2Cmatrix-method'></span><span id='topic+triu+2CCsparseMatrix-method'></span><span id='topic+triu+2CRsparseMatrix-method'></span><span id='topic+triu+2CTsparseMatrix-method'></span><span id='topic+triu+2CdenseMatrix-method'></span><span id='topic+triu+2CdiagonalMatrix-method'></span><span id='topic+triu+2CindMatrix-method'></span><span id='topic+triu+2Cmatrix-method'></span><span id='topic+tril+2CCsparseMatrix-method'></span><span id='topic+tril+2CRsparseMatrix-method'></span><span id='topic+tril+2CTsparseMatrix-method'></span><span id='topic+tril+2CdenseMatrix-method'></span><span id='topic+tril+2CdiagonalMatrix-method'></span><span id='topic+tril+2CindMatrix-method'></span><span id='topic+tril+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Return the matrix obtained by setting to zero elements below a diagonal
(<code>triu</code>), above a diagonal (<code>tril</code>), or outside of a general
band (<code>band</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>band(x, k1, k2, ...)
triu(x, k = 0L, ...)
tril(x, k = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="band-methods_+3A_x">x</code></td>
<td>
<p>a matrix-like object</p>
</td></tr>
<tr><td><code id="band-methods_+3A_k">k</code>, <code id="band-methods_+3A_k1">k1</code>, <code id="band-methods_+3A_k2">k2</code></td>
<td>
<p>integers specifying the diagonals that are not set to
zero, <code>k1 &lt;= k2</code>.  These are interpreted relative to the main
diagonal, which is <code>k = 0</code>.
Positive and negative values of <code>k</code> indicate
diagonals above and below the main diagonal, respectively.</p>
</td></tr>
<tr><td><code id="band-methods_+3A_...">...</code></td>
<td>
<p>optional arguments passed to methods, currently unused
by package <span class="pkg">Matrix</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triu(x, k)</code> is equivalent to <code>band(x, k, dim(x)[2])</code>.
Similarly,
<code>tril(x, k)</code> is equivalent to <code>band(x, -dim(x)[1], k)</code>.
</p>


<h3>Value</h3>

<p>An object of a suitable matrix class, inheriting from
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code> where appropriate.
It inherits from <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> if
and only if <code>x</code> does.
</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;CsparseMatrix&quot;</dt><dd><p>method for compressed, sparse,
column-oriented matrices.</p>
</dd>
<dt>x = &quot;RsparseMatrix&quot;</dt><dd><p>method for compressed, sparse,
row-oriented matrices.</p>
</dd>
<dt>x = &quot;TsparseMatrix&quot;</dt><dd><p>method for sparse matrices in
triplet format.</p>
</dd>
<dt>x = &quot;diagonalMatrix&quot;</dt><dd><p>method for diagonal matrices.</p>
</dd>
<dt>x = &quot;denseMatrix&quot;</dt><dd><p>method for dense matrices in
packed or unpacked format.</p>
</dd>
<dt>x = &quot;matrix&quot;</dt><dd><p>method for traditional matrices
of implicit class <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+bandSparse">bandSparse</a></code> for the <em>construction</em> of a
banded sparse matrix directly from its non-zero diagonals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A random sparse matrix :
set.seed(7)
m &lt;- matrix(0, 5, 5)
m[sample(length(m), size = 14)] &lt;- rep(1:9, length=14)
(mm &lt;- as(m, "CsparseMatrix"))

tril(mm)        # lower triangle
tril(mm, -1)    # strict lower triangle
triu(mm,  1)    # strict upper triangle
band(mm, -1, 2) # general band
(m5 &lt;- Matrix(rnorm(25), ncol = 5))
tril(m5)        # lower triangle
tril(m5, -1)    # strict lower triangle
triu(m5, 1)     # strict upper triangle
band(m5, -1, 2) # general band
(m65 &lt;- Matrix(rnorm(30), ncol = 5))  # not square
triu(m65)       # result not "dtrMatrix" unless square
(sm5 &lt;- crossprod(m65)) # symmetric
   band(sm5, -1, 1)# "dsyMatrix": symmetric band preserves symmetry property
as(band(sm5, -1, 1), "sparseMatrix")# often preferable
(sm &lt;- round(crossprod(triu(mm/2)))) # sparse symmetric ("dsC*")
band(sm, -1,1) # remains "dsC", *however*
band(sm, -2,1) # -&gt; "dgC"

</code></pre>

<hr>
<h2 id='bandSparse'>Construct Sparse Banded Matrix from (Sup-/Super-) Diagonals</h2><span id='topic+bandSparse'></span>

<h3>Description</h3>

<p>Construct a sparse banded matrix by specifying its non-zero sup- and
super-diagonals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandSparse(n, m = n, k, diagonals, symmetric = FALSE,
           repr = "C", giveCsparse = (repr == "C"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandSparse_+3A_n">n</code>, <code id="bandSparse_+3A_m">m</code></td>
<td>
<p>the matrix dimension <code class="reqn">(n,m) = (nrow, ncol)</code>.</p>
</td></tr>
<tr><td><code id="bandSparse_+3A_k">k</code></td>
<td>
<p>integer vector of &ldquo;diagonal numbers&rdquo;, with identical
meaning as in <code><a href="#topic+band">band</a>(*, k)</code>, i.e., relative to the main diagonal,
which is <code>k=0</code>.</p>
</td></tr>
<tr><td><code id="bandSparse_+3A_diagonals">diagonals</code></td>
<td>
<p>optional list of sub-/super- diagonals; if missing,
the result will be a patter<b>n</b> matrix, i.e., inheriting from
class <code><a href="#topic+nMatrix-class">nMatrix</a></code>.
</p>
<p><code>diagonals</code> can also be <code class="reqn">n' \times d</code> matrix, where
<code>d &lt;- length(k)</code> and <code class="reqn">n' &gt;= min(n,m)</code>.  In that case,
the sub-/super- diagonals are taken from the columns of
<code>diagonals</code>, where only the first several rows will be used
(typically) for off-diagonals.
</p>
</td></tr>
<tr><td><code id="bandSparse_+3A_symmetric">symmetric</code></td>
<td>
<p>logical; if true the result will be symmetric
(inheriting from class <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>) and
only the upper or lower triangle must be specified (via <code>k</code> and
<code>diagonals</code>).</p>
</td></tr>
<tr><td><code id="bandSparse_+3A_repr">repr</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string, one of <code>"C"</code>,
<code>"T"</code>, or <code>"R"</code>, specifying the sparse <em>repr</em>esentation to
be used for the result, i.e., one from the super classes
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, or
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="bandSparse_+3A_givecsparse">giveCsparse</code></td>
<td>
<p>(<b>deprecated</b>, replaced with <code>repr</code>):
logical indicating if the result should be a
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> or a
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, where the default was <code>TRUE</code>,
and now is determined from <code>repr</code>; very often Csparse matrices are
more efficient subsequently, but not always.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sparse matrix (of <code><a href="base.html#topic+class">class</a></code>
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>) of dimension <code class="reqn">n \times m</code>
with diagonal &ldquo;bands&rdquo; as specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+band">band</a></code>, for <em>extraction</em> of matrix bands;
<code><a href="#topic+bdiag">bdiag</a></code>, <code><a href="base.html#topic+diag">diag</a></code>,
<code><a href="#topic+sparseMatrix">sparseMatrix</a></code>,
<code><a href="#topic+Matrix">Matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
diags &lt;- list(1:30, 10*(1:20), 100*(1:20))
s1 &lt;- bandSparse(13, k = -c(0:2, 6), diag = c(diags, diags[2]), symm=TRUE)
s1
s2 &lt;- bandSparse(13, k =  c(0:2, 6), diag = c(diags, diags[2]), symm=TRUE)
stopifnot(identical(s1, t(s2)), is(s1,"dsCMatrix"))

## a pattern Matrix of *full* (sub-)diagonals:
bk &lt;- c(0:4, 7,9)
(s3 &lt;- bandSparse(30, k = bk, symm = TRUE))

## If you want a pattern matrix, but with "sparse"-diagonals,
## you currently need to go via logical sparse:
lLis &lt;- lapply(list(rpois(20, 2), rpois(20, 1), rpois(20, 3))[c(1:3, 2:3, 3:2)],
               as.logical)
(s4 &lt;- bandSparse(20, k = bk, symm = TRUE, diag = lLis))
(s4. &lt;- as(drop0(s4), "nsparseMatrix"))

n &lt;- 1e4
bk &lt;- c(0:5, 7,11)
bMat &lt;- matrix(1:8, n, 8, byrow=TRUE)
bLis &lt;- as.data.frame(bMat)
B  &lt;- bandSparse(n, k = bk, diag = bLis)
Bs &lt;- bandSparse(n, k = bk, diag = bLis, symmetric=TRUE)
B [1:15, 1:30]
Bs[1:15, 1:30]
## can use a list *or* a matrix for specifying the diagonals:
stopifnot(identical(B,  bandSparse(n, k = bk, diag = bMat)),
	  identical(Bs, bandSparse(n, k = bk, diag = bMat, symmetric=TRUE))
          , inherits(B, "dtCMatrix") # triangular!
)
</code></pre>

<hr>
<h2 id='bdiag'>Construct a Block Diagonal Matrix</h2><span id='topic+bdiag'></span><span id='topic+.bdiag'></span>

<h3>Description</h3>

<p>Build a block diagonal matrix given several building block matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag(...)
.bdiag(lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiag_+3A_...">...</code></td>
<td>
<p>individual matrices or a <code><a href="base.html#topic+list">list</a></code> of matrices.</p>
</td></tr>
<tr><td><code id="bdiag_+3A_lst">lst</code></td>
<td>
<p>non-empty <code><a href="base.html#topic+list">list</a></code> of matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-trivial argument list, <code>bdiag()</code> calls <code>.bdiag()</code>.
The latter maybe useful to programmers.
</p>


<h3>Value</h3>

<p>A <em>sparse</em> matrix obtained by combining the arguments into a
block diagonal matrix.
</p>
<p>The value of <code>bdiag()</code> inherits from class
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, whereas
<code>.bdiag()</code> returns a <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.
</p>


<h3>Note</h3>

<p>This function has been written and is efficient for the case of
relatively few block matrices which are typically sparse themselves.
</p>
<p>It is currently <em>inefficient</em> for the case of many small dense
block matrices.
For the case of <em>many</em> dense <code class="reqn">k \times k</code> matrices,
the <code>bdiag_m()</code> function in the &lsquo;Examples&rsquo; is an order of
magnitude faster.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, built on a version posted by Berton Gunter to
R-help; earlier versions have been posted by other authors, notably
Scott Chasalow to S-news.  Doug Bates's faster implementation builds
on <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Diagonal">Diagonal</a></code> for constructing matrices of
class <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>, or <code><a href="#topic+kronecker">kronecker</a></code>
which also works for <code>"Matrix"</code> inheriting matrices.
</p>
<p><code><a href="#topic+bandSparse">bandSparse</a></code> constructs a <em>banded</em> sparse matrix from
its non-zero sub-/super - diagonals.
</p>
<p>Note that other CRAN <span class="rlang"><b>R</b></span> packages have own versions of <code>bdiag()</code>
which return traditional matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bdiag(matrix(1:4, 2), diag(3))
## combine "Matrix" class and traditional matrices:
bdiag(Diagonal(2), matrix(1:3, 3,4), diag(3:2))

mlist &lt;- list(1, 2:3, diag(x=5:3), 27, cbind(1,3:6), 100:101)
bdiag(mlist)
stopifnot(identical(bdiag(mlist), 
                    bdiag(lapply(mlist, as.matrix))))

ml &lt;- c(as(matrix((1:24)%% 11 == 0, 6,4),"nMatrix"),
        rep(list(Diagonal(2, x=TRUE)), 3))
mln &lt;- c(ml, Diagonal(x = 1:3))
stopifnot(is(bdiag(ml), "lsparseMatrix"),
          is(bdiag(mln),"dsparseMatrix") )

## random (diagonal-)block-triangular matrices:
rblockTri &lt;- function(nb, max.ni, lambda = 3) {
   .bdiag(replicate(nb, {
         n &lt;- sample.int(max.ni, 1)
         tril(Matrix(rpois(n * n, lambda = lambda), n, n)) }))
}

(T4 &lt;- rblockTri(4, 10, lambda = 1))
image(T1 &lt;- rblockTri(12, 20))


##' Fast version of Matrix :: .bdiag() -- for the case of *many*  (k x k) matrices:
##' @param lmat list(&lt;mat1&gt;, &lt;mat2&gt;, ....., &lt;mat_N&gt;)  where each mat_j is a  k x k 'matrix'
##' @return a sparse (N*k x N*k) matrix of class  \code{"\linkS4class{dgCMatrix}"}.
bdiag_m &lt;- function(lmat) {
    ## Copyright (C) 2016 Martin Maechler, ETH Zurich
    if(!length(lmat)) return(new("dgCMatrix"))
    stopifnot(is.list(lmat), is.matrix(lmat[[1]]),
              (k &lt;- (d &lt;- dim(lmat[[1]]))[1]) == d[2], # k x k
              all(vapply(lmat, dim, integer(2)) == k)) # all of them
    N &lt;- length(lmat)
    if(N * k &gt; .Machine$integer.max)
        stop("resulting matrix too large; would be  M x M, with M=", N*k)
    M &lt;- as.integer(N * k)
    ## result: an   M x M  matrix
    new("dgCMatrix", Dim = c(M,M),
        ## 'i :' maybe there's a faster way (w/o matrix indexing), but elegant?
        i = as.vector(matrix(0L:(M-1L), nrow=k)[, rep(seq_len(N), each=k)]),
        p = k * 0L:M,
        x = as.double(unlist(lmat, recursive=FALSE, use.names=FALSE)))
}

l12 &lt;- replicate(12, matrix(rpois(16, lambda = 6.4), 4, 4),
                 simplify=FALSE)
dim(T12 &lt;- bdiag_m(l12))# 48 x 48
T12[1:20, 1:20]
</code></pre>

<hr>
<h2 id='boolmatmult-methods'>Boolean Arithmetic Matrix Products: <code>%&amp;%</code> and Methods</h2><span id='topic++25+26+25'></span><span id='topic++25+26+25-methods'></span><span id='topic+boolmatmult-methods'></span><span id='topic++25+26+25+2CANY+2CANY-method'></span><span id='topic++25+26+25+2CANY+2CMatrix-method'></span><span id='topic++25+26+25+2CANY+2Cmatrix-method'></span><span id='topic++25+26+25+2CANY+2CsparseVector-method'></span><span id='topic++25+26+25+2CANY+2Cvector-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CCsparseMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CMatrix+2CANY-method'></span><span id='topic++25+26+25+2CMatrix+2CindMatrix-method'></span><span id='topic++25+26+25+2CMatrix+2CpMatrix-method'></span><span id='topic++25+26+25+2CMatrix+2CsparseVector-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CRsparseMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CTsparseMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CdenseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CdenseMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CdiagonalMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CindMatrix+2CMatrix-method'></span><span id='topic++25+26+25+2CindMatrix+2CindMatrix-method'></span><span id='topic++25+26+25+2CindMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CindMatrix+2CpMatrix-method'></span><span id='topic++25+26+25+2CindMatrix+2Cvector-method'></span><span id='topic++25+26+25+2Cmatrix+2CANY-method'></span><span id='topic++25+26+25+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CdenseMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CindMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CpMatrix-method'></span><span id='topic++25+26+25+2Cmatrix+2CsparseVector-method'></span><span id='topic++25+26+25+2Cmatrix+2Cvector-method'></span><span id='topic++25+26+25+2CpMatrix+2CMatrix-method'></span><span id='topic++25+26+25+2CpMatrix+2CindMatrix-method'></span><span id='topic++25+26+25+2CpMatrix+2Cmatrix-method'></span><span id='topic++25+26+25+2CpMatrix+2CpMatrix-method'></span><span id='topic++25+26+25+2CpMatrix+2Cvector-method'></span><span id='topic++25+26+25+2CsparseVector+2CANY-method'></span><span id='topic++25+26+25+2CsparseVector+2CMatrix-method'></span><span id='topic++25+26+25+2CsparseVector+2Cmatrix-method'></span><span id='topic++25+26+25+2CsparseVector+2CsparseVector-method'></span><span id='topic++25+26+25+2CsparseVector+2Cvector-method'></span><span id='topic++25+26+25+2Cvector+2CANY-method'></span><span id='topic++25+26+25+2Cvector+2CCsparseMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CRsparseMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CTsparseMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CdenseMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CdiagonalMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CindMatrix-method'></span><span id='topic++25+26+25+2Cvector+2Cmatrix-method'></span><span id='topic++25+26+25+2Cvector+2CpMatrix-method'></span><span id='topic++25+26+25+2Cvector+2CsparseVector-method'></span><span id='topic++25+26+25+2Cvector+2Cvector-method'></span>

<h3>Description</h3>

<p>For boolean or &ldquo;patter<b>n</b>&rdquo; matrices, i.e., <span class="rlang"><b>R</b></span> objects of
class <code><a href="#topic+nMatrix-class">nMatrix</a></code>, it is natural to allow matrix
products using boolean instead of numerical arithmetic.
</p>
<p>In package <span class="pkg">Matrix</span>, we use the binary operator <code>%&amp;%</code> (aka
&ldquo;infix&rdquo;) function) for this and provide methods for all our
matrices and the traditional <span class="rlang"><b>R</b></span> matrices (see <code><a href="base.html#topic+matrix">matrix</a></code>).
</p>


<h3>Value</h3>

<p>a pattern matrix, i.e., inheriting from <code>"<a href="#topic+nMatrix-class">nMatrix</a>"</code>,
or an <code>"<a href="#topic+ldiMatrix-class">ldiMatrix</a>"</code> in case of a diagonal matrix.
</p>


<h3>Methods</h3>

<p>We provide methods for both the &ldquo;traditional&rdquo; (<span class="rlang"><b>R</b></span> base) matrices
and numeric vectors and conceptually all matrices and
<code><a href="#topic+sparseVector-class">sparseVector</a></code>s in package <span class="pkg">Matrix</span>.
</p>

<dl>
<dt><code>signature(x = "ANY", y = "ANY")</code></dt><dd> </dd>
<dt><code>signature(x = "ANY", y = "Matrix")</code></dt><dd> </dd>
<dt><code>signature(x = "Matrix", y = "ANY")</code></dt><dd> </dd>
<dt><code>signature(x = "nMatrix", y = "nMatrix")</code></dt><dd> </dd>
<dt><code>signature(x = "nMatrix", y = "nsparseMatrix")</code></dt><dd> </dd>
<dt><code>signature(x = "nsparseMatrix", y = "nMatrix")</code></dt><dd> </dd>
<dt><code>signature(x = "nsparseMatrix", y = "nsparseMatrix")</code></dt><dd> </dd>
<dt><code>signature(x = "sparseVector", y = "sparseVector")</code></dt><dd> </dd>
</dl>



<h3>Note</h3>

<p>These boolean arithmetic matrix products had been newly
introduced for <span class="pkg">Matrix</span> 1.2.0 (March 2015).  Its implementation
has still not been tested extensively.
</p>
<p>Originally, it was left unspecified how non-structural zeros, i.e., <code>0</code>'s
as part of the <code>M@x</code> slot should be treated for numeric
(<code>"<a href="#topic+dMatrix-class">dMatrix</a>"</code>) and logical (<code>"<a href="#topic+lMatrix-class">lMatrix</a>"</code>)
sparse matrices.  We now specify that boolean matrix products should behave as if
applied to <code><a href="#topic+drop0">drop0</a>(M)</code>, i.e., as if dropping such zeros from
the matrix before using it.
<br />
Equivalently, for all matrices <code>M</code>, boolean arithmetic should work as if
applied to <code>M != 0</code> (or <code>M != FALSE</code>).
</p>
<p>The current implementation ends up coercing both <code>x</code> and <code>y</code> to
(virtual) class <code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code> which may be quite inefficient
for dense matrices.  A future implementation may well return a matrix
with <b>different</b> class, but the &ldquo;same&rdquo; content, i.e., the
same matrix entries <code class="reqn">m_ij</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25+2A+25">%*%</a></code>, <code>crossprod()</code>, or <code><a href="#topic+tcrossprod">tcrossprod</a>()</code>,
for (regular) matrix product methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(7)
L &lt;- Matrix(rnorm(20) &gt; 1,    4,5)
(N &lt;- as(L, "nMatrix"))
L. &lt;- L; L.[1:2,1] &lt;- TRUE; L.@x[1:2] &lt;- FALSE; L. # has "zeros" to drop0()
D &lt;- Matrix(round(rnorm(30)), 5,6) # -&gt; values in -1:1 (for this seed)
L %&amp;% D
stopifnot(identical(L %&amp;% D, N %&amp;% D),
          all(L %&amp;% D == as((L %*% abs(D)) &gt; 0, "sparseMatrix")))

## cross products , possibly with  boolArith = TRUE :
crossprod(N)     # -&gt; sparse patter'n' (TRUE/FALSE : boolean arithmetic)
crossprod(N  +0) # -&gt; numeric Matrix (with same "pattern")
stopifnot(all(crossprod(N) == t(N) %&amp;% N),
          identical(crossprod(N), crossprod(N +0, boolArith=TRUE)),
          identical(crossprod(L), crossprod(N   , boolArith=FALSE)))
crossprod(D, boolArith =  TRUE) # pattern: "nsCMatrix"
crossprod(L, boolArith =  TRUE) #  ditto
crossprod(L, boolArith = FALSE) # numeric: "dsCMatrix"
</code></pre>

<hr>
<h2 id='BunchKaufman-class'>Dense Bunch-Kaufman Factorizations</h2><span id='topic+BunchKaufman-class'></span><span id='topic+pBunchKaufman-class'></span><span id='topic+coerce+2CBunchKaufman+2CdtrMatrix-method'></span><span id='topic+coerce+2CpBunchKaufman+2CdtpMatrix-method'></span><span id='topic+determinant+2CBunchKaufman+2Clogical-method'></span><span id='topic+determinant+2CpBunchKaufman+2Clogical-method'></span>

<h3>Description</h3>

<p>Classes <code>BunchKaufman</code> and <code>pBunchKaufman</code> represent
Bunch-Kaufman factorizations of <code class="reqn">n \times n</code> real,
symmetric matrices <code class="reqn">A</code>, having the general form
</p>
<p style="text-align: center;"><code class="reqn">A = U D_{U} U' = L D_{L} L'</code>
</p>

<p>where
<code class="reqn">D_{U}</code> and <code class="reqn">D_{L}</code> are symmetric, block diagonal
matrices composed of <code class="reqn">b_{U}</code> and <code class="reqn">b_{L}</code>
<code class="reqn">1 \times 1</code> or <code class="reqn">2 \times 2</code> diagonal blocks;
<code class="reqn">U = \prod_{k = 1}^{b_{U}} P_{k} U_{k}</code>
is the product of <code class="reqn">b_{U}</code> row-permuted unit upper triangular
matrices, each having nonzero entries above the diagonal in 1 or 2 columns;
and
<code class="reqn">L = \prod_{k = 1}^{b_{L}} P_{k} L_{k}</code>
is the product of <code class="reqn">b_{L}</code> row-permuted unit lower triangular
matrices, each having nonzero entries below the diagonal in 1 or 2 columns.
</p>
<p>These classes store the nonzero entries of the
<code class="reqn">2 b_{U} + 1</code> or <code class="reqn">2 b_{L} + 1</code> factors,
which are individually sparse,
in a dense format as a vector of length
<code class="reqn">nn</code> (<code>BunchKaufman</code>) or
<code class="reqn">n(n+1)/2</code> (<code>pBunchKaufman</code>),
the latter giving the &ldquo;packed&rdquo; representation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>uplo</code></dt><dd><p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle (upper or lower) of the factorized
symmetric matrix was used to compute the factorization and
in turn how the <code>x</code> slot is partitioned.</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector of length <code>n*n</code>
(<code>BunchKaufman</code>) or <code>n*(n+1)/2</code> (<code>pBunchKaufman</code>),
where <code>n=Dim[1]</code>.
The details of the representation are specified by the manual
for LAPACK routines <code>dsytrf</code> and <code>dsptrf</code>.</p>
</dd>
<dt><code>perm</code></dt><dd><p>an integer vector of length <code>n=Dim[1]</code>
specifying row and column interchanges as described in the manual
for LAPACK routines <code>dsytrf</code> and <code>dsptrf</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+BunchKaufmanFactorization-class">BunchKaufmanFactorization</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+BunchKaufmanFactorization-class">BunchKaufmanFactorization</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("BunchKaufman", ...)</code> or <code>new("pBunchKaufman", ...)</code>,
but they are more typically obtained as the value of
<code><a href="#topic+BunchKaufman">BunchKaufman</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> or <code><a href="#topic+dspMatrix-class">dspMatrix</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "BunchKaufman", to = "dtrMatrix")</code>:
returns a <code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code>, useful for inspecting
the internal representation of the factorization; see &lsquo;Note&rsquo;.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "pBunchKaufman", to = "dtpMatrix")</code>:
returns a <code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code>, useful for inspecting
the internal representation of the factorization; see &lsquo;Note&rsquo;.</p>
</dd>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "p?BunchKaufman", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "p?BunchKaufman")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "p?BunchKaufman")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "p?BunchKaufman", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>In <span class="pkg">Matrix</span> <code>&lt; 1.6-0</code>, class <code>BunchKaufman</code> extended
<code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code> and class <code>pBunchKaufman</code> extended
<code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code>, reflecting the fact that the internal
representation of the factorization is fundamentally triangular:
there are <code class="reqn">n(n+1)/2</code> &ldquo;parameters&rdquo;, and these
can be arranged systematically to form an <code class="reqn">n \times n</code>
triangular matrix.
<span class="pkg">Matrix</span> <code>1.6-0</code> removed these extensions so that methods
would no longer be inherited from <code>dtrMatrix</code> and <code>dtpMatrix</code>.  
The availability of such methods gave the wrong impression that
<code>BunchKaufman</code> and <code>pBunchKaufman</code> represent a (singular)
matrix, when in fact they represent an ordered set of matrix factors.
</p>
<p>The coercions <code>as(., "dtrMatrix")</code> and <code>as(., "dtpMatrix")</code>
are provided for users who understand the caveats.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dsytrf.f">https://netlib.org/lapack/double/dsytrf.f</a> and
<a href="https://netlib.org/lapack/double/dsptrf.f">https://netlib.org/lapack/double/dsptrf.f</a>.
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> and its packed counterpart.
</p>
<p>Generic functions <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+expand1">expand1</a></code>, and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("BunchKaufman")
set.seed(1)

n &lt;- 6L
(A &lt;- forceSymmetric(Matrix(rnorm(n * n), n, n)))

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- rep.int(list(paste0("x", seq_len(n))), 2L)

(bk.A &lt;- BunchKaufman(A))
str(e.bk.A &lt;- expand2(bk.A, complete = FALSE), max.level = 2L)
str(E.bk.A &lt;- expand2(bk.A, complete =  TRUE), max.level = 2L)

## Underlying LAPACK representation
(m.bk.A &lt;- as(bk.A, "dtrMatrix"))
stopifnot(identical(as(m.bk.A, "matrix"), `dim&lt;-`(bk.A@x, bk.A@Dim)))

## Number of factors is 2*b+1, b &lt;= n, which can be nontrivial ...
(b &lt;- (length(E.bk.A) - 1L) %/% 2L)

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ U DU U', U := prod(Pk Uk) in floating point
stopifnot(exprs = {
    identical(names(e.bk.A), c("U", "DU", "U."))
    identical(e.bk.A[["U" ]], Reduce(`%*%`, E.bk.A[seq_len(b)]))
    identical(e.bk.A[["U."]], t(e.bk.A[["U"]]))
    ae1(A, with(e.bk.A, U %*% DU %*% U.))
})

## Factorization handled as factorized matrix
b &lt;- rnorm(n)
stopifnot(identical(det(A), det(bk.A)),
          identical(solve(A, b), solve(bk.A, b)))
</code></pre>

<hr>
<h2 id='BunchKaufman-methods'>Methods for Bunch-Kaufman Factorization</h2><span id='topic+BunchKaufman'></span><span id='topic+BunchKaufman-methods'></span><span id='topic+BunchKaufman+2CdspMatrix-method'></span><span id='topic+BunchKaufman+2CdsyMatrix-method'></span><span id='topic+BunchKaufman+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Computes the Bunch-Kaufman factorization of an <code class="reqn">n \times n</code>
real, symmetric matrix <code class="reqn">A</code>, which has the general form
</p>
<p style="text-align: center;"><code class="reqn">A = U D_{U} U' = L D_{L} L'</code>
</p>

<p>where
<code class="reqn">D_{U}</code> and <code class="reqn">D_{L}</code> are symmetric, block diagonal
matrices composed of <code class="reqn">b_{U}</code> and <code class="reqn">b_{L}</code>
<code class="reqn">1 \times 1</code> or <code class="reqn">2 \times 2</code> diagonal blocks;
<code class="reqn">U = \prod_{k = 1}^{b_{U}} P_{k} U_{k}</code>
is the product of <code class="reqn">b_{U}</code> row-permuted unit upper triangular
matrices, each having nonzero entries above the diagonal in 1 or 2 columns;
and
<code class="reqn">L = \prod_{k = 1}^{b_{L}} P_{k} L_{k}</code>
is the product of <code class="reqn">b_{L}</code> row-permuted unit lower triangular
matrices, each having nonzero entries below the diagonal in 1 or 2 columns.
</p>
<p>Methods are built on LAPACK routines <code>dsytrf</code> and <code>dsptrf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BunchKaufman(x, ...)
## S4 method for signature 'dsyMatrix'
BunchKaufman(x, warnSing = TRUE, ...)
## S4 method for signature 'dspMatrix'
BunchKaufman(x, warnSing = TRUE, ...)
## S4 method for signature 'matrix'
BunchKaufman(x, uplo = "U", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BunchKaufman-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> symmetric matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> to be factorized.
If <code>x</code> is square but not symmetric, then it will be
<em>treated</em> as symmetric; see <code>uplo</code>.</p>
</td></tr>
<tr><td><code id="BunchKaufman-methods_+3A_warnsing">warnSing</code></td>
<td>
<p>a logical indicating if a <a href="base.html#topic+warning">warning</a> should
be signaled for singular <code>x</code>.</p>
</td></tr>
<tr><td><code id="BunchKaufman-methods_+3A_uplo">uplo</code></td>
<td>
<p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle of <code>x</code> should be used
to compute the factorization.</p>
</td></tr>
<tr><td><code id="BunchKaufman-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the factorization, inheriting from
virtual class <code><a href="#topic+BunchKaufmanFactorization-class">BunchKaufmanFactorization</a></code>.
The specific class is <code><a href="#topic+BunchKaufman-class">BunchKaufman</a></code> unless
<code>x</code> inherits from virtual class <code><a href="#topic+packedMatrix-class">packedMatrix</a></code>,
in which case it is <code><a href="#topic+pBunchKaufman-class">pBunchKaufman</a></code>.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dsytrf.f">https://netlib.org/lapack/double/dsytrf.f</a> and
<a href="https://netlib.org/lapack/double/dsptrf.f">https://netlib.org/lapack/double/dsptrf.f</a>.
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+BunchKaufman-class">BunchKaufman</a></code> and
<code><a href="#topic+pBunchKaufman-class">pBunchKaufman</a></code> and their methods.
</p>
<p>Classes <code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> and
<code><a href="#topic+dspMatrix-class">dspMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>,
for constructing matrix factors from the result.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+Schur">Schur</a></code>,
<code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code>,
for computing other factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("BunchKaufman", inherited = FALSE)
set.seed(0)

data(CAex, package = "Matrix")
class(CAex) # dgCMatrix
isSymmetric(CAex) # symmetric, but not formally

A &lt;- as(CAex, "symmetricMatrix")
class(A) # dsCMatrix

## Have methods for denseMatrix (unpacked and packed),
## but not yet sparseMatrix ...
## Not run: 
(bk.A &lt;- BunchKaufman(A))

## End(Not run)
(bk.A &lt;- BunchKaufman(as(A, "unpackedMatrix")))

## A ~ U DU U' in floating point
str(e.bk.A &lt;- expand2(bk.A), max.level = 2L)
stopifnot(all.equal(as(A, "matrix"), as(Reduce(`%*%`, e.bk.A), "matrix")))
</code></pre>

<hr>
<h2 id='CAex'>Albers' example Matrix with &quot;Difficult&quot; Eigen Factorization</h2><span id='topic+CAex'></span>

<h3>Description</h3>

<p>An example of a sparse matrix for which <code><a href="base.html#topic+eigen">eigen</a>()</code> seemed
to be difficult, an unscaled version of this has been posted to the
web, accompanying an E-mail to R-help
(<a href="https://stat.ethz.ch/mailman/listinfo/r-help">https://stat.ethz.ch/mailman/listinfo/r-help</a>), by
Casper J Albers, Open University, UK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CAex)</code></pre>


<h3>Format</h3>

<p>This is a <code class="reqn">72 \times 72</code> symmetric matrix with 216
non-zero entries in five bands, stored as sparse matrix of class
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>


<h3>Details</h3>

<p>Historical note (2006-03-30):
In earlier versions of <span class="rlang"><b>R</b></span>, <code><a href="base.html#topic+eigen">eigen</a>(CAex)</code> fell into an
infinite loop whereas <code><a href="base.html#topic+eigen">eigen</a>(CAex, EISPACK=TRUE)</code> had been okay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(CAex, package = "Matrix")
str(CAex) # of class "dgCMatrix"

image(CAex)# -&gt; it's a simple band matrix with 5 bands
## and the eigen values are basically 1 (42 times) and 0 (30 x):
zapsmall(ev &lt;- eigen(CAex, only.values=TRUE)$values)
## i.e., the matrix is symmetric, hence
sCA &lt;- as(CAex, "symmetricMatrix")
## and
stopifnot(class(sCA) == "dsCMatrix",
          as(sCA, "matrix") == as(CAex, "matrix"))
</code></pre>

<hr>
<h2 id='cbind2-methods'>'cbind()' and 'rbind()' recursively built on cbind2/rbind2</h2><span id='topic+cbind2'></span><span id='topic+cbind2-methods'></span><span id='topic+rbind2'></span><span id='topic+rbind2-methods'></span><span id='topic+cbind2+2CMatrix+2CMatrix-method'></span><span id='topic+cbind2+2CMatrix+2CNULL-method'></span><span id='topic+cbind2+2CMatrix+2Cmatrix-method'></span><span id='topic+cbind2+2CMatrix+2Cmissing-method'></span><span id='topic+cbind2+2CMatrix+2Cvector-method'></span><span id='topic+cbind2+2CNULL+2CMatrix-method'></span><span id='topic+cbind2+2Cmatrix+2CMatrix-method'></span><span id='topic+cbind2+2Cvector+2CMatrix-method'></span><span id='topic+rbind2+2CMatrix+2CMatrix-method'></span><span id='topic+rbind2+2CMatrix+2CNULL-method'></span><span id='topic+rbind2+2CMatrix+2Cmatrix-method'></span><span id='topic+rbind2+2CMatrix+2Cmissing-method'></span><span id='topic+rbind2+2CMatrix+2Cvector-method'></span><span id='topic+rbind2+2CNULL+2CMatrix-method'></span><span id='topic+rbind2+2Cmatrix+2CMatrix-method'></span><span id='topic+rbind2+2Cvector+2CMatrix-method'></span>

<h3>Description</h3>

<p>The base functions <code><a href="base.html#topic+cbind">cbind</a></code> and <code><a href="base.html#topic+rbind">rbind</a></code> are
defined for an arbitrary number of arguments and hence have the first
formal argument <code>...</code>.  Now, when S4 objects are found among the arguments,
base <code>cbind()</code> and <code>rbind()</code> internally &ldquo;dispatch&rdquo;
<em>recursively</em>, calling <code><a href="#topic+cbind2">cbind2</a></code> or <code><a href="#topic+rbind2">rbind2</a></code>
respectively, where these have methods defined and so should dispatch
appropriately.
</p>
<p><code><a href="#topic+cbind2">cbind2</a>()</code> and <code><a href="#topic+rbind2">rbind2</a>()</code> are from the
<span class="pkg">methods</span> package, i.e., standard <span class="rlang"><b>R</b></span>, and have been provided for
binding together <em>two</em> matrices, where in <span class="pkg">Matrix</span>, we have
defined methods for these and the <code>'Matrix'</code> matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## cbind(..., deparse.level = 1)
## rbind(..., deparse.level = 1)

## S4 method for signature 'Matrix,Matrix'
cbind2(x, y, ...)
## S4 method for signature 'Matrix,Matrix'
rbind2(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind2-methods_+3A_...">...</code></td>
<td>
<p>for <code>[cr]bind</code>, vector- or matrix-like <span class="rlang"><b>R</b></span> objects
to be bound together; for <code>[cr]bind2</code>, further arguments
passed to or from methods; see <code><a href="base.html#topic+cbind">cbind</a></code> and
<code><a href="methods.html#topic+cbind2">cbind2</a></code>.</p>
</td></tr>
<tr><td><code id="cbind2-methods_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer controlling the construction of labels
in the case of non-matrix-like arguments; see <code><a href="base.html#topic+cbind">cbind</a></code>.</p>
</td></tr>
<tr><td><code id="cbind2-methods_+3A_x">x</code>, <code id="cbind2-methods_+3A_y">y</code></td>
<td>
<p>vector- or matrix-like <span class="rlang"><b>R</b></span> objects to be bound together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>typically a &lsquo;matrix-like&rsquo; object of a similar
<code><a href="base.html#topic+class">class</a></code> as the first argument in <code>...</code>.
</p>
<p>Note that sometimes by default, the result is a
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> if one of the arguments is (even in
the case where this is not efficient).  In other cases,
the result is chosen to be sparse when there are more zero entries is
than non-zero ones (as the default <code>sparse</code> in
<code><a href="#topic+Matrix">Matrix</a>()</code>).
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="methods.html#topic+cbind2">cbind2</a></code>.
</p>
<p>Our class definition help pages mentioning <code>cbind2()</code> and
<code>rbind2()</code> methods:
<code>"<a href="#topic+denseMatrix-class">denseMatrix</a>"</code>,
<code>"<a href="#topic+diagonalMatrix-class">diagonalMatrix</a>"</code>,
<code>"<a href="#topic+indMatrix-class">indMatrix</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- matrix(c(2:1,1:2), 2,2))

(M1 &lt;- cbind(0, rbind(a, 7))) # a traditional matrix

D &lt;- Diagonal(2)
(M2 &lt;- cbind(4, a, D, -1, D, 0)) # a sparse Matrix

stopifnot(validObject(M2), inherits(M2, "sparseMatrix"),
          dim(M2) == c(2,9))
</code></pre>

<hr>
<h2 id='CHMfactor-class'>Sparse Cholesky Factorizations</h2><span id='topic+CHMfactor-class'></span><span id='topic+CHMsimpl-class'></span><span id='topic+CHMsuper-class'></span><span id='topic+dCHMsimpl-class'></span><span id='topic+dCHMsuper-class'></span><span id='topic+nCHMsimpl-class'></span><span id='topic+nCHMsuper-class'></span><span id='topic+coerce+2CCHMsimpl+2CdtCMatrix-method'></span><span id='topic+coerce+2CCHMsuper+2CdgCMatrix-method'></span><span id='topic+determinant+2CCHMfactor+2Clogical-method'></span><span id='topic+diag+2CCHMfactor-method'></span><span id='topic+update+2CCHMfactor-method'></span><span id='topic+isLDL'></span>

<h3>Description</h3>

<p><code>CHMfactor</code> is the virtual class of sparse Cholesky
factorizations of <code class="reqn">n \times n</code> real, symmetric
matrices <code class="reqn">A</code>, having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_1 A P_1' = L_1 D L_1' \overset{D_{jj} \ge 0}{=} L L'</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_1' L_1 D L_1' P_1 \overset{D_{jj} \ge 0}{=} P_1' L L' P_1</code>
</p>

<p>where
<code class="reqn">P_1</code> is a permutation matrix,
<code class="reqn">L_1</code> is a unit lower triangular matrix,
<code class="reqn">D</code> is a diagonal matrix, and
<code class="reqn">L = L_1 \sqrt{D}</code>.
The second equalities hold only for positive semidefinite <code class="reqn">A</code>,
for which the diagonal entries of <code class="reqn">D</code> are non-negative
and <code class="reqn">\sqrt{D}</code> is well-defined.
</p>
<p>The implementation of class <code>CHMfactor</code> is based on
CHOLMOD's C-level <code>cholmod_factor_struct</code>.  Virtual
subclasses <code>CHMsimpl</code> and <code>CHMsuper</code> separate
the simplicial and supernodal variants.  These have nonvirtual
subclasses <code>[dn]CHMsimpl</code> and <code>[dn]CHMsuper</code>,
where prefix &lsquo;<span class="samp">&#8288;d&#8288;</span>&rsquo; and prefix &lsquo;<span class="samp">&#8288;n&#8288;</span>&rsquo; are reserved
for numeric and symbolic factorizations, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isLDL(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CHMfactor-class_+3A_x">x</code></td>
<td>
<p>an object inheriting from virtual class <code>CHMfactor</code>,
almost always the result of a call to generic function
<code><a href="#topic+Cholesky">Cholesky</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>isLDL(x)</code> returns <code>TRUE</code> or <code>FALSE</code>:
<code>TRUE</code> if <code>x</code> stores the lower triangular entries
of <code class="reqn">L_1-I+D</code>,
<code>FALSE</code> if <code>x</code> stores the lower triangular entries
of <code class="reqn">L</code>.
</p>


<h3>Slots</h3>

<p>Of <code>CHMfactor</code>:
</p>

<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>colcount</code></dt><dd><p>an integer vector of length <code>Dim[1]</code>
giving an <em>estimate</em> of the number of nonzero entries in
each column of the lower triangular Cholesky factor.
If symbolic analysis was performed prior to factorization,
then the estimate is exact.</p>
</dd>
<dt><code>perm</code></dt><dd><p>a 0-based integer vector of length <code>Dim[1]</code>
specifying the permutation applied to the rows and columns
of the factorized matrix.  <code>perm</code> of length 0 is valid and
equivalent to the identity permutation, implying no pivoting.</p>
</dd>
<dt><code>type</code></dt><dd><p>an integer vector of length 6 specifying
details of the factorization.  The elements correspond to
members <code>ordering</code>, <code>is_ll</code>, <code>is_super</code>,
<code>is_monotonic</code>, <code>maxcsize</code>, and <code>maxesize</code>
of the original <code>cholmod_factor_struct</code>.
Simplicial and supernodal factorizations are distinguished
by <code>is_super</code>.  Simplicial factorizations do not use
<code>maxcsize</code> or <code>maxesize</code>.  Supernodal factorizations
do not use <code>is_ll</code> or <code>is_monotonic</code>.</p>
</dd>
</dl>

<p>Of <code>CHMsimpl</code> (all unused by <code>nCHMsimpl</code>): 
</p>

<dl>
<dt><code>nz</code></dt><dd><p>an integer vector of length <code>Dim[1]</code>
giving the number of nonzero entries in each column of the
lower triangular Cholesky factor.  There is at least one
nonzero entry in each column, because the diagonal elements
of the factor are stored explicitly.</p>
</dd>
<dt><code>p</code></dt><dd><p>an integer vector of length <code>Dim[1]+1</code>.
Row indices of nonzero entries in column <code>j</code> of the
lower triangular Cholesky factor are obtained as
<code>i[p[j]+seq_len(nz[j])]+1</code>.</p>
</dd>
<dt><code>i</code></dt><dd><p>an integer vector of length greater than or equal
to <code>sum(nz)</code> containing the row indices of nonzero entries
in the lower triangular Cholesky factor.  These are grouped by
column and sorted within columns, but the columns themselves
need not be ordered monotonically.  Columns may be overallocated,
i.e., the number of elements of <code>i</code> reserved for column
<code>j</code> may exceed <code>nz[j]</code>.</p>
</dd>
<dt><code>prv</code>, <code>nxt</code></dt><dd><p>integer vectors of length
<code>Dim[1]+2</code> indicating the order in which the columns of
the lower triangular Cholesky factor are stored in <code>i</code>
and <code>x</code>.
Starting from <code>j &lt;- Dim[1]+2</code>,
the recursion <code>j &lt;- nxt[j+1]+1</code> traverses the columns
in  forward order and terminates when <code>nxt[j+1] = -1</code>.
Starting from <code>j &lt;- Dim[1]+1</code>,
the recursion <code>j &lt;- prv[j+1]+1</code> traverses the columns
in backward order and terminates when <code>prv[j+1] = -1</code>.</p>
</dd>
</dl>

<p>Of <code>dCHMsimpl</code>:
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector parallel to <code>i</code> containing
the corresponding nonzero entries of the lower triangular
Cholesky factor <code class="reqn">L</code> <em>or</em> (if and only if <code>type[2]</code>
is 0) of the lower triangular matrix <code class="reqn">L_1-I+D</code>.</p>
</dd>
</dl>

<p>Of <code>CHMsuper</code>:
</p>

<dl>
<dt><code>super</code>, <code>pi</code>, <code>px</code></dt><dd><p>integer vectors of
length <code>nsuper+1</code>, where <code>nsuper</code> is the number of
supernodes.  <code>super[j]+1</code> is the index of the leftmost
column of supernode <code>j</code>.  The row indices of supernode
<code>j</code> are obtained as <code>s[pi[j]+seq_len(pi[j+1]-pi[j])]+1</code>.
The numeric entries of supernode <code>j</code> are obtained as
<code>x[px[j]+seq_len(px[j+1]-px[j])]+1</code> (if slot <code>x</code>
is available).</p>
</dd>
<dt><code>s</code></dt><dd><p>an integer vector of length greater than or equal
to <code>Dim[1]</code> containing the row indices of the supernodes.
<code>s</code> may contain duplicates, but not within a supernode,
where the row indices must be increasing.</p>
</dd>
</dl>

<p>Of <code>dCHMsuper</code>:
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector of length less than or equal to
<code>prod(Dim)</code> containing the numeric entries of the supernodes.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, directly.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("dCHMsimpl", ...)</code>, etc., but <code>dCHMsimpl</code> and
<code>dCHMsuper</code> are more typically obtained as the value of
<code><a href="#topic+Cholesky">Cholesky</a>(x, ...)</code> for <code>x</code> inheriting from
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>
(often <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>).
</p>
<p>There is currently no API outside of calls to <code><a href="methods.html#topic+new">new</a></code>
for generating <code>nCHMsimpl</code> and <code>nCHMsuper</code>.  These
classes are vestigial and may be formally deprecated in a future
version of <span class="pkg">Matrix</span>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "CHMsimpl", to = "dtCMatrix")</code>:
returns a <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code> representing
the lower triangular Cholesky factor <code class="reqn">L</code> <em>or</em>
the lower triangular matrix <code class="reqn">L_1-I+D</code>,
the latter if and only if <code>from@type[2]</code> is 0.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "CHMsuper", to = "dgCMatrix")</code>:
returns a <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> representing
the lower triangular Cholesky factor <code class="reqn">L</code>.  Note that,
for supernodes spanning two or more columns, the supernodal
algorithm by design stores non-structural zeros above
the main diagonal, hence <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> is
indeed more appropriate than <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>
as a coercion target.</p>
</dd>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "CHMfactor", logarithm = "logical")</code>:
behaves according to an optional argument <code>sqrt</code>.
If <code>sqrt = FALSE</code>, then this method computes the determinant
of the factorized matrix <code class="reqn">A</code> or its logarithm.
If <code>sqrt = TRUE</code>, then this method computes the determinant
of the factor <code class="reqn">L = L_1 sqrt(D)</code> or
its logarithm, giving <code>NaN</code> for the modulus when <code class="reqn">D</code>
has negative diagonal elements.  For backwards compatibility,
the default value of <code>sqrt</code> is <code>TRUE</code>, but that can
be expected change in a future version of <span class="pkg">Matrix</span>, hence
defensive code will always set <code>sqrt</code> (to <code>TRUE</code>,
if the code must remain backwards compatible with <span class="pkg">Matrix</span>
<code>&lt; 1.6-0</code>).  Calls to this method not setting <code>sqrt</code>
may warn about the pending change.  The warnings can be disabled
with <code><a href="base.html#topic+options">options</a>(Matrix.warnSqrtDefault = 0)</code>.</p>
</dd>
<dt><code>diag</code></dt><dd><p><code>signature(x = "CHMfactor")</code>:
returns a numeric vector of length <code class="reqn">n</code> containing the diagonal
elements of <code class="reqn">D</code>, which (<em>if</em> they are all non-negative)
are the squared diagonal elements of <code class="reqn">L</code>.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "CHMfactor")</code>:
see <code><a href="#topic+expand-methods">expand-methods</a></code>.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "CHMsimpl")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "CHMsuper")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "CHMsimpl")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "CHMsuper")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>image</code></dt><dd><p><code>signature(x = "CHMfactor")</code>:
see <code><a href="#topic+image-methods">image-methods</a></code>.</p>
</dd>
<dt><code>nnzero</code></dt><dd><p><code>signature(x = "CHMfactor")</code>:
see <code><a href="#topic+nnzero-methods">nnzero-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "CHMfactor", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt><code>update</code></dt><dd><p><code>signature(object = "CHMfactor")</code>:
returns a copy of <code>object</code> with the same nonzero pattern
but with numeric entries updated according to additional
arguments <code>parent</code> and <code>mult</code>, where <code>parent</code>
is (coercible to) a <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code> or a
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> and <code>mult</code> is a numeric
vector of positive length.
<br />
The numeric entries are updated with those of the Cholesky
factor of <code>F(parent) + mult[1] * I</code>, i.e.,
<code>F(parent)</code> plus <code>mult[1]</code> times the identity matrix,
where <code>F = <a href="base.html#topic+identity">identity</a></code> for symmetric <code>parent</code>
and <code>F = <a href="#topic+tcrossprod">tcrossprod</a></code> for other <code>parent</code>.
The nonzero pattern of <code>F(parent)</code> must match
that of <code>S</code> if <code>object = Cholesky(S, ...)</code>.</p>
</dd>
<dt><code>updown</code></dt><dd><p><code>signature(update = ., C = ., object = "CHMfactor")</code>:
see <code><a href="#topic+updown-methods">updown-methods</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>The CHOLMOD source code; see
<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">https://github.com/DrTimothyAldenDavis/SuiteSparse</a>,
notably the header file &lsquo;<span class="file">CHOLMOD/Include/cholmod.h</span>&rsquo;
defining <code>cholmod_factor_struct</code>.
</p>
<p>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008).
Algorithm 887: CHOLMOD, supernodal sparse Cholesky factorization
and update/downdate.
<em>ACM Transactions on Mathematical Software</em>,
<em>35</em>(3), Article 22, 1-14.
<a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a>
</p>
<p>Amestoy, P. R., Davis, T. A., &amp; Duff, I. S. (2004).
Algorithm 837: AMD, an approximate minimum degree ordering algorithm.
<em>ACM Transactions on Mathematical Software</em>,
<em>17</em>(4), 886-905.
<a href="https://doi.org/10.1145/1024074.1024081">doi:10.1145/1024074.1024081</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+updown">updown</a></code>,
<code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("dCHMsimpl")
showClass("dCHMsuper")
set.seed(2)

m &lt;- 1000L
n &lt;- 200L
M &lt;- rsparsematrix(m, n, 0.01)
A &lt;- crossprod(M)

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- dn &lt;- rep.int(list(paste0("x", seq_len(n))), 2L)

(ch.A &lt;- Cholesky(A)) # pivoted, by default
str(e.ch.A &lt;- expand2(ch.A, LDL =  TRUE), max.level = 2L)
str(E.ch.A &lt;- expand2(ch.A, LDL = FALSE), max.level = 2L)

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ P1' L1 D L1' P1 ~ P1' L L' P1 in floating point
stopifnot(exprs = {
    identical(names(e.ch.A), c("P1.", "L1", "D", "L1.", "P1"))
    identical(names(E.ch.A), c("P1.", "L" ,      "L." , "P1"))
    identical(e.ch.A[["P1"]],
              new("pMatrix", Dim = c(n, n), Dimnames = c(list(NULL), dn[2L]),
                  margin = 2L, perm = invertPerm(ch.A@perm, 0L, 1L)))
    identical(e.ch.A[["P1."]], t(e.ch.A[["P1"]]))
    identical(e.ch.A[["L1."]], t(e.ch.A[["L1"]]))
    identical(E.ch.A[["L." ]], t(E.ch.A[["L" ]]))
    identical(e.ch.A[["D"]], Diagonal(x = diag(ch.A)))
    all.equal(E.ch.A[["L"]], with(e.ch.A, L1 %*% sqrt(D)))
    ae1(A, with(e.ch.A, P1. %*% L1 %*% D %*% L1. %*% P1))
    ae1(A, with(E.ch.A, P1. %*% L  %*%         L.  %*% P1))
    ae2(A[ch.A@perm + 1L, ch.A@perm + 1L], with(e.ch.A, L1 %*% D %*% L1.))
    ae2(A[ch.A@perm + 1L, ch.A@perm + 1L], with(E.ch.A, L  %*%         L. ))
})

## Factorization handled as factorized matrix
## (in some cases only optionally, depending on arguments)
b &lt;- rnorm(n)
stopifnot(identical(det(A), det(ch.A, sqrt = FALSE)),
          identical(solve(A, b), solve(ch.A, b, system = "A")))

u1 &lt;- update(ch.A,   A , mult = sqrt(2))
u2 &lt;- update(ch.A, t(M), mult = sqrt(2)) # updating with crossprod(M), not M
stopifnot(all.equal(u1, u2, tolerance = 1e-14))
</code></pre>

<hr>
<h2 id='chol-methods'>Compute the Cholesky Factor of a Matrix</h2><span id='topic+chol'></span><span id='topic+chol-methods'></span><span id='topic+chol+2CddiMatrix-method'></span><span id='topic+chol+2CdiagonalMatrix-method'></span><span id='topic+chol+2CdsCMatrix-method'></span><span id='topic+chol+2CdsRMatrix-method'></span><span id='topic+chol+2CdsTMatrix-method'></span><span id='topic+chol+2CdspMatrix-method'></span><span id='topic+chol+2CdsyMatrix-method'></span><span id='topic+chol+2CgeneralMatrix-method'></span><span id='topic+chol+2CsymmetricMatrix-method'></span><span id='topic+chol+2CtriangularMatrix-method'></span>

<h3>Description</h3>

<p>Computes the upper triangular Cholesky factor of an
<code class="reqn">n \times n</code> real, symmetric, positive semidefinite
matrix <code class="reqn">A</code>, optionally after pivoting.
That is the factor <code class="reqn">L'</code> in
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{1}' = L L'</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' L L' P_{1}</code>
</p>

<p>where
<code class="reqn">P_{1}</code> is a permutation matrix.
</p>
<p>Methods for <code><a href="#topic+denseMatrix-class">denseMatrix</a></code> are built on
LAPACK routines <code>dpstrf</code>, <code>dpotrf</code>, and <code>dpptrf</code>,
The latter two do not permute rows or columns,
so that <code class="reqn">P_{1}</code> is an identity matrix.
</p>
<p>Methods for <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> are built on
CHOLMOD routines <code>cholmod_analyze</code> and <code>cholmod_factorize_p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol(x, ...)
## S4 method for signature 'dsyMatrix'
chol(x, pivot = FALSE, tol = -1, ...)
## S4 method for signature 'dspMatrix'
chol(x, ...)
## S4 method for signature 'dsCMatrix'
chol(x, pivot = FALSE, ...)
## S4 method for signature 'ddiMatrix'
chol(x, ...)
## S4 method for signature 'generalMatrix'
chol(x, uplo = "U", ...)
## S4 method for signature 'triangularMatrix'
chol(x, uplo = "U", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a>, symmetric, positive
semidefinite matrix or <code><a href="#topic+Matrix-class">Matrix</a></code> to
be factorized.  If <code>x</code> is square but not symmetric,
then it will be <em>treated</em> as symmetric; see <code>uplo</code>.
Methods for dense <code>x</code> require positive definiteness
when <code>pivot = FALSE</code>.
Methods for sparse (but not diagonal) <code>x</code> require
positive definiteness unconditionally.</p>
</td></tr>
<tr><td><code id="chol-methods_+3A_pivot">pivot</code></td>
<td>
<p>a logical indicating if the rows and columns
of <code class="reqn">x</code> should be pivoted.  Methods for sparse <code>x</code>
employ the approximate minimum degree (AMD) algorithm
in order to reduce fill-in, i.e., without regard for
numerical stability.</p>
</td></tr>
<tr><td><code id="chol-methods_+3A_tol">tol</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> numeric tolerance,
used only if <code>pivot = TRUE</code>.
The factorization algorithm stops if the pivot is less than
or equal to <code>tol</code>.  Negative <code>tol</code> is equivalent
to <code>nrow(x) * .Machine$double.eps * max(diag(x))</code>.</p>
</td></tr>
<tr><td><code id="chol-methods_+3A_uplo">uplo</code></td>
<td>
<p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle of <code>x</code> should be used
to compute the factorization.  The default is <code>"U"</code>,
even for lower triangular <code>x</code>, to be consistent with
<code><a href="base.html#topic+chol">chol</a></code> from <span class="pkg">base</span>.</p>
</td></tr>
<tr><td><code id="chol-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>x</code> inheriting from <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>,
the diagonal result is computed directly and without pivoting,
i.e., bypassing CHOLMOD.
</p>
<p>For all other <code>x</code>, <code>chol(x, pivot = value)</code> calls
<code><a href="#topic+Cholesky">Cholesky</a>(x, perm = value, ...)</code> under the hood.
If you must know the permutation <code class="reqn">P_{1}</code> in addition
to the Cholesky factor <code class="reqn">L'</code>, then call <code><a href="#topic+Cholesky">Cholesky</a></code>
directly, as the result of <code>chol(x, pivot = TRUE)</code> specifies
<code class="reqn">L'</code> but not <code class="reqn">P_{1}</code>.
</p>


<h3>Value</h3>

<p>A matrix, <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>,
or <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code> representing
the upper triangular Cholesky factor <code class="reqn">L'</code>.
The result is a traditional matrix if <code>x</code> is a
traditional matrix, dense if <code>x</code> is dense, and
sparse if <code>x</code> is sparse.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dpstrf.f">https://netlib.org/lapack/double/dpstrf.f</a>,
<a href="https://netlib.org/lapack/double/dpotrf.f">https://netlib.org/lapack/double/dpotrf.f</a>, and
<a href="https://netlib.org/lapack/double/dpptrf.f">https://netlib.org/lapack/double/dpptrf.f</a>.
</p>
<p>The CHOLMOD source code; see
<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">https://github.com/DrTimothyAldenDavis/SuiteSparse</a>,
notably the header file &lsquo;<span class="file">CHOLMOD/Include/cholmod.h</span>&rsquo;
defining <code>cholmod_factor_struct</code>.
</p>
<p>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008).
Algorithm 887: CHOLMOD, supernodal sparse Cholesky factorization
and update/downdate.
<em>ACM Transactions on Mathematical Software</em>,
<em>35</em>(3), Article 22, 1-14.
<a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a>
</p>
<p>Amestoy, P. R., Davis, T. A., &amp; Duff, I. S. (2004).
Algorithm 837: AMD, an approximate minimum degree ordering algorithm.
<em>ACM Transactions on Mathematical Software</em>,
<em>17</em>(4), 886-905.
<a href="https://doi.org/10.1145/1024074.1024081">doi:10.1145/1024074.1024081</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>The default method from <span class="pkg">base</span>, <code><a href="base.html#topic+chol">chol</a></code>,
called for traditional matrices <code>x</code>.
</p>
<p>Generic function <code><a href="#topic+Cholesky">Cholesky</a></code>, for more flexibility
notably when computing the Cholesky <em>factorization</em> and
not only the <em>factor</em> <code class="reqn">L'</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("chol", inherited = FALSE)
set.seed(0)

## ---- Dense ----------------------------------------------------------

## chol(x, pivot = value) wrapping Cholesky(x, perm = value)
selectMethod("chol", "dsyMatrix")

## Except in packed cases where pivoting is not yet available
selectMethod("chol", "dspMatrix")

## .... Positive definite ..............................................

(A1 &lt;- new("dsyMatrix", Dim = c(2L, 2L), x = c(1, 2, 2, 5)))
(R1.nopivot &lt;- chol(A1))
(R1 &lt;- chol(A1, pivot = TRUE))

## In 2-by-2 cases, we know that the permutation is 1:2 or 2:1,
## even if in general 'chol' does not say ...

stopifnot(exprs = {
   all.equal(  A1           , as(crossprod(R1.nopivot), "dsyMatrix"))
   all.equal(t(A1[2:1, 2:1]), as(crossprod(R1        ), "dsyMatrix"))
   identical(Cholesky(A1)@perm, 2:1) # because 5 &gt; 1
})

## .... Positive semidefinite but not positive definite ................

(A2 &lt;- new("dpoMatrix", Dim = c(2L, 2L), x = c(1, 2, 2, 4)))
try(R2.nopivot &lt;- chol(A2)) # fails as not positive definite
(R2 &lt;- chol(A2, pivot = TRUE)) # returns, with a warning and ...

stopifnot(exprs = {
   all.equal(t(A2[2:1, 2:1]), as(crossprod(R2), "dsyMatrix"))
   identical(Cholesky(A2)@perm, 2:1) # because 4 &gt; 1
})

## .... Not positive semidefinite ......................................

(A3 &lt;- new("dsyMatrix", Dim = c(2L, 2L), x = c(1, 2, 2, 3)))
try(R3.nopivot &lt;- chol(A3)) # fails as not positive definite
(R3 &lt;- chol(A3, pivot = TRUE)) # returns, with a warning and ...

## _Not_ equal: see details and examples in help("Cholesky")
all.equal(t(A3[2:1, 2:1]), as(crossprod(R3), "dsyMatrix"))

## ---- Sparse ---------------------------------------------------------

## chol(x, pivot = value) wrapping
## Cholesky(x, perm = value, LDL = FALSE, super = FALSE)
selectMethod("chol", "dsCMatrix")

## Except in diagonal cases which are handled "directly"
selectMethod("chol", "ddiMatrix")

(A4 &lt;- toeplitz(as(c(10, 0, 1, 0, 3), "sparseVector")))
(ch.A4.nopivot &lt;- Cholesky(A4, perm = FALSE, LDL = FALSE, super = FALSE))
(ch.A4 &lt;- Cholesky(A4, perm = TRUE, LDL = FALSE, super = FALSE))
(R4.nopivot &lt;- chol(A4))
(R4 &lt;- chol(A4, pivot = TRUE))

det4 &lt;- det(A4)
b4 &lt;- rnorm(5L)
x4 &lt;- solve(A4, b4)

stopifnot(exprs = {
    identical(R4.nopivot, expand1(ch.A4.nopivot, "L."))
    identical(R4, expand1(ch.A4, "L."))
    all.equal(A4, crossprod(R4.nopivot))
    all.equal(A4[ch.A4@perm + 1L, ch.A4@perm + 1L], crossprod(R4))
    all.equal(diag(R4.nopivot), sqrt(diag(ch.A4.nopivot)))
    all.equal(diag(R4), sqrt(diag(ch.A4)))
    all.equal(sqrt(det4), det(R4.nopivot))
    all.equal(sqrt(det4), det(R4))
    all.equal(det4, det(ch.A4.nopivot, sqrt = FALSE))
    all.equal(det4, det(ch.A4, sqrt = FALSE))
    all.equal(x4, solve(R4.nopivot, solve(t(R4.nopivot), b4)))
    all.equal(x4, solve(ch.A4.nopivot, b4))
    all.equal(x4, solve(ch.A4, b4))
})
</code></pre>

<hr>
<h2 id='chol2inv-methods'>Inverse from Cholesky Factor</h2><span id='topic+chol2inv'></span><span id='topic+chol2inv-methods'></span><span id='topic+chol2inv+2CANY-method'></span><span id='topic+chol2inv+2CddiMatrix-method'></span><span id='topic+chol2inv+2CdiagonalMatrix-method'></span><span id='topic+chol2inv+2CdtCMatrix-method'></span><span id='topic+chol2inv+2CdtRMatrix-method'></span><span id='topic+chol2inv+2CdtTMatrix-method'></span><span id='topic+chol2inv+2CdtrMatrix-method'></span><span id='topic+chol2inv+2CdtpMatrix-method'></span><span id='topic+chol2inv+2CgeneralMatrix-method'></span><span id='topic+chol2inv+2CsymmetricMatrix-method'></span><span id='topic+chol2inv+2CtriangularMatrix-method'></span>

<h3>Description</h3>

<p>Given <em>formally</em> upper and lower triangular matrices
<code class="reqn">U</code> and <code class="reqn">L</code>, compute <code class="reqn">(U' U)^{-1}</code>
and <code class="reqn">(L L')^{-1}</code>, respectively.
</p>
<p>This function can be seen as way to compute the inverse of a
symmetric positive definite matrix given its Cholesky factor.
Equivalently, it can be seen as a way to compute
<code class="reqn">(X' X)^{-1}</code> given the <code class="reqn">R</code> part of the
QR factorization of <code class="reqn">X</code>, if <code class="reqn">R</code> is constrained to have
positive diagonal entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol2inv(x, ...)
## S4 method for signature 'dtrMatrix'
chol2inv(x, ...)
## S4 method for signature 'dtCMatrix'
chol2inv(x, ...)
## S4 method for signature 'generalMatrix'
chol2inv(x, uplo = "U", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol2inv-methods_+3A_x">x</code></td>
<td>
<p>a square matrix or <code><a href="#topic+Matrix-class">Matrix</a></code>,
typically the result of a call to <code><a href="#topic+chol">chol</a></code>.
If <code>x</code> is square but not (formally) triangular,
then only the upper or lower triangle is considered,
depending on optional argument <code>uplo</code> if <code>x</code>
is a <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</td></tr>
<tr><td><code id="chol2inv-methods_+3A_uplo">uplo</code></td>
<td>
<p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle of <code>x</code> contains the
Cholesky factor.  The default is <code>"U"</code>, to be
consistent with <code><a href="base.html#topic+chol2inv">chol2inv</a></code> from <span class="pkg">base</span>.</p>
</td></tr>
<tr><td><code id="chol2inv-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>,
or <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code> representing
the inverse of the positive definite matrix whose
Cholesky factor is <code>x</code>.
The result is a traditional matrix if <code>x</code> is a
traditional matrix, dense if <code>x</code> is dense, and
sparse if <code>x</code> is sparse.
</p>


<h3>See Also</h3>

<p>The default method from <span class="pkg">base</span>, <code><a href="base.html#topic+chol2inv">chol2inv</a></code>,
called for traditional matrices <code>x</code>.
</p>
<p>Generic function <code><a href="#topic+chol">chol</a></code>, for computing the upper
triangular Cholesky factor <code class="reqn">L'</code> of a symmetric positive
semidefinite matrix.
</p>
<p>Generic function <code><a href="#topic+solve">solve</a></code>, for solving linear systems
and (as a corollary) for computing inverses more generally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(A &lt;- Matrix(cbind(c(1, 1, 1), c(1, 2, 4), c(1, 4, 16))))
(R &lt;- chol(A))
(L &lt;- t(R))
(R2i &lt;- chol2inv(R))
(L2i &lt;- chol2inv(R))
stopifnot(exprs = {
    all.equal(R2i, tcrossprod(solve(R)))
    all.equal(L2i,  crossprod(solve(L)))
    all.equal(as(R2i %*% A, "matrix"), diag(3L)) # the identity 
    all.equal(as(L2i %*% A, "matrix"), diag(3L)) # ditto
})
</code></pre>

<hr>
<h2 id='Cholesky-class'>Dense Cholesky Factorizations</h2><span id='topic+Cholesky-class'></span><span id='topic+pCholesky-class'></span><span id='topic+coerce+2CCholesky+2CdtrMatrix-method'></span><span id='topic+coerce+2CpCholesky+2CdtpMatrix-method'></span><span id='topic+determinant+2CCholesky+2Clogical-method'></span><span id='topic+determinant+2CpCholesky+2Clogical-method'></span><span id='topic+diag+2CCholesky-method'></span><span id='topic+diag+2CpCholesky-method'></span>

<h3>Description</h3>

<p>Classes <code>Cholesky</code> and <code>pCholesky</code> represent
dense, pivoted Cholesky factorizations of <code class="reqn">n \times n</code>
real, symmetric, positive semidefinite matrices <code class="reqn">A</code>,
having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{1}' = L_{1} D L_{1}' = L L'</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' L_{1} D L_{1}' P_{1} = P_{1}' L L' P_{1}</code>
</p>

<p>where
<code class="reqn">P_{1}</code> is a permutation matrix,
<code class="reqn">L_{1}</code> is a unit lower triangular matrix,
<code class="reqn">D</code> is a non-negative diagonal matrix, and
<code class="reqn">L = L_{1} \sqrt{D}</code>.
</p>
<p>These classes store the entries of the Cholesky factor
<code class="reqn">L</code> or its transpose <code class="reqn">L'</code> in a dense format as
a vector of length <code class="reqn">nn</code> (<code>Cholesky</code>) or
<code class="reqn">n(n+1)/2</code> (<code>pCholesky</code>), the latter
giving the &ldquo;packed&rdquo; representation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>uplo</code></dt><dd><p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle (upper or lower) of the factorized
symmetric matrix was used to compute the factorization and
in turn whether <code>x</code> stores <code class="reqn">L'</code> or <code class="reqn">L</code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector of length <code>n*n</code>
(<code>Cholesky</code>) or <code>n*(n+1)/2</code> (<code>pCholesky</code>),
where <code>n=Dim[1]</code>, listing the entries of the Cholesky
factor <code class="reqn">L</code> or its transpose <code class="reqn">L'</code> in column-major
order.</p>
</dd>
<dt><code>perm</code></dt><dd><p>a 1-based integer vector of length <code>Dim[1]</code>
specifying the permutation applied to the rows and columns
of the factorized matrix.  <code>perm</code> of length 0 is valid and
equivalent to the identity permutation, implying no pivoting.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+CholeskyFactorization-class">CholeskyFactorization</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+CholeskyFactorization-class">CholeskyFactorization</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("Cholesky", ...)</code> or <code>new("pCholesky", ...)</code>,
but they are more typically obtained as the value of
<code><a href="#topic+Cholesky">Cholesky</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> or <code><a href="#topic+dspMatrix-class">dspMatrix</a></code>
(often the subclasses of those reserved for positive
semidefinite matrices, namely <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code>
and <code><a href="#topic+dppMatrix-class">dppMatrix</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "Cholesky", to = "dtrMatrix")</code>:
returns a <code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code> representing
the Cholesky factor <code class="reqn">L</code> or its transpose <code class="reqn">L'</code>;
see &lsquo;Note&rsquo;.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "pCholesky", to = "dtpMatrix")</code>:
returns a <code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code> representing
the Cholesky factor <code class="reqn">L</code> or its transpose <code class="reqn">L'</code>;
see &lsquo;Note&rsquo;.</p>
</dd>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "p?Cholesky", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>diag</code></dt><dd><p><code>signature(x = "p?Cholesky")</code>:
returns a numeric vector of length <code class="reqn">n</code> containing the diagonal
elements of <code class="reqn">D</code>, which are the squared diagonal elements of
<code class="reqn">L</code>.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "p?Cholesky")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "p?Cholesky")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "p?Cholesky", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>In <span class="pkg">Matrix</span> <code>&lt; 1.6-0</code>, class <code>Cholesky</code> extended
<code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code> and class <code>pCholesky</code> extended
<code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code>, reflecting the fact that the factor
<code class="reqn">L</code> is indeed a triangular matrix.
<span class="pkg">Matrix</span> <code>1.6-0</code> removed these extensions so that methods
would no longer be inherited from <code>dtrMatrix</code> and <code>dtpMatrix</code>.  
The availability of such methods gave the wrong impression that
<code>Cholesky</code> and <code>pCholesky</code> represent a (singular)
matrix, when in fact they represent an ordered set of matrix factors.
</p>
<p>The coercions <code>as(., "dtrMatrix")</code> and <code>as(., "dtpMatrix")</code>
are provided for users who understand the caveats.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dpstrf.f">https://netlib.org/lapack/double/dpstrf.f</a>,
<a href="https://netlib.org/lapack/double/dpotrf.f">https://netlib.org/lapack/double/dpotrf.f</a>, and
<a href="https://netlib.org/lapack/double/dpptrf.f">https://netlib.org/lapack/double/dpptrf.f</a>.
</p>
<p>Lucas, C. (2004).
<em>LAPACK-style codes for level 2 and 3 pivoted Cholesky factorizations</em>.
LAPACK Working Note, Number 161.
<a href="https://www.netlib.org/lapack/lawnspdf/lawn161.pdf">https://www.netlib.org/lapack/lawnspdf/lawn161.pdf</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+CHMfactor-class">CHMfactor</a></code> for sparse Cholesky factorizations.
</p>
<p>Classes <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code> and <code><a href="#topic+dppMatrix-class">dppMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>,
<code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("Cholesky")
set.seed(1)

m &lt;- 30L
n &lt;- 6L
(A &lt;- crossprod(Matrix(rnorm(m * n), m, n)))

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- dn &lt;- rep.int(list(paste0("x", seq_len(n))), 2L)

(ch.A &lt;- Cholesky(A)) # pivoted, by default
str(e.ch.A &lt;- expand2(ch.A, LDL =  TRUE), max.level = 2L)
str(E.ch.A &lt;- expand2(ch.A, LDL = FALSE), max.level = 2L)

## Underlying LAPACK representation
(m.ch.A &lt;- as(ch.A, "dtrMatrix")) # which is L', not L, because
A@uplo == "U"
stopifnot(identical(as(m.ch.A, "matrix"), `dim&lt;-`(ch.A@x, ch.A@Dim)))

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ P1' L1 D L1' P1 ~ P1' L L' P1 in floating point
stopifnot(exprs = {
    identical(names(e.ch.A), c("P1.", "L1", "D", "L1.", "P1"))
    identical(names(E.ch.A), c("P1.", "L" ,      "L." , "P1"))
    identical(e.ch.A[["P1"]],
              new("pMatrix", Dim = c(n, n), Dimnames = c(list(NULL), dn[2L]),
                  margin = 2L, perm = invertPerm(ch.A@perm)))
    identical(e.ch.A[["P1."]], t(e.ch.A[["P1"]]))
    identical(e.ch.A[["L1."]], t(e.ch.A[["L1"]]))
    identical(E.ch.A[["L." ]], t(E.ch.A[["L" ]]))
    identical(e.ch.A[["D"]], Diagonal(x = diag(ch.A)))
    all.equal(E.ch.A[["L"]], with(e.ch.A, L1 %*% sqrt(D)))
    ae1(A, with(e.ch.A, P1. %*% L1 %*% D %*% L1. %*% P1))
    ae1(A, with(E.ch.A, P1. %*% L  %*%         L.  %*% P1))
    ae2(A[ch.A@perm, ch.A@perm], with(e.ch.A, L1 %*% D %*% L1.))
    ae2(A[ch.A@perm, ch.A@perm], with(E.ch.A, L  %*%         L. ))
})

## Factorization handled as factorized matrix
b &lt;- rnorm(n)
all.equal(det(A), det(ch.A), tolerance = 0)
all.equal(solve(A, b), solve(ch.A, b), tolerance = 0)

## For identical results, we need the _unpivoted_ factorization
## computed by det(A) and solve(A, b)
(ch.A.nopivot &lt;- Cholesky(A, perm = FALSE))
stopifnot(identical(det(A), det(ch.A.nopivot)),
          identical(solve(A, b), solve(ch.A.nopivot, b)))
</code></pre>

<hr>
<h2 id='Cholesky-methods'>Methods for Cholesky Factorization</h2><span id='topic+Cholesky'></span><span id='topic+Cholesky-methods'></span><span id='topic+Cholesky+2CddiMatrix-method'></span><span id='topic+Cholesky+2CdiagonalMatrix-method'></span><span id='topic+Cholesky+2CdsCMatrix-method'></span><span id='topic+Cholesky+2CdsRMatrix-method'></span><span id='topic+Cholesky+2CdsTMatrix-method'></span><span id='topic+Cholesky+2CdspMatrix-method'></span><span id='topic+Cholesky+2CdsyMatrix-method'></span><span id='topic+Cholesky+2CgeneralMatrix-method'></span><span id='topic+Cholesky+2Cmatrix-method'></span><span id='topic+Cholesky+2CsymmetricMatrix-method'></span><span id='topic+Cholesky+2CtriangularMatrix-method'></span>

<h3>Description</h3>

<p>Computes the pivoted Cholesky factorization of an
<code class="reqn">n \times n</code> real, symmetric matrix <code class="reqn">A</code>,
which has the general form
</p>
<p style="text-align: center;"><code class="reqn">P_1 A P_1' = L_1 D L_1' \overset{D_{jj} \ge 0}{=} L L'</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_1' L_1 D L_1' P_1 \overset{D_{jj} \ge 0}{=} P_1' L L' P_1</code>
</p>

<p>where
<code class="reqn">P_1</code> is a permutation matrix,
<code class="reqn">L_1</code> is a unit lower triangular matrix,
<code class="reqn">D</code> is a diagonal matrix, and
<code class="reqn">L = L_1 \sqrt{D}</code>.
The second equalities hold only for positive semidefinite <code class="reqn">A</code>,
for which the diagonal entries of <code class="reqn">D</code> are non-negative
and <code class="reqn">\sqrt{D}</code> is well-defined.
</p>
<p>Methods for <code><a href="#topic+denseMatrix-class">denseMatrix</a></code> are built on
LAPACK routines <code>dpstrf</code>, <code>dpotrf</code>, and <code>dpptrf</code>.
The latter two do not permute rows or columns,
so that <code class="reqn">P_1</code> is an identity matrix.
</p>
<p>Methods for <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> are built on
CHOLMOD routines <code>cholmod_analyze</code> and <code>cholmod_factorize_p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cholesky(A, ...)
## S4 method for signature 'dsyMatrix'
Cholesky(A, perm = TRUE, tol = -1, ...)
## S4 method for signature 'dspMatrix'
Cholesky(A, ...)
## S4 method for signature 'dsCMatrix'
Cholesky(A, perm = TRUE, LDL = !super, super = FALSE,
    Imult = 0, ...)
## S4 method for signature 'ddiMatrix'
Cholesky(A, ...)
## S4 method for signature 'generalMatrix'
Cholesky(A, uplo = "U", ...)
## S4 method for signature 'triangularMatrix'
Cholesky(A, uplo = "U", ...)
## S4 method for signature 'matrix'
Cholesky(A, uplo = "U", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cholesky-methods_+3A_a">A</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a>, symmetric matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> to be factorized.  If <code>A</code>
is square but not symmetric, then it will be <em>treated</em>
as symmetric; see <code>uplo</code>.
Methods for dense <code>A</code> require positive definiteness
when <code>perm = FALSE</code> and positive semidefiniteness
when <code>perm = TRUE</code>.
Methods for sparse <code>A</code> require positive definiteness
when <code>LDL = TRUE</code> and nonzero leading principal minors
(after pivoting) when <code>LDL = FALSE</code>.
Methods for sparse, <em>diagonal</em> <code>A</code> are an exception,
requiring positive semidefiniteness unconditionally.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_perm">perm</code></td>
<td>
<p>a logical indicating if the rows and columns
of <code class="reqn">A</code> should be pivoted.  Methods for sparse <code>A</code>
employ the approximate minimum degree (AMD) algorithm
in order to reduce fill-in, i.e., without regard for
numerical stability.
Pivoting for sparsity may introduce nonpositive leading
principal minors, causing the factorization to fail, in
which case it may be necessary to set <code>perm = FALSE</code>.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_tol">tol</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> numeric tolerance,
used only if <code>perm = TRUE</code>.
The factorization algorithm stops if the pivot is less than
or equal to <code>tol</code>.  Negative <code>tol</code> is equivalent
to <code>nrow(A) * .Machine$double.eps * max(diag(A))</code>.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_ldl">LDL</code></td>
<td>
<p>a logical indicating if the simplicial factorization
should be computed as
<code class="reqn">P_1' L_1 D L_1' P_1</code>,
such that the result stores the lower triangular entries
of <code class="reqn">L_1-I+D</code>.
The alternative is <code class="reqn">P_1' L L' P_1</code>,
such that the result stores the lower triangular entries
of <code class="reqn">L = L_1 \sqrt{D}</code>.  This argument
is ignored if <code>super = TRUE</code> (or if <code>super = NA</code>
and the supernodal algorithm is chosen), as the supernodal
code does not yet support the <code>LDL = TRUE</code> variant.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_super">super</code></td>
<td>
<p>a logical indicating if the factorization should
use the supernodal algorithm.  The alternative is the simplicial
algorithm.  Setting <code>super = NA</code> leaves the choice to
a CHOLMOD-internal heuristic.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_imult">Imult</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> number. The matrix
that is factorized is <code>A + Imult * diag(nrow(A))</code>,
i.e., <code>A</code> plus <code>Imult</code> times the identity matrix.
This argument is useful for symmetric, indefinite <code>A</code>,
as <code>Imult &gt; max(rowSums(abs(A)) - diag(abs(A)))</code> ensures
that <code>A + Imult * diag(nrow(A))</code> is diagonally dominant.
(Symmetric, diagonally dominant matrices are positive definite.)</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_uplo">uplo</code></td>
<td>
<p>a string, either <code>"U"</code> or <code>"L"</code>,
indicating which triangle of <code>A</code> should be used
to compute the factorization.  The default is <code>"U"</code>,
even for lower triangular <code>A</code>, to be consistent with
<code><a href="base.html#topic+chol">chol</a></code> from <span class="pkg">base</span>.</p>
</td></tr>
<tr><td><code id="Cholesky-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the result of a call to <code>Cholesky</code> inherits
from <code><a href="#topic+CholeskyFactorization-class">CholeskyFactorization</a></code> but not
<code><a href="#topic+Matrix-class">Matrix</a></code>.  Users who just want a matrix
should consider using <code><a href="#topic+chol">chol</a></code>, whose methods are
simple wrappers around <code>Cholesky</code> returning just the
upper triangular Cholesky factor <code class="reqn">L'</code>,
typically as a <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.
However, a more principled approach would be to construct
factors as needed from the <code>CholeskyFactorization</code> object,
e.g., with <code><a href="#topic+expand1">expand1</a>(x, "L")</code>, if <code>x</code> is the
object.
</p>
<p>The behaviour of <code>Cholesky(A, perm = TRUE)</code> for dense <code>A</code>
is somewhat exceptional, in that it expects <em>without</em> checking
that <code>A</code> is positive semidefinite.  By construction, if <code class="reqn">A</code>
is positive semidefinite and the exact algorithm encounters a zero
pivot, then the unfactorized trailing submatrix is the zero matrix,
and there is nothing left to do.  Hence when the finite precision
algorithm encounters a pivot less than <code>tol</code>, it signals a
warning instead of an error and zeros the trailing submatrix in
order to guarantee that <code class="reqn">P' L L' P</code> is positive
semidefinite even if <code class="reqn">A</code> is not.  It follows that one way to
test for positive semidefiniteness of <code class="reqn">A</code> in the event of a
warning is to analyze the error
</p>
<p style="text-align: center;"><code class="reqn">\frac{\lVert A - P' L L' P \rVert}{\lVert A \rVert}\,.</code>
</p>

<p>See the examples and LAPACK Working Note (&ldquo;LAWN&rdquo;) 161
for details.
</p>


<h3>Value</h3>

<p>An object representing the factorization, inheriting from
virtual class <code><a href="#topic+CholeskyFactorization-class">CholeskyFactorization</a></code>.
For a traditional matrix <code>A</code>, the specific class is
<code><a href="#topic+Cholesky-class">Cholesky</a></code>.
For <code>A</code> inheriting from
<code><a href="#topic+unpackedMatrix-class">unpackedMatrix</a></code>,
<code><a href="#topic+packedMatrix-class">packedMatrix</a></code>, and
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>,
the specific class is
<code><a href="#topic+Cholesky-class">Cholesky</a></code>,
<code><a href="#topic+pCholesky-class">pCholesky</a></code>, and
<code><a href="#topic+dCHMsimpl-class">dCHMsimpl</a></code> or <code><a href="#topic+dCHMsuper-class">dCHMsuper</a></code>,
respectively.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dpstrf.f">https://netlib.org/lapack/double/dpstrf.f</a>,
<a href="https://netlib.org/lapack/double/dpotrf.f">https://netlib.org/lapack/double/dpotrf.f</a>, and
<a href="https://netlib.org/lapack/double/dpptrf.f">https://netlib.org/lapack/double/dpptrf.f</a>.
</p>
<p>The CHOLMOD source code; see
<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">https://github.com/DrTimothyAldenDavis/SuiteSparse</a>,
notably the header file &lsquo;<span class="file">CHOLMOD/Include/cholmod.h</span>&rsquo;
defining <code>cholmod_factor_struct</code>.
</p>
<p>Lucas, C. (2004).
<em>LAPACK-style codes for level 2 and 3 pivoted Cholesky factorizations</em>.
LAPACK Working Note, Number 161.
<a href="https://www.netlib.org/lapack/lawnspdf/lawn161.pdf">https://www.netlib.org/lapack/lawnspdf/lawn161.pdf</a>
</p>
<p>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008).
Algorithm 887: CHOLMOD, supernodal sparse Cholesky factorization
and update/downdate.
<em>ACM Transactions on Mathematical Software</em>,
<em>35</em>(3), Article 22, 1-14.
<a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a>
</p>
<p>Amestoy, P. R., Davis, T. A., &amp; Duff, I. S. (2004).
Algorithm 837: AMD, an approximate minimum degree ordering algorithm.
<em>ACM Transactions on Mathematical Software</em>,
<em>17</em>(4), 886-905.
<a href="https://doi.org/10.1145/1024074.1024081">doi:10.1145/1024074.1024081</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+Cholesky-class">Cholesky</a></code>, <code><a href="#topic+pCholesky-class">pCholesky</a></code>,
<code><a href="#topic+dCHMsimpl-class">dCHMsimpl</a></code> and <code><a href="#topic+dCHMsuper-class">dCHMsuper</a></code>
and their methods.
</p>
<p>Classes <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code>, <code><a href="#topic+dppMatrix-class">dppMatrix</a></code>,
and <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>.
</p>
<p>Generic function <code><a href="#topic+chol">chol</a></code>,
for obtaining the upper triangular Cholesky factor <code class="reqn">L'</code> as a
matrix or <code><a href="#topic+Matrix-class">Matrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>,
for constructing matrix factors from the result.
</p>
<p>Generic functions <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>, <code><a href="#topic+Schur">Schur</a></code>,
<code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code>,
for computing other factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("Cholesky", inherited = FALSE)
set.seed(0)

## ---- Dense ----------------------------------------------------------

## .... Positive definite ..............................................

n &lt;- 6L
(A1 &lt;- crossprod(Matrix(rnorm(n * n), n, n)))
(ch.A1.nopivot &lt;- Cholesky(A1, perm = FALSE))
(ch.A1 &lt;- Cholesky(A1))
stopifnot(exprs = {
    length(ch.A1@perm) == ncol(A1)
    isPerm(ch.A1@perm)
    is.unsorted(ch.A1@perm) # typically not the identity permutation
    length(ch.A1.nopivot@perm) == 0L
})

## A ~ P1' L D L' P1 ~ P1' L L' P1 in floating point
str(e.ch.A1 &lt;- expand2(ch.A1, LDL =  TRUE), max.level = 2L)
str(E.ch.A1 &lt;- expand2(ch.A1, LDL = FALSE), max.level = 2L)
stopifnot(exprs = {
    all.equal(as(A1, "matrix"), as(Reduce(`%*%`, e.ch.A1), "matrix"))
    all.equal(as(A1, "matrix"), as(Reduce(`%*%`, E.ch.A1), "matrix"))
})

## .... Positive semidefinite but not positive definite ................

A2 &lt;- A1
A2[1L, ] &lt;- A2[, 1L] &lt;- 0
A2
try(Cholesky(A2, perm = FALSE)) # fails as not positive definite
ch.A2 &lt;- Cholesky(A2) # returns, with a warning and ...
A2.hat &lt;- Reduce(`%*%`, expand2(ch.A2, LDL = FALSE))
norm(A2 - A2.hat, "2") / norm(A2, "2") # 7.670858e-17

## .... Not positive semidefinite ......................................

A3 &lt;- A1
A3[1L, ] &lt;- A3[, 1L] &lt;- -1
A3
try(Cholesky(A3, perm = FALSE)) # fails as not positive definite
ch.A3 &lt;- Cholesky(A3) # returns, with a warning and ...
A3.hat &lt;- Reduce(`%*%`, expand2(ch.A3, LDL = FALSE))
norm(A3 - A3.hat, "2") / norm(A3, "2") # 1.781568

## Indeed, 'A3' is not positive semidefinite, but 'A3.hat' _is_
ch.A3.hat &lt;- Cholesky(A3.hat)
A3.hat.hat &lt;- Reduce(`%*%`, expand2(ch.A3.hat, LDL = FALSE))
norm(A3.hat - A3.hat.hat, "2") / norm(A3.hat, "2") # 1.777944e-16

## ---- Sparse ---------------------------------------------------------

## Really just three cases modulo permutation :
##
##            type        factorization  minors of P1 A P1'
##   1  simplicial  P1 A P1' = L1 D L1'             nonzero
##   2  simplicial  P1 A P1' = L    L '            positive
##   3  supernodal  P1 A P2' = L    L '            positive

data(KNex, package = "Matrix")
A4 &lt;- crossprod(KNex[["mm"]])

ch.A4 &lt;-
list(pivoted =
     list(simpl1 = Cholesky(A4, perm =  TRUE, super = FALSE, LDL =  TRUE),
          simpl0 = Cholesky(A4, perm =  TRUE, super = FALSE, LDL = FALSE),
          super0 = Cholesky(A4, perm =  TRUE, super =  TRUE             )),
     unpivoted =
     list(simpl1 = Cholesky(A4, perm = FALSE, super = FALSE, LDL =  TRUE),
          simpl0 = Cholesky(A4, perm = FALSE, super = FALSE, LDL = FALSE),
          super0 = Cholesky(A4, perm = FALSE, super =  TRUE             )))
ch.A4

s &lt;- simplify2array
rapply2 &lt;- function(object, f, ...) rapply(object, f, , , how = "list", ...)

s(rapply2(ch.A4, isLDL))
s(m.ch.A4 &lt;- rapply2(ch.A4, expand1, "L")) # giving L = L1 sqrt(D)

## By design, the pivoted and simplicial factorizations
## are more sparse than the unpivoted and supernodal ones ...
s(rapply2(m.ch.A4, object.size))

## Which is nicely visualized by lattice-based methods for 'image'
inm &lt;- c("pivoted", "unpivoted")
jnm &lt;- c("simpl1", "simpl0", "super0")
for(i in 1:2)
  for(j in 1:3)
    print(image(m.ch.A4[[c(i, j)]], main = paste(inm[i], jnm[j])),
          split = c(j, i, 3L, 2L), more = i * j &lt; 6L)

simpl1 &lt;- ch.A4[[c("pivoted", "simpl1")]]
stopifnot(exprs = {
    length(simpl1@perm) == ncol(A4)
    isPerm(simpl1@perm, 0L)
    is.unsorted(simpl1@perm) # typically not the identity permutation
})

## One can expand with and without D regardless of isLDL(.),
## but "without" requires L = L1 sqrt(D), which is conditional
## on min(diag(D)) &gt;= 0, hence "with" is the default
isLDL(simpl1)
stopifnot(min(diag(simpl1)) &gt;= 0)
str(e.ch.A4 &lt;- expand2(simpl1, LDL =  TRUE), max.level = 2L) # default
str(E.ch.A4 &lt;- expand2(simpl1, LDL = FALSE), max.level = 2L)
stopifnot(exprs = {
    all.equal(E.ch.A4[["L" ]], e.ch.A4[["L1" ]] %*% sqrt(e.ch.A4[["D"]]))
    all.equal(E.ch.A4[["L."]], sqrt(e.ch.A4[["D"]]) %*% e.ch.A4[["L1."]])
    all.equal(A4, as(Reduce(`%*%`, e.ch.A4), "symmetricMatrix"))
    all.equal(A4, as(Reduce(`%*%`, E.ch.A4), "symmetricMatrix"))
})

## The "same" permutation matrix with "alternate" representation
## [i, perm[i]] {margin=1} &lt;-&gt; [invertPerm(perm)[j], j] {margin=2}
alt &lt;- function(P) {
    P@margin &lt;- 1L + !(P@margin - 1L) # 1 &lt;-&gt; 2
    P@perm &lt;- invertPerm(P@perm)
    P
}

## Expansions are elegant but inefficient (transposes are redundant)
## hence programmers should consider methods for 'expand1' and 'diag'
stopifnot(exprs = {
    identical(expand1(simpl1, "P1"), alt(e.ch.A4[["P1"]]))
    identical(expand1(simpl1, "L"), E.ch.A4[["L"]])
    identical(Diagonal(x = diag(simpl1)), e.ch.A4[["D"]])
})

## chol(A, pivot = value) is a simple wrapper around
## Cholesky(A, perm = value, LDL = FALSE, super = FALSE),
## returning L' = sqrt(D) L1' _but_ giving no information
## about the permutation P1
selectMethod("chol", "dsCMatrix")
stopifnot(all.equal(chol(A4, pivot = TRUE), E.ch.A4[["L."]]))

## Now a symmetric matrix with positive _and_ negative eigenvalues,
## hence _not_ positive semidefinite
A5 &lt;- new("dsCMatrix",
          Dim = c(7L, 7L),
          p = c(0:1, 3L, 6:7, 10:11, 15L),
          i = c(0L, 0:1, 0:3, 2:5, 3:6),
          x = c(1, 6, 38, 10, 60, 103, -4, 6, -32, -247, -2, -16, -128, -2, -67))
(ev &lt;- eigen(A5, only.values = TRUE)$values)
(t.ev &lt;- table(factor(sign(ev), -1:1))) # the matrix "inertia"

ch.A5 &lt;- Cholesky(A5)
isLDL(ch.A5)
(d.A5 &lt;- diag(ch.A5)) # diag(D) is partly negative

## Sylvester's law of inertia holds here, but not in general
## in finite precision arithmetic
stopifnot(identical(table(factor(sign(d.A5), -1:1)), t.ev))

try(expand1(ch.A5, "L"))         # unable to compute L = L1 sqrt(D)
try(expand2(ch.A5, LDL = FALSE)) # ditto
try(chol(A5, pivot = TRUE))      # ditto

## The default expansion is "square root free" and still works here
str(e.ch.A5 &lt;- expand2(ch.A5, LDL = TRUE), max.level = 2L)
stopifnot(all.equal(A5, as(Reduce(`%*%`, e.ch.A5), "symmetricMatrix")))

## Version of the SuiteSparse library, which includes CHOLMOD
Mv &lt;- Matrix.Version()
Mv[["suitesparse"]]
</code></pre>

<hr>
<h2 id='coerce-methods-graph'>Conversions &quot;graph&quot; &lt;&ndash;&gt; (sparse) Matrix</h2><span id='topic+coerce-methods-graph'></span><span id='topic+coerce+2CMatrix+2Cgraph-method'></span><span id='topic+coerce+2CMatrix+2CgraphNEL-method'></span><span id='topic+coerce+2CTsparseMatrix+2CgraphNEL-method'></span><span id='topic+coerce+2Cgraph+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cgraph+2CMatrix-method'></span><span id='topic+coerce+2Cgraph+2CRsparseMatrix-method'></span><span id='topic+coerce+2Cgraph+2CTsparseMatrix-method'></span><span id='topic+coerce+2Cgraph+2CsparseMatrix-method'></span><span id='topic+coerce+2CgraphAM+2CTsparseMatrix-method'></span><span id='topic+coerce+2CgraphNEL+2CTsparseMatrix-method'></span><span id='topic+T2graph'></span><span id='topic+graph2T'></span>

<h3>Description</h3>

<p>Since 2005, package <span class="pkg">Matrix</span> has supported coercions to and
from class <code><a href="graph.html#topic+graph-class">graph</a></code> from package
<a href="https://bioconductor.org/packages/graph/"><span class="pkg">graph</span></a>.
Since 2013, this functionality has been exposed via functions
<code>T2graph</code> and <code>graph2T</code>, which, unlike methods for
<code><a href="methods.html#topic+as">as</a>(from, "&lt;Class&gt;")</code>, support optional arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2T(from, use.weights = )
T2graph(from, need.uniq = !isUniqueT(from), edgemode = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce-methods-graph_+3A_from">from</code></td>
<td>
<p>for <code>graph2T()</code>, an <span class="rlang"><b>R</b></span> object of class
<code>"graph"</code>; <br />
for <code>T2graph()</code>, a sparse matrix inheriting from
<code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code>.</p>
</td></tr>
<tr><td><code id="coerce-methods-graph_+3A_use.weights">use.weights</code></td>
<td>
<p>logical indicating if weights should be used, i.e.,
equivalently the result will be numeric, i.e. of class
<code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>; otherwise the result will be
<code><a href="#topic+ngTMatrix-class">ngTMatrix</a></code> or <code><a href="#topic+nsTMatrix-class">nsTMatrix</a></code>,
the latter if the graph is undirected.  The default looks if there
are weights in the graph, and if any differ from <code>1</code>, weights
are used.</p>
</td></tr>
<tr><td><code id="coerce-methods-graph_+3A_need.uniq">need.uniq</code></td>
<td>
<p>a logical indicating if <code>from</code> may need to be
internally &ldquo;uniqified&rdquo;; do not set this and hence rather use
the default, unless you know what you are doing!</p>
</td></tr>
<tr><td><code id="coerce-methods-graph_+3A_edgemode">edgemode</code></td>
<td>
<p>one of <code>NULL</code>, <code>"directed"</code>, or
<code>"undirected"</code>.  The default <code>NULL</code> looks if the matrix is
symmetric and assumes <code>"undirected"</code> in that case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>graph2T()</code>, a sparse matrix  inheriting from
<code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code>.
</p>
<p>For <code>T2graph()</code> an <span class="rlang"><b>R</b></span> object of class <code>"graph"</code>.
</p>


<h3>See Also</h3>

<p>Package <a href="https://CRAN.R-project.org/package=igraph"><span class="pkg">igraph</span></a>, which provides similar coercions
to and from its class <code>igraph</code> via functions
<code>graph_from_adjacency_matrix</code> and <code>as_adjacency_matrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("graph")) {
  n4 &lt;- LETTERS[1:4]; dns &lt;- list(n4,n4)
  show(a1 &lt;- sparseMatrix(i= c(1:4),   j=c(2:4,1),   x = 2,    dimnames=dns))
  show(g1 &lt;- as(a1, "graph")) # directed
  unlist(graph::edgeWeights(g1)) # all '2'

  show(a2 &lt;- sparseMatrix(i= c(1:4,4), j=c(2:4,1:2), x = TRUE, dimnames=dns))
  show(g2 &lt;- as(a2, "graph")) # directed
  # now if you want it undirected:
  show(g3  &lt;- T2graph(as(a2,"TsparseMatrix"), edgemode="undirected"))
  show(m3 &lt;- as(g3,"Matrix"))
  show( graph2T(g3) ) # a "pattern Matrix" (nsTMatrix)

  a. &lt;- sparseMatrix(i=4:1, j=1:4, dimnames=list(n4, n4), repr="T") # no 'x'
  show(a.) # "ngTMatrix"
  show(g. &lt;- as(a., "graph"))

}
</code></pre>

<hr>
<h2 id='coerce-methods-SparseM'>Sparse Matrix Coercion from and to those from package <span class="pkg">SparseM</span></h2><span id='topic+coerce-methods-SparseM'></span><span id='topic+coerce+2CMatrix+2Cmatrix.coo-method'></span><span id='topic+coerce+2CMatrix+2Cmatrix.csc-method'></span><span id='topic+coerce+2CMatrix+2Cmatrix.csr-method'></span><span id='topic+coerce+2CdgCMatrix+2Cmatrix.csc-method'></span><span id='topic+coerce+2CdgRMatrix+2Cmatrix.csr-method'></span><span id='topic+coerce+2CdgTMatrix+2Cmatrix.coo-method'></span><span id='topic+coerce+2Cmatrix.coo+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CRsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CTsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CdgCMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CdgTMatrix-method'></span><span id='topic+coerce+2Cmatrix.coo+2CsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CRsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CTsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CdgCMatrix-method'></span><span id='topic+coerce+2Cmatrix.csc+2CsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CRsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CTsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CdgCMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CdgRMatrix-method'></span><span id='topic+coerce+2Cmatrix.csr+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Methods for coercion from and to sparse matrices from package <span class="pkg">SparseM</span>
are provided here, for ease of porting functionality to the
<span class="pkg">Matrix</span> package, and comparing functionality of the two
packages.  All these work via the usual <code><a href="methods.html#topic+as">as</a>(., "&lt;class&gt;")</code>
coercion, </p>
<pre>  as(from, Class)
</pre>


<h3>Methods</h3>


<dl>
<dt>from = &quot;matrix.csr&quot;, to = &quot;dgRMatrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.csc&quot;, to = &quot;dgCMatrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.coo&quot;, to = &quot;dgTMatrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;dgRMatrix&quot;, to = &quot;matrix.csr&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;dgCMatrix&quot;, to = &quot;matrix.csc&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;dgTMatrix&quot;, to = &quot;matrix.coo&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;Matrix&quot;, to = &quot;matrix.csr&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.csr&quot;, to = &quot;dgCMatrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.coo&quot;, to = &quot;dgCMatrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.csr&quot;, to = &quot;Matrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.csc&quot;, to = &quot;Matrix&quot;</dt><dd><p> ... </p>
</dd>
<dt>from = &quot;matrix.coo&quot;, to = &quot;Matrix&quot;</dt><dd><p> ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>The documentation in CRAN package <a href="https://CRAN.R-project.org/package=SparseM"><span class="pkg">SparseM</span></a>, such as
<code><a href="SparseM.html#topic+SparseM.ontology">SparseM.ontology</a></code>, and one important class,
<code><a href="SparseM.html#topic+matrix.csr-class">matrix.csr</a></code>.
</p>

<hr>
<h2 id='colSums-methods'>Form Row and Column Sums and Means</h2><span id='topic+colSums'></span><span id='topic+colSums-methods'></span><span id='topic+colMeans'></span><span id='topic+colMeans-methods'></span><span id='topic+rowSums'></span><span id='topic+rowSums-methods'></span><span id='topic+rowMeans'></span><span id='topic+rowMeans-methods'></span><span id='topic+colSums+2CCsparseMatrix-method'></span><span id='topic+colSums+2CRsparseMatrix-method'></span><span id='topic+colSums+2CTsparseMatrix-method'></span><span id='topic+colSums+2CdenseMatrix-method'></span><span id='topic+colSums+2CdiagonalMatrix-method'></span><span id='topic+colSums+2CindMatrix-method'></span><span id='topic+colMeans+2CCsparseMatrix-method'></span><span id='topic+colMeans+2CRsparseMatrix-method'></span><span id='topic+colMeans+2CTsparseMatrix-method'></span><span id='topic+colMeans+2CdenseMatrix-method'></span><span id='topic+colMeans+2CdiagonalMatrix-method'></span><span id='topic+colMeans+2CindMatrix-method'></span><span id='topic+rowSums+2CCsparseMatrix-method'></span><span id='topic+rowSums+2CRsparseMatrix-method'></span><span id='topic+rowSums+2CTsparseMatrix-method'></span><span id='topic+rowSums+2CdenseMatrix-method'></span><span id='topic+rowSums+2CdiagonalMatrix-method'></span><span id='topic+rowSums+2CindMatrix-method'></span><span id='topic+rowMeans+2CCsparseMatrix-method'></span><span id='topic+rowMeans+2CRsparseMatrix-method'></span><span id='topic+rowMeans+2CTsparseMatrix-method'></span><span id='topic+rowMeans+2CdenseMatrix-method'></span><span id='topic+rowMeans+2CdiagonalMatrix-method'></span><span id='topic+rowMeans+2CindMatrix-method'></span>

<h3>Description</h3>

<p>Form row and column sums and means for
objects, for <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> the result may
optionally be sparse (<code><a href="#topic+sparseVector-class">sparseVector</a></code>), too.
Row or column names are kept respectively as for <span class="pkg">base</span> matrices
and <code><a href="#topic+colSums">colSums</a></code> methods, when the result is
<code><a href="base.html#topic+numeric">numeric</a></code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> colSums(x, na.rm = FALSE, dims = 1L, ...)
 rowSums(x, na.rm = FALSE, dims = 1L, ...)
colMeans(x, na.rm = FALSE, dims = 1L, ...)
rowMeans(x, na.rm = FALSE, dims = 1L, ...)

## S4 method for signature 'CsparseMatrix'
 colSums(x, na.rm = FALSE, dims = 1L,
         sparseResult = FALSE, ...)
## S4 method for signature 'CsparseMatrix'
 rowSums(x, na.rm = FALSE, dims = 1L,
         sparseResult = FALSE, ...)
## S4 method for signature 'CsparseMatrix'
colMeans(x, na.rm = FALSE, dims = 1L,
         sparseResult = FALSE, ...)
## S4 method for signature 'CsparseMatrix'
rowMeans(x, na.rm = FALSE, dims = 1L,
         sparseResult = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSums-methods_+3A_x">x</code></td>
<td>
<p>a Matrix, i.e., inheriting from  <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values (including <code>NaN</code>)
be omitted from the calculations?</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_dims">dims</code></td>
<td>
<p>completely ignored by the <code>Matrix</code> methods.</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_...">...</code></td>
<td>
<p>potentially further arguments, for method <code>&lt;-&gt;</code>
generic compatibility.</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_sparseresult">sparseResult</code></td>
<td>
<p>logical indicating if the result should be sparse,
i.e., inheriting from class <code><a href="#topic+sparseVector-class">sparseVector</a></code>.  Only
applicable when <code>x</code> is inheriting from a
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric vector if <code>sparseResult</code> is <code>FALSE</code> as per
default.  Otherwise, returns a <code><a href="#topic+sparseVector-class">sparseVector</a></code>.
</p>
<p><code><a href="base.html#topic+dimnames">dimnames</a>(x)</code> are only kept (as <code><a href="base.html#topic+names">names</a>(v)</code>)
when the resulting <code>v</code> is <code><a href="base.html#topic+numeric">numeric</a></code>, since
<code><a href="#topic+sparseVector">sparseVector</a></code>s do not have names.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colSums">colSums</a></code> and the
<code><a href="#topic+sparseVector-class">sparseVector</a></code> classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(M &lt;- bdiag(Diagonal(2), matrix(1:3, 3,4), diag(3:2))) # 7 x 8
colSums(M)
d &lt;- Diagonal(10, c(0,0,10,0,2,rep(0,5)))
MM &lt;- kronecker(d, M)
dim(MM) # 70 80
length(MM@x) # 160, but many are '0' ; drop those:
MM &lt;- drop0(MM)
length(MM@x) # 32
  cm &lt;- colSums(MM)
(scm &lt;- colSums(MM, sparseResult = TRUE))
stopifnot(is(scm, "sparseVector"),
          identical(cm, as.numeric(scm)))
rowSums (MM, sparseResult = TRUE) # 14 of 70 are not zero
colMeans(MM, sparseResult = TRUE) # 16 of 80 are not zero
## Since we have no 'NA's, these two are equivalent :
stopifnot(identical(rowMeans(MM, sparseResult = TRUE),
                    rowMeans(MM, sparseResult = TRUE, na.rm = TRUE)),
	  rowMeans(Diagonal(16)) == 1/16,
	  colSums(Diagonal(7)) == 1)

## dimnames(x) --&gt;  names( &lt;value&gt; ) :
dimnames(M) &lt;- list(paste0("r", 1:7), paste0("V",1:8))
M
colSums(M)
rowMeans(M)
## Assertions :
stopifnot(exprs = {
    all.equal(colSums(M),
              structure(c(1,1,6,6,6,6,3,2), names = colnames(M)))
    all.equal(rowMeans(M),
              structure(c(1,1,4,8,12,3,2)/8, names = paste0("r", 1:7)))
})
</code></pre>

<hr>
<h2 id='condest'>Compute Approximate CONDition number and 1-Norm of (Large) Matrices</h2><span id='topic+condest'></span><span id='topic+onenormest'></span>

<h3>Description</h3>

<p>&ldquo;Estimate&rdquo;, i.e. compute approximately the CONDition number of
a (potentially large, often sparse) matrix <code>A</code>.
It works by apply a fast <em>randomized</em> approximation of the 1-norm,
<code>norm(A,"1")</code>, through <code>onenormest(.)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condest(A, t = min(n, 5), normA = norm(A, "1"),
        silent = FALSE, quiet = TRUE)

onenormest(A, t = min(n, 5), A.x, At.x, n,
           silent = FALSE, quiet = silent,
           iter.max = 10, eps = 4 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condest_+3A_a">A</code></td>
<td>
<p>a square matrix, optional for <code>onenormest()</code>, where
instead of <code>A</code>, <code>A.x</code> and <code>At.x</code> can be specified,
see there.</p>
</td></tr>
<tr><td><code id="condest_+3A_t">t</code></td>
<td>
<p>number of columns to use in the iterations.</p>
</td></tr>
<tr><td><code id="condest_+3A_norma">normA</code></td>
<td>
<p>number; (an estimate of) the 1-norm of <code>A</code>, by
default <code><a href="#topic+norm">norm</a>(A, "1")</code>; may be replaced by an estimate.</p>
</td></tr>
<tr><td><code id="condest_+3A_silent">silent</code></td>
<td>
<p>logical indicating if warning and (by default)
convergence messages should be displayed.</p>
</td></tr>
<tr><td><code id="condest_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating if convergence messages should be
displayed.</p>
</td></tr>
<tr><td><code id="condest_+3A_a.x">A.x</code>, <code id="condest_+3A_at.x">At.x</code></td>
<td>
<p>when <code>A</code> is missing, these two must be given as
functions which compute <code>A %% x</code>, or <code>t(A) %% x</code>,
respectively.</p>
</td></tr>
<tr><td><code id="condest_+3A_n">n</code></td>
<td>
<p><code> == nrow(A)</code>, only needed when <code>A</code> is not specified.</p>
</td></tr>
<tr><td><code id="condest_+3A_iter.max">iter.max</code></td>
<td>
<p>maximal number of iterations for the 1-norm estimator.</p>
</td></tr>
<tr><td><code id="condest_+3A_eps">eps</code></td>
<td>
<p>the relative change that is deemed irrelevant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+condest">condest</a>()</code> calls <code><a href="#topic+lu">lu</a>(A)</code>, and subsequently
<code>onenormest(A.x = , At.x = )</code> to compute an approximate norm of
the <em>inverse</em> of <code>A</code>, <code class="reqn">A^{-1}</code>, in a way which
keeps using sparse matrices efficiently when <code>A</code> is sparse.
</p>
<p>Note that <code>onenormest()</code> uses random vectors and hence
<em>both</em> functions' results are random, i.e., depend on the random
seed, see, e.g., <code><a href="base.html#topic+set.seed">set.seed</a>()</code>.
</p>


<h3>Value</h3>

<p>Both functions return a <code><a href="base.html#topic+list">list</a></code>;
<code>condest()</code> with components,
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a number <code class="reqn">&gt; 0</code>, the estimated (1-norm) condition number
<code class="reqn">\hat\kappa</code>; when <code class="reqn">r :=</code><code>rcond(A)</code>,
<code class="reqn">1/\hat\kappa \approx r</code>.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the maximal <code class="reqn">A x</code> column, scaled to norm(v) = 1.
Consequently, <code class="reqn">norm(A v) = norm(A) / est</code>;
when <code>est</code> is large, <code>v</code> is an approximate null vector.</p>
</td></tr>
</table>
<p>The function <code>onenormest()</code> returns a list with components,
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a number <code class="reqn">&gt; 0</code>, the estimated <code>norm(A, "1")</code>.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>0-1 integer vector length <code>n</code>, with an <code>1</code> at the index
<code>j</code> with maximal column <code>A[,j]</code> in <code class="reqn">A</code>.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>numeric vector, the largest <code class="reqn">A x</code> found.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This is based on octave's <code>condest()</code> and
<code>onenormest()</code> implementations with original author
Jason Riedy, U Berkeley; translation to <span class="rlang"><b>R</b></span> and
adaption by Martin Maechler.
</p>


<h3>References</h3>

<p>Nicholas J. Higham and Françoise Tisseur (2000).
A Block Algorithm for Matrix 1-Norm Estimation, with an Application
to 1-Norm Pseudospectra.
<em>SIAM J. Matrix Anal. Appl.</em> <b>21</b>, 4, 1185&ndash;1201.


</p>
<p>William W. Hager (1984).
Condition Estimates.
<em>SIAM J. Sci. Stat. Comput.</em> <b>5</b>, 311&ndash;316.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>, <code><a href="#topic+rcond">rcond</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KNex, package = "Matrix")
mtm &lt;- with(KNex, crossprod(mm))
system.time(ce &lt;- condest(mtm))
sum(abs(ce$v)) ## || v ||_1  == 1
## Prove that  || A v || = || A || / est  (as ||v|| = 1):
stopifnot(all.equal(norm(mtm %*% ce$v),
                    norm(mtm) / ce$est))

## reciprocal
1 / ce$est
system.time(rc &lt;- rcond(mtm)) # takes ca  3 x  longer
rc
all.equal(rc, 1/ce$est) # TRUE -- the approximation was good

one &lt;- onenormest(mtm)
str(one) ## est = 12.3
## the maximal column:
which(one$v == 1) # mostly 4, rarely 1, depending on random seed
</code></pre>

<hr>
<h2 id='CsparseMatrix-class'>Class &quot;CsparseMatrix&quot; of Sparse Matrices in Column-compressed Form</h2><span id='topic+CsparseMatrix-class'></span><span id='topic+Arith+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+Arith+2CCsparseMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CCsparseMatrix-method'></span><span id='topic+Compare+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+Logic+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2CCsparseMatrix-method'></span><span id='topic+diag+2CCsparseMatrix-method'></span><span id='topic+diag+3C-+2CCsparseMatrix-method'></span><span id='topic+t+2CCsparseMatrix-method'></span><span id='topic+.validateCsparse'></span>

<h3>Description</h3>

<p>The <code>"CsparseMatrix"</code> class is the virtual class of
all sparse matrices coded in sorted compressed column-oriented form.
Since it is a virtual class, no objects may be created from it.  See
<code>showClass("CsparseMatrix")</code> for its subclasses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the <em>0-based</em> row numbers for
each non-zero element in the matrix, i.e., <code>i</code> must be in
<code>0:(nrow(.)-1)</code>.</p>
</dd>
<dt><code>p</code>:</dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> vector for providing pointers, one
for each column, to the initial (zero-based) index of elements in
the column.  <code>.@p</code> is of length <code>ncol(.) + 1</code>, with
<code>p[1] == 0</code> and <code>p[length(p)] == nnzero</code>, such that in
fact, <code>diff(.@p)</code> are the number of non-zero elements for
each column.
</p>
<p>In other words, <code>m@p[1:ncol(m)]</code> contains the indices of
those elements in <code>m@x</code> that are the first elements in the
respective column of <code>m</code>.
</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>inherited from
the superclass, see the <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> class.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"sparseMatrix"</code>, directly.
Class <code>"Matrix"</code>, by class <code>"sparseMatrix"</code>.
</p>


<h3>Methods</h3>


<p>matrix products <code><a href="#topic+crossprod-methods">%*%</a></code>,
<code><a href="#topic+crossprod-methods">crossprod</a>()</code> and <code>tcrossprod()</code>,
several <code><a href="#topic+solve">solve</a></code> methods,
and other matrix methods available:


</p>
<dl>
<dt>Arith</dt><dd><p><code>signature(e1 = "CsparseMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "numeric", e2 = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>band</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "CsparseMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>-</dt><dd><p><code>signature(e1 = "numeric", e2 = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "CsparseMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>+</dt><dd><p><code>signature(e1 = "numeric", e2 = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "CsparseMatrix", to = "TsparseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "CsparseMatrix", to = "denseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "CsparseMatrix", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "TsparseMatrix", to = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "denseMatrix", to = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>gamma</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>lgamma</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>log</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>tril</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>triu</dt><dd><p><code>signature(x = "CsparseMatrix")</code>: ... </p>
</dd>
</dl>



<h3>Note</h3>

<p>All classes extending <code>CsparseMatrix</code> have a common validity
(see <code><a href="methods.html#topic+validObject">validObject</a></code>) check function.  That function
additionally checks the <code>i</code> slot for each column to contain
increasing row numbers. <br />
In earlier versions of <span class="pkg">Matrix</span> (<code>&lt;= 0.999375-16</code>),
<code><a href="methods.html#topic+validObject">validObject</a></code> automatically re-sorted the entries when
necessary, and hence <code>new()</code> calls with somewhat permuted
<code>i</code> and <code>x</code> slots worked, as <code><a href="methods.html#topic+new">new</a>(...)</code>
(<em>with</em> slot arguments) automatically checks the validity.
</p>
<p>Now, you have to use <code><a href="#topic+sparseMatrix">sparseMatrix</a></code> to achieve the same
functionality or know how to use <code>.validateCsparse()</code> to do so.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colSums">colSums</a></code>, <code><a href="#topic+kronecker">kronecker</a></code>, and other such methods
with own help pages.
</p>
<p>Further, the super class of <code>CsparseMatrix</code>,
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, and, e.g.,
class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> for the links to other classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getClass("CsparseMatrix")

## The common validity check function (based on C code):
getValidity(getClass("CsparseMatrix"))
</code></pre>

<hr>
<h2 id='ddenseMatrix-class'>Virtual Class &quot;ddenseMatrix&quot; of Numeric Dense Matrices</h2><span id='topic+ddenseMatrix-class'></span><span id='topic++26+2CddenseMatrix+2CddiMatrix-method'></span><span id='topic++26+2CddenseMatrix+2CldiMatrix-method'></span><span id='topic++26+2CddenseMatrix+2CndiMatrix-method'></span><span id='topic++2A+2CddenseMatrix+2CddiMatrix-method'></span><span id='topic++2A+2CddenseMatrix+2CldiMatrix-method'></span><span id='topic++2A+2CddenseMatrix+2CndiMatrix-method'></span><span id='topic+Arith+2CddenseMatrix+2Clogical-method'></span><span id='topic+Arith+2CddenseMatrix+2Cnumeric-method'></span><span id='topic+Arith+2CddenseMatrix+2CsparseVector-method'></span><span id='topic+Arith+2Clogical+2CddenseMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CddenseMatrix-method'></span><span id='topic++5E+2CddenseMatrix+2CddiMatrix-method'></span><span id='topic++5E+2CddenseMatrix+2CldiMatrix-method'></span><span id='topic++5E+2CddenseMatrix+2CndiMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CddenseMatrix-method'></span><span id='topic+coerce+2Cvector+2CddenseMatrix-method'></span>

<h3>Description</h3>

<p>This is the virtual class of all dense numeric (i.e.,
<b>d</b>ouble, hence <em>&ldquo;ddense&rdquo;</em>) S4 matrices.
</p>
<p>Its most important subclass is the <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> class.

</p>


<h3>Extends</h3>

<p>Class <code>"dMatrix"</code> directly;
class <code>"Matrix"</code>, by the above.
</p>


<h3>Slots</h3>

<p>the same slots at its subclass <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>, see
there.
</p>


<h3>Methods</h3>

<p>Most methods are implemented via <code>as(*, "generalMatrix")</code> and are
mainly used as &ldquo;fallbacks&rdquo; when the subclass doesn't need its
own specialized method.
</p>
<p>Use <code><a href="methods.html#topic+showMethods">showMethods</a>(class = "ddenseMatrix", where =
      "package:Matrix")</code> for an overview.
</p>


<h3>See Also</h3>

<p>The virtual classes <code><a href="#topic+Matrix-class">Matrix</a></code>,
<code><a href="#topic+dMatrix-class">dMatrix</a></code>, and <code><a href="#topic+dsparseMatrix-class">dsparseMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ddenseMatrix")

showMethods(class = "ddenseMatrix", where = "package:Matrix")
</code></pre>

<hr>
<h2 id='ddiMatrix-class'>Class &quot;ddiMatrix&quot; of Diagonal Numeric Matrices</h2><span id='topic+ddiMatrix-class'></span><span id='topic++25+25+2CddiMatrix+2CMatrix-method'></span><span id='topic++25+25+2CddiMatrix+2CddenseMatrix-method'></span><span id='topic++25+25+2CddiMatrix+2CldenseMatrix-method'></span><span id='topic++25+25+2CddiMatrix+2CndenseMatrix-method'></span><span id='topic++25+2F+25+2CddiMatrix+2CMatrix-method'></span><span id='topic++25+2F+25+2CddiMatrix+2CddenseMatrix-method'></span><span id='topic++25+2F+25+2CddiMatrix+2CldenseMatrix-method'></span><span id='topic++25+2F+25+2CddiMatrix+2CndenseMatrix-method'></span><span id='topic++26+2CddiMatrix+2CMatrix-method'></span><span id='topic++26+2CddiMatrix+2CddenseMatrix-method'></span><span id='topic++26+2CddiMatrix+2CldenseMatrix-method'></span><span id='topic++26+2CddiMatrix+2CndenseMatrix-method'></span><span id='topic++2A+2CddiMatrix+2CMatrix-method'></span><span id='topic++2A+2CddiMatrix+2CddenseMatrix-method'></span><span id='topic++2A+2CddiMatrix+2CldenseMatrix-method'></span><span id='topic++2A+2CddiMatrix+2CndenseMatrix-method'></span><span id='topic++2F+2CddiMatrix+2CMatrix-method'></span><span id='topic++2F+2CddiMatrix+2CddenseMatrix-method'></span><span id='topic++2F+2CddiMatrix+2CldenseMatrix-method'></span><span id='topic++2F+2CddiMatrix+2CndenseMatrix-method'></span><span id='topic+Arith+2CddiMatrix+2Clogical-method'></span><span id='topic+Arith+2CddiMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CddiMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CddiMatrix-method'></span><span id='topic+Ops+2CANY+2CddiMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2CANY-method'></span><span id='topic+Ops+2CddiMatrix+2CMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2CdMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2CndiMatrix-method'></span><span id='topic+Ops+2CddiMatrix+2Clogical-method'></span><span id='topic+Ops+2CddiMatrix+2Cnumeric-method'></span><span id='topic+Ops+2CddiMatrix+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>The class <code>"ddiMatrix"</code> of numerical diagonal matrices.

Note that diagonal matrices now extend <em><code>sparseMatrix</code></em>, whereas
they did extend dense matrices earlier.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ddiMatrix", ...)</code>
but typically rather via <code><a href="#topic+Diagonal">Diagonal</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>numeric vector.  For an <code class="reqn">n \times n</code>
matrix, the <code>x</code> slot is of length <code class="reqn">n</code> or <code>0</code>,
depending on the <code>diag</code> slot:</p>
</dd>
<dt><code>diag</code>:</dt><dd><p><code>"character"</code> string, either <code>"U"</code> or
<code>"N"</code> where <code>"U"</code> denotes unit-diagonal, i.e., identity
matrices.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>matrix dimension and
<code><a href="base.html#topic+dimnames">dimnames</a></code>, see the <code><a href="#topic+Matrix-class">Matrix</a></code> class
description.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+diagonalMatrix-class">diagonalMatrix</a>"</code>, directly.
Class <code>"<a href="#topic+dMatrix-class">dMatrix</a>"</code>, directly.
Class <code>"<a href="#topic+sparseMatrix-class">sparseMatrix</a>"</code>, indirectly, see
<code><a href="methods.html#topic+showClass">showClass</a>("ddiMatrix")</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "ddiMatrix", y = "ddiMatrix")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>Class <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code> and function <code><a href="#topic+Diagonal">Diagonal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(d2 &lt;- Diagonal(x = c(10,1)))
str(d2)
## slightly larger in internal size:
str(as(d2, "sparseMatrix"))

M &lt;- Matrix(cbind(1,2:4))
M %*% d2 #&gt; `fast' multiplication

chol(d2) # trivial
stopifnot(is(cd2 &lt;- chol(d2), "ddiMatrix"),
          all.equal(cd2@x, c(sqrt(10),1)))
</code></pre>

<hr>
<h2 id='denseLU-class'>Dense LU Factorizations</h2><span id='topic+denseLU-class'></span><span id='topic+coerce+2CdenseLU+2CdgeMatrix-method'></span><span id='topic+determinant+2CdenseLU+2Clogical-method'></span>

<h3>Description</h3>

<p><code>denseLU</code> is the class of dense, row-pivoted LU factorizations
of <code class="reqn">m \times n</code> real matrices <code class="reqn">A</code>,
having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A = L U</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' L U</code>
</p>

<p>where
<code class="reqn">P_{1}</code> is an <code class="reqn">m \times m</code> permutation matrix, 
<code class="reqn">L</code> is an <code class="reqn">m \times \min(m,n)</code>
unit lower trapezoidal matrix, and
<code class="reqn">U</code> is a  <code class="reqn">\min(m,n) \times n</code>
upper trapezoidal matrix.  If <code class="reqn">m = n</code>, then the factors
<code class="reqn">L</code> and <code class="reqn">U</code> are triangular.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector of length <code>prod(Dim)</code> storing
the triangular <code class="reqn">L</code> and <code class="reqn">U</code> factors together in a packed
format.  The details of the representation are specified by the
manual for LAPACK routine <code>dgetrf</code>.</p>
</dd>
<dt><code>perm</code></dt><dd><p>an integer vector of length <code>min(Dim)</code>
specifying the permutation <code class="reqn">P_{1}</code> as a product of
transpositions.   The corresponding permutation vector can
be obtained as <code><a href="#topic+asPerm">asPerm</a>(perm)</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+LU-class">LU</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+LU-class">LU</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("denseLU", ...)</code>, but they are more typically obtained
as the value of <code><a href="#topic+lu">lu</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code> (often <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "denseLU", to = "dgeMatrix")</code>:
returns a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> with the dimensions
of the factorized matrix <code class="reqn">A</code>, equal to <code class="reqn">L</code> below the
diagonal and equal to <code class="reqn">U</code> on and above the diagonal.</p>
</dd>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "denseLU", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "denseLU")</code>:
see <code><a href="#topic+expand-methods">expand-methods</a></code>.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "denseLU")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "denseLU")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "denseLU", b = "missing")</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dgetrf.f">https://netlib.org/lapack/double/dgetrf.f</a>.
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+sparseLU-class">sparseLU</a></code> for sparse LU factorizations.
</p>
<p>Class <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+lu">lu</a></code>,
<code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("denseLU")
set.seed(1)

n &lt;- 3L
(A &lt;- Matrix(round(rnorm(n * n), 2L), n, n))

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- dn &lt;- list(paste0("r", seq_len(n)),
                          paste0("c", seq_len(n)))

(lu.A &lt;- lu(A))
str(e.lu.A &lt;- expand2(lu.A), max.level = 2L)

## Underlying LAPACK representation
(m.lu.A &lt;- as(lu.A, "dgeMatrix")) # which is L and U interlaced
stopifnot(identical(as(m.lu.A, "matrix"), `dim&lt;-`(lu.A@x, lu.A@Dim)))

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ P1' L U in floating point
stopifnot(exprs = {
    identical(names(e.lu.A), c("P1.", "L", "U"))
    identical(e.lu.A[["P1."]],
              new(  "pMatrix", Dim = c(n, n), Dimnames = c(dn[1L], list(NULL)),
                  margin = 1L, perm = invertPerm(asPerm(lu.A@perm))))
    identical(e.lu.A[["L"]],
              new("dtrMatrix", Dim = c(n, n), Dimnames = list(NULL, NULL),
                  uplo = "L", diag = "U", x = lu.A@x))
    identical(e.lu.A[["U"]],
              new("dtrMatrix", Dim = c(n, n), Dimnames = c(list(NULL), dn[2L]),
                  uplo = "U", diag = "N", x = lu.A@x))
    ae1(A, with(e.lu.A, P1. %*% L %*% U))
    ae2(A[asPerm(lu.A@perm), ], with(e.lu.A, L %*% U))
})

## Factorization handled as factorized matrix
b &lt;- rnorm(n)
stopifnot(identical(det(A), det(lu.A)),
          identical(solve(A, b), solve(lu.A, b)))
</code></pre>

<hr>
<h2 id='denseMatrix-class'>Virtual Class &quot;denseMatrix&quot; of All Dense Matrices</h2><span id='topic+denseMatrix-class'></span><span id='topic+-+2CdenseMatrix+2Cmissing-method'></span><span id='topic+Math+2CdenseMatrix-method'></span><span id='topic+Summary+2CdenseMatrix-method'></span><span id='topic+coerce+2CANY+2CdenseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdenseMatrix-method'></span><span id='topic+coerce+2Cvector+2CdenseMatrix-method'></span><span id='topic+diag+2CdenseMatrix-method'></span><span id='topic+diag+3C-+2CdenseMatrix-method'></span><span id='topic+diff+2CdenseMatrix-method'></span><span id='topic+dim+3C-+2CdenseMatrix-method'></span><span id='topic+log+2CdenseMatrix-method'></span><span id='topic+mean+2CdenseMatrix-method'></span><span id='topic+rep+2CdenseMatrix-method'></span><span id='topic+show+2CdenseMatrix-method'></span><span id='topic+t+2CdenseMatrix-method'></span>

<h3>Description</h3>

<p>This is the virtual class of all dense (S4) matrices.
It partitions into two subclasses
<code><a href="#topic+packedMatrix-class">packedMatrix</a></code> and
<code><a href="#topic+unpackedMatrix-class">unpackedMatrix</a></code>.
Alternatively into the (currently) three subclasses
<code><a href="#topic+ddenseMatrix-class">ddenseMatrix</a></code>,
<code><a href="#topic+ldenseMatrix-class">ldenseMatrix</a></code>, and
<code><a href="#topic+ndenseMatrix-class">ndenseMatrix</a></code>.
</p>
<p><code>denseMatrix</code> is (hence) the direct superclass of these (<code class="reqn">2+3 = 5</code>) classes.
</p>


<h3>Extends</h3>

<p>class <code>"Matrix"</code> directly.
</p>


<h3>Slots</h3>

<p>exactly those of its superclass <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>, i.e.,
<code>"Dim"</code> and <code>"Dimnames"</code>.
</p>


<h3>Methods</h3>

<p>Use <code><a href="methods.html#topic+showMethods">showMethods</a>(class = "denseMatrix", where =
    "package:Matrix")</code> for an overview of methods.
</p>
<p>Extraction (<code>"["</code>) methods,
see <code><a href="#topic++5B-methods">[-methods</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colSums">colSums</a></code>, <code><a href="#topic+kronecker">kronecker</a></code>, and other such methods
with own help pages.
</p>
<p>Its superclass <code><a href="#topic+Matrix-class">Matrix</a></code>, and main subclasses,
<code><a href="#topic+ddenseMatrix-class">ddenseMatrix</a></code> and <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("denseMatrix")
</code></pre>

<hr>
<h2 id='dgCMatrix-class'>Compressed, sparse, column-oriented numeric matrices</h2><span id='topic+dgCMatrix-class'></span><span id='topic+Arith+2CdgCMatrix+2CdgCMatrix-method'></span><span id='topic+Arith+2CdgCMatrix+2Clogical-method'></span><span id='topic+Arith+2CdgCMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CdgCMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CdgCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdgCMatrix-method'></span><span id='topic+determinant+2CdgCMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The <code>dgCMatrix</code> class is a class of sparse numeric
matrices in the compressed, sparse, column-oriented format.  In this
implementation the non-zero elements in the columns are sorted into
increasing row order.  <code>dgCMatrix</code> is the
<em>&ldquo;standard&rdquo;</em> class for sparse numeric matrices in the
<span class="pkg">Matrix</span> package.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dgCMatrix",
    ...)</code>, more typically via <code>as(*, "CsparseMatrix")</code> or similar.
Often however, more easily via <code><a href="#topic+Matrix">Matrix</a>(*, sparse = TRUE)</code>,
or most efficiently via <code><a href="#topic+sparseMatrix">sparseMatrix</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the non-zero
elements of the matrix.</p>
</dd>
<dt>...</dt><dd><p>all other slots are inherited from the superclass
<code>"<a href="#topic+CsparseMatrix-class">CsparseMatrix</a>"</code>.
</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Matrix products (e.g., <a href="#topic+crossprod-methods">crossprod-methods</a>), and (among other)
</p>

<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "dgCMatrix")</code></p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "dgCMatrix")</code>: returns the diagonal
of <code>x</code></p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "dgCMatrix")</code>: returns the dimensions
of <code>x</code></p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "dgCMatrix")</code>: plots an image of
<code>x</code> using the <code><a href="lattice.html#topic+levelplot">levelplot</a></code> function</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dgCMatrix", b = "...")</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>, notably the extra argument
<code>sparse</code>.</p>
</dd>
<dt>lu</dt><dd><p><code>signature(x = "dgCMatrix")</code>: computes the LU
decomposition of a square <code>dgCMatrix</code> object</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>,
<code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>, <code><a href="#topic+lu">lu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m &lt;- Matrix(c(0,0,2:0), 3,5))
str(m)
m[,1]

</code></pre>

<hr>
<h2 id='dgeMatrix-class'>Class &quot;dgeMatrix&quot; of Dense Numeric (S4 Class) Matrices</h2><span id='topic+dgeMatrix-class'></span><span id='topic+Arith+2CdgeMatrix+2CdgeMatrix-method'></span><span id='topic+Arith+2CdgeMatrix+2Clogical-method'></span><span id='topic+Arith+2CdgeMatrix+2Cnumeric-method'></span><span id='topic+Arith+2CdgeMatrix+2CsparseVector-method'></span><span id='topic+Arith+2Clogical+2CdgeMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CdgeMatrix-method'></span><span id='topic+determinant+2CdgeMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>A general numeric dense matrix in the S4 Matrix
representation.  <code>dgeMatrix</code> is the <em>&ldquo;standard&rdquo;</em>
class for dense numeric matrices in the <span class="pkg">Matrix</span> package.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dgeMatrix", ...)</code>
or, more commonly, by coercion from the <code>Matrix</code> class (see
<a href="#topic+Matrix-class">Matrix</a>) or by <code><a href="#topic+Matrix">Matrix</a>(..)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the numeric
values contained in the matrix, in column-major order.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>a list of length two - inherited from class
<code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code> - a list
of factorizations of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The are group methods (see, e.g., <code><a href="methods.html#topic+Arith">Arith</a></code>)
</p>

<dl>
<dt>Arith</dt><dd><p><code>signature(e1 = "dgeMatrix", e2 = "dgeMatrix")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "dgeMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "numeric", e2 = "dgeMatrix")</code>: ... </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "dgeMatrix")</code>: ... </p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "dgeMatrix", digits = "numeric")</code>: ...</p>
</dd>
</dl>

<p>matrix products <code><a href="#topic+crossprod-methods">%*%</a></code>,
<code><a href="#topic+crossprod-methods">crossprod</a>()</code> and <code>tcrossprod()</code>,
several <code><a href="#topic+solve">solve</a></code> methods,
and other matrix methods available:
</p>

<dl>
<dt>Schur</dt><dd><p><code>signature(x = "dgeMatrix", vectors = "logical")</code>: ... </p>
</dd>
<dt>Schur</dt><dd><p><code>signature(x = "dgeMatrix", vectors = "missing")</code>: ... </p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "dgeMatrix")</code>: see <code><a href="#topic+chol">chol</a></code>.</p>
</dd>
<dt>colMeans</dt><dd><p><code>signature(x = "dgeMatrix")</code>: columnwise means (averages)</p>
</dd>
<dt>colSums</dt><dd><p><code>signature(x = "dgeMatrix")</code>: columnwise sums</p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "dgeMatrix")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "dgeMatrix")</code>: ... </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "dgeMatrix")</code>: ... </p>
</dd>
<dt>eigen</dt><dd><p><code>signature(x = "dgeMatrix", only.values= "logical")</code>: ...</p>
</dd>
<dt>eigen</dt><dd><p><code>signature(x = "dgeMatrix", only.values= "missing")</code>: ...</p>
</dd>
<dt>norm</dt><dd><p><code>signature(x = "dgeMatrix", type = "character")</code>: ... </p>
</dd>
<dt>norm</dt><dd><p><code>signature(x = "dgeMatrix", type = "missing")</code>: ... </p>
</dd>
<dt>rcond</dt><dd><p><code>signature(x = "dgeMatrix", norm = "character")</code>
or <code>norm = "missing"</code>:
the reciprocal condition number, <code><a href="#topic+rcond">rcond</a>()</code>.</p>
</dd>
<dt>rowMeans</dt><dd><p><code>signature(x = "dgeMatrix")</code>: rowwise means (averages)</p>
</dd>
<dt>rowSums</dt><dd><p><code>signature(x = "dgeMatrix")</code>: rowwise sums</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dgeMatrix")</code>: matrix transpose</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes <code><a href="#topic+Matrix-class">Matrix</a></code>,
<code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code>, and <code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code>.
</p>

<hr>
<h2 id='dgRMatrix-class'>Sparse Compressed, Row-oriented Numeric Matrices</h2><span id='topic+dgRMatrix-class'></span><span id='topic+determinant+2CdgRMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The <code>dgRMatrix</code> class is a class of sparse numeric
matrices in the compressed, sparse, row-oriented format.  In this
implementation the non-zero elements in the rows are sorted into
increasing column order.
</p>
<p><b>Note:</b> The column-oriented sparse classes, e.g.,
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, are preferred and better supported in
the <span class="pkg">Matrix</span> package.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dgRMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the column numbers for
each non-zero element in the matrix.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each row, to the initial (zero-based) index of elements in
the row.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the non-zero
elements of the matrix.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>diag</dt><dd><p><code>signature(x = "dgRMatrix")</code>: returns the diagonal
of <code>x</code></p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "dgRMatrix")</code>: returns the dimensions
of <code>x</code></p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "dgRMatrix")</code>: plots an image of
<code>x</code> using the <code><a href="lattice.html#topic+levelplot">levelplot</a></code> function</p>
</dd>
</dl>



<h3>See Also</h3>

<p>the <code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code> class, the virtual class of all
sparse compressed <b>r</b>ow-oriented matrices, with its methods.
The <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> class (<b>c</b>olumn compressed
sparse) is really preferred.
</p>

<hr>
<h2 id='dgTMatrix-class'>Sparse matrices in triplet form</h2><span id='topic+dgTMatrix-class'></span><span id='topic++2B+2CdgTMatrix+2CdgTMatrix-method'></span><span id='topic+determinant+2CdgTMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The <code>"dgTMatrix"</code> class is the class of sparse
matrices stored as (possibly redundant) triplets.  The internal
representation is not at all unique, contrary to the one for class
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("dgTMatrix", ...)</code>, but more typically via
<code><a href="#topic+spMatrix">spMatrix</a>()</code> or <code><a href="#topic+sparseMatrix">sparseMatrix</a>(*, repr = "T")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>i</code>:</dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> row indices of non-zero
entries <em>in 0-base</em>, i.e., must be in <code>0:(nrow(.)-1)</code>.</p>
</dd>
<dt><code>j</code>:</dt><dd><p><code><a href="base.html#topic+integer">integer</a></code> column indices of non-zero
entries.  Must be the same length as slot <code>i</code> and
<em>0-based</em> as well, i.e., in <code>0:(ncol(.)-1)</code>.</p>
</dd>
<dt><code>x</code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> vector - the (non-zero)
entry at position <code>(i,j)</code>.  Must be the same length as slot
<code>i</code>.  If an index pair occurs more than once, the corresponding
values of slot <code>x</code> are added to form the element of the matrix.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> of length 2 -
the dimensions of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>+</dt><dd><p><code>signature(e1 = "dgTMatrix", e2 = "dgTMatrix")</code></p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "dgTMatrix")</code>: plots an image of
<code>x</code> using the <code><a href="lattice.html#topic+levelplot">levelplot</a></code> function</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dgTMatrix")</code>: returns the transpose of
<code>x</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>Triplet matrices are a convenient form in which to construct sparse
matrices after which they can be coerced to
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> objects.
</p>
<p>Note that both <code>new(.)</code> and <code><a href="#topic+spMatrix">spMatrix</a></code> constructors
for <code>"dgTMatrix"</code> (and other <code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code>
classes) implicitly add <code class="reqn">x_k</code>'s that belong to identical
<code class="reqn">(i_k, j_k)</code> pairs.
</p>
<p>However this means that a matrix typically can be stored in more than
one possible <code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code> representations.
Use <code><a href="#topic+asUniqueT">asUniqueT</a>()</code> in order to ensure uniqueness of the
internal representation of such a matrix.
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> or the superclasses
<code><a href="#topic+dsparseMatrix-class">dsparseMatrix</a></code> and
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>; <code><a href="#topic+asUniqueT">asUniqueT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- Matrix(0+1:28, nrow = 4)
m[-3,c(2,4:5,7)] &lt;- m[ 3, 1:4] &lt;- m[1:3, 6] &lt;- 0
(mT &lt;- as(m, "TsparseMatrix"))
str(mT)
mT[1,]
mT[4, drop = FALSE]
stopifnot(identical(mT[lower.tri(mT)],
                    m [lower.tri(m) ]))
mT[lower.tri(mT,diag=TRUE)] &lt;- 0
mT

## Triplet representation with repeated (i,j) entries
## *adds* the corresponding x's:
T2 &lt;- new("dgTMatrix",
          i = as.integer(c(1,1,0,3,3)),
          j = as.integer(c(2,2,4,0,0)), x=10*1:5, Dim=4:5)
str(T2) # contains (i,j,x) slots exactly as above, but
T2 ## has only three non-zero entries, as for repeated (i,j)'s,
   ## the corresponding x's are "implicitly" added
stopifnot(nnzero(T2) == 3)
</code></pre>

<hr>
<h2 id='Diagonal'>Construct a Diagonal Matrix</h2><span id='topic+Diagonal'></span><span id='topic+.sparseDiagonal'></span><span id='topic+.trDiagonal'></span><span id='topic+.symDiagonal'></span>

<h3>Description</h3>

<p>Construct a formally diagonal <code><a href="#topic+Matrix-class">Matrix</a></code>,
i.e., an object inheriting from virtual class
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>
(or, if desired, a <em>mathematically</em> diagonal
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diagonal(n, x = NULL, names = FALSE)

.sparseDiagonal(n, x = NULL, uplo = "U", shape = "t", unitri = TRUE, kind, cols)
    .trDiagonal(n, x = NULL, uplo = "U", unitri = TRUE, kind)
   .symDiagonal(n, x = NULL, uplo = "U", kind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diagonal_+3A_n">n</code></td>
<td>
<p>integer indicating the dimension of the (square) matrix.
If missing, then <code>length(x)</code> is used.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_x">x</code></td>
<td>
<p>numeric or logical vector listing values for the diagonal
entries, to be recycled as necessary.  If <code>NULL</code> (the default),
then the result is a unit diagonal matrix.  <code>.sparseDiagonal()</code>
and friends ignore non-<code>NULL</code> <code>x</code> when <code>kind = "n"</code>.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_names">names</code></td>
<td>
<p>either <code><a href="base.html#topic+logical">logical</a></code> <code>TRUE</code> or <code>FALSE</code> or
then a <code><a href="base.html#topic+character">character</a></code> vector of <code><a href="base.html#topic+length">length</a></code>
<code>n</code>.  If true <em>and</em> <code><a href="base.html#topic+names">names</a>(x)</code> is not
<code>NULL</code>, use that as both row and column names for the resulting
matrix.  When a character vector, use it for both dimnames.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_uplo">uplo</code></td>
<td>
<p>one of <code>c("U","L")</code>, specifying the <code>uplo</code> slot
of the result if the result is formally triangular of symmetric.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_shape">shape</code></td>
<td>
<p>one of <code>c("t","s","g")</code>, indicating if the result
should be formally triangular, symmetric, or &ldquo;general&rdquo;.
The result will inherit from virtual class
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>,
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>, or
<code><a href="#topic+generalMatrix-class">generalMatrix</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_unitri">unitri</code></td>
<td>
<p>logical indicating if a formally triangular result with
ones on the diagonal should be formally <em>unit</em> triangular, i.e.,
with <code>diag</code> slot equal to <code>"U"</code> rather than <code>"N"</code>.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_kind">kind</code></td>
<td>
<p>one of <code>c("d","l","n")</code>, indicating the &ldquo;mode&rdquo;
of the result: numeric, logical, or pattern.
The result will inherit from virtual class
<code><a href="#topic+dsparseMatrix-class">dsparseMatrix</a></code>,
<code><a href="#topic+lsparseMatrix-class">lsparseMatrix</a></code>, or
<code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>, respectively.
Values other than <code>"n"</code> are ignored when <code>x</code> is
non-<code>NULL</code>; in that case the mode is determined by
<code><a href="base.html#topic+typeof">typeof</a>(x)</code>.</p>
</td></tr>
<tr><td><code id="Diagonal_+3A_cols">cols</code></td>
<td>
<p>optional integer vector with values in <code>0:(n-1)</code>,
indexing columns of the specified diagonal matrix.  If specified,
then the result is (mathematically) <code>D[, cols+1]</code> rather
than <code>D</code>, where <code>D = Diagonal(n, x)</code>, and it is always
&ldquo;general&rdquo; (i.e., <code>shape</code> is ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Diagonal()</code> returns an object inheriting from virtual class
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>.
</p>
<p><code>.sparseDiagonal()</code> returns a <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>
representation of <code>Diagonal(n, x)</code> or, if <code>cols</code> is given,
of <code>Diagonal(n, x)[, cols+1]</code>.  The precise class of the result
depends on <code>shape</code> and <code>kind</code>.
</p>
<p><code>.trDiagonal()</code> and <code>.symDiagonal()</code> are simple wrappers,
for <code>.sparseDiagonal(shape = "t")</code> and
<code>.sparseDiagonal(shape = "s")</code>, respectively.
</p>
<p><code>.sparseDiagonal()</code> exists primarily to leverage efficient
C-level methods available for <code>CsparseMatrix</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>the generic function <code><a href="base.html#topic+diag">diag</a></code> for <em>extraction</em>
of the diagonal from a matrix works for all &ldquo;Matrices&rdquo;.
</p>
<p><code><a href="#topic+bandSparse">bandSparse</a></code> constructs a <em>banded</em> sparse matrix from
its non-zero sub-/super - diagonals.  <code><a href="#topic+band">band</a>(A)</code> returns a
band matrix containing some sub-/super - diagonals of <code>A</code>.
</p>
<p><code><a href="#topic+Matrix">Matrix</a></code> for general matrix construction;
further, class <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Diagonal(3)
Diagonal(x = 10^(3:1))
Diagonal(x = (1:4) &gt;= 2)#-&gt; "ldiMatrix"

## Use Diagonal() + kronecker() for "repeated-block" matrices:
M1 &lt;- Matrix(0+0:5, 2,3)
(M &lt;- kronecker(Diagonal(3), M1))

(S &lt;- crossprod(Matrix(rbinom(60, size=1, prob=0.1), 10,6)))
(SI &lt;- S + 10*.symDiagonal(6)) # sparse symmetric still
stopifnot(is(SI, "dsCMatrix"))
(I4 &lt;- .sparseDiagonal(4, shape="t"))# now (2012-10) unitriangular
stopifnot(I4@diag == "U", all(I4 == diag(4)))

</code></pre>

<hr>
<h2 id='diagonalMatrix-class'>Class &quot;diagonalMatrix&quot; of Diagonal Matrices</h2><span id='topic+diagonalMatrix-class'></span><span id='topic+-+2CdiagonalMatrix+2Cmissing-method'></span><span id='topic+Math+2CdiagonalMatrix-method'></span><span id='topic+Ops+2CdiagonalMatrix+2CtriangularMatrix-method'></span><span id='topic+Summary+2CdiagonalMatrix-method'></span><span id='topic+coerce+2CdiagonalMatrix+2CsymmetricMatrix-method'></span><span id='topic+coerce+2CdiagonalMatrix+2CtriangularMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdiagonalMatrix-method'></span><span id='topic+determinant+2CdiagonalMatrix+2Clogical-method'></span><span id='topic+diag+2CdiagonalMatrix-method'></span><span id='topic+diag+3C-+2CdiagonalMatrix-method'></span><span id='topic+log+2CdiagonalMatrix-method'></span><span id='topic+print+2CdiagonalMatrix-method'></span><span id='topic+show+2CdiagonalMatrix-method'></span><span id='topic+summary+2CdiagonalMatrix-method'></span><span id='topic+t+2CdiagonalMatrix-method'></span>

<h3>Description</h3>

<p>Class &quot;diagonalMatrix&quot; is the virtual class of all diagonal matrices.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be
created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>diag</code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string, either <code>"U"</code> or
<code>"N"</code>, where <code>"U"</code> means &lsquo;unit-diagonal&rsquo;.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>matrix dimension, and</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>the <code><a href="base.html#topic+dimnames">dimnames</a></code>, a
<code><a href="base.html#topic+list">list</a></code>, see the <code><a href="#topic+Matrix-class">Matrix</a></code> class
description.  Typically <code>list(NULL,NULL)</code> for diagonal matrices.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sparseMatrix-class">sparseMatrix</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>These are just a subset of the signature for which defined methods.
Currently, there are (too) many explicit methods defined in order to
ensure efficient methods for diagonal matrices.
</p>

<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "diagonalMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "Matrix", to = "diagonalMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "diagonalMatrix", to = "generalMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "diagonalMatrix", to = "triangularMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "diagonalMatrix", to = "nMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "diagonalMatrix", to = "matrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "diagonalMatrix", to = "sparseVector")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "diagonalMatrix")</code>: ... </p>
</dd>
</dl>
<p><br /> and many more methods
</p>
<dl>
<dt>solve</dt><dd><p><code>signature(a = "diagonalMatrix", b, ...)</code>: is
trivially implemented, of course; see also <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "nMatrix")</code>, semantically
equivalent to <span class="pkg">base</span> function <code><a href="base.html#topic+which">which</a>(x, arr.ind)</code>.</p>
</dd>
<dt>&quot;Math&quot;</dt><dd><p><code>signature(x = "diagonalMatrix")</code>: all these
group methods return a <code>"diagonalMatrix"</code>, apart from
<code><a href="base.html#topic+cumsum">cumsum</a>()</code> etc which return a <em>vector</em> also for
<span class="pkg">base</span> <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "ddiMatrix", e2="denseMatrix")</code>:
arithmetic and other operators from the <code><a href="methods.html#topic+S4groupGeneric">Ops</a></code>
group have a few dozen explicit method definitions, in order to
keep the results <em>diagonal</em> in many cases, including the following:</p>
</dd>
<dt>/</dt><dd><p><code>signature(e1 = "ddiMatrix", e2="denseMatrix")</code>:
the result is from class <code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code> which is
typically very desirable.  Note that when <code>e2</code> contains
off-diagonal zeros or <code><a href="base.html#topic+NA">NA</a></code>s, we implicitly use <code class="reqn">0 / x = 0</code>, hence
differing from traditional <span class="rlang"><b>R</b></span> arithmetic (where <code class="reqn">0 / 0
	\mapsto \mbox{NaN}</code>), in order to preserve sparsity.</p>
</dd>
<dt>summary</dt><dd><p><code>(object = "diagonalMatrix")</code>: Returns
an object of S3 class <code>"diagSummary"</code> which is the summary of
the vector <code>object@x</code> plus a simple heading, and an
appropriate <code><a href="base.html#topic+print">print</a></code> method.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Diagonal">Diagonal</a>()</code> as constructor of these matrices, and
<code><a href="#topic+isDiagonal">isDiagonal</a></code>.
<code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code> and <code><a href="#topic+ldiMatrix-class">ldiMatrix</a></code> are
&ldquo;actual&rdquo; classes extending <code>"diagonalMatrix"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>I5 &lt;- Diagonal(5)
D5 &lt;- Diagonal(x = 10*(1:5))
## trivial (but explicitly defined) methods:
stopifnot(identical(crossprod(I5), I5),
          identical(tcrossprod(I5), I5),
          identical(crossprod(I5, D5), D5),
          identical(tcrossprod(D5, I5), D5),
          identical(solve(D5), solve(D5, I5)),
          all.equal(D5, solve(solve(D5)), tolerance = 1e-12)
          )
solve(D5)# efficient as is diagonal

# an unusual way to construct a band matrix:
rbind2(cbind2(I5, D5),
       cbind2(D5, I5))
</code></pre>

<hr>
<h2 id='diagU2N'>Transform Triangular Matrices from Unit Triangular to General Triangular and Back</h2><span id='topic+diagU2N'></span><span id='topic+diagN2U'></span><span id='topic+.diagU2N'></span><span id='topic+.diagN2U'></span>

<h3>Description</h3>

<p>Transform a triangular matrix <code>x</code>, i.e., of <code><a href="base.html#topic+class">class</a></code>
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>,
from (internally!) unit triangular (&ldquo;unitriangular&rdquo;) to
&ldquo;general&rdquo; triangular (<code>diagU2N(x)</code>) or back (<code>diagN2U(x)</code>).
Note that the latter, <code>diagN2U(x)</code>, also sets the diagonal to one
in cases where <code>diag(x)</code> was not all one.
</p>
<p><code>.diagU2N(x)</code> and <code>.diagN2U(x)</code> assume <em>without</em>
checking that <code>x</code> is a <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code> with
suitable <code>diag</code> slot (<code>"U"</code> and <code>"N"</code>, respectively),
hence they should be used with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> diagU2N(x, cl = getClassDef(class(x)), checkDense = FALSE)
 diagN2U(x, cl = getClassDef(class(x)), checkDense = FALSE)

.diagU2N(x, cl = getClassDef(class(x)), checkDense = FALSE)
.diagN2U(x, cl = getClassDef(class(x)), checkDense = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagU2N_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>, often sparse.</p>
</td></tr>
<tr><td><code id="diagU2N_+3A_cl">cl</code></td>
<td>
<p>(optional, for speedup only:) class (definition) of <code>x</code>.</p>
</td></tr>
<tr><td><code id="diagU2N_+3A_checkdense">checkDense</code></td>
<td>
<p>logical indicating if dense (see
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code>) matrices should be considered at
all; i.e., when false, as per default, the result will be sparse even
when <code>x</code> is dense.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept of unit triangular matrices with a <code>diag</code> slot of
<code>"U"</code> stems from LAPACK.
</p>


<h3>Value</h3>

<p>a triangular matrix of the same <code><a href="base.html#topic+class">class</a></code> but with a
different <code>diag</code> slot.  For <code>diagU2N</code> (semantically) with
identical entries as <code>x</code>, whereas in <code>diagN2U(x)</code>, the
off-diagonal entries are unchanged and the diagonal is set to all
<code>1</code> even if it was not previously.
</p>


<h3>Note</h3>

<p>Such internal storage details should rarely be of relevance to the
user.  Hence, these functions really are rather <em>internal</em>
utilities.
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+triangularMatrix-class">triangularMatrix</a>"</code>,
<code>"<a href="#topic+dtCMatrix-class">dtCMatrix</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(T &lt;- Diagonal(7) + triu(Matrix(rpois(49, 1/4), 7, 7), k = 1))
(uT &lt;- diagN2U(T)) # "unitriangular"
(t.u &lt;- diagN2U(10*T))# changes the diagonal!
stopifnot(all(T == uT), diag(t.u) == 1,
          identical(T, diagU2N(uT)))
T[upper.tri(T)] &lt;- 5 # still "dtC"
T &lt;- diagN2U(as(T,"triangularMatrix"))
dT &lt;- as(T, "denseMatrix") # (unitriangular)
dT.n &lt;- diagU2N(dT, checkDense = TRUE)
sT.n &lt;- diagU2N(dT)
stopifnot(is(dT.n, "denseMatrix"), is(sT.n, "sparseMatrix"),
          dT@diag == "U", dT.n@diag == "N", sT.n@diag == "N",
          all(dT == dT.n), all(dT == sT.n))
</code></pre>

<hr>
<h2 id='dimScale'>Scale the Rows and Columns of a Matrix</h2><span id='topic+dimScale'></span><span id='topic+rowScale'></span><span id='topic+colScale'></span>

<h3>Description</h3>

<p><code>dimScale</code>, <code>rowScale</code>, and <code>colScale</code> implement
<code>D1 %*% x %*% D2</code>, <code>D %*% x</code>, and <code>x %*% D</code>
for diagonal matrices <code>D1</code>, <code>D2</code>, and <code>D</code> with
diagonal entries <code>d1</code>, <code>d2</code>, and <code>d</code>, respectively.
Unlike the explicit products, these functions preserve <code>dimnames(x)</code>
and symmetry where appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimScale(x, d1 = sqrt(1/diag(x, names = FALSE)), d2 = d1)
rowScale(x, d)
colScale(x, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimScale_+3A_x">x</code></td>
<td>
<p>a matrix, possibly inheriting from virtual class
<code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</td></tr>
<tr><td><code id="dimScale_+3A_d1">d1</code>, <code id="dimScale_+3A_d2">d2</code>, <code id="dimScale_+3A_d">d</code></td>
<td>
<p>numeric vectors giving factors by which to scale
the rows or columns of <code>x</code>; they are recycled as necessary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dimScale(x)</code> (with <code>d1</code> and <code>d2</code> unset) is only
roughly equivalent to <code><a href="stats.html#topic+cov2cor">cov2cor</a>(x)</code>.  <code>cov2cor</code>
sets the diagonal entries of the result to 1 (exactly);
<code>dimScale</code> does not.
</p>


<h3>Value</h3>

<p>The result of scaling <code>x</code>, currently always inheriting from
virtual class <code><a href="#topic+dMatrix-class">dMatrix</a></code>.
</p>
<p>It inherits from <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code> if and only
if <code>x</code> does.  In the special case of <code>dimScale(x, d1, d2)</code>
with identical <code>d1</code> and <code>d2</code>, it inherits from
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code> if and only if <code>x</code> does.
</p>


<h3>Author(s)</h3>

<p>Mikael Jagan</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov2cor">cov2cor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 6L
(x &lt;- forceSymmetric(matrix(1, n, n)))
dimnames(x) &lt;- rep.int(list(letters[seq_len(n)]), 2L)

d &lt;- seq_len(n)
(D &lt;- Diagonal(x = d))

(scx &lt;- dimScale(x, d)) # symmetry and 'dimnames' kept
(mmx &lt;- D %*% x %*% D) # symmetry and 'dimnames' lost
stopifnot(identical(unname(as(scx, "generalMatrix")), mmx))

rowScale(x, d)
colScale(x, d)
</code></pre>

<hr>
<h2 id='dMatrix-class'>(Virtual) Class &quot;dMatrix&quot; of &quot;double&quot; Matrices</h2><span id='topic+dMatrix-class'></span><span id='topic+lMatrix-class'></span><span id='topic+Compare+2CdMatrix+2Clogical-method'></span><span id='topic+Compare+2CdMatrix+2Cnumeric-method'></span><span id='topic+Compare+2Clogical+2CdMatrix-method'></span><span id='topic+Compare+2Cnumeric+2CdMatrix-method'></span><span id='topic+Logic+2CdMatrix+2Clogical-method'></span><span id='topic+Logic+2CdMatrix+2Cnumeric-method'></span><span id='topic+Logic+2CdMatrix+2CsparseVector-method'></span><span id='topic+Logic+2Clogical+2CdMatrix-method'></span><span id='topic+Logic+2Cnumeric+2CdMatrix-method'></span><span id='topic+Ops+2CdMatrix+2CdMatrix-method'></span><span id='topic+Ops+2CdMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CdMatrix+2ClMatrix-method'></span><span id='topic+Ops+2CdMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CdMatrix+2CnMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdMatrix-method'></span><span id='topic+coerce+2Cvector+2CdMatrix-method'></span><span id='topic+Arith+2ClMatrix+2Cnumeric-method'></span><span id='topic+Arith+2ClMatrix+2Clogical-method'></span><span id='topic+Arith+2Clogical+2ClMatrix-method'></span><span id='topic+Arith+2Cnumeric+2ClMatrix-method'></span><span id='topic+Compare+2ClMatrix+2Clogical-method'></span><span id='topic+Compare+2ClMatrix+2Cnumeric-method'></span><span id='topic+Compare+2Clogical+2ClMatrix-method'></span><span id='topic+Compare+2Cnumeric+2ClMatrix-method'></span><span id='topic+Logic+2ClMatrix+2Clogical-method'></span><span id='topic+Logic+2ClMatrix+2Cnumeric-method'></span><span id='topic+Logic+2ClMatrix+2CsparseVector-method'></span><span id='topic+Logic+2Clogical+2ClMatrix-method'></span><span id='topic+Logic+2Cnumeric+2ClMatrix-method'></span><span id='topic+Ops+2ClMatrix+2CdMatrix-method'></span><span id='topic+Ops+2ClMatrix+2ClMatrix-method'></span><span id='topic+Ops+2ClMatrix+2CnMatrix-method'></span><span id='topic+Ops+2ClMatrix+2Cnumeric-method'></span><span id='topic+Ops+2Cnumeric+2ClMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClMatrix-method'></span><span id='topic+coerce+2Cvector+2ClMatrix-method'></span>

<h3>Description</h3>

<p>The <code>dMatrix</code> class is a virtual class contained by all actual
classes of numeric matrices in the <span class="pkg">Matrix</span> package.  Similarly,
all the actual classes of logical matrices inherit from the
<code>lMatrix</code> class.
</p>


<h3>Slots</h3>

<p>Common to <em>all</em> matrix object in the package:
</p>

<dl>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>list of length two; each component
containing NULL or a <code><a href="base.html#topic+character">character</a></code> vector length
equal the corresponding <code>Dim</code> element.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>There are (relatively simple) group methods (see, e.g., <code><a href="methods.html#topic+Arith">Arith</a></code>)
</p>

<dl>
<dt>Arith</dt><dd><p><code>signature(e1 = "dMatrix", e2 = "dMatrix")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "dMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "numeric", e2 = "dMatrix")</code>: ... </p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "dMatrix")</code>: ... </p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "dMatrix", digits = "numeric")</code>:
this group contains <code><a href="base.html#topic+round">round</a>()</code> and <code><a href="base.html#topic+signif">signif</a>()</code>.</p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "numeric", e2 = "dMatrix")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "dMatrix", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "dMatrix", e2 = "dMatrix")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "dMatrix")</code>: The <code>"Summary"</code>
group contains the seven functions
<code><a href="base.html#topic+max">max</a>()</code>, <code><a href="base.html#topic+min">min</a>()</code>, <code><a href="base.html#topic+range">range</a>()</code>,
<code><a href="base.html#topic+prod">prod</a>()</code>, <code><a href="base.html#topic+sum">sum</a>()</code>,
<code><a href="base.html#topic+any">any</a>()</code>, and <code><a href="base.html#topic+all">all</a>()</code>.</p>
</dd>
</dl>

<p>The following methods are also defined for all double matrices:
</p>

<dl>
<dt>expm</dt><dd><p><code>signature(x = "dMatrix")</code>: computes the
<em>&ldquo;Matrix Exponential&rdquo;</em>, see <code><a href="#topic+expm">expm</a></code>.</p>
</dd>
</dl>

<p>The following methods are defined for all logical matrices:
</p>

<dl>
<dt>which</dt><dd><p><code>signature(x = "lsparseMatrix")</code> and many other
subclasses of <code>"lMatrix"</code>: as the <span class="pkg">base</span> function
<code><a href="base.html#topic+which">which</a>(x, arr.ind)</code> returns the indices of the
<code><a href="base.html#topic+TRUE">TRUE</a></code> entries in <code>x</code>; if <code>arr.ind</code> is true,
as a 2-column matrix of row and column indices. Since <span class="pkg">Matrix</span>
version 1.2-9, if <code>useNames</code> is true, as by default, with
<code><a href="base.html#topic+dimnames">dimnames</a></code>, the same as <code>base::which</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The nonzero-pattern matrix class <code><a href="#topic+nMatrix-class">nMatrix</a></code>, which
can be used to store non-<code><a href="base.html#topic+NA">NA</a></code> <code><a href="base.html#topic+logical">logical</a></code>
matrices even more compactly.
</p>
<p>The numeric matrix classes <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>,
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, and <code><a href="#topic+Matrix-class">Matrix</a></code>.
</p>
<p><code><a href="#topic+drop0">drop0</a>(x, tol=1e-10)</code> is sometimes preferable to (and
more efficient than) <code>zapsmall(x, digits=10)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 showClass("dMatrix")

 set.seed(101)
 round(Matrix(rnorm(28), 4,7), 2)
 M &lt;- Matrix(rlnorm(56, sd=10), 4,14)
 (M. &lt;- zapsmall(M))
 table(as.logical(M. == 0))
</code></pre>

<hr>
<h2 id='dmperm'>Dulmage-Mendelsohn Permutation / Decomposition</h2><span id='topic+dmperm'></span>

<h3>Description</h3>

<p>For any <code class="reqn">n \times m</code> (typically) sparse matrix <code>x</code>
compute the Dulmage-Mendelsohn row and columns permutations which at
first splits the <code class="reqn">n</code> rows and <code>m</code> columns into coarse partitions
each; and then a finer one, reordering rows and columns such that the
permutated matrix is &ldquo;as upper triangular&rdquo; as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmperm(x, nAns = 6L, seed = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmperm_+3A_x">x</code></td>
<td>
<p>a typically sparse matrix; internally coerced to either
<code>"<a href="#topic+dgCMatrix-class">dgCMatrix</a>"</code> or
<code>"<a href="#topic+dtCMatrix-class">dtCMatrix</a>"</code>.</p>
</td></tr>
<tr><td><code id="dmperm_+3A_nans">nAns</code></td>
<td>
<p>an integer specifying the <code><a href="base.html#topic+length">length</a></code> of the
resulting <code><a href="base.html#topic+list">list</a></code>.  Must be 2, 4, or 6.

</p>
</td></tr>
<tr><td><code id="dmperm_+3A_seed">seed</code></td>
<td>
<p>an integer code in -1,0,1; determining the (initial)
permutation; by default, <code>seed = 0</code>, no (or the identity) permutation;
<code>seed = -1</code> uses the &ldquo;reverse&rdquo; permutation <code>k:1</code>; for
<code>seed = 1</code>, it is a <em>random</em> permutation (using R's RNG,
seed, etc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the book section by Tim Davis; page 122&ndash;127, in the References.
</p>


<h3>Value</h3>

<p>a named <code><a href="base.html#topic+list">list</a></code> with (by default) 6 components,
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>integer vector with the permutation <code>p</code>, of length <code>nrow(x)</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>integer vector with the permutation <code>q</code>, of length <code>ncol(x)</code>.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>integer vector of length <code>nb+1</code>, where block k is rows r[k] to r[k+1]-1 in A[p,q].</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>integer vector of length <code>nb+1</code>, where block k is cols s[k] to s[k+1]-1 in A[p,q].</p>
</td></tr>
<tr><td><code>rr5</code></td>
<td>
<p>integer vector of length 5, defining the coarse row
decomposition.</p>
</td></tr>
<tr><td><code>cc5</code></td>
<td>
<p>integer vector of length 5, defining the coarse column decomposition.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler, with a lot of &ldquo;encouragement&rdquo; by Mauricio
Vargas.
</p>


<h3>References</h3>

<p>Section 7.4 <em>Dulmage-Mendelsohn decomposition</em>, pp. 122 ff  of
<br />
Timothy A. Davis (2006)
<em>Direct Methods for Sparse Linear Systems</em>, SIAM Series
&ldquo;Fundamentals of Algorithms&rdquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Schur">Schur</a></code>, the class of permutation matrices; <code>"<a href="#topic+pMatrix-class">pMatrix</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(17)
(S9 &lt;- rsparsematrix(9, 9, nnz = 10, symmetric=TRUE)) # dsCMatrix
str( dm9 &lt;- dmperm(S9) )
(S9p &lt;- with(dm9, S9[p, q]))
## looks good, but *not* quite upper triangular; these, too:
str( dm9.0 &lt;- dmperm(S9, seed=-1)) # non-random too.
str( dm9_1 &lt;- dmperm(S9, seed= 1)) # a random one
## The last two permutations differ, but have the same effect!
(S9p0 &lt;- with(dm9.0, S9[p, q])) # .. hmm ..
stopifnot(all.equal(S9p0, S9p))# same as as default, but different from the random one


set.seed(11)
(M &lt;- triu(rsparsematrix(9,11, 1/4)))
dM &lt;- dmperm(M); with(dM, M[p, q])
(Mp &lt;- M[sample.int(nrow(M)), sample.int(ncol(M))])
dMp &lt;- dmperm(Mp); with(dMp, Mp[p, q])


set.seed(7)
(n7 &lt;- rsparsematrix(5, 12, nnz = 10, rand.x = NULL))
str( dm.7 &lt;- dmperm(n7) )
stopifnot(exprs = {
  lengths(dm.7[1:2]) == dim(n7)
  identical(dm.7,      dmperm(as(n7, "dMatrix")))
  identical(dm.7[1:4], dmperm(n7, nAns=4))
  identical(dm.7[1:2], dmperm(n7, nAns=2))
})
</code></pre>

<hr>
<h2 id='dpoMatrix-class'>Positive Semi-definite Dense (Packed | Non-packed) Numeric Matrices</h2><span id='topic+dpoMatrix-class'></span><span id='topic+dppMatrix-class'></span><span id='topic+corMatrix-class'></span><span id='topic+copMatrix-class'></span><span id='topic+Arith+2CdpoMatrix+2Clogical-method'></span><span id='topic+Arith+2CdpoMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CdpoMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CdpoMatrix-method'></span><span id='topic+Ops+2CdpoMatrix+2Clogical-method'></span><span id='topic+Ops+2CdpoMatrix+2Cnumeric-method'></span><span id='topic+Ops+2Clogical+2CdpoMatrix-method'></span><span id='topic+Ops+2Cnumeric+2CdpoMatrix-method'></span><span id='topic+coerce+2CdpoMatrix+2CcorMatrix-method'></span><span id='topic+coerce+2CdpoMatrix+2CdppMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdpoMatrix-method'></span><span id='topic+determinant+2CdpoMatrix+2Clogical-method'></span><span id='topic+Arith+2CdppMatrix+2Clogical-method'></span><span id='topic+Arith+2CdppMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CdppMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CdppMatrix-method'></span><span id='topic+Ops+2CdppMatrix+2Clogical-method'></span><span id='topic+Ops+2CdppMatrix+2Cnumeric-method'></span><span id='topic+Ops+2Clogical+2CdppMatrix-method'></span><span id='topic+Ops+2Cnumeric+2CdppMatrix-method'></span><span id='topic+coerce+2CdppMatrix+2CcopMatrix-method'></span><span id='topic+coerce+2CdppMatrix+2CdpoMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdppMatrix-method'></span><span id='topic+determinant+2CdppMatrix+2Clogical-method'></span><span id='topic+coerce+2CcorMatrix+2CcopMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CcorMatrix-method'></span><span id='topic+coerce+2CcopMatrix+2CcorMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CcopMatrix-method'></span>

<h3>Description</h3>


<ul>
<li><p> The <code>"dpoMatrix"</code> class is the class of
positive-semidefinite symmetric matrices in nonpacked storage.
</p>
</li>
<li><p> The <code>"dppMatrix"</code> class is the same except in packed
storage.  Only the upper triangle or the lower triangle is
required to be available.
</p>
</li>
<li><p> The <code>"corMatrix"</code> and <code>"copMatrix"</code> classes
represent correlation matrices.  They extend <code>"dpoMatrix"</code>
and <code>"dppMatrix"</code>, respectively, with an additional slot
<code>sd</code> allowing restoration of the original covariance matrix.
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the
form <code>new("dpoMatrix", ...)</code> or from <code>crossprod</code> applied to
an <code>"dgeMatrix"</code> object.</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The numeric
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code>. The dimensions
of the matrix which must be a two-element vector of non-negative
integers.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>inherited from class <code>"Matrix"</code></p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
<dt><code>sd</code>:</dt><dd><p>(for <code>"corMatrix"</code> and <code>"copMatrix"</code>)
a <code><a href="base.html#topic+numeric">numeric</a></code> vector of length <code>n</code> containing the
(original) <code class="reqn">\sqrt{var(.)}</code> entries which allow
reconstruction of a covariance matrix from the correlation matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"dsyMatrix"</code>, directly.<br />
Classes <code>"dgeMatrix"</code>, <code>"symmetricMatrix"</code>, and many more
by class <code>"dsyMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>chol</dt><dd><p><code>signature(x = "dpoMatrix")</code>:
Returns (and stores) the Cholesky decomposition of <code>x</code>, see
<code><a href="#topic+chol">chol</a></code>.</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "dpoMatrix")</code>:
Returns the <code><a href="base.html#topic+determinant">determinant</a></code> of <code>x</code>, via
<code>chol(x)</code>, see above.</p>
</dd>
<dt>rcond</dt><dd><p><code>signature(x = "dpoMatrix", norm = "character")</code>:
Returns (and stores) the reciprocal of the condition number of
<code>x</code>.  The <code>norm</code> can be <code>"O"</code> for the
one-norm (the default) or <code>"I"</code> for the infinity-norm.  For
symmetric matrices the result does not depend on the norm.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dpoMatrix", b = "....")</code>, and</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dppMatrix", b = "....")</code>  work
via the Cholesky composition, see also the Matrix <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "dpoMatrix", e2 = "numeric")</code> (and
quite a few other signatures): The result of (&ldquo;elementwise&rdquo;
defined) arithmetic operations is typically <em>not</em>
positive-definite anymore.  The only exceptions, currently, are
multiplications, divisions or additions with <em>positive</em>
<code>length(.) == 1</code> numbers (or <code><a href="base.html#topic+logical">logical</a></code>s).</p>
</dd>
</dl>



<h3>Note</h3>

<p>Currently the validity methods for these classes such as
<code><a href="methods.html#topic+getValidity">getValidity</a>(getClass("dpoMatrix"))</code> for efficiency reasons
only check the diagonal entries of the matrix &ndash; they may not be negative.
This is only necessary but not sufficient for a symmetric matrix to be
positive semi-definite.
</p>
<p>A more reliable (but often more expensive) check for positive
semi-definiteness would look at the signs of <code>diag(<a href="#topic+BunchKaufman">BunchKaufman</a>(.))</code>
(with some tolerance for very small negative values), and for (strict)
positive definiteness at something like
<code>!inherits(tryCatch(chol(.), error=identity), "error")</code> .
Indeed, when <em>coercing</em> to these classes, a version
of <code><a href="#topic+Cholesky">Cholesky</a>()</code> or <code><a href="#topic+chol">chol</a>()</code> is
typically used, e.g., see <code>selectMethod("coerce",
    c(from="dsyMatrix", to="dpoMatrix"))</code> .
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> and <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>;
further, <code><a href="#topic+Matrix">Matrix</a></code>, <code><a href="#topic+rcond">rcond</a></code>,
<code><a href="base.html#topic+chol">chol</a></code>, <code><a href="base.html#topic+solve">solve</a></code>, <code><a href="#topic+crossprod">crossprod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h6 &lt;- Hilbert(6)
rcond(h6)
str(h6)
h6 * 27720 # is ``integer''
solve(h6)
str(hp6 &lt;- pack(h6))

### Note that  as(*, "corMatrix")  *scales* the matrix
(ch6 &lt;- as(h6, "corMatrix"))
stopifnot(all.equal(as(h6 * 27720, "dsyMatrix"), round(27720 * h6),
                    tolerance = 1e-14),
          all.equal(ch6@sd^(-2), 2*(1:6)-1,
                    tolerance = 1e-12))
chch &lt;- Cholesky(ch6, perm = FALSE)
stopifnot(identical(chch, ch6@factors$Cholesky),
          all(abs(crossprod(as(chch, "dtrMatrix")) - ch6) &lt; 1e-10))
</code></pre>

<hr>
<h2 id='drop0'>Drop Non-Structural Zeros from a Sparse Matrix</h2><span id='topic+drop0'></span>

<h3>Description</h3>

<p>Deletes &ldquo;non-structural&rdquo; zeros (i.e., zeros stored explicitly,
in memory) from a sparse matrix and returns the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop0(x, tol = 0, is.Csparse = NA, give.Csparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop0_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+Matrix-class">Matrix</a></code>, typically inheriting
from virtual class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code> and traditional vectors and
matrices are coerced to <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>,
with zeros dropped automatically, hence users passing such
<code>x</code> should consider <code>as(x, "CsparseMatrix")</code> instead,
notably in the <code>tol = 0</code> case.</p>
</td></tr>
<tr><td><code id="drop0_+3A_tol">tol</code></td>
<td>
<p>a non-negative number.  If <code>x</code> is numeric,
then entries less than or equal to <code>tol</code> in absolute value
are deleted.</p>
</td></tr>
<tr><td><code id="drop0_+3A_is.csparse">is.Csparse</code></td>
<td>
<p>a logical used only if <code>give.Csparse</code>
is <code>TRUE</code>, indicating if <code>x</code> already inherits from
virtual class <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, in which
case coercion is not attempted, permitting some (typically
small) speed-up.</p>
</td></tr>
<tr><td><code id="drop0_+3A_give.csparse">give.Csparse</code></td>
<td>
<p>a logical indicating if the result must
inherit from virtual class <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>.
If <code>FALSE</code> and <code>x</code> inherits from
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>,
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, or
<code><a href="#topic+indMatrix-class">indMatrix</a></code>,
then the result preserves the class of <code>x</code>.
The default value is <code>TRUE</code> only for backwards compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, the result of deleting
non-structural zeros from <code>x</code>, possibly after coercion.
</p>


<h3>Note</h3>

<p><code>drop0</code> is sometimes called in conjunction with
<code><a href="base.html#topic+zapsmall">zapsmall</a></code>, e.g., when dealing with sparse
matrix products; see the example.
</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+sparseMatrix">sparseMatrix</a></code>, for constructing objects
inheriting from virtual class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>;
<code><a href="#topic+nnzero">nnzero</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- sparseMatrix(i = 1:8, j = 2:9, x = c(0:2, 3:-1),
                   dims = c(10L, 20L)))
drop0(m)

## A larger example:
t5 &lt;- new("dtCMatrix", Dim = c(5L, 5L), uplo = "L",
          x = c(10, 1, 3, 10, 1, 10, 1, 10, 10),
          i = c(0L,2L,4L, 1L, 3L,2L,4L, 3L, 4L),
          p = c(0L, 3L, 5L, 7:9))
TT &lt;- kronecker(t5, kronecker(kronecker(t5, t5), t5))
IT &lt;- solve(TT)
I. &lt;- TT %*% IT ;  nnzero(I.) # 697 ( == 625 + 72 )
I.0 &lt;- drop0(zapsmall(I.))
## which actually can be more efficiently achieved by
I.. &lt;- drop0(I., tol = 1e-15)
stopifnot(all(I.0 == Diagonal(625)), nnzero(I..) == 625)
</code></pre>

<hr>
<h2 id='dsCMatrix-class'>Numeric Symmetric Sparse (column compressed) Matrices</h2><span id='topic+dsCMatrix-class'></span><span id='topic+dsTMatrix-class'></span><span id='topic+Arith+2CdsCMatrix+2CdsCMatrix-method'></span><span id='topic+determinant+2CdsCMatrix+2Clogical-method'></span><span id='topic+determinant+2CdsTMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The <code>dsCMatrix</code> class is a class of symmetric, sparse
numeric matrices in the compressed, <b>c</b>olumn-oriented format.  In
this implementation the non-zero elements in the columns are sorted
into increasing row order.
</p>
<p>The <code>dsTMatrix</code> class is the class of symmetric, sparse numeric
matrices in <b>t</b>riplet format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dsCMatrix",
    ...)</code> or <code>new("dsTMatrix", ...)</code>, or automatically via e.g.,
<code>as(*, "symmetricMatrix")</code>, or (for <code>dsCMatrix</code>) also
from <code><a href="#topic+Matrix">Matrix</a>(.)</code>.
</p>
<p>Creation &ldquo;from scratch&rdquo; most efficiently happens via
<code><a href="#topic+sparseMatrix">sparseMatrix</a>(*, symmetric=TRUE)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>A character object indicating if the upper
triangle (<code>"U"</code>) or the lower triangle (<code>"L"</code>) is stored.</p>
</dd>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnZ
(<em>half</em> number of non-zero elements).  These are the row
numbers for each non-zero element in the lower triangle of the matrix.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>(only in class <code>"dsCMatrix"</code>:) an
<code><a href="base.html#topic+integer">integer</a></code> vector for providing pointers, one for each
column, see the detailed description in <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>(only in class <code>"dsTMatrix"</code>:) Object of
class <code>"integer"</code> of length nnZ (as <code>i</code>).  These are the
column numbers for each non-zero element in the lower triangle of
the matrix.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> of length nnZ &ndash;
the non-zero elements of the matrix (to be duplicated for full matrix).</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code> - a list
of factorizations of the matrix. </p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Both classes extend classes and <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>
<code><a href="#topic+dsparseMatrix-class">dsparseMatrix</a></code> directly;
<code>dsCMatrix</code> further directly extends
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, where
<code>dsTMatrix</code> does <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>solve</dt><dd><p><code>signature(a = "dsCMatrix", b = "....")</code>: <code>x
	&lt;- solve(a,b)</code> solves <code class="reqn">A x = b</code> for <code class="reqn">x</code>; see
<code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>chol</dt><dd><p><code>signature(x = "dsCMatrix", pivot = "logical")</code>:
Returns (and stores) the Cholesky decomposition of <code>x</code>, see
<code><a href="#topic+chol">chol</a></code>.</p>
</dd>
<dt>Cholesky</dt><dd><p><code>signature(A = "dsCMatrix",...)</code>:
Computes more flexibly Cholesky decompositions,
see <code><a href="#topic+Cholesky">Cholesky</a></code>.</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "dsCMatrix", logarithm =
	"missing")</code>: Evaluate the determinant of <code>x</code> on the
logarithm scale.  This creates and stores the Cholesky factorization.</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "dsCMatrix", logarithm =
	"logical")</code>: Evaluate the determinant of <code>x</code> on the
logarithm scale or not, according to the <code>logarithm</code>
argument.  This creates and stores the Cholesky factorization.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dsCMatrix")</code>: Transpose.  As for all
symmetric matrices, a matrix for which the upper triangle is
stored produces a matrix for which the lower triangle is stored
and vice versa, i.e., the <code>uplo</code> slot is swapped, and the row
and column indices are interchanged.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dsTMatrix")</code>: Transpose.  The
<code>uplo</code> slot is swapped from <code>"U"</code> to <code>"L"</code> or vice
versa, as for a <code>"dsCMatrix"</code>, see above.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, <code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>,
<code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> and those mentioned above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm &lt;- Matrix(toeplitz(c(10, 0, 1, 0, 3)), sparse = TRUE)
mm # automatically dsCMatrix
str(mm)
mT &lt;- as(as(mm, "generalMatrix"), "TsparseMatrix")

## Either
(symM &lt;- as(mT, "symmetricMatrix")) # dsT
(symC &lt;- as(symM, "CsparseMatrix")) # dsC
## or
sT &lt;- Matrix(mT, sparse=TRUE, forceCheck=TRUE) # dsT

sym2 &lt;- as(symC, "TsparseMatrix")
## --&gt; the same as 'symM', a "dsTMatrix"

</code></pre>

<hr>
<h2 id='dsparseMatrix-class'>Virtual Class &quot;dsparseMatrix&quot; of Numeric Sparse Matrices</h2><span id='topic+dsparseMatrix-class'></span><span id='topic+Arith+2CdsparseMatrix+2Clogical-method'></span><span id='topic+Arith+2CdsparseMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CdsparseMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CdsparseMatrix-method'></span><span id='topic+Ops+2CdsparseMatrix+2CnsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2CdsparseMatrix-method'></span>

<h3>Description</h3>

<p>The Class <code>"dsparseMatrix"</code> is the virtual (super) class of
all numeric sparse matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>:</dt><dd><p>the matrix dimension, see class <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>see the <code>"Matrix"</code> class.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector containing the
(non-zero) matrix entries.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"dMatrix"</code> and <code>"sparseMatrix"</code>, directly.<br />
Class <code>"Matrix"</code>, by the above classes.
</p>


<h3>See Also</h3>

<p>the documentation of the (non virtual) sub classes, see
<code>showClass("dsparseMatrix")</code>; in particular,
<a href="#topic+dgTMatrix-class">dgTMatrix</a>, <a href="#topic+dgCMatrix-class">dgCMatrix</a>, and
<a href="#topic+dgRMatrix-class">dgRMatrix</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("dsparseMatrix")
</code></pre>

<hr>
<h2 id='dsRMatrix-class'>Symmetric Sparse Compressed Row Matrices</h2><span id='topic+dsRMatrix-class'></span><span id='topic+determinant+2CdsRMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The <code>dsRMatrix</code> class is a class of symmetric, sparse
matrices in the compressed, row-oriented format.  In this
implementation the non-zero elements in the rows are sorted into
increasing column order.
</p>


<h3>Objects from the Class</h3>

<p>These <code>"..RMatrix"</code> classes are currently still mostly unimplemented!
</p>
<p>Objects can be created by calls of the form <code>new("dsRMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>A character object indicating if the upper
triangle (<code>"U"</code>) or the lower triangle (<code>"L"</code>) is
stored.  At present only the lower triangle form is allowed.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length
<code>nnzero</code> (number of non-zero elements).  These are the row
numbers for each non-zero element in the matrix.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each row, to the initial (zero-based) index of elements in
the row.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code> - a list
of factorizations of the matrix.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the non-zero
elements of the matrix.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>List of length two, see <code><a href="#topic+Matrix">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Classes <code><a href="#topic+dsparseMatrix-class">dsparseMatrix</a></code>,
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>, and
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, directly.
</p>
<p>Class <code>"dMatrix"</code>, by class <code>"dsparseMatrix"</code>;
class <code>"sparseMatrix"</code>, by classes <code>"dsparseMatrix"</code> and
<code>"RsparseMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>forceSymmetric</dt><dd><p><code>signature(x = "dsRMatrix", uplo = "missing")</code>:
a trivial method just returning <code>x</code></p>
</dd>
<dt>forceSymmetric</dt><dd><p><code>signature(x = "dsRMatrix", uplo = "character")</code>:
if <code>uplo == x@uplo</code>, this trivially returns <code>x</code>;
otherwise <code>t(x)</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>the classes <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>,
<code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>, and <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m0 &lt;- new("dsRMatrix"))
m2 &lt;- new("dsRMatrix", Dim = c(2L,2L),
          x = c(3,1), j = c(1L,1L), p = 0:2)
m2
stopifnot(colSums(as(m2, "TsparseMatrix")) == 3:4)
str(m2)
(ds2 &lt;- forceSymmetric(diag(2))) # dsy*
dR &lt;- as(ds2, "RsparseMatrix")
dR # dsRMatrix
</code></pre>

<hr>
<h2 id='dsyMatrix-class'>Symmetric Dense (Packed or Unpacked) Numeric Matrices</h2><span id='topic+dsyMatrix-class'></span><span id='topic+dspMatrix-class'></span><span id='topic+coerce+2CdsyMatrix+2CcorMatrix-method'></span><span id='topic+coerce+2CdsyMatrix+2CdpoMatrix-method'></span><span id='topic+determinant+2CdsyMatrix+2Clogical-method'></span><span id='topic+coerce+2CdspMatrix+2CcopMatrix-method'></span><span id='topic+coerce+2CdspMatrix+2CdppMatrix-method'></span><span id='topic+determinant+2CdspMatrix+2Clogical-method'></span>

<h3>Description</h3>


<ul>
<li><p> The <code>"dsyMatrix"</code> class is the class of symmetric, dense matrices
in <em>non-packed</em> storage and
</p>
</li>
<li> <p><code>"dspMatrix"</code> is the class of symmetric dense matrices in
<em>packed</em> storage, see <code><a href="#topic+pack">pack</a>()</code>.  Only the upper
triangle or the lower triangle is stored.
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dsyMatrix",
    ...)</code> or <code>new("dspMatrix", ...)</code>, respectively.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The numeric
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p><code>"dsyMatrix"</code> extends class <code>"dgeMatrix"</code>, directly, whereas<br />
<code>"dspMatrix"</code> extends class <code>"ddenseMatrix"</code>, directly.
</p>
<p>Both extend class <code>"symmetricMatrix"</code>, directly,
and class <code>"Matrix"</code> and others, <em>in</em>directly, use
<code><a href="methods.html#topic+showClass">showClass</a>("dsyMatrix")</code>, e.g., for details.
</p>


<h3>Methods</h3>


<dl>
<dt>norm</dt><dd><p><code>signature(x = "dspMatrix", type = "character")</code>, or
<code>x = "dsyMatrix"</code> or <code>type = "missing"</code>: Computes the
matrix norm of the desired type, see, <code><a href="#topic+norm">norm</a></code>.</p>
</dd>
<dt>rcond</dt><dd><p><code>signature(x = "dspMatrix", type = "character")</code>, or
<code>x = "dsyMatrix"</code> or <code>type = "missing"</code>: Computes the
reciprocal condition number, <code><a href="#topic+rcond">rcond</a>()</code>.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dspMatrix", b = "....")</code>, and</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dsyMatrix", b = "....")</code>: <code>x
	&lt;- solve(a,b)</code> solves <code class="reqn">A x = b</code> for <code class="reqn">x</code>; see
<code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dsyMatrix")</code>: Transpose; swaps from
upper triangular to lower triangular storage, i.e., the uplo slot
from <code>"U"</code> to <code>"L"</code> or vice versa, the same as for all
symmetric matrices.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <em>positive (Semi-)definite</em> dense (packed or non-packed
numeric matrix classes <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code>,
<code><a href="#topic+dppMatrix-class">dppMatrix</a></code> and <code><a href="#topic+corMatrix-class">corMatrix</a></code>,
</p>
<p>Classes <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> and <code><a href="#topic+Matrix-class">Matrix</a></code>;
<code><a href="base.html#topic+solve">solve</a></code>, <code><a href="#topic+norm">norm</a></code>, <code><a href="#topic+rcond">rcond</a></code>,
<code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Only upper triangular part matters (when uplo == "U" as per default)
(sy2 &lt;- new("dsyMatrix", Dim = as.integer(c(2,2)), x = c(14, NA,32,77)))
str(t(sy2)) # uplo = "L", and the lower tri. (i.e. NA is replaced).

chol(sy2) #-&gt; "Cholesky" matrix
(sp2 &lt;- pack(sy2)) # a "dspMatrix"

## Coercing to dpoMatrix gives invalid object:
sy3 &lt;- new("dsyMatrix", Dim = as.integer(c(2,2)), x = c(14, -1, 2, -7))
try(as(sy3, "dpoMatrix")) # -&gt; error: not positive definite


## 4x4 example
m &lt;- matrix(0,4,4); m[upper.tri(m)] &lt;- 1:6
(sym &lt;- m+t(m)+diag(11:14, 4))
(S1 &lt;- pack(sym))
(S2 &lt;- t(S1))
stopifnot(all(S1 == S2)) # equal "seen as matrix", but differ internally :
str(S1)
S2@x
</code></pre>

<hr>
<h2 id='dtCMatrix-class'>Triangular, (compressed) sparse column matrices</h2><span id='topic+dtCMatrix-class'></span><span id='topic+dtTMatrix-class'></span><span id='topic+Arith+2CdtCMatrix+2CdtCMatrix-method'></span>

<h3>Description</h3>

<p>The <code>"dtCMatrix"</code> class is a class of triangular, sparse
matrices in the compressed, column-oriented format.  In this
implementation the non-zero elements in the columns are sorted into
increasing row order.
</p>
<p>The <code>"dtTMatrix"</code> class is a class of triangular, sparse matrices
in triplet format.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dtCMatrix",
    ...)</code> or calls of the form  <code>new("dtTMatrix", ...)</code>,
but more typically automatically via <code><a href="#topic+Matrix">Matrix</a>()</code>
or coercions such as <code>as(x, "triangularMatrix")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>(only present in <code>"dtCMatrix"</code>:) an
<code><a href="base.html#topic+integer">integer</a></code> vector for providing pointers, one for each
column, see the detailed description in <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>.</p>
</dd>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the row numbers for
each non-zero element in the matrix.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the column numbers for
each non-zero element in the matrix. (Only present in the
<code>dtTMatrix</code> class.)</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the non-zero
elements of the matrix.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>),
inherited from the <code><a href="#topic+Matrix-class">Matrix</a></code>, see there.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"dgCMatrix"</code>, directly.
Class <code>"triangularMatrix"</code>, directly.
Class <code>"dMatrix"</code>, <code>"sparseMatrix"</code>, and more by class
<code>"dgCMatrix"</code> etc, see the examples.
</p>


<h3>Methods</h3>


<dl>
<dt>solve</dt><dd><p><code>signature(a = "dtCMatrix", b = "....")</code>:
sparse triangular solve (aka &ldquo;backsolve&rdquo; or
&ldquo;forwardsolve&rdquo;), see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dtCMatrix")</code>: returns the transpose of
<code>x</code></p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dtTMatrix")</code>: returns the transpose of
<code>x</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, <code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>,
<code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>, and <code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("dtCMatrix")
showClass("dtTMatrix")
t1 &lt;- new("dtTMatrix", x= c(3,7), i= 0:1, j=3:2, Dim= as.integer(c(4,4)))
t1
## from  0-diagonal to unit-diagonal {low-level step}:
tu &lt;- t1 ; tu@diag &lt;- "U"
tu
(cu &lt;- as(tu, "CsparseMatrix"))
str(cu)# only two entries in @i and @x
stopifnot(cu@i == 1:0,
          all(2 * symmpart(cu) == Diagonal(4) + forceSymmetric(cu)))

t1[1,2:3] &lt;- -1:-2
diag(t1) &lt;- 10*c(1:2,3:2)
t1 # still triangular
(it1 &lt;- solve(t1))
t1. &lt;- solve(it1)
all(abs(t1 - t1.) &lt; 10 * .Machine$double.eps)

## 2nd example
U5 &lt;- new("dtCMatrix", i= c(1L, 0:3), p=c(0L,0L,0:2, 5L), Dim = c(5L, 5L),
          x = rep(1, 5), diag = "U")
U5
(iu &lt;- solve(U5)) # contains one '0'
validObject(iu2 &lt;- solve(U5, Diagonal(5)))# failed in earlier versions

I5 &lt;- iu  %*% U5 # should equal the identity matrix
i5 &lt;- iu2 %*% U5
m53 &lt;- matrix(1:15, 5,3, dimnames=list(NULL,letters[1:3]))
asDiag &lt;- function(M) as(drop0(M), "diagonalMatrix")
stopifnot(
   all.equal(Diagonal(5), asDiag(I5), tolerance=1e-14) ,
   all.equal(Diagonal(5), asDiag(i5), tolerance=1e-14) ,
   identical(list(NULL, dimnames(m53)[[2]]), dimnames(solve(U5, m53)))
)

</code></pre>

<hr>
<h2 id='dtpMatrix-class'>Packed Triangular Dense Matrices - &quot;dtpMatrix&quot;</h2><span id='topic+dtpMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"dtpMatrix"</code> class is the class of triangular,
dense, numeric matrices in packed storage.  The <code>"dtrMatrix"</code>
class is the same except in nonpacked storage.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dtpMatrix",
    ...)</code> or by coercion from other classes of matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The numeric
values that constitute the matrix, stored in column-major order.
For a packed square matrix of dimension <code class="reqn">d \times d</code>,
<code>length(x)</code> is of length <code class="reqn">d(d+1)/2</code> (also when
<code>diag == "U"</code>!).</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>),
inherited from the <code><a href="#topic+Matrix-class">Matrix</a></code>, see there.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ddenseMatrix"</code>, directly.
Class <code>"triangularMatrix"</code>, directly.
Class <code>"dMatrix"</code> and more by class <code>"ddenseMatrix"</code> etc, see
the examples.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "dtpMatrix", y = "dgeMatrix")</code>:
Matrix multiplication; ditto for several other signature
combinations, see <code>showMethods("%*%", class = "dtpMatrix")</code>.</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "dtpMatrix", logarithm = "logical")</code>:
the <code><a href="base.html#topic+determinant">determinant</a>(x)</code> trivially is
<code>prod(diag(x))</code>, but computed on log scale to prevent over-
and underflow.</p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "dtpMatrix")</code>: ... </p>
</dd>
<dt>norm</dt><dd><p><code>signature(x = "dtpMatrix", type = "character")</code>: ... </p>
</dd>
<dt>rcond</dt><dd><p><code>signature(x = "dtpMatrix", norm = "character")</code>: ... </p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dtpMatrix", b = "...")</code>:
efficiently using internal backsolve or forwardsolve, see
<code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "dtpMatrix")</code>: <code>t(x)</code> remains
a <code>"dtpMatrix"</code>, lower triangular if <code>x</code> is upper
triangular, and vice versa.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Class <code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("dtrMatrix")

example("dtrMatrix-class", echo=FALSE)
(p1 &lt;- pack(T2))
str(p1)
(pp &lt;- pack(T))
ip1 &lt;- solve(p1)
stopifnot(length(p1@x) == 3, length(pp@x) == 3,
          p1 @ uplo == T2 @ uplo, pp @ uplo == T @ uplo,
	  identical(t(pp), p1), identical(t(p1), pp),
	  all((l.d &lt;- p1 - T2) == 0), is(l.d, "dtpMatrix"),
	  all((u.d &lt;- pp - T ) == 0), is(u.d, "dtpMatrix"),
	  l.d@uplo == T2@uplo, u.d@uplo == T@uplo,
	  identical(t(ip1), solve(pp)), is(ip1, "dtpMatrix"),
	  all.equal(as(solve(p1,p1), "diagonalMatrix"), Diagonal(2)))
</code></pre>

<hr>
<h2 id='dtrMatrix-class'>Triangular, dense, numeric matrices</h2><span id='topic+dtrMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"dtrMatrix"</code> class is the class of triangular, dense,
numeric matrices in nonpacked storage.  The <code>"dtpMatrix"</code> class
is the same except in packed storage, see <code><a href="#topic+pack">pack</a>()</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dtrMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The numeric
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code>. The dimensions
of the matrix which must be a two-element vector of non-negative
integers.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ddenseMatrix"</code>, directly.
Class <code>"triangularMatrix"</code>, directly.
Class <code>"Matrix"</code> and others, by class <code>"ddenseMatrix"</code>.
</p>


<h3>Methods</h3>

<p>Among others (such as matrix products, e.g. <code>?<a href="#topic+crossprod-methods">crossprod-methods</a></code>),
</p>

<dl>
<dt>norm</dt><dd><p><code>signature(x = "dtrMatrix", type = "character")</code>: ..</p>
</dd>
<dt>rcond</dt><dd><p><code>signature(x = "dtrMatrix", norm = "character")</code>: ..</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "dtrMatrix", b = "....")</code>: efficiently
use a &ldquo;forwardsolve&rdquo; or <code>backsolve</code> for a lower or
upper triangular matrix, respectively, see also
<code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt>+, -, *, ..., ==, &gt;=, ...</dt><dd><p> all the <code><a href="base.html#topic+Ops">Ops</a></code> group
methods are available.  When applied to two triangular matrices,
these return a triangular matrix when easily possible.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes <code><a href="#topic+ddenseMatrix-class">ddenseMatrix</a></code>, <code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code>,
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

(m &lt;- rbind(2:3, 0:-1))
(M &lt;- as(m, "generalMatrix"))

(T &lt;- as(M, "triangularMatrix")) # formally upper triangular
(T2 &lt;- as(t(M), "triangularMatrix"))
stopifnot(T@uplo == "U", T2@uplo == "L", identical(T2, t(T)))

m &lt;- matrix(0,4,4); m[upper.tri(m)] &lt;- 1:6
(t1 &lt;- Matrix(m+diag(,4)))
str(t1p &lt;- pack(t1))
(t1pu &lt;- diagN2U(t1p))
stopifnot(exprs = {
   inherits(t1 , "dtrMatrix"); validObject(t1)
   inherits(t1p, "dtpMatrix"); validObject(t1p)
   inherits(t1pu,"dtCMatrix"); validObject(t1pu)
   t1pu@x == 1:6
   all(t1pu == t1p)
   identical((t1pu - t1)@x, numeric())# sparse all-0
})
</code></pre>

<hr>
<h2 id='dtRMatrix-class'>Triangular Sparse Compressed Row Matrices</h2><span id='topic+dtRMatrix-class'></span>

<h3>Description</h3>

<p>The <code>dtRMatrix</code> class is a class of triangular, sparse
matrices in the compressed, row-oriented format.  In this
implementation the non-zero elements in the rows are sorted into
increasing columnd order.
</p>


<h3>Objects from the Class</h3>

<p>This class is currently still mostly unimplemented!
</p>
<p>Objects can be created by calls of the form <code>new("dtRMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.
At present only the lower triangle form is allowed.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length
<code><a href="#topic+nnzero">nnzero</a>(.)</code> (number of non-zero elements).  These are
the row numbers for each non-zero element in the matrix.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each row, to the initial (zero-based) index of elements in
the row. (Only present in the <code>dsRMatrix</code> class.)</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the non-zero
elements of the matrix.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>The dimension (a length-2 <code>"integer"</code>)</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>corresponding names (or <code>NULL</code>),
inherited from the <code><a href="#topic+Matrix-class">Matrix</a></code>, see there.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"dgRMatrix"</code>, directly.
Class <code>"dsparseMatrix"</code>, by class <code>"dgRMatrix"</code>.
Class <code>"dMatrix"</code>, by class <code>"dgRMatrix"</code>.
Class <code>"sparseMatrix"</code>, by class <code>"dgRMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"dgRMatrix"</code>.
</p>


<h3>Methods</h3>

<p>No methods currently with class &quot;dsRMatrix&quot; in the signature.
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, <code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>,
<code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m0 &lt;- new("dtRMatrix"))
(m2 &lt;- new("dtRMatrix", Dim = c(2L,2L),
                        x = c(5, 1:2), p = c(0L,2:3), j= c(0:1,1L)))
str(m2)
(m3 &lt;- as(Diagonal(2), "RsparseMatrix"))# --&gt; dtRMatrix
</code></pre>

<hr>
<h2 id='expand-methods'>Expand Matrix Factorizations</h2><span id='topic+expand'></span><span id='topic+expand-methods'></span><span id='topic+expand1'></span><span id='topic+expand1-methods'></span><span id='topic+expand2'></span><span id='topic+expand2-methods'></span><span id='topic+expand+2CCHMfactor-method'></span><span id='topic+expand+2CdenseLU-method'></span><span id='topic+expand+2CsparseLU-method'></span><span id='topic+expand1+2CBunchKaufman-method'></span><span id='topic+expand1+2CCHMsimpl-method'></span><span id='topic+expand1+2CCHMsuper-method'></span><span id='topic+expand1+2CCholesky-method'></span><span id='topic+expand1+2CSchur-method'></span><span id='topic+expand1+2CdenseLU-method'></span><span id='topic+expand1+2CpBunchKaufman-method'></span><span id='topic+expand1+2CpCholesky-method'></span><span id='topic+expand1+2CsparseLU-method'></span><span id='topic+expand1+2CsparseQR-method'></span><span id='topic+expand2+2CBunchKaufman-method'></span><span id='topic+expand2+2CCHMsimpl-method'></span><span id='topic+expand2+2CCHMsuper-method'></span><span id='topic+expand2+2CCholesky-method'></span><span id='topic+expand2+2CSchur-method'></span><span id='topic+expand2+2CdenseLU-method'></span><span id='topic+expand2+2CpBunchKaufman-method'></span><span id='topic+expand2+2CpCholesky-method'></span><span id='topic+expand2+2CsparseLU-method'></span><span id='topic+expand2+2CsparseQR-method'></span>

<h3>Description</h3>

<p><code>expand1</code> and <code>expand2</code> construct matrix factors from
objects specifying matrix factorizations.  Such objects typically
do not store the factors explicitly, employing instead a compact
representation to save memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand1(x, which, ...)
expand2(x, ...)

expand (x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand-methods_+3A_x">x</code></td>
<td>
<p>a matrix factorization, typically inheriting from
virtual class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</td></tr>
<tr><td><code id="expand-methods_+3A_which">which</code></td>
<td>
<p>a character string indicating a matrix factor.</p>
</td></tr>
<tr><td><code id="expand-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for <code>expand</code> are retained only for backwards
compatibility with <span class="pkg">Matrix</span> <code>&lt; 1.6-0</code>.  New code
should use <code>expand1</code> and <code>expand2</code>, whose methods
provide more control and behave more consistently.  Notably,
<code>expand2</code> obeys the rule that the product of the matrix
factors in the returned list should reproduce
(within some tolerance) the factorized matrix,
<em>including</em> its <code>dimnames</code>.
</p>
<p>Hence if <code>x</code> is a matrix and <code>y</code> is its factorization,
then
</p>
<pre>    all.equal(as(x, "matrix"), as(Reduce(`%*%`, expand2(y)), "matrix"))</pre>
<p>should in most cases return <code>TRUE</code>.
</p>


<h3>Value</h3>

<p><code>expand1</code> returns an object inheriting from virtual class
<code><a href="#topic+Matrix-class">Matrix</a></code>, representing the factor indicated
by <code>which</code>, always without row and column names.
</p>
<p><code>expand2</code> returns a list of factors, typically with names
using conventional notation, as in <code>list(L=, U=)</code>.
The first and last factors get the row and column names of the
factorized matrix, which are preserved in the <code>Dimnames</code>
slot of <code>x</code>.
</p>


<h3>Methods</h3>

<p>The following table lists methods for <code>expand1</code> together with
allowed values of argument <code>which</code>.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>class(x)</code> </td><td style="text-align: left;"> <code>which</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+Schur-class">Schur</a></code> </td><td style="text-align: left;"> <code>c("Q", "T", "Q.")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+denseLU-class">denseLU</a></code> </td><td style="text-align: left;"> <code>c("P1", "P1.", "L", "U")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+sparseLU-class">sparseLU</a></code> </td><td style="text-align: left;"> <code>c("P1", "P1.", "P2", "P2.", "L", "U")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+sparseQR-class">sparseQR</a></code> </td><td style="text-align: left;"> <code>c("P1", "P1.", "P2", "P2.", "Q", "Q1", "R", "R1")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+BunchKaufman-class">BunchKaufman</a></code>, <code><a href="#topic+pBunchKaufman-class">pBunchKaufman</a></code> </td><td style="text-align: left;"> <code>c("U", "DU", "U.", "L", "DL", "L.")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+Cholesky-class">Cholesky</a></code>, <code><a href="#topic+pCholesky-class">pCholesky</a></code> </td><td style="text-align: left;"> <code>c("P1", "P1.", "L1", "D", "L1.", "L", "L.")</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code><a href="#topic+CHMsimpl-class">CHMsimpl</a></code>, <code><a href="#topic+CHMsimpl-class">CHMsimpl</a></code> </td><td style="text-align: left;"> <code>c("P1", "P1.", "L1", "D", "L1.", "L", "L.")</code>
  </td>
</tr>

</table>

<p>Methods for <code>expand2</code> and <code>expand</code> are described
below.  Factor names and classes apply also to <code>expand1</code>.
</p>

<dl>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "CHMsimpl")</code>:
expands the factorization
<code class="reqn">A = P_{1}' L_{1} D L_{1}' P_{1} = P_{1}' L L' P_{1}</code>
as <code>list(P1., L1, D, L1., P1)</code> (the default)
or as <code>list(P1., L, L., P1)</code>,
depending on optional logical argument <code>LDL</code>.
<code>P1</code> and <code>P1.</code> are <code><a href="#topic+pMatrix-class">pMatrix</a></code>,
<code>L1</code>, <code>L1.</code>, <code>L</code>, and <code>L.</code> are
<code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>,
and <code>D</code> is a <code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "CHMsuper")</code>:
as <code>CHMsimpl</code>, but the triangular factors are
stored as <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "p?Cholesky")</code>:
expands the factorization
<code class="reqn">A = L_{1} D L_{1}' = L L'</code>
as <code>list(L1, D, L1.)</code> (the default) or as <code>list(L, L.)</code>,
depending on optional logical argument <code>LDL</code>.
<code>L1</code>, <code>L1.</code>, <code>L</code>, and <code>L.</code> are
<code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code> or <code><a href="#topic+dtpMatrix-class">dtpMatrix</a></code>,
and <code>D</code> is a <code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "p?BunchKaufman")</code>:
expands the factorization
<code class="reqn">A = U D_{U} U' = L D_{L} L'</code>
where
<code class="reqn">U = \prod_{k = 1}^{b_{U}} P_{k} U_{k}</code>
and
<code class="reqn">L = \prod_{k = 1}^{b_{L}} P_{k} L_{k}</code>
as <code>list(U, DU, U.)</code> or <code>list(L, DL, L.)</code>,
depending on <code>x@uplo</code>.  If optional argument <code>complete</code>
is <code>TRUE</code>, then an unnamed list giving the full expansion
with <code class="reqn">2 b_{U} + 1</code> or <code class="reqn">2 b_{L} + 1</code> matrix
factors is returned instead.
<code class="reqn">P_{k}</code> are represented as <code><a href="#topic+pMatrix-class">pMatrix</a></code>,
<code class="reqn">U_{k}</code> and <code class="reqn">L_{k}</code> are represented as
<code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>, and
<code class="reqn">D_{U}</code> and <code class="reqn">D_{L}</code> are represented as
<code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "Schur")</code>:
expands the factorization
<code class="reqn">A = Q T Q'</code>
as <code>list(Q, T, Q.)</code>.
<code>Q</code> and <code>Q.</code> are <code>x@Q</code> and <code>t(x@Q)</code>
modulo <code>Dimnames</code>, and <code>T</code> is <code>x@T</code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "sparseLU")</code>:
expands the factorization
<code class="reqn">A = P_{1}' L U P_{2}'</code>
as <code>list(P1., L, U, P2.)</code>.
<code>P1.</code> and <code>P2.</code> are <code><a href="#topic+pMatrix-class">pMatrix</a></code>,
and <code>L</code> and <code>U</code> are <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "denseLU")</code>:
expands the factorization
<code class="reqn">A = P_{1}' L U</code>
as <code>list(P1., L, U)</code>.
<code>P1.</code> is a <code><a href="#topic+pMatrix-class">pMatrix</a></code>,
and <code>L</code> and <code>U</code> are <code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code>
if square and <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> otherwise.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "sparseQR")</code>:
expands the factorization
<code class="reqn">A = P_{1}' Q R P_{2}' = P_{1}' Q_{1} R_{1} P_{2}'</code>
as <code>list(P1., Q, R, P2.)</code> or <code>list(P1., Q1, R1, P2.)</code>,
depending on optional logical argument <code>complete</code>.
<code>P1.</code> and <code>P2.</code> are <code><a href="#topic+pMatrix-class">pMatrix</a></code>,
<code>Q</code> and <code>Q1</code> are <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>,
<code>R</code> is a <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>,
and <code>R1</code> is a <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "CHMfactor")</code>:
as <code>expand2</code>, but returning <code>list(P, L)</code>.
<code>expand(x)[["P"]]</code> and <code>expand2(x)[["P1"]]</code>
represent the same permutation matrix <code class="reqn">P_{1}</code>
but have opposite <code>margin</code> slots and inverted
<code>perm</code> slots.  The components of <code>expand(x)</code>
do not preserve <code>x@Dimnames</code>.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "sparseLU")</code>:
as <code>expand2</code>, but returning <code>list(P, L, U, Q)</code>.
<code>expand(x)[["Q"]]</code> and <code>expand2(x)[["P2."]]</code>
represent the same permutation matrix <code class="reqn">P_{2}'</code>
but have opposite <code>margin</code> slots and inverted
<code>perm</code> slots.  <code>expand(x)[["P"]]</code> represents
the permutation matrix <code class="reqn">P_{1}</code> rather than its
transpose <code class="reqn">P_{1}'</code>; it is <code>expand2(x)[["P1."]]</code>
with an inverted <code>perm</code> slot.  <code>expand(x)[["L"]]</code>
and <code>expand2(x)[["L"]]</code> represent the same unit lower
triangular matrix <code class="reqn">L</code>, but with <code>diag</code> slot equal
to <code>"N"</code> and <code>"U"</code>, respectively.
<code>expand(x)[["L"]]</code> and <code>expand(x)[["U"]]</code>
store the <em>permuted</em> first and second components of
<code>x@Dimnames</code> in their <code>Dimnames</code> slots.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "denseLU")</code>:
as <code>expand2</code>, but returning <code>list(L, U, P)</code>.
<code>expand(x)[["P"]]</code> and <code>expand2(x)[["P1."]]</code>
are identical modulo <code>Dimnames</code>.  The components
of <code>expand(x)</code> do not preserve <code>x@Dimnames</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The virtual class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>
of matrix factorizations.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+Schur">Schur</a></code>, <code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code> for
<em>computing</em> factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("expand1", inherited = FALSE)
showMethods("expand2", inherited = FALSE)
set.seed(0)

(A &lt;- Matrix(rnorm(9L, 0, 10), 3L, 3L))
(lu.A &lt;- lu(A))
(e.lu.A &lt;- expand2(lu.A))
stopifnot(exprs = {
    is.list(e.lu.A)
    identical(names(e.lu.A), c("P1.", "L", "U"))
    all(sapply(e.lu.A, is, "Matrix"))
    all.equal(as(A, "matrix"), as(Reduce(`%*%`, e.lu.A), "matrix"))
})

## 'expand1' and 'expand2' give equivalent results modulo
## dimnames and representation of permutation matrices;
## see also function 'alt' in example("Cholesky-methods")
(a1 &lt;- sapply(names(e.lu.A), expand1, x = lu.A, simplify = FALSE))
all.equal(a1, e.lu.A)

## see help("denseLU-class") and others for more examples
</code></pre>

<hr>
<h2 id='expm-methods'>Matrix Exponential</h2><span id='topic+expm'></span><span id='topic+expm-methods'></span><span id='topic+expm+2CMatrix-method'></span><span id='topic+expm+2CdMatrix-method'></span><span id='topic+expm+2CddiMatrix-method'></span><span id='topic+expm+2CdgeMatrix-method'></span><span id='topic+expm+2CdspMatrix-method'></span><span id='topic+expm+2CdsparseMatrix-method'></span><span id='topic+expm+2CdsyMatrix-method'></span><span id='topic+expm+2CdtpMatrix-method'></span><span id='topic+expm+2CdtrMatrix-method'></span><span id='topic+expm+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Compute the exponential of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm-methods_+3A_x">x</code></td>
<td>
<p>a matrix, typically inheriting from the
<code><a href="#topic+dMatrix-class">dMatrix</a></code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential of a matrix is defined as the infinite Taylor
series <code>expm(A) = I + A + A^2/2! + A^3/3! + ...</code> (although this is
definitely not the way to compute it).  The method for the
<code>dgeMatrix</code> class uses Ward's diagonal Pade' approximation with
three step preconditioning, a recommendation from
Moler &amp; Van Loan (1978) &ldquo;Nineteen dubious ways...&rdquo;.
</p>


<h3>Value</h3>

<p>The matrix exponential of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>This is a translation of the implementation of the corresponding
Octave function contributed to the Octave project by
A. Scottedward Hodel <a href="mailto:A.S.Hodel@Eng.Auburn.EDU">A.S.Hodel@Eng.Auburn.EDU</a>.  A bug in there
has been fixed by Martin Maechler.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Matrix_exponential">https://en.wikipedia.org/wiki/Matrix_exponential</a>
</p>
<p>Cleve Moler and Charles Van Loan (2003)
Nineteen dubious ways to compute the exponential of a matrix,
twenty-five years later. <em>SIAM Review</em> <b>45</b>, 1, 3&ndash;49.
<a href="https://doi.org/10.1137/S00361445024180">doi:10.1137/S00361445024180</a>
</p>
<p><em>for historical reference mostly:</em><br />
Moler, C. and Van Loan, C. (1978)
Nineteen dubious ways to compute the exponential of a matrix.
<em>SIAM Review</em> <b>20</b>, 4, 801&ndash;836.
<a href="https://doi.org/10.1137/1020098">doi:10.1137/1020098</a>
</p>

<p>Eric W. Weisstein et al. (1999) <em>Matrix Exponential</em>.
From MathWorld, <a href="https://mathworld.wolfram.com/MatrixExponential.html">https://mathworld.wolfram.com/MatrixExponential.html</a>
</p>


<h3>See Also</h3>

<p>Package <a href="https://CRAN.R-project.org/package=expm"><span class="pkg">expm</span></a>, which provides newer (in some cases
faster, more accurate) algorithms for computing the matrix
exponential via its own (non-generic) function <code>expm()</code>.
<span class="pkg">expm</span> also implements <code>logm()</code>, <code>sqrtm()</code>, etc.
</p>
<p>Generic function <code><a href="#topic+Schur">Schur</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m1 &lt;- Matrix(c(1,0,1,1), ncol = 2))
(e1 &lt;- expm(m1)) ; e &lt;- exp(1)
stopifnot(all.equal(e1@x, c(e,0,e,e), tolerance = 1e-15))
(m2 &lt;- Matrix(c(-49, -64, 24, 31), ncol = 2))
(e2 &lt;- expm(m2))
(m3 &lt;- Matrix(cbind(0,rbind(6*diag(3),0))))# sparse!
(e3 &lt;- expm(m3)) # upper triangular
</code></pre>

<hr>
<h2 id='externalFormats'>Read and write external matrix formats</h2><span id='topic+readHB'></span><span id='topic+readMM'></span><span id='topic+writeMM'></span><span id='topic+writeMM+2CCsparseMatrix-method'></span><span id='topic+writeMM+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Read matrices stored in the Harwell-Boeing or MatrixMarket formats
or write <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> objects to one of these
formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHB(file)
readMM(file)
writeMM(obj, file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="externalFormats_+3A_obj">obj</code></td>
<td>
<p>a real sparse matrix</p>
</td></tr>
<tr><td><code id="externalFormats_+3A_file">file</code></td>
<td>
<p>for <code>writeMM</code> - the name of the file to be written.
For <code>readHB</code> and <code>readMM</code> the name of the file to read, as
a character scalar.  The names of files storing matrices in the
Harwell-Boeing format usually end in <code>".rua"</code> or <code>".rsa"</code>.
Those storing matrices in the MatrixMarket format usually end in
<code>".mtx"</code>.
</p>
<p>Alternatively, <code>readHB</code> and <code>readMM</code> accept connection objects.</p>
</td></tr>
<tr><td><code id="externalFormats_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently none are used in
any methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>readHB</code> and <code>readMM</code> functions return an object that
inherits from the <code>"<a href="#topic+Matrix-class">Matrix</a>"</code> class.  Methods for the
<code>writeMM</code> generic functions usually return
<code><a href="base.html#topic+NULL">NULL</a></code> and, as a side effect, the matrix <code>obj</code> is
written to <code>file</code> in the MatrixMarket format (writeMM).
</p>


<h3>Note</h3>

<p>The Harwell-Boeing format is older and less flexible than the
MatrixMarket format.  The function <code>writeHB</code> was deprecated and
has now been removed.  Please use <code>writeMM</code> instead.
</p>
<p>Note that these formats do <em>not</em> know anything about
<code><a href="base.html#topic+dimnames">dimnames</a></code>, hence these are dropped by <code>writeMM()</code>.
</p>
<p>A very simple way to export small sparse matrices <code>S</code>, is to use
<code>summary(S)</code> which returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with
columns <code>i</code>, <code>j</code>, and possibly <code>x</code>, see <code>summary</code> in
<code><a href="#topic+sparseMatrix-class">sparseMatrix-class</a></code>, and an example below.
</p>


<h3>References</h3>

<p><a href="https://math.nist.gov/MatrixMarket/">https://math.nist.gov/MatrixMarket/</a>
</p>
<p><a href="https://sparse.tamu.edu/">https://sparse.tamu.edu/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(pores &lt;- readMM(system.file("external/pores_1.mtx", package = "Matrix")))
str(utm   &lt;- readHB(system.file("external/utm300.rua" , package = "Matrix")))
str(lundA &lt;- readMM(system.file("external/lund_a.mtx" , package = "Matrix")))
str(lundA &lt;- readHB(system.file("external/lund_a.rsa" , package = "Matrix")))
## https://math.nist.gov/MatrixMarket/data/Harwell-Boeing/counterx/counterx.htm
str(jgl   &lt;- readMM(system.file("external/jgl009.mtx" , package = "Matrix")))

## NOTE: The following examples take quite some time
## ----  even on a fast internet connection:
if(FALSE) {
## The URL has been corrected, but we need an untar step:
u. &lt;- url("https://www.cise.ufl.edu/research/sparse/RB/Boeing/msc00726.tar.gz")
str(sm &lt;- readHB(gzcon(u.)))
}

data(KNex, package = "Matrix")
## Store as MatrixMarket (".mtx") file, here inside temporary dir./folder:
(MMfile &lt;- file.path(tempdir(), "mmMM.mtx"))
writeMM(KNex$mm, file=MMfile)
file.info(MMfile)[,c("size", "ctime")] # (some confirmation of the file's)

## very simple export - in triplet format - to text file:
data(CAex, package = "Matrix")
s.CA &lt;- summary(CAex)
s.CA # shows  (i, j, x)  [columns of a data frame]
message("writing to ", outf &lt;- tempfile())
write.table(s.CA, file = outf, row.names=FALSE)
## and read it back -- showing off  sparseMatrix():
str(dd &lt;- read.table(outf, header=TRUE))
## has columns (i, j, x) -&gt; we can use via do.call() as arguments to sparseMatrix():
mm &lt;- do.call(sparseMatrix, dd)
stopifnot(all.equal(mm, CAex, tolerance=1e-15))
</code></pre>

<hr>
<h2 id='facmul-methods'>Multiplication by Factors from Matrix Factorizations</h2><span id='topic+facmul'></span><span id='topic+facmul-methods'></span>

<h3>Description</h3>

<p>Multiplies a matrix or vector on the left or right by a factor
from a matrix factorization or its transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facmul(x, factor, y, trans = FALSE, left = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facmul-methods_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code> object.</p>
</td></tr>
<tr><td><code id="facmul-methods_+3A_factor">factor</code></td>
<td>
<p>a character string indicating a factor in the
factorization represented by <code>x</code>, typically an element
of <code>names(<a href="#topic+expand2">expand2</a>(x, ...))</code>.</p>
</td></tr>
<tr><td><code id="facmul-methods_+3A_y">y</code></td>
<td>
<p>a matrix or vector to be multiplied on the left or right
by the factor or its transpose.</p>
</td></tr>
<tr><td><code id="facmul-methods_+3A_trans">trans</code></td>
<td>
<p>a logical indicating if the transpose of the
factor should be used, rather than the factor itself.</p>
</td></tr>
<tr><td><code id="facmul-methods_+3A_left">left</code></td>
<td>
<p>a logical indicating if the <code>y</code> should be
multiplied on the left by the factor, rather than on the right.</p>
</td></tr>
<tr><td><code id="facmul-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>facmul</code> is experimental and currently no methods are
exported from <span class="pkg">Matrix</span>.
</p>


<h3>Value</h3>

<p>The value of <code>op(M) %*% y</code> or <code>y %*% op(M)</code>,
depending on <code>left</code>, where <code>M</code> is the factor
(always <em>without</em> <code>dimnames</code>) and <code>op(M)</code>
is <code>M</code> or <code>t(M)</code>, depending on <code>trans</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Conceptually, methods for 'facmul' _would_ behave as follows ...
## Not run: 
n &lt;- 3L
x &lt;- lu(Matrix(rnorm(n * n), n, n))
y &lt;- rnorm(n)
L &lt;- unname(expand2(x)[[nm &lt;- "L"]])
stopifnot(exprs = {
    all.equal(facmul(x, nm, y, trans = FALSE, left =  TRUE), L %*% y)
    all.equal(facmul(x, nm, y, trans = FALSE, left = FALSE), y %*% L)
    all.equal(facmul(x, nm, y, trans =  TRUE, left =  TRUE),  crossprod(L, y))
    all.equal(facmul(x, nm, y, trans =  TRUE, left = FALSE), tcrossprod(y, L))
})

## End(Not run)
</code></pre>

<hr>
<h2 id='fastMisc'>&ldquo;Low Level&rdquo; Coercions and Methods</h2><span id='topic+fastMisc'></span><span id='topic+.M2kind'></span><span id='topic+.M2gen'></span><span id='topic+.M2sym'></span><span id='topic+.M2tri'></span><span id='topic+.M2diag'></span><span id='topic+.M2v'></span><span id='topic+.M2m'></span><span id='topic+.M2unpacked'></span><span id='topic+.M2packed'></span><span id='topic+.M2C'></span><span id='topic+.M2R'></span><span id='topic+.M2T'></span><span id='topic+.M2V'></span><span id='topic+.m2V'></span><span id='topic+.sparse2dense'></span><span id='topic+.diag2dense'></span><span id='topic+.ind2dense'></span><span id='topic+.m2dense'></span><span id='topic+.dense2sparse'></span><span id='topic+.diag2sparse'></span><span id='topic+.ind2sparse'></span><span id='topic+.m2sparse'></span><span id='topic+.tCRT'></span><span id='topic+.CR2RC'></span><span id='topic+.CR2T'></span><span id='topic+.T2CR'></span><span id='topic+.dense2g'></span><span id='topic+.dense2kind'></span><span id='topic+.dense2m'></span><span id='topic+.dense2v'></span><span id='topic+.sparse2g'></span><span id='topic+.sparse2kind'></span><span id='topic+.sparse2m'></span><span id='topic+.sparse2v'></span><span id='topic+.tCR2RC'></span><span id='topic+.diag.dsC'></span><span id='topic+.solve.dgC.lu'></span><span id='topic+.solve.dgC.qr'></span><span id='topic+.solve.dgC.chol'></span><span id='topic+.updateCHMfactor'></span>

<h3>Description</h3>

<p>&ldquo;Semi-API&rdquo; functions used internally by <span class="pkg">Matrix</span>,
often to bypass S4 dispatch and avoid the associated overhead.
These are exported to provide this capability to expert users.
Typical users should continue to rely on S4 generic functions
to dispatch suitable methods, by calling,
e.g., <code>as(., &lt;class&gt;)</code> for coercions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.M2kind(from, kind = ".", sparse = NA)

.M2gen(from, kind = ".")
.M2sym(from, ...)
.M2tri(from, ...)
.M2diag(from)

.M2v(from)
.M2m(from)
.M2unpacked(from)
.M2packed(from)
.M2C(from)
.M2R(from)
.M2T(from)

.M2V(from)
.m2V(from, kind = ".")

.sparse2dense(from, packed = FALSE)
.diag2dense(from, kind = ".", shape = "t", packed = FALSE, uplo = "U")
.ind2dense(from, kind = "n")
.m2dense(from, class = ".ge", uplo = "U", diag = "N", trans = FALSE)

.dense2sparse(from, repr = "C")
.diag2sparse(from, kind = ".", shape = "t", repr = "C", uplo = "U")
.ind2sparse(from, kind = "n", repr = ".")
.m2sparse(from, class = ".gC", uplo = "U", diag = "N", trans = FALSE)

.tCRT(x, lazy = TRUE)

.diag.dsC(x, Chx = Cholesky(x, LDL = TRUE), res.kind = "diag")

.solve.dgC.lu  (a, b, tol = .Machine$double.eps, check = TRUE)
.solve.dgC.qr  (a, b, order = 3L, check = TRUE)
.solve.dgC.chol(a, b, check = TRUE)

.updateCHMfactor(object, parent, mult = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastMisc_+3A_from">from</code>, <code id="fastMisc_+3A_x">x</code>, <code id="fastMisc_+3A_a">a</code>, <code id="fastMisc_+3A_b">b</code></td>
<td>
<p>a <code><a href="#topic+Matrix-class">Matrix</a></code>, matrix, or vector.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_kind">kind</code></td>
<td>
<p>a string (<code>"."</code>, <code>","</code>, <code>"n"</code>, <code>"l"</code>,
or <code>"d"</code>) specifying the &ldquo;kind&rdquo; of the result.
<code>"."</code> indicates that the kind of <code>from</code> should be preserved.
<code>","</code> is equivalent to <code>"z"</code> if <code>from</code> is complex
and to <code>"d"</code> otherwise.
<code>"n"</code> indicates that the result should inherit from
<code><a href="#topic+nMatrix-class">nMatrix</a></code> or <code><a href="#topic+nsparseVector-class">nsparseVector</a></code>
(and so on).</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_shape">shape</code></td>
<td>
<p>a string (<code>"."</code>, <code>"g"</code>, <code>"s"</code>, or
<code>"t"</code>) specifying the &ldquo;shape&rdquo; of the result.  <code>"."</code>
indicates that the shape of <code>from</code> should be preserved.
<code>"g"</code> indicates that the result should inherit from
<code><a href="#topic+generalMatrix-class">generalMatrix</a></code> (and so on).</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_repr">repr</code></td>
<td>
<p>a string (<code>"."</code>, <code>"C"</code>, <code>"R"</code>, or
<code>"T"</code>) specifying the sparse representation of the result.
<code>"."</code> is accepted only by <code>.ind2sparse</code> and indicates
the most efficient representation,
which is <code>"C"</code> (<code>"R"</code>) for <code>margin = 2</code> (<code>1</code>).
<code>"C"</code> indicates that the result should inherit from
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> (and so on).</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_packed">packed</code></td>
<td>
<p>a logical indicating if the result should
inherit from <code><a href="#topic+packedMatrix-class">packedMatrix</a></code>
rather than from <code><a href="#topic+unpackedMatrix-class">unpackedMatrix</a></code>.
It is ignored for <code>from</code> inheriting from
<code><a href="#topic+generalMatrix-class">generalMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_sparse">sparse</code></td>
<td>
<p>a logical indicating if the result should inherit
from <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> rather than from
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code>.  If <code>NA</code>, then the result
will be formally sparse if and only if <code>from</code> is.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_uplo">uplo</code></td>
<td>
<p>a string (<code>"U"</code> or <code>"L"</code>) indicating whether
the result (if symmetric or triangular) should store the upper or
lower triangle of <code>from</code>.  The elements of <code>from</code> in the
opposite triangle are ignored.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_diag">diag</code></td>
<td>
<p>a string (<code>"N"</code> or <code>"U"</code>) indicating whether
the result (if triangular) should be formally nonunit or unit
triangular.  In the unit triangular case, the diagonal elements
of <code>from</code> are ignored.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_trans">trans</code></td>
<td>
<p>a logical indicating if the result should be a 1-row
matrix rather than a 1-column matrix where <code>from</code> is a vector
but not a matrix.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_class">class</code></td>
<td>
<p>a string whose first three characters specify the class
of the result.  It should match the pattern
<code>"^[.nld](ge|sy|tr|sp|tp)"</code> for <code>.m2dense</code> and
<code>"^[.nld][gst][CRT]"</code> for <code>.m2sparse</code>,
where <code>"."</code> in the first position is equivalent to <code>"l"</code>
for logical arguments and <code>"d"</code> for numeric arguments.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+isSymmetric">isSymmetric</a></code>
or <code><a href="#topic+isTriangular">isTriangular</a></code>.</p>
</td></tr>

<tr><td><code id="fastMisc_+3A_lazy">lazy</code></td>
<td>
<p>a logical indicating if the transpose should be
constructed with minimal allocation, but possibly <em>without</em>
preserving representation.</p>
</td></tr>

<tr><td><code id="fastMisc_+3A_chx">Chx</code></td>
<td>
<p>optionally, the <code><a href="#topic+Cholesky">Cholesky</a>(x, ...)</code>
factorization of <code>x</code>.  If supplied, then <code>x</code> is unused.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_res.kind">res.kind</code></td>
<td>
<p>a string in <code>c("trace", "sumLog", "prod", "min",
      "max", "range", "diag", "diagBack")</code>.</p>
</td></tr>

<tr><td><code id="fastMisc_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="#topic+lu-methods">lu-methods</a></code>.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_order">order</code></td>
<td>
<p>see <code><a href="#topic+qr-methods">qr-methods</a></code>.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_check">check</code></td>
<td>
<p>a logical indicating if the first argument should be
tested for inheritance from <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> and
coerced if necessary.   Set to <code>FALSE</code> for speed only if it
is known to already inherit from <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>

<tr><td><code id="fastMisc_+3A_object">object</code></td>
<td>
<p>a Cholesky factorization inheriting from virtual class
<code>CHMfactor</code>, almost always the result of a call to generic
function <code><a href="#topic+Cholesky">Cholesky</a></code>.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_parent">parent</code></td>
<td>
<p>an object of class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>
or class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="fastMisc_+3A_mult">mult</code></td>
<td>
<p>a numeric vector of postive length.  Only the first
element is used, and that must be finite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions with names of the form <code>.&lt;A&gt;2&lt;B&gt;</code> implement coercions
from virtual class A to the &ldquo;nearest&rdquo; non-virtual subclass of
virtual class B, where the virtual classes are abbreviated as follows:
</p>

<dl>
<dt><code>M</code></dt><dd><p><code><a href="#topic+Matrix-class">Matrix</a></code></p>
</dd>
<dt><code>V</code></dt><dd><p><code><a href="#topic+sparseVector-class">sparseVector</a></code></p>
</dd>
<dt><code>m</code></dt><dd><p>matrix</p>
</dd>
<dt><code>v</code></dt><dd><p>vector</p>
</dd>
<dt><code>dense</code></dt><dd><p><code><a href="#topic+denseMatrix-class">denseMatrix</a></code></p>
</dd>
<dt><code>unpacked</code></dt><dd><p><code><a href="#topic+unpackedMatrix-class">unpackedMatrix</a></code></p>
</dd>
<dt><code>packed</code></dt><dd><p><code><a href="#topic+packedMatrix-class">packedMatrix</a></code></p>
</dd>
<dt><code>sparse</code></dt><dd>
<p><code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>,
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, or
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code></p>
</dd>
<dt><code>C</code></dt><dd><p><code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code></p>
</dd>
<dt><code>R</code></dt><dd><p><code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code></p>
</dd>
<dt><code>T</code></dt><dd><p><code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code></p>
</dd>
<dt><code>gen</code></dt><dd><p><code><a href="#topic+generalMatrix-class">generalMatrix</a></code></p>
</dd>
<dt><code>sym</code></dt><dd><p><code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code></p>
</dd>
<dt><code>tri</code></dt><dd><p><code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code></p>
</dd>
<dt><code>diag</code></dt><dd><p><code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code></p>
</dd>
<dt><code>ind</code></dt><dd><p><code><a href="#topic+indMatrix-class">indMatrix</a></code></p>
</dd>
</dl>

<p>Abbreviations should be seen as a guide, rather than as an
exact description of behaviour.  Notably, <code>.m2dense</code>,
<code>.m2sparse</code>, and <code>.m2V</code> accept vectors that are
not matrices.
</p>


<h4><code>.tCRT(x)</code></h4>

<p>If <code>lazy = TRUE</code>, then <code>.tCRT</code> constructs the transpose
of <code>x</code> using the most efficient representation,
which for &lsquo;<span class="samp">&#8288;CRT&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;RCT&#8288;</span>&rsquo;.  If <code>lazy = FALSE</code>,
then <code>.tCRT</code> preserves the representation of <code>x</code>,
behaving as the corresponding methods for generic function <code>t</code>.
</p>



<h4><code>.diag.dsC(x)</code></h4>

<p><code>.diag.dsC</code> computes (or uses if <code>Chx</code> is supplied)
the Cholesky factorization of <code>x</code> as <code class="reqn">L D L'</code> in order
to calculate one of several possible statistics from the diagonal
entries of <code class="reqn">D</code>.  See <code>res.kind</code> under &lsquo;Arguments&rsquo;.
</p>



<h4><code>.solve.dgC.*(a, b)</code></h4>

<p><code>.solve.dgC.lu(a, b)</code> needs a square matrix <code>a</code>.
<code>.solve.dgC.qr(a, b)</code> needs a &ldquo;long&rdquo; matrix <code>a</code>,
with <code>nrow(a) &gt;= ncol(a)</code>.
<code>.solve.dgC.chol(a, b)</code> needs a &ldquo;wide&rdquo; matrix <code>a</code>,
with <code>nrow(a) &lt;= ncol(a)</code>.
</p>
<p>All three may be used to solve sparse linear systems directly.
Only <code>.solve.dgC.qr</code> and <code>.solve.dgC.chol</code> be used
to solve sparse <em>least squares</em> problems.
</p>



<h4><code>.updateCHMfactor(object, parent, mult)</code></h4>

<p><code>.updateCHMfactor</code> updates <code>object</code> with the result
of Cholesky factorizing
<code>F(parent) + mult[1] * diag(nrow(parent))</code>,
i.e., <code>F(parent)</code> plus <code>mult[1]</code> times the identity matrix,
where <code>F = identity</code> if <code>parent</code> is a <code>dsCMatrix</code>
and <code>F = tcrossprod</code> if <code>parent</code> is a <code>dgCMatrix</code>.
The nonzero pattern of <code>F(parent)</code> must match
that of <code>S</code> if <code>object = Cholesky(S, ...)</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
D. &lt;- diag(x = c(1, 1, 2, 3, 5, 8))
D.0 &lt;- Diagonal(x = c(0, 0, 0, 3, 5, 8))
S. &lt;- toeplitz(as.double(1:6))
C. &lt;- new("dgCMatrix", Dim = c(3L, 4L),
          p = c(0L, 1L, 1L, 1L, 3L), i = c(1L, 0L, 2L), x = c(-8, 2, 3))

stopifnot(exprs = {
    identical(.M2tri (D.), as(D., "triangularMatrix"))
    identical(.M2sym (D.), as(D.,  "symmetricMatrix"))
    identical(.M2diag(D.), as(D.,   "diagonalMatrix"))
    identical(.M2kind(C., "l"),
              as(C., "lMatrix"))
    identical(.M2kind(.sparse2dense(C.), "l"),
              as(as(C., "denseMatrix"), "lMatrix"))
    identical(.diag2sparse(D.0, ".", "t", "C"),
              .dense2sparse(.diag2dense(D.0, ".", "t", TRUE), "C"))
    identical(.M2gen(.diag2dense(D.0, ".", "s", FALSE)),
              .sparse2dense(.M2gen(.diag2sparse(D.0, ".", "s", "T"))))
    identical(S.,
              .M2m(.m2sparse(S., ".sR")))
    identical(S. * lower.tri(S.) + diag(1, 6L),
              .M2m(.m2dense (S., ".tr", "L", "U")))
    identical(.M2R(C.), .M2R(.M2T(C.)))
    identical(.tCRT(C.), .M2R(t(C.)))
})

A &lt;- tcrossprod(C.)/6 + Diagonal(3, 1/3); A[1,2] &lt;- 3; A
stopifnot(exprs = {
    is.numeric( x. &lt;- c(2.2, 0, -1.2) )
    all.equal(x., .solve.dgC.lu(A, c(1,0,0), check=FALSE))
    all.equal(x., .solve.dgC.qr(A, c(1,0,0), check=FALSE))
})

## Solving sparse least squares:

X &lt;- rbind(A, Diagonal(3)) # design matrix X (for L.S.)
Xt &lt;- t(X)                 # *transposed*  X (for L.S.)
(y &lt;- drop(crossprod(Xt, 1:3)) + c(-1,1)/1000) # small rand.err.
str(solveCh &lt;- .solve.dgC.chol(Xt, y, check=FALSE)) # Xt *is* dgC..
stopifnot(exprs = {
    all.equal(solveCh$coef, 1:3, tol = 1e-3)# rel.err ~ 1e-4
    all.equal(solveCh$coef, drop(solve(tcrossprod(Xt), Xt %*% y)))
    all.equal(solveCh$coef, .solve.dgC.qr(X, y, check=FALSE))
})
</code></pre>

<hr>
<h2 id='forceSymmetric-methods'>Force a Matrix to 'symmetricMatrix' Without Symmetry Checks</h2><span id='topic+forceSymmetric'></span><span id='topic+forceSymmetric-methods'></span><span id='topic+forceSymmetric+2CCsparseMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CCsparseMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2CRsparseMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CRsparseMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2CTsparseMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CTsparseMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2CdenseMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CdenseMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2CdiagonalMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CdiagonalMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2CindMatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2CindMatrix+2Cmissing-method'></span><span id='topic+forceSymmetric+2Cmatrix+2Ccharacter-method'></span><span id='topic+forceSymmetric+2Cmatrix+2Cmissing-method'></span>

<h3>Description</h3>

<p>Force a square matrix <code>x</code> to a <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>,
<b>without</b> a symmetry check as it would be applied for <code>as(x,
    "symmetricMatrix")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forceSymmetric(x, uplo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forceSymmetric-methods_+3A_x">x</code></td>
<td>
<p>any square matrix (of numbers), either &ldquo;&quot;traditional&quot;&rdquo;
(<code><a href="base.html#topic+matrix">matrix</a></code>) or inheriting from
<code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</td></tr>
<tr><td><code id="forceSymmetric-methods_+3A_uplo">uplo</code></td>
<td>
<p>optional string, <code>"U"</code> or <code>"L"</code> indicating which
&ldquo;triangle&rdquo; half of <code>x</code> should determine the result.  The
default is <code>"U"</code> unless <code>x</code> already has a <code>uplo</code> slot
(i.e., when it is <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>, or
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>), where the default will be
<code>x@uplo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix inheriting from class
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symmpart">symmpart</a></code> for the symmetric part of a matrix, or
the coercions <code>as(x, &lt;symmetricMatrix class&gt;)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Hilbert matrix
 i &lt;- 1:6
 h6 &lt;- 1/outer(i - 1L, i, "+")
 sd &lt;- sqrt(diag(h6))
 hh &lt;- t(h6/sd)/sd # theoretically symmetric
 isSymmetric(hh, tol=0) # FALSE; hence
 try( as(hh, "symmetricMatrix") ) # fails, but this works fine:
 H6 &lt;- forceSymmetric(hh)

 ## result can be pretty surprising:
 (M &lt;- Matrix(1:36, 6))
 forceSymmetric(M) # symmetric, hence very different in lower triangle
 (tm &lt;- tril(M))
 forceSymmetric(tm)
</code></pre>

<hr>
<h2 id='formatSparseM'>Formatting Sparse Numeric Matrices Utilities</h2><span id='topic+formatSparseM'></span><span id='topic+.formatSparseSimple'></span>

<h3>Description</h3>

<p>Utilities for formatting sparse numeric matrices in a flexible way.
These functions are used by the <code><a href="base.html#topic+format">format</a></code> and <code>print</code>
methods for sparse matrices and can be applied as well to standard <span class="rlang"><b>R</b></span>
matrices.  Note that <em>all</em> arguments but the first are optional.
</p>
<p><code>formatSparseM()</code> is the main &ldquo;workhorse&rdquo; of
<code><a href="#topic+formatSpMatrix">formatSpMatrix</a></code>, the <code>format</code> method for sparse
matrices.
</p>
<p><code>.formatSparseSimple()</code> is a simple helper function, also dealing
with (short/empty) column names construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatSparseM(x, zero.print = ".", align = c("fancy", "right"),
              m = as(x,"matrix"), asLogical=NULL, uniDiag=NULL,
              digits=NULL, cx, iN0, dn = dimnames(m))

.formatSparseSimple(m, asLogical=FALSE, digits=NULL,
		    col.names, note.dropping.colnames = TRUE,
                    dn=dimnames(m))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatSparseM_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_zero.print">zero.print</code></td>
<td>
<p>character which should be used for
<em>structural</em> zeroes.  The default <code>"."</code> may occasionally
be replaced by <code>" "</code> (blank); using <code>"0"</code> would look
almost like <code>print()</code>ing of non-sparse matrices.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_align">align</code></td>
<td>
<p>a string specifying how the <code>zero.print</code> codes
should be aligned, see <code><a href="#topic+formatSpMatrix">formatSpMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_m">m</code></td>
<td>
<p>(optional) a (standard <span class="rlang"><b>R</b></span>) <code><a href="base.html#topic+matrix">matrix</a></code> version of <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_aslogical">asLogical</code></td>
<td>
<p>should the matrix be formatted as a logical matrix
(or rather as a numeric one); mostly for <code>formatSparseM()</code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_unidiag">uniDiag</code></td>
<td>
<p>logical indicating if the diagonal entries of a sparse
unit triangular or unit-diagonal matrix should be formatted as
<code>"I"</code> instead of <code>"1"</code> (to emphasize that the 1's are
&ldquo;structural&rdquo;).</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_digits">digits</code></td>
<td>
<p>significant digits to use for printing, see
<code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_cx">cx</code></td>
<td>
<p>(optional) character matrix; a formatted version of <code>x</code>, still
with strings such as <code>"0.00"</code> for the zeros.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_in0">iN0</code></td>
<td>
<p>(optional) integer vector, specifying the location of the
<em>non</em>-zeroes of <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_col.names">col.names</code>, <code id="formatSparseM_+3A_note.dropping.colnames">note.dropping.colnames</code></td>
<td>
<p>see <code><a href="#topic+formatSpMatrix">formatSpMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="formatSparseM_+3A_dn">dn</code></td>
<td>
<p><code><a href="base.html#topic+dimnames">dimnames</a></code> to be used; a list (of length two)
with row and column names (or <code><a href="base.html#topic+NULL">NULL</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character matrix like <code>cx</code>, where the zeros have been replaced
with (padded versions of) <code>zero.print</code>.
As this is a <em>dense</em> matrix, do not use these functions for
really large (really) sparse matrices!
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+formatSpMatrix">formatSpMatrix</a></code> which calls <code>formatSparseM()</code> and is
the <code><a href="base.html#topic+format">format</a></code> method for sparse matrices.<br />
<code><a href="#topic+printSpMatrix">printSpMatrix</a></code> which is used by the (typically
implicitly called) <code><a href="methods.html#topic+show">show</a></code> and <code><a href="base.html#topic+print">print</a></code> methods
for sparse matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- suppressWarnings(matrix(c(0, 3.2, 0,0, 11,0,0,0,0,-7,0), 4,9))
fm &lt;- formatSparseM(m)
noquote(fm)
## nice, but this is nicer {with "units" vertically aligned}:
print(fm, quote=FALSE, right=TRUE)
## and "the same" as :
Matrix(m)

## align = "right" is cheaper --&gt;  the "." are not aligned:
noquote(f2 &lt;- formatSparseM(m,align="r"))
stopifnot(f2 == fm   |   m == 0, dim(f2) == dim(m),
         (f2 == ".") == (m == 0))
</code></pre>

<hr>
<h2 id='generalMatrix-class'>Class &quot;generalMatrix&quot; of General Matrices</h2><span id='topic+generalMatrix-class'></span><span id='topic+coerce+2CgeneralMatrix+2CpackedMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CgeneralMatrix-method'></span><span id='topic+coerce+2Cvector+2CgeneralMatrix-method'></span><span id='topic+dimnames+3C-+2CgeneralMatrix+2CNULL-method'></span><span id='topic+dimnames+3C-+2CgeneralMatrix+2Clist-method'></span>

<h3>Description</h3>

<p>Virtual class of &ldquo;general&rdquo; matrices; i.e., matrices
that do not have a known property such as symmetric, triangular, or
diagonal.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim, Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
<dt><code>factors</code></dt><dd><p>a list of
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code> objects caching
factorizations of the matrix.  Typically, it is initialized
as an empty list and updated &ldquo;automagically&rdquo; whenever
a factorization is computed.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Matrix"</code>, directly.
</p>


<h3>See Also</h3>

<p>Virtual classes
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>,
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>, and
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>.
</p>

<hr>
<h2 id='Hilbert'>Generate a Hilbert matrix</h2><span id='topic+Hilbert'></span>

<h3>Description</h3>

<p>Generate the <code>n</code> by <code>n</code> symmetric Hilbert matrix.  Because
these matrices are ill-conditioned for moderate to large <code>n</code>,
they are often used for testing numerical linear algebra code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hilbert(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hilbert_+3A_n">n</code></td>
<td>
<p>a non-negative integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>n</code> by <code>n</code> symmetric Hilbert matrix as a
<code>"dpoMatrix"</code> object.
</p>


<h3>See Also</h3>

<p>the class <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Hilbert(6)
</code></pre>

<hr>
<h2 id='image-methods'>Methods for image() in Package 'Matrix'</h2><span id='topic+image'></span><span id='topic+image-methods'></span><span id='topic+image+2CANY-method'></span><span id='topic+image+2CCHMfactor-method'></span><span id='topic+image+2CMatrix-method'></span><span id='topic+image+2CdgTMatrix-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="graphics.html#topic+image">image</a></code> in package
<span class="pkg">Matrix</span>.  An image of a matrix simply color codes all matrix
entries and draws the <code class="reqn">n\times m</code> matrix using an
<code class="reqn">n\times m</code> grid of (colored) rectangles.
</p>
<p>The <span class="pkg">Matrix</span> package <code>image</code> methods are based on
<code><a href="lattice.html#topic+levelplot">levelplot</a>()</code> from package <span class="pkg">lattice</span>; hence
these methods return an &ldquo;object&rdquo; of class <code>"trellis"</code>,
producing a graphic when (auto-) <code><a href="base.html#topic+print">print</a>()</code>ed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S4 method for signature 'dgTMatrix'
image(x,
      xlim = c(1, di[2]),
      ylim = c(di[1], 1), aspect = "iso",
      sub = sprintf("Dimensions: %d x %d", di[1], di[2]),
      xlab = "Column", ylab = "Row", cuts = 15,
      useRaster = FALSE,
      useAbs = NULL, colorkey = !useAbs,
      col.regions = NULL,
      lwd = NULL, border.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image-methods_+3A_x">x</code></td>
<td>
<p>a Matrix object, i.e., fulfilling <code><a href="methods.html#topic+is">is</a>(x, "Matrix")</code>.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_xlim">xlim</code>, <code id="image-methods_+3A_ylim">ylim</code></td>
<td>
<p>x- and y-axis limits; may be used to &ldquo;zoom
into&rdquo; matrix.  Note that <code class="reqn">x,y</code> &ldquo;feel reversed&rdquo;:
<code>ylim</code> is for the rows (= 1st index) and <code>xlim</code> for the
columns (= 2nd index).  For convenience, when the limits are integer
valued, they are both extended by <code>0.5</code>; also, <code>ylim</code> is
always used decreasingly.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_aspect">aspect</code></td>
<td>
<p>aspect ratio specified as number (y/x) or string;
see <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_sub">sub</code>, <code id="image-methods_+3A_xlab">xlab</code>, <code id="image-methods_+3A_ylab">ylab</code></td>
<td>
<p>axis annotation with sensible defaults;
see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_cuts">cuts</code></td>
<td>
<p>number of levels the range of matrix values would be
divided into.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_useraster">useRaster</code></td>
<td>
<p>logical indicating if raster graphics should be used
(instead of the tradition rectangle vector drawing).  If true,
<code><a href="lattice.html#topic+panel.levelplot.raster">panel.levelplot.raster</a></code> (from <span class="pkg">lattice</span>
package) is used, and the colorkey is also done via rasters, see
also <code><a href="lattice.html#topic+levelplot">levelplot</a></code> and possibly
<code><a href="grid.html#topic+grid.raster">grid.raster</a></code>.
</p>
<p>Note that using raster graphics may often be faster, but can be slower,
depending on the matrix dimensions and the graphics device (dimensions).</p>
</td></tr>
<tr><td><code id="image-methods_+3A_useabs">useAbs</code></td>
<td>
<p>logical indicating if <code><a href="base.html#topic+abs">abs</a>(x)</code> should be
shown; if <code>TRUE</code>, the former (implicit) default, the default
<code>col.regions</code> will be <code><a href="grDevices.html#topic+grey">grey</a></code> colors (and no
<code>colorkey</code> drawn).  The default is <code>FALSE</code> unless the
matrix has no negative entries.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_colorkey">colorkey</code></td>
<td>
<p>logical indicating if a color key aka &lsquo;legend&rsquo;
should be produced.  Default is to draw one, unless <code>useAbs</code> is
true.  You can also specify a <code><a href="base.html#topic+list">list</a></code>, see
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>, such as<code>list(raster=TRUE)</code> in
the case of rastering.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_col.regions">col.regions</code></td>
<td>
<p>vector of gradually varying colors; see
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_lwd">lwd</code></td>
<td>
<p>(only used when <code>useRaster</code> is false:) non-negative
number or <code>NULL</code> (default), specifying the line-width of the
rectangles of each non-zero matrix entry (drawn by
<code><a href="grid.html#topic+grid.rect">grid.rect</a></code>).  The default depends on the matrix
dimension and the device size.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_border.col">border.col</code></td>
<td>
<p>color for the border of each rectangle. <code>NA</code>
means no border is drawn.   When <code>NULL</code> as by default,
<code>border.col &lt;- if(lwd &lt; .01) NA else NULL</code> is used.
Consider using an opaque color instead of <code>NULL</code> which
corresponds to <code>grid::<a href="grid.html#topic+get.gpar">get.gpar</a>("col")</code>.</p>
</td></tr>
<tr><td><code id="image-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods and
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>, notably <code>at</code> for specifying
(possibly non equidistant) cut values for dividing the matrix
values (superseding <code>cuts</code> above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as all <span class="pkg">lattice</span> graphics functions, <code>image(&lt;Matrix&gt;)</code>
returns a <code>"trellis"</code> object, effectively the result of
<code><a href="lattice.html#topic+levelplot">levelplot</a>()</code>.
</p>


<h3>Methods</h3>

<p>All methods currently end up calling the method for the
<code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code> class.
Use <code>showMethods(image)</code> to list them all.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+levelplot">levelplot</a></code>, and
<code><a href="lattice.html#topic+print.trellis">print.trellis</a></code> from package <span class="pkg">lattice</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods(image)
## And if you want to see the method definitions:
showMethods(image, includeDefs = TRUE, inherited = FALSE)

data(CAex, package = "Matrix")
image(CAex, main = "image(CAex)") -&gt; imgC; imgC
stopifnot(!is.null(leg &lt;- imgC$legend), is.list(leg$right)) # failed for 2 days ..
image(CAex, useAbs=TRUE, main = "image(CAex, useAbs=TRUE)")

cCA &lt;- Cholesky(crossprod(CAex), Imult = .01)
## See  ?print.trellis --- place two image() plots side by side:
print(image(cCA, main="Cholesky(crossprod(CAex), Imult = .01)"),
      split=c(x=1,y=1,nx=2, ny=1), more=TRUE)
print(image(cCA, useAbs=TRUE),
      split=c(x=2,y=1,nx=2,ny=1))

data(USCounties, package = "Matrix")
image(USCounties)# huge
image(sign(USCounties))## just the pattern
    # how the result looks, may depend heavily on
    # the device, screen resolution, antialiasing etc
    # e.g. x11(type="Xlib") may show very differently than cairo-based

## Drawing borders around each rectangle;
    # again, viewing depends very much on the device:
image(USCounties[1:400,1:200], lwd=.1)
## Using (xlim,ylim) has advantage : matrix dimension and (col/row) indices:
image(USCounties, c(1,200), c(1,400), lwd=.1)
image(USCounties, c(1,300), c(1,200), lwd=.5 )
image(USCounties, c(1,300), c(1,200), lwd=.01)
## These 3 are all equivalent :
(I1 &lt;- image(USCounties, c(1,100), c(1,100), useAbs=FALSE))
 I2 &lt;- image(USCounties, c(1,100), c(1,100), useAbs=FALSE,        border.col=NA)
 I3 &lt;- image(USCounties, c(1,100), c(1,100), useAbs=FALSE, lwd=2, border.col=NA)
stopifnot(all.equal(I1, I2, check.environment=FALSE),
          all.equal(I2, I3, check.environment=FALSE))
## using an opaque border color
image(USCounties, c(1,100), c(1,100), useAbs=FALSE, lwd=3, border.col = adjustcolor("skyblue", 1/2))

if(interactive() || nzchar(Sys.getenv("R_MATRIX_CHECK_EXTRA"))) {
## Using raster graphics: For PDF this would give a 77 MB file,
## however, for such a large matrix, this is typically considerably
## *slower* (than vector graphics rectangles) in most cases :
if(doPNG &lt;- !dev.interactive())
   png("image-USCounties-raster.png", width=3200, height=3200)
image(USCounties, useRaster = TRUE) # should not suffer from anti-aliasing
if(doPNG)
   dev.off()
   ## and now look at the *.png image in a viewer you can easily zoom in and out
}#only if(doExtras)
</code></pre>

<hr>
<h2 id='index-class'>Virtual Class &ldquo;index&rdquo; of Index Vectors</h2><span id='topic+index-class'></span>

<h3>Description</h3>

<p>Class <code>index</code> is a virtual class designating index vectors,
or &ldquo;subscripts&rdquo;, for (possibly named) vectors and arrays.
It is typically used in signatures of methods for the subscript
and subassignment operators, namely <code>[</code> and <code>[&lt;-</code>.
It is implemented as a <em>union</em> of the atomic vector classes
<code><a href="methods.html#topic+numeric-class">numeric</a></code>, <code><a href="methods.html#topic+logical-class">logical</a></code>,
and <code><a href="methods.html#topic+character-class">character</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++5B">[</a></code>, <code><a href="#topic++5B-methods">[-methods</a></code>, and
<code><a href="#topic++5B+3C--methods">[&lt;&ndash;methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("index")
</code></pre>

<hr>
<h2 id='indMatrix-class'>Index Matrices</h2><span id='topic+indMatrix-class'></span><span id='topic++21+2CindMatrix-method'></span><span id='topic+-+2CindMatrix+2Cmissing-method'></span><span id='topic+Math+2CindMatrix-method'></span><span id='topic+Summary+2CindMatrix-method'></span><span id='topic+coerce+2CindMatrix+2CpMatrix-method'></span><span id='topic+coerce+2Clist+2CindMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CindMatrix-method'></span><span id='topic+coerce+2Cnumeric+2CindMatrix-method'></span><span id='topic+determinant+2CindMatrix+2Clogical-method'></span><span id='topic+diag+2CindMatrix-method'></span><span id='topic+diag+3C-+2CindMatrix-method'></span><span id='topic+log+2CindMatrix-method'></span><span id='topic+t+2CindMatrix-method'></span><span id='topic+which+2CindMatrix-method'></span>

<h3>Description</h3>

<p>The <code>indMatrix</code> class is the class of row and column
<em>index</em> matrices, stored as 1-based integer index vectors.
A row (column) index matrix is a matrix whose rows (columns)
are standard unit vectors.  Such matrices are useful
when mapping observations to discrete sets of covariate values.
</p>
<p>Multiplying a matrix on the left by a row index matrix is
equivalent to indexing its rows, i.e., sampling the rows
&ldquo;with replacement&rdquo;.  Analogously, multiplying a matrix
on the right by a column index matrix is equivalent to
indexing its columns.  Indeed, such products are implemented in
<span class="pkg">Matrix</span> as indexing operations; see &lsquo;Details&rsquo; below.
</p>
<p>A matrix whose rows <em>and</em> columns are standard unit vectors
is called a <em>permutation</em> matrix.  This special case is
designated by the <code><a href="#topic+pMatrix-class">pMatrix</a></code> class, a direct
subclass of <code>indMatrix</code>.
</p>


<h3>Details</h3>

<p>The transpose of an index matrix is an index matrix with identical
<code>perm</code> but opposite <code>margin</code>.  Hence the transpose of a
row index matrix is a column index matrix, and vice versa.
</p>
<p>The cross product of a row index matrix <code>R</code> and itself is a
diagonal matrix whose diagonal entries are the the number of entries
in each column of <code>R</code>.
</p>
<p>Given a row index matrix <code>R</code> with <code>perm</code> slot <code>p</code>,
a column index matrix <code>C</code> with <code>perm</code> slot <code>q</code>,
and a matrix <code>M</code> with conformable dimensions, we have
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code class="reqn">R M</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>R %*% M</code>        </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[p, ]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">M C</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M %*% C</code>        </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[, q]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">C'M</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>crossprod(C, M)</code>  </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[q, ]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">MR'</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>tcrossprod(M, R)</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[, p]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">R'R</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>crossprod(R)</code>     </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>Diagonal(x=tabulate(p, ncol(R)))</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">CC'</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>tcrossprod(C)</code>    </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>Diagonal(x=tabulate(q, nrow(C)))</code>
  </td>
</tr>

</table>

<p>Operations on index matrices that result in index matrices will
accordingly return an <code>indMatrix</code>.  These include products
of two column index matrices and (equivalently) column-indexing
of a column index matrix (when dimensions are not dropped).
Most other operations on <code>indMatrix</code> treat them as sparse
nonzero pattern matrices (i.e., inheriting from virtual class
<code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>).  Hence vector-valued subsets
of <code>indMatrix</code>, such as those given by <code><a href="base.html#topic+diag">diag</a></code>,
are always of type <code>"<a href="base.html#topic+logical">logical</a>"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created explicitly with calls of the form
<code>new("indMatrix", ...)</code>, but they are more commonly created
by coercing 1-based integer index vectors, with calls of the
form <code>as(., "indMatrix")</code>; see &lsquo;Methods&rsquo; below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>margin</code></dt><dd><p>an integer, either 1 or 2, specifying
whether the matrix is a row (1) or column (2) index.</p>
</dd>
<dt><code>perm</code></dt><dd><p>a 1-based integer index vector, i.e.,
a vector of length <code>Dim[margin]</code> with elements
taken from <code>1:Dim[1+margin%%2]</code>.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code></dt><dd><p>inherited from virtual
superclass <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Classes <code>"<a href="#topic+sparseMatrix-class">sparseMatrix</a>"</code> and
<code>"<a href="#topic+generalMatrix-class">generalMatrix</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt><code>%*%</code></dt><dd><p><code>signature(x = "indMatrix", y = "Matrix")</code>
and others listed by <code>showMethods("%*%", classes = "indMatrix")</code>:
matrix products implemented where appropriate as indexing operations.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "numeric", to = "indMatrix")</code>:
supporting typical <code>indMatrix</code> construction from
a vector of positive integers.  Row indexing is assumed.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "list", to = "indMatrix")</code>:
supporting <code>indMatrix</code> construction for row <em>and</em>
column indexing, including index vectors of length 0 and
index vectors whose maximum is less than the number of rows
or columns being indexed.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "indMatrix", to = "matrix")</code>:
coercion to a traditional <code><a href="base.html#topic+matrix">matrix</a></code> of <a href="base.html#topic+logical">logical</a> type,
with <code>FALSE</code> and <code>TRUE</code> in place of 0 and 1.</p>
</dd>
<dt><code>t</code></dt><dd><p><code>signature(x = "indMatrix")</code>:
the transpose, which is an <code>indMatrix</code> with identical
<code>perm</code> but opposite <code>margin</code>.</p>
</dd>
<dt><code>rowSums</code>,<code>rowMeans</code>,<code>colSums</code>,<code>colMeans</code></dt><dd><p><code>signature(x = "indMatrix")</code>:
row and column sums and means.</p>
</dd>
<dt><code>rbind2</code>,<code>cbind2</code></dt><dd><p><code>signature(x = "indMatrix", y = "indMatrix")</code>:
row-wise catenation of two row index matrices with equal numbers
of columns and column-wise catenation of two column index matrices
with equal numbers of rows.</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "indMatrix", Y = "indMatrix")</code>:
Kronecker product of two row index matrices or two column index
matrices, giving the row or column index matrix corresponding to
their &ldquo;interaction&rdquo;.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Fabian Scheipl at &lsquo;<span class="file">uni-muenchen.de</span>&rsquo;, building on the existing class
<code><a href="#topic+pMatrix-class">pMatrix</a></code> after a nice hike's conversation with
Martin Maechler.  Methods for <code><a href="#topic+crossprod">crossprod</a>(x, y)</code> and
<code><a href="#topic+kronecker">kronecker</a>(x, y)</code> with both arguments inheriting from
<code>indMatrix</code> were made considerably faster thanks to a suggestion
by Boris Vaillant.  Diverse tweaks by Martin Maechler and
Mikael Jagan, notably the latter's implementation of <code>margin</code>,
prior to which the <code>indMatrix</code> class was designated only for
row index matrices.
</p>


<h3>See Also</h3>

<p>Subclass <code><a href="#topic+pMatrix-class">pMatrix</a></code> of permutation matrices,
a special case of index matrices; virtual class
<code><a href="#topic+nMatrix-class">nMatrix</a></code> of nonzero pattern matrices,
and its subclasses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as(c(2,3,1), "pMatrix")
(sm1 &lt;- as(rep(c(2,3,1), e=3), "indMatrix"))
stopifnot(all(sm1 == p1[rep(1:3, each=3),]))

## row-indexing of a &lt;pMatrix&gt; turns it into an &lt;indMatrix&gt;:
class(p1[rep(1:3, each=3),])

set.seed(12) # so we know '10' is in sample
## random index matrix for 30 observations and 10 unique values:
(s10 &lt;- as(sample(10, 30, replace=TRUE),"indMatrix"))

## Sample rows of a numeric matrix :
(mm &lt;- matrix(1:10, nrow=10, ncol=3))
s10 %*% mm

set.seed(27)
IM1 &lt;- as(sample(1:20, 100, replace=TRUE), "indMatrix")
IM2 &lt;- as(sample(1:18, 100, replace=TRUE), "indMatrix")
(c12 &lt;- crossprod(IM1,IM2))
## same as cross-tabulation of the two index vectors:
stopifnot(all(c12 - unclass(table(IM1@perm, IM2@perm)) == 0))

# 3 observations, 4 implied values, first does not occur in sample:
as(2:4, "indMatrix")
# 3 observations, 5 values, first and last do not occur in sample:
as(list(2:4, 5), "indMatrix")

as(sm1, "nMatrix")
s10[1:7, 1:4] # gives an "ngTMatrix" (most economic!)
s10[1:4, ]  # preserves "indMatrix"-class

I1 &lt;- as(c(5:1,6:4,7:3), "indMatrix")
I2 &lt;- as(7:1, "pMatrix")
(I12 &lt;- rbind(I1, I2))
stopifnot(is(I12, "indMatrix"),
          identical(I12, rbind(I1, I2)),
	  colSums(I12) == c(2L,2:4,4:2))
</code></pre>

<hr>
<h2 id='invertPerm'>Utilities for Permutation Vectors</h2><span id='topic+invertPerm'></span><span id='topic+signPerm'></span><span id='topic+isPerm'></span><span id='topic+asPerm'></span><span id='topic+invPerm'></span>

<h3>Description</h3>

<p><code>invertPerm</code> and <code>signPerm</code> compute the inverse and sign
of a length-<code>n</code> permutation vector.  <code>isPerm</code> tests
if a length-<code>n</code> integer vector is a valid permutation vector.
<code>asPerm</code> coerces a length-<code>m</code> transposition vector to a
length-<code>n</code> permutation vector, where <code>m &lt;= n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertPerm(p, off = 1L, ioff = 1L)
signPerm(p, off = 1L)
isPerm(p, off = 1L)
asPerm(pivot, off = 1L, ioff = 1L, n = length(pivot))

invPerm(p, zero.p = FALSE, zero.res = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertPerm_+3A_p">p</code></td>
<td>
<p>an integer vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_pivot">pivot</code></td>
<td>
<p>an integer vector of length <code>m</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_off">off</code></td>
<td>
<p>an integer offset, indicating that <code>p</code> is
a permutation of <code>off+0:(n-1)</code> or that <code>pivot</code>
contains <code>m</code> values sampled with replacement from
<code>off+0:(n-1)</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_ioff">ioff</code></td>
<td>
<p>an integer offset, indicating that the result
should be a permutation of <code>ioff+0:(n-1)</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_n">n</code></td>
<td>
<p>a integer greater than or equal to <code>m</code>,
indicating the length of the result.  Transpositions
are applied to a permutation vector vector initialized
as <code>seq_len(n)</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_zero.p">zero.p</code></td>
<td>
<p>a logical.  Equivalent to <code>off=0</code> if <code>TRUE</code>
and <code>off=1</code> if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="invertPerm_+3A_zero.res">zero.res</code></td>
<td>
<p>a logical.  Equivalent to <code>ioff=0</code> if <code>TRUE</code>
and <code>ioff=1</code> if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>invertPerm(p, off, ioff=1)</code> is equivalent to
<code><a href="base.html#topic+order">order</a>(p)</code> or <code><a href="base.html#topic+sort.list">sort.list</a>(p)</code>
for all values of <code>off</code>.  For the default value
<code>off=1</code>, it returns the value of <code>p</code> after
<code>p[p] &lt;- seq_along(p)</code>.
</p>
<p><code>invPerm</code> is a simple wrapper around <code>invertPerm</code>,
retained for backwards compatibility.
</p>


<h3>Value</h3>

<p>By default, i.e., with <code>off=1</code> and <code>ioff=1</code>:
</p>
<p><code>invertPerm(p)</code> returns an integer vector of length
<code>length(p)</code> such that <code>p[invertPerm(p)]</code>
and <code>invertPerm(p)[p]</code> are both <code>seq_along(p)</code>,
i.e., the identity permutation.
</p>
<p><code>signPerm(p)</code> returns 1 if <code>p</code> is an even permutation
and <code>-1</code> otherwise (i.e., if <code>p</code> is odd).
</p>
<p><code>isPerm(p)</code> returns <code>TRUE</code> if <code>p</code> is a
permutation of <code>seq_along(p)</code> and <code>FALSE</code> otherwise.
</p>
<p><code>asPerm(pivot)</code> returns the result of transposing elements
<code>i</code> and <code>pivot[i]</code> of a permutation vector initialized
as <code>seq_len(n)</code>, for <code>i</code> in <code>seq_along(pivot)</code>.
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+pMatrix-class">pMatrix</a></code> of permutation matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- sample(10L) # a random permutation vector
ip &lt;- invertPerm(p)
s &lt;- signPerm(p)

## 'p' and 'ip' are indeed inverses:
stopifnot(exprs = {
    isPerm(p)
    isPerm(ip)
    identical(s, 1L) || identical(s, -1L)
    identical(s, signPerm(ip))
    identical(p[ip], 1:10)
    identical(ip[p], 1:10)
    identical(invertPerm(ip), p)
})

## Product of transpositions (1 2)(2 1)(4 3)(6 8)(10 1) = (3 4)(6 8)(1 10)
pivot &lt;- c(2L, 1L, 3L, 3L, 5L, 8L, 7L, 8L, 9L, 1L)
q &lt;- asPerm(pivot)
stopifnot(exprs = {
    identical(q, c(10L, 2L, 4L, 3L, 5L, 8L, 7L, 6L, 9L, 1L))
    identical(q[q], seq_len(10L)) # because the permutation is odd:
    signPerm(q) == -1L
})

invPerm # a less general version of 'invertPerm'

</code></pre>

<hr>
<h2 id='is.na-methods'>is.na(), is.finite() Methods for 'Matrix' Objects</h2><span id='topic+anyNA'></span><span id='topic+anyNA-methods'></span><span id='topic+is.na'></span><span id='topic+is.na-methods'></span><span id='topic+is.nan'></span><span id='topic+is.nan-methods'></span><span id='topic+is.infinite'></span><span id='topic+is.infinite-methods'></span><span id='topic+is.finite'></span><span id='topic+is.finite-methods'></span><span id='topic+anyNA+2CdenseMatrix-method'></span><span id='topic+anyNA+2CdiagonalMatrix-method'></span><span id='topic+anyNA+2CindMatrix-method'></span><span id='topic+anyNA+2CsparseMatrix-method'></span><span id='topic+anyNA+2CsparseVector-method'></span><span id='topic+is.na+2CabIndex-method'></span><span id='topic+is.na+2CdenseMatrix-method'></span><span id='topic+is.na+2CdiagonalMatrix-method'></span><span id='topic+is.na+2CindMatrix-method'></span><span id='topic+is.na+2CsparseMatrix-method'></span><span id='topic+is.na+2CsparseVector-method'></span><span id='topic+is.nan+2CdenseMatrix-method'></span><span id='topic+is.nan+2CdiagonalMatrix-method'></span><span id='topic+is.nan+2CindMatrix-method'></span><span id='topic+is.nan+2CsparseMatrix-method'></span><span id='topic+is.nan+2CsparseVector-method'></span><span id='topic+is.infinite+2CabIndex-method'></span><span id='topic+is.infinite+2CdenseMatrix-method'></span><span id='topic+is.infinite+2CdiagonalMatrix-method'></span><span id='topic+is.infinite+2CindMatrix-method'></span><span id='topic+is.infinite+2CsparseMatrix-method'></span><span id='topic+is.infinite+2CsparseVector-method'></span><span id='topic+is.finite+2CabIndex-method'></span><span id='topic+is.finite+2CdenseMatrix-method'></span><span id='topic+is.finite+2CdiagonalMatrix-method'></span><span id='topic+is.finite+2CindMatrix-method'></span><span id='topic+is.finite+2CsparseMatrix-method'></span><span id='topic+is.finite+2CsparseVector-method'></span>

<h3>Description</h3>

<p>Methods for generic functions <code><a href="#topic+anyNA">anyNA</a>()</code>,
<code><a href="#topic+is.na">is.na</a>()</code>, <code><a href="#topic+is.nan">is.nan</a>()</code>,
<code><a href="#topic+is.infinite">is.infinite</a>()</code>, and <code><a href="#topic+is.finite">is.finite</a>()</code>,
for objects inheriting from virtual class
<code><a href="#topic+Matrix-class">Matrix</a></code> or <code><a href="#topic+sparseVector-class">sparseVector</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'denseMatrix'
is.na(x)
## S4 method for signature 'sparseMatrix'
is.na(x)
## S4 method for signature 'diagonalMatrix'
is.na(x)
## S4 method for signature 'indMatrix'
is.na(x)
## S4 method for signature 'sparseVector'
is.na(x)
## ...
## and likewise for anyNA, is.nan, is.infinite, is.finite
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.na-methods_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, here a sparse or dense matrix or vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>is.*()</code>, an <code><a href="#topic+nMatrix-class">nMatrix</a></code> or
<code><a href="#topic+nsparseVector-class">nsparseVector</a></code> matching the dimensions
of <code>x</code> and specifying the positions in <code>x</code> of
(some subset of) <code><a href="base.html#topic+NA">NA</a></code>, <code><a href="base.html#topic+NaN">NaN</a></code>,
<code><a href="base.html#topic+Inf">Inf</a></code>, and <code>-Inf</code>.
For <code>anyNA</code>(), <code>TRUE</code> if <code>x</code> contains <code>NA</code>
or <code>NaN</code> and <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+NA">NA</a></code>, <code><a href="base.html#topic+NaN">NaN</a></code>, <code><a href="base.html#topic+Inf">Inf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(M &lt;- Matrix(1:6, nrow = 4, ncol = 3,
             dimnames = list(letters[1:4], LETTERS[1:3])))
stopifnot(!anyNA(M), !any(is.na(M)))

M[2:3, 2] &lt;- NA
(inM &lt;- is.na(M))
stopifnot(anyNA(M), sum(inM) == 2)

(A &lt;- spMatrix(nrow = 10, ncol = 20,
               i = c(1, 3:8), j = c(2, 9, 6:10), x = 7 * (1:7)))
stopifnot(!anyNA(A), !any(is.na(A)))

A[2, 3] &lt;- A[1, 2] &lt;- A[5, 5:9] &lt;- NA
(inA &lt;- is.na(A))
stopifnot(anyNA(A), sum(inA) == 1 + 1 + 5)
</code></pre>

<hr>
<h2 id='is.null.DN'>Are the Dimnames <code>dn</code> NULL-like ?</h2><span id='topic+is.null.DN'></span>

<h3>Description</h3>

<p>Are the <code><a href="base.html#topic+dimnames">dimnames</a></code> <code>dn</code> <code><a href="base.html#topic+NULL">NULL</a></code>-like?
</p>
<p><code>is.null.DN(dn)</code> is less strict than <code><a href="base.html#topic+is.null">is.null</a>(dn)</code>,
because it is also true (<code><a href="base.html#topic+TRUE">TRUE</a></code>) when the dimnames
<code>dn</code> are &ldquo;like&rdquo; <code>NULL</code>, or <code>list(NULL,NULL)</code>, as
they can easily be for the traditional <span class="rlang"><b>R</b></span> matrices
(<code><a href="base.html#topic+matrix">matrix</a></code>) which have no formal <code><a href="base.html#topic+class">class</a></code>
definition, and hence much freedom in how their <code><a href="base.html#topic+dimnames">dimnames</a></code>
look like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.null.DN(dn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.null.DN_+3A_dn">dn</code></td>
<td>
<p><code><a href="base.html#topic+dimnames">dimnames</a>()</code> of a <code><a href="base.html#topic+matrix">matrix</a></code>-like <span class="rlang"><b>R</b></span>
object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+logical">logical</a></code> <code><a href="base.html#topic+TRUE">TRUE</a></code> or <code><a href="base.html#topic+FALSE">FALSE</a></code>.
</p>


<h3>Note</h3>

<p>This function is really to be used on &ldquo;traditional&rdquo; matrices
rather than those inheriting from <code><a href="#topic+Matrix-class">Matrix</a></code>, as
the latter will always have dimnames <code>list(NULL,NULL)</code> exactly,
in such a case.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.null">is.null</a></code>,
<code><a href="base.html#topic+dimnames">dimnames</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m1 &lt;- m2 &lt;- m3 &lt;- m4 &lt;- m &lt;-
    matrix(round(100 * rnorm(6)), 2, 3)
dimnames(m1) &lt;- list(NULL, NULL)
dimnames(m2) &lt;- list(NULL, character())
dimnames(m3) &lt;- rev(dimnames(m2))
dimnames(m4) &lt;- rep(list(character()),2)

m4 # prints absolutely identically to m

c.o &lt;- capture.output
cm &lt;- c.o(m)
stopifnot(exprs = {
    m == m1; m == m2; m == m3; m == m4
	identical(cm, c.o(m1));	identical(cm, c.o(m2))
	identical(cm, c.o(m3)); identical(cm, c.o(m4))
})

hasNoDimnames &lt;- function(.) is.null.DN(dimnames(.))
stopifnot(exprs = {
    hasNoDimnames(m)
    hasNoDimnames(m1); hasNoDimnames(m2)
    hasNoDimnames(m3); hasNoDimnames(m4)
    hasNoDimnames(Matrix(m) -&gt; M)
    hasNoDimnames(as(M, "sparseMatrix"))
})
</code></pre>

<hr>
<h2 id='isSymmetric-methods'>Methods for Function 'isSymmetric' in Package 'Matrix'</h2><span id='topic+isSymmetric'></span><span id='topic+isSymmetric-methods'></span><span id='topic+isSymmetric+2CCsparseMatrix-method'></span><span id='topic+isSymmetric+2CRsparseMatrix-method'></span><span id='topic+isSymmetric+2CTsparseMatrix-method'></span><span id='topic+isSymmetric+2CdenseMatrix-method'></span><span id='topic+isSymmetric+2CdiagonalMatrix-method'></span><span id='topic+isSymmetric+2CindMatrix-method'></span><span id='topic+isSymmetric+2CdgCMatrix-method'></span><span id='topic+isSymmetric+2CdgRMatrix-method'></span><span id='topic+isSymmetric+2CdgTMatrix-method'></span><span id='topic+isSymmetric+2CdgeMatrix-method'></span><span id='topic+isSymmetric+2CdtCMatrix-method'></span><span id='topic+isSymmetric+2CdtRMatrix-method'></span><span id='topic+isSymmetric+2CdtTMatrix-method'></span><span id='topic+isSymmetric+2CdtpMatrix-method'></span><span id='topic+isSymmetric+2CdtrMatrix-method'></span>

<h3>Description</h3>

<p><code>isSymmetric</code> tests whether its argument is a symmetric square
matrix, by default tolerating some numerical fuzz and requiring
symmetric <code>[dD]imnames</code> in addition to symmetry in the
mathematical sense.  <code>isSymmetric</code> is a generic function in
<span class="pkg">base</span>, which has a <a href="#topic+isSymmetric">method</a> for traditional
matrices of implicit <code><a href="base.html#topic+class">class</a></code> <code>"<a href="base.html#topic+matrix">matrix</a>"</code>.
Methods are defined here for various proper and virtual classes
in <span class="pkg">Matrix</span>, so that <code>isSymmetric</code> works for all objects
inheriting from virtual class <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'denseMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'CsparseMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'RsparseMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'TsparseMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'diagonalMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'indMatrix'
isSymmetric(object, checkDN = TRUE, ...)
## S4 method for signature 'dgeMatrix'
isSymmetric(object, checkDN = TRUE, tol = 100 * .Machine$double.eps, tol1 = 8 * tol, ...)
## S4 method for signature 'dgCMatrix'
isSymmetric(object, checkDN = TRUE, tol = 100 * .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isSymmetric-methods_+3A_object">object</code></td>
<td>
<p>a <code>"Matrix"</code>.</p>
</td></tr>
<tr><td><code id="isSymmetric-methods_+3A_checkdn">checkDN</code></td>
<td>
<p>a <a href="base.html#topic+logical">logical</a> indicating whether symmetry of the
<code>Dimnames</code> <a href="methods.html#topic+slot">slot</a> of <code>object</code> should be checked.</p>
</td></tr>
<tr><td><code id="isSymmetric-methods_+3A_tol">tol</code>, <code id="isSymmetric-methods_+3A_tol1">tol1</code></td>
<td>
<p>numerical tolerances allowing <em>approximate</em>
symmetry of numeric (rather than logical) matrices.  See also
<code><a href="base.html#topic+isSymmetric.matrix">isSymmetric.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="isSymmetric-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods
(typically methods for <code><a href="#topic+all.equal">all.equal</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Dimnames</code> <a href="methods.html#topic+slot">slot</a> of <code>object</code>, say <code>dn</code>,
is considered to be symmetric if and only if
</p>

<ul>
<li> <p><code>dn[[1]]</code> and <code>dn[[2]]</code> are identical <em>or</em>
one is <code>NULL</code>; <em>and</em>
</p>
</li>
<li> <p><code>ndn &lt;- names(dn)</code> is <code>NULL</code> <em>or</em>
<code>ndn[1]</code> and <code>ndn[2]</code> are identical <em>or</em>
one is the empty string <code>""</code>.
</p>
</li></ul>

<p>Hence <code>list(a=nms, a=nms)</code> is considered to be <em>symmetric</em>,
and so too are <code>list(a=nms, NULL)</code> and <code>list(NULL, a=nms)</code>.
</p>
<p>Note that this definition is <em>looser</em> than that employed by
<code><a href="base.html#topic+isSymmetric.matrix">isSymmetric.matrix</a></code>, which requires <code>dn[1]</code> and
<code>dn[2]</code> to be identical, where <code>dn</code> is the <code>dimnames</code>
<a href="base.html#topic+attr">attribute</a> of a traditional matrix.
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+logical">logical</a>, either <code>TRUE</code> or <code>FALSE</code>
(never <code><a href="base.html#topic+NA">NA</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forceSymmetric">forceSymmetric</a></code>;
<code><a href="#topic+symmpart">symmpart</a></code> and <code><a href="#topic+skewpart">skewpart</a></code>;
virtual class <code>"<a href="#topic+symmetricMatrix-class">symmetricMatrix</a>"</code> and its subclasses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isSymmetric(Diagonal(4)) # TRUE of course
M &lt;- Matrix(c(1,2,2,1), 2,2)
isSymmetric(M) # TRUE (*and* of formal class "dsyMatrix")
isSymmetric(as(M, "generalMatrix")) # still symmetric, even if not "formally"
isSymmetric(triu(M)) # FALSE

## Look at implementations:
showMethods("isSymmetric", includeDefs = TRUE) # includes S3 generic from base
</code></pre>

<hr>
<h2 id='isTriangular-methods'>Test whether a Matrix is Triangular or Diagonal</h2><span id='topic+isTriangular'></span><span id='topic+isTriangular-methods'></span><span id='topic+isDiagonal'></span><span id='topic+isDiagonal-methods'></span><span id='topic+isTriangular+2CCsparseMatrix-method'></span><span id='topic+isTriangular+2CRsparseMatrix-method'></span><span id='topic+isTriangular+2CTsparseMatrix-method'></span><span id='topic+isTriangular+2CdenseMatrix-method'></span><span id='topic+isTriangular+2CdiagonalMatrix-method'></span><span id='topic+isTriangular+2CindMatrix-method'></span><span id='topic+isTriangular+2Cmatrix-method'></span><span id='topic+isDiagonal+2CCsparseMatrix-method'></span><span id='topic+isDiagonal+2CRsparseMatrix-method'></span><span id='topic+isDiagonal+2CTsparseMatrix-method'></span><span id='topic+isDiagonal+2CdenseMatrix-method'></span><span id='topic+isDiagonal+2CdiagonalMatrix-method'></span><span id='topic+isDiagonal+2CindMatrix-method'></span><span id='topic+isDiagonal+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>isTriangular</code> and <code>isDiagonal</code> test whether their argument
is a triangular or diagonal matrix, respectively.  Unlike the analogous
<code><a href="#topic+isSymmetric">isSymmetric</a></code>, these two functions are generically
from <span class="pkg">Matrix</span> rather than <code>base</code>.  Hence <span class="pkg">Matrix</span>
defines methods for traditional matrices of implicit <a href="base.html#topic+class">class</a>
<code>"<a href="base.html#topic+matrix">matrix</a>"</code> in addition to matrices inheriting from
virtual class <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>.
</p>
<p>By our definition, triangular and diagonal matrices are <em>square</em>,
i.e., they have the same number of rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTriangular(object, upper = NA, ...)

isDiagonal(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTriangular-methods_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, typically a matrix.</p>
</td></tr>
<tr><td><code id="isTriangular-methods_+3A_upper">upper</code></td>
<td>
<p>a <a href="base.html#topic+logical">logical</a>, either <code>TRUE</code> or <code>FALSE</code>,
in which case <code>TRUE</code> is returned only for upper or lower
triangular <code>object</code>; or otherwise <code><a href="base.html#topic+NA">NA</a></code> (the
default), in which case <code>TRUE</code> is returned for any triangular
<code>object</code>.</p>
</td></tr>
<tr><td><code id="isTriangular-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods
(currently unused by <span class="pkg">Matrix</span>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+logical">logical</a>, either <code>TRUE</code> or <code>FALSE</code>
(never <code><a href="base.html#topic+NA">NA</a></code>).
</p>
<p>If <code>object</code> is triangular and <code>upper</code> is <code>NA</code>, then
<code>isTriangular</code> returns <code>TRUE</code> with an <a href="base.html#topic+attr">attribute</a> 
<code>kind</code>, either <code>"U"</code> or <code>"L"</code>, indicating that
<code>object</code> is <b>u</b>pper or <b>l</b>ower triangular, respectively.  
Users should not rely on how <code>kind</code> is determined for diagonal
matrices, which are both upper and lower triangular.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isSymmetric">isSymmetric</a></code>;
virtual classes <code>"<a href="#topic+triangularMatrix-class">triangularMatrix</a>"</code> and
<code>"<a href="#topic+diagonalMatrix-class">diagonalMatrix</a>"</code> and their subclasses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isTriangular(Diagonal(4))
## is TRUE: a diagonal matrix is also (both upper and lower) triangular
(M &lt;- Matrix(c(1,2,0,1), 2,2))
isTriangular(M) # TRUE (*and* of formal class "dtrMatrix")
isTriangular(as(M, "generalMatrix")) # still triangular, even if not "formally"
isTriangular(crossprod(M)) # FALSE

isDiagonal(matrix(c(2,0,0,1), 2,2)) # TRUE

## Look at implementations:
showMethods("isTriangular", includeDefs = TRUE)
showMethods("isDiagonal", includeDefs = TRUE)
</code></pre>

<hr>
<h2 id='KhatriRao'>Khatri-Rao Matrix Product</h2><span id='topic+KhatriRao'></span>

<h3>Description</h3>

<p>Computes Khatri-Rao products for any kind of matrices.
</p>
<p>The Khatri-Rao product is a column-wise Kronecker product.  Originally
introduced by Khatri and Rao (1968), it has many different applications,
see Liu and Trenkler (2008) for a survey.  Notably, it is used in
higher-dimensional tensor decompositions, see Bader and Kolda (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KhatriRao(X, Y = X, FUN = "*", sparseY = TRUE, make.dimnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KhatriRao_+3A_x">X</code>, <code id="KhatriRao_+3A_y">Y</code></td>
<td>
<p>matrices of with the same number of columns.</p>
</td></tr>
<tr><td><code id="KhatriRao_+3A_fun">FUN</code></td>
<td>
<p>the (name of the) <code><a href="base.html#topic+function">function</a></code> to be used for the
column-wise Kronecker products, see <code><a href="#topic+kronecker">kronecker</a></code>,
defaulting to the usual multiplication.</p>
</td></tr>
<tr><td><code id="KhatriRao_+3A_sparsey">sparseY</code></td>
<td>
<p>logical specifying if <code>Y</code> should be coerced and
treated as <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.   Set this to
<code>FALSE</code>, e.g., to distinguish structural zeros from zero entries.</p>
</td></tr>
<tr><td><code id="KhatriRao_+3A_make.dimnames">make.dimnames</code></td>
<td>
<p>logical indicating if the result should inherit
<code><a href="base.html#topic+dimnames">dimnames</a></code> from <code>X</code> and <code>Y</code> in a simple way.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>"<a href="#topic+CsparseMatrix-class">CsparseMatrix</a>"</code>, say <code>R</code>, the Khatri-Rao
product of <code>X</code> (<code class="reqn">n \times k</code>) and <code>Y</code> (<code class="reqn">m
    \times k</code>), is of dimension <code class="reqn">(n\cdot m) \times k</code>,
where the j-th column, <code>R[,j]</code> is the kronecker product
<code><a href="#topic+kronecker">kronecker</a>(X[,j], Y[,j])</code>.
</p>


<h3>Note</h3>


<p>The current implementation is efficient for large sparse matrices.
</p>


<h3>Author(s)</h3>

<p>Original by Michael Cysouw, Univ. Marburg;
minor tweaks, bug fixes etc, by Martin Maechler.
</p>


<h3>References</h3>

<p>Khatri, C. G., and Rao, C. Radhakrishna (1968)
Solutions to Some Functional Equations and Their Applications to
Characterization of Probability Distributions.
<em>Sankhya: Indian J. Statistics, Series A</em> <b>30</b>, 167&ndash;180.
</p>
<p>Bader, Brett W, and Tamara G Kolda (2008)
Efficient MATLAB Computations with Sparse and Factored Tensors.
<em>SIAM J. Scientific Computing</em> <b>30</b>, 205&ndash;231.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kronecker">kronecker</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with very small matrices:
m &lt;- matrix(1:12,3,4)
d &lt;- diag(1:4)
KhatriRao(m,d)
KhatriRao(d,m)
dimnames(m) &lt;- list(LETTERS[1:3], letters[1:4])
KhatriRao(m,d, make.dimnames=TRUE)
KhatriRao(d,m, make.dimnames=TRUE)
dimnames(d) &lt;- list(NULL, paste0("D", 1:4))
KhatriRao(m,d, make.dimnames=TRUE)
KhatriRao(d,m, make.dimnames=TRUE)
dimnames(d) &lt;- list(paste0("d", 10*1:4), paste0("D", 1:4))
(Kmd &lt;- KhatriRao(m,d, make.dimnames=TRUE))
(Kdm &lt;- KhatriRao(d,m, make.dimnames=TRUE))

nm &lt;- as(m, "nsparseMatrix")
nd &lt;- as(d, "nsparseMatrix")
KhatriRao(nm,nd, make.dimnames=TRUE)
KhatriRao(nd,nm, make.dimnames=TRUE)

stopifnot(dim(KhatriRao(m,d)) == c(nrow(m)*nrow(d), ncol(d)))
## border cases / checks:
zm &lt;- nm; zm[] &lt;- FALSE # all FALSE matrix
stopifnot(all(K1 &lt;- KhatriRao(nd, zm) == 0), identical(dim(K1), c(12L, 4L)),
          all(K2 &lt;- KhatriRao(zm, nd) == 0), identical(dim(K2), c(12L, 4L)))

d0 &lt;- d; d0[] &lt;- 0; m0 &lt;- Matrix(d0[-1,])
stopifnot(all(K3 &lt;- KhatriRao(d0, m) == 0), identical(dim(K3), dim(Kdm)),
	  all(K4 &lt;- KhatriRao(m, d0) == 0), identical(dim(K4), dim(Kmd)),
	  all(KhatriRao(d0, d0) == 0), all(KhatriRao(m0, d0) == 0),
	  all(KhatriRao(d0, m0) == 0), all(KhatriRao(m0, m0) == 0),
	  identical(dimnames(KhatriRao(m, d0, make.dimnames=TRUE)), dimnames(Kmd)))

## a matrix with "structural" and non-structural zeros:
m01 &lt;- new("dgCMatrix", i = c(0L, 2L, 0L, 1L), p = c(0L, 0L, 0L, 2L, 4L),
           Dim = 3:4, x = c(1, 0, 1, 0))
D4 &lt;- Diagonal(4, x=1:4) # "as" d
DU &lt;- Diagonal(4)# unit-diagonal: uplo="U"
(K5  &lt;- KhatriRao( d, m01))
K5d  &lt;- KhatriRao( d, m01, sparseY=FALSE)
K5Dd &lt;- KhatriRao(D4, m01, sparseY=FALSE)
K5Ud &lt;- KhatriRao(DU, m01, sparseY=FALSE)
(K6  &lt;- KhatriRao(diag(3),     t(m01)))
K6D  &lt;- KhatriRao(Diagonal(3), t(m01))
K6d  &lt;- KhatriRao(diag(3),     t(m01), sparseY=FALSE)
K6Dd &lt;- KhatriRao(Diagonal(3), t(m01), sparseY=FALSE)
stopifnot(exprs = {
    all(K5 == K5d)
    identical(cbind(c(7L, 10L), c(3L, 4L)),
              which(K5 != 0, arr.ind = TRUE, useNames=FALSE))
    identical(K5d, K5Dd)
    identical(K6, K6D)
    all(K6 == K6d)
    identical(cbind(3:4, 1L),
              which(K6 != 0, arr.ind = TRUE, useNames=FALSE))
    identical(K6d, K6Dd)
})
</code></pre>

<hr>
<h2 id='KNex'>Koenker-Ng Example Sparse Model Matrix and Response Vector</h2><span id='topic+KNex'></span>

<h3>Description</h3>

<p>A model matrix <code>mm</code> and corresponding response vector <code>y</code>
used in an example by Koenker and Ng.  The matrix <code>mm</code> is a sparse
matrix with 1850 rows and 712 columns but only 8758 non-zero entries.
It is a <code>"dgCMatrix"</code> object.  The vector <code>y</code> is just
<code><a href="base.html#topic+numeric">numeric</a></code> of length 1850.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KNex)</code></pre>


<h3>References</h3>

<p>Roger Koenker and Pin Ng (2003).
SparseM: A sparse matrix package for R;
<em>J. of Statistical Software</em>, <b>8</b> (6),
<a href="https://doi.org/10.18637/jss.v008.i06">doi:10.18637/jss.v008.i06</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KNex, package = "Matrix")
class(KNex$mm)
dim(KNex$mm)
image(KNex$mm)
str(KNex)

system.time( # a fraction of a second
  sparse.sol &lt;- with(KNex, solve(crossprod(mm), crossprod(mm, y))))

head(round(sparse.sol,3))

## Compare with QR-based solution ("more accurate, but slightly slower"):
system.time(
  sp.sol2 &lt;- with(KNex, qr.coef(qr(mm), y) ))

all.equal(sparse.sol, sp.sol2, tolerance = 1e-13) # TRUE
</code></pre>

<hr>
<h2 id='kronecker-methods'>Methods for Function 'kronecker()' in Package 'Matrix'</h2><span id='topic+kronecker'></span><span id='topic+kronecker-methods'></span><span id='topic+kronecker+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+kronecker+2CCsparseMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CCsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+kronecker+2CMatrix+2Cmatrix-method'></span><span id='topic+kronecker+2CMatrix+2Cvector-method'></span><span id='topic+kronecker+2CRsparseMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+kronecker+2CRsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+kronecker+2CTsparseMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+kronecker+2CTsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+kronecker+2CdenseMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CdenseMatrix+2CdenseMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CCsparseMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CRsparseMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CTsparseMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CdiagonalMatrix-method'></span><span id='topic+kronecker+2CdiagonalMatrix+2CindMatrix-method'></span><span id='topic+kronecker+2CindMatrix+2CMatrix-method'></span><span id='topic+kronecker+2CindMatrix+2CdiagonalMatrix-method'></span><span id='topic+kronecker+2CindMatrix+2CindMatrix-method'></span><span id='topic+kronecker+2Cmatrix+2CMatrix-method'></span><span id='topic+kronecker+2Cvector+2CMatrix-method'></span>

<h3>Description</h3>

<p>Computes Kronecker products for objects inheriting from
<code>"<a href="#topic+Matrix-class">Matrix</a>"</code>.
</p>
<p>In order to preserver sparseness, we treat <code>0 * NA</code> as <code>0</code>,
not as <code><a href="base.html#topic+NA">NA</a></code> as usually in <span class="rlang"><b>R</b></span> (and as used for the
<span class="pkg">base</span> function <code><a href="base.html#topic+kronecker">kronecker</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt>kronecker</dt><dd><p><code>signature(X = "Matrix", Y = "ANY")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "ANY", Y = "Matrix")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "diagonalMatrix", Y = "ANY")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "sparseMatrix", Y = "ANY")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "TsparseMatrix", Y = "TsparseMatrix")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "dgTMatrix", Y = "dgTMatrix")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "dtTMatrix", Y = "dtTMatrix")</code> .......</p>
</dd>
<dt>kronecker</dt><dd><p><code>signature(X = "indMatrix", Y = "indMatrix")</code> .......</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>(t1 &lt;- spMatrix(5,4, x= c(3,2,-7,11), i= 1:4, j=4:1)) #  5 x  4
(t2 &lt;- kronecker(Diagonal(3, 2:4), t1))               # 15 x 12

## should also work with special-cased logical matrices
l3 &lt;- upper.tri(matrix(,3,3))
M &lt;- Matrix(l3)
(N &lt;- as(M, "nsparseMatrix")) # "ntCMatrix" (upper triangular)
N2 &lt;- as(N, "generalMatrix")  # (lost "t"riangularity)
MM &lt;- kronecker(M,M)
NN &lt;- kronecker(N,N) # "dtTMatrix" i.e. did keep
NN2 &lt;- kronecker(N2,N2)
stopifnot(identical(NN,MM),
          is(NN2, "sparseMatrix"), all(NN2 == NN),
          is(NN, "triangularMatrix"))
</code></pre>

<hr>
<h2 id='ldenseMatrix-class'>Virtual Class &quot;ldenseMatrix&quot; of Dense Logical Matrices</h2><span id='topic+ldenseMatrix-class'></span><span id='topic++21+2CldenseMatrix-method'></span><span id='topic++26+2CldenseMatrix+2CddiMatrix-method'></span><span id='topic++26+2CldenseMatrix+2CldiMatrix-method'></span><span id='topic++26+2CldenseMatrix+2CndiMatrix-method'></span><span id='topic++2A+2CldenseMatrix+2CddiMatrix-method'></span><span id='topic++2A+2CldenseMatrix+2CldiMatrix-method'></span><span id='topic++2A+2CldenseMatrix+2CndiMatrix-method'></span><span id='topic+Logic+2CldenseMatrix+2ClsparseMatrix-method'></span><span id='topic+Ops+2CldenseMatrix+2CldenseMatrix-method'></span><span id='topic++5E+2CldenseMatrix+2CddiMatrix-method'></span><span id='topic++5E+2CldenseMatrix+2CldiMatrix-method'></span><span id='topic++5E+2CldenseMatrix+2CndiMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CldenseMatrix-method'></span><span id='topic+coerce+2Cvector+2CldenseMatrix-method'></span><span id='topic+which+2CldenseMatrix-method'></span>

<h3>Description</h3>

<p><code>ldenseMatrix</code> is the virtual class of all dense <b>l</b>ogical
(S4) matrices.  It extends both <code><a href="#topic+denseMatrix-class">denseMatrix</a></code>
and <code><a href="#topic+lMatrix-class">lMatrix</a></code> directly.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>logical vector containing the entries of the matrix.</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>see <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"lMatrix"</code>, directly.
Class <code>"denseMatrix"</code>, directly.
Class <code>"Matrix"</code>, by class <code>"lMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"denseMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>as.vector</dt><dd><p><code>signature(x = "ldenseMatrix", mode = "missing")</code>: ...</p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "ndenseMatrix")</code>, semantically
equivalent to <span class="pkg">base</span> function <code><a href="base.html#topic+which">which</a>(x, arr.ind)</code>;
for details, see the <code><a href="#topic+lMatrix-class">lMatrix</a></code> class documentation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Class <code><a href="#topic+lgeMatrix-class">lgeMatrix</a></code> and the other subclasses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ldenseMatrix")

as(diag(3) &gt; 0, "ldenseMatrix")
</code></pre>

<hr>
<h2 id='ldiMatrix-class'>Class &quot;ldiMatrix&quot; of Diagonal Logical Matrices</h2><span id='topic+ldiMatrix-class'></span><span id='topic+ndiMatrix-class'></span><span id='topic++21+2CldiMatrix-method'></span><span id='topic++25+25+2CldiMatrix+2CMatrix-method'></span><span id='topic++25+25+2CldiMatrix+2CddenseMatrix-method'></span><span id='topic++25+25+2CldiMatrix+2CldenseMatrix-method'></span><span id='topic++25+25+2CldiMatrix+2CndenseMatrix-method'></span><span id='topic++25+2F+25+2CldiMatrix+2CMatrix-method'></span><span id='topic++25+2F+25+2CldiMatrix+2CddenseMatrix-method'></span><span id='topic++25+2F+25+2CldiMatrix+2CldenseMatrix-method'></span><span id='topic++25+2F+25+2CldiMatrix+2CndenseMatrix-method'></span><span id='topic++26+2CldiMatrix+2CMatrix-method'></span><span id='topic++26+2CldiMatrix+2CddenseMatrix-method'></span><span id='topic++26+2CldiMatrix+2CldenseMatrix-method'></span><span id='topic++26+2CldiMatrix+2CndenseMatrix-method'></span><span id='topic++2A+2CldiMatrix+2CMatrix-method'></span><span id='topic++2A+2CldiMatrix+2CddenseMatrix-method'></span><span id='topic++2A+2CldiMatrix+2CldenseMatrix-method'></span><span id='topic++2A+2CldiMatrix+2CndenseMatrix-method'></span><span id='topic++2F+2CldiMatrix+2CMatrix-method'></span><span id='topic++2F+2CldiMatrix+2CddenseMatrix-method'></span><span id='topic++2F+2CldiMatrix+2CldenseMatrix-method'></span><span id='topic++2F+2CldiMatrix+2CndenseMatrix-method'></span><span id='topic+Arith+2CldiMatrix+2Clogical-method'></span><span id='topic+Arith+2CldiMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CldiMatrix-method'></span><span id='topic+Arith+2Cnumeric+2CldiMatrix-method'></span><span id='topic+Ops+2CANY+2CldiMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2CANY-method'></span><span id='topic+Ops+2CldiMatrix+2CMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2CdMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2CndiMatrix-method'></span><span id='topic+Ops+2CldiMatrix+2Clogical-method'></span><span id='topic+Ops+2CldiMatrix+2Cnumeric-method'></span><span id='topic+Ops+2CldiMatrix+2CsparseMatrix-method'></span><span id='topic+which+2CldiMatrix-method'></span><span id='topic++21+2CndiMatrix-method'></span><span id='topic++25+25+2CndiMatrix+2CMatrix-method'></span><span id='topic++25+25+2CndiMatrix+2CddenseMatrix-method'></span><span id='topic++25+25+2CndiMatrix+2CldenseMatrix-method'></span><span id='topic++25+25+2CndiMatrix+2CndenseMatrix-method'></span><span id='topic++25+2F+25+2CndiMatrix+2CMatrix-method'></span><span id='topic++25+2F+25+2CndiMatrix+2CddenseMatrix-method'></span><span id='topic++25+2F+25+2CndiMatrix+2CldenseMatrix-method'></span><span id='topic++25+2F+25+2CndiMatrix+2CndenseMatrix-method'></span><span id='topic++26+2CndiMatrix+2CMatrix-method'></span><span id='topic++26+2CndiMatrix+2CddenseMatrix-method'></span><span id='topic++26+2CndiMatrix+2CldenseMatrix-method'></span><span id='topic++26+2CndiMatrix+2CndenseMatrix-method'></span><span id='topic++2A+2CndiMatrix+2CMatrix-method'></span><span id='topic++2A+2CndiMatrix+2CMatrix-method'></span><span id='topic++2A+2CndiMatrix+2CddenseMatrix-method'></span><span id='topic++2A+2CndiMatrix+2CldenseMatrix-method'></span><span id='topic++2A+2CndiMatrix+2CndenseMatrix-method'></span><span id='topic++2F+2CndiMatrix+2CMatrix-method'></span><span id='topic++2F+2CndiMatrix+2CddenseMatrix-method'></span><span id='topic++2F+2CndiMatrix+2CldenseMatrix-method'></span><span id='topic++2F+2CndiMatrix+2CndenseMatrix-method'></span><span id='topic+Ops+2CndiMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CndiMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CndiMatrix+2CndiMatrix-method'></span><span id='topic+which+2CndiMatrix-method'></span>

<h3>Description</h3>

<p>The class <code>"ldiMatrix"</code> of logical diagonal matrices.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ldiMatrix", ...)</code>
but typically rather via <code><a href="#topic+Diagonal">Diagonal</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p><code>"logical"</code> vector.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p><code>"character"</code> string, either &quot;U&quot; or &quot;N&quot;,
see <code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code>.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>matrix dimension and
<code><a href="base.html#topic+dimnames">dimnames</a></code>, see the <code><a href="#topic+Matrix-class">Matrix</a></code> class
description.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+diagonalMatrix-class">diagonalMatrix</a>"</code> and
class <code>"<a href="#topic+lMatrix-class">lMatrix</a>"</code>, directly.
</p>
<p>Class <code>"<a href="#topic+sparseMatrix-class">sparseMatrix</a>"</code>, by class <code>"diagonalMatrix"</code>.
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+ddiMatrix-class">ddiMatrix</a></code> and
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>; function <code><a href="#topic+Diagonal">Diagonal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(lM &lt;- Diagonal(x = c(TRUE,FALSE,FALSE)))
str(lM)#&gt; gory details (slots)

crossprod(lM) # numeric
(nM &lt;- as(lM, "nMatrix"))
crossprod(nM) # pattern sparse
</code></pre>

<hr>
<h2 id='lgeMatrix-class'>Class &quot;lgeMatrix&quot; of General Dense Logical Matrices</h2><span id='topic+lgeMatrix-class'></span><span id='topic+Arith+2ClgeMatrix+2ClgeMatrix-method'></span><span id='topic+Compare+2ClgeMatrix+2ClgeMatrix-method'></span><span id='topic+Logic+2ClgeMatrix+2ClgeMatrix-method'></span>

<h3>Description</h3>

<p>This is the class of general dense <code><a href="base.html#topic+logical">logical</a></code>
matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ldenseMatrix"</code>, directly.
Class <code>"lMatrix"</code>, by class <code>"ldenseMatrix"</code>.
Class <code>"denseMatrix"</code>, by class <code>"ldenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ldenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ldenseMatrix"</code>.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>); use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="lgeMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p>Non-general logical dense matrix classes such as
<code><a href="#topic+ltrMatrix-class">ltrMatrix</a></code>, or <code><a href="#topic+lsyMatrix-class">lsyMatrix</a></code>;
<em>sparse</em> logical classes such as <code><a href="#topic+lgCMatrix-class">lgCMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("lgeMatrix")
str(new("lgeMatrix"))
set.seed(1)
(lM &lt;- Matrix(matrix(rnorm(28), 4,7) &gt; 0))# a simple random lgeMatrix
set.seed(11)
(lC &lt;- Matrix(matrix(rnorm(28), 4,7) &gt; 0))# a simple random lgCMatrix
as(lM, "CsparseMatrix")
</code></pre>

<hr>
<h2 id='lsparseMatrix-class'>Sparse logical matrices</h2><span id='topic+lsparseMatrix-class'></span><span id='topic+lsparseMatrix-classes'></span><span id='topic+lgCMatrix-class'></span><span id='topic+lgRMatrix-class'></span><span id='topic+lgTMatrix-class'></span><span id='topic+ltCMatrix-class'></span><span id='topic+ltRMatrix-class'></span><span id='topic+ltTMatrix-class'></span><span id='topic+lsCMatrix-class'></span><span id='topic+lsRMatrix-class'></span><span id='topic+lsTMatrix-class'></span><span id='topic++21+2ClsparseMatrix-method'></span><span id='topic+Arith+2ClsparseMatrix+2CMatrix-method'></span><span id='topic+Logic+2ClsparseMatrix+2CldenseMatrix-method'></span><span id='topic+Logic+2ClsparseMatrix+2ClsparseMatrix-method'></span><span id='topic+Ops+2ClsparseMatrix+2ClsparseMatrix-method'></span><span id='topic+Ops+2ClsparseMatrix+2CnsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2ClsparseMatrix-method'></span><span id='topic+which+2ClsparseMatrix-method'></span><span id='topic+Arith+2ClgCMatrix+2ClgCMatrix-method'></span><span id='topic+Logic+2ClgCMatrix+2ClgCMatrix-method'></span><span id='topic+Arith+2ClgTMatrix+2ClgTMatrix-method'></span><span id='topic+Logic+2ClgTMatrix+2ClgTMatrix-method'></span><span id='topic+Logic+2CltCMatrix+2CltCMatrix-method'></span><span id='topic+Logic+2ClsCMatrix+2ClsCMatrix-method'></span>

<h3>Description</h3>

<p>The <code>lsparseMatrix</code> class is a virtual class
of logical sparse matrices, i.e., sparse matrices with entries
<code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>.
</p>
<p>These can be stored in the &ldquo;triplet&rdquo; form (class
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, subclasses <code>lgTMatrix</code>,
<code>lsTMatrix</code>, and <code>ltTMatrix</code>) or in compressed
column-oriented form (class <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>,
subclasses <code>lgCMatrix</code>, <code>lsCMatrix</code>, and <code>ltCMatrix</code>)
or&ndash;<em>rarely</em>&ndash;in compressed row-oriented form (class
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, subclasses <code>lgRMatrix</code>,
<code>lsRMatrix</code>, and <code>ltRMatrix</code>).  The second letter in the
name of these non-virtual classes indicates <code>g</code>eneral,
<code>s</code>ymmetric, or <code>t</code>riangular.
</p>


<h3>Details</h3>

<p>Note that triplet stored (<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>) matrices
such as <code>lgTMatrix</code> may contain duplicated pairs of indices
<code class="reqn">(i,j)</code> as for the corresponding numeric class
<code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code> where for such pairs, the corresponding
<code>x</code> slot entries are added.  For logical matrices, the <code>x</code>
entries corresponding to duplicated index pairs <code class="reqn">(i,j)</code> are
&ldquo;added&rdquo; as well if the addition is defined as logical <code class="reqn">or</code>,
i.e., &ldquo;<code>TRUE + TRUE  |-&gt;  TRUE</code>&rdquo; and
&ldquo;<code>TRUE + FALSE  |-&gt;  TRUE</code>&rdquo;.
Note the use of <code><a href="#topic+asUniqueT">asUniqueT</a>()</code> for getting an internally
unique representation without duplicated <code class="reqn">(i,j)</code> entries.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("lgCMatrix",
    ...)</code> and so on.  More frequently objects are created by coercion of
a numeric sparse matrix to the logical form, e.g. in an expression
<code>x != 0</code>.
</p>
<p>The logical form is also used in the symbolic analysis phase
of an algorithm involving sparse matrices.  Such algorithms often
involve two phases: a symbolic phase wherein the positions of the
non-zeros in the result are determined and a numeric phase wherein the
actual results are calculated.  During the symbolic phase only the
positions of the non-zero elements in any operands are of interest,
hence any numeric sparse matrices can be treated as logical sparse
matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>, i.e., either
<code>TRUE</code>, <code><a href="base.html#topic+NA">NA</a></code>, or <code>FALSE</code>.</p>
</dd>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower
triangular. Present in the triangular and symmetric classes but not
in the general class.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code> for non-unit.  The implicit diagonal elements are not
explicitly stored when <code>diag</code> is <code>"U"</code>.  Present in the
triangular classes only.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each column (row), to the initial (zero-based) index of elements in
the column.  Present in compressed column-oriented and compressed
row-oriented forms only.</p>
</dd>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the row numbers for
each TRUE element in the matrix.  All other elements are FALSE.
Present in triplet and compressed column-oriented forms only.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the column numbers for
each TRUE element in the matrix.  All other elements are FALSE.
Present in triplet and compressed row-oriented forms only.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "dgCMatrix", to = "lgCMatrix")</code></p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "lgCMatrix")</code>: returns the transpose
of <code>x</code></p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "lsparseMatrix")</code>, semantically
equivalent to <span class="pkg">base</span> function <code><a href="base.html#topic+which">which</a>(x, arr.ind)</code>;
for details, see the <code><a href="#topic+lMatrix-class">lMatrix</a></code> class documentation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>the class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code> and <code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m &lt;- Matrix(c(0,0,2:0), 3,5, dimnames=list(LETTERS[1:3],NULL)))
(lm &lt;- (m &gt; 1)) # lgC
!lm     # no longer sparse
stopifnot(is(lm,"lsparseMatrix"),
          identical(!lm, m &lt;= 1))

data(KNex, package = "Matrix")
str(mmG.1 &lt;- (KNex $ mm) &gt; 0.1)# "lgC..."
table(mmG.1@x)# however with many ``non-structural zeros''
## from logical to nz_pattern -- okay when there are no NA's :
nmG.1 &lt;- as(mmG.1, "nMatrix") # &lt;&lt;&lt; has "TRUE" also where mmG.1 had FALSE
## from logical to "double"
dmG.1 &lt;- as(mmG.1, "dMatrix") # has '0' and back:
lmG.1 &lt;- as(dmG.1, "lMatrix")
stopifnot(identical(nmG.1, as((KNex $ mm) != 0,"nMatrix")),
          validObject(lmG.1),
          identical(lmG.1, mmG.1))

class(xnx &lt;- crossprod(nmG.1))# "nsC.."
class(xlx &lt;- crossprod(mmG.1))# "dsC.." : numeric
is0 &lt;- (xlx == 0)
mean(as.vector(is0))# 99.3% zeros: quite sparse, but
table(xlx@x == 0)# more than half of the entries are (non-structural!) 0
stopifnot(isSymmetric(xlx), isSymmetric(xnx),
          ## compare xnx and xlx : have the *same* non-structural 0s :
          sapply(slotNames(xnx),
                 function(n) identical(slot(xnx, n), slot(xlx, n))))
</code></pre>

<hr>
<h2 id='lsyMatrix-class'>Symmetric Dense Logical Matrices</h2><span id='topic+lsyMatrix-class'></span><span id='topic+lspMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"lsyMatrix"</code> class is the class of symmetric, dense logical
matrices in non-packed storage and <code>"lspMatrix"</code> is the class of
of these in packed storage. In the packed form, only the upper
triangle or the lower triangle is stored.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("lsyMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Both extend classes <code>"<a href="#topic+ldenseMatrix-class">ldenseMatrix</a>"</code> and
<code>"<a href="#topic+symmetricMatrix-class">symmetricMatrix</a>"</code>, directly; further, class
<code>"Matrix"</code> and others, <em>in</em>directly.  Use
<code><a href="methods.html#topic+showClass">showClass</a>("lsyMatrix")</code>, e.g., for details.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>; use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="lsyMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lgeMatrix-class">lgeMatrix</a></code>, <code><a href="#topic+Matrix-class">Matrix</a></code>,
<code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(M2 &lt;- Matrix(c(TRUE, NA, FALSE, FALSE), 2, 2)) # logical dense (ltr)
str(M2)
# can
(sM &lt;- M2 | t(M2)) # "lge"
as(sM, "symmetricMatrix")
str(sM &lt;- as(sM, "packedMatrix")) # packed symmetric
</code></pre>

<hr>
<h2 id='ltrMatrix-class'>Triangular Dense Logical Matrices</h2><span id='topic+ltrMatrix-class'></span><span id='topic+ltpMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"ltrMatrix"</code> class is the class of triangular, dense,
logical matrices in nonpacked storage.  The <code>"ltpMatrix"</code> class
is the same except in packed storage.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Both extend classes <code>"<a href="#topic+ldenseMatrix-class">ldenseMatrix</a>"</code> and
<code>"<a href="#topic+triangularMatrix-class">triangularMatrix</a>"</code>, directly; further, class
<code>"Matrix"</code>, <code>"<a href="#topic+lMatrix-class">lMatrix</a>"</code> and others,
<em>in</em>directly.  Use <code><a href="methods.html#topic+showClass">showClass</a>("ltrMatrix")</code>, e.g.,
for details.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>; use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="ltrMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+lgeMatrix-class">lgeMatrix</a></code>, <code><a href="#topic+Matrix-class">Matrix</a></code>;
function <code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("ltrMatrix")

str(new("ltpMatrix"))
(lutr &lt;- as(upper.tri(matrix(, 4, 4)), "ldenseMatrix"))
str(lutp &lt;- pack(lutr)) # packed matrix: only 10 = 4*(4+1)/2 entries
!lutp # the logical negation (is *not* logical triangular !)
## but this one is:
stopifnot(all.equal(lutp, pack(!!lutp)))
</code></pre>

<hr>
<h2 id='lu-methods'>Methods for LU Factorization</h2><span id='topic+lu'></span><span id='topic+lu-methods'></span><span id='topic+lu+2CdenseMatrix-method'></span><span id='topic+lu+2CdiagonalMatrix-method'></span><span id='topic+lu+2CdgCMatrix-method'></span><span id='topic+lu+2CdgRMatrix-method'></span><span id='topic+lu+2CdgTMatrix-method'></span><span id='topic+lu+2CdgeMatrix-method'></span><span id='topic+lu+2CdsCMatrix-method'></span><span id='topic+lu+2CdsRMatrix-method'></span><span id='topic+lu+2CdsTMatrix-method'></span><span id='topic+lu+2CdspMatrix-method'></span><span id='topic+lu+2CdsyMatrix-method'></span><span id='topic+lu+2CdtCMatrix-method'></span><span id='topic+lu+2CdtRMatrix-method'></span><span id='topic+lu+2CdtTMatrix-method'></span><span id='topic+lu+2CdtpMatrix-method'></span><span id='topic+lu+2CdtrMatrix-method'></span><span id='topic+lu+2Cmatrix-method'></span><span id='topic+lu+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Computes the pivoted LU factorization of an <code class="reqn">m \times n</code>
real matrix <code class="reqn">A</code>, which has the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{2} = L U</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' L U P_{2}'</code>
</p>

<p>where
<code class="reqn">P_{1}</code> is an <code class="reqn">m \times m</code> permutation matrix, 
<code class="reqn">P_{2}</code> is an <code class="reqn">n \times n</code> permutation matrix, 
<code class="reqn">L</code> is an <code class="reqn">m \times \min(m,n)</code>
unit lower trapezoidal matrix, and
<code class="reqn">U</code> is a  <code class="reqn">\min(m,n) \times n</code>
upper trapezoidal matrix.
</p>
<p>Methods for <code><a href="#topic+denseMatrix-class">denseMatrix</a></code> are built on
LAPACK routine <code>dgetrf</code>, which does not permute columns,
so that <code class="reqn">P_{2}</code> is an identity matrix.
</p>
<p>Methods for <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> are built on
CXSparse routine <code>cs_lu</code>, which requires <code class="reqn">m = n</code>,
so that <code class="reqn">L</code> and <code class="reqn">U</code> are triangular matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lu(x, ...)
## S4 method for signature 'dgeMatrix'
lu(x, warnSing = TRUE, ...)
## S4 method for signature 'dgCMatrix'
lu(x, errSing = TRUE, order = NA_integer_,
  tol = 1, ...)
## S4 method for signature 'dsyMatrix'
lu(x, cache = TRUE, ...)
## S4 method for signature 'dsCMatrix'
lu(x, cache = TRUE, ...)
## S4 method for signature 'matrix'
lu(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> to be factorized,
which must be square if sparse.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_warnsing">warnSing</code></td>
<td>
<p>a logical indicating if a <a href="base.html#topic+warning">warning</a> should
be signaled for singular <code>x</code>.  Used only by methods for
dense matrices.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_errsing">errSing</code></td>
<td>
<p>a logical indicating if an <a href="base.html#topic+stop">error</a> should
be signaled for singular <code>x</code>.  Used only by methods for
sparse matrices.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_order">order</code></td>
<td>
<p>an integer in <code>0:3</code> passed to CXSparse routine
<code>cs_sqr</code>, indicating a strategy for choosing the column
permutation <code class="reqn">P_{2}</code>.  0 means no column permutation.
1, 2, and 3 indicate a fill-reducing ordering of <code class="reqn">A + A'</code>,
<code class="reqn">\tilde{A}' \tilde{A}</code>, and <code class="reqn">A' A</code>,
where <code class="reqn">\tilde{A}</code> is <code class="reqn">A</code> with &ldquo;dense&rdquo; rows
removed.
<code>NA</code> (the default) is equivalent to 2 if <code>tol == 1</code>
and 1 otherwise.
Do not set to 0 unless you know that the column order of <code class="reqn">A</code>
is already sensible.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_tol">tol</code></td>
<td>
<p>a number.  The original pivot element is used
if its absolute value exceeds <code>tol * a</code>,
where <code>a</code> is the maximum in absolute value of the
other possible pivot elements.
Set <code>tol &lt; 1</code> only if you know what you are doing.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_cache">cache</code></td>
<td>
<p>a logical indicating if the result should be
cached in <code>x@factors[["LU"]]</code>.  Note that
caching is experimental and that only methods for classes
extending <code><a href="#topic+generalMatrix-class">generalMatrix</a></code> or
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code> will have this argument.</p>
</td></tr>
<tr><td><code id="lu-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What happens when <code>x</code> is determined to be near-singular
differs by method.  The method for class <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>
completes the factorization, warning if <code>warnSing = TRUE</code>
and in any case returning a valid <code><a href="#topic+denseLU-class">denseLU</a></code>
object.  Users of this method can detect singular <code>x</code> with
a suitable warning handler; see <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.
In contrast, the method for class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>
abandons further computation, throwing an error if <code>errSing = TRUE</code>
and otherwise returning <code>NA</code>.  Users of this method can
detect singular <code>x</code> with an error handler or by setting
<code>errSing = FALSE</code> and testing for a formal result with
<code>is(., "sparseLU")</code>.
</p>


<h3>Value</h3>

<p>An object representing the factorization, inheriting from
virtual class <code><a href="#topic+LU-class">LU</a></code>.  The specific class
is <code><a href="#topic+denseLU-class">denseLU</a></code> unless <code>x</code> inherits
from virtual class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>,
in which case it is <code><a href="#topic+sparseLU-class">sparseLU</a></code>.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dgetrf.f">https://netlib.org/lapack/double/dgetrf.f</a>.
</p>
<p>Davis, T. A. (2006).
<em>Direct methods for sparse linear systems</em>.
Society for Industrial and Applied Mathematics.
<a href="https://doi.org/10.1137/1.9780898718881">doi:10.1137/1.9780898718881</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+denseLU-class">denseLU</a></code> and
<code><a href="#topic+sparseLU-class">sparseLU</a></code> and their methods.
</p>
<p>Classes <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> and
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>,
for constructing matrix factors from the result.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+Schur">Schur</a></code>, and <code><a href="#topic+qr">qr</a></code>,
for computing other factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("lu", inherited = FALSE)
set.seed(0)

## ---- Dense ----------------------------------------------------------

(A1 &lt;- Matrix(rnorm(9L), 3L, 3L))
(lu.A1 &lt;- lu(A1))

(A2 &lt;- round(10 * A1[, -3L]))
(lu.A2 &lt;- lu(A2))

## A ~ P1' L U in floating point
str(e.lu.A2 &lt;- expand2(lu.A2), max.level = 2L)
stopifnot(all.equal(A2, Reduce(`%*%`, e.lu.A2)))

## ---- Sparse ---------------------------------------------------------

A3 &lt;- as(readMM(system.file("external/pores_1.mtx", package = "Matrix")),
         "CsparseMatrix")
(lu.A3 &lt;- lu(A3))

## A ~ P1' L U P2' in floating point
str(e.lu.A3 &lt;- expand2(lu.A3), max.level = 2L)
stopifnot(all.equal(A3, Reduce(`%*%`, e.lu.A3)))
</code></pre>

<hr>
<h2 id='mat2triplet'>Map Matrix to its Triplet Representation</h2><span id='topic+mat2triplet'></span>

<h3>Description</h3>

<p>From an <span class="rlang"><b>R</b></span> object coercible to <code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code>,
typically a (sparse) matrix, produce its triplet representation which may
collapse to a &ldquo;Duplet&rdquo; in the case of binary aka pattern, such as
<code>"<a href="#topic+nMatrix-class">nMatrix</a>"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2triplet(x, uniqT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2triplet_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object for which <code>as(x, "<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>")</code>
works; typically a <code><a href="base.html#topic+matrix">matrix</a></code> of one of the <span class="pkg">Matrix</span>
package matrices.</p>
</td></tr>
<tr><td><code id="mat2triplet_+3A_uniqt">uniqT</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the triplet
representation should be &lsquo;unique&rsquo; in the sense of
<code><a href="#topic+asUniqueT">asUniqueT</a>(byrow=FALSE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code>, typically with three components,
</p>
<table>
<tr><td><code>i</code></td>
<td>
<p>vector of   row   indices for all non-zero entries of <code>x</code></p>
</td></tr>
<tr><td><code>i</code></td>
<td>
<p>vector of columns indices for all non-zero entries of <code>x</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>vector of all non-zero entries of <code>x</code>; exists <b>only</b>
when <code>as(x, "TsparseMatrix")</code> is <b>not</b> a
<code>"<a href="#topic+nsparseMatrix-class">nsparseMatrix</a>"</code>.</p>
</td></tr>
</table>
<p>Note that the <code><a href="base.html#topic+order">order</a></code> of the entries is determined by the
coercion to <code>"<a href="#topic+TsparseMatrix-class">TsparseMatrix</a>"</code> and hence typically
with increasing <code>j</code> (and increasing <code>i</code> within ties of <code>j</code>).
</p>


<h3>Note</h3>

<p>The <code>mat2triplet()</code> utility was created to be a more efficient and
more predictable substitute for <code><a href="base.html#topic+summary">summary</a>(&lt;sparseMatrix&gt;)</code>.
UseRs have wrongly expected the latter to return a data frame with
columns <code>i</code> and <code>j</code> which however is wrong for a
<code>"<a href="#topic+diagonalMatrix-class">diagonalMatrix</a>"</code>.
</p>


<h3>See Also</h3>

<p>The <code>summary()</code> method for <code>"sparseMatrix"</code>,
<code><a href="#topic+summary+2CsparseMatrix-method">summary,sparseMatrix-method</a></code>.
</p>
<p><code>mat2triplet()</code> is conceptually the <em>inverse</em> function of
<code><a href="#topic+spMatrix">spMatrix</a></code> and (one case of) <code><a href="#topic+sparseMatrix">sparseMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mat2triplet # simple definition

i &lt;- c(1,3:8); j &lt;- c(2,9,6:10); x &lt;- 7 * (1:7)
(Ax &lt;- sparseMatrix(i, j, x = x)) ##  8 x 10 "dgCMatrix"
str(trA &lt;- mat2triplet(Ax))
stopifnot(i == sort(trA$i),  sort(j) == trA$j,  x == sort(trA$x))

D &lt;- Diagonal(x=4:2)
summary(D)
str(mat2triplet(D))
</code></pre>

<hr>
<h2 id='matmult-methods'>Matrix (Cross) Products (of Transpose)</h2><span id='topic++25+2A+25'></span><span id='topic++25+2A+25-methods'></span><span id='topic+crossprod'></span><span id='topic+crossprod-methods'></span><span id='topic+tcrossprod'></span><span id='topic+tcrossprod-methods'></span><span id='topic+matmult-methods'></span><span id='topic++25+2A+25+2CANY+2CMatrix-method'></span><span id='topic++25+2A+25+2CANY+2CsparseVector-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CMatrix+2CANY-method'></span><span id='topic++25+2A+25+2CMatrix+2CindMatrix-method'></span><span id='topic++25+2A+25+2CMatrix+2CpMatrix-method'></span><span id='topic++25+2A+25+2CMatrix+2CsparseVector-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CTsparseMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CdenseMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CdiagonalMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CindMatrix+2CMatrix-method'></span><span id='topic++25+2A+25+2CindMatrix+2CindMatrix-method'></span><span id='topic++25+2A+25+2CindMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CindMatrix+2CpMatrix-method'></span><span id='topic++25+2A+25+2CindMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CindMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CpMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CsparseVector-method'></span><span id='topic++25+2A+25+2CpMatrix+2CMatrix-method'></span><span id='topic++25+2A+25+2CpMatrix+2CindMatrix-method'></span><span id='topic++25+2A+25+2CpMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CpMatrix+2CpMatrix-method'></span><span id='topic++25+2A+25+2CpMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CsparseVector+2CANY-method'></span><span id='topic++25+2A+25+2CsparseVector+2CMatrix-method'></span><span id='topic++25+2A+25+2CsparseVector+2Cmatrix-method'></span><span id='topic++25+2A+25+2CsparseVector+2CsparseVector-method'></span><span id='topic++25+2A+25+2CsparseVector+2Cvector-method'></span><span id='topic++25+2A+25+2Cvector+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CRsparseMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CTsparseMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CdenseMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CdiagonalMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CindMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CpMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CsparseVector-method'></span><span id='topic+crossprod+2CANY+2CMatrix-method'></span><span id='topic+crossprod+2CANY+2CsparseVector-method'></span><span id='topic+crossprod+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CCsparseMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CCsparseMatrix+2Cvector-method'></span><span id='topic+crossprod+2CMatrix+2CANY-method'></span><span id='topic+crossprod+2CMatrix+2CindMatrix-method'></span><span id='topic+crossprod+2CMatrix+2CpMatrix-method'></span><span id='topic+crossprod+2CMatrix+2CsparseVector-method'></span><span id='topic+crossprod+2CRsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CRsparseMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CRsparseMatrix+2Cvector-method'></span><span id='topic+crossprod+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CTsparseMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CTsparseMatrix+2Cvector-method'></span><span id='topic+crossprod+2CdenseMatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CdenseMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CdenseMatrix+2Cvector-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CdiagonalMatrix+2Cvector-method'></span><span id='topic+crossprod+2CindMatrix+2CMatrix-method'></span><span id='topic+crossprod+2CindMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CindMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CindMatrix+2Cvector-method'></span><span id='topic+crossprod+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CdenseMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CindMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CpMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CsparseVector-method'></span><span id='topic+crossprod+2CpMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CpMatrix+2CpMatrix-method'></span><span id='topic+crossprod+2CsparseVector+2CANY-method'></span><span id='topic+crossprod+2CsparseVector+2CMatrix-method'></span><span id='topic+crossprod+2CsparseVector+2Cmatrix-method'></span><span id='topic+crossprod+2CsparseVector+2Cmissing-method'></span><span id='topic+crossprod+2CsparseVector+2CsparseVector-method'></span><span id='topic+crossprod+2CsparseVector+2Cvector-method'></span><span id='topic+crossprod+2Cvector+2CCsparseMatrix-method'></span><span id='topic+crossprod+2Cvector+2CRsparseMatrix-method'></span><span id='topic+crossprod+2Cvector+2CTsparseMatrix-method'></span><span id='topic+crossprod+2Cvector+2CdenseMatrix-method'></span><span id='topic+crossprod+2Cvector+2CdiagonalMatrix-method'></span><span id='topic+crossprod+2Cvector+2CindMatrix-method'></span><span id='topic+crossprod+2Cvector+2CpMatrix-method'></span><span id='topic+crossprod+2Cvector+2CsparseVector-method'></span><span id='topic+tcrossprod+2CANY+2CMatrix-method'></span><span id='topic+tcrossprod+2CANY+2CsparseVector-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CCsparseMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CMatrix+2CANY-method'></span><span id='topic+tcrossprod+2CMatrix+2CindMatrix-method'></span><span id='topic+tcrossprod+2CMatrix+2CsparseVector-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CTsparseMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CdenseMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CdiagonalMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CindMatrix+2CMatrix-method'></span><span id='topic+tcrossprod+2CindMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CindMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CindMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CindMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CsparseVector-method'></span><span id='topic+tcrossprod+2CpMatrix+2CMatrix-method'></span><span id='topic+tcrossprod+2CpMatrix+2Cmatrix-method'></span><span id='topic+tcrossprod+2CpMatrix+2Cmissing-method'></span><span id='topic+tcrossprod+2CpMatrix+2CpMatrix-method'></span><span id='topic+tcrossprod+2CpMatrix+2Cvector-method'></span><span id='topic+tcrossprod+2CsparseVector+2CANY-method'></span><span id='topic+tcrossprod+2CsparseVector+2CMatrix-method'></span><span id='topic+tcrossprod+2CsparseVector+2Cmatrix-method'></span><span id='topic+tcrossprod+2CsparseVector+2Cmissing-method'></span><span id='topic+tcrossprod+2CsparseVector+2CsparseVector-method'></span><span id='topic+tcrossprod+2CsparseVector+2Cvector-method'></span><span id='topic+tcrossprod+2Cvector+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CTsparseMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CdenseMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CdiagonalMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CindMatrix-method'></span><span id='topic+tcrossprod+2Cvector+2CsparseVector-method'></span>

<h3>Description</h3>

<p>The basic matrix product, <code>%*%</code> is implemented for all our
<code><a href="#topic+Matrix-class">Matrix</a></code> and also for
<code><a href="#topic+sparseVector-class">sparseVector</a></code> classes, fully analogously to <span class="rlang"><b>R</b></span>'s
base <code>matrix</code> and vector objects.
</p>
<p>The functions <code><a href="#topic+crossprod">crossprod</a></code> and <code><a href="#topic+tcrossprod">tcrossprod</a></code> are
matrix products or &ldquo;cross products&rdquo;, ideally implemented
efficiently without computing <code><a href="base.html#topic+t">t</a>(.)</code>'s unnecessarily.
They also return <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code> classed
matrices when easily detectable, e.g., in <code>crossprod(m)</code>, the one
argument case.
</p>
<p><code>tcrossprod()</code> takes the cross-product of the transpose of a matrix.
<code>tcrossprod(x)</code> is formally equivalent to, but faster than, the
call <code>x %*% t(x)</code>, and so is <code>tcrossprod(x, y)</code> instead of
<code>x %*% t(y)</code>.
</p>
<p><em>Boolean</em> matrix products are computed via either
<code><a href="#topic++25+26+25">%&amp;%</a></code> or <code>boolArith = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CsparseMatrix,diagonalMatrix'
x %*% y

## S4 method for signature 'CsparseMatrix,diagonalMatrix'
crossprod(x, y = NULL, boolArith = NA, ...)
       ## .... and for many more signatures

## S4 method for signature 'TsparseMatrix,missing'
tcrossprod(x, y = NULL, boolArith = NA, ...)
       ## .... and for many more signatures
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult-methods_+3A_x">x</code></td>
<td>
<p>a matrix-like object</p>
</td></tr>
<tr><td><code id="matmult-methods_+3A_y">y</code></td>
<td>
<p>a matrix-like object, or for <code>[t]crossprod()</code>
<code>NULL</code> (by default); the latter case is formally equivalent to
<code>y = x</code>.</p>
</td></tr>
<tr><td><code id="matmult-methods_+3A_boolarith">boolArith</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, i.e., <code>NA</code>, <code>TRUE</code>,
or <code>FALSE</code>.  If true the result is (coerced to) a pattern
matrix, i.e., <code>"<a href="#topic+nMatrix-class">nMatrix</a>"</code>, unless there are
<code>NA</code> entries and the result will be a
<code>"<a href="#topic+lMatrix-class">lMatrix</a>"</code>.  If false the result is (coerced to)
numeric.  When <code>NA</code>, currently the default, the
result is a pattern matrix when <code>x</code> and <code>y</code> are
<code>"<a href="#topic+nsparseMatrix-class">nsparseMatrix</a>"</code> and numeric otherwise.</p>
</td></tr>
<tr><td><code id="matmult-methods_+3A_...">...</code></td>
<td>
<p>potentially more arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For some classes in the <code>Matrix</code> package, such as
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, it is much faster to calculate the
cross-product of the transpose directly instead of calculating the
transpose first and then its cross-product.
</p>
<p><code>boolArith = TRUE</code> for regular (&ldquo;non cross&rdquo;) matrix
products, <code>%*%</code> cannot be specified.  Instead, we provide the
<code><a href="#topic++25+26+25">%&amp;%</a></code> operator for <em>boolean</em> matrix products.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Matrix-class">Matrix</a></code> object, in the one argument case
of an appropriate <em>symmetric</em> matrix class, i.e., inheriting from
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "dgeMatrix", y = "dgeMatrix")</code>:
Matrix multiplication; ditto for several other signature
combinations, see <code>showMethods("%*%", class = "dgeMatrix")</code>.</p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "dtrMatrix", y = "matrix")</code> and other
signatures (use <code>showMethods("%*%", class="dtrMatrix")</code>):
matrix multiplication.  Multiplication of (matching) triangular
matrices now should remain triangular (in the sense of class
<a href="#topic+triangularMatrix-class">triangularMatrix</a>).</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "dgeMatrix", y = "dgeMatrix")</code>:
ditto for several other signatures, use
<code>showMethods("crossprod", class = "dgeMatrix")</code>, matrix
crossproduct, an efficient version of <code>t(x) %*% y</code>.</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "CsparseMatrix", y = "missing")</code>
returns <code>t(x) %*% x</code> as an <code>dsCMatrix</code> object.</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "TsparseMatrix", y = "missing")</code>
returns <code>t(x) %*% x</code> as an <code>dsCMatrix</code> object.</p>
</dd>
<dt>crossprod,tcrossprod</dt><dd><p><code>signature(x = "dtrMatrix", y =
      "matrix")</code> and other signatures, see <code>"%*%"</code> above.</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>boolArith = TRUE</code>, <code>FALSE</code> or <code>NA</code> has been newly
introduced for <span class="pkg">Matrix</span> 1.2.0 (March 2015).  Its implementation
has still not been tested extensively.  Notably the behaviour for
sparse matrices with <code>x</code> slots containing extra zeros had not been
documented previously, see the <code><a href="#topic++25+26+25">%&amp;%</a></code> help page.
</p>
<p>Currently, <code>boolArith = TRUE</code> is implemented via
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> coercions which may be quite
inefficient for dense matrices.  Contributions for efficiency
improvements are welcome.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tcrossprod">tcrossprod</a></code> in <span class="rlang"><b>R</b></span>'s base, and
<code><a href="#topic+crossprod">crossprod</a></code> and <code><a href="#topic++25+2A+25">%*%</a></code>.
<span class="pkg">Matrix</span> package <code><a href="#topic++25+26+25">%&amp;%</a></code> for boolean matrix product
methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## A random sparse "incidence" matrix :
 m &lt;- matrix(0, 400, 500)
 set.seed(12)
 m[runif(314, 0, length(m))] &lt;- 1
 mm &lt;- as(m, "CsparseMatrix")
 object.size(m) / object.size(mm) # smaller by a factor of &gt; 200

 ## tcrossprod() is very fast:
 system.time(tCmm &lt;- tcrossprod(mm))# 0   (PIII, 933 MHz)
 system.time(cm &lt;- crossprod(t(m))) # 0.16
 system.time(cm. &lt;- tcrossprod(m))  # 0.02

 stopifnot(cm == as(tCmm, "matrix"))

 ## show sparse sub matrix
 tCmm[1:16, 1:30]
</code></pre>

<hr>
<h2 id='Matrix'>Construct a Classed Matrix</h2><span id='topic+Matrix'></span>

<h3>Description</h3>

<p>Construct a Matrix of a class that inherits from <code>Matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix(data=NA, nrow=1, ncol=1, byrow=FALSE, dimnames=NULL,
       sparse = NULL, doDiag = TRUE, forceCheck = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix_+3A_data">data</code></td>
<td>
<p>an optional numeric data vector or matrix.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_nrow">nrow</code></td>
<td>
<p>when <code>data</code> is not a matrix, the desired number of rows</p>
</td></tr>
<tr><td><code id="Matrix_+3A_ncol">ncol</code></td>
<td>
<p>when <code>data</code> is not a matrix, the desired number of columns</p>
</td></tr>
<tr><td><code id="Matrix_+3A_byrow">byrow</code></td>
<td>
<p>logical.  If <code>FALSE</code> (the default) the matrix is
filled by columns, otherwise the matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>a <code><a href="base.html#topic+dimnames">dimnames</a></code> attribute for the matrix: a
<code>list</code> of two character components.  They are set if not
<code><a href="base.html#topic+NULL">NULL</a></code> (as per default).</p>
</td></tr>
<tr><td><code id="Matrix_+3A_sparse">sparse</code></td>
<td>
<p>logical or <code>NULL</code>, specifying if the result should
be sparse or not.  By default, it is made sparse when more than half
of the entries are 0.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_dodiag">doDiag</code></td>
<td>
<p>logical indicating if a <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>
object should be returned when the resulting matrix is diagonal
(<em>mathematically</em>).  As class <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>
<code><a href="methods.html#topic+extends">extends</a></code> <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, this is a
natural default for all values of <code>sparse</code>.
</p>
<p>Otherwise, if <code>doDiag</code> is false, a dense or sparse (depending on
<code>sparse</code>) <em>symmetric</em> matrix will be returned.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_forcecheck">forceCheck</code></td>
<td>
<p>logical indicating if the checks for structure
should even happen when <code>data</code> is already a <code>"Matrix"</code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either of <code>nrow</code> or <code>ncol</code> is not given, an attempt is
made to infer it from the length of <code>data</code> and the other
parameter.
Further, <code>Matrix()</code> makes efforts to keep <code><a href="base.html#topic+logical">logical</a></code>
matrices logical, i.e., inheriting from class <code><a href="#topic+lMatrix-class">lMatrix</a></code>,
and to determine specially structured matrices such as symmetric,
triangular or diagonal ones.  Note that a <em>symmetric</em> matrix also
needs symmetric <code><a href="base.html#topic+dimnames">dimnames</a></code>, e.g., by specifying
<code>dimnames = list(NULL,NULL)</code>, see the examples.
</p>
<p>Most of the time, the function works via a traditional (<em>full</em>)
<code><a href="base.html#topic+matrix">matrix</a></code>.  However, <code>Matrix(0, nrow,ncol)</code> directly
constructs an &ldquo;empty&rdquo; <a href="#topic+sparseMatrix-class">sparseMatrix</a>, as does
<code>Matrix(FALSE, *)</code>.
</p>
<p>Although it is sometime possible to mix unclassed matrices (created
with <code>matrix</code>) with ones of class <code>"Matrix"</code>, it is much
safer to always use carefully constructed ones of class
<code>"Matrix"</code>.
</p>


<h3>Value</h3>

<p>Returns matrix of a class that inherits from <code>"Matrix"</code>.
Only if <code>data</code> is not a <code><a href="base.html#topic+matrix">matrix</a></code> and does not already inherit
from class <code><a href="#topic+Matrix-class">Matrix</a></code> are the arguments
<code>nrow</code>, <code>ncol</code> and <code>byrow</code> made use of.
</p>


<h3>See Also</h3>

<p>The classes <code><a href="#topic+Matrix-class">Matrix</a></code>,
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>,
<code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>, and
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code>; further,
<code><a href="base.html#topic+matrix">matrix</a></code>.
</p>
<p>Special matrices can be constructed, e.g., via
<code><a href="#topic+sparseMatrix">sparseMatrix</a></code> (sparse), <code><a href="#topic+bdiag">bdiag</a></code>
(block-diagonal), <code><a href="#topic+bandSparse">bandSparse</a></code> (banded sparse), or
<code><a href="#topic+Diagonal">Diagonal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Matrix(0, 3, 2)             # 3 by 2 matrix of zeros -&gt; sparse
Matrix(0, 3, 2, sparse=FALSE)# -&gt; 'dense'

## 4 cases - 3 different results :
Matrix(0, 2, 2)              # diagonal !
Matrix(0, 2, 2, sparse=FALSE)# (ditto)
Matrix(0, 2, 2,               doDiag=FALSE)# -&gt; sparse symm. "dsCMatrix"
Matrix(0, 2, 2, sparse=FALSE, doDiag=FALSE)# -&gt; dense  symm. "dsyMatrix"

Matrix(1:6, 3, 2)           # a 3 by 2 matrix (+ integer warning)
Matrix(1:6 + 1, nrow=3)

## logical ones:
Matrix(diag(4) &gt;  0) # -&gt; "ldiMatrix" with diag = "U"
Matrix(diag(4) &gt;  0, sparse=TRUE) #  (ditto)
Matrix(diag(4) &gt;= 0) # -&gt; "lsyMatrix" (of all 'TRUE')
## triangular
l3 &lt;- upper.tri(matrix(,3,3))
(M &lt;- Matrix(l3))   # -&gt; "ltCMatrix"
Matrix(! l3)        # -&gt; "ltrMatrix"
as(l3, "CsparseMatrix")# "lgCMatrix"

Matrix(1:9, nrow=3,
       dimnames = list(c("a", "b", "c"), c("A", "B", "C")))
(I3 &lt;- Matrix(diag(3)))# identity, i.e., unit "diagonalMatrix"
str(I3) # note  'diag = "U"' and the empty 'x' slot

(A &lt;- cbind(a=c(2,1), b=1:2))# symmetric *apart* from dimnames
Matrix(A)                    # hence 'dgeMatrix'
(As &lt;- Matrix(A, dimnames = list(NULL,NULL)))# -&gt; symmetric
forceSymmetric(A) # also symmetric, w/ symm. dimnames
stopifnot(is(As, "symmetricMatrix"),
          is(Matrix(0, 3,3), "sparseMatrix"),
          is(Matrix(FALSE, 1,1), "sparseMatrix"))
</code></pre>

<hr>
<h2 id='Matrix-class'>Virtual Class &quot;Matrix&quot; of Matrices</h2><span id='topic+Matrix-class'></span><span id='topic++21+2CMatrix-method'></span><span id='topic++26+2CMatrix+2CddiMatrix-method'></span><span id='topic++26+2CMatrix+2CldiMatrix-method'></span><span id='topic++26+2CMatrix+2CndiMatrix-method'></span><span id='topic++2A+2CMatrix+2CddiMatrix-method'></span><span id='topic++2A+2CMatrix+2CldiMatrix-method'></span><span id='topic++2A+2CMatrix+2CndiMatrix-method'></span><span id='topic++2B+2CMatrix+2Cmissing-method'></span><span id='topic+-+2CMatrix+2Cmissing-method'></span><span id='topic+Arith+2CMatrix+2CMatrix-method'></span><span id='topic+Arith+2CMatrix+2ClsparseMatrix-method'></span><span id='topic+Arith+2CMatrix+2CnsparseMatrix-method'></span><span id='topic+Logic+2CANY+2CMatrix-method'></span><span id='topic+Logic+2CMatrix+2CANY-method'></span><span id='topic+Logic+2CMatrix+2CnMatrix-method'></span><span id='topic+Math2+2CMatrix-method'></span><span id='topic+Ops+2CANY+2CMatrix-method'></span><span id='topic+Ops+2CMatrix+2CANY-method'></span><span id='topic+Ops+2CMatrix+2CNULL-method'></span><span id='topic+Ops+2CMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CMatrix+2Cmatrix-method'></span><span id='topic+Ops+2CMatrix+2CsparseVector-method'></span><span id='topic+Ops+2CNULL+2CMatrix-method'></span><span id='topic+Ops+2Cmatrix+2CMatrix-method'></span><span id='topic++5E+2CMatrix+2CddiMatrix-method'></span><span id='topic++5E+2CMatrix+2CldiMatrix-method'></span><span id='topic++5E+2CMatrix+2CndiMatrix-method'></span><span id='topic+as.array+2CMatrix-method'></span><span id='topic+as.complex+2CMatrix-method'></span><span id='topic+as.integer+2CMatrix-method'></span><span id='topic+as.logical+2CMatrix-method'></span><span id='topic+as.matrix+2CMatrix-method'></span><span id='topic+as.numeric+2CMatrix-method'></span><span id='topic+as.vector+2CMatrix-method'></span><span id='topic+coerce+2CANY+2CMatrix-method'></span><span id='topic+coerce+2CMatrix+2CCsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CRsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CTsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CcopMatrix-method'></span><span id='topic+coerce+2CMatrix+2CcorMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdMatrix-method'></span><span id='topic+coerce+2CMatrix+2CddenseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdenseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdiagonalMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdpoMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdppMatrix-method'></span><span id='topic+coerce+2CMatrix+2CdsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CgeneralMatrix-method'></span><span id='topic+coerce+2CMatrix+2CindMatrix-method'></span><span id='topic+coerce+2CMatrix+2ClMatrix-method'></span><span id='topic+coerce+2CMatrix+2CldenseMatrix-method'></span><span id='topic+coerce+2CMatrix+2ClsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2Cmatrix-method'></span><span id='topic+coerce+2CMatrix+2CnMatrix-method'></span><span id='topic+coerce+2CMatrix+2CndenseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CnsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CpMatrix-method'></span><span id='topic+coerce+2CMatrix+2CpackedMatrix-method'></span><span id='topic+coerce+2CMatrix+2CsparseMatrix-method'></span><span id='topic+coerce+2CMatrix+2CsparseVector-method'></span><span id='topic+coerce+2CMatrix+2CsymmetricMatrix-method'></span><span id='topic+coerce+2CMatrix+2CtriangularMatrix-method'></span><span id='topic+coerce+2CMatrix+2CunpackedMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CMatrix-method'></span><span id='topic+coerce+2Cvector+2CMatrix-method'></span><span id='topic+determinant+2CMatrix+2Cmissing-method'></span><span id='topic+determinant+2CMatrix+2Clogical-method'></span><span id='topic+dim+2CMatrix-method'></span><span id='topic+dimnames+2CMatrix-method'></span><span id='topic+dimnames+3C-+2CMatrix+2CNULL-method'></span><span id='topic+dimnames+3C-+2CMatrix+2Clist-method'></span><span id='topic+drop+2CMatrix-method'></span><span id='topic+head+2CMatrix-method'></span><span id='topic+initialize+2CMatrix-method'></span><span id='topic+length+2CMatrix-method'></span><span id='topic+tail+2CMatrix-method'></span><span id='topic+unname+2CMatrix-method'></span><span id='topic+zapsmall+2CMatrix-method'></span><span id='topic+c.Matrix'></span><span id='topic+Matrix.Version'></span><span id='topic+det'></span>

<h3>Description</h3>

<p>The <code>Matrix</code> class is a class contained by all actual
classes in the <span class="pkg">Matrix</span> package.  It is a &ldquo;virtual&rdquo; class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code></dt><dd><p>an integer vector of length 2 giving the
dimensions of the matrix.</p>
</dd>
<dt><code>Dimnames</code></dt><dd><p>a list of length 2.  Each element must
be <code>NULL</code> or a character vector of length equal to the
corresponding element of <code>Dim</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>determinant</dt><dd><p><code>signature(x = "Matrix", logarithm = "missing")</code>: and</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "Matrix", logarithm = "logical")</code>:
compute the (<code class="reqn">\log</code>) determinant of <code>x</code>.  The method
chosen depends on the actual Matrix class of <code>x</code>.  Note that
<code><a href="base.html#topic+det">det</a></code> also works for all our matrices, calling the
appropriate <code>determinant()</code> method.  The <code>Matrix::det</code>
is an exact copy of <code>base::det</code>, but in the correct
namespace, and hence calling the S4-aware version of
<code>determinant()</code>.).</p>
</dd>
<dt>diff</dt><dd><p><code>signature(x = "Matrix")</code>: As <code><a href="base.html#topic+diff">diff</a>()</code>
for traditional matrices, i.e., applying <code>diff()</code> to each
column.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "Matrix")</code>: extract matrix dimensions
<code><a href="base.html#topic+dim">dim</a></code>.</p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "Matrix", value = "ANY")</code>: where
<code>value</code> is integer of length 2.  Allows to <em>reshape</em>
Matrix objects, but only when <code>prod(value) == prod(dim(x))</code>.</p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "Matrix")</code>: extract
<code><a href="base.html#topic+dimnames">dimnames</a></code>.</p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "Matrix", value = "list")</code>: set
the <code>dimnames</code> to a <code><a href="base.html#topic+list">list</a></code> of length 2, see
<code><a href="base.html#topic+dimnames+3C-">dimnames&lt;-</a></code>.</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "Matrix")</code>: simply defined as
<code>prod(dim(x))</code> (and hence of mode <code>"double"</code>).</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Matrix")</code>: <code><a href="methods.html#topic+show">show</a></code>
method for <code><a href="base.html#topic+print">print</a></code>ing.  For printing <em>sparse</em>
matrices, see <code><a href="#topic+printSpMatrix">printSpMatrix</a></code>.</p>
</dd>
<dt>zapsmall</dt><dd><p><code>signature(x = "Matrix")</code>: typically used for
<code>"<a href="#topic+dMatrix-class">dMatrix</a>"</code>: <code><a href="base.html#topic+round">round</a>()</code> matrix entries
such that (relatively) very small entries become zero exactly.</p>
</dd>
<dt>image</dt><dd><p><code>signature(object = "Matrix")</code>: draws an
<code><a href="#topic+image">image</a></code> of the matrix entries, using
<code><a href="lattice.html#topic+levelplot">levelplot</a>()</code> from package <span class="pkg">lattice</span>.</p>
</dd>
<dt>head</dt><dd><p><code>signature(object = "Matrix")</code>: return only the
<em>&ldquo;head&rdquo;</em>, i.e., the first few rows.</p>
</dd>
<dt>tail</dt><dd><p><code>signature(object = "Matrix")</code>: return only the
<em>&ldquo;tail&rdquo;</em>, i.e., the last few rows of the respective matrix.</p>
</dd>
</dl>
<p><br /> 
</p>
<dl>
<dt>as.matrix, as.array</dt><dd><p><code>signature(x = "Matrix")</code>: the same as
<code>as(x, "matrix")</code>; see also the note below.</p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "Matrix", mode = "missing")</code>:
<code>as.vector(m)</code> should be identical to <code>as.vector(as(m,
	"matrix"))</code>, implemented more efficiently for some subclasses.</p>
</dd>
<dt>as(x, &quot;vector&quot;), as(x, &quot;numeric&quot;)</dt><dd><p>etc, similarly.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ANY", to = "Matrix")</code>: This
relies on a correct <code><a href="base.html#topic+as.matrix">as.matrix</a>()</code> method for <code>from</code>.</p>
</dd>
</dl>

<p>There are many more methods that (conceptually should) work for all
<code>"Matrix"</code> objects, e.g., <code><a href="#topic+colSums">colSums</a></code>,
<code><a href="#topic+rowMeans">rowMeans</a></code>.  Even <span class="pkg">base</span> functions may work
automagically (if they first call <code><a href="base.html#topic+as.matrix">as.matrix</a>()</code> on their
principal argument), e.g., <code><a href="base.html#topic+apply">apply</a></code>, <code><a href="base.html#topic+eigen">eigen</a></code>,
<code><a href="base.html#topic+svd">svd</a></code> or <code><a href="base.html#topic+kappa">kappa</a></code> all do work via coercion to a
&ldquo;traditional&rdquo; (dense) <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>



<h3>Note</h3>

<p>Loading the <code>Matrix</code> namespace &ldquo;overloads&rdquo;
<code><a href="base.html#topic+as.matrix">as.matrix</a></code> and <code><a href="base.html#topic+as.array">as.array</a></code> in the <span class="pkg">base</span>
namespace by the equivalent of <code>function(x) as(x, "matrix")</code>.
Consequently, <code>as.matrix(m)</code> or <code>as.array(m)</code> will properly
work when <code>m</code> inherits from the <code>"Matrix"</code> class &mdash;
<em>also</em> for functions in package <span class="pkg">base</span> and other packages.
E.g., <code><a href="base.html#topic+apply">apply</a></code> or <code><a href="base.html#topic+outer">outer</a></code> can therefore be applied
to <code>"Matrix"</code> matrices.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a> and Martin Maechler</p>


<h3>See Also</h3>

<p>the classes <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>,
<code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>, and function
<code><a href="#topic+Matrix">Matrix</a></code> for construction (and examples).
</p>
<p>Methods, e.g., for <code><a href="#topic+kronecker-methods">kronecker</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>slotNames("Matrix")

cl &lt;- getClass("Matrix")
names(cl@subclasses) # more than 40 ..

showClass("Matrix")#&gt; output with slots and all subclasses

(M &lt;- Matrix(c(0,1,0,0), 6, 4))
dim(M)
diag(M)
cm &lt;- M[1:4,] + 10*Diagonal(4)
diff(M)
## can reshape it even :
dim(M) &lt;- c(2, 12)
M
stopifnot(identical(M, Matrix(c(0,1,0,0), 2,12)),
          all.equal(det(cm),
                    determinant(as(cm,"matrix"), log=FALSE)$modulus,
                    check.attributes=FALSE))
</code></pre>

<hr>
<h2 id='Matrix-defunct'>Defunct Functions in Package <span class="pkg">Matrix</span></h2><span id='topic+Matrix-defunct'></span><span id='topic+cBind'></span><span id='topic+rBind'></span>

<h3>Description</h3>

<p>The functions or variables listed here are no longer part of
<span class="pkg">Matrix</span> as they are no longer needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Defunct in 1.3-3
rBind(..., deparse.level = 1)
cBind(..., deparse.level = 1)
</code></pre>


<h3>Details</h3>

<p>These either are stubs reporting that they are defunct, or
have been removed completely (apart from being documented here).
</p>
<p><code>rBind</code> and <code>cBind</code> were provided for <span class="rlang"><b>R</b></span> versions
older than 3.2.0 as substitutes for the <span class="pkg">base</span> analogues
<code>rbind</code> and <code>cbind</code>, which at that time were not
&ldquo;S4-aware&rdquo; and so could not be used to vertically or
horizontally concatenate <code>"<a href="#topic+Matrix-class">Matrix</a>"</code> objects
together with traditional matrices and vectors.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>,
<code><a href="base.html#topic+base-defunct">base-defunct</a></code>,
<code><a href="#topic+Matrix-deprecated">Matrix-deprecated</a></code>
</p>

<hr>
<h2 id='Matrix-deprecated'>Deprecated Functions in Package <span class="pkg">Matrix</span></h2><span id='topic+Matrix-deprecated'></span><span id='topic+..2dge'></span><span id='topic+.C2nC'></span><span id='topic+.SuiteSparse_version'></span><span id='topic+.T2Cmat'></span><span id='topic+.asmatrix'></span><span id='topic+.dense2sy'></span><span id='topic+.diag2mat'></span><span id='topic+.diag2sT'></span><span id='topic+.diag2tT'></span><span id='topic+.dsy2dsp'></span><span id='topic+.dsy2mat'></span><span id='topic+.dxC2mat'></span><span id='topic+.m2dgC'></span><span id='topic+.m2lgC'></span><span id='topic+.m2ngCn'></span><span id='topic+.m2ngC'></span><span id='topic+.m2ngTn'></span><span id='topic+.n2dgT'></span><span id='topic+.nC2d'></span><span id='topic+.nC2l'></span><span id='topic+atomicVector-class'></span><span id='topic+compMatrix-class'></span><span id='topic+number-class'></span><span id='topic+replValue-class'></span><span id='topic+chol2inv+2CCHMfactor-method'></span><span id='topic+coerce+2CCHMfactor+2CMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CCsparseMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CRsparseMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CTsparseMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CdMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CdsparseMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CpMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CsparseMatrix-method'></span><span id='topic+coerce+2CCHMfactor+2CtriangularMatrix-method'></span><span id='topic+coerce+2CRsparseMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CddenseMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CddiMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CddiMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CddiMatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdspMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CdgeMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdsRMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2ClsCMatrix-method'></span><span id='topic+coerce+2CdsCMatrix+2CnsCMatrix-method'></span><span id='topic+coerce+2CdsTMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdsTMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdsTMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2CdsTMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2CdsTMatrix+2ClsTMatrix-method'></span><span id='topic+coerce+2CdspMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2CdspMatrix+2ClspMatrix-method'></span><span id='topic+coerce+2CdsyMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2CdsyMatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2CdsyMatrix+2CdspMatrix-method'></span><span id='topic+coerce+2CdsyMatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CltCMatrix-method'></span><span id='topic+coerce+2CdtCMatrix+2CntCMatrix-method'></span><span id='topic+coerce+2CdtTMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdtTMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CdtTMatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2CdtTMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CdtpMatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2CdtpMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CdtpMatrix+2CltpMatrix-method'></span><span id='topic+coerce+2CdtrMatrix+2CdtpMatrix-method'></span><span id='topic+coerce+2CdtrMatrix+2CltrMatrix-method'></span><span id='topic+coerce+2CindMatrix+2CngTMatrix-method'></span><span id='topic+coerce+2CindMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2ClMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2ClgCMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2ClgCMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2ClgCMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2ClgCMatrix+2CltCMatrix-method'></span><span id='topic+coerce+2ClgTMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2ClgTMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2ClgTMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2ClgTMatrix+2ClsCMatrix-method'></span><span id='topic+coerce+2ClgTMatrix+2CltTMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2ClspMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2CltpMatrix-method'></span><span id='topic+coerce+2ClgeMatrix+2CltrMatrix-method'></span><span id='topic+coerce+2ClsCMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2ClsCMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2ClsCMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2ClsCMatrix+2ClsTMatrix-method'></span><span id='topic+coerce+2ClsTMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2ClsTMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2ClsTMatrix+2ClsCMatrix-method'></span><span id='topic+coerce+2ClsTMatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2ClspMatrix+2CdspMatrix-method'></span><span id='topic+coerce+2ClspMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2ClspMatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2ClsyMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2ClsyMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2ClsyMatrix+2ClspMatrix-method'></span><span id='topic+coerce+2CltCMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2CltCMatrix+2CltTMatrix-method'></span><span id='topic+coerce+2CltTMatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2CltTMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2CltTMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2CltTMatrix+2CltCMatrix-method'></span><span id='topic+coerce+2CltTMatrix+2CltrMatrix-method'></span><span id='topic+coerce+2CltpMatrix+2CdtpMatrix-method'></span><span id='topic+coerce+2CltpMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2CltpMatrix+2CltrMatrix-method'></span><span id='topic+coerce+2CltrMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CltrMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2CltrMatrix+2CltpMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdgRMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdspMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdtpMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClsCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClspMatrix-method'></span><span id='topic+coerce+2Cmatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CltCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CltTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CltpMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CltrMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CngCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CngTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CngeMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CnspMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CnsyMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CntCMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CntTMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CntpMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CntrMatrix-method'></span><span id='topic+coerce+2CngCMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CngCMatrix+2ClgCMatrix-method'></span><span id='topic+coerce+2CngCMatrix+2CntCMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2ClgTMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2CngTMatrix+2CntTMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CdgeMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2ClgeMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CngTMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CnspMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CnsyMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CntpMatrix-method'></span><span id='topic+coerce+2CngeMatrix+2CntrMatrix-method'></span><span id='topic+coerce+2CnsCMatrix+2CdsCMatrix-method'></span><span id='topic+coerce+2CnsCMatrix+2ClsCMatrix-method'></span><span id='topic+coerce+2CnsCMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CnsCMatrix+2CnsTMatrix-method'></span><span id='topic+coerce+2CnsTMatrix+2CdsTMatrix-method'></span><span id='topic+coerce+2CnsTMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CnsTMatrix+2CngTMatrix-method'></span><span id='topic+coerce+2CnsTMatrix+2CnsCMatrix-method'></span><span id='topic+coerce+2CnsTMatrix+2CnsyMatrix-method'></span><span id='topic+coerce+2CnspMatrix+2CdspMatrix-method'></span><span id='topic+coerce+2CnspMatrix+2ClspMatrix-method'></span><span id='topic+coerce+2CnspMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2CnspMatrix+2CnsyMatrix-method'></span><span id='topic+coerce+2CnsyMatrix+2CdsyMatrix-method'></span><span id='topic+coerce+2CnsyMatrix+2ClsyMatrix-method'></span><span id='topic+coerce+2CnsyMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2CnsyMatrix+2CnspMatrix-method'></span><span id='topic+coerce+2CntCMatrix+2CdtCMatrix-method'></span><span id='topic+coerce+2CntCMatrix+2CltCMatrix-method'></span><span id='topic+coerce+2CntCMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CntTMatrix+2CdtTMatrix-method'></span><span id='topic+coerce+2CntTMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CntTMatrix+2CngTMatrix-method'></span><span id='topic+coerce+2CntTMatrix+2CntCMatrix-method'></span><span id='topic+coerce+2CntTMatrix+2CntrMatrix-method'></span><span id='topic+coerce+2CntpMatrix+2CdtpMatrix-method'></span><span id='topic+coerce+2CntpMatrix+2CltpMatrix-method'></span><span id='topic+coerce+2CntpMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2CntpMatrix+2CntrMatrix-method'></span><span id='topic+coerce+2CntrMatrix+2CdtrMatrix-method'></span><span id='topic+coerce+2CntrMatrix+2CltrMatrix-method'></span><span id='topic+coerce+2CntrMatrix+2CngeMatrix-method'></span><span id='topic+coerce+2CntrMatrix+2CntpMatrix-method'></span><span id='topic+coerce+2CnumLike+2CdgeMatrix-method'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions
of <span class="pkg">Matrix</span> only and may be defunct as soon as the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Deprecated in 1.5-4
..2dge(from)
.C2nC(from, isTri)
.T2Cmat(from, isTri)
.asmatrix(x)
.dense2sy(from, ...)
.diag2mat(from)
.diag2sT(from, uplo = "U", kind = ".", drop0 = TRUE)
.diag2tT(from, uplo = "U", kind = ".", drop0 = TRUE)
.dsy2dsp(from)
.dsy2mat(from, keep.dimnames = TRUE)
.dxC2mat(from, chkUdiag)
.m2dgC(from)
.m2lgC(from)
.m2ngC(from)
.m2ngCn(from, na.is.not.0 = FALSE)
.m2ngTn(from, na.is.not.0 = FALSE)
.n2dgT(from)
.nC2d(from)
.nC2l(from)

## Deprecated in 1.5-0
## S4 method for signature 'RsparseMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ddenseMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ddiMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ddiMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ddiMatrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgCMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgTMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgTMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgTMatrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgTMatrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgTMatrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dgeMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dsRMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,lsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsCMatrix,nsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsTMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsTMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsTMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsTMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsTMatrix,lsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dspMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dspMatrix,lspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsyMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsyMatrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsyMatrix,dspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dsyMatrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,ltCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtCMatrix,ntCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtTMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtTMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtTMatrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtTMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtpMatrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtpMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtpMatrix,ltpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtrMatrix,dtpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'dtrMatrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'indMatrix,ngTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'indMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgCMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgCMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgCMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgCMatrix,ltCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgTMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgTMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgTMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgTMatrix,lsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgTMatrix,ltTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,lspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,ltpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lgeMatrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsCMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsCMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsCMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsCMatrix,lsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsTMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsTMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsTMatrix,lsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsTMatrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lspMatrix,dspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lspMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lspMatrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsyMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsyMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'lsyMatrix,lspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltCMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltCMatrix,ltTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltTMatrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltTMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltTMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltTMatrix,ltCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltTMatrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltpMatrix,dtpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltpMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltpMatrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltrMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltrMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ltrMatrix,ltpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dgRMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dtpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ltCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ltTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ltpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ngTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,nspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,nsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ntCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ntTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ntpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'matrix,ntrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngCMatrix,dgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngCMatrix,lgCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngCMatrix,ntCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,dgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,lgTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngTMatrix,ntTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,dgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,lgeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,ngTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,nspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,nsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,ntpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ngeMatrix,ntrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsCMatrix,dsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsCMatrix,lsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsCMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsCMatrix,nsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsTMatrix,dsTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsTMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsTMatrix,ngTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsTMatrix,nsCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsTMatrix,nsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nspMatrix,dspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nspMatrix,lspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nspMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nspMatrix,nsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsyMatrix,dsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsyMatrix,lsyMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsyMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'nsyMatrix,nspMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntCMatrix,dtCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntCMatrix,ltCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntCMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntTMatrix,dtTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntTMatrix,ngCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntTMatrix,ngTMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntTMatrix,ntCMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntTMatrix,ntrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntpMatrix,dtpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntpMatrix,ltpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntpMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntpMatrix,ntrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntrMatrix,dtrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntrMatrix,ltrMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntrMatrix,ngeMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'ntrMatrix,ntpMatrix'
coerce(from, to, strict = TRUE)
## S4 method for signature 'numLike,dgeMatrix'
coerce(from, to, strict = TRUE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>,
<code><a href="base.html#topic+base-deprecated">base-deprecated</a></code>,
<code><a href="#topic+Matrix-defunct">Matrix-defunct</a></code>
</p>

<hr>
<h2 id='Matrix-notyet'>Virtual Classes Not Yet Really Implemented and Used</h2><span id='topic+Matrix-notyet'></span><span id='topic+iMatrix-class'></span><span id='topic+zMatrix-class'></span>

<h3>Description</h3>

<p><code>iMatrix</code> is the virtual class of all integer
(S4) matrices.  It extends the <code><a href="#topic+Matrix-class">Matrix</a></code> class directly.
</p>
<p><code>zMatrix</code> is the virtual class of all <code><a href="base.html#topic+complex">complex</a></code>
(S4) matrices.  It extends the <code><a href="#topic+Matrix-class">Matrix</a></code> class directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("iMatrix")
showClass("zMatrix")
</code></pre>

<hr>
<h2 id='MatrixClass'>The Matrix (Super-) Class of a Class</h2><span id='topic+MatrixClass'></span>

<h3>Description</h3>

<p>Return the (maybe super-)<code><a href="base.html#topic+class">class</a></code> of class <code>cl</code> from
package <span class="pkg">Matrix</span>, returning <code><a href="base.html#topic+character">character</a>(0)</code> if there is none.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixClass(cl, cld = getClassDef(cl), ...Matrix = TRUE,
            dropVirtual = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixClass_+3A_cl">cl</code></td>
<td>
<p>string, class name</p>
</td></tr>
<tr><td><code id="MatrixClass_+3A_cld">cld</code></td>
<td>
<p>its class definition</p>
</td></tr>
<tr><td><code id="MatrixClass_+3A_...matrix">...Matrix</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the result must be of
pattern <code>"[dlniz]..Matrix"</code> where the first letter &quot;[dlniz]&quot;
denotes the content kind.</p>
</td></tr>
<tr><td><code id="MatrixClass_+3A_dropvirtual">dropVirtual</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if virtual classes
are included or not.</p>
</td></tr>
<tr><td><code id="MatrixClass_+3A_...">...</code></td>
<td>
<p>further arguments are passed to
<code><a href="methods.html#topic+.selectSuperClasses">.selectSuperClasses</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+character">character</a></code> string
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, 24 Mar 2009</p>


<h3>See Also</h3>

<p><code><a href="#topic+Matrix-class">Matrix</a></code>, the mother of all <span class="pkg">Matrix</span> classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mkA &lt;- setClass("A", contains="dgCMatrix")
(A &lt;- mkA())
stopifnot(identical(
     MatrixClass("A"),
     "dgCMatrix"))
</code></pre>

<hr>
<h2 id='MatrixFactorization-class'>Virtual Class &quot;MatrixFactorization&quot; of Matrix Factorizations</h2><span id='topic+MatrixFactorization-class'></span><span id='topic+BunchKaufmanFactorization-class'></span><span id='topic+CholeskyFactorization-class'></span><span id='topic+SchurFactorization-class'></span><span id='topic+LU-class'></span><span id='topic+QR-class'></span><span id='topic+determinant+2CMatrixFactorization+2Cmissing-method'></span><span id='topic+dim+2CMatrixFactorization-method'></span><span id='topic+dimnames+2CMatrixFactorization-method'></span><span id='topic+dimnames+3C-+2CMatrixFactorization+2CNULL-method'></span><span id='topic+dimnames+3C-+2CMatrixFactorization+2Clist-method'></span><span id='topic+length+2CMatrixFactorization-method'></span><span id='topic+show+2CMatrixFactorization-method'></span><span id='topic+unname+2CMatrixFactorization-method'></span><span id='topic+show+2CBunchKaufmanFactorization-method'></span><span id='topic+show+2CCholeskyFactorization-method'></span><span id='topic+show+2CSchurFactorization-method'></span><span id='topic+show+2CLU-method'></span><span id='topic+show+2CQR-method'></span>

<h3>Description</h3>

<p><code>MatrixFactorization</code> is the virtual class of
factorizations of <code class="reqn">m \times n</code> matrices <code class="reqn">A</code>,
having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{2} = A_{1} \cdots A_{p}</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' A_{1} \cdots A_{p} P_{2}'</code>
</p>

<p>where <code class="reqn">P_{1}</code> and <code class="reqn">P_{2}</code> are permutation matrices.
Factorizations requiring symmetric <code class="reqn">A</code> have the constraint
<code class="reqn">P_{2} = P_{1}'</code>, and factorizations without row
or column pivoting have the constraints
<code class="reqn">P_{1} = I_{m}</code> and <code class="reqn">P_{2} = I_{n}</code>,
where <code class="reqn">I_{m}</code> and <code class="reqn">I_{n}</code> are the
<code class="reqn">m \times m</code> and <code class="reqn">n \times n</code> identity matrices.
</p>
<p><code>CholeskyFactorization</code>, <code>BunchKaufmanFactorization</code>,
<code>SchurFactorization</code>, <code>LU</code>, and <code>QR</code> are the virtual
subclasses of <code>MatrixFactorization</code> containing all Cholesky,
Bunch-Kaufman, Schur, LU, and QR factorizations, respectively.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code></dt><dd><p>an integer vector of length 2 giving the
dimensions of the factorized matrix.</p>
</dd>
<dt><code>Dimnames</code></dt><dd><p>a list of length 2 preserving the
<code>dimnames</code> of the factorized matrix.  Each element
must be <code>NULL</code> or a character vector of length equal
to the corresponding element of <code>Dim</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>determinant</code></dt><dd><p><code>signature(x = "MatrixFactorization", logarithm = "missing")</code>:
sets <code>logarithm = TRUE</code> and recalls the generic function.</p>
</dd>
<dt><code>dim</code></dt><dd><p><code>signature(x = "MatrixFactorization")</code>:
returns <code>x@Dim</code>.</p>
</dd>
<dt><code>dimnames</code></dt><dd><p><code>signature(x = "MatrixFactorization")</code>:
returns <code>x@Dimnames</code>.</p>
</dd>
<dt><code>dimnames&lt;-</code></dt><dd><p><code>signature(x = "MatrixFactorization", value = "NULL")</code>:
returns <code>x</code> with <code>x@Dimnames</code> set to <code>list(NULL, NULL)</code>.</p>
</dd>
<dt><code>dimnames&lt;-</code></dt><dd><p><code>signature(x = "MatrixFactorization", value = "list")</code>:
returns <code>x</code> with <code>x@Dimnames</code> set to <code>value</code>.</p>
</dd>
<dt><code>length</code></dt><dd><p><code>signature(x = "MatrixFactorization")</code>:
returns <code>prod(x@Dim)</code>.</p>
</dd>
<dt><code>show</code></dt><dd><p><code>signature(object = "MatrixFactorization")</code>:
prints the internal representation of the factorization using
<code><a href="utils.html#topic+str">str</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "MatrixFactorization", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
<dt><code>unname</code></dt><dd><p><code>signature(obj = "MatrixFactorization")</code>:
returns <code>obj</code> with <code>obj@Dimnames</code> set to
<code>list(NULL, NULL)</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Classes extending <code>CholeskyFactorization</code>, namely
<code><a href="#topic+Cholesky-class">Cholesky</a></code>, <code><a href="#topic+pCholesky-class">pCholesky</a></code>,
and <code><a href="#topic+CHMfactor-class">CHMfactor</a></code>.
</p>
<p>Classes extending <code>BunchKaufmanFactorization</code>, namely
<code><a href="#topic+BunchKaufman-class">BunchKaufman</a></code> and <code><a href="#topic+pBunchKaufman-class">pBunchKaufman</a></code>.
</p>
<p>Classes extending <code>SchurFactorization</code>, namely
<code><a href="#topic+Schur-class">Schur</a></code>.
</p>
<p>Classes extending <code>LU</code>, namely
<code><a href="#topic+denseLU-class">denseLU</a></code> and <code><a href="#topic+sparseLU-class">sparseLU</a></code>.
</p>
<p>Classes extending <code>QR</code>, namely <code><a href="#topic+sparseQR-class">sparseQR</a></code>.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+Schur">Schur</a></code>, <code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code> for
<em>computing</em> factorizations.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>
for constructing matrix factors from <code>MatrixFactorization</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MatrixFactorization")
</code></pre>

<hr>
<h2 id='ndenseMatrix-class'>Virtual Class &quot;ndenseMatrix&quot; of Dense Logical Matrices</h2><span id='topic+ndenseMatrix-class'></span><span id='topic++21+2CndenseMatrix-method'></span><span id='topic++26+2CndenseMatrix+2CddiMatrix-method'></span><span id='topic++26+2CndenseMatrix+2CldiMatrix-method'></span><span id='topic++26+2CndenseMatrix+2CndiMatrix-method'></span><span id='topic++2A+2CndenseMatrix+2CddiMatrix-method'></span><span id='topic++2A+2CndenseMatrix+2CldiMatrix-method'></span><span id='topic++2A+2CndenseMatrix+2CndiMatrix-method'></span><span id='topic+Ops+2CndenseMatrix+2CndenseMatrix-method'></span><span id='topic++5E+2CndenseMatrix+2CddiMatrix-method'></span><span id='topic++5E+2CndenseMatrix+2CldiMatrix-method'></span><span id='topic++5E+2CndenseMatrix+2CndiMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CndenseMatrix-method'></span><span id='topic+coerce+2Cvector+2CndenseMatrix-method'></span><span id='topic+which+2CndenseMatrix-method'></span>

<h3>Description</h3>

<p><code>ndenseMatrix</code> is the virtual class of all dense <b>l</b>ogical
(S4) matrices.  It extends both <code><a href="#topic+denseMatrix-class">denseMatrix</a></code>
and <code><a href="#topic+lMatrix-class">lMatrix</a></code> directly.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>logical vector containing the entries of the matrix.</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>see <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"nMatrix"</code>, directly.
Class <code>"denseMatrix"</code>, directly.
Class <code>"Matrix"</code>, by class <code>"nMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"denseMatrix"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "nsparseMatrix", y = "ndenseMatrix")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "ndenseMatrix", y = "nsparseMatrix")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "nsparseMatrix", y = "ndenseMatrix")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "ndenseMatrix", y = "nsparseMatrix")</code>: ... </p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "ndenseMatrix", mode = "missing")</code>: ...</p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "ndenseMatrix")</code>: extracts the
diagonal as for all matrices, see the generic <code><a href="base.html#topic+diag">diag</a>()</code>.</p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "ndenseMatrix")</code>, semantically
equivalent to <span class="pkg">base</span> function <code><a href="base.html#topic+which">which</a>(x, arr.ind)</code>;
for details, see the <code><a href="#topic+lMatrix-class">lMatrix</a></code> class documentation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Class <code><a href="#topic+ngeMatrix-class">ngeMatrix</a></code> and the other subclasses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ndenseMatrix")

as(diag(3) &gt; 0, "ndenseMatrix")# -&gt; "nge"
</code></pre>

<hr>
<h2 id='nearPD'>Nearest Positive Definite Matrix</h2><span id='topic+nearPD'></span>

<h3>Description</h3>

<p>Compute the nearest positive definite matrix to an approximate
one, typically a correlation or variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearPD(x, corr = FALSE, keepDiag = FALSE, base.matrix = FALSE,
       do2eigen = TRUE, doSym = FALSE,
       doDykstra = TRUE, only.values = FALSE,
       ensureSymmetry = !isSymmetric(x),
       eig.tol = 1e-06, conv.tol = 1e-07, posd.tol = 1e-08,
       maxit = 100, conv.norm.type = "I", trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearPD_+3A_x">x</code></td>
<td>
<p>numeric <code class="reqn">n \times n</code> approximately positive
definite matrix, typically an approximation to a correlation or
covariance matrix.  If <code>x</code> is not symmetric (and
<code>ensureSymmetry</code> is not false), <code><a href="#topic+symmpart">symmpart</a>(x)</code> is used.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_corr">corr</code></td>
<td>
<p>logical indicating if the matrix should be a
<em>correlation</em> matrix.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_keepdiag">keepDiag</code></td>
<td>
<p>logical, generalizing <code>corr</code>: if <code>TRUE</code>, the
resulting matrix should have the same diagonal
(<code><a href="base.html#topic+diag">diag</a>(x)</code>) as the input matrix.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_base.matrix">base.matrix</code></td>
<td>
<p>logical indicating if the resulting <code>mat</code>
component should be a <span class="pkg">base</span> <code><a href="base.html#topic+matrix">matrix</a></code> or (by default) a
<code><a href="#topic+Matrix-class">Matrix</a></code> of class <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_do2eigen">do2eigen</code></td>
<td>
<p>logical indicating if a
<code><a href="sfsmisc.html#topic+posdefify">posdefify</a>()</code> eigen step should be applied to
the result of the Higham algorithm.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_dosym">doSym</code></td>
<td>
<p>logical indicating if <code>X &lt;- (X + t(X))/2</code> should be
done, after <code>X &lt;- tcrossprod(Qd, Q)</code>; some doubt if this is necessary.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_dodykstra">doDykstra</code></td>
<td>
<p>logical indicating if Dykstra's correction should be
used; true by default.  If false, the algorithm is basically the
direct fixpoint iteration
<code class="reqn">Y_k = P_U(P_S(Y_{k-1}))</code>.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_only.values">only.values</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result is just the
vector of eigenvalues of the approximating matrix.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_ensuresymmetry">ensureSymmetry</code></td>
<td>
<p>logical; by default, <code><a href="#topic+symmpart">symmpart</a>(x)</code>
is used whenever <code><a href="#topic+isSymmetric">isSymmetric</a>(x)</code> is not true.  The user
can explicitly set this to <code>TRUE</code> or <code>FALSE</code>, saving the
symmetry test. <em>Beware</em> however that setting it <code>FALSE</code>
for an <b>a</b>symmetric input <code>x</code>, is typically nonsense!</p>
</td></tr>
<tr><td><code id="nearPD_+3A_eig.tol">eig.tol</code></td>
<td>
<p>defines relative positiveness of eigenvalues compared
to largest one, <code class="reqn">\lambda_1</code>. Eigenvalues <code class="reqn">\lambda_k</code> are
treated as if zero when <code class="reqn">\lambda_k / \lambda_1 \le eig.tol</code>.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_conv.tol">conv.tol</code></td>
<td>
<p>convergence tolerance for Higham algorithm.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_posd.tol">posd.tol</code></td>
<td>
<p>tolerance for enforcing positive definiteness (in the
final <code>posdefify</code> step when <code>do2eigen</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="nearPD_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_conv.norm.type">conv.norm.type</code></td>
<td>
<p>convergence norm type (<code><a href="#topic+norm">norm</a>(*,
      type)</code>) used for Higham algorithm.  The default is <code>"I"</code>
(infinity), for reasons of speed (and back compatibility); using
<code>"F"</code> is more in line with Higham's proposal.</p>
</td></tr>
<tr><td><code id="nearPD_+3A_trace">trace</code></td>
<td>
<p>logical or integer specifying if convergence monitoring
should be traced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the algorithm of Higham (2002), and then (if
<code>do2eigen</code> is true) forces positive definiteness using code from
<code><a href="sfsmisc.html#topic+posdefify">posdefify</a></code>.  The algorithm of Knol and ten
Berge (1989) (not implemented here) is more general in that it
allows constraints to (1) fix some rows (and columns) of the matrix and
(2) force the smallest eigenvalue to have a certain value.
</p>
<p>Note that setting <code>corr = TRUE</code> just sets <code>diag(.) &lt;- 1</code>
within the algorithm.
</p>
<p>Higham (2002) uses Dykstra's correction, but the version by Jens
Oehlschlägel did not use it (accidentally),
and still gave reasonable results; this simplification, now only
used if <code>doDykstra = FALSE</code>,
was active in <code>nearPD()</code> up to Matrix version 0.999375-40.
</p>


<h3>Value</h3>

<p>If <code>only.values = TRUE</code>, a numeric vector of eigenvalues of the
approximating matrix;
Otherwise, as by default, an S3 object of <code><a href="base.html#topic+class">class</a></code>
<code>"nearPD"</code>, basically a list with components
</p>
<table>
<tr><td><code>mat</code></td>
<td>
<p>a matrix of class <code><a href="#topic+dpoMatrix-class">dpoMatrix</a></code>, the
computed positive-definite matrix.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>numeric vector of eigenvalues of <code>mat</code>.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>logical, just the argument <code>corr</code>.</p>
</td></tr>
<tr><td><code>normF</code></td>
<td>
<p>the Frobenius norm (<code><a href="#topic+norm">norm</a>(x-X, "F")</code>) of the
difference between the original and the resulting matrix.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations needed.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating if iterations converged.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel donated a first version.
Subsequent changes by the Matrix package authors.
</p>


<h3>References</h3>


<p>Cheng, Sheung Hun and Higham, Nick (1998)
A Modified Cholesky Algorithm Based on a Symmetric Indefinite Factorization;
<em>SIAM J. Matrix Anal.\ Appl.</em>, <b>19</b>, 1097&ndash;1110.
</p>
<p>Knol DL, ten Berge JMF (1989)
Least-squares approximation of an improper correlation matrix by a
proper one.
<em>Psychometrika</em> <b>54</b>, 53&ndash;61.
</p>
<p>Higham, Nick (2002)
Computing the nearest correlation matrix - a problem from finance;
<em>IMA Journal of Numerical Analysis</em> <b>22</b>, 329&ndash;343.
</p>


<h3>See Also</h3>

<p>A first version of this (with non-optional <code>corr=TRUE</code>)
has been available as <code><a href="sfsmisc.html#topic+nearcor">nearcor</a>()</code>; and
more simple versions with a similar purpose
<code><a href="sfsmisc.html#topic+posdefify">posdefify</a>()</code>, both from package <span class="pkg">sfsmisc</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Higham(2002), p.334f - simple example
 A &lt;- matrix(1, 3,3); A[1,3] &lt;- A[3,1] &lt;- 0
 n.A &lt;- nearPD(A, corr=TRUE, do2eigen=FALSE)
 n.A[c("mat", "normF")]
 n.A.m &lt;- nearPD(A, corr=TRUE, do2eigen=FALSE, base.matrix=TRUE)$mat
 stopifnot(exprs = {                           #=--------------
   all.equal(n.A$mat[1,2], 0.760689917)
   all.equal(n.A$normF, 0.52779033, tolerance=1e-9)
   all.equal(n.A.m, unname(as.matrix(n.A$mat)), tolerance = 1e-15)# seen rel.d.= 1.46e-16
 })
 set.seed(27)
 m &lt;- matrix(round(rnorm(25),2), 5, 5)
 m &lt;- m + t(m)
 diag(m) &lt;- pmax(0, diag(m)) + 1
 (m &lt;- round(cov2cor(m), 2))

 str(near.m &lt;- nearPD(m, trace = TRUE))
 round(near.m$mat, 2)
 norm(m - near.m$mat) # 1.102 / 1.08

 if(requireNamespace("sfsmisc")) {
    m2 &lt;- sfsmisc::posdefify(m) # a simpler approach
    norm(m - m2)  # 1.185, i.e., slightly "less near"
 }

 round(nearPD(m, only.values=TRUE), 9)

## A longer example, extended from Jens' original,
## showing the effects of some of the options:

pr &lt;- Matrix(c(1,     0.477, 0.644, 0.478, 0.651, 0.826,
               0.477, 1,     0.516, 0.233, 0.682, 0.75,
               0.644, 0.516, 1,     0.599, 0.581, 0.742,
               0.478, 0.233, 0.599, 1,     0.741, 0.8,
               0.651, 0.682, 0.581, 0.741, 1,     0.798,
               0.826, 0.75,  0.742, 0.8,   0.798, 1),
             nrow = 6, ncol = 6)

nc.  &lt;- nearPD(pr, conv.tol = 1e-7) # default
nc.$iterations  # 2
nc.1 &lt;- nearPD(pr, conv.tol = 1e-7, corr = TRUE)
nc.1$iterations # 11 / 12 (!)
ncr   &lt;- nearPD(pr, conv.tol = 1e-15)
str(ncr)# still 2 iterations
ncr.1 &lt;- nearPD(pr, conv.tol = 1e-15, corr = TRUE)
ncr.1 $ iterations # 27 / 30 !

ncF &lt;- nearPD(pr, conv.tol = 1e-15, conv.norm = "F")
stopifnot(all.equal(ncr, ncF))# norm type does not matter at all in this example

## But indeed, the 'corr = TRUE' constraint did ensure a better solution;
## cov2cor() does not just fix it up equivalently :
norm(pr - cov2cor(ncr$mat)) # = 0.09994
norm(pr -       ncr.1$mat)  # = 0.08746 / 0.08805

### 3) a real data example from a 'systemfit' model (3 eq.):
(load(system.file("external", "symW.rda", package="Matrix"))) # "symW"
dim(symW) #  24 x 24
class(symW)# "dsCMatrix": sparse symmetric
if(dev.interactive())  image(symW)
EV &lt;- eigen(symW, only=TRUE)$values
summary(EV) ## looking more closely {EV sorted decreasingly}:
tail(EV)# all 6 are negative
EV2 &lt;- eigen(sWpos &lt;- nearPD(symW)$mat, only=TRUE)$values
stopifnot(EV2 &gt; 0)
if(requireNamespace("sfsmisc")) {
    plot(pmax(1e-3,EV), EV2, type="o", log="xy", xaxt="n", yaxt="n")
    for(side in 1:2) sfsmisc::eaxis(side)
} else
    plot(pmax(1e-3,EV), EV2, type="o", log="xy")
abline(0, 1, col="red3", lty=2)
</code></pre>

<hr>
<h2 id='ngeMatrix-class'>Class &quot;ngeMatrix&quot; of General Dense Nonzero-pattern Matrices</h2><span id='topic+ngeMatrix-class'></span><span id='topic+Arith+2CngeMatrix+2CngeMatrix-method'></span><span id='topic+Compare+2CngeMatrix+2CngeMatrix-method'></span><span id='topic+Logic+2CngeMatrix+2CngeMatrix-method'></span>

<h3>Description</h3>

<p>This is the class of general dense nonzero-pattern
matrices, see <code><a href="#topic+nMatrix-class">nMatrix</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"ndenseMatrix"</code>, directly.
Class <code>"lMatrix"</code>, by class <code>"ndenseMatrix"</code>.
Class <code>"denseMatrix"</code>, by class <code>"ndenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ndenseMatrix"</code>.
Class <code>"Matrix"</code>, by class <code>"ndenseMatrix"</code>.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>); use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="ngeMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p>Non-general logical dense matrix classes such as
<code><a href="#topic+ntrMatrix-class">ntrMatrix</a></code>, or <code><a href="#topic+nsyMatrix-class">nsyMatrix</a></code>;
<em>sparse</em> logical classes such as <code><a href="#topic+ngCMatrix-class">ngCMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ngeMatrix")
## "lgeMatrix" is really more relevant
</code></pre>

<hr>
<h2 id='nMatrix-class'>Class &quot;nMatrix&quot; of Non-zero Pattern Matrices</h2><span id='topic+nMatrix-class'></span><span id='topic+Arith+2Clogical+2CnMatrix-method'></span><span id='topic+Arith+2CnMatrix+2Clogical-method'></span><span id='topic+Arith+2CnMatrix+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CnMatrix-method'></span><span id='topic+Compare+2Clogical+2CnMatrix-method'></span><span id='topic+Compare+2CnMatrix+2Clogical-method'></span><span id='topic+Compare+2CnMatrix+2CnMatrix-method'></span><span id='topic+Compare+2CnMatrix+2Cnumeric-method'></span><span id='topic+Compare+2Cnumeric+2CnMatrix-method'></span><span id='topic+Logic+2Clogical+2CnMatrix-method'></span><span id='topic+Logic+2CnMatrix+2CMatrix-method'></span><span id='topic+Logic+2CnMatrix+2Clogical-method'></span><span id='topic+Logic+2CnMatrix+2CnMatrix-method'></span><span id='topic+Logic+2CnMatrix+2Cnumeric-method'></span><span id='topic+Logic+2CnMatrix+2CsparseVector-method'></span><span id='topic+Logic+2Cnumeric+2CnMatrix-method'></span><span id='topic+Ops+2CnMatrix+2CdMatrix-method'></span><span id='topic+Ops+2CnMatrix+2ClMatrix-method'></span><span id='topic+Ops+2CnMatrix+2CnMatrix-method'></span><span id='topic+Ops+2CnMatrix+2Cnumeric-method'></span><span id='topic+Ops+2Cnumeric+2CnMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CnMatrix-method'></span><span id='topic+coerce+2Cvector+2CnMatrix-method'></span>

<h3>Description</h3>

<p>The <code>nMatrix</code> class is the virtual &ldquo;mother&rdquo; class of all
<em><b>n</b>on-zero pattern</em> (or simply <em>patter<b>n</b></em>)
matrices in the <span class="pkg">Matrix</span> package.
</p>


<h3>Slots</h3>

<p>Common to <em>all</em> matrix object in the package:
</p>

<dl>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>list of length two; each component
containing NULL or a <code><a href="base.html#topic+character">character</a></code> vector length
equal the corresponding <code>Dim</code> element.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "nMatrix")</code>:
Note that these coercions (must) coerce <code><a href="base.html#topic+NA">NA</a></code>s to
non-zero, hence conceptually <code>TRUE</code>.
This is particularly important when
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> objects are coerced to
<code>"nMatrix"</code> and hence to <code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>.
</p>
</dd>
</dl>

<p>&mdash; &mdash; &mdash;
</p>
<p>Additional methods contain group methods, such as
</p>

<dl>
<dt>Ops</dt><dd><p><code>signature(e1 = "nMatrix", e2 = "....")</code>, ...</p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "nMatrix", e2 = "....")</code>, ...</p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "nMatrix", e2 = "....")</code>, ...</p>
</dd>
<dt>Logic</dt><dd><p><code>signature(e1 = "nMatrix", e2 = "....")</code>, ...</p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "nMatrix", "....")</code>, ...</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The classes <code><a href="#topic+lMatrix-class">lMatrix</a></code>,
<code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>, and the mother class,
<code><a href="#topic+Matrix-class">Matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getClass("nMatrix")

L3 &lt;- Matrix(upper.tri(diag(3)))
L3 # an "ltCMatrix"
as(L3, "nMatrix") # -&gt; ntC*

## similar, not using Matrix()
as(upper.tri(diag(3)), "nMatrix")# currently "ngTMatrix"
</code></pre>

<hr>
<h2 id='nnzero-methods'>The Number of Non-Zero Values of a Matrix</h2><span id='topic+nnzero'></span><span id='topic+nnzero-methods'></span><span id='topic+nnzero+2CANY-method'></span><span id='topic+nnzero+2CCHMfactor-method'></span><span id='topic+nnzero+2CdenseMatrix-method'></span><span id='topic+nnzero+2CdiagonalMatrix-method'></span><span id='topic+nnzero+2CindMatrix-method'></span><span id='topic+nnzero+2CsparseMatrix-method'></span><span id='topic+nnzero+2Cvector-method'></span>

<h3>Description</h3>

<p>Returns the number of non-zero values of a numeric-like <span class="rlang"><b>R</b></span> object, and
in particular an object <code>x</code> inheriting from class
<code><a href="#topic+Matrix-class">Matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnzero(x, na.counted = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnzero-methods_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object, typically inheriting from class
<code><a href="#topic+Matrix-class">Matrix</a></code> or <code><a href="base.html#topic+numeric">numeric</a></code>.</p>
</td></tr>
<tr><td><code id="nnzero-methods_+3A_na.counted">na.counted</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> describing how
<code><a href="base.html#topic+NA">NA</a></code>s should be counted.  There are three possible
settings for <code>na.counted</code>:
</p>

<dl>
<dt>TRUE</dt><dd><p><code>NA</code>s <em>are</em> counted as non-zero (since
&ldquo;they are not zero&rdquo;).</p>
</dd>
<dt>NA</dt><dd><p>(default)the result will be <code>NA</code> if there are <code>NA</code>'s in
<code>x</code> (since &ldquo;NA's are not known, i.e., <em>may be</em> zero&rdquo;).</p>
</dd>
<dt>FALSE</dt><dd><p><code>NA</code>s are <em>omitted</em> from <code>x</code> before
the non-zero entries are counted.</p>
</dd>
</dl>

<p>For sparse matrices, you may often want to use <code>na.counted = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of non zero entries in <code>x</code> (typically
<code><a href="base.html#topic+integer">integer</a></code>).
</p>
<p>Note that for a <em>symmetric</em> sparse matrix <code>S</code> (i.e., inheriting from
class <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>), <code>nnzero(S)</code> is
typically <em>twice</em> the <code>length(S@x)</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd><p>the default method for
non-<code><a href="#topic+Matrix-class">Matrix</a></code> class objects, simply counts the
number <code>0</code>s in <code>x</code>, counting <code>NA</code>'s depending on
the <code>na.counted</code> argument, see above.</p>
</dd>
<dt><code>signature(x = "denseMatrix")</code></dt><dd><p>conceptually the same as
for traditional <code><a href="base.html#topic+matrix">matrix</a></code> objects, care has to be taken
for <code>"<a href="#topic+symmetricMatrix-class">symmetricMatrix</a>"</code> objects.</p>
</dd>
<dt><code>signature(x = "diagonalMatrix")</code>, and
<code>signature(x = "indMatrix")</code></dt><dd><p>fast simple methods for these
special <code>"sparseMatrix"</code> classes.</p>
</dd>
<dt><code>signature(x = "sparseMatrix")</code></dt><dd><p>typically, the most
interesting method, also carefully taking
<code>"<a href="#topic+symmetricMatrix-class">symmetricMatrix</a>"</code> objects into account.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <code><a href="#topic+Matrix-class">Matrix</a></code> class also has a
<code><a href="base.html#topic+length">length</a></code> method; typically, <code>length(M)</code> is much
larger than <code>nnzero(M)</code> for a sparse matrix M, and the latter is
a better indication of the <em>size</em> of <code>M</code>.
</p>
<p><code><a href="#topic+drop0">drop0</a></code>, <code><a href="base.html#topic+zapsmall">zapsmall</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- Matrix(0+1:28, nrow = 4)
m[-3,c(2,4:5,7)] &lt;- m[ 3, 1:4] &lt;- m[1:3, 6] &lt;- 0
(mT &lt;- as(m, "TsparseMatrix"))
nnzero(mT)
(S &lt;- crossprod(mT))
nnzero(S)
str(S) # slots are smaller than nnzero()
stopifnot(nnzero(S) == sum(as.matrix(S) != 0))# failed earlier

data(KNex, package = "Matrix")
M &lt;- KNex$mm
class(M)
dim(M)
length(M); stopifnot(length(M) == prod(dim(M)))
nnzero(M) # more relevant than length
## the above are also visible from
str(M)
</code></pre>

<hr>
<h2 id='norm-methods'>Matrix Norms</h2><span id='topic+norm'></span><span id='topic+norm-methods'></span><span id='topic+norm+2CANY+2Cmissing-method'></span><span id='topic+norm+2CdenseMatrix+2Ccharacter-method'></span><span id='topic+norm+2CdiagonalMatrix+2Ccharacter-method'></span><span id='topic+norm+2CindMatrix+2Ccharacter-method'></span><span id='topic+norm+2CpMatrix+2Ccharacter-method'></span><span id='topic+norm+2CsparseMatrix+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Computes a matrix norm of <code>x</code>, using Lapack for dense matrices.
The norm can be the one  (<code>"O"</code>, or <code>"1"</code>) norm, the
infinity (<code>"I"</code>) norm, the Frobenius  (<code>"F"</code>) norm,
the maximum modulus (<code>"M"</code>) among elements of a matrix, or the
spectral norm or 2-norm (<code>"2"</code>), as determined by the value of
<code>type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm-methods_+3A_x">x</code></td>
<td>

<p>a real or complex matrix.
</p>
</td></tr>
<tr><td><code id="norm-methods_+3A_type">type</code></td>
<td>

<p>A character indicating the type of norm desired.
</p>

<dl>
<dt><code>"O"</code>, <code>"o"</code> or <code>"1"</code></dt><dd><p>specifies the one norm,
(maximum absolute column sum);</p>
</dd>
<dt><code>"I"</code> or <code>"i"</code></dt><dd><p>specifies the infinity norm (maximum
absolute row sum);</p>
</dd>
<dt><code>"F"</code> or <code>"f"</code></dt><dd><p>specifies the Frobenius norm (the
Euclidean norm of <code>x</code> treated as if it were a vector);</p>
</dd>
<dt><code>"M"</code> or <code>"m"</code></dt><dd><p>specifies the maximum modulus of
all the elements in <code>x</code>; and</p>
</dd>
<dt><code>"2"</code></dt><dd><p>specifies the &ldquo;spectral norm&rdquo; aka &ldquo;2-norm&rdquo;, which
is the largest singular value (<code><a href="base.html#topic+svd">svd</a></code>) of <code>x</code>.</p>
</dd>
</dl>

<p>The default is <code>"O"</code>.  Only the first character of
<code>type[1]</code> is used.
</p>
</td></tr>
<tr><td><code id="norm-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dense matrices, the methods eventually call the Lapack functions
<code>dlange</code>, <code>dlansy</code>, <code>dlantr</code>, <code>zlange</code>,
<code>zlansy</code>, and <code>zlantr</code>.
</p>


<h3>Value</h3>

<p>A numeric value of class <code>"norm"</code>, representing the quantity
chosen according to <code>type</code>.
</p>


<h3>References</h3>

<p>Anderson, E., et al. (1994).
<em>LAPACK User's Guide,</em>
2nd edition, SIAM, Philadelphia.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+onenormest">onenormest</a>()</code>, an <em>approximate</em> randomized estimate
of the 1-norm condition number, efficient for large sparse matrices.
</p>
<p>The <code><a href="base.html#topic+norm">norm</a>()</code> function from <span class="rlang"><b>R</b></span>'s <span class="pkg">base</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Hilbert(9)
norm(x)# = "O" = "1"
stopifnot(identical(norm(x), norm(x, "1")))
norm(x, "I")# the same, because 'x' is symmetric

allnorms &lt;- function(x) {
    ## norm(NA, "2") did not work until R 4.0.0
    do2 &lt;- getRversion() &gt;= "4.0.0" || !anyNA(x)
    vapply(c("1", "I", "F", "M", if(do2) "2"), norm, 0, x = x)
}
allnorms(x)
allnorms(Hilbert(10))

i &lt;- c(1,3:8); j &lt;- c(2,9,6:10); x &lt;- 7 * (1:7)
A &lt;- sparseMatrix(i, j, x = x)                      ##  8 x 10 "dgCMatrix"
(sA &lt;- sparseMatrix(i, j, x = x, symmetric = TRUE)) ## 10 x 10 "dsCMatrix"
(tA &lt;- sparseMatrix(i, j, x = x, triangular= TRUE)) ## 10 x 10 "dtCMatrix"
(allnorms(A) -&gt; nA)
allnorms(sA)
allnorms(tA)
stopifnot(all.equal(nA, allnorms(as(A, "matrix"))),
	  all.equal(nA, allnorms(tA))) # because tA == rbind(A, 0, 0)
A. &lt;- A; A.[1,3] &lt;- NA
stopifnot(is.na(allnorms(A.))) # gave error
</code></pre>

<hr>
<h2 id='nsparseMatrix-class'>Sparse &quot;pattern&quot; Matrices</h2><span id='topic+nsparseMatrix-class'></span><span id='topic+nsparseMatrix-classes'></span><span id='topic+ngCMatrix-class'></span><span id='topic+ngRMatrix-class'></span><span id='topic+ngTMatrix-class'></span><span id='topic+ntCMatrix-class'></span><span id='topic+ntRMatrix-class'></span><span id='topic+ntTMatrix-class'></span><span id='topic+nsCMatrix-class'></span><span id='topic+nsRMatrix-class'></span><span id='topic+nsTMatrix-class'></span><span id='topic++21+2CnsparseMatrix-method'></span><span id='topic+-+2CnsparseMatrix+2Cmissing-method'></span><span id='topic+Arith+2CnsparseMatrix+2CMatrix-method'></span><span id='topic+Arith+2CdsparseMatrix+2CnsparseMatrix-method'></span><span id='topic+Arith+2ClsparseMatrix+2CnsparseMatrix-method'></span><span id='topic+Arith+2CnsparseMatrix+2CdsparseMatrix-method'></span><span id='topic+Arith+2CnsparseMatrix+2ClsparseMatrix-method'></span><span id='topic+Ops+2CnsparseMatrix+2CdsparseMatrix-method'></span><span id='topic+Ops+2CnsparseMatrix+2ClsparseMatrix-method'></span><span id='topic+Ops+2CnsparseMatrix+2CsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CnsparseMatrix-method'></span><span id='topic+coerce+2CnsparseMatrix+2CindMatrix-method'></span><span id='topic+coerce+2CnsparseMatrix+2CpMatrix-method'></span><span id='topic+coerce+2Cvector+2CnsparseMatrix-method'></span><span id='topic+which+2CnsparseMatrix-method'></span>

<h3>Description</h3>

<p>The <code>nsparseMatrix</code> class is a virtual class of sparse
<em>&ldquo;pattern&rdquo;</em> matrices, i.e., binary matrices conceptually
with <code>TRUE</code>/<code>FALSE</code> entries.  Only the positions of the
elements that are <code>TRUE</code> are stored.
</p>
<p>These can be stored in the &ldquo;triplet&rdquo; form
(<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, subclasses <code>ngTMatrix</code>,
<code>nsTMatrix</code>, and <code>ntTMatrix</code> which really contain pairs, not
triplets) or in compressed column-oriented form (class
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, subclasses <code>ngCMatrix</code>,
<code>nsCMatrix</code>, and <code>ntCMatrix</code>) or&ndash;<em>rarely</em>&ndash;in
compressed row-oriented form (class <code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>,
subclasses <code>ngRMatrix</code>, <code>nsRMatrix</code>, and <code>ntRMatrix</code>).
The second letter in the name of these non-virtual classes indicates
<code>g</code>eneral, <code>s</code>ymmetric, or <code>t</code>riangular.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ngCMatrix",
    ...)</code> and so on.  More frequently objects are created by coercion of
a numeric sparse matrix to the pattern form for use in
the symbolic analysis phase
of an algorithm involving sparse matrices.  Such algorithms often
involve two phases: a symbolic phase wherein the positions of the
non-zeros in the result are determined and a numeric phase wherein the
actual results are calculated.  During the symbolic phase only the
positions of the non-zero elements in any operands are of interest,
hence numeric sparse matrices can be treated as sparse pattern
matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower
triangular. Present in the triangular and symmetric classes but not
in the general class.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code> for non-unit.  The implicit diagonal elements are not
explicitly stored when <code>diag</code> is <code>"U"</code>.  Present in the
triangular classes only.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each column (row), to the initial (zero-based) index of elements in
the column.  Present in compressed column-oriented and compressed
row-oriented forms only.</p>
</dd>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the row numbers for
each TRUE element in the matrix.  All other elements are FALSE.
Present in triplet and compressed column-oriented forms only.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length nnzero
(number of non-zero elements).  These are the column numbers for
each TRUE element in the matrix.  All other elements are FALSE.
Present in triplet and compressed row-oriented forms only.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "dgCMatrix", to =
	"ngCMatrix")</code>, and many similar ones; typically you should
coerce to <code>"nsparseMatrix"</code> (or <code>"nMatrix"</code>).  Note that
coercion to a sparse pattern matrix records all the potential
non-zero entries, i.e., explicit (&ldquo;non-structural&rdquo;) zeroes
are coerced to <code>TRUE</code>, not <code>FALSE</code>, see the example.
</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "ngCMatrix")</code>: returns the transpose
of <code>x</code></p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "lsparseMatrix")</code>, semantically
equivalent to <span class="pkg">base</span> function <code><a href="base.html#topic+which">which</a>(x, arr.ind)</code>;
for details, see the <code><a href="#topic+lMatrix-class">lMatrix</a></code> class documentation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>the class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m &lt;- Matrix(c(0,0,2:0), 3,5, dimnames=list(LETTERS[1:3],NULL)))
## ``extract the nonzero-pattern of (m) into an nMatrix'':
nm &lt;- as(m, "nsparseMatrix") ## -&gt; will be a "ngCMatrix"
str(nm) # no 'x' slot
nnm &lt;- !nm # no longer sparse
## consistency check:
stopifnot(xor(as( nm, "matrix"),
              as(nnm, "matrix")))

## low-level way of adding "non-structural zeros" :
nnm &lt;- as(nnm, "lsparseMatrix") # "lgCMatrix"
nnm@x[2:4] &lt;- c(FALSE, NA, NA)
nnm
as(nnm, "nMatrix") # NAs *and* non-structural 0  |---&gt;  'TRUE'

data(KNex, package = "Matrix")
nmm &lt;- as(KNex $ mm, "nMatrix")
str(xlx &lt;- crossprod(nmm))# "nsCMatrix"
stopifnot(isSymmetric(xlx))
image(xlx, main=paste("crossprod(nmm) : Sparse", class(xlx)))
</code></pre>

<hr>
<h2 id='nsyMatrix-class'>Symmetric Dense Nonzero-Pattern Matrices</h2><span id='topic+nsyMatrix-class'></span><span id='topic+nspMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"nsyMatrix"</code> class is the class of symmetric, dense nonzero-pattern
matrices in non-packed storage and <code>"nspMatrix"</code> is the class of
of these in packed storage.  Only the upper triangle or the
lower triangle is stored.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("nsyMatrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p><code>"nsyMatrix"</code> extends class <code>"ngeMatrix"</code>, directly, whereas<br />
<code>"nspMatrix"</code> extends class <code>"ndenseMatrix"</code>, directly.
</p>
<p>Both extend class <code>"symmetricMatrix"</code>, directly,
and class <code>"Matrix"</code> and others, <em>in</em>directly, use
<code><a href="methods.html#topic+showClass">showClass</a>("nsyMatrix")</code>, e.g., for details.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>; use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="nsyMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngeMatrix-class">ngeMatrix</a></code>, <code><a href="#topic+Matrix-class">Matrix</a></code>,
<code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(s0 &lt;- new("nsyMatrix"))

(M2 &lt;- Matrix(c(TRUE, NA, FALSE, FALSE), 2, 2)) # logical dense (ltr)
(sM &lt;- M2 &amp; t(M2))                       # -&gt; "lge"
class(sM &lt;- as(sM, "nMatrix"))           # -&gt; "nge"
     (sM &lt;- as(sM, "symmetricMatrix"))   # -&gt; "nsy"
str(sM &lt;- as(sM, "packedMatrix")) # -&gt; "nsp", i.e., packed symmetric
</code></pre>

<hr>
<h2 id='ntrMatrix-class'>Triangular Dense Logical Matrices</h2><span id='topic+ntrMatrix-class'></span><span id='topic+ntpMatrix-class'></span>

<h3>Description</h3>

<p>The <code>"ntrMatrix"</code> class is the class of triangular, dense,
logical matrices in nonpacked storage.  The <code>"ntpMatrix"</code> class
is the same except in packed storage.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"logical"</code>. The logical
values that constitute the matrix, stored in column-major order.</p>
</dd>
<dt><code>uplo</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>Object of class <code>"character"</code>. Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code>; see <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>), see the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</dd>
<dt><code>factors</code>:</dt><dd><p>Object of class <code>"list"</code>.  A named
list of factorizations that have been computed for the matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p><code>"ntrMatrix"</code> extends class <code>"ngeMatrix"</code>, directly, whereas<br />
<code>"ntpMatrix"</code> extends class <code>"ndenseMatrix"</code>, directly.
</p>
<p>Both extend Class <code>"triangularMatrix"</code>, directly,
and class <code>"denseMatrix"</code>, <code>"lMatrix"</code> and others,
<em>in</em>directly, use <code><a href="methods.html#topic+showClass">showClass</a>("nsyMatrix")</code>, e.g., for
details.
</p>


<h3>Methods</h3>

<p>Currently, mainly <code><a href="base.html#topic+t">t</a>()</code> and coercion methods (for
<code><a href="methods.html#topic+as">as</a>(.)</code>; use, e.g.,
<code><a href="methods.html#topic+showMethods">showMethods</a>(class="ntrMatrix")</code> for details.
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+ngeMatrix-class">ngeMatrix</a></code>, <code><a href="#topic+Matrix-class">Matrix</a></code>;
function <code><a href="base.html#topic+t">t</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("ntrMatrix")

str(new("ntpMatrix"))
(nutr &lt;- as(upper.tri(matrix(, 4, 4)), "ndenseMatrix"))
str(nutp &lt;- pack(nutr)) # packed matrix: only 10 = 4*(4+1)/2 entries
!nutp # the logical negation (is *not* logical triangular !)
## but this one is:
stopifnot(all.equal(nutp, pack(!!nutp)))
</code></pre>

<hr>
<h2 id='pack-methods'>Representation of Packed and Unpacked Dense Matrices</h2><span id='topic+pack'></span><span id='topic+pack-methods'></span><span id='topic+unpack'></span><span id='topic+unpack-methods'></span><span id='topic+pack+2CdgeMatrix-method'></span><span id='topic+pack+2ClgeMatrix-method'></span><span id='topic+pack+2Cmatrix-method'></span><span id='topic+pack+2CngeMatrix-method'></span><span id='topic+pack+2CpackedMatrix-method'></span><span id='topic+pack+2CsparseMatrix-method'></span><span id='topic+pack+2CunpackedMatrix-method'></span><span id='topic+unpack+2Cmatrix-method'></span><span id='topic+unpack+2CpackedMatrix-method'></span><span id='topic+unpack+2CsparseMatrix-method'></span><span id='topic+unpack+2CunpackedMatrix-method'></span>

<h3>Description</h3>

<p><code>pack()</code> coerces dense symmetric and dense triangular matrices
from unpacked format (storing the full matrix) to packed format
(storing only one of the upper and lower triangles).  <code>unpack()</code>
performs the reverse coercion. The two formats are formalized
by the virtual classes <code>"<a href="#topic+packedMatrix-class">packedMatrix</a>"</code> and
<code>"<a href="#topic+unpackedMatrix-class">unpackedMatrix</a>"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(x, ...)
## S4 method for signature 'dgeMatrix'
pack(x, symmetric = NA, upperTri = NA, ...)
## S4 method for signature 'lgeMatrix'
pack(x, symmetric = NA, upperTri = NA, ...)
## S4 method for signature 'ngeMatrix'
pack(x, symmetric = NA, upperTri = NA, ...)
## S4 method for signature 'matrix'
pack(x, symmetric = NA, upperTri = NA, ...)

unpack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack-methods_+3A_x">x</code></td>
<td>
<p>A dense symmetric or dense triangular matrix.
</p>

<dl>
<dt>For <code>pack()</code>:</dt><dd><p>typically an <code>"unpackedMatrix"</code>
or a standard <code>"matrix"</code>, though <code>"packedMatrix"</code>
are allowed and returned unchanged.</p>
</dd>
<dt>For <code>unpack()</code>:</dt><dd><p>typically a <code>"packedMatrix"</code>,
though <code>"unpackedMatrix"</code> are allowed and returned unchanged.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="pack-methods_+3A_symmetric">symmetric</code></td>
<td>
<p>logical (including <code>NA</code>) optionally
indicating whether <code>x</code> is symmetric (or triangular).</p>
</td></tr>
<tr><td><code id="pack-methods_+3A_uppertri">upperTri</code></td>
<td>
<p>(for triangular <code>x</code> only) logical
(including <code>NA</code>) indicating whether <code>x</code> is
upper (or lower) triangular.</p>
</td></tr>
<tr><td><code id="pack-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pack(x)</code> checks matrices <code>x</code> <em>not</em> inheriting from
one of the virtual classes <code>"<a href="#topic+symmetricMatrix-class">symmetricMatrix</a>"</code>
<code>"<a href="#topic+triangularMatrix-class">triangularMatrix</a>"</code> for symmetry
(via <code><a href="#topic+isSymmetric-methods">isSymmetric</a>()</code>)
then for upper and lower triangularity
(via <code><a href="#topic+isTriangular">isTriangular</a>()</code>) in order to identify a suitable
coercion.  Setting one or both of <code>symmetric</code> and <code>upperTri</code>
to <code>TRUE</code> or <code>FALSE</code> rather than <code>NA</code> allows skipping
of irrelevant tests for large matrices known to be symmetric or
(upper or lower) triangular.
</p>
<p>Users should <em>not</em> assume that <code>pack()</code> and <code>unpack()</code>
are inverse operations.  Specifically, <code>y &lt;- unpack(pack(x))</code>
may not reproduce an <code>"unpackedMatrix"</code> <code>x</code> in the sense of
<code><a href="base.html#topic+identical">identical</a>()</code>.  See the examples.
</p>


<h3>Value</h3>


<dl>
<dt>For <code>pack()</code>:</dt><dd><p>a <code>"packedMatrix"</code> giving
the condensed representation of <code>x</code>.</p>
</dd>
<dt>For <code>unpack()</code>:</dt><dd><p>an <code>"unpackedMatrix"</code> giving
the full storage representation of <code>x</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("pack")
(s &lt;- crossprod(matrix(sample(15), 5,3))) # traditional symmetric matrix
(sp &lt;- pack(s))
mt &lt;- as.matrix(tt &lt;- tril(s))
(pt &lt;- pack(mt))
stopifnot(identical(pt, pack(tt)),
	  dim(s ) == dim(sp), all(s  == sp),
	  dim(mt) == dim(pt), all(mt == pt), all(mt == tt))

showMethods("unpack")
(cp4 &lt;- chol(Hilbert(4))) # is triangular
tp4 &lt;- pack(cp4) # [t]riangular [p]acked
str(tp4)
(unpack(tp4))
stopifnot(identical(tp4, pack(unpack(tp4))))

z1 &lt;- new("dsyMatrix", Dim = c(2L, 2L), x = as.double(1:4), uplo = "U")
z2 &lt;- unpack(pack(z1))
stopifnot(!identical(z1, z2), # _not_ identical
          all(z1 == z2)) # but mathematically equal
cbind(z1@x, z2@x) # (unused!) lower triangle is "lost" in translation
</code></pre>

<hr>
<h2 id='packedMatrix-class'>Virtual Class <code>"packedMatrix"</code> of Packed Dense Matrices</h2><span id='topic+packedMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CpackedMatrix-method'></span><span id='topic+cov2cor+2CpackedMatrix-method'></span>

<h3>Description</h3>

<p>Class <code>"packedMatrix"</code> is the <em>virtual</em> class of dense
symmetric or triangular matrices in &quot;packed&quot; format, storing only
the <code>choose(n+1,2) == n*(n+1)/2</code> elements of the upper or
lower triangle of an <code>n</code>-by-<code>n</code> matrix. It is used to
define common methods for efficient subsetting, transposing, etc.
of its <em>proper</em> subclasses: currently <code>"[dln]spMatrix"</code>
(packed symmetric), <code>"[dln]tpMatrix"</code> (packed triangular),
and subclasses of these, such as
<code>"<a href="#topic+dppMatrix-class">dppMatrix</a>"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p><code>"character"</code>; either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower.</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>as all <code><a href="#topic+Matrix-class">Matrix</a></code> objects.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+denseMatrix-class">denseMatrix</a>"</code>, directly.
Class <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>, by class <code>"denseMatrix"</code>,
distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>pack</dt><dd><p><code>signature(x = "packedMatrix")</code>: ... </p>
</dd>
<dt>unpack</dt><dd><p><code>signature(x = "packedMatrix")</code>: ... </p>
</dd>
<dt>isSymmetric</dt><dd><p><code>signature(object = "packedMatrix")</code>: ... </p>
</dd>
<dt>isTriangular</dt><dd><p><code>signature(object = "packedMatrix")</code>: ... </p>
</dd>
<dt>isDiagonal</dt><dd><p><code>signature(object = "packedMatrix")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "packedMatrix")</code>: ... </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "packedMatrix")</code>: ... </p>
</dd>
<dt>diag&lt;-</dt><dd><p><code>signature(x = "packedMatrix")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Mikael Jagan</p>


<h3>See Also</h3>

<p><code><a href="#topic+pack">pack</a></code> and <code><a href="#topic+unpack">unpack</a></code>; its virtual &quot;complement&quot;
<code>"<a href="#topic+unpackedMatrix-class">unpackedMatrix</a>"</code>; its proper subclasses
<code>"<a href="#topic+dspMatrix-class">dspMatrix</a>"</code>, <code>"<a href="#topic+ltpMatrix-class">ltpMatrix</a>"</code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("packedMatrix")
showMethods(classes = "packedMatrix")
</code></pre>

<hr>
<h2 id='pMatrix-class'>Permutation matrices</h2><span id='topic+pMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CpMatrix-method'></span><span id='topic+coerce+2Cnumeric+2CpMatrix-method'></span><span id='topic+determinant+2CpMatrix+2Clogical-method'></span><span id='topic+t+2CpMatrix-method'></span>

<h3>Description</h3>

<p>The <code>pMatrix</code> class is the class of <em>permutation</em> matrices,
stored as 1-based integer permutation vectors.  A permutation
matrix is a square matrix whose rows <em>and</em> columns are all
standard unit vectors.  It follows that permutation matrices are
a special case of <em>index</em> matrices (hence <code>pMatrix</code>
is defined as a direct subclass of <code><a href="#topic+indMatrix-class">indMatrix</a></code>).
</p>
<p>Multiplying a matrix on the left by a permutation matrix is
equivalent to permuting its rows.  Analogously, multiplying a
matrix on the right by a permutation matrix is equivalent to
permuting its columns.  Indeed, such products are implemented in
<span class="pkg">Matrix</span> as indexing operations; see &lsquo;Details&rsquo; below.
</p>


<h3>Details</h3>

<p>By definition, a permutation matrix is both a row index matrix
and a column index matrix.  However, the <code>perm</code> slot of
a <code>pMatrix</code> cannot be used interchangeably as a row index
vector and column index vector.  If <code>margin=1</code>, then
<code>perm</code> is a row index vector, and the corresponding column
index vector can be computed as <code><a href="#topic+invPerm">invPerm</a>(perm)</code>, i.e.,
by inverting the permutation.  Analogously, if <code>margin=2</code>,
then <code>perm</code> and <code>invPerm(perm)</code> are column and row
index vectors, respectively.
</p>
<p>Given an <code>n</code>-by-<code>n</code> row permutation matrix <code>P</code>
with <code>perm</code> slot <code>p</code> and a matrix <code>M</code> with
conformable dimensions, we have
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code class="reqn">P M</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>P %*% M</code>        </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[p, ]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">M P</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M %*% P</code>        </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[, i(p)]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">P'M</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>crossprod(P, M)</code>  </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[i(p), ]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">MP'</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>tcrossprod(M, P)</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>M[, p]</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">P'P</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>crossprod(P)</code>     </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>Diagonal(n)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code class="reqn">PP'</code> </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>tcrossprod(P)</code>    </td><td style="text-align: center;"> = </td><td style="text-align: left;"> <code>Diagonal(n)</code>
  </td>
</tr>

</table>

<p>where <code>i := invPerm</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created explicitly with calls of the form
<code>new("pMatrix", ...)</code>, but they are more commonly created
by coercing 1-based integer index vectors, with calls of the
form <code>as(., "pMatrix")</code>; see &lsquo;Methods&rsquo; below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>margin</code>,<code>perm</code></dt><dd><p>inherited from superclass
<code><a href="#topic+indMatrix-class">indMatrix</a></code>.  Here, <code>perm</code> is an
integer vector of length <code>Dim[1]</code> and a permutation
of <code>1:Dim[1]</code>.</p>
</dd>
<dt><code>Dim</code>,<code>Dimnames</code></dt><dd><p>inherited from virtual
superclass <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+indMatrix-class">indMatrix</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt><code>%*%</code></dt><dd><p><code>signature(x = "pMatrix", y = "Matrix")</code>
and others listed by <code>showMethods("%*%", classes = "pMatrix")</code>:
matrix products implemented where appropriate as indexing operations.</p>
</dd>
<dt><code>coerce</code></dt><dd><p><code>signature(from = "numeric", to = "pMatrix")</code>:
supporting typical <code>pMatrix</code> construction from a vector
of positive integers, specifically a permutation of <code>1:n</code>.
Row permutation is assumed.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "pMatrix")</code>:
the transpose, which is a <code>pMatrix</code> with identical
<code>perm</code> but opposite <code>margin</code>.  Coincides with
the inverse, as permutation matrices are orthogonal.</p>
</dd>
<dt>solve</dt><dd><p><code>signature(a = "pMatrix", b = "missing")</code>:
the inverse permutation matrix, which is a <code>pMatrix</code>
with identical <code>perm</code> but opposite <code>margin</code>.
Coincides with the transpose, as permutation matrices are
orthogonal.  See <code>showMethods("solve", classes = "pMatrix")</code>
for more signatures.</p>
</dd>
<dt>determinant</dt><dd><p><code>signature(x = "pMatrix", logarithm = "logical")</code>:
always returning 1 or -1, as permutation matrices are orthogonal.  
In fact, the result is exactly the <em>sign</em> of the permutation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Superclass <code><a href="#topic+indMatrix-class">indMatrix</a></code> of index matrices,
for many inherited methods; <code><a href="#topic+invPerm">invPerm</a></code>, for computing
inverse permutation vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(pm1 &lt;- as(as.integer(c(2,3,1)), "pMatrix"))
t(pm1) # is the same as
solve(pm1)
pm1 %*% t(pm1) # check that the transpose is the inverse
stopifnot(all(diag(3) == as(pm1 %*% t(pm1), "matrix")),
          is.logical(as(pm1, "matrix")))

set.seed(11)
## random permutation matrix :
(p10 &lt;- as(sample(10),"pMatrix"))

## Permute rows / columns of a numeric matrix :
(mm &lt;- round(array(rnorm(3 * 3), c(3, 3)), 2))
mm %*% pm1
pm1 %*% mm
try(as(as.integer(c(3,3,1)), "pMatrix"))# Error: not a permutation

as(pm1, "TsparseMatrix")
p10[1:7, 1:4] # gives an "ngTMatrix" (most economic!)

## row-indexing of a &lt;pMatrix&gt; keeps it as an &lt;indMatrix&gt;:
p10[1:3, ]
</code></pre>

<hr>
<h2 id='printSpMatrix'>Format and Print Sparse Matrices Flexibly</h2><span id='topic+formatSpMatrix'></span><span id='topic+printSpMatrix'></span><span id='topic+printSpMatrix2'></span>

<h3>Description</h3>

<p>Format and print sparse matrices flexibly.  These are the &ldquo;workhorses&rdquo; used by
the <code><a href="base.html#topic+format">format</a></code>, <code><a href="methods.html#topic+show">show</a></code> and <code><a href="base.html#topic+print">print</a></code>
methods for sparse matrices.  If <code>x</code> is large,
<code>printSpMatrix2(x)</code> calls <code>printSpMatrix()</code> twice, namely,
for the first and the last few rows, suppressing those in between, and
also suppresses columns when <code>x</code> is too wide.
</p>
<p><code>printSpMatrix()</code> basically prints the result of
<code>formatSpMatrix()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatSpMatrix(x, digits = NULL, maxp = 1e9,
               cld = getClassDef(class(x)), zero.print = ".",
               col.names, note.dropping.colnames = TRUE, uniDiag = TRUE,
               align = c("fancy", "right"), ...)

printSpMatrix(x, digits = NULL, maxp = max(100L, getOption("max.print")),
              cld = getClassDef(class(x)),
              zero.print = ".", col.names, note.dropping.colnames = TRUE,
              uniDiag = TRUE, col.trailer = "",
              align = c("fancy", "right"), ...)

printSpMatrix2(x, digits = NULL, maxp = max(100L, getOption("max.print")),
              zero.print = ".", col.names, note.dropping.colnames = TRUE,
              uniDiag = TRUE, suppRows = NULL, suppCols = NULL,
              col.trailer = if(suppCols) "......" else "",
              align = c("fancy", "right"),
              width = getOption("width"), fitWidth = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printSpMatrix_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_digits">digits</code></td>
<td>
<p>significant digits to use for printing, see
<code><a href="base.html#topic+print.default">print.default</a></code>, the default, <code><a href="base.html#topic+NULL">NULL</a></code>,
corresponds to using <code><a href="base.html#topic+getOption">getOption</a>("digits")</code>.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_maxp">maxp</code></td>
<td>
<p>integer, default from <code><a href="base.html#topic+options">options</a>(max.print)</code>,
influences how many entries of large matrices are printed at all.
Typically should not be smaller than around 1000; values smaller than
100 are silently &ldquo;rounded up&rdquo; to 100.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_cld">cld</code></td>
<td>
<p>the class definition of <code>x</code>; must be equivalent to
<code><a href="methods.html#topic+getClassDef">getClassDef</a>(class(x))</code> and exists mainly for possible
speedup.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_zero.print">zero.print</code></td>
<td>
<p>character which should be printed for
<em>structural</em> zeroes.  The default <code>"."</code> may occasionally
be replaced by <code>" "</code> (blank); using <code>"0"</code> would look
almost like <code>print()</code>ing of non-sparse matrices.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_col.names">col.names</code></td>
<td>
<p>logical or string specifying if and how column names of
<code>x</code> should be printed, possibly abbreviated.  The default is
taken from <code><a href="base.html#topic+options">options</a>("sparse.colnames")</code> if that is set, otherwise
<code>FALSE</code> unless there are less than ten columns.  When
<code>TRUE</code> the full column names are printed.<br />
When <code>col.names</code> is a string beginning with <code>"abb"</code> or
<code>"sub"</code> and ending with an integer <code>n</code> (i.e., of the form
<code>"abb... &lt;n&gt;"</code>),
the column names are <code><a href="base.html#topic+abbreviate">abbreviate</a>()</code>d or
<code><a href="base.html#topic+substring">substring</a>()</code>ed to (target) length <code>n</code>, see the examples.
</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_note.dropping.colnames">note.dropping.colnames</code></td>
<td>
<p>logical specifying, when
<code>col.names</code> is <code>FALSE</code> if the dropping of the column names
should be noted, <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_unidiag">uniDiag</code></td>
<td>
<p>logical indicating if the diagonal entries of a sparse
unit triangular or unit-diagonal matrix should be formatted as
<code>"I"</code> instead of <code>"1"</code> (to emphasize that the 1's are
&ldquo;structural&rdquo;).</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_col.trailer">col.trailer</code></td>
<td>
<p>a string to be appended to the right of each
column; this is typically made use of by <code><a href="methods.html#topic+show">show</a>(&lt;sparseMatrix&gt;)</code>
only, when suppressing columns.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_supprows">suppRows</code>, <code id="printSpMatrix_+3A_suppcols">suppCols</code></td>
<td>
<p>logicals or <code>NULL</code>, for
<code>printSpMatrix2()</code> specifying if rows or columns should be
suppressed in printing.  If <code>NULL</code>, sensible defaults are
determined from <code><a href="base.html#topic+dim">dim</a>(x)</code> and
<code><a href="base.html#topic+options">options</a>(c("width", "max.print"))</code>.
Setting both to <code>FALSE</code> may be a very bad idea.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_align">align</code></td>
<td>
<p>a string specifying how the <code>zero.print</code> codes
should be aligned, i.e., padded as strings.  The default,
<code>"fancy"</code>, takes some effort to align the typical
<code>zero.print = "."</code> with the position of <code>0</code>, i.e., the
first decimal (one left of decimal point) of the numbers printed,
whereas <code>align = "right"</code> just makes use of
<code><a href="base.html#topic+print">print</a>(*, right = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_width">width</code></td>
<td>
<p>number, a positive integer, indicating the approximately
desired (line) width of the output, see also <code>fitWidth</code>.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_fitwidth">fitWidth</code></td>
<td>
<p>logical indicating if some effort should be made to
match the desired <code>width</code> or temporarily enlarge that if deemed
necessary.</p>
</td></tr>
<tr><td><code id="printSpMatrix_+3A_...">...</code></td>
<td>
<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>formatSpMatrix:</dt><dd>
<p>If <code>x</code> is large, only the first rows making up the
approximately first <code>maxp</code> entries is used, otherwise all of <code>x</code>.
<code><a href="#topic+.formatSparseSimple">.formatSparseSimple</a>()</code> is applied to (a dense version
of) the matrix.  Then, <code><a href="#topic+formatSparseM">formatSparseM</a></code> is used, unless
in trivial cases or for sparse matrices without <code>x</code> slot.</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>formatSpMatrix()</code></td>
<td>
<p>returns a character matrix with possibly empty
column names, depending on <code>col.names</code> etc, see above.</p>
</td></tr>
<tr><td><code>printSpMatrix*()</code></td>
<td>
<p>return <code>x</code> <em>invisibly</em>, see <code><a href="base.html#topic+invisible">invisible</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>the virtual class <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> and the
classes extending it;  maybe <code><a href="#topic+sparseMatrix">sparseMatrix</a></code> or
<code><a href="#topic+spMatrix">spMatrix</a></code> as simple constructors of such matrices.
</p>
<p>The underlying utilities <code><a href="#topic+formatSparseM">formatSparseM</a></code> and
<code>.formatSparseSimple()</code> (on the same page).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- gl(5, 3, labels = LETTERS[1:5])
X &lt;- as(f1, "sparseMatrix")
X ## &lt;==&gt;  show(X)  &lt;==&gt;  print(X)
t(X) ## shows column names, since only 5 columns

X2 &lt;- as(gl(12, 3, labels = paste(LETTERS[1:12],"c",sep=".")),
         "sparseMatrix")
X2
## less nice, but possible:
print(X2, col.names = TRUE) # use [,1] [,2] .. =&gt; does not fit

## Possibilities with column names printing:
      t(X2) # suppressing column names
print(t(X2), col.names=TRUE)
print(t(X2), zero.print = "", col.names="abbr. 1")
print(t(X2), zero.print = "-", col.names="substring 2")


</code></pre>

<hr>
<h2 id='qr-methods'>Methods for QR Factorization</h2><span id='topic+qr'></span><span id='topic+qr-methods'></span><span id='topic+qr+2CdgCMatrix-method'></span><span id='topic+qr+2CsparseMatrix-method'></span>

<h3>Description</h3>

<p>Computes the pivoted QR factorization of an <code class="reqn">m \times n</code>
real matrix <code class="reqn">A</code>, which has the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{2} = Q R</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' Q R P_{2}'</code>
</p>

<p>where
<code class="reqn">P_{1}</code> and <code class="reqn">P_{2}</code> are permutation matrices,
<code class="reqn">Q = \prod_{j = 1}^{n} H_{j}</code>
is an <code class="reqn">m \times m</code> orthogonal matrix
equal to the product of <code class="reqn">n</code> Householder matrices <code class="reqn">H_{j}</code>, and
<code class="reqn">R</code> is an <code class="reqn">m \times n</code> upper trapezoidal matrix.
</p>
<p><code><a href="#topic+denseMatrix-class">denseMatrix</a></code> use the default method implemented
in <span class="pkg">base</span>, namely <code><a href="base.html#topic+qr.default">qr.default</a></code>.  It is built on
LINPACK routine <code>dqrdc</code> and LAPACK routine <code>dgeqp3</code>, which
do not pivot rows, so that <code class="reqn">P_{1}</code> is an identity matrix.
</p>
<p>Methods for <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> are built on
CXSparse routines <code>cs_sqr</code> and <code>cs_qr</code>, which require
<code class="reqn">m \ge n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qr(x, ...)
## S4 method for signature 'dgCMatrix'
qr(x, order = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qr-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> to be factorized,
satisfying <code>nrow(x) &gt;= ncol(x)</code> if sparse.</p>
</td></tr>
<tr><td><code id="qr-methods_+3A_order">order</code></td>
<td>
<p>an integer in <code>0:3</code> passed to CXSparse routine
<code>cs_sqr</code>, indicating a strategy for choosing the column
permutation <code class="reqn">P_{2}</code>.  0 means no column permutation.
1, 2, and 3 indicate a fill-reducing ordering of <code class="reqn">A + A'</code>,
<code class="reqn">\tilde{A}' \tilde{A}</code>, and <code class="reqn">A' A</code>,
where <code class="reqn">\tilde{A}</code> is <code class="reqn">A</code> with &ldquo;dense&rdquo; rows
removed.
Do not set to 0 unless you know that the column order of <code class="reqn">A</code>
is already sensible.</p>
</td></tr>
<tr><td><code id="qr-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is sparse and structurally rank deficient, having
structural rank <code class="reqn">r &lt; n</code>, then <code>x</code> is augmented with
<code class="reqn">(n-r)</code> rows of (partly non-structural) zeros, such that
the augmented matrix has structural rank <code class="reqn">n</code>.
This augmented matrix is factorized as described above:
</p>
<p style="text-align: center;"><code class="reqn">P_1 A P_2 = P_1 \begin{bmatrix} A_{0} \\ 0 \end{bmatrix} P_2 = Q R</code>
</p>

<p>where <code class="reqn">A_0</code> denotes the original, user-supplied
<code class="reqn">(m-(n-r)) \times n</code> matrix.
</p>


<h3>Value</h3>

<p>An object representing the factorization, inheriting from
virtual S4 class <code><a href="#topic+QR-class">QR</a></code> or S3 class
<code><a href="base.html#topic+qr">qr</a></code>.  The specific class is <code>qr</code>
unless <code>x</code> inherits from virtual class
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, in which case it is
<code><a href="#topic+sparseQR-class">sparseQR</a></code>.
</p>


<h3>References</h3>

<p>Davis, T. A. (2006).
<em>Direct methods for sparse linear systems</em>.
Society for Industrial and Applied Mathematics.
<a href="https://doi.org/10.1137/1.9780898718881">doi:10.1137/1.9780898718881</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+sparseQR-class">sparseQR</a></code> and its methods.
</p>
<p>Class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>
<p>Generic function <code><a href="base.html#topic+qr">qr</a></code> from <span class="pkg">base</span>,
whose default method <code>qr.default</code> &ldquo;defines&rdquo;
the S3 class <code>qr</code> of dense QR factorizations.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>,
for constructing matrix factors from the result.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+Schur">Schur</a></code>, and <code><a href="#topic+lu">lu</a></code>,
for computing other factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods("qr", inherited = FALSE)

## Rank deficient: columns 3 {b2} and 6 {c3} are "extra"
M &lt;- as(cbind(a1 = 1,
              b1 = rep(c(1, 0), each = 3L),
              b2 = rep(c(0, 1), each = 3L),
              c1 = rep(c(1, 0, 0), 2L),
              c2 = rep(c(0, 1, 0), 2L),
              c3 = rep(c(0, 0, 1), 2L)),
        "CsparseMatrix")
rownames(M) &lt;- paste0("r", seq_len(nrow(M)))
b &lt;- 1:6
eps &lt;- .Machine$double.eps

## .... [1] full rank ..................................................
## ===&gt; a least squares solution of A x = b exists
##      and is unique _in exact arithmetic_

(A1 &lt;- M[, -c(3L, 6L)])
(qr.A1 &lt;- qr(A1))

stopifnot(exprs = {
    rankMatrix(A1) == ncol(A1)
    { d1 &lt;- abs(diag(qr.A1@R)); sum(d1 &lt; max(d1) * eps) == 0L }
    rcond(crossprod(A1)) &gt;= eps
    all.equal(qr.coef(qr.A1, b), drop(solve(crossprod(A1), crossprod(A1, b))))
    all.equal(qr.fitted(qr.A1, b) + qr.resid(qr.A1, b), b)
})

## .... [2] numerically rank deficient with full structural rank .......
## ===&gt; a least squares solution of A x = b does not
##      exist or is not unique _in exact arithmetic_

(A2 &lt;- M)
(qr.A2 &lt;- qr(A2))

stopifnot(exprs = {
    rankMatrix(A2) == ncol(A2) - 2L
    { d2 &lt;- abs(diag(qr.A2@R)); sum(d2 &lt; max(d2) * eps) == 2L }
    rcond(crossprod(A2)) &lt; eps

    ## 'qr.coef' computes unique least squares solution of "nearby" problem
    ## Z x = b for some full rank Z ~ A, currently without warning {FIXME} !
    tryCatch({ qr.coef(qr.A2, b); TRUE }, condition = function(x) FALSE)

    all.equal(qr.fitted(qr.A2, b) + qr.resid(qr.A2, b), b)
})

## .... [3] numerically and structurally rank deficient ................
## ===&gt; factorization of _augmented_ matrix with
##      full structural rank proceeds as in [2]

##  NB: implementation details are subject to change; see (*) below

A3 &lt;- M
A3[, c(3L, 6L)] &lt;- 0
A3
(qr.A3 &lt;- qr(A3)) # with a warning ... "additional 2 row(s) of zeros"

stopifnot(exprs = {
    ## sparseQR object preserves the unaugmented dimensions (*)
    dim(qr.A3  ) == dim(A3)
    dim(qr.A3@V) == dim(A3) + c(2L, 0L)
    dim(qr.A3@R) == dim(A3) + c(2L, 0L)

    ## The augmented matrix remains numerically rank deficient
    rankMatrix(A3) == ncol(A3) - 2L
    { d3 &lt;- abs(diag(qr.A3@R)); sum(d3 &lt; max(d3) * eps) == 2L }
    rcond(crossprod(A3)) &lt; eps
})

## Auxiliary functions accept and return a vector or matrix
## with dimensions corresponding to the unaugmented matrix (*),
## in all cases with a warning
qr.coef  (qr.A3, b)
qr.fitted(qr.A3, b)
qr.resid (qr.A3, b)

## .... [4] yet more examples ..........................................

## By disabling column pivoting, one gets the "vanilla" factorization
## A = Q~ R, where Q~ := P1' Q is orthogonal because P1 and Q are

(qr.A1.pp &lt;- qr(A1, order = 0L)) # partial pivoting

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

stopifnot(exprs = {
    length(qr.A1   @q) == ncol(A1)
    length(qr.A1.pp@q) == 0L # indicating no column pivoting
    ae2(A1[, qr.A1@q + 1L], qr.Q(qr.A1   ) %*% qr.R(qr.A1   ))
    ae2(A1                , qr.Q(qr.A1.pp) %*% qr.R(qr.A1.pp))
})
</code></pre>

<hr>
<h2 id='rankMatrix'>Rank of a Matrix</h2><span id='topic+rankMatrix'></span><span id='topic+qr2rankMatrix'></span>

<h3>Description</h3>

<p>Compute &lsquo;the&rsquo; matrix rank, a well-defined functional in theory(*),
somewhat ambiguous in practice.  We provide several methods, the
default corresponding to Matlab's definition.
</p>
<p>(*) The rank of a <code class="reqn">n \times m</code> matrix <code class="reqn">A</code>, <code class="reqn">rk(A)</code>,
is the maximal number of linearly independent columns (or rows); hence
<code class="reqn">rk(A) \le min(n,m)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankMatrix(x, tol = NULL,
           method = c("tolNorm2", "qr.R", "qrLINPACK", "qr",
                      "useGrad", "maybeGrad"),
           sval = svd(x, 0, 0)$d, warn.t = TRUE, warn.qr = TRUE)

qr2rankMatrix(qr, tol = NULL, isBqr = is.qr(qr), do.warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankMatrix_+3A_x">x</code></td>
<td>
<p>numeric matrix, of dimension <code class="reqn">n \times m</code>, say.</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_tol">tol</code></td>
<td>
<p>nonnegative number specifying a (relative,
&ldquo;scalefree&rdquo;) tolerance for testing of
&ldquo;practically zero&rdquo; with specific meaning depending on
<code>method</code>; by default, <code>max(dim(x)) * <a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>
is according to Matlab's default (for its only method which is our
<code>method="tolNorm2"</code>).</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_method">method</code></td>
<td>
<p>a character string specifying the computational method
for the rank, can be abbreviated:
</p>

<dl>
<dt><code>"tolNorm2"</code>:</dt><dd><p>the number of singular values
<code>&gt;= tol * max(sval)</code>;</p>
</dd>
<dt><code>"qrLINPACK"</code>:</dt><dd><p>for a dense matrix, this is the rank of
<code><a href="base.html#topic+qr">qr</a>(x, tol, LAPACK=FALSE)</code> (which is
<code>qr(...)$rank</code>);
<br />
This (&quot;qr*&quot;, dense) version used to be <em>the</em> recommended way to
compute a matrix rank for a while in the past.
</p>
<p>For sparse <code>x</code>, this is equivalent to <code>"qr.R"</code>.
</p>
</dd>
<dt><code>"qr.R"</code>:</dt><dd><p>this is the rank of triangular matrix
<code class="reqn">R</code>, where <code>qr()</code> uses LAPACK or a &quot;sparseQR&quot; method
(see <code><a href="#topic+qr-methods">qr-methods</a></code>) to compute the decomposition
<code class="reqn">QR</code>.  The rank of <code class="reqn">R</code> is then defined as the number of
&ldquo;non-zero&rdquo; diagonal entries <code class="reqn">d_i</code> of <code class="reqn">R</code>, and
&ldquo;non-zero&rdquo;s fulfill
<code class="reqn">|d_i| \ge \mathrm{tol}\cdot\max(|d_i|)</code>.
</p>
</dd>
<dt><code>"qr"</code>:</dt><dd><p>is for back compatibility; for dense <code>x</code>,
it corresponds to <code>"qrLINPACK"</code>, whereas for sparse
<code>x</code>, it uses <code>"qr.R"</code>.
</p>
<p>For all the &quot;qr*&quot; methods, singular values <code>sval</code> are not
used, which may be crucially important for a large sparse matrix
<code>x</code>, as in that case, when <code>sval</code> is not specified,
the default, computing <code><a href="base.html#topic+svd">svd</a>()</code> currently coerces
<code>x</code> to a dense matrix.
</p>
</dd>
<dt><code>"useGrad"</code>:</dt><dd><p>considering the &ldquo;gradient&rdquo; of the
(decreasing) singular values, the index of the <em>smallest</em> gap.</p>
</dd>
<dt><code>"maybeGrad"</code>:</dt><dd><p>choosing method <code>"useGrad"</code> only when
that seems <em>reasonable</em>; otherwise using <code>"tolNorm2"</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="rankMatrix_+3A_sval">sval</code></td>
<td>
<p>numeric vector of non-increasing singular values of
<code>x</code>; typically unspecified and computed from <code>x</code> when
needed, i.e., unless <code>method = "qr"</code>.</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_warn.t">warn.t</code></td>
<td>
<p>logical indicating if <code>rankMatrix()</code> should warn
when it needs <code><a href="base.html#topic+t">t</a>(x)</code> instead of <code>x</code>.  Currently, for
<code>method = "qr"</code> only, gives a warning by default because the
caller often could have passed <code>t(x)</code> directly, more efficiently.</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_warn.qr">warn.qr</code></td>
<td>
<p>in the <code class="reqn">QR</code> cases (i.e., if <code>method</code> starts with
<code>"qr"</code>), <code>rankMatrix()</code> calls
<code>qr2rankMarix(.., do.warn = warn.qr)</code>, see below.</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_qr">qr</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object resulting from <code><a href="#topic+qr">qr</a>(x,..)</code>, i.e.,
typically inheriting from <code><a href="base.html#topic+class">class</a></code> <code>"<a href="#topic+qr">qr</a>"</code> or
<code>"<a href="#topic+sparseQR-class">sparseQR</a>"</code>.</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_isbqr">isBqr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if <code>qr</code> is resulting
from <span class="pkg">base</span> <code><a href="base.html#topic+qr">qr</a>()</code>.  (Otherwise, it is typically
from <span class="pkg">Matrix</span> package sparse <code><a href="#topic+qr">qr</a></code>.)</p>
</td></tr>
<tr><td><code id="rankMatrix_+3A_do.warn">do.warn</code></td>
<td>
<p>logical; if true, warn about non-finite diagonal
entries in the <code class="reqn">R</code> matrix of the <code class="reqn">QR</code> decomposition.
Do not change lightly!</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qr2rankMatrix()</code> is typically called from <code>rankMatrix()</code> for
the <code>"qr"</code>* <code>method</code>s, but can be used directly - much more
efficiently in case the <code>qr</code>-decomposition is available anyway.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a matrix of all <code>0</code> (or of zero dimension), the rank
is zero; otherwise, typically a positive integer in <code>1:min(dim(x))</code>
with attributes detailing the method used.
</p>
<p>There are rare cases where the sparse <code class="reqn">QR</code> decomposition
&ldquo;fails&rdquo; in so far as the diagonal entries of <code class="reqn">R</code>, the
<code class="reqn">d_i</code> (see above), end with non-finite, typically <code><a href="base.html#topic+NaN">NaN</a></code>
entries.  Then, a warning is signalled (unless <code>warn.qr</code> /
<code>do.warn</code> is not true) and <code>NA</code> (specifically,
<code><a href="base.html#topic+NA_integer_">NA_integer_</a></code>) is returned.
</p>


<h3>Note</h3>

<p>For large sparse matrices <code>x</code>, unless you can specify
<code>sval</code> yourself, currently <code>method = "qr"</code> may
be the only feasible one, as the others need <code>sval</code> and call
<code><a href="base.html#topic+svd">svd</a>()</code> which currently coerces <code>x</code> to a
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code> which may be very slow or impossible,
depending on the matrix dimensions.
</p>
<p>Note that in the case of sparse <code>x</code>, <code>method = "qr"</code>, all
non-strictly zero diagonal entries <code class="reqn">d_i</code> where counted, up to
including <span class="pkg">Matrix</span> version 1.1-0, i.e., that method implicitly
used <code>tol = 0</code>, see also the <code>set.seed(42)</code> example below.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler; for the &quot;*Grad&quot; methods building on
suggestions by Ravi Varadhan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qr">qr</a></code>, <code><a href="base.html#topic+svd">svd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rankMatrix(cbind(1, 0, 1:3)) # 2

(meths &lt;- eval(formals(rankMatrix)$method))

## a "border" case:
H12 &lt;- Hilbert(12)
rankMatrix(H12, tol = 1e-20) # 12;  but  11  with default method &amp; tol.
sapply(meths, function(.m.) rankMatrix(H12, method = .m.))
## tolNorm2   qr.R  qrLINPACK   qr  useGrad maybeGrad
##       11     11         12   12       11        11
## The meaning of 'tol' for method="qrLINPACK" and *dense* x is not entirely "scale free"
rMQL &lt;- function(ex, M) rankMatrix(M, method="qrLINPACK",tol = 10^-ex)
rMQR &lt;- function(ex, M) rankMatrix(M, method="qr.R",     tol = 10^-ex)
sapply(5:15, rMQL, M = H12) # result is platform dependent
##  7  7  8 10 10 11 11 11 12 12 12  {x86_64}
sapply(5:15, rMQL, M = 1000 * H12) # not identical unfortunately
##  7  7  8 10 11 11 12 12 12 12 12
sapply(5:15, rMQR, M = H12)
##  5  6  7  8  8  9  9 10 10 11 11
sapply(5:15, rMQR, M = 1000 * H12) # the *same*


## "sparse" case:
M15 &lt;- kronecker(diag(x=c(100,1,10)), Hilbert(5))
sapply(meths, function(.m.) rankMatrix(M15, method = .m.))
#--&gt; all 15, but 'useGrad' has 14.
sapply(meths, function(.m.) rankMatrix(M15, method = .m., tol = 1e-7)) # all 14

## "large" sparse
n &lt;- 250000; p &lt;- 33; nnz &lt;- 10000
L &lt;- sparseMatrix(i = sample.int(n, nnz, replace=TRUE),
                  j = sample.int(p, nnz, replace=TRUE),
                  x = rnorm(nnz))
(st1 &lt;- system.time(r1 &lt;- rankMatrix(L)))                # warning+ ~1.5 sec (2013)
(st2 &lt;- system.time(r2 &lt;- rankMatrix(L, method = "qr"))) # considerably faster!
r1[[1]] == print(r2[[1]]) ## --&gt;  ( 33  TRUE )

## another sparse-"qr" one, which ``failed'' till 2013-11-23:
set.seed(42)
f1 &lt;- factor(sample(50, 1000, replace=TRUE))
f2 &lt;- factor(sample(50, 1000, replace=TRUE))
f3 &lt;- factor(sample(50, 1000, replace=TRUE))
D &lt;- t(do.call(rbind, lapply(list(f1,f2,f3), as, 'sparseMatrix')))
dim(D); nnzero(D) ## 1000 x 150 // 3000 non-zeros (= 2%)
stopifnot(rankMatrix(D,           method='qr') == 148,
	  rankMatrix(crossprod(D),method='qr') == 148)

## zero matrix has rank 0 :
stopifnot(sapply(meths, function(.m.)
                        rankMatrix(matrix(0, 2, 2), method = .m.)) == 0)
</code></pre>

<hr>
<h2 id='rcond-methods'>Estimate the Reciprocal Condition Number</h2><span id='topic+rcond'></span><span id='topic+rcond-methods'></span><span id='topic+rcond+2CANY+2Cmissing-method'></span><span id='topic+rcond+2CdenseMatrix+2Ccharacter-method'></span><span id='topic+rcond+2CdiagonalMatrix+2Ccharacter-method'></span><span id='topic+rcond+2CindMatrix+2Ccharacter-method'></span><span id='topic+rcond+2CpMatrix+2Ccharacter-method'></span><span id='topic+rcond+2CsparseMatrix+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Estimate the reciprocal of the condition number of a matrix.
</p>
<p>This is a generic function with several methods, as seen by
<code><a href="methods.html#topic+showMethods">showMethods</a>(rcond)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcond(x, norm, ...)

## S4 method for signature 'sparseMatrix,character'
rcond(x, norm, useInv=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcond-methods_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object that inherits from the <code>Matrix</code> class.</p>
</td></tr>
<tr><td><code id="rcond-methods_+3A_norm">norm</code></td>
<td>
<p>character string indicating the type of norm to be used in
the estimate. The default is <code>"O"</code> for the 1-norm (<code>"O"</code> is
equivalent to <code>"1"</code>).  For sparse matrices, when <code>useInv=TRUE</code>,
<code>norm</code> can be any of the <code>kind</code>s allowed for <code><a href="#topic+norm">norm</a></code>;
otherwise, the other possible value is <code>"I"</code> for the infinity
norm, see also <code><a href="#topic+norm">norm</a></code>.
</p>
</td></tr>
<tr><td><code id="rcond-methods_+3A_useinv">useInv</code></td>
<td>
<p>logical (or <code>"Matrix"</code> containing
<code><a href="#topic+solve">solve</a>(x)</code>).  If not false, compute the reciprocal
condition number as <code class="reqn">1/(\|x\| \cdot \|x^{-1}\|)</code>,
where <code class="reqn">x^{-1}</code> is the inverse of <code class="reqn">x</code>, <code>solve(x)</code>.
</p>
<p>This may be an efficient alternative (only) in situations where
<code>solve(x)</code> is fast (or known), e.g., for (very) sparse or
triangular matrices.
</p>
<p>Note that the <em>result</em> may differ depending on <code>useInv</code>,
as per default, when it is false, an <em>approximation</em> is
computed.
</p>
</td></tr>
<tr><td><code id="rcond-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the reciprocal condition number of <code>x</code>.
</p>


<h3>BACKGROUND</h3>

<p>The condition number of a regular (square) matrix is the product of
the <code><a href="#topic+norm">norm</a></code> of the matrix and the norm of its inverse (or
pseudo-inverse).
</p>
<p>More generally, the condition number is defined (also for
non-square matrices <code class="reqn">A</code>) as
</p>
<p style="text-align: center;"><code class="reqn">\kappa(A) = \frac{\max_{\|v\| = 1} \|A v\|}{\min_{\|v\| = 1} \|A v\|}.</code>
</p>

<p>Whenever <code>x</code> is <em>not</em> a square matrix, in our method
definitions, this is typically computed via <code>rcond(qr.R(qr(X)), ...)</code>
where <code>X</code> is <code>x</code> or <code>t(x)</code>.
</p>
<p>The condition number takes on values between 1 and infinity,
inclusive, and can be viewed as a factor by which errors in solving
linear systems with this matrix as coefficient matrix could be
magnified.
</p>
<p><code>rcond()</code> computes the <em>reciprocal</em> condition number
<code class="reqn">1/\kappa</code> with values in <code class="reqn">[0,1]</code> and can be viewed as a
scaled measure of how close a matrix is to being rank deficient (aka
&ldquo;singular&rdquo;).
</p>
<p>Condition numbers are usually estimated, since exact computation is
costly in terms of floating-point operations.  An (over) estimate of
reciprocal condition number is given, since by doing so overflow is
avoided.  Matrices are well-conditioned if the reciprocal condition
number is near 1 and ill-conditioned if it is near zero.
</p>


<h3>References</h3>

<p>Golub, G., and Van Loan, C. F. (1989).
<em>Matrix Computations,</em>
2nd edition, Johns Hopkins, Baltimore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>, <code><a href="base.html#topic+kappa">kappa</a>()</code> from package
<span class="pkg">base</span> computes an <em>approximate</em> condition number of a
&ldquo;traditional&rdquo; matrix, even non-square ones, with respect to the
<code class="reqn">p=2</code> (Euclidean) <code><a href="#topic+norm">norm</a></code>.
<code><a href="base.html#topic+solve">solve</a></code>.
</p>
<p><code><a href="#topic+condest">condest</a></code>, a newer <em>approximate</em> estimate of
the (1-norm) condition number, particularly efficient for large sparse
matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- Matrix(rnorm(9), 3, 3)
rcond(x)
## typically "the same" (with more computational effort):
1 / (norm(x) * norm(solve(x)))
rcond(Hilbert(9))  # should be about 9.1e-13

## For non-square matrices:
rcond(x1 &lt;- cbind(1,1:10))# 0.05278
rcond(x2 &lt;- cbind(x1, 2:11))# practically 0, since x2 does not have full rank

## sparse
(S1 &lt;- Matrix(rbind(0:1,0, diag(3:-2))))
rcond(S1)
m1 &lt;- as(S1, "denseMatrix")
all.equal(rcond(S1), rcond(m1))

## wide and sparse
rcond(Matrix(cbind(0, diag(2:-1))))

## Large sparse example ----------
m &lt;- Matrix(c(3,0:2), 2,2)
M &lt;- bdiag(kronecker(Diagonal(2), m), kronecker(m,m))
36*(iM &lt;- solve(M)) # still sparse
MM &lt;- kronecker(Diagonal(10), kronecker(Diagonal(5),kronecker(m,M)))
dim(M3 &lt;- kronecker(bdiag(M,M),MM)) # 12'800 ^ 2
if(interactive()) ## takes about 2 seconds if you have &gt;= 8 GB RAM
  system.time(r &lt;- rcond(M3))
## whereas this is *fast* even though it computes  solve(M3)
system.time(r. &lt;- rcond(M3, useInv=TRUE))
if(interactive()) ## the values are not the same
  c(r, r.)  # 0.05555 0.013888
## for all 4 norms available for sparseMatrix :
cbind(rr &lt;- sapply(c("1","I","F","M"),
             function(N) rcond(M3, norm=N, useInv=TRUE)))

</code></pre>

<hr>
<h2 id='rep2abI'>Replicate Vectors into 'abIndex' Result</h2><span id='topic+rep2abI'></span>

<h3>Description</h3>

<p><code>rep2abI(x, times)</code> conceptually computes
<code><a href="base.html#topic+rep.int">rep.int</a>(x, times)</code> but with an
<code><a href="#topic+abIndex-class">abIndex</a></code> class result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep2abI(x, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep2abI_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="rep2abI_+3A_times">times</code></td>
<td>
<p>integer (valued) scalar: the number of repetitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+abIndex-class">abIndex</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep.int">rep.int</a>()</code>, the base function;
<code><a href="#topic+abIseq">abIseq</a></code>, <code><a href="#topic+abIndex-class">abIndex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(ab &lt;- rep2abI(2:7, 4))
stopifnot(identical(as(ab, "numeric"),
	   rep(2:7, 4)))
</code></pre>

<hr>
<h2 id='rleDiff-class'>Class &quot;rleDiff&quot; of  rle(diff(.))  Stored Vectors</h2><span id='topic+rleDiff-class'></span><span id='topic+show+2CrleDiff-method'></span>

<h3>Description</h3>

<p>Class <code>"rleDiff"</code> is for compactly storing long vectors
which mainly consist of <em>linear</em> stretches.  For such a vector
<code>x</code>, <code><a href="base.html#topic+diff">diff</a>(x)</code> consists of <em>constant</em> stretches
and is hence well compressable via <code><a href="base.html#topic+rle">rle</a>()</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("rleDiff", ...)</code>.
</p>
<p>Currently experimental, see below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>first</code>:</dt><dd><p>A single number (of class <code>"numLike"</code>,
a class union of <code>"numeric"</code> and <code>"logical"</code>).</p>
</dd>
<dt><code>rle</code>:</dt><dd><p>Object of class <code>"rle"</code>, basically a
<code><a href="base.html#topic+list">list</a></code> with components <code>"lengths"</code> and
<code>"values"</code>, see <code><a href="base.html#topic+rle">rle</a>()</code>.  As this is used to
encode potentially huge index vectors, <code>lengths</code> may be of
type <code><a href="base.html#topic+double">double</a></code> here.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>There is a simple <code><a href="methods.html#topic+show">show</a></code> method only.
</p>


<h3>Note</h3>

<p>This is currently an <em>experimental</em> auxiliary class
for the class <code><a href="#topic+abIndex-class">abIndex</a></code>, see there.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rle">rle</a></code>, <code><a href="#topic+abIndex-class">abIndex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("rleDiff")

ab &lt;- c(abIseq(2, 100), abIseq(20, -2))
ab@rleD  # is "rleDiff"
</code></pre>

<hr>
<h2 id='rsparsematrix'>Random Sparse Matrix</h2><span id='topic+rsparsematrix'></span>

<h3>Description</h3>

<p>Generate a random sparse matrix efficiently.  The default has rounded
gaussian non-zero entries, and <code>rand.x = NULL</code> generates random
patter<b>n</b> matrices, i.e. inheriting from <code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsparsematrix(nrow, ncol, density, nnz = round(density * maxE),
              symmetric = FALSE,
              rand.x = function(n) signif(rnorm(n), 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsparsematrix_+3A_nrow">nrow</code>, <code id="rsparsematrix_+3A_ncol">ncol</code></td>
<td>
<p>number of rows and columns, i.e., the matrix
dimension (<code><a href="base.html#topic+dim">dim</a></code>).</p>
</td></tr>
<tr><td><code id="rsparsematrix_+3A_density">density</code></td>
<td>
<p>optional number in <code class="reqn">[0,1]</code>, the density is the
proportion of non-zero entries among all matrix entries.  If
specified it determines the default for <code>nnz</code>, otherwise
<code>nnz</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="rsparsematrix_+3A_nnz">nnz</code></td>
<td>
<p>number of non-zero entries, for a sparse matrix typically
considerably smaller than <code>nrow*ncol</code>.  Must be specified if
<code>density</code> is not.</p>
</td></tr>
<tr><td><code id="rsparsematrix_+3A_symmetric">symmetric</code></td>
<td>
<p>logical indicating if result should be a matrix of
class <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>.  Note that in the symmetric
case, <code>nnz</code> denotes the number of non zero entries of the upper
(or lower) part of the matrix, including the diagonal.</p>
</td></tr>
<tr><td><code id="rsparsematrix_+3A_rand.x">rand.x</code></td>
<td>
<p><code><a href="base.html#topic+NULL">NULL</a></code> or the random number generator for the <code>x</code> slot, a
<code><a href="base.html#topic+function">function</a></code> such that <code>rand.x(n)</code> generates a
numeric vector of length <code>n</code>.  Typical examples are
<code>rand.x = rnorm</code>, or <code>rand.x = runif</code>; the default is nice
for didactical purposes.</p>
</td></tr>
<tr><td><code id="rsparsematrix_+3A_...">...</code></td>
<td>
<p>optionally further arguments passed to
<code><a href="#topic+sparseMatrix">sparseMatrix</a>()</code>, notably <code>repr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm first samples &ldquo;encoded&rdquo; <code class="reqn">(i,j)</code>s without
replacement, via one dimensional indices, if not <code>symmetric</code>
<code><a href="base.html#topic+sample.int">sample.int</a>(nrow*ncol, nnz)</code>, then&mdash;if <code>rand.x</code> is
not <code>NULL</code>&mdash;gets <code>x &lt;- rand.x(nnz)</code> and calls
<code><a href="#topic+sparseMatrix">sparseMatrix</a>(i=i, j=j, x=x, ..)</code>.  When
<code>rand.x=NULL</code>, <code><a href="#topic+sparseMatrix">sparseMatrix</a>(i=i, j=j, ..)</code> will
return a patter<b>n</b> matrix (i.e., inheriting from
<code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>).
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, say <code>M</code> of dimension (nrow,
ncol), i.e., with <code>dim(M) == c(nrow, ncol)</code>, if <code>symmetric</code>
is not true, with <code>nzM &lt;- <a href="#topic+nnzero">nnzero</a>(M)</code> fulfilling
<code>nzM &lt;= nnz</code> and typically, <code>nzM == nnz</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(17)# to be reproducible
M &lt;- rsparsematrix(8, 12, nnz = 30) # small example, not very sparse
M
M1 &lt;- rsparsematrix(1000, 20,  nnz = 123,  rand.x = runif)
summary(M1)

## a random *symmetric* Matrix
(S9 &lt;- rsparsematrix(9, 9, nnz = 10, symmetric=TRUE)) # dsCMatrix
nnzero(S9)# ~ 20: as 'nnz' only counts one "triangle"

## a random patter*n* aka boolean Matrix (no 'x' slot):
(n7 &lt;- rsparsematrix(5, 12, nnz = 10, rand.x = NULL))

## a [T]riplet representation sparseMatrix:
T2 &lt;- rsparsematrix(40, 12, nnz = 99, repr = "T")
head(T2)
</code></pre>

<hr>
<h2 id='RsparseMatrix-class'>Class &quot;RsparseMatrix&quot; of Sparse Matrices in Row-compressed Form</h2><span id='topic+RsparseMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2CRsparseMatrix-method'></span><span id='topic+diag+2CRsparseMatrix-method'></span><span id='topic+diag+3C-+2CRsparseMatrix-method'></span><span id='topic+t+2CRsparseMatrix-method'></span>

<h3>Description</h3>

<p>The <code>"RsparseMatrix"</code> class is the virtual class of
all sparse matrices coded in sorted compressed row-oriented form.
Since it is a virtual class, no objects may be created from it.  See
<code>showClass("RsparseMatrix")</code> for its subclasses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> of length <code>nnzero</code>
(number of non-zero elements).  These are the row numbers for
each non-zero element in the matrix.</p>
</dd>
<dt><code>p</code>:</dt><dd><p>Object of class <code>"integer"</code> of pointers, one
for each row, to the initial (zero-based) index of elements in
the row.</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>inherited from
the superclass, see <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"sparseMatrix"</code>, directly.
Class <code>"Matrix"</code>, by class <code>"sparseMatrix"</code>.
</p>


<h3>Methods</h3>

<p>Originally, <b>few</b> methods were defined on purpose, as we
rather use the <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> in <span class="pkg">Matrix</span>.
Then, more methods were added but <em>beware</em> that these
typically do <em>not</em> return <code>"RsparseMatrix"</code> results, but
rather Csparse* or Tsparse* ones; e.g., <code>R[i, j] &lt;- v</code> for an
<code>"RsparseMatrix"</code> <code>R</code> works, but after the assignment, <code>R</code>
is a (triplet) <code>"TsparseMatrix"</code>.
</p>

<dl>
<dt>t</dt><dd><p><code>signature(x = "RsparseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "RsparseMatrix", to = "CsparseMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "RsparseMatrix", to = "TsparseMatrix")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>its superclass, <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, and, e.g., class
<code><a href="#topic+dgRMatrix-class">dgRMatrix</a></code> for the links to other classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("RsparseMatrix")
</code></pre>

<hr>
<h2 id='Schur-class'>Schur Factorizations</h2><span id='topic+Schur-class'></span><span id='topic+determinant+2CSchur+2Clogical-method'></span>

<h3>Description</h3>

<p><code>Schur</code> is the class of Schur factorizations of
<code class="reqn">n \times n</code> real matrices <code class="reqn">A</code>,
having the general form
</p>
<p style="text-align: center;"><code class="reqn">A = Q T Q'</code>
</p>

<p>where
<code class="reqn">Q</code> is an orthogonal matrix and
<code class="reqn">T</code> is a block upper triangular matrix with
<code class="reqn">1 \times 1</code> or <code class="reqn">2 \times 2</code> diagonal blocks
specifying the real and complex conjugate eigenvalues of <code class="reqn">A</code>.
The column vectors of <code class="reqn">Q</code> are the Schur vectors of <code class="reqn">A</code>,
and <code class="reqn">T</code> is the Schur form of <code class="reqn">A</code>.
</p>
<p>The Schur factorization generalizes the spectral decomposition
of normal matrices <code class="reqn">A</code>, whose Schur form is block diagonal,
to arbitrary square matrices.
</p>


<h3>Details</h3>

<p>The matrix <code class="reqn">A</code> and its Schur form <code class="reqn">T</code> are <em>similar</em>
and thus have the same spectrum.  The eigenvalues are computed
trivially as the eigenvalues of the diagonal blocks of <code class="reqn">T</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>Q</code></dt><dd><p>an orthogonal matrix,
inheriting from virtual class <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
<dt><code>T</code></dt><dd><p>a block upper triangular matrix,
inheriting from virtual class <code><a href="#topic+Matrix-class">Matrix</a></code>.
The diagonal blocks have dimensions 1-by-1 or 2-by-2.</p>
</dd>
<dt><code>EValues</code></dt><dd><p>a numeric or complex vector containing
the eigenvalues of the diagonal blocks of <code>T</code>, which are
the eigenvalues of <code>T</code> and consequently of the factorized
matrix.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+SchurFactorization-class">SchurFactorization</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+SchurFactorization-class">SchurFactorization</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("Schur", ...)</code>, but they are more typically obtained
as the value of <code><a href="#topic+Schur">Schur</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+Matrix-class">Matrix</a></code> (often <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "Schur", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "Schur")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "Schur")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "Schur", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dgees.f">https://netlib.org/lapack/double/dgees.f</a>.
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+Schur">Schur</a></code>,
<code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("Schur")
set.seed(0)

n &lt;- 4L
(A &lt;- Matrix(rnorm(n * n), n, n))

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- list(paste0("r", seq_len(n)),
                    paste0("c", seq_len(n)))

(sch.A &lt;- Schur(A))
str(e.sch.A &lt;- expand2(sch.A), max.level = 2L)

## A ~ Q T Q' in floating point
stopifnot(exprs = {
    identical(names(e.sch.A), c("Q", "T", "Q."))
    all.equal(A, with(e.sch.A, Q %*% T %*% Q.))
})

## Factorization handled as factorized matrix
b &lt;- rnorm(n)
stopifnot(all.equal(det(A), det(sch.A)),
          all.equal(solve(A, b), solve(sch.A, b)))

## One of the non-general cases:
Schur(Diagonal(6L))
</code></pre>

<hr>
<h2 id='Schur-methods'>Methods for Schur Factorization</h2><span id='topic+Schur'></span><span id='topic+Schur-methods'></span><span id='topic+Schur+2CdgeMatrix-method'></span><span id='topic+Schur+2CdiagonalMatrix-method'></span><span id='topic+Schur+2CdsyMatrix-method'></span><span id='topic+Schur+2CgeneralMatrix-method'></span><span id='topic+Schur+2Cmatrix-method'></span><span id='topic+Schur+2CsymmetricMatrix-method'></span><span id='topic+Schur+2CtriangularMatrix-method'></span>

<h3>Description</h3>

<p>Computes the Schur factorization of an <code class="reqn">n \times n</code>
real matrix <code class="reqn">A</code>, which has the general form 
</p>
<p style="text-align: center;"><code class="reqn">A = Q T Q'</code>
</p>

<p>where
<code class="reqn">Q</code> is an orthogonal matrix and
<code class="reqn">T</code> is a block upper triangular matrix with
<code class="reqn">1 \times 1</code> and <code class="reqn">2 \times 2</code> diagonal blocks
specifying the real and complex conjugate eigenvalues of <code class="reqn">A</code>.
The column vectors of <code class="reqn">Q</code> are the Schur vectors of <code class="reqn">A</code>,
and <code class="reqn">T</code> is the Schur form of <code class="reqn">A</code>.
</p>
<p>Methods are built on LAPACK routine <code>dgees</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schur(x, vectors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Schur-methods_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> square matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> to be factorized.</p>
</td></tr>
<tr><td><code id="Schur-methods_+3A_vectors">vectors</code></td>
<td>
<p>a logical.  If <code>TRUE</code> (the default),
then Schur vectors are computed in addition to the Schur form.</p>
</td></tr>
<tr><td><code id="Schur-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the factorization, inheriting
from virtual class <code><a href="#topic+SchurFactorization-class">SchurFactorization</a></code>
if <code>vectors = TRUE</code>.  Currently, the specific class
is always <code><a href="#topic+Schur-class">Schur</a></code> in that case.

An exception is if <code>x</code> is a traditional matrix,
in which case the result is a named list containing
<code>Q</code>, <code>T</code>, and <code>EValues</code> slots of the
<code><a href="#topic+Schur-class">Schur</a></code> object.
</p>
<p>If <code>vectors = FALSE</code>, then the result is the same
named list but without <code>Q</code>.
</p>


<h3>References</h3>

<p>The LAPACK source code, including documentation; see
<a href="https://netlib.org/lapack/double/dgees.f">https://netlib.org/lapack/double/dgees.f</a>.
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+Schur-class">Schur</a></code> and its methods.
</p>
<p>Class <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>,
for constructing matrix factors from the result.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code>,
for computing other factorizations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showMethods("Schur", inherited = FALSE)
set.seed(0)

Schur(Hilbert(9L)) # real eigenvalues

(A &lt;- Matrix(round(rnorm(25L, sd = 100)), 5L, 5L))
(sch.A &lt;- Schur(A)) # complex eigenvalues

## A ~ Q T Q' in floating point
str(e.sch.A &lt;- expand2(sch.A), max.level = 2L)
stopifnot(all.equal(A, Reduce(`%*%`, e.sch.A)))

(e1 &lt;- eigen(sch.A@T, only.values = TRUE)$values)
(e2 &lt;- eigen(    A  , only.values = TRUE)$values)
(e3 &lt;- sch.A@EValues)

stopifnot(exprs = {
    all.equal(e1, e2, tolerance = 1e-13)
    all.equal(e1, e3[order(Mod(e3), decreasing = TRUE)], tolerance = 1e-13) 
    identical(Schur(A, vectors = FALSE),
              list(T = sch.A@T, EValues = e3))    
    identical(Schur(as(A, "matrix")),
              list(Q = as(sch.A@Q, "matrix"),
                   T = as(sch.A@T, "matrix"), EValues = e3))
})
</code></pre>

<hr>
<h2 id='solve-methods'>Methods in Package <span class="pkg">Matrix</span> for Function <code>solve</code></h2><span id='topic+solve'></span><span id='topic+solve-methods'></span><span id='topic+solve+2CANY+2CANY-method'></span><span id='topic+solve+2CBunchKaufman+2Cmissing-method'></span><span id='topic+solve+2CBunchKaufman+2CdgeMatrix-method'></span><span id='topic+solve+2CCHMfactor+2Cmissing-method'></span><span id='topic+solve+2CCHMfactor+2CdgeMatrix-method'></span><span id='topic+solve+2CCHMfactor+2CdgCMatrix-method'></span><span id='topic+solve+2CCholesky+2Cmissing-method'></span><span id='topic+solve+2CCholesky+2CdgeMatrix-method'></span><span id='topic+solve+2CCsparseMatrix+2CANY-method'></span><span id='topic+solve+2CMatrix+2CsparseVector-method'></span><span id='topic+solve+2CMatrixFactorization+2CCsparseMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CRsparseMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CTsparseMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CdenseMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CdgCMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CdgeMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CdiagonalMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CindMatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2Cmatrix-method'></span><span id='topic+solve+2CMatrixFactorization+2CsparseVector-method'></span><span id='topic+solve+2CMatrixFactorization+2Cvector-method'></span><span id='topic+solve+2CRsparseMatrix+2CANY-method'></span><span id='topic+solve+2CSchur+2CANY-method'></span><span id='topic+solve+2CTsparseMatrix+2CANY-method'></span><span id='topic+solve+2CddiMatrix+2CMatrix-method'></span><span id='topic+solve+2CddiMatrix+2Cmatrix-method'></span><span id='topic+solve+2CddiMatrix+2Cmissing-method'></span><span id='topic+solve+2CddiMatrix+2Cvector-method'></span><span id='topic+solve+2CdenseLU+2Cmissing-method'></span><span id='topic+solve+2CdenseLU+2CdgeMatrix-method'></span><span id='topic+solve+2CdenseMatrix+2CANY-method'></span><span id='topic+solve+2CdgCMatrix+2CdenseMatrix-method'></span><span id='topic+solve+2CdgCMatrix+2Cmatrix-method'></span><span id='topic+solve+2CdgCMatrix+2Cmissing-method'></span><span id='topic+solve+2CdgCMatrix+2CsparseMatrix-method'></span><span id='topic+solve+2CdgCMatrix+2Cvector-method'></span><span id='topic+solve+2CdgeMatrix+2CANY-method'></span><span id='topic+solve+2CdiagonalMatrix+2CANY-method'></span><span id='topic+solve+2CdpoMatrix+2CANY-method'></span><span id='topic+solve+2CdppMatrix+2CANY-method'></span><span id='topic+solve+2CdsCMatrix+2CdenseMatrix-method'></span><span id='topic+solve+2CdsCMatrix+2Cmatrix-method'></span><span id='topic+solve+2CdsCMatrix+2Cmissing-method'></span><span id='topic+solve+2CdsCMatrix+2CsparseMatrix-method'></span><span id='topic+solve+2CdsCMatrix+2Cvector-method'></span><span id='topic+solve+2CdspMatrix+2CANY-method'></span><span id='topic+solve+2CdsyMatrix+2CANY-method'></span><span id='topic+solve+2CdtCMatrix+2CdgCMatrix-method'></span><span id='topic+solve+2CdtCMatrix+2CdgeMatrix-method'></span><span id='topic+solve+2CdtCMatrix+2Cmissing-method'></span><span id='topic+solve+2CdtCMatrix+2CtriangularMatrix-method'></span><span id='topic+solve+2CdtpMatrix+2CdgeMatrix-method'></span><span id='topic+solve+2CdtpMatrix+2Cmissing-method'></span><span id='topic+solve+2CdtpMatrix+2CtriangularMatrix-method'></span><span id='topic+solve+2CdtrMatrix+2CdgeMatrix-method'></span><span id='topic+solve+2CdtrMatrix+2Cmissing-method'></span><span id='topic+solve+2CdtrMatrix+2CtriangularMatrix-method'></span><span id='topic+solve+2CindMatrix+2CANY-method'></span><span id='topic+solve+2Cmatrix+2CMatrix-method'></span><span id='topic+solve+2Cmatrix+2CsparseVector-method'></span><span id='topic+solve+2CpBunchKaufman+2Cmissing-method'></span><span id='topic+solve+2CpBunchKaufman+2CdgeMatrix-method'></span><span id='topic+solve+2CpCholesky+2Cmissing-method'></span><span id='topic+solve+2CpCholesky+2CdgeMatrix-method'></span><span id='topic+solve+2CpMatrix+2CMatrix-method'></span><span id='topic+solve+2CpMatrix+2Cmatrix-method'></span><span id='topic+solve+2CpMatrix+2Cmissing-method'></span><span id='topic+solve+2CpMatrix+2Cvector-method'></span><span id='topic+solve+2CsparseLU+2Cmissing-method'></span><span id='topic+solve+2CsparseLU+2CdgeMatrix-method'></span><span id='topic+solve+2CsparseLU+2CdgCMatrix-method'></span><span id='topic+solve+2CsparseQR+2Cmissing-method'></span><span id='topic+solve+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+solve+2CsparseQR+2CdgCMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CCsparseMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CRsparseMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CTsparseMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CdenseMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CdgCMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CdgeMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CdiagonalMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2CindMatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2Cmatrix-method'></span><span id='topic+solve+2CtriangularMatrix+2Cvector-method'></span>

<h3>Description</h3>

<p>Methods for generic function <code><a href="base.html#topic+solve">solve</a></code> for solving
linear systems of equations,
i.e., for <code class="reqn">X</code> in <code class="reqn">A X = B</code>,
where <code class="reqn">A</code> is a square matrix and <code class="reqn">X</code> and <code class="reqn">B</code> are matrices
with dimensions consistent with <code class="reqn">A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve(a, b, ...)

## S4 method for signature 'dgeMatrix,ANY'
solve(a, b, tol = .Machine$double.eps, ...)

## S4 method for signature 'dgCMatrix,missing'
solve(a, b, sparse = TRUE, ...)
## S4 method for signature 'dgCMatrix,matrix'
solve(a, b, sparse = FALSE, ...)
## S4 method for signature 'dgCMatrix,denseMatrix'
solve(a, b, sparse = FALSE, ...)
## S4 method for signature 'dgCMatrix,sparseMatrix'
solve(a, b, sparse = TRUE, ...)

## S4 method for signature 'denseLU,dgeMatrix'
solve(a, b, ...)
## S4 method for signature 'BunchKaufman,dgeMatrix'
solve(a, b, ...)
## S4 method for signature 'Cholesky,dgeMatrix'
solve(a, b, ...)
## S4 method for signature 'sparseLU,dgCMatrix'
solve(a, b, tol = .Machine$double.eps, ...)
## S4 method for signature 'sparseQR,dgCMatrix'
solve(a, b, ...)
## S4 method for signature 'CHMfactor,dgCMatrix'
solve(a, b, system = c("A", "LDLt", "LD", "DLt", "L", "Lt", "D", "P", "Pt"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve-methods_+3A_a">a</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> square matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> containing the coefficients
of the linear system, or otherwise a
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>,
in which case methods behave (by default)
as if the factorized matrix were specified.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_b">b</code></td>
<td>
<p>a vector, <code><a href="#topic+sparseVector-class">sparseVector</a></code>,
matrix, or <code><a href="#topic+Matrix-class">Matrix</a></code> satisfying
<code>NROW(b) == nrow(a)</code>, giving the right-hand side(s)
of the linear system.  Vectors <code>b</code> are treated as
<code>length(b)</code>-by-1 matrices.  If <code>b</code> is missing,
then methods take <code>b</code> to be an identity matrix.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_tol">tol</code></td>
<td>
<p>a non-negative number.  For <code>a</code> inheriting from
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code>, an error is signaled if the
reciprocal one-norm condition number (see <code><a href="base.html#topic+rcond">rcond</a></code>)
of <code>a</code> is less than <code>tol</code>, indicating that <code>a</code> is
near-singular.  For <code>a</code> of class <code><a href="#topic+sparseLU-class">sparseLU</a></code>,
an error is signaled if the ratio <code>min(d)/max(d)</code> is less
than <code>tol</code>, where <code>d = abs(diag(a@U))</code>.  (Interpret
with care, as this ratio is a cheap heuristic and <em>not</em>
in general equal to or even proportional to the reciprocal
one-norm condition number.)  Setting <code>tol = 0</code> disables
the test.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_sparse">sparse</code></td>
<td>
<p>a logical indicating if the result should be formally
sparse, i.e., if the result should inherit from virtual class
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>.
Only methods for sparse <code>a</code> and missing or matrix <code>b</code>
have this argument.
Methods for missing or sparse <code>b</code> use <code>sparse = TRUE</code>
by default.  Methods for dense <code>b</code> use <code>sparse = FALSE</code>
by default.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_system">system</code></td>
<td>
<p>a string specifying a linear system to be solved.
Only methods for <code>a</code>
inheriting from <code><a href="#topic+CHMfactor-class">CHMfactor</a></code> have this argument.
See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="solve-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for general and symmetric matrices <code>a</code> compute a
triangular factorization (LU, Bunch-Kaufman, or Cholesky)
and call the method for the corresponding factorization class.
The factorization is sparse if <code>a</code> is.  Methods for sparse,
symmetric matrices <code>a</code> attempt a Cholesky factorization
and perform an LU factorization only if that fails (typically
because <code>a</code> is not positive definite).
</p>
<p>Triangular, diagonal, and permutation matrices do not require
factorization (they are already &ldquo;factors&rdquo;), hence methods
for those are implemented directly.  For triangular <code>a</code>,
solutions are obtained by forward or backward substitution;
for diagonal <code>a</code>, they are obtained by scaling the rows
of <code>b</code>; and for permutations <code>a</code>, they are obtained
by permuting the rows of <code>b</code>.
</p>
<p>Methods for dense <code>a</code> are built on 14 LAPACK routines:
class <code>d..Matrix</code>, where <code>..=(ge|tr|tp|sy|sp|po|pp)</code>,
uses routines <code>d..tri</code> and <code>d..trs</code> for missing
and non-missing <code>b</code>, respectively.  A corollary is that
these methods always give a dense result.
</p>
<p>Methods for sparse <code>a</code> are built on CXSparse routines
<code>cs_lsolve</code>, <code>cs_usolve</code>, and <code>cs_spsolve</code> and
CHOLMOD routines <code>cholmod_solve</code> and <code>cholmod_spsolve</code>.
By default, these methods give a vector result if <code>b</code>
is a vector, a sparse matrix result if <code>b</code> is missing
or a sparse matrix, and a dense matrix result if <code>b</code>
is a dense matrix.  One can override this behaviour by setting
the <code>sparse</code> argument, where available, but that should
be done with care.  Note that a sparse result may be sparse only
in the formal sense and not at all in the mathematical sense,
depending on the nonzero patterns of <code>a</code> and <code>b</code>.
Furthermore, whereas dense results are fully preallocated,
sparse results must be &ldquo;grown&rdquo; in a loop over the columns
of <code>b</code>.
</p>
<p>Methods for <code>a</code> of class <code><a href="#topic+sparseQR-class">sparseQR</a></code>
are simple wrappers around <code><a href="base.html#topic+qr.coef">qr.coef</a></code>, giving the
<em>least squares</em> solution in overdetermined cases.
</p>
<p>Methods for <code>a</code> inheriting from <code><a href="#topic+CHMfactor-class">CHMfactor</a></code>
can solve systems other than the default one <code class="reqn">A X = B</code>.
The correspondence between its <code>system</code> argument the system
actually solved is outlined in the table below.
See <code><a href="#topic+CHMfactor-class">CHMfactor-class</a></code> for a definition of notation.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>system</code> </td><td style="text-align: right;"> <code><a href="#topic+isLDL">isLDL</a>(a)=TRUE</code> </td><td style="text-align: right;"> <code><a href="#topic+isLDL">isLDL</a>(a)=FALSE</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"A"</code> </td><td style="text-align: right;"> <code class="reqn">A X = B</code> </td><td style="text-align: right;"> <code class="reqn">A X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"LDLt"</code> </td><td style="text-align: right;"> <code class="reqn">L_{1} D L_{1}' X = B</code> </td><td style="text-align: right;"> <code class="reqn">L L' X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"LD"</code> </td><td style="text-align: right;"> <code class="reqn">L_{1} D X = B</code> </td><td style="text-align: right;"> <code class="reqn">L X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"DLt"</code> </td><td style="text-align: right;"> <code class="reqn">D L_{1}' X = B</code> </td><td style="text-align: right;"> <code class="reqn">L' X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"L"</code> </td><td style="text-align: right;"> <code class="reqn">L_{1} X = B</code> </td><td style="text-align: right;"> <code class="reqn">L X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"Lt"</code> </td><td style="text-align: right;"> <code class="reqn">L_{1}' X = B</code> </td><td style="text-align: right;"> <code class="reqn">L' X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"D"</code> </td><td style="text-align: right;"> <code class="reqn">D X = B</code> </td><td style="text-align: right;"> <code class="reqn">X = B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"P"</code> </td><td style="text-align: right;"> <code class="reqn">X = P_{1} B</code> </td><td style="text-align: right;"> <code class="reqn">X = P_{1} B</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>"Pt"</code> </td><td style="text-align: right;"> <code class="reqn">X = P_{1}' B</code> </td><td style="text-align: right;"> <code class="reqn">X = P_{1}' B</code>
  </td>
</tr>

</table>



<h3>See Also</h3>

<p>Virtual class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code> and its
subclasses.
</p>
<p>Generic functions <code><a href="#topic+Cholesky">Cholesky</a></code>, <code><a href="#topic+BunchKaufman">BunchKaufman</a></code>,
<code><a href="#topic+Schur">Schur</a></code>, <code><a href="#topic+lu">lu</a></code>, and <code><a href="#topic+qr">qr</a></code> for
<em>computing</em> factorizations.
</p>
<p>Generic function <code><a href="base.html#topic+solve">solve</a></code> from <span class="pkg">base</span>.
</p>
<p>Function <code><a href="base.html#topic+qr.coef">qr.coef</a></code> from <span class="pkg">base</span> for computing
least squares solutions of overdetermined linear systems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A close to symmetric example with "quite sparse" inverse:
n1 &lt;- 7; n2 &lt;- 3
dd &lt;- data.frame(a = gl(n1,n2), b = gl(n2,1,n1*n2))# balanced 2-way
X &lt;- sparse.model.matrix(~ -1+ a + b, dd)# no intercept --&gt; even sparser
XXt &lt;- tcrossprod(X)
diag(XXt) &lt;- rep(c(0,0,1,0), length.out = nrow(XXt))

n &lt;- nrow(ZZ &lt;- kronecker(XXt, Diagonal(x=c(4,1))))
image(a &lt;- 2*Diagonal(n) + ZZ %*% Diagonal(x=c(10, rep(1, n-1))))
isSymmetric(a) # FALSE
image(drop0(skewpart(a)))
image(ia0 &lt;- solve(a, tol = 0)) # checker board, dense [but really, a is singular!]
try(solve(a, sparse=TRUE))##-&gt; error [ TODO: assertError ]
ia. &lt;- solve(a, sparse=TRUE, tol = 1e-19)##-&gt; *no* error
if(R.version$arch == "x86_64")
  ## Fails on 32-bit [Fedora 19, R 3.0.2] from Matrix 1.1-0 on [FIXME ??] only
  stopifnot(all.equal(as.matrix(ia.), as.matrix(ia0)))
a &lt;- a + Diagonal(n)
iad &lt;- solve(a)
ias &lt;- solve(a, sparse=FALSE)
stopifnot(all.equal(as(iad,"denseMatrix"), ias, tolerance=1e-14))
I. &lt;- iad %*% a          ; image(I.)
I0 &lt;- drop0(zapsmall(I.)); image(I0)
.I &lt;- a %*% iad
.I0 &lt;- drop0(zapsmall(.I))
stopifnot( all.equal(as(I0, "diagonalMatrix"), Diagonal(n)),
           all.equal(as(.I0,"diagonalMatrix"), Diagonal(n)) )

</code></pre>

<hr>
<h2 id='sparse.model.matrix'>Construct Sparse Design / Model Matrices</h2><span id='topic+sparse.model.matrix'></span><span id='topic+fac2sparse'></span><span id='topic+fac2Sparse'></span>

<h3>Description</h3>

<p>Construct a sparse model or &ldquo;design&rdquo; matrix,
from a formula and data frame (<code>sparse.model.matrix</code>) or a single
factor (<code>fac2sparse</code>).
</p>
<p>The <code>fac2[Ss]parse()</code> functions are utilities, also used
internally in the principal user level function
<code>sparse.model.matrix()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.model.matrix(object, data = environment(object),
		    contrasts.arg = NULL, xlev = NULL, transpose = FALSE,
		    drop.unused.levels = FALSE, row.names = TRUE,
		    sep = "", verbose = FALSE, ...)

fac2sparse(from, to = c("d", "l", "n"),
	   drop.unused.levels = TRUE, repr = c("C", "R", "T"), giveCsparse)
fac2Sparse(from, to = c("d", "l", "n"),
	   drop.unused.levels = TRUE, repr = c("C", "R", "T"), giveCsparse,
	   factorPatt12, contrasts.arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.model.matrix_+3A_object">object</code></td>
<td>
<p>an object of an appropriate class.  For the default
method, a model formula or terms object.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_data">data</code></td>
<td>
<p>a data frame created with <code><a href="stats.html#topic+model.frame">model.frame</a></code>.  If
another sort of object, <code>model.frame</code> is called first.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_contrasts.arg">contrasts.arg</code></td>
<td>

<dl>
<dt>for <code>sparse.model.matrix()</code>:</dt><dd><p>A list, whose entries are
contrasts suitable for input to the <code><a href="stats.html#topic+contrasts">contrasts</a></code>
replacement function and whose names are the names of columns
of <code>data</code> containing <code><a href="base.html#topic+factor">factor</a></code>s.</p>
</dd>
<dt>for <code>fac2Sparse()</code>:</dt><dd><p>character string or <code>NULL</code> or
(coercable to) <code>"<a href="#topic+sparseMatrix-class">sparseMatrix</a>"</code>, specifying the
contrasts to be applied to the factor levels.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_xlev">xlev</code></td>
<td>
<p>to be used as argument of <code><a href="stats.html#topic+model.frame">model.frame</a></code> if
<code>data</code> has no <code>"terms"</code> attribute.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_transpose">transpose</code></td>
<td>
<p>logical indicating if the <em>transpose</em> should be
returned; if the transposed is used anyway, setting <code>transpose = TRUE</code>
is more efficient.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>should factors have unused levels dropped?
The default for <code>sparse.model.matrix</code> has been changed to
<code>FALSE</code>, 2010-07, for compatibility with <span class="rlang"><b>R</b></span>'s standard (dense)
<code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_row.names">row.names</code></td>
<td>
<p>logical indicating if row names should be used.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_sep">sep</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string passed to <code><a href="base.html#topic+paste">paste</a>()</code>
when constructing column names from the variable name and its levels.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer indicating if (and how much)
progress output should be printed.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_from">from</code></td>
<td>
<p>(for <code>fac2sparse()</code>:) a <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_to">to</code></td>
<td>
<p>a character indicating the &ldquo;kind&rdquo; of sparse matrix to
be returned.  The default, <code>"d"</code> is for <code><a href="base.html#topic+double">double</a></code>.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_givecsparse">giveCsparse</code></td>
<td>
<p><b>deprecated</b>, replaced with <code>repr</code>; logical indicating if
the result must be a <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_repr">repr</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string, one of <code>"C"</code>,
<code>"T"</code>, or <code>"R"</code>, specifying the sparse <em>repr</em>esentation to
be used for the result, i.e., one from the super classes
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>, <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, or
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="sparse.model.matrix_+3A_factorpatt12">factorPatt12</code></td>
<td>
<p>logical vector, say <code>fp</code>, of length two;
when <code>fp[1]</code> is true, return &ldquo;contrasted&rdquo; <code>t(X)</code>;
when <code>fp[2]</code> is true, the original (&ldquo;dummy&rdquo;)
<code>t(X)</code>, i.e, the result of <code><a href="#topic+fac2sparse">fac2sparse</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sparse matrix, extending <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> (for
<code>fac2sparse()</code> if <code>repr = "C"</code> as per default; a
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> or <code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, otherwise).
</p>
<p>For <code>fac2Sparse()</code>, a <code><a href="base.html#topic+list">list</a></code> of length two, both
components with the corresponding transposed model matrix, where the
corresponding <code>factorPatt12</code> is true.
</p>
<p><code>fac2sparse()</code>, the basic workhorse of
<code>sparse.model.matrix()</code>, returns the <em>transpose</em>
(<code><a href="base.html#topic+t">t</a></code>) of the model matrix.
</p>


<h3>Note</h3>

<p><code>model.Matrix(sparse = TRUE)</code> from package <a href="https://CRAN.R-project.org/package=MatrixModels"><span class="pkg">MatrixModels</span></a>
may be nowadays be preferable to <code>sparse.model.matrix</code>,
as <code>model.Matrix</code> returns an object of class <code>modelMatrix</code>
with additional slots <code>assign</code> and <code>contrasts</code> relating to
the model variables.
</p>


<h3>Author(s)</h3>

<p>Doug Bates and Martin Maechler, with initial suggestions from Tim
Hesterberg.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code> in package <span class="pkg">stats</span>, part of base <span class="rlang"><b>R</b></span>.
</p>
<p><code>model.Matrix</code> in package <a href="https://CRAN.R-project.org/package=MatrixModels"><span class="pkg">MatrixModels</span></a>; see &lsquo;Note&rsquo;.
</p>
<p><code>as(f, "sparseMatrix")</code> (see <code>coerce(from = "factor", ..)</code>
in the class doc <a href="#topic+sparseMatrix-class">sparseMatrix</a>) produces the
<em>transposed</em> sparse model matrix for a single factor <code>f</code>
(and <em>no</em> contrasts).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dd &lt;- data.frame(a = gl(3,4), b = gl(4,1,12))# balanced 2-way
options("contrasts") # the default:  "contr.treatment"
sparse.model.matrix(~ a + b, dd)
sparse.model.matrix(~ -1+ a + b, dd)# no intercept --&gt; even sparser
sparse.model.matrix(~ a + b, dd, contrasts = list(a="contr.sum"))
sparse.model.matrix(~ a + b, dd, contrasts = list(b="contr.SAS"))

## Sparse method is equivalent to the traditional one :
stopifnot(all(sparse.model.matrix(~    a + b, dd) ==
	          Matrix(model.matrix(~    a + b, dd), sparse=TRUE)),
	      all(sparse.model.matrix(~0 + a + b, dd) ==
	          Matrix(model.matrix(~0 + a + b, dd), sparse=TRUE)))

(ff &lt;- gl(3,4,, c("X","Y", "Z")))
fac2sparse(ff) #  3 x 12 sparse Matrix of class "dgCMatrix"
##
##  X  1 1 1 1 . . . . . . . .
##  Y  . . . . 1 1 1 1 . . . .
##  Z  . . . . . . . . 1 1 1 1

## can also be computed via sparse.model.matrix():
f30 &lt;- gl(3,0    )
f12 &lt;- gl(3,0, 12)
stopifnot(
  all.equal(t( fac2sparse(ff) ),
	    sparse.model.matrix(~ 0+ff),
	    tolerance = 0, check.attributes=FALSE),
  is(M &lt;- fac2sparse(f30, drop= TRUE),"CsparseMatrix"), dim(M) == c(0, 0),
  is(M &lt;- fac2sparse(f30, drop=FALSE),"CsparseMatrix"), dim(M) == c(3, 0),
  is(M &lt;- fac2sparse(f12, drop= TRUE),"CsparseMatrix"), dim(M) == c(0,12),
  is(M &lt;- fac2sparse(f12, drop=FALSE),"CsparseMatrix"), dim(M) == c(3,12)
 )
</code></pre>

<hr>
<h2 id='sparseLU-class'>Sparse LU Factorizations</h2><span id='topic+sparseLU-class'></span><span id='topic+determinant+2CsparseLU+2Clogical-method'></span>

<h3>Description</h3>

<p><code>sparseLU</code> is the class of sparse, row- and column-pivoted
LU factorizations of <code class="reqn">n \times n</code> real matrices <code class="reqn">A</code>,
having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{2} = L U</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_{1}' L U P_{2}'</code>
</p>

<p>where
<code class="reqn">P_{1}</code> and <code class="reqn">P_{2}</code> are permutation matrices,
<code class="reqn">L</code> is a unit lower triangular matrix, and
<code class="reqn">U</code> is an upper triangular matrix.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>L</code></dt><dd><p>an object of class <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>,
the unit lower triangular <code class="reqn">L</code> factor.</p>
</dd>
<dt><code>U</code></dt><dd><p>an object of class <code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>,
the upper triangular <code class="reqn">U</code> factor.</p>
</dd>
<dt><code>p</code>, <code>q</code></dt><dd><p>0-based integer vectors of length
<code>Dim[1]</code>,
specifying the permutations applied to the rows and columns of
the factorized matrix.  <code>q</code> of length 0 is valid and
equivalent to the identity permutation, implying no column pivoting.
Using <span class="rlang"><b>R</b></span> syntax, the matrix <code class="reqn">P_{1} A P_{2}</code>
is precisely <code>A[p+1, q+1]</code>
(<code>A[p+1, ]</code> when <code>q</code> has length 0).</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+LU-class">LU</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+LU-class">LU</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("sparseLU", ...)</code>, but they are more typically obtained
as the value of <code><a href="#topic+lu">lu</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> (often <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "sparseLU", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>expand</code></dt><dd><p><code>signature(x = "sparseLU")</code>:
see <code><a href="#topic+expand-methods">expand-methods</a></code>.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "sparseLU")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "sparseLU")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "sparseLU", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Davis, T. A. (2006).
<em>Direct methods for sparse linear systems</em>.
Society for Industrial and Applied Mathematics.
<a href="https://doi.org/10.1137/1.9780898718881">doi:10.1137/1.9780898718881</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+denseLU-class">denseLU</a></code> for dense LU factorizations.
</p>
<p>Class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>
<p>Generic functions <code><a href="#topic+lu">lu</a></code>,
<code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("sparseLU")
set.seed(2)

A &lt;- as(readMM(system.file("external", "pores_1.mtx", package = "Matrix")),
        "CsparseMatrix")
(n &lt;- A@Dim[1L])

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- dn &lt;- list(paste0("r", seq_len(n)),
                          paste0("c", seq_len(n)))

(lu.A &lt;- lu(A))
str(e.lu.A &lt;- expand2(lu.A), max.level = 2L)

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ P1' L U P2' in floating point
stopifnot(exprs = {
    identical(names(e.lu.A), c("P1.", "L", "U", "P2."))
    identical(e.lu.A[["P1."]],
              new("pMatrix", Dim = c(n, n), Dimnames = c(dn[1L], list(NULL)),
                  margin = 1L, perm = invertPerm(lu.A@p, 0L, 1L)))
    identical(e.lu.A[["P2."]],
              new("pMatrix", Dim = c(n, n), Dimnames = c(list(NULL), dn[2L]),
                  margin = 2L, perm = invertPerm(lu.A@q, 0L, 1L)))
    identical(e.lu.A[["L"]], lu.A@L)
    identical(e.lu.A[["U"]], lu.A@U)
    ae1(A, with(e.lu.A, P1. %*% L %*% U %*% P2.))
    ae2(A[lu.A@p + 1L, lu.A@q + 1L], with(e.lu.A, L %*% U))
})

## Factorization handled as factorized matrix
b &lt;- rnorm(n)
stopifnot(identical(det(A), det(lu.A)),
          identical(solve(A, b), solve(lu.A, b)))
</code></pre>

<hr>
<h2 id='sparseMatrix'>General Sparse Matrix Construction from Nonzero Entries</h2><span id='topic+sparseMatrix'></span>

<h3>Description</h3>

<p>User-friendly construction of sparse matrices (inheriting from
virtual <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>,
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, or
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>)
from the positions and values of their nonzero entries.
</p>
<p>This interface is recommended over direct construction via
calls such as <code><a href="methods.html#topic+new">new</a>("..[CRT]Matrix", ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseMatrix(i, j, p, x, dims, dimnames,
             symmetric = FALSE, triangular = FALSE, index1 = TRUE,
             repr = c("C", "R", "T"), giveCsparse,
             check = TRUE, use.last.ij = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseMatrix_+3A_i">i</code>, <code id="sparseMatrix_+3A_j">j</code></td>
<td>
<p>integer vectors of equal length specifying the positions
(row and column indices) of the nonzero (or non-<code>TRUE</code>) entries
of the matrix.  Note that, when <code>x</code> is non-missing, the
<code class="reqn">x_k</code> corresponding to <em>repeated</em> pairs <code class="reqn">(i_k,j_k)</code>
are <em>added</em>, for consistency with the definition of class
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>, unless <code>use.last.ij</code> is
<code>TRUE</code>, in which case only the <em>last</em> such <code class="reqn">x_k</code> is
used.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_p">p</code></td>
<td>
<p>integer vector of pointers, one for each column (or row),
to the initial (zero-based) index of elements in the column (or row).
Exactly one of <code>i</code>, <code>j</code>, and <code>p</code> must be missing.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_x">x</code></td>
<td>
<p>optional, typically nonzero values for the matrix entries.
If specified, then the length must equal that of <code>i</code>
(or <code>j</code>) or equal 1, in which case <code>x</code> is recycled as
necessary.  If missing, then the result is a <b>n</b>onzero pattern
matrix, i.e., inheriting from class <code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_dims">dims</code></td>
<td>
<p>optional length-2 integer vector of matrix dimensions.
If missing, then <code>!index1+c(max(i),max(j))</code> is used.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_dimnames">dimnames</code></td>
<td>
<p>optional list of <code><a href="base.html#topic+dimnames">dimnames</a></code>; if missing,
then <code><a href="base.html#topic+NULL">NULL</a></code> ones are used.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_symmetric">symmetric</code></td>
<td>
<p>logical indicating if the resulting matrix should
be symmetric.  In that case, <code class="reqn">(i,j,p)</code> should specify only one
triangle (upper or lower).</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_triangular">triangular</code></td>
<td>
<p>logical indicating if the resulting matrix should
be triangular.  In that case, <code class="reqn">(i,j,p)</code> should specify only one
triangle (upper or lower).</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_index1">index1</code></td>
<td>
<p>logical.  If <code>TRUE</code> (the default), then <code>i</code>
and <code>j</code> are interpreted as 1-based indices, following the <span class="rlang"><b>R</b></span>
convention.  That is, counting of rows and columns starts at 1.
If <code>FALSE</code>, then they are interpreted as 0-based indices.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_repr">repr</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string, one of <code>"C"</code>,
<code>"R"</code>, and <code>"T"</code>, specifying the <b>repr</b>esentation
of the sparse matrix result, i.e., specifying one of the virtual
classes <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>,
<code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code>, and
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_givecsparse">giveCsparse</code></td>
<td>
<p>(<b>deprecated</b>, replaced by <code>repr</code>)
logical indicating if the result should inherit from
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> or
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.
Note that operations involving <code>CsparseMatrix</code> are very often
(but not always) more efficient.</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_check">check</code></td>
<td>
<p>logical indicating whether to check that the result is
formally valid before returning.  Do not set to <code>FALSE</code> unless
you know what you are doing!</p>
</td></tr>
<tr><td><code id="sparseMatrix_+3A_use.last.ij">use.last.ij</code></td>
<td>
<p>logical indicating if, in the case of repeated
(duplicated) pairs <code class="reqn">(i_k,j_k)</code>, only the last pair should be
used.  <code>FALSE</code> (the default) is consistent with the definiton
of class <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Exactly one of the arguments <code>i</code>, <code>j</code> and <code>p</code> must be
missing.
</p>
<p>In typical usage, <code>p</code> is missing, <code>i</code> and <code>j</code> are
vectors of positive integers and <code>x</code> is a numeric vector.  These
three vectors, which must have the same length, form the triplet
representation of the sparse matrix.
</p>
<p>If <code>i</code> or <code>j</code> is missing then <code>p</code> must be a
non-decreasing integer vector whose first element is zero.  It
provides the compressed, or &ldquo;pointer&rdquo; representation of the row
or column indices, whichever is missing.  The expanded form of <code>p</code>,
<code>rep(seq_along(dp),dp)</code> where <code>dp &lt;- diff(p)</code>, is used as
the (1-based) row or column indices.
</p>
<p>You cannot set both <code>singular</code> and <code>triangular</code> to true;
rather use <code><a href="#topic+Diagonal">Diagonal</a>()</code> (or its alternatives, see there).
</p>
<p>The values of <code>i</code>, <code>j</code>, <code>p</code> and <code>index1</code> are used
to create 1-based index vectors <code>i</code> and <code>j</code> from which a
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> is constructed, with numerical
values given by <code>x</code>, if non-missing.  Note that in that case,
when some pairs <code class="reqn">(i_k,j_k)</code> are repeated (aka
&ldquo;duplicated&rdquo;), the corresponding <code class="reqn">x_k</code> are <em>added</em>, in
consistency with the definition of the
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> class, unless <code>use.last.ij</code>
is set to true.
</p>
<p>By default, when <code>repr = "C"</code>, the <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>
derived from this triplet form is returned, where <code>repr = "R"</code> now
allows to directly get an <code><a href="#topic+RsparseMatrix-class">RsparseMatrix</a></code> and
<code>repr = "T"</code> leaves the result as <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>.
</p>
<p>The reason for returning a <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> object
instead of the triplet format by default is that the compressed column
form is easier to work with when performing matrix operations.  In
particular, if there are no zeros in <code>x</code> then a
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> is a unique representation of the
sparse matrix.
</p>


<h3>Value</h3>

<p>A sparse matrix, by default in compressed sparse column format and
(formally) without symmetric or triangular structure, i.e.,
by default inheriting from both <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>
and <code><a href="#topic+generalMatrix-class">generalMatrix</a></code>.
</p>


<h3>Note</h3>


<p>You <em>do</em> need to use <code>index1 = FALSE</code> (or add <code>+ 1</code>
to <code>i</code> and <code>j</code>) if you want use the 0-based <code>i</code> (and
<code>j</code>) slots from existing sparse matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Matrix">Matrix</a>(*, sparse=TRUE)</code> for the constructor of
such matrices from a <em>dense</em> matrix.  That is easier in small
sample, but much less efficient (or impossible) for large matrices,
where something like <code>sparseMatrix()</code> is needed.
Further <code><a href="#topic+bdiag">bdiag</a></code> and <code><a href="#topic+Diagonal">Diagonal</a></code> for (block-)diagonal and
<code><a href="#topic+bandSparse">bandSparse</a></code> for banded sparse matrix constructors.
</p>
<p>Random sparse matrices via <code><a href="#topic+rsparsematrix">rsparsematrix</a>()</code>.
</p>
<p>The standard <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+xtabs">xtabs</a>(*, sparse=TRUE)</code>, for sparse tables
and <code><a href="#topic+sparse.model.matrix">sparse.model.matrix</a>()</code> for building sparse model
matrices.
</p>
<p>Consider <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> and similar class
definition help files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example
i &lt;- c(1,3:8); j &lt;- c(2,9,6:10); x &lt;- 7 * (1:7)
(A &lt;- sparseMatrix(i, j, x = x))                    ##  8 x 10 "dgCMatrix"
summary(A)
str(A) # note that *internally* 0-based row indices are used

(sA &lt;- sparseMatrix(i, j, x = x, symmetric = TRUE)) ## 10 x 10 "dsCMatrix"
(tA &lt;- sparseMatrix(i, j, x = x, triangular= TRUE)) ## 10 x 10 "dtCMatrix"
stopifnot( all(sA == tA + t(tA)) ,
           identical(sA, as(tA + t(tA), "symmetricMatrix")))

## dims can be larger than the maximum row or column indices
(AA &lt;- sparseMatrix(c(1,3:8), c(2,9,6:10), x = 7 * (1:7), dims = c(10,20)))
summary(AA)

## i, j and x can be in an arbitrary order, as long as they are consistent
set.seed(1); (perm &lt;- sample(1:7))
(A1 &lt;- sparseMatrix(i[perm], j[perm], x = x[perm]))
stopifnot(identical(A, A1))

## The slots are 0-index based, so
try( sparseMatrix(i=A@i, p=A@p, x= seq_along(A@x)) )
## fails and you should say so: 1-indexing is FALSE:
     sparseMatrix(i=A@i, p=A@p, x= seq_along(A@x), index1 = FALSE)

## the (i,j) pairs can be repeated, in which case the x's are summed
(args &lt;- data.frame(i = c(i, 1), j = c(j, 2), x = c(x, 2)))
(Aa &lt;- do.call(sparseMatrix, args))
## explicitly ask for elimination of such duplicates, so
## that the last one is used:
(A. &lt;- do.call(sparseMatrix, c(args, list(use.last.ij = TRUE))))
stopifnot(Aa[1,2] == 9, # 2+7 == 9
          A.[1,2] == 2) # 2 was *after* 7

## for a pattern matrix, of course there is no "summing":
(nA &lt;- do.call(sparseMatrix, args[c("i","j")]))

dn &lt;- list(LETTERS[1:3], letters[1:5])
## pointer vectors can be used, and the (i,x) slots are sorted if necessary:
m &lt;- sparseMatrix(i = c(3,1, 3:2, 2:1), p= c(0:2, 4,4,6), x = 1:6, dimnames = dn)
m
str(m)
stopifnot(identical(dimnames(m), dn))

sparseMatrix(x = 2.72, i=1:3, j=2:4) # recycling x
sparseMatrix(x = TRUE, i=1:3, j=2:4) # recycling x, |--&gt; "lgCMatrix"

## no 'x' --&gt; patter*n* matrix:
(n &lt;- sparseMatrix(i=1:6, j=rev(2:7)))# -&gt; ngCMatrix

## an empty sparse matrix:
(e &lt;- sparseMatrix(dims = c(4,6), i={}, j={}))

## a symmetric one:
(sy &lt;- sparseMatrix(i= c(2,4,3:5), j= c(4,7:5,5), x = 1:5,
                    dims = c(7,7), symmetric=TRUE))
stopifnot(isSymmetric(sy),
          identical(sy, ## switch i &lt;-&gt; j {and transpose }
    t( sparseMatrix(j= c(2,4,3:5), i= c(4,7:5,5), x = 1:5,
                    dims = c(7,7), symmetric=TRUE))))

## rsparsematrix() calls sparseMatrix() :
M1 &lt;- rsparsematrix(1000, 20, nnz = 200)
summary(M1)

## pointers example in converting from other sparse matrix representations.
if(requireNamespace("SparseM") &amp;&amp;
   packageVersion("SparseM") &gt;= "0.87" &amp;&amp;
   nzchar(dfil &lt;- system.file("extdata", "rua_32_ax.rua", package = "SparseM"))) {
  X &lt;- SparseM::model.matrix(SparseM::read.matrix.hb(dfil))
  XX &lt;- sparseMatrix(j = X@ja, p = X@ia - 1L, x = X@ra, dims = X@dimension)
  validObject(XX)

  ## Alternatively, and even more user friendly :
  X. &lt;- as(X, "Matrix")  # or also
  X2 &lt;- as(X, "sparseMatrix")
  stopifnot(identical(XX, X.), identical(X., X2))
}
</code></pre>

<hr>
<h2 id='sparseMatrix-class'>Virtual Class &quot;sparseMatrix&quot; &mdash; Mother of Sparse Matrices</h2><span id='topic+sparseMatrix-class'></span><span id='topic+-+2CsparseMatrix+2Cmissing-method'></span><span id='topic+Math+2CsparseMatrix-method'></span><span id='topic+Ops+2Cnumeric+2CsparseMatrix-method'></span><span id='topic+Ops+2CsparseMatrix+2CddiMatrix-method'></span><span id='topic+Ops+2CsparseMatrix+2CldiMatrix-method'></span><span id='topic+Ops+2CsparseMatrix+2CnsparseMatrix-method'></span><span id='topic+Ops+2CsparseMatrix+2Cnumeric-method'></span><span id='topic+Ops+2CsparseMatrix+2CsparseMatrix-method'></span><span id='topic+Summary+2CsparseMatrix-method'></span><span id='topic+coerce+2CANY+2CsparseMatrix-method'></span><span id='topic+coerce+2Cfactor+2CsparseMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2CsparseMatrix-method'></span><span id='topic+cov2cor+2CsparseMatrix-method'></span><span id='topic+diff+2CsparseMatrix-method'></span><span id='topic+dim+3C-+2CsparseMatrix-method'></span><span id='topic+format+2CsparseMatrix-method'></span><span id='topic+log+2CsparseMatrix-method'></span><span id='topic+mean+2CsparseMatrix-method'></span><span id='topic+print+2CsparseMatrix-method'></span><span id='topic+rep+2CsparseMatrix-method'></span><span id='topic+show+2CsparseMatrix-method'></span><span id='topic+summary+2CsparseMatrix-method'></span><span id='topic+print.sparseMatrix'></span>

<h3>Description</h3>

<p>Virtual Mother Class of All Sparse Matrices</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>:</dt><dd><p>Object of class <code>"integer"</code> - the dimensions
of the matrix - must be an integer vector with exactly two
non-negative values.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>a list of length two - inherited from class
<code>Matrix</code>, see <code><a href="#topic+Matrix-class">Matrix</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Matrix"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>(object = "sparseMatrix")</code>: The
<code><a href="methods.html#topic+show">show</a></code> method for sparse matrices prints
<em>&ldquo;structural&rdquo;</em> zeroes as <code>"."</code> using
<code><a href="#topic+printSpMatrix">printSpMatrix</a>()</code> which allows further customization.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "sparseMatrix")</code>, ....<br />
The <code><a href="base.html#topic+print">print</a></code> method for sparse matrices by default is the
same as <code>show()</code> but can be called with extra optional
arguments, see <code><a href="#topic+printSpMatrix">printSpMatrix</a>()</code>.</p>
</dd>
<dt>format</dt><dd><p><code>signature(x = "sparseMatrix")</code>, ....<br />
The <code><a href="base.html#topic+format">format</a></code> method for sparse matrices, see
<code><a href="#topic+formatSpMatrix">formatSpMatrix</a>()</code> for details such as the extra
optional arguments.</p>
</dd>
<dt>summary</dt><dd><p><code>(object = "sparseMatrix", uniqT=FALSE)</code>: Returns
an object of S3 class <code>"sparseSummary"</code> which is basically a
<code><a href="base.html#topic+data.frame">data.frame</a></code> with columns <code>(i,j,x)</code> (or just
<code>(i,j)</code> for <code><a href="#topic+nsparseMatrix-class">nsparseMatrix</a></code> class objects)
with the stored (typically non-zero) entries.  The
<code><a href="base.html#topic+print">print</a></code> method resembles Matlab's way of printing
sparse matrices, and also the MatrixMarket format, see
<code><a href="#topic+writeMM">writeMM</a></code>.</p>
</dd>
<dt>cbind2</dt><dd><p><code>(x = *, y = *)</code>: several methods for binding
matrices together, column-wise, see the basic <code><a href="base.html#topic+cbind">cbind</a></code>
and <code><a href="base.html#topic+rbind">rbind</a></code> functions.<br />
Note that the result will typically be sparse, even when one
argument is dense and larger than the sparse one.
</p>
</dd>
<dt>rbind2</dt><dd><p><code>(x = *, y = *)</code>: binding matrices together
row-wise, see <code>cbind2</code> above.</p>
</dd>
<dt>determinant</dt><dd><p><code>(x = "sparseMatrix", logarithm=TRUE)</code>:
<code><a href="base.html#topic+determinant">determinant</a>()</code> methods for sparse matrices typically
work via <code><a href="#topic+Cholesky">Cholesky</a></code> or <code><a href="#topic+lu">lu</a></code> decompositions.</p>
</dd>
<dt>diag</dt><dd><p><code>(x = "sparseMatrix")</code>: extracts the diagonal of a
sparse matrix.</p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "sparseMatrix", value = "ANY")</code>:
allows to <em>reshape</em> a sparse matrix to a sparse matrix with
the same entries but different dimensions. <code>value</code> must be of
length two and fulfill <code>prod(value) == prod(dim(x))</code>.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "factor", to = "sparseMatrix")</code>:
Coercion of a factor to <code>"sparseMatrix"</code> produces the matrix
of indicator <b>rows</b> stored as an object of class
<code>"dgCMatrix"</code>.  To obtain columns representing the interaction
of the factor and a numeric covariate, replace the <code>"x"</code> slot
of the result by the numeric covariate then take the transpose.
Missing values (<code><a href="base.html#topic+NA">NA</a></code>) from the factor are translated
to columns of all <code>0</code>s.</p>
</dd>
</dl>

<p>See also <code><a href="#topic+colSums">colSums</a></code>, <code><a href="#topic+norm">norm</a></code>,
... 
for methods with separate help pages.
</p>


<h3>Note</h3>

<p>In method selection for multiplication operations (i.e. <code>%*%</code>
and the two-argument form of <code><a href="base.html#topic+crossprod">crossprod</a></code>)
the sparseMatrix class takes precedence in the sense that if one
operand is a sparse matrix and the other is any type of dense matrix
then the dense matrix is coerced to a <code>dgeMatrix</code> and the
appropriate sparse matrix method is used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparseMatrix">sparseMatrix</a></code>, and its references, such as
<code><a href="stats.html#topic+xtabs">xtabs</a>(*, sparse=TRUE)</code>, or
<code><a href="#topic+sparse.model.matrix">sparse.model.matrix</a>()</code>,
for constructing sparse matrices.
</p>
<p><code><a href="#topic+T2graph">T2graph</a></code> for conversion of <code>"graph"</code> objects
(package <span class="pkg">graph</span>) to and from sparse matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("sparseMatrix") ## and look at the help() of its subclasses
M &lt;- Matrix(0, 10000, 100)
M[1,1] &lt;- M[2,3] &lt;- 3.14
M  ## show(.) method suppresses printing of the majority of rows

data(CAex, package = "Matrix")
dim(CAex) # 72 x 72 matrix
determinant(CAex) # works via sparse lu(.)

## factor -&gt; t( &lt;sparse design matrix&gt; ) :
(fact &lt;- gl(5, 3, 30, labels = LETTERS[1:5]))
(Xt &lt;- as(fact, "sparseMatrix"))  # indicator rows

## missing values --&gt; all-0 columns:
f.mis &lt;- fact
i.mis &lt;- c(3:5, 17)
is.na(f.mis) &lt;- i.mis
Xt != (X. &lt;- as(f.mis, "sparseMatrix")) # differ only in columns 3:5,17
stopifnot(all(X.[,i.mis] == 0), all(Xt[,-i.mis] == X.[,-i.mis]))
</code></pre>

<hr>
<h2 id='sparseQR-class'>Sparse QR Factorizations</h2><span id='topic+sparseQR-class'></span><span id='topic+determinant+2CsparseQR+2Clogical-method'></span><span id='topic+qr.Q+2CsparseQR-method'></span><span id='topic+qr.R+2CsparseQR-method'></span><span id='topic+qr.X+2CsparseQR-method'></span><span id='topic+qr.coef+2CsparseQR+2CMatrix-method'></span><span id='topic+qr.coef+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+qr.coef+2CsparseQR+2Cmatrix-method'></span><span id='topic+qr.coef+2CsparseQR+2Cvector-method'></span><span id='topic+qr.fitted+2CsparseQR+2CMatrix-method'></span><span id='topic+qr.fitted+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+qr.fitted+2CsparseQR+2Cmatrix-method'></span><span id='topic+qr.fitted+2CsparseQR+2Cvector-method'></span><span id='topic+qr.qty+2CsparseQR+2CMatrix-method'></span><span id='topic+qr.qty+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+qr.qty+2CsparseQR+2Cmatrix-method'></span><span id='topic+qr.qty+2CsparseQR+2Cvector-method'></span><span id='topic+qr.qy+2CsparseQR+2CMatrix-method'></span><span id='topic+qr.qy+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+qr.qy+2CsparseQR+2Cmatrix-method'></span><span id='topic+qr.qy+2CsparseQR+2Cvector-method'></span><span id='topic+qr.resid+2CsparseQR+2CMatrix-method'></span><span id='topic+qr.resid+2CsparseQR+2CdgeMatrix-method'></span><span id='topic+qr.resid+2CsparseQR+2Cmatrix-method'></span><span id='topic+qr.resid+2CsparseQR+2Cvector-method'></span><span id='topic+qrR'></span>

<h3>Description</h3>

<p><code>sparseQR</code> is the class of sparse, row- and column-pivoted
QR factorizations of <code class="reqn">m \times n</code> (<code class="reqn">m \ge n</code>)
real matrices, having the general form
</p>
<p style="text-align: center;"><code class="reqn">P_1 A P_2 = Q R = \begin{bmatrix} Q_1 &amp; Q_2 \end{bmatrix} \begin{bmatrix} R_1 \\ 0 \end{bmatrix} = Q_1 R_1</code>
</p>

<p>or (equivalently)
</p>
<p style="text-align: center;"><code class="reqn">A = P_1' Q R P_2' = P_1' \begin{bmatrix} Q_1 &amp; Q_2 \end{bmatrix} \begin{bmatrix} R_1 \\ 0 \end{bmatrix} P_2' = P_1' Q_1 R_1 P_2'</code>
</p>

<p>where
<code class="reqn">P_1</code> and <code class="reqn">P_2</code> are permutation matrices,
<code class="reqn">Q = \prod_{j = 1}^{n} H_j</code>
is an <code class="reqn">m \times m</code> orthogonal matrix
(<code class="reqn">Q_1</code> contains the first <code class="reqn">n</code> column vectors)
equal to the product of <code class="reqn">n</code> Householder matrices <code class="reqn">H_j</code>, and
<code class="reqn">R</code> is an <code class="reqn">m \times n</code> upper trapezoidal matrix
(<code class="reqn">R_1</code> contains the first <code class="reqn">n</code> row vectors and is
upper <em>triangular</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrR(qr, complete = FALSE, backPermute = TRUE, row.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseQR-class_+3A_qr">qr</code></td>
<td>
<p>an object of class <code><a href="#topic+sparseQR-class">sparseQR</a></code>,
almost always the result of a call to generic function <code>qr</code>
with sparse <code>x</code>.</p>
</td></tr>
<tr><td><code id="sparseQR-class_+3A_complete">complete</code></td>
<td>
<p>a logical indicating if <code class="reqn">R</code> should be returned
instead of <code class="reqn">R_1</code>.</p>
</td></tr>
<tr><td><code id="sparseQR-class_+3A_backpermute">backPermute</code></td>
<td>
<p>a logical indicating if <code class="reqn">R</code> or <code class="reqn">R_1</code>
should be multiplied on the right by <code class="reqn">P_2'</code>.</p>
</td></tr>
<tr><td><code id="sparseQR-class_+3A_row.names">row.names</code></td>
<td>
<p>a logical indicating if <code>dimnames(qr)[1]</code>
should be propagated unpermuted to the result.
If <code>complete = FALSE</code>, then only the first <code class="reqn">n</code> names are kept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code>qr.Q</code> does not return <code class="reqn">Q</code> but rather the
(also orthogonal) product <code class="reqn">P_1' Q</code>.  This behaviour
is algebraically consistent with the <span class="pkg">base</span> implementation
(see <code><a href="base.html#topic+qr">qr</a></code>), which can be seen by noting that
<code>qr.default</code> in <span class="pkg">base</span> does not pivot rows, constraining
<code class="reqn">P_1</code> to be an identity matrix.  It follows that
<code>qr.Q(qr.default(x))</code> also returns <code class="reqn">P_1' Q</code>.
</p>
<p>Similarly, the methods for <code>qr.qy</code> and <code>qr.qty</code> multiply
on the left by <code class="reqn">P_1' Q</code> and <code class="reqn">Q' P_1</code>
rather than <code class="reqn">Q</code> and <code class="reqn">Q'</code>.
</p>
<p>It is wrong to expect the values of <code>qr.Q</code> (or <code>qr.R</code>,
<code>qr.qy</code>, <code>qr.qty</code>) computed from &ldquo;equivalent&rdquo;
sparse and dense factorizations
(say, <code>qr(x)</code> and <code>qr(as(x, "matrix"))</code> for <code>x</code>
of class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>) to compare equal.
The underlying factorization algorithms are quite different,
notably as they employ different pivoting strategies,
and in general the factorization is not unique even for fixed
<code class="reqn">P_1</code> and <code class="reqn">P_2</code>.
</p>
<p>On the other hand, the values of <code>qr.X</code>, <code>qr.coef</code>,
<code>qr.fitted</code>, and <code>qr.resid</code> are well-defined, and
in those cases the sparse and dense computations <em>should</em>
compare equal (within some tolerance).
</p>
<p>The method for <code>qr.R</code> is a simple wrapper around <code>qrR</code>,
but not back-permuting by default and never giving row names.
It did not support <code>backPermute = TRUE</code> until <span class="pkg">Matrix</span>
<code>1.6-0</code>, hence code needing the back-permuted result should
call <code>qrR</code> if <span class="pkg">Matrix</span> <code>&gt;= 1.6-0</code> is not known.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>a numeric vector of length <code>Dim[2]</code>,
used to construct Householder matrices; see <code>V</code> below.</p>
</dd>
<dt><code>V</code></dt><dd><p>an object of class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>
with <code>Dim[2]</code> columns.  The number of rows <code>nrow(V)</code>
is at least <code>Dim[1]</code> and at most <code>Dim[1]+Dim[2]</code>.
<code>V</code> is lower trapezoidal, and its column vectors generate the
Householder matrices <code class="reqn">H_j</code> that compose the orthogonal
<code class="reqn">Q</code> factor.  Specifically, <code class="reqn">H_j</code> is constructed as
<code>diag(Dim[1]) - beta[j] * tcrossprod(V[, j])</code>.</p>
</dd>
<dt><code>R</code></dt><dd><p>an object of class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>
with <code>nrow(V)</code> rows and <code>Dim[2]</code> columns.
<code>R</code> is the upper trapezoidal <code class="reqn">R</code> factor.</p>
</dd>
<dt><code>p</code>, <code>q</code></dt><dd><p>0-based integer vectors of length
<code>nrow(V)</code> and <code>Dim[2]</code>, respectively,
specifying the permutations applied to the rows and columns of
the factorized matrix.  <code>q</code> of length 0 is valid and
equivalent to the identity permutation, implying no column pivoting.
Using <span class="rlang"><b>R</b></span> syntax, the matrix <code class="reqn">P_1 A P_2</code>
is precisely <code>A[p+1, q+1]</code>
(<code>A[p+1, ]</code> when <code>q</code> has length 0).</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+QR-class">QR</a></code>, directly.
Class <code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code>, by class
<code><a href="#topic+QR-class">QR</a></code>, distance 2.
</p>


<h3>Instantiation</h3>

<p>Objects can be generated directly by calls of the form
<code>new("sparseQR", ...)</code>, but they are more typically obtained
as the value of <code><a href="#topic+qr">qr</a>(x)</code> for <code>x</code> inheriting from
<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code> (often <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>determinant</code></dt><dd><p><code>signature(from = "sparseQR", logarithm = "logical")</code>:
computes the determinant of the factorized matrix <code class="reqn">A</code>
or its logarithm.</p>
</dd>
<dt><code>expand1</code></dt><dd><p><code>signature(x = "sparseQR")</code>:
see <code><a href="#topic+expand1-methods">expand1-methods</a></code>.</p>
</dd>
<dt><code>expand2</code></dt><dd><p><code>signature(x = "sparseQR")</code>:
see <code><a href="#topic+expand2-methods">expand2-methods</a></code>.</p>
</dd>
<dt><code>qr.Q</code></dt><dd><p><code>signature(qr = "sparseQR")</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> either
<code class="reqn">P_1' Q</code> or <code class="reqn">P_1' Q_1</code>,
depending on optional argument <code>complete</code>.  The default
is <code>FALSE</code>, indicating <code class="reqn">P_1' Q_1</code>.</p>
</dd>
<dt><code>qr.R</code></dt><dd><p><code>signature(qr = "sparseQR")</code>:
<code>qrR</code> returns <code class="reqn">R</code>, <code class="reqn">R_1</code>, 
<code class="reqn">R P2'</code>, or <code class="reqn">R_1 P2'</code>,
depending on optional arguments <code>complete</code> and
<code>backPermute</code>.  The default in both cases is <code>FALSE</code>,
indicating <code class="reqn">R_1</code>, for compatibility with <span class="pkg">base</span>.  
The class of the result in that case is
<code><a href="#topic+dtCMatrix-class">dtCMatrix</a></code>.  In the other three cases,
it is <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</dd>
<dt><code>qr.X</code></dt><dd><p><code>signature(qr = "sparseQR")</code>:
returns <code class="reqn">A</code> as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code>,
by default.  If <code class="reqn">m &gt; n</code> and optional argument
<code>ncol</code> is greater than <code class="reqn">n</code>, then the result
is augmented with <code class="reqn">P_1' Q J</code>, where
<code class="reqn">J</code> is composed of columns <code class="reqn">(n+1)</code> through
<code>ncol</code> of the <code class="reqn">m \times m</code> identity matrix.</p>
</dd>
<dt><code>qr.coef</code></dt><dd><p><code>signature(qr = "sparseQR", y = .)</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> or vector
the result of multiplying <code>y</code> on the left by
<code class="reqn">P_2 R_1^{-1} Q_1' P_1</code>.</p>
</dd>
<dt><code>qr.fitted</code></dt><dd><p><code>signature(qr = "sparseQR", y = .)</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> or vector
the result of multiplying <code>y</code> on the left by
<code class="reqn">P_1' Q_1 Q_1' P_1</code>.</p>
</dd>
<dt><code>qr.resid</code></dt><dd><p><code>signature(qr = "sparseQR", y = .)</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> or vector
the result of multiplying <code>y</code> on the left by
<code class="reqn">P_1' Q_2 Q_2' P_1</code>.</p>
</dd>
<dt><code>qr.qty</code></dt><dd><p><code>signature(qr = "sparseQR", y = .)</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> or vector
the result of multiplying <code>y</code> on the left by
<code class="reqn">Q' P_1</code>.</p>
</dd>
<dt><code>qr.qy</code></dt><dd><p><code>signature(qr = "sparseQR", y = .)</code>:
returns as a <code><a href="#topic+dgeMatrix-class">dgeMatrix</a></code> or vector
the result of multiplying <code>y</code> on the left by
<code class="reqn">P_1' Q</code>.</p>
</dd>
<dt><code>solve</code></dt><dd><p><code>signature(a = "sparseQR", b = .)</code>:
see <code><a href="#topic+solve-methods">solve-methods</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Davis, T. A. (2006).
<em>Direct methods for sparse linear systems</em>.
Society for Industrial and Applied Mathematics.
<a href="https://doi.org/10.1137/1.9780898718881">doi:10.1137/1.9780898718881</a>
</p>
<p>Golub, G. H., &amp; Van Loan, C. F. (2013).
<em>Matrix computations</em> (4th ed.).
Johns Hopkins University Press.
<a href="https://doi.org/10.56021/9781421407944">doi:10.56021/9781421407944</a>
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>
<p>Generic function <code><a href="base.html#topic+qr">qr</a></code> from <span class="pkg">base</span>,
whose default method <code>qr.default</code> &ldquo;defines&rdquo;
the S3 class <code>qr</code> of dense QR factorizations.
</p>
<p><code><a href="#topic+qr-methods">qr-methods</a></code> for methods defined in <span class="pkg">Matrix</span>.
</p>
<p>Generic functions <code><a href="#topic+expand1">expand1</a></code> and <code><a href="#topic+expand2">expand2</a></code>.
</p>
<p>The many auxiliary functions for QR factorizations:
<code><a href="base.html#topic+qr.Q">qr.Q</a></code>, <code><a href="base.html#topic+qr.R">qr.R</a></code>, <code><a href="base.html#topic+qr.X">qr.X</a></code>,
<code><a href="base.html#topic+qr.coef">qr.coef</a></code>, <code><a href="base.html#topic+qr.fitted">qr.fitted</a></code>, <code><a href="base.html#topic+qr.resid">qr.resid</a></code>,
<code><a href="base.html#topic+qr.qty">qr.qty</a></code>, <code><a href="base.html#topic+qr.qy">qr.qy</a></code>, and <code><a href="base.html#topic+qr.solve">qr.solve</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("sparseQR")
set.seed(2)

m &lt;- 300L
n &lt;- 60L
A &lt;- rsparsematrix(m, n, 0.05)

## With dimnames, to see that they are propagated :
dimnames(A) &lt;- dn &lt;- list(paste0("r", seq_len(m)),
                          paste0("c", seq_len(n)))

(qr.A &lt;- qr(A))
str(e.qr.A &lt;- expand2(qr.A, complete = FALSE), max.level = 2L)
str(E.qr.A &lt;- expand2(qr.A, complete =  TRUE), max.level = 2L)

t(sapply(e.qr.A, dim))
t(sapply(E.qr.A, dim))

## Horribly inefficient, but instructive :
slowQ &lt;- function(V, beta) {
    d &lt;- dim(V)
    Q &lt;- diag(d[1L])
    if(d[2L] &gt; 0L) {
        for(j in d[2L]:1L) {
            cat(j, "\n", sep = "")
            Q &lt;- Q - (beta[j] * tcrossprod(V[, j])) %*% Q
        }
    }
    Q
}

ae1 &lt;- function(a, b, ...) all.equal(as(a, "matrix"), as(b, "matrix"), ...)
ae2 &lt;- function(a, b, ...) ae1(unname(a), unname(b), ...)

## A ~ P1' Q R P2' ~ P1' Q1 R1 P2' in floating point
stopifnot(exprs = {
    identical(names(e.qr.A), c("P1.", "Q1", "R1", "P2."))
    identical(names(E.qr.A), c("P1.", "Q" , "R" , "P2."))
    identical(e.qr.A[["P1."]],
              new("pMatrix", Dim = c(m, m), Dimnames = c(dn[1L], list(NULL)),
                  margin = 1L, perm = invertPerm(qr.A@p, 0L, 1L)))
    identical(e.qr.A[["P2."]],
              new("pMatrix", Dim = c(n, n), Dimnames = c(list(NULL), dn[2L]),
                  margin = 2L, perm = invertPerm(qr.A@q, 0L, 1L)))
    identical(e.qr.A[["R1"]], triu(E.qr.A[["R"]][seq_len(n), ]))
    identical(e.qr.A[["Q1"]],      E.qr.A[["Q"]][, seq_len(n)] )
    identical(E.qr.A[["R"]], qr.A@R)
 ## ae1(E.qr.A[["Q"]], slowQ(qr.A@V, qr.A@beta))
    ae1(crossprod(E.qr.A[["Q"]]), diag(m))
    ae1(A, with(e.qr.A, P1. %*% Q1 %*% R1 %*% P2.))
    ae1(A, with(E.qr.A, P1. %*% Q  %*% R  %*% P2.))
    ae2(A.perm &lt;- A[qr.A@p + 1L, qr.A@q + 1L], with(e.qr.A, Q1 %*% R1))
    ae2(A.perm                               , with(E.qr.A, Q  %*% R ))
})

## More identities
b &lt;- rnorm(m)
stopifnot(exprs = {
    ae1(qrX &lt;- qr.X     (qr.A   ), A)
    ae2(qrQ &lt;- qr.Q     (qr.A   ), with(e.qr.A, P1. %*% Q1))
    ae2(       qr.R     (qr.A   ), with(e.qr.A, R1))
    ae2(qrc &lt;- qr.coef  (qr.A, b), with(e.qr.A, solve(R1 %*% P2., t(qrQ)) %*% b))
    ae2(qrf &lt;- qr.fitted(qr.A, b), with(e.qr.A, tcrossprod(qrQ) %*% b))
    ae2(qrr &lt;- qr.resid (qr.A, b), b - qrf)
    ae2(qrq &lt;- qr.qy    (qr.A, b), with(E.qr.A, P1. %*% Q %*% b))
    ae2(qr.qty(qr.A, qrq), b)
})

## Sparse and dense computations should agree here
qr.Am &lt;- qr(as(A, "matrix")) # &lt;=&gt; qr.default(A)
stopifnot(exprs = {
    ae2(qrX, qr.X     (qr.Am   ))
    ae2(qrc, qr.coef  (qr.Am, b))
    ae2(qrf, qr.fitted(qr.Am, b))
    ae2(qrr, qr.resid (qr.Am, b))
})
</code></pre>

<hr>
<h2 id='sparseVector'>Sparse Vector Construction from Nonzero Entries</h2><span id='topic+sparseVector'></span>

<h3>Description</h3>

<p>User friendly construction of sparse vectors,
i.e., objects inheriting from <code><a href="base.html#topic+class">class</a></code>
<code><a href="#topic+sparseVector-class">sparseVector</a></code>, from indices and values of its
non-zero entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseVector(x, i, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseVector_+3A_x">x</code></td>
<td>
<p>vector of the non zero entries; may be missing in which case a
<code>"nsparseVector"</code> will be returned.</p>
</td></tr>
<tr><td><code id="sparseVector_+3A_i">i</code></td>
<td>
<p>integer vector (of the same length as <code>x</code>) specifying
the indices of the non-zero (or non-<code>TRUE</code>) entries of the
sparse vector.</p>
</td></tr>
<tr><td><code id="sparseVector_+3A_length">length</code></td>
<td>
<p>length of the sparse vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>zero entries in <code>x</code> are dropped automatically, analogously as
<code><a href="#topic+drop0">drop0</a>()</code> acts on sparse matrices.
</p>


<h3>Value</h3>

<p>a sparse vector, i.e., inheriting from <code><a href="base.html#topic+class">class</a></code>
<code><a href="#topic+sparseVector-class">sparseVector</a></code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparseMatrix">sparseMatrix</a>()</code> constructor for sparse matrices;
the class <code><a href="#topic+sparseVector-class">sparseVector</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(sv &lt;- sparseVector(x = 1:10, i = sample(999, 10), length=1000))

sx &lt;- c(0,0,3, 3.2, 0,0,0,-3:1,0,0,2,0,0,5,0,0)
ss &lt;- as(sx, "sparseVector")
stopifnot(identical(ss,
   sparseVector(x = c(2, -1, -2, 3, 1, -3, 5, 3.2),
                i = c(15L, 10:9, 3L,12L,8L,18L, 4L), length = 20L)))

(ns &lt;- sparseVector(i= c(7, 3, 2), length = 10))
stopifnot(identical(ns,
      new("nsparseVector", length = 10, i = c(2, 3, 7))))
</code></pre>

<hr>
<h2 id='sparseVector-class'>Sparse Vector Classes</h2><span id='topic+sparseVector-class'></span><span id='topic+nsparseVector-class'></span><span id='topic+lsparseVector-class'></span><span id='topic+isparseVector-class'></span><span id='topic+dsparseVector-class'></span><span id='topic+zsparseVector-class'></span><span id='topic++21+2CsparseVector-method'></span><span id='topic+Arith+2CsparseVector+2CddenseMatrix-method'></span><span id='topic+Arith+2CsparseVector+2CdgeMatrix-method'></span><span id='topic+Arith+2CsparseVector+2CsparseVector-method'></span><span id='topic+Logic+2CsparseVector+2CdMatrix-method'></span><span id='topic+Logic+2CsparseVector+2ClMatrix-method'></span><span id='topic+Logic+2CsparseVector+2CnMatrix-method'></span><span id='topic+Logic+2CsparseVector+2CsparseVector-method'></span><span id='topic+Math+2CsparseVector-method'></span><span id='topic+Math2+2CsparseVector-method'></span><span id='topic+Ops+2CANY+2CsparseVector-method'></span><span id='topic+Ops+2CsparseVector+2CANY-method'></span><span id='topic+Ops+2CsparseVector+2CMatrix-method'></span><span id='topic+Ops+2CsparseVector+2CsparseVector-method'></span><span id='topic+Ops+2CsparseVector+2Cvector-method'></span><span id='topic+Ops+2Cvector+2CsparseVector-method'></span><span id='topic+Summary+2CsparseVector-method'></span><span id='topic+as.array+2CsparseVector-method'></span><span id='topic+as.complex+2CsparseVector-method'></span><span id='topic+as.integer+2CsparseVector-method'></span><span id='topic+as.logical+2CsparseVector-method'></span><span id='topic+as.matrix+2CsparseVector-method'></span><span id='topic+as.numeric+2CsparseVector-method'></span><span id='topic+as.vector+2CsparseVector-method'></span><span id='topic+coerce+2CANY+2CsparseVector-method'></span><span id='topic+coerce+2Cmatrix+2CsparseVector-method'></span><span id='topic+coerce+2CsparseVector+2CCsparseMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CRsparseMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CTsparseMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CdenseMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CdsparseVector-method'></span><span id='topic+coerce+2CsparseVector+2CgeneralMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CisparseVector-method'></span><span id='topic+coerce+2CsparseVector+2ClsparseVector-method'></span><span id='topic+coerce+2CsparseVector+2CnsparseVector-method'></span><span id='topic+coerce+2CsparseVector+2CsparseMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CunpackedMatrix-method'></span><span id='topic+coerce+2CsparseVector+2CzsparseVector-method'></span><span id='topic+coerce+2Cvector+2CdsparseVector-method'></span><span id='topic+coerce+2Cvector+2CisparseVector-method'></span><span id='topic+coerce+2Cvector+2ClsparseVector-method'></span><span id='topic+coerce+2Cvector+2CnsparseVector-method'></span><span id='topic+coerce+2Cvector+2CsparseVector-method'></span><span id='topic+coerce+2Cvector+2CzsparseVector-method'></span><span id='topic+diff+2CsparseVector-method'></span><span id='topic+dim+3C-+2CsparseVector-method'></span><span id='topic+head+2CsparseVector-method'></span><span id='topic+initialize+2CsparseVector-method'></span><span id='topic+length+2CsparseVector-method'></span><span id='topic+log+2CsparseVector-method'></span><span id='topic+mean+2CsparseVector-method'></span><span id='topic+rep+2CsparseVector-method'></span><span id='topic+show+2CsparseVector-method'></span><span id='topic+sort+2CsparseVector-method'></span><span id='topic+t+2CsparseVector-method'></span><span id='topic+tail+2CsparseVector-method'></span><span id='topic+toeplitz+2CsparseVector-method'></span><span id='topic+zapsmall+2CsparseVector-method'></span><span id='topic++21+2CnsparseVector-method'></span><span id='topic+which+2CnsparseVector-method'></span><span id='topic++21+2ClsparseVector-method'></span><span id='topic+Logic+2ClsparseVector+2ClsparseVector-method'></span><span id='topic+which+2ClsparseVector-method'></span><span id='topic+-+2CdsparseVector+2Cmissing-method'></span><span id='topic+Arith+2CdsparseVector+2CdsparseVector-method'></span><span id='topic+c.sparseVector'></span>

<h3>Description</h3>

<p>Sparse Vector Classes: The virtual mother class
<code>"sparseVector"</code> has the five actual daughter classes
<code>"dsparseVector"</code>, <code>"isparseVector"</code>,
<code>"lsparseVector"</code>, <code>"nsparseVector"</code>, and
<code>"zsparseVector"</code>, where we've mainly implemented methods for
the <code>d*</code>, <code>l*</code> and <code>n*</code> ones.
</p>


<h3>Slots</h3>


<dl>
<dt><code>length</code>:</dt><dd><p>class <code>"numeric"</code> - the <code><a href="base.html#topic+length">length</a></code>
of the sparse vector.  Note that <code>"numeric"</code> can be
considerably larger than the maximal <code>"integer"</code>,
<code><a href="base.html#topic+.Machine">.Machine</a>$integer.max</code>, on purpose.</p>
</dd>
<dt><code>i</code>:</dt><dd><p>class <code>"numeric"</code> - the (1-based) indices of
the non-zero entries.  Must <em>not</em> be <code>NA</code> and strictly
sorted increasingly.
</p>
<p>Note that <code>"integer"</code> is &ldquo;part of&rdquo; <code>"numeric"</code>,
and can (and often will) be used for non-huge sparseVectors.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>(for all but <code>"nsparseVector"</code>):
the non-zero entries.  This is of class <code>"numeric"</code> for class
<code>"dsparseVector"</code>,  <code>"logical"</code> for class
<code>"lsparseVector"</code>, etc.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>length</dt><dd><p><code>signature(x = "sparseVector")</code>: simply extracts
the <code>length</code> slot.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sparseVector")</code>: The
<code><a href="methods.html#topic+show">show</a></code> method for sparse vectors prints
<em>&ldquo;structural&rdquo;</em> zeroes as <code>"."</code> using the
non-exported <code>prSpVector</code> function which allows further
customization such as replacing <code>"."</code> by <code>" "</code> (blank).
</p>
<p>Note that <code><a href="base.html#topic+options">options</a>(max.print)</code> will influence how many
entries of large sparse vectors are printed at all.</p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "sparseVector", mode = "character")</code>
coerces sparse vectors to &ldquo;regular&rdquo;, i.e., atomic vectors.
This is the same as <code>as(x, "vector")</code>.</p>
</dd>
<dt>as</dt><dd><p>..: see <code>coerce</code> below</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "sparseVector", to = "sparseMatrix")</code>, and</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "sparseMatrix", to = "sparseVector")</code>,
etc: coercions to and from sparse matrices (<code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>) are
provided and work analogously as in standard <span class="rlang"><b>R</b></span>, i.e., a vector is
coerced to a 1-column matrix.</p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "sparseVector", value = "integer")</code>
coerces a sparse vector to a sparse Matrix, i.e., an object
inheriting from <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, of the
appropriate dimension.</p>
</dd>
<dt>head</dt><dd><p><code>signature(x = "sparseVector")</code>: as with <span class="rlang"><b>R</b></span>'s
(package <span class="pkg">util</span>) <code><a href="utils.html#topic+head">head</a></code>, <code>head(x,n)</code> (for
<code class="reqn">n &gt;= 1</code>) is equivalent to <code>x[1:n]</code>, but here can be much
more efficient, see the example.</p>
</dd>
<dt>tail</dt><dd><p><code>signature(x = "sparseVector")</code>: analogous to
<code><a href="utils.html#topic+head">head</a></code>, see above.</p>
</dd>
<dt>toeplitz</dt><dd><p><code>signature(x = "sparseVector")</code>: as
<code><a href="stats.html#topic+toeplitz">toeplitz</a>(x)</code>, produce the <code class="reqn">n \times n</code>
Toeplitz matrix from <code>x</code>, where <code>n = length(x)</code>.</p>
</dd>
<dt>rep</dt><dd><p><code>signature(x = "sparseVector")</code> repeat <code>x</code>,
with the same argument list <code>(x, times, length.out, each,
	...)</code> as the default method for rep().</p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "nsparseVector")</code> and</p>
</dd>
<dt>which</dt><dd><p><code>signature(x = "lsparseVector")</code> return the
indices of the non-zero entries (which is trivial for sparse vectors).</p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "sparseVector", e2 = "*")</code>: define
arithmetic, compare and logic operations, (see
<code><a href="methods.html#topic+S4groupGeneric">Ops</a></code>).</p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "sparseVector")</code>: define
all the <code><a href="methods.html#topic+S4groupGeneric">Summary</a></code> methods.</p>
</dd>
<dt>is.na, is.finite, is.infinite</dt><dd><p><code>(x = "sparseVector")</code>, and</p>
</dd>
<dt>is.na, is.finite, is.infinite</dt><dd><p><code>(x = "nsparseVector")</code>:
return <code><a href="base.html#topic+logical">logical</a></code> or <code>"nsparseVector"</code> of the same
length as <code>x</code>, indicating if/where <code>x</code> is
<code><a href="base.html#topic+NA">NA</a></code> (or <code>NaN</code>), finite or infinite, entirely
analogously to the corresponding base <span class="rlang"><b>R</b></span> functions.</p>
</dd>
<dt>zapsmall</dt><dd><p><code>signature(x = "sparseVectors")</code>: typically used for
numeric sparse vector: <code><a href="base.html#topic+round">round</a>()</code> entries
such that (relatively) very small entries become zero exactly.</p>
</dd>
</dl>

<p><code>c.sparseVector()</code> is an S3 method for all
<code>"sparseVector"</code>s, but automatic dispatch only happens for the
first argument, so it is useful also as regular <span class="rlang"><b>R</b></span> function, see the
examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparseVector">sparseVector</a>()</code> for friendly construction of sparse
vectors (apart from <code>as(*, "sparseVector")</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getClass("sparseVector")
getClass("dsparseVector")

sx &lt;- c(0,0,3, 3.2, 0,0,0,-3:1,0,0,2,0,0,5,0,0)
(ss &lt;- as(sx, "sparseVector"))

ix &lt;- as.integer(round(sx))
(is &lt;- as(ix, "sparseVector")) ## an "isparseVector" (!)
(ns &lt;- sparseVector(i= c(7, 3, 2), length = 10)) # "nsparseVector"
## rep() works too:
(ri &lt;- rep(is, length.out= 25))

## Using `dim&lt;-`  as in base R :
r &lt;- ss
dim(r) &lt;- c(4,5) # becomes a sparse Matrix:
r
## or coercion (as as.matrix() in base R):
as(ss, "Matrix")
stopifnot(all(ss == print(as(ss, "CsparseMatrix"))))

## currently has "non-structural" FALSE -- printing as ":"
(lis &lt;- is &amp; FALSE)
(nn &lt;- is[is == 0]) # all "structural" FALSE

## NA-case
sN &lt;- sx; sN[4] &lt;- NA
(svN &lt;- as(sN, "sparseVector"))

v &lt;- as(c(0,0,3, 3.2, rep(0,9),-3,0,-1, rep(0,20),5,0),
         "sparseVector")
v &lt;- rep(rep(v, 50), 5000)
set.seed(1); v[sample(v@i, 1e6)] &lt;- 0
str(v)
system.time(for(i in 1:4) hv &lt;- head(v, 1e6))
##   user  system elapsed
##  0.033   0.000   0.032
system.time(for(i in 1:4) h2 &lt;- v[1:1e6])
##   user  system elapsed
##  1.317   0.000   1.319

stopifnot(identical(hv, h2),
          identical(is | FALSE, is != 0),
          validObject(svN), validObject(lis), as.logical(is.na(svN[4])),
          identical(is^2 &gt; 0, is &amp; TRUE),
          all(!lis), !any(lis), length(nn@i) == 0, !any(nn), all(!nn),
          sum(lis) == 0, !prod(lis), range(lis) == c(0,0))

## create and use the t(.) method:
t(x20 &lt;- sparseVector(c(9,3:1), i=c(1:2,4,7), length=20))
(T20 &lt;- toeplitz(x20))
stopifnot(is(T20, "symmetricMatrix"), is(T20, "sparseMatrix"),
          identical(unname(as.matrix(T20)),
                    toeplitz(as.vector(x20))))

## c() method for "sparseVector" - also available as regular function
(c1 &lt;- c(x20, 0,0,0, -10*x20))
(c2 &lt;- c(ns, is, FALSE))
(c3 &lt;- c(ns, !ns, TRUE, NA, FALSE))
(c4 &lt;- c(ns, rev(ns)))
## here, c() would produce a list {not dispatching to c.sparseVector()}
(c5 &lt;- c.sparseVector(0,0, x20))

## checking (consistency)
.v &lt;- as.vector
.s &lt;- function(v) as(v, "sparseVector")
stopifnot(exprs = {
    all.equal(c1, .s(c(.v(x20), 0,0,0, -10*.v(x20))),      tol = 0)
    all.equal(c2, .s(c(.v(ns), .v(is), FALSE)),            tol = 0)
    all.equal(c3, .s(c(.v(ns), !.v(ns), TRUE, NA, FALSE)), tol = 0)
    all.equal(c4, .s(c(.v(ns), rev(.v(ns)))),              tol = 0,
              check.class = FALSE)
    all.equal(c5, .s(c(0,0, .v(x20))),                     tol = 0)
})
</code></pre>

<hr>
<h2 id='spMatrix'>Sparse Matrix Constructor From Triplet</h2><span id='topic+spMatrix'></span>

<h3>Description</h3>

<p>User friendly construction of a sparse matrix (inheriting from class
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code>) from the triplet representation.
</p>
<p>This is much less flexible than <code><a href="#topic+sparseMatrix">sparseMatrix</a>()</code> and hence
somewhat <em>deprecated</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMatrix(nrow, ncol, i = integer(0L), j = integer(0L), x = double(0L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spMatrix_+3A_nrow">nrow</code>, <code id="spMatrix_+3A_ncol">ncol</code></td>
<td>
<p>integers specifying the desired number of rows and
columns.</p>
</td></tr>
<tr><td><code id="spMatrix_+3A_i">i</code>, <code id="spMatrix_+3A_j">j</code></td>
<td>
<p>integer vectors of the same length specifying the locations
of the non-zero (or non-<code>TRUE</code>) entries of the matrix.</p>
</td></tr>
<tr><td><code id="spMatrix_+3A_x">x</code></td>
<td>
<p>atomic vector of the same length as <code>i</code> and <code>j</code>,
specifying the values of the non-zero entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix in triplet form, as an <span class="rlang"><b>R</b></span> object inheriting from both
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> and
<code><a href="#topic+generalMatrix-class">generalMatrix</a></code>.
</p>
<p>The matrix <code class="reqn">M</code> will have
<code>M[i[k], j[k]] == x[k]</code>, for <code class="reqn">k = 1,2,\ldots, n</code>, where
<code>n = length(i)</code> and
<code>M[ i', j' ] == 0</code> for all other pairs <code class="reqn">(i',j')</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Matrix">Matrix</a>(*, sparse=TRUE)</code> for the more usual
constructor of such matrices.  Then, <code><a href="#topic+sparseMatrix">sparseMatrix</a></code>
is more general and flexible than <code>spMatrix()</code> and by default
returns a <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> which is often slightly
more desirable.   Further, <code><a href="#topic+bdiag">bdiag</a></code> and
<code><a href="#topic+Diagonal">Diagonal</a></code> for (block-)diagonal matrix constructors.
</p>
<p>Consider <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> and similar class
definition help files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simple example
A &lt;- spMatrix(10,20, i = c(1,3:8),
                     j = c(2,9,6:10),
                     x = 7 * (1:7))
A # a "dgTMatrix"
summary(A)
str(A) # note that *internally* 0-based indices (i,j) are used

L &lt;- spMatrix(9, 30, i = rep(1:9, 3), 1:27,
              (1:27) %% 4 != 1)
L # an "lgTMatrix"


## A simplified predecessor of  Matrix'  rsparsematrix() function :

 rSpMatrix &lt;- function(nrow, ncol, nnz,
                       rand.x = function(n) round(rnorm(nnz), 2))
 {
     ## Purpose: random sparse matrix
     ## --------------------------------------------------------------
     ## Arguments: (nrow,ncol): dimension
     ##          nnz  :  number of non-zero entries
     ##         rand.x:  random number generator for 'x' slot
     ## --------------------------------------------------------------
     ## Author: Martin Maechler, Date: 14.-16. May 2007
     stopifnot((nnz &lt;- as.integer(nnz)) &gt;= 0,
               nrow &gt;= 0, ncol &gt;= 0, nnz &lt;= nrow * ncol)
     spMatrix(nrow, ncol,
              i = sample(nrow, nnz, replace = TRUE),
              j = sample(ncol, nnz, replace = TRUE),
              x = rand.x(nnz))
 }

 M1 &lt;- rSpMatrix(100000, 20, nnz = 200)
 summary(M1)
</code></pre>

<hr>
<h2 id='subassign-methods'>Methods for &quot;[&lt;-&quot; - Assigning to Subsets for 'Matrix'</h2><span id='topic++5B+3C-'></span><span id='topic++5B+3C--methods'></span><span id='topic+subassign-methods'></span><span id='topic++5B+3C-+2CCsparseMatrix+2CMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cindex+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cindex+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CCsparseMatrix+2Cmissing+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2CANY+2CMatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2CANY+2Cmatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2Cmissing+2CMatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2Cmissing+2Cmatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2CldenseMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CMatrix+2ClsparseMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CMatrix+2Cmissing+2CANY+2CMatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2Cmissing+2CANY+2Cmatrix-method'></span><span id='topic++5B+3C-+2CMatrix+2CndenseMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CMatrix+2CnsparseMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cindex+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cindex+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CRsparseMatrix+2Cmissing+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2CMatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cindex+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cindex+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CTsparseMatrix+2Cmissing+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdenseMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdenseMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdenseMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdenseMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdenseMatrix+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cindex+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cmissing+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cindex+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cmatrix+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cmissing+2Cindex+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cmissing+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdiagonalMatrix+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CindMatrix+2Cindex+2Cindex+2CANY-method'></span><span id='topic++5B+3C-+2CindMatrix+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CindMatrix+2Cmissing+2Cindex+2CANY-method'></span><span id='topic++5B+3C-+2CindMatrix+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CsparseMatrix+2CANY+2CANY+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CsparseMatrix+2CANY+2Cmissing+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CsparseMatrix+2Cmissing+2CANY+2CsparseMatrix-method'></span><span id='topic++5B+3C-+2CsparseMatrix+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CsparseVector+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CsparseVector+2CsparseVector+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for <code>"[&lt;-"</code>, i.e., extraction or subsetting mostly of
matrices, in package <span class="pkg">Matrix</span>.
</p>
<p><b>Note</b>: Contrary to standard <code><a href="base.html#topic+matrix">matrix</a></code> assignment in
base <span class="rlang"><b>R</b></span>, in <code>x[..] &lt;- val</code> it is typically an <b>error</b> (see
<code><a href="base.html#topic+stop">stop</a></code>) when the <a href="base.html#topic+type">type</a> or <code><a href="base.html#topic+class">class</a></code> of
<code>val</code> would require the class of <code>x</code> to be changed, e.g.,
when <code>x</code> is logical, say <code>"lsparseMatrix"</code>, and <code>val</code>
is numeric.
In other cases, e.g., when <code>x</code> is a <code>"nsparseMatrix"</code> and
<code>val</code> is not <code>TRUE</code> or <code>FALSE</code>, a warning is signalled,
and <code>val</code> is &ldquo;interpreted&rdquo; as <code><a href="base.html#topic+logical">logical</a></code>, and
(logical) <code><a href="base.html#topic+NA">NA</a></code> is interpreted as <code>TRUE</code>.
</p>


<h3>Methods</h3>

<p>There are <em>many many</em> more than these:
</p>

<dl>
<dt>x = &quot;Matrix&quot;, i = &quot;missing&quot;, j = &quot;missing&quot;, value= &quot;ANY&quot;</dt><dd>
<p>is currently a simple fallback method implementation which ensures
&ldquo;readable&rdquo; error messages.</p>
</dd>
<dt>x = &quot;Matrix&quot;, i = &quot;ANY&quot;, j = &quot;ANY&quot;, value= &quot;ANY&quot;</dt><dd><p> currently
gives an error </p>
</dd>
<dt>x = &quot;denseMatrix&quot;, i = &quot;index&quot;, j = &quot;missing&quot;, value= &quot;numeric&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;denseMatrix&quot;, i = &quot;index&quot;, j = &quot;index&quot;, value= &quot;numeric&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;denseMatrix&quot;, i = &quot;missing&quot;, j = &quot;index&quot;, value= &quot;numeric&quot;</dt><dd><p> ... </p>
</dd>
</dl>



<h3>See Also</h3>


<p><code><a href="#topic++5B-methods">[-methods</a></code> for subsetting <code>"Matrix"</code> objects; the
<code><a href="#topic+index-class">index</a></code> class;
<code><a href="base.html#topic+Extract">Extract</a></code> about the standard subset assignment (and extraction).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(101)
(a &lt;- m &lt;- Matrix(round(rnorm(7*4),2), nrow = 7))

a[] &lt;- 2.2 # &lt;&lt;- replaces **every** entry
a
## as do these:
a[,] &lt;- 3 ; a[TRUE,] &lt;- 4

m[2, 3]  &lt;- 3.14 # simple number
m[3, 3:4]&lt;- 3:4  # simple numeric of length 2

## sub matrix assignment:
m[-(4:7), 3:4] &lt;- cbind(1,2:4) #-&gt; upper right corner of 'm'
m[3:5, 2:3] &lt;- 0
m[6:7, 1:2] &lt;- Diagonal(2)
m

## rows or columns only:
m[1,] &lt;- 10
m[,2] &lt;- 1:7
m[-(1:6), ] &lt;- 3:0 # not the first 6 rows, i.e. only the 7th
as(m, "sparseMatrix")
</code></pre>

<hr>
<h2 id='subscript-methods'>Methods for &quot;[&quot;: Extraction or Subsetting in Package 'Matrix'</h2><span id='topic++5B'></span><span id='topic++5B-methods'></span><span id='topic+subscript-methods'></span><span id='topic++5B+2CMatrix+2CANY+2CNULL+2CANY-method'></span><span id='topic++5B+2CMatrix+2CNULL+2CANY+2CANY-method'></span><span id='topic++5B+2CMatrix+2CNULL+2CNULL+2CANY-method'></span><span id='topic++5B+2CMatrix+2Cindex+2Cindex+2Clogical-method'></span><span id='topic++5B+2CMatrix+2Cindex+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CMatrix+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2ClMatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic++5B+2CMatrix+2Cmissing+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2Cmissing+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CMatrix+2CnMatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CabIndex+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+2CsparseVector+2CNULL+2CANY+2CANY-method'></span><span id='topic++5B+2CsparseVector+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsparseVector+2ClsparseVector+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsparseVector+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsparseVector+2CnsparseVector+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for <code>"["</code>, i.e., extraction or subsetting mostly of
matrices, in package <span class="pkg">Matrix</span>.
</p>


<h3>Methods</h3>

<p>There are more than these:
</p>

<dl>
<dt>x = &quot;Matrix&quot;, i = &quot;missing&quot;, j = &quot;missing&quot;, drop= &quot;ANY&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;Matrix&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop= &quot;missing&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;Matrix&quot;, i = &quot;missing&quot;, j = &quot;numeric&quot;, drop= &quot;missing&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;dsparseMatrix&quot;, i = &quot;missing&quot;, j = &quot;numeric&quot;, drop= &quot;logical&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;dsparseMatrix&quot;, i = &quot;numeric&quot;, j = &quot;missing&quot;, drop= &quot;logical&quot;</dt><dd><p> ... </p>
</dd>
<dt>x = &quot;dsparseMatrix&quot;, i = &quot;numeric&quot;, j = &quot;numeric&quot;, drop= &quot;logical&quot;</dt><dd><p> ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic++5B+3C--methods">[&lt;&ndash;methods</a></code> for sub<em>assign</em>ment to <code>"Matrix"</code>
objects.
<code><a href="base.html#topic+Extract">Extract</a></code> about the standard extraction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(m &lt;- Matrix(round(rnorm(7*4),2), nrow = 7))
stopifnot(identical(m, m[]))
m[2, 3]   # simple number
m[2, 3:4] # simple numeric of length 2
m[2, 3:4, drop=FALSE] # sub matrix of class 'dgeMatrix'
## rows or columns only:
m[1,]     # first row, as simple numeric vector
m[,1:2]   # sub matrix of first two columns

showMethods("[", inherited = FALSE)
</code></pre>

<hr>
<h2 id='symmetricMatrix-class'>Virtual Class of Symmetric Matrices in Package Matrix</h2><span id='topic+symmetricMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CsymmetricMatrix-method'></span><span id='topic+dimnames+2CsymmetricMatrix-method'></span><span id='topic+dimnames+3C-+2CsymmetricMatrix+2CNULL-method'></span><span id='topic+dimnames+3C-+2CsymmetricMatrix+2Clist-method'></span>

<h3>Description</h3>

<p>The virtual class of symmetric matrices, <code>"symmetricMatrix"</code>,
from the package <span class="pkg">Matrix</span> contains numeric and logical, dense and
sparse matrices, e.g., see the examples with the &ldquo;actual&rdquo;
subclasses.
</p>
<p>The main use is in methods (and C functions) that can deal with
all symmetric matrices, and in <code>as(*, "symmetricMatrix")</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim, Dimnames</code></dt><dd><p>inherited from virtual class
<code><a href="#topic+Matrix-class">Matrix</a></code>.  See comments below about
symmetry of <code>Dimnames</code>.</p>
</dd>
<dt><code>factors</code></dt><dd><p>a list of
<code><a href="#topic+MatrixFactorization-class">MatrixFactorization</a></code> objects caching
factorizations of the matrix.  Typically, it is initialized
as an empty list and updated &ldquo;automagically&rdquo; whenever
a factorization is computed.</p>
</dd>
<dt><code>uplo</code></dt><dd><p>a character string, either <code>"U"</code> or
<code>"L"</code> indicating that only entries in the upper or lower
triangle are referenced.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Matrix"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>dimnames</dt><dd><p><code>signature(object = "symmetricMatrix")</code>:
returns <em>symmetric</em> <code><a href="base.html#topic+dimnames">dimnames</a></code>, even when the
<code>Dimnames</code> slot only has row or column names.  This allows to
save storage for large (typically sparse) symmetric matrices.</p>
</dd>
<dt>isSymmetric</dt><dd><p><code>signature(object = "symmetricMatrix")</code>:
returns <code>TRUE</code> trivially.</p>
</dd>
</dl>

<p>There's a C function <code>symmetricMatrix_validate()</code>
called by the internal validity checking functions, and also from
<code><a href="methods.html#topic+getValidity">getValidity</a>(getClass("symmetricMatrix"))</code>.
</p>


<h3>Validity and <code><a href="base.html#topic+dimnames">dimnames</a></code></h3>

<p>The validity checks do not require a symmetric <code>Dimnames</code> slot,
so it can be <code>list(NULL, &lt;character&gt;)</code>, e.g., for efficiency.
However, <code><a href="base.html#topic+dimnames">dimnames</a>()</code> and other functions and methods
should behave as if the dimnames were symmetric, i.e., with both list
components identical.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isSymmetric">isSymmetric</a></code> which has efficient methods
(<a href="#topic+isSymmetric-methods">isSymmetric-methods</a>) for the <span class="pkg">Matrix</span> classes.
Classes <code><a href="#topic+triangularMatrix-class">triangularMatrix</a></code>, and, e.g.,
<code><a href="#topic+dsyMatrix-class">dsyMatrix</a></code> for numeric <em>dense</em> matrices, or
<code><a href="#topic+lsCMatrix-class">lsCMatrix</a></code> for a logical <em>sparse</em> matrix class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An example about the symmetric Dimnames:
sy &lt;- sparseMatrix(i= c(2,4,3:5), j= c(4,7:5,5), x = 1:5, dims = c(7,7),
                   symmetric=TRUE, dimnames = list(NULL, letters[1:7]))
sy # shows symmetrical dimnames
sy@Dimnames  # internally only one part is stored
dimnames(sy) # both parts - as sy *is* symmetrical

showClass("symmetricMatrix")

## The names of direct subclasses:
scl &lt;- getClass("symmetricMatrix")@subclasses
directly &lt;- sapply(lapply(scl, slot, "by"), length) == 0
names(scl)[directly]

## Methods -- applicaple to all subclasses above:
showMethods(classes = "symmetricMatrix")
</code></pre>

<hr>
<h2 id='symmpart-methods'>Symmetric Part and Skew(symmetric) Part of a Matrix</h2><span id='topic+symmpart'></span><span id='topic+symmpart-methods'></span><span id='topic+skewpart'></span><span id='topic+skewpart-methods'></span><span id='topic+symmpart+2CCsparseMatrix-method'></span><span id='topic+symmpart+2CRsparseMatrix-method'></span><span id='topic+symmpart+2CTsparseMatrix-method'></span><span id='topic+symmpart+2CdenseMatrix-method'></span><span id='topic+symmpart+2CdiagonalMatrix-method'></span><span id='topic+symmpart+2CindMatrix-method'></span><span id='topic+symmpart+2Cmatrix-method'></span><span id='topic+skewpart+2CCsparseMatrix-method'></span><span id='topic+skewpart+2CRsparseMatrix-method'></span><span id='topic+skewpart+2CTsparseMatrix-method'></span><span id='topic+skewpart+2CdenseMatrix-method'></span><span id='topic+skewpart+2CdiagonalMatrix-method'></span><span id='topic+skewpart+2CindMatrix-method'></span><span id='topic+skewpart+2Cmatrix-method'></span>

<h3>Description</h3>

<p><code>symmpart(x)</code> computes the symmetric part <code>(x + t(x))/2</code> and
<code>skewpart(x)</code> the
skew symmetric part <code>(x - t(x))/2</code> of a square matrix <code>x</code>,
more efficiently for specific Matrix classes.
</p>
<p>Note that <code>x == symmpart(x) + skewpart(x)</code> for all square
matrices &ndash; apart from extraneous <code><a href="base.html#topic+NA">NA</a></code> values in the RHS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmpart(x)
skewpart(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmpart-methods_+3A_x">x</code></td>
<td>
<p>a <em>square</em> matrix; either &ldquo;traditional&rdquo; of class
<code>"matrix"</code>, or typically, inheriting from the
<code><a href="#topic+Matrix-class">Matrix</a></code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are generic functions with several methods for different matrix
classes, use e.g., <code><a href="methods.html#topic+showMethods">showMethods</a>(symmpart)</code> to see them.
</p>
<p>If the row and column names differ, the result will use the column
names unless they are (partly) <code>NULL</code> where the row names are
non-<code>NULL</code> (see also the examples).
</p>


<h3>Value</h3>

<p><code>symmpart(x)</code> returns a symmetric matrix,
inheriting from <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>
or <code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code> if <code>x</code>
inherits from <code>Matrix</code>.
</p>
<p><code>skewpart(x)</code> returns a skew-symmetric matrix,
inheriting from <code><a href="#topic+generalMatrix-class">generalMatrix</a></code>,
<code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code> or
<code><a href="#topic+diagonalMatrix-class">diagonalMatrix</a></code> if <code>x</code>
inherits from <code>Matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isSymmetric">isSymmetric</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- Matrix(1:4, 2,2)
symmpart(m)
skewpart(m)

stopifnot(all(m == symmpart(m) + skewpart(m)))

dn &lt;- dimnames(m) &lt;- list(row = c("r1", "r2"), col = c("var.1", "var.2"))
stopifnot(all(m == symmpart(m) + skewpart(m)))
colnames(m) &lt;- NULL
stopifnot(all(m == symmpart(m) + skewpart(m)))
dimnames(m) &lt;- unname(dn)
stopifnot(all(m == symmpart(m) + skewpart(m)))


## investigate the current methods:
showMethods(skewpart, include = TRUE)
</code></pre>

<hr>
<h2 id='triangularMatrix-class'>Virtual Class of Triangular Matrices in Package Matrix</h2><span id='topic+triangularMatrix-class'></span><span id='topic+Arith+2CtriangularMatrix+2CdiagonalMatrix-method'></span><span id='topic+Compare+2CtriangularMatrix+2CdiagonalMatrix-method'></span><span id='topic+Logic+2CtriangularMatrix+2CdiagonalMatrix-method'></span><span id='topic+coerce+2Cmatrix+2CtriangularMatrix-method'></span><span id='topic+determinant+2CtriangularMatrix+2Clogical-method'></span>

<h3>Description</h3>

<p>The virtual class of triangular matrices,<code>"triangularMatrix"</code>,
the package <span class="pkg">Matrix</span> contains <em>square</em> (<code><a href="base.html#topic+nrow">nrow</a> ==
    <a href="base.html#topic+ncol">ncol</a></code>) numeric and logical, dense and sparse matrices, e.g.,
see the examples.
A main use of the virtual class is in methods (and C functions) that
can deal with all triangular matrices.
</p>


<h3>Slots</h3>


<dl>
<dt><code>uplo</code>:</dt><dd><p>String (of class <code>"character"</code>).  Must be
either &quot;U&quot;, for upper triangular, and &quot;L&quot;, for lower triangular.</p>
</dd>
<dt><code>diag</code>:</dt><dd><p>String (of class <code>"character"</code>).  Must be
either <code>"U"</code>, for unit triangular (diagonal is all ones), or
<code>"N"</code> for non-unit.  The diagonal elements are not
accessed internally when <code>diag</code> is <code>"U"</code>. For
<code><a href="#topic+denseMatrix-class">denseMatrix</a></code> classes, they need to be
allocated though, such that the length of the <code>x</code> slot does not
depend on <code>diag</code>.</p>
</dd>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>The dimension (a length-2
<code>"integer"</code>) and corresponding names (or <code>NULL</code>),
inherited from the <code><a href="#topic+Matrix-class">Matrix</a></code>, see there.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"Matrix"</code>, directly.
</p>


<h3>Methods</h3>

<p>There's a C function <code>triangularMatrix_validity()</code>
called by the internal validity checking functions.
</p>
<p>Currently, <code><a href="#topic+Schur">Schur</a></code>, <code><a href="#topic+isSymmetric">isSymmetric</a></code> and
<code>as()</code> (i.e. <code><a href="methods.html#topic+coerce">coerce</a></code>) have methods with
<code>triangularMatrix</code> in their signature.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isTriangular">isTriangular</a>()</code> for testing any matrix for triangularity;
classes <code><a href="#topic+symmetricMatrix-class">symmetricMatrix</a></code>, and, e.g.,
<code><a href="#topic+dtrMatrix-class">dtrMatrix</a></code> for numeric <em>dense</em> matrices, or
<code><a href="#topic+ltCMatrix-class">ltCMatrix</a></code> for a logical <em>sparse</em> matrix
subclass of <code>"triangularMatrix"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("triangularMatrix")

## The names of direct subclasses:
scl &lt;- getClass("triangularMatrix")@subclasses
directly &lt;- sapply(lapply(scl, slot, "by"), length) == 0
names(scl)[directly]

(m &lt;- matrix(c(5,1,0,3), 2))
as(m, "triangularMatrix")
</code></pre>

<hr>
<h2 id='TsparseMatrix-class'>Class &quot;TsparseMatrix&quot; of Sparse Matrices in Triplet Form</h2><span id='topic+TsparseMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic+coerce+2Cvector+2CTsparseMatrix-method'></span><span id='topic+diag+2CTsparseMatrix-method'></span><span id='topic+diag+3C-+2CTsparseMatrix-method'></span><span id='topic+t+2CTsparseMatrix-method'></span>

<h3>Description</h3>

<p>The <code>"TsparseMatrix"</code> class is the virtual class of
all sparse matrices coded in triplet form.  Since it is a virtual class,
no objects may be created from it.  See
<code>showClass("TsparseMatrix")</code> for its subclasses.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>from the <code>"<a href="#topic+Matrix-class">Matrix</a>"</code> class,</p>
</dd>
<dt><code>i</code>:</dt><dd><p>Object of class <code>"integer"</code> - the row indices
of non-zero entries <em>in 0-base</em>, i.e., must be in
<code>0:(nrow(.)-1)</code>.</p>
</dd>
<dt><code>j</code>:</dt><dd><p>Object of class <code>"integer"</code> - the column
indices of non-zero entries.  Must be the same length as slot
<code>i</code> and <em>0-based</em> as well, i.e., in
<code>0:(ncol(.)-1)</code>.   For numeric Tsparse matrices, <code>(i,j)</code>
pairs can occur more than once, see <code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code>.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"sparseMatrix"</code>, directly.
Class <code>"Matrix"</code>, by class <code>"sparseMatrix"</code>.
</p>


<h3>Methods</h3>

<p>Extraction (<code>"["</code>) methods, see
<code><a href="#topic++5B-methods">[-methods</a></code>.
</p>


<h3>Note</h3>

<p>Most operations with sparse matrices are performed using the
compressed, column-oriented or <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code>
representation.  The triplet representation is convenient for
creating a sparse matrix or for reading and writing such
matrices.  Once it is created, however, the matrix is generally
coerced to a <code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> for further
operations.
</p>
<p>Note that all <code>new(.)</code>, <code><a href="#topic+spMatrix">spMatrix</a></code> and
<code><a href="#topic+sparseMatrix">sparseMatrix</a>(*, repr="T")</code> constructors
for <code>"TsparseMatrix"</code> classes implicitly add (i.e., &ldquo;sum up&rdquo;)
<code class="reqn">x_k</code>'s that belong to identical <code class="reqn">(i_k, j_k)</code> pairs, see, the
example below, or also <code>"<a href="#topic+dgTMatrix-class">dgTMatrix</a>"</code>.
</p>
<p>For convenience, methods for some operations such as <code>%*%</code>
and <code>crossprod</code> are defined for
<code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> objects.  These methods simply
coerce the <code><a href="#topic+TsparseMatrix-class">TsparseMatrix</a></code> object to a
<code><a href="#topic+CsparseMatrix-class">CsparseMatrix</a></code> object then perform the
operation.
</p>


<h3>See Also</h3>

<p>its superclass, <code><a href="#topic+sparseMatrix-class">sparseMatrix</a></code>, and the
<code><a href="#topic+dgTMatrix-class">dgTMatrix</a></code> class, for the links to other classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TsparseMatrix")
## or just the subclasses' names
names(getClass("TsparseMatrix")@subclasses)

T3 &lt;- spMatrix(3,4, i=c(1,3:1), j=c(2,4:2), x=1:4)
T3 # only 3 non-zero entries, 5 = 1+4 !

</code></pre>

<hr>
<h2 id='unpackedMatrix-class'>Virtual Class <code>"unpackedMatrix"</code> of Unpacked Dense Matrices</h2><span id='topic+unpackedMatrix-class'></span><span id='topic+coerce+2Cmatrix+2CunpackedMatrix-method'></span><span id='topic+coerce+2Cvector+2CunpackedMatrix-method'></span><span id='topic+cov2cor+2CunpackedMatrix-method'></span>

<h3>Description</h3>

<p>Class <code>"unpackedMatrix"</code> is the <em>virtual</em> class of dense
matrices in &quot;unpacked&quot; format, storing all <code>m*n</code> elements of
an <code>m</code>-by-<code>n</code> matrix. It is used to define common methods
for efficient subsetting, transposing, etc. of its <em>proper</em>
subclasses: currently <code>"[dln]geMatrix"</code> (unpacked general),
<code>"[dln]syMatrix"</code> (unpacked symmetric), <code>"[dln]trMatrix"</code>
(unpacked triangular), and subclasses of these, such as
<code>"<a href="#topic+dpoMatrix-class">dpoMatrix</a>"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Dim</code>, <code>Dimnames</code>:</dt><dd><p>as all <code><a href="#topic+Matrix-class">Matrix</a></code> objects.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+denseMatrix-class">denseMatrix</a>"</code>, directly.
Class <code>"<a href="#topic+Matrix-class">Matrix</a>"</code>, by class <code>"denseMatrix"</code>,
distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>pack</dt><dd><p><code>signature(x = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>unpack</dt><dd><p><code>signature(x = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>isSymmetric</dt><dd><p><code>signature(object = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>isTriangular</dt><dd><p><code>signature(object = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>isDiagonal</dt><dd><p><code>signature(object = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "unpackedMatrix")</code>: ... </p>
</dd>
<dt>diag&lt;-</dt><dd><p><code>signature(x = "unpackedMatrix")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Mikael Jagan</p>


<h3>See Also</h3>

<p><code><a href="#topic+pack">pack</a></code> and <code><a href="#topic+unpack">unpack</a></code>; its virtual &quot;complement&quot;
<code>"<a href="#topic+packedMatrix-class">packedMatrix</a>"</code>; its proper subclasses
<code>"<a href="#topic+dsyMatrix-class">dsyMatrix</a>"</code>, <code>"<a href="#topic+ltrMatrix-class">ltrMatrix</a>"</code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("unpackedMatrix")
showMethods(classes = "unpackedMatrix")
</code></pre>

<hr>
<h2 id='updown-methods'>Updating and Downdating Sparse Cholesky Factorizations</h2><span id='topic+updown'></span><span id='topic+updown-methods'></span><span id='topic+updown+2Ccharacter+2CANY+2CANY-method'></span><span id='topic+updown+2Clogical+2CMatrix+2CCHMfactor-method'></span><span id='topic+updown+2Clogical+2CdgCMatrix+2CCHMfactor-method'></span><span id='topic+updown+2Clogical+2CdsCMatrix+2CCHMfactor-method'></span><span id='topic+updown+2Clogical+2CdtCMatrix+2CCHMfactor-method'></span><span id='topic+updown+2Clogical+2Cmatrix+2CCHMfactor-method'></span>

<h3>Description</h3>

<p>Computes a rank-<code class="reqn">k</code> update or downdate of a sparse Cholesky
factorization
</p>
<p style="text-align: center;"><code class="reqn">P_{1} A P_{1}' = L_{1} D L_{1}' = L L'</code>
</p>

<p>which for some <code class="reqn">k</code>-column matrix <code class="reqn">C</code> is the factorization
</p>
<p style="text-align: center;"><code class="reqn">P_{1} (A + s C C') P_{1}' = \tilde{L}_{1} \tilde{D} \tilde{L}_{1}' = \tilde{L} \tilde{L}'</code>
</p>

<p>Here, <code class="reqn">s = 1</code> for an update and <code class="reqn">s = -1</code> for a downdate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updown(update, C, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updown-methods_+3A_update">update</code></td>
<td>
<p>a logical (<code>TRUE</code> or <code>FALSE</code>) or
character (<code>"+"</code> or <code>"-"</code>) indicating if <code>L</code>
should be updated (or otherwise downdated).</p>
</td></tr>
<tr><td><code id="updown-methods_+3A_c">C</code></td>
<td>
<p>a <a href="#topic+is.finite">finite</a> matrix or
<code><a href="#topic+Matrix-class">Matrix</a></code> such that
<code><a href="#topic+tcrossprod">tcrossprod</a>(C)</code> has the dimensions of <code>L</code>.</p>
</td></tr>
<tr><td><code id="updown-methods_+3A_l">L</code></td>
<td>
<p>an object of class <code><a href="#topic+dCHMsimpl-class">dCHMsimpl</a></code> or
<code><a href="#topic+dCHMsuper-class">dCHMsuper</a></code> specifying a sparse Cholesky
factorization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse Cholesky factorization with dimensions matching <code>L</code>,
typically of class <code><a href="#topic+dCHMsimpl-class">dCHMsimpl</a></code>.
</p>


<h3>Author(s)</h3>

<p>Initial implementation by Nicholas Nagle, University of Tennessee.</p>


<h3>References</h3>

<p>Davis, T. A., Hager, W. W. (2001).
Multiple-rank modifications of a sparse Cholesky factorization.
<em>SIAM Journal on Matrix Analysis and Applications</em>,
<em>22</em>(4), 997-1013.
<a href="https://doi.org/10.1137/S0895479899357346">doi:10.1137/S0895479899357346</a>
</p>


<h3>See Also</h3>

<p>Classes
<code><a href="#topic+dCHMsimpl-class">dCHMsimpl</a></code> and <code><a href="#topic+dCHMsuper-class">dCHMsuper</a></code>
and their methods, notably for generic function <code><a href="stats.html#topic+update">update</a></code>,
which is <em>not</em> equivalent to <code>updown(update = TRUE)</code>.
</p>
<p>Generic function <code><a href="#topic+Cholesky">Cholesky</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- sparseMatrix(i = c(3, 1, 3:2, 2:1), p = c(0:2, 4, 4, 6), x = 1:6,
                  dimnames = list(LETTERS[1:3], letters[1:5]))
uc0 &lt;- Cholesky(A &lt;- crossprod(m) + Diagonal(5))
uc1 &lt;- updown("+", Diagonal(5, 1), uc0)
uc2 &lt;- updown("-", Diagonal(5, 1), uc1)
stopifnot(all.equal(uc0, uc2))

</code></pre>

<hr>
<h2 id='USCounties'>Contiguity Matrix of U.S. Counties</h2><span id='topic+USCounties'></span>

<h3>Description</h3>

<p>This matrix gives the contiguities of 3111 U.S. counties,
using the queen criterion of at least one shared vertex
or edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USCounties)</code></pre>


<h3>Format</h3>

<p>A <code class="reqn">3111 \times 3111</code> sparse, symmetric
matrix of class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>, with 9101
nonzero entries.
</p>


<h3>Source</h3>

<p>GAL lattice file &lsquo;<span class="file">usc_q.GAL</span>&rsquo;
(retrieved in 2008 from
&lsquo;<span class="file">http://sal.uiuc.edu/weights/zips/usc.zip</span>&rsquo;
with permission from Luc Anselin for use and distribution)
was read into <span class="rlang"><b>R</b></span> using function <code>read.gal</code>
from package <a href="https://CRAN.R-project.org/package=spdep"><span class="pkg">spdep</span></a>.
</p>
<p>Neighbour lists were augmented with row-standardized
(and then symmetrized) spatial weights, using functions
<code>nb2listw</code> and <code>similar.listw</code> from packages
<a href="https://CRAN.R-project.org/package=spdep"><span class="pkg">spdep</span></a> and <a href="https://CRAN.R-project.org/package=spatialreg"><span class="pkg">spatialreg</span></a>.
The resulting <code>listw</code> object was coerced to class
<code><a href="#topic+dsTMatrix-class">dsTMatrix</a></code>
using <code>as_dsTMatrix_listw</code> from <a href="https://CRAN.R-project.org/package=spatialreg"><span class="pkg">spatialreg</span></a>,
and subsequently to class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>.
</p>


<h3>References</h3>

<p>Ord, J. K. (1975).
Estimation methods for models of spatial interaction.
<em>Journal of the American Statistical Association</em>,
<em>70</em>(349), 120-126.
<a href="https://doi.org/10.2307/2285387">doi:10.2307/2285387</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USCounties, package = "Matrix")
(n &lt;- ncol(USCounties))
I &lt;- .symDiagonal(n)

set.seed(1)
r &lt;- 50L
rho &lt;- 1 / runif(r, 0, 0.5)

system.time(MJ0 &lt;- sapply(rho, function(mult)
    determinant(USCounties + mult * I, logarithm = TRUE)$modulus))

## Can be done faster by updating the Cholesky factor:

C1 &lt;- Cholesky(USCounties, Imult = 2)
system.time(MJ1 &lt;- sapply(rho, function(mult)
    determinant(update(C1, USCounties, mult), sqrt = FALSE)$modulus))
stopifnot(all.equal(MJ0, MJ1))

C2 &lt;- Cholesky(USCounties, super = TRUE, Imult = 2)
system.time(MJ2 &lt;- sapply(rho, function(mult)
    determinant(update(C2, USCounties, mult), sqrt = FALSE)$modulus))
stopifnot(all.equal(MJ0, MJ2))
</code></pre>

<hr>
<h2 id='wrld_1deg'>Contiguity Matrix of World One-Degree Grid Cells</h2><span id='topic+wrld_1deg'></span>

<h3>Description</h3>

<p>This matrix gives the contiguities of 15260 one-degree
grid cells of world land areas, using a criterion based
on the great-circle distance between centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wrld_1deg)</code></pre>


<h3>Format</h3>

<p>A <code class="reqn">15260 \times 15260</code> sparse, symmetric
matrix of class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>, with 55973
nonzero entries.
</p>


<h3>Source</h3>

<p>Shoreline data were read into <span class="rlang"><b>R</b></span> from the GSHHS database
using function <code>Rgshhs</code> from package <a href="https://CRAN.R-project.org/package=maptools"><span class="pkg">maptools</span></a>.
Antarctica was excluded.  An approximately one-degree grid
was generated using function <code>Sobj_SpatialGrid</code>, also
from <a href="https://CRAN.R-project.org/package=maptools"><span class="pkg">maptools</span></a>.  Grid cells with centers on land
were identified using the <code>over</code> method for classes
<code>SpatialPolygons</code> and <code>SpatialGrid</code>, defined in
package <a href="https://CRAN.R-project.org/package=sp"><span class="pkg">sp</span></a>.  Neighbours of these were identified
by passing the resulting <code>SpatialPixels</code> object to
function <code>dnearneigh</code> from package <a href="https://CRAN.R-project.org/package=spdep"><span class="pkg">spdep</span></a>,
using as a cut-off a great-circle distance of <code>sqrt(2)</code>
kilometers between centers.
</p>
<p>Neighbour lists were augmented with row-standardized
(and then symmetrized) spatial weights, using functions
<code>nb2listw</code> and <code>similar.listw</code> from packages
<a href="https://CRAN.R-project.org/package=spdep"><span class="pkg">spdep</span></a> and <a href="https://CRAN.R-project.org/package=spatialreg"><span class="pkg">spatialreg</span></a>.
The resulting <code>listw</code> object was coerced to class
<code><a href="#topic+dsTMatrix-class">dsTMatrix</a></code>
using <code>as_dsTMatrix_listw</code> from <a href="https://CRAN.R-project.org/package=spatialreg"><span class="pkg">spatialreg</span></a>,
and subsequently to class <code><a href="#topic+dsCMatrix-class">dsCMatrix</a></code>.
</p>


<h3>References</h3>

<p>Ord, J. K. (1975).
Estimation methods for models of spatial interaction.
<em>Journal of the American Statistical Association</em>,
<em>70</em>(349), 120-126.
<a href="https://doi.org/10.2307/2285387">doi:10.2307/2285387</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wrld_1deg, package = "Matrix")
(n &lt;- ncol(wrld_1deg))
I &lt;- .symDiagonal(n)

doExtras &lt;- interactive() || nzchar(Sys.getenv("R_MATRIX_CHECK_EXTRA"))
set.seed(1)
r &lt;- if(doExtras) 20L else 3L
rho &lt;- 1 / runif(r, 0, 0.5)

system.time(MJ0 &lt;- sapply(rho, function(mult)
    determinant(wrld_1deg + mult * I, logarithm = TRUE)$modulus))

## Can be done faster by updating the Cholesky factor:

C1 &lt;- Cholesky(wrld_1deg, Imult = 2)
system.time(MJ1 &lt;- sapply(rho, function(mult)
    determinant(update(C1, wrld_1deg, mult), sqrt = FALSE)$modulus))
stopifnot(all.equal(MJ0, MJ1))

C2 &lt;- Cholesky(wrld_1deg, super = TRUE, Imult = 2)
system.time(MJ2 &lt;- sapply(rho, function(mult)
    determinant(update(C2, wrld_1deg, mult), sqrt = FALSE)$modulus))
stopifnot(all.equal(MJ0, MJ2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
