<!DOCTYPE html><html><head><title>Help for package forecast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy.default'><p>Accuracy measures for a forecast model</p></a></li>
<li><a href='#Acf'><p>(Partial) Autocorrelation and Cross-Correlation Function Estimation</p></a></li>
<li><a href='#arfima'><p>Fit a fractionally differenced ARFIMA model</p></a></li>
<li><a href='#Arima'><p>Fit ARIMA model to univariate time series</p></a></li>
<li><a href='#arima.errors'><p>Errors from a regression model with ARIMA errors</p></a></li>
<li><a href='#arimaorder'><p>Return the order of an ARIMA or ARFIMA model</p></a></li>
<li><a href='#auto.arima'><p>Fit best ARIMA model to univariate time series</p></a></li>
<li><a href='#autolayer'><p>Create a ggplot layer appropriate to a particular data type</p></a></li>
<li><a href='#autolayer.mts'><p>Automatically create a ggplot for time series objects</p></a></li>
<li><a href='#autoplot.acf'><p>ggplot (Partial) Autocorrelation and Cross-Correlation Function Estimation</p>
and Plotting</a></li>
<li><a href='#autoplot.decomposed.ts'><p>Plot time series decomposition components using ggplot</p></a></li>
<li><a href='#autoplot.mforecast'><p>Multivariate forecast plot</p></a></li>
<li><a href='#baggedModel'><p>Forecasting using a bagged model</p></a></li>
<li><a href='#bats'><p>BATS model (Exponential smoothing state space model with Box-Cox</p>
transformation, ARMA errors, Trend and Seasonal components)</a></li>
<li><a href='#bizdays'><p>Number of trading days in each season</p></a></li>
<li><a href='#bld.mbb.bootstrap'><p>Box-Cox and Loess-based decomposition bootstrap.</p></a></li>
<li><a href='#BoxCox'><p>Box Cox Transformation</p></a></li>
<li><a href='#BoxCox.lambda'><p>Automatic selection of Box Cox transformation parameter</p></a></li>
<li><a href='#checkresiduals'><p>Check that residuals from a time series model look like white noise</p></a></li>
<li><a href='#croston'><p>Forecasts for intermittent demand using Croston's method</p></a></li>
<li><a href='#CV'><p>Cross-validation statistic</p></a></li>
<li><a href='#CVar'><p>k-fold Cross-Validation applied to an autoregressive model</p></a></li>
<li><a href='#dm.test'><p>Diebold-Mariano test for predictive accuracy</p></a></li>
<li><a href='#dshw'><p>Double-Seasonal Holt-Winters Forecasting</p></a></li>
<li><a href='#easter'><p>Easter holidays in each season</p></a></li>
<li><a href='#ets'><p>Exponential smoothing state space model</p></a></li>
<li><a href='#findfrequency'><p>Find dominant frequency of a time series</p></a></li>
<li><a href='#fitted.ARFIMA'><p>h-step in-sample forecasts for time series models.</p></a></li>
<li><a href='#forecast-package'><p>forecast: Forecasting Functions for Time Series and Linear Models</p></a></li>
<li><a href='#forecast.baggedModel'><p>Forecasting using a bagged model</p></a></li>
<li><a href='#forecast.bats'><p>Forecasting using BATS and TBATS models</p></a></li>
<li><a href='#forecast.ets'><p>Forecasting using ETS models</p></a></li>
<li><a href='#forecast.fracdiff'><p>Forecasting using ARIMA or ARFIMA models</p></a></li>
<li><a href='#forecast.HoltWinters'><p>Forecasting using Holt-Winters objects</p></a></li>
<li><a href='#forecast.lm'><p>Forecast a linear model with possible time series components</p></a></li>
<li><a href='#forecast.mlm'><p>Forecast a multiple linear model with possible time series components</p></a></li>
<li><a href='#forecast.modelAR'><p>Forecasting using user-defined model</p></a></li>
<li><a href='#forecast.mts'><p>Forecasting time series</p></a></li>
<li><a href='#forecast.nnetar'><p>Forecasting using neural network models</p></a></li>
<li><a href='#forecast.stl'><p>Forecasting using stl objects</p></a></li>
<li><a href='#forecast.StructTS'><p>Forecasting using Structural Time Series models</p></a></li>
<li><a href='#forecast.ts'><p>Forecasting time series</p></a></li>
<li><a href='#fourier'><p>Fourier terms for modelling seasonality</p></a></li>
<li><a href='#gas'><p>Australian monthly gas production</p></a></li>
<li><a href='#getResponse'><p>Get response variable from time series model.</p></a></li>
<li><a href='#gghistogram'><p>Histogram with optional normal and kernel density functions</p></a></li>
<li><a href='#gglagplot'><p>Time series lag ggplots</p></a></li>
<li><a href='#ggmonthplot'><p>Create a seasonal subseries ggplot</p></a></li>
<li><a href='#ggseasonplot'><p>Seasonal plot</p></a></li>
<li><a href='#ggtsdisplay'><p>Time series display</p></a></li>
<li><a href='#gold'><p>Daily morning gold prices</p></a></li>
<li><a href='#is.acf'><p>Is an object a particular model type?</p></a></li>
<li><a href='#is.constant'><p>Is an object constant?</p></a></li>
<li><a href='#is.forecast'><p>Is an object a particular forecast type?</p></a></li>
<li><a href='#ma'><p>Moving-average smoothing</p></a></li>
<li><a href='#meanf'><p>Mean Forecast</p></a></li>
<li><a href='#modelAR'><p>Time Series Forecasts with a user-defined model</p></a></li>
<li><a href='#monthdays'><p>Number of days in each season</p></a></li>
<li><a href='#mstl'><p>Multiple seasonal decomposition</p></a></li>
<li><a href='#msts'><p>Multi-Seasonal Time Series</p></a></li>
<li><a href='#na.interp'><p>Interpolate missing values in a time series</p></a></li>
<li><a href='#ndiffs'><p>Number of differences required for a stationary series</p></a></li>
<li><a href='#nnetar'><p>Neural Network Time Series Forecasts</p></a></li>
<li><a href='#nsdiffs'><p>Number of differences required for a seasonally stationary series</p></a></li>
<li><a href='#ocsb.test'><p>Osborn, Chui, Smith, and Birchenhall Test for Seasonal Unit Roots</p></a></li>
<li><a href='#plot.Arima'><p>Plot characteristic roots from ARIMA model</p></a></li>
<li><a href='#plot.bats'><p>Plot components from BATS model</p></a></li>
<li><a href='#plot.ets'><p>Plot components from ETS model</p></a></li>
<li><a href='#plot.forecast'><p>Forecast plot</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.forecast'><p>Residuals for various time series models</p></a></li>
<li><a href='#rwf'><p>Naive and Random Walk Forecasts</p></a></li>
<li><a href='#seasadj'><p>Seasonal adjustment</p></a></li>
<li><a href='#seasonal'><p>Extract components from a time series decomposition</p></a></li>
<li><a href='#seasonaldummy'><p>Seasonal dummy variables</p></a></li>
<li><a href='#ses'><p>Exponential smoothing forecasts</p></a></li>
<li><a href='#simulate.ets'><p>Simulation from a time series model</p></a></li>
<li><a href='#sindexf'><p>Forecast seasonal index</p></a></li>
<li><a href='#splinef'><p>Cubic Spline Forecast</p></a></li>
<li><a href='#StatForecast'><p>Forecast plot</p></a></li>
<li><a href='#subset.ts'><p>Subsetting a time series</p></a></li>
<li><a href='#taylor'><p>Half-hourly electricity demand</p></a></li>
<li><a href='#tbats'><p>TBATS model (Exponential smoothing state space model with Box-Cox</p>
transformation, ARMA errors, Trend and Seasonal components)</a></li>
<li><a href='#tbats.components'><p>Extract components of a TBATS model</p></a></li>
<li><a href='#thetaf'><p>Theta method forecast</p></a></li>
<li><a href='#tsclean'><p>Identify and replace outliers and missing values in a time series</p></a></li>
<li><a href='#tsCV'><p>Time series cross-validation</p></a></li>
<li><a href='#tslm'><p>Fit a linear model with time series components</p></a></li>
<li><a href='#tsoutliers'><p>Identify and replace outliers in a time series</p></a></li>
<li><a href='#wineind'><p>Australian total wine sales</p></a></li>
<li><a href='#woolyrnq'><p>Quarterly production of woollen yarn in Australia</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>8.21.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecasting Functions for Time Series and Linear Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods and tools for displaying and analysing
             univariate time series forecasts including exponential smoothing
             via state space models and automatic ARIMA modelling.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, fracdiff, generics (&ge; 0.1.2), ggplot2 (&ge; 2.2.1),
graphics, lmtest, magrittr, nnet, parallel, Rcpp (&ge; 0.11.0),
stats, timeDate, tseries, urca, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>forecTheta, knitr, methods, rmarkdown, rticles, seasonal,
testthat (&ge; 3.0.0), uroot</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0), RcppArmadillo (&ge; 0.2.35)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robjhyndman/forecast/issues">https://github.com/robjhyndman/forecast/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pkg.robjhyndman.com/forecast/">https://pkg.robjhyndman.com/forecast/</a>,
<a href="https://github.com/robjhyndman/forecast">https://github.com/robjhyndman/forecast</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-31 13:24:15 UTC; robjhyndman</td>
</tr>
<tr>
<td>Author:</td>
<td>Rob Hyndman <a href="https://orcid.org/0000-0002-2140-5352"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre, cph],
  George Athanasopoulos <a href="https://orcid.org/0000-0002-5389-2802"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Christoph Bergmeir <a href="https://orcid.org/0000-0002-3665-9021"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gabriel Caceres <a href="https://orcid.org/0000-0002-2947-2023"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Leanne Chhay [aut],
  Kirill Kuroptev [aut],
  Mitchell O'Hara-Wild <a href="https://orcid.org/0000-0001-6729-7695"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Fotios Petropoulos <a href="https://orcid.org/0000-0003-3039-4955"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Slava Razbash [aut],
  Earo Wang <a href="https://orcid.org/0000-0001-6448-5260"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Farah Yasmeen <a href="https://orcid.org/0000-0002-1479-5401"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Federico Garza [ctb],
  Daniele Girolimetto [ctb],
  Ross Ihaka [ctb, cph],
  R Core Team [ctb, cph],
  Daniel Reid [ctb],
  David Shaub [ctb],
  Yuan Tang <a href="https://orcid.org/0000-0001-5243-233X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Xiaoqian Wang [ctb],
  Zhenyu Zhou [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Hyndman &lt;Rob.Hyndman@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-31 15:10:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:57:04 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='accuracy.default'>Accuracy measures for a forecast model</h2><span id='topic+accuracy.default'></span>

<h3>Description</h3>

<p>Returns range of summary measures of the forecast accuracy. If <code>x</code> is
provided, the function measures test set forecast accuracy
based on <code>x-f</code>. If <code>x</code> is not provided, the function only produces
training set accuracy measures of the forecasts based on
<code>f["x"]-fitted(f)</code>. All measures are defined and discussed in Hyndman
and Koehler (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
accuracy(object, x, test = NULL, d = NULL, D = NULL, f = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy.default_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;<code>forecast</code>&rdquo;, or a numerical vector
containing forecasts. It will also work with <code>Arima</code>, <code>ets</code> and
<code>lm</code> objects if <code>x</code> is omitted &ndash; in which case training set accuracy
measures are returned.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_x">x</code></td>
<td>
<p>An optional numerical vector containing actual values of the same
length as object, or a time series overlapping with the times of <code>f</code>.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_test">test</code></td>
<td>
<p>Indicator of which elements of <code>x</code> and <code>f</code> to test. If
<code>test</code> is <code>NULL</code>, all elements are used. Otherwise test is a
numeric vector containing the indices of the elements to use in the test.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_d">d</code></td>
<td>
<p>An integer indicating the number of lag-1 differences to be used
for the denominator in MASE calculation. Default value is 1 for non-seasonal
series and 0 for seasonal series.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_d">D</code></td>
<td>
<p>An integer indicating the number of seasonal differences to be used
for the denominator in MASE calculation. Default value is 0 for non-seasonal
series and 1 for seasonal series.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_f">f</code></td>
<td>
<p>Deprecated. Please use 'object' instead.</p>
</td></tr>
<tr><td><code id="accuracy.default_+3A_...">...</code></td>
<td>
<p>Additional arguments depending on the specific method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measures calculated are:
</p>

<ul>
<li><p> ME: Mean Error
</p>
</li>
<li><p> RMSE: Root Mean Squared Error
</p>
</li>
<li><p> MAE: Mean Absolute Error
</p>
</li>
<li><p> MPE: Mean Percentage Error
</p>
</li>
<li><p> MAPE: Mean Absolute Percentage Error
</p>
</li>
<li><p> MASE: Mean Absolute Scaled Error
</p>
</li>
<li><p> ACF1: Autocorrelation of errors at lag 1.
</p>
</li></ul>

<p>By default, the MASE calculation is scaled using MAE of training set naive
forecasts for non-seasonal time series, training set seasonal naive forecasts
for seasonal time series and training set mean forecasts for non-time series data.
If <code>f</code> is a numerical vector rather than a <code>forecast</code> object, the MASE
will not be returned as the training data will not be available.
</p>
<p>See Hyndman and Koehler (2006) and Hyndman and Athanasopoulos (2014, Section
2.5) for further details.
</p>


<h3>Value</h3>

<p>Matrix giving forecast accuracy measures.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. and Koehler, A.B. (2006) &quot;Another look at measures
of forecast accuracy&quot;. <em>International Journal of Forecasting</em>,
<b>22</b>(4), 679-688. Hyndman, R.J. and Athanasopoulos, G. (2018)
&quot;Forecasting: principles and practice&quot;, 2nd ed., OTexts, Melbourne, Australia.
Section 3.4 &quot;Evaluating forecast accuracy&quot;.
<a href="https://otexts.com/fpp2/accuracy.html">https://otexts.com/fpp2/accuracy.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit1 &lt;- rwf(EuStockMarkets[1:200, 1], h = 100)
fit2 &lt;- meanf(EuStockMarkets[1:200, 1], h = 100)
accuracy(fit1)
accuracy(fit2)
accuracy(fit1, EuStockMarkets[201:300, 1])
accuracy(fit2, EuStockMarkets[201:300, 1])
plot(fit1)
lines(EuStockMarkets[1:300, 1])
</code></pre>

<hr>
<h2 id='Acf'>(Partial) Autocorrelation and Cross-Correlation Function Estimation</h2><span id='topic+Acf'></span><span id='topic+Pacf'></span><span id='topic+Ccf'></span><span id='topic+taperedacf'></span><span id='topic+taperedpacf'></span>

<h3>Description</h3>

<p>The function <code>Acf</code> computes (and by default plots) an estimate of the
autocorrelation function of a (possibly multivariate) time series. Function
<code>Pacf</code> computes (and by default plots) an estimate of the partial
autocorrelation function of a (possibly multivariate) time series. Function
<code>Ccf</code> computes the cross-correlation or cross-covariance of two
univariate series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Acf(
  x,
  lag.max = NULL,
  type = c("correlation", "covariance", "partial"),
  plot = TRUE,
  na.action = na.contiguous,
  demean = TRUE,
  ...
)

Pacf(
  x,
  lag.max = NULL,
  plot = TRUE,
  na.action = na.contiguous,
  demean = TRUE,
  ...
)

Ccf(
  x,
  y,
  lag.max = NULL,
  type = c("correlation", "covariance"),
  plot = TRUE,
  na.action = na.contiguous,
  ...
)

taperedacf(
  x,
  lag.max = NULL,
  type = c("correlation", "partial"),
  plot = TRUE,
  calc.ci = TRUE,
  level = 95,
  nsim = 100,
  ...
)

taperedpacf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Acf_+3A_x">x</code></td>
<td>
<p>a univariate or multivariate (not Ccf) numeric time series object
or a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="Acf_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the acf. Default is
$10*log10(N/m)$ where $N$ is the number of observations and $m$ the number
of series. Will be automatically limited to one less than the number of
observations in the series.</p>
</td></tr>
<tr><td><code id="Acf_+3A_type">type</code></td>
<td>
<p>character string giving the type of acf to be computed. Allowed
values are &ldquo;<code>correlation</code>&rdquo; (the default),
&ldquo;<code>covariance</code>&rdquo; or &ldquo;<code>partial</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="Acf_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the resulting acf, pacf or
ccf is plotted.</p>
</td></tr>
<tr><td><code id="Acf_+3A_na.action">na.action</code></td>
<td>
<p>function to handle missing values. Default is
<code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code>.  Useful alternatives are
<code><a href="stats.html#topic+na.pass">na.pass</a></code> and <code><a href="forecast.html#topic+na.interp">na.interp</a></code>.</p>
</td></tr>
<tr><td><code id="Acf_+3A_demean">demean</code></td>
<td>
<p>Should covariances be about the sample means?</p>
</td></tr>
<tr><td><code id="Acf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting function.</p>
</td></tr>
<tr><td><code id="Acf_+3A_y">y</code></td>
<td>
<p>a univariate numeric time series object or a numeric vector.</p>
</td></tr>
<tr><td><code id="Acf_+3A_calc.ci">calc.ci</code></td>
<td>
<p>If <code>TRUE</code>, confidence intervals for the ACF/PACF
estimates are calculated.</p>
</td></tr>
<tr><td><code id="Acf_+3A_level">level</code></td>
<td>
<p>Percentage level used for the confidence intervals.</p>
</td></tr>
<tr><td><code id="Acf_+3A_nsim">nsim</code></td>
<td>
<p>The number of bootstrap samples used in estimating the
confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions improve the <code><a href="stats.html#topic+acf">acf</a></code>,
<code><a href="stats.html#topic+pacf">pacf</a></code> and <code><a href="stats.html#topic+ccf">ccf</a></code> functions. The main
differences are that <code>Acf</code> does not plot a spike at lag 0 when
<code>type=="correlation"</code> (which is redundant) and the horizontal axes show
lags in time units rather than seasonal units.
</p>
<p>The tapered versions implement the ACF and PACF estimates and plots
described in Hyndman (2015), based on the banded and tapered estimates of
autocovariance proposed by McMurry and Politis (2010).
</p>


<h3>Value</h3>

<p>The <code>Acf</code>, <code>Pacf</code> and <code>Ccf</code> functions return objects
of class &quot;acf&quot; as described in <code><a href="stats.html#topic+acf">acf</a></code> from the stats
package. The <code>taperedacf</code> and <code>taperedpacf</code> functions return
objects of class &quot;mpacf&quot;.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (2015). Discussion of &ldquo;High-dimensional
autocovariance matrices and optimal linear prediction&rdquo;. <em>Electronic
Journal of Statistics</em>, 9, 792-796.
</p>
<p>McMurry, T. L., &amp; Politis, D. N. (2010). Banded and tapered estimates for
autocovariance matrices and the linear process bootstrap. <em>Journal of
Time Series Analysis</em>, 31(6), 471-482.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="stats.html#topic+pacf">pacf</a></code>,
<code><a href="stats.html#topic+ccf">ccf</a></code>, <code><a href="forecast.html#topic+tsdisplay">tsdisplay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Acf(wineind)
Pacf(wineind)
## Not run: 
taperedacf(wineind, nsim=50)
taperedpacf(wineind, nsim=50)

## End(Not run)

</code></pre>

<hr>
<h2 id='arfima'>Fit a fractionally differenced ARFIMA model</h2><span id='topic+arfima'></span>

<h3>Description</h3>

<p>An ARFIMA(p,d,q) model is selected and estimated automatically using the
Hyndman-Khandakar (2008) algorithm to select p and q and the Haslett and
Raftery (1989) algorithm to estimate the parameters including d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfima(
  y,
  drange = c(0, 0.5),
  estim = c("mle", "ls"),
  model = NULL,
  lambda = NULL,
  biasadj = FALSE,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfima_+3A_y">y</code></td>
<td>
<p>a univariate time series (numeric vector).</p>
</td></tr>
<tr><td><code id="arfima_+3A_drange">drange</code></td>
<td>
<p>Allowable values of d to be considered. Default of
<code>c(0,0.5)</code> ensures a stationary model is returned.</p>
</td></tr>
<tr><td><code id="arfima_+3A_estim">estim</code></td>
<td>
<p>If <code>estim=="ls"</code>, then the ARMA parameters are calculated
using the Haslett-Raftery algorithm. If <code>estim=="mle"</code>, then the ARMA
parameters are calculated using full MLE via the <code><a href="stats.html#topic+arima">arima</a></code>
function.</p>
</td></tr>
<tr><td><code id="arfima_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>arfima</code>. If model is
passed, this same model is fitted to y without re-estimating any parameters.</p>
</td></tr>
<tr><td><code id="arfima_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="arfima_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="arfima_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="arfima_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> when
selecting p and q.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code> and
<code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> to automatically select and estimate an ARFIMA
model.  The fractional differencing parameter is chosen first assuming an
ARFIMA(2,d,0) model. Then the data are fractionally differenced using the
estimated d and an ARMA model is selected for the resulting time series
using <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>. Finally, the full ARFIMA(p,d,q) model is
re-estimated using <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code>. If <code>estim=="mle"</code>,
the ARMA coefficients are refined using <code><a href="stats.html#topic+arima">arima</a></code>.
</p>


<h3>Value</h3>

<p>A list object of S3 class <code>"fracdiff"</code>, which is described in
the <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code> documentation. A few additional objects
are added to the list including <code>x</code> (the original time series), and the
<code>residuals</code> and <code>fitted</code> values.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Farah Yasmeen
</p>


<h3>References</h3>

<p>J. Haslett and A. E. Raftery (1989) Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource (with
discussion); <em>Applied Statistics</em> <b>38</b>, 1-50.
</p>
<p>Hyndman, R.J. and Khandakar, Y. (2008) &quot;Automatic time series forecasting:
The forecast package for R&quot;, <em>Journal of Statistical Software</em>,
<b>26</b>(3).
</p>


<h3>See Also</h3>

<p><code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="forecast.html#topic+forecast.fracdiff">forecast.fracdiff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(fracdiff)
x &lt;- fracdiff.sim( 100, ma=-.4, d=.3)$series
fit &lt;- arfima(x)
tsdisplay(residuals(fit))

</code></pre>

<hr>
<h2 id='Arima'>Fit ARIMA model to univariate time series</h2><span id='topic+Arima'></span><span id='topic+print.ARIMA'></span><span id='topic+summary.Arima'></span><span id='topic+as.character.Arima'></span>

<h3>Description</h3>

<p>Largely a wrapper for the <code><a href="stats.html#topic+arima">arima</a></code> function in the stats
package. The main difference is that this function allows a drift term. It
is also possible to take an ARIMA model from a previous call to <code>Arima</code>
and re-apply it to the data <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arima(
  y,
  order = c(0, 0, 0),
  seasonal = c(0, 0, 0),
  xreg = NULL,
  include.mean = TRUE,
  include.drift = FALSE,
  include.constant,
  lambda = model$lambda,
  biasadj = FALSE,
  method = c("CSS-ML", "ML", "CSS"),
  model = NULL,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arima_+3A_y">y</code></td>
<td>
<p>a univariate time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="Arima_+3A_order">order</code></td>
<td>
<p>A specification of the non-seasonal part of the ARIMA model:
the three components (p, d, q) are the AR order, the degree of differencing,
and the MA order.</p>
</td></tr>
<tr><td><code id="Arima_+3A_seasonal">seasonal</code></td>
<td>
<p>A specification of the seasonal part of the ARIMA model,
plus the period (which defaults to frequency(y)). This should be a list with
components order and period, but a specification of just a numeric vector of
length 3 will be turned into a suitable list with the specification as the
order.</p>
</td></tr>
<tr><td><code id="Arima_+3A_xreg">xreg</code></td>
<td>
<p>Optionally, a numerical vector or matrix of external regressors, which
must have the same number of rows as y. It should not be a data frame.</p>
</td></tr>
<tr><td><code id="Arima_+3A_include.mean">include.mean</code></td>
<td>
<p>Should the ARIMA model include a mean term? The default
is <code>TRUE</code> for undifferenced series, <code>FALSE</code> for differenced ones
(where a mean would not affect the fit nor predictions).</p>
</td></tr>
<tr><td><code id="Arima_+3A_include.drift">include.drift</code></td>
<td>
<p>Should the ARIMA model include a linear drift term?
(i.e., a linear regression with ARIMA errors is fitted.)  The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Arima_+3A_include.constant">include.constant</code></td>
<td>
<p>If <code>TRUE</code>, then <code>include.mean</code> is set to
be <code>TRUE</code> for undifferenced series and <code>include.drift</code> is set to
be <code>TRUE</code> for differenced series. Note that if there is more than one
difference taken, no constant is included regardless of the value of this
argument. This is deliberate as otherwise quadratic and higher order
polynomial trends would be induced.</p>
</td></tr>
<tr><td><code id="Arima_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="Arima_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="Arima_+3A_method">method</code></td>
<td>
<p>Fitting method: maximum likelihood or minimize conditional
sum-of-squares. The default (unless there are missing values) is to use
conditional-sum-of-squares to find starting values, then maximum likelihood.</p>
</td></tr>
<tr><td><code id="Arima_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>Arima</code>. If model is
passed, this same model is fitted to <code>y</code> without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="Arima_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="Arima_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code><a href="stats.html#topic+arima">arima</a></code> function in the stats package.
</p>


<h3>Value</h3>

<p>See the <code><a href="stats.html#topic+arima">arima</a></code> function in the stats package.
The additional objects returned are </p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The time series data</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The regressors used in fitting (when relevant).</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>The bias adjusted MLE of the innovations variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>, <code><a href="forecast.html#topic+forecast.Arima">forecast.Arima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
WWWusage %&gt;%
  Arima(order=c(3,1,0)) %&gt;%
  forecast(h=20) %&gt;%
  autoplot

# Fit model to first few years of AirPassengers data
air.model &lt;- Arima(window(AirPassengers,end=1956+11/12),order=c(0,1,1),
                   seasonal=list(order=c(0,1,1),period=12),lambda=0)
plot(forecast(air.model,h=48))
lines(AirPassengers)

# Apply fitted model to later data
air.model2 &lt;- Arima(window(AirPassengers,start=1957),model=air.model)

# Forecast accuracy measures on the log scale.
# in-sample one-step forecasts.
accuracy(air.model)
# out-of-sample one-step forecasts.
accuracy(air.model2)
# out-of-sample multi-step forecasts
accuracy(forecast(air.model,h=48,lambda=NULL),
         log(window(AirPassengers,start=1957)))

</code></pre>

<hr>
<h2 id='arima.errors'>Errors from a regression model with ARIMA errors</h2><span id='topic+arima.errors'></span>

<h3>Description</h3>

<p>Returns time series of the regression residuals from a fitted ARIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arima.errors(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arima.errors_+3A_object">object</code></td>
<td>
<p>An object containing a time series model of class <code>Arima</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a deprecated function
which is identical to <code><a href="forecast.html#topic+residuals.Arima">residuals.Arima</a>(object, type="regression")</code>
Regression residuals are equal to the original data
minus the effect of any regression variables. If there are no regression
variables, the errors will be identical to the original series (possibly
adjusted to have zero mean).
</p>


<h3>Value</h3>

<p>A <code>ts</code> object
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+residuals.Arima">residuals.Arima</a></code>.
</p>

<hr>
<h2 id='arimaorder'>Return the order of an ARIMA or ARFIMA model</h2><span id='topic+arimaorder'></span>

<h3>Description</h3>

<p>Returns the order of a univariate ARIMA or ARFIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arimaorder(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arimaorder_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;<code>Arima</code>&rdquo;, dQuote<code>ar</code> or
&ldquo;<code>fracdiff</code>&rdquo;. Usually the result of a call to
<code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="forecast.html#topic+arfima">arfima</a></code> or
<code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector giving the values <code class="reqn">p</code>, <code class="reqn">d</code> and <code class="reqn">q</code> of
the ARIMA or ARFIMA model. For a seasonal ARIMA model, the returned vector
contains the values <code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>, <code class="reqn">P</code>, <code class="reqn">D</code>, <code class="reqn">Q</code> and
<code class="reqn">m</code>, where <code class="reqn">m</code> is the period of seasonality.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="forecast.html#topic+arfima">arfima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WWWusage %&gt;% auto.arima %&gt;% arimaorder

</code></pre>

<hr>
<h2 id='auto.arima'>Fit best ARIMA model to univariate time series</h2><span id='topic+auto.arima'></span>

<h3>Description</h3>

<p>Returns best ARIMA model according to either AIC, AICc or BIC value. The
function conducts a search over possible model within the order constraints
provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto.arima(
  y,
  d = NA,
  D = NA,
  max.p = 5,
  max.q = 5,
  max.P = 2,
  max.Q = 2,
  max.order = 5,
  max.d = 2,
  max.D = 1,
  start.p = 2,
  start.q = 2,
  start.P = 1,
  start.Q = 1,
  stationary = FALSE,
  seasonal = TRUE,
  ic = c("aicc", "aic", "bic"),
  stepwise = TRUE,
  nmodels = 94,
  trace = FALSE,
  approximation = (length(x) &gt; 150 | frequency(x) &gt; 12),
  method = NULL,
  truncate = NULL,
  xreg = NULL,
  test = c("kpss", "adf", "pp"),
  test.args = list(),
  seasonal.test = c("seas", "ocsb", "hegy", "ch"),
  seasonal.test.args = list(),
  allowdrift = TRUE,
  allowmean = TRUE,
  lambda = NULL,
  biasadj = FALSE,
  parallel = FALSE,
  num.cores = 2,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.arima_+3A_y">y</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_d">d</code></td>
<td>
<p>Order of first-differencing. If missing, will choose a value based
on <code>test</code>.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_d">D</code></td>
<td>
<p>Order of seasonal-differencing. If missing, will choose a value
based on <code>season.test</code>.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.p">max.p</code></td>
<td>
<p>Maximum value of p</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.q">max.q</code></td>
<td>
<p>Maximum value of q</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.p">max.P</code></td>
<td>
<p>Maximum value of P</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.q">max.Q</code></td>
<td>
<p>Maximum value of Q</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.order">max.order</code></td>
<td>
<p>Maximum value of p+q+P+Q if model selection is not
stepwise.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.d">max.d</code></td>
<td>
<p>Maximum number of non-seasonal differences</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_max.d">max.D</code></td>
<td>
<p>Maximum number of seasonal differences</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_start.p">start.p</code></td>
<td>
<p>Starting value of p in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_start.q">start.q</code></td>
<td>
<p>Starting value of q in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_start.p">start.P</code></td>
<td>
<p>Starting value of P in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_start.q">start.Q</code></td>
<td>
<p>Starting value of Q in stepwise procedure.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_stationary">stationary</code></td>
<td>
<p>If <code>TRUE</code>, restricts search to stationary models.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_seasonal">seasonal</code></td>
<td>
<p>If <code>FALSE</code>, restricts search to non-seasonal models.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_ic">ic</code></td>
<td>
<p>Information criterion to be used in model selection.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_stepwise">stepwise</code></td>
<td>
<p>If <code>TRUE</code>, will do stepwise selection (faster).
Otherwise, it searches over all models. Non-stepwise selection can be very
slow, especially for seasonal models.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_nmodels">nmodels</code></td>
<td>
<p>Maximum number of models considered in the stepwise search.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, the list of ARIMA models considered will be
reported.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_approximation">approximation</code></td>
<td>
<p>If <code>TRUE</code>, estimation is via conditional sums of
squares and the information criteria used for model selection are
approximated. The final model is still computed using maximum likelihood
estimation. Approximation should be used for long time series or a high
seasonal period to avoid excessive computation times.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_method">method</code></td>
<td>
<p>fitting method: maximum likelihood or minimize
conditional sum-of-squares.  The default (unless there are missing
values) is to use conditional-sum-of-squares to find starting
values, then maximum likelihood.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_truncate">truncate</code></td>
<td>
<p>An integer value indicating how many observations to use in
model selection. The last <code>truncate</code> values of the series are used to
select a model when <code>truncate</code> is not <code>NULL</code> and
<code>approximation=TRUE</code>. All observations are used if either
<code>truncate=NULL</code> or <code>approximation=FALSE</code>.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_xreg">xreg</code></td>
<td>
<p>Optionally, a numerical vector or matrix of external regressors, which
must have the same number of rows as <code>y</code>. (It should not be a data frame.)</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_test">test</code></td>
<td>
<p>Type of unit root test to use. See <code><a href="forecast.html#topic+ndiffs">ndiffs</a></code> for
details.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_test.args">test.args</code></td>
<td>
<p>Additional arguments to be passed to the unit root test.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_seasonal.test">seasonal.test</code></td>
<td>
<p>This determines which method is used to select the number of seasonal differences.
The default method is to use a measure of seasonal strength computed from an STL decomposition.
Other possibilities involve seasonal unit root tests.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_seasonal.test.args">seasonal.test.args</code></td>
<td>
<p>Additional arguments to be passed to the seasonal
unit root test.
See <code><a href="forecast.html#topic+nsdiffs">nsdiffs</a></code> for details.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_allowdrift">allowdrift</code></td>
<td>
<p>If <code>TRUE</code>, models with drift terms are considered.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_allowmean">allowmean</code></td>
<td>
<p>If <code>TRUE</code>, models with a non-zero mean are considered.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> and <code>stepwise = FALSE</code>, then the
specification search is done in parallel. This can give a significant
speedup on multicore machines.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_num.cores">num.cores</code></td>
<td>
<p>Allows the user to specify the amount of parallel processes
to be used if <code>parallel = TRUE</code> and <code>stepwise = FALSE</code>. If
<code>NULL</code>, then the number of logical cores is automatically detected and
all available cores are used.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="auto.arima_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default arguments are designed for rapid estimation of models for many time series.
If you are analysing just one time series, and can afford to take some more time, it
is recommended that you set <code>stepwise=FALSE</code> and <code>approximation=FALSE</code>.
</p>
<p>Non-stepwise selection can be slow, especially for seasonal data. The stepwise
algorithm outlined in Hyndman &amp; Khandakar (2008) is used except that the default
method for selecting seasonal differences is now based on an estimate of seasonal
strength (Wang, Smith &amp; Hyndman, 2006) rather than the Canova-Hansen test.
There are also some other minor variations to the algorithm described in
Hyndman and Khandakar (2008).
</p>


<h3>Value</h3>

<p>Same as for <code><a href="forecast.html#topic+Arima">Arima</a></code>
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, RJ and Khandakar, Y (2008) &quot;Automatic time series
forecasting: The forecast package for R&quot;, <em>Journal of Statistical
Software</em>, <b>26</b>(3).
</p>
<p>Wang, X, Smith, KA, Hyndman, RJ (2006) &quot;Characteristic-based clustering
for time series data&quot;, <em>Data Mining and Knowledge Discovery</em>,
<b>13</b>(3), 335-364.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+Arima">Arima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- auto.arima(WWWusage)
plot(forecast(fit,h=20))

</code></pre>

<hr>
<h2 id='autolayer'>Create a ggplot layer appropriate to a particular data type</h2><span id='topic+autolayer'></span>

<h3>Description</h3>

<p><code>autolayer()</code> uses ggplot2 to draw a particular layer for an object of a
particular class in a single command. This defines the S3 generic that
other classes and packages can extend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autolayer(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolayer_+3A_object">object</code></td>
<td>
<p>an object, whose class will determine the behaviour of autolayer</p>
</td></tr>
<tr><td><code id="autolayer_+3A_...">...</code></td>
<td>
<p>other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot layer
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">autoplot()</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code> and <code><a href="ggplot2.html#topic+fortify">fortify()</a></code>
</p>

<hr>
<h2 id='autolayer.mts'>Automatically create a ggplot for time series objects</h2><span id='topic+autolayer.mts'></span><span id='topic+autolayer.msts'></span><span id='topic+autolayer.ts'></span><span id='topic+autoplot.ts'></span><span id='topic+autoplot.mts'></span><span id='topic+autoplot.msts'></span><span id='topic+fortify.ts'></span>

<h3>Description</h3>

<p><code>autoplot</code> takes an object of type <code>ts</code> or <code>mts</code> and creates
a ggplot object suitable for usage with <code>stat_forecast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mts'
autolayer(object, colour = TRUE, series = NULL, ...)

## S3 method for class 'msts'
autolayer(object, series = NULL, ...)

## S3 method for class 'ts'
autolayer(object, colour = TRUE, series = NULL, ...)

## S3 method for class 'ts'
autoplot(
  object,
  series = NULL,
  xlab = "Time",
  ylab = deparse(substitute(object)),
  main = NULL,
  ...
)

## S3 method for class 'mts'
autoplot(
  object,
  colour = TRUE,
  facets = FALSE,
  xlab = "Time",
  ylab = deparse(substitute(object)),
  main = NULL,
  ...
)

## S3 method for class 'msts'
autoplot(object, ...)

## S3 method for class 'ts'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autolayer.mts_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;<code>ts</code>&rdquo; or &ldquo;<code>mts</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_colour">colour</code></td>
<td>
<p>If TRUE, the time series will be assigned a colour aesthetic</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_series">series</code></td>
<td>
<p>Identifies the time series with a colour, which integrates well
with the functionality of <a href="forecast.html#topic+geom_forecast">geom_forecast</a>.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_...">...</code></td>
<td>
<p>Other plotting parameters to affect the plot.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_facets">facets</code></td>
<td>
<p>If TRUE, multiple time series will be faceted (and unless
specified, colour is set to FALSE). If FALSE, each series will be assigned a
colour.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_model">model</code></td>
<td>
<p>Object of class &ldquo;<code>ts</code>&rdquo; to be converted to
&ldquo;<code>data.frame</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="autolayer.mts_+3A_data">data</code></td>
<td>
<p>Not used (required for <a href="ggplot2.html#topic+fortify">fortify</a> method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fortify.ts</code> takes a <code>ts</code> object and converts it into a data frame
(for usage with ggplot2).
</p>


<h3>Value</h3>

<p>None. Function produces a ggplot graph.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="ggplot2.html#topic+fortify">fortify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
autoplot(USAccDeaths)

lungDeaths &lt;- cbind(mdeaths, fdeaths)
autoplot(lungDeaths)
autoplot(lungDeaths, facets=TRUE)

</code></pre>

<hr>
<h2 id='autoplot.acf'>ggplot (Partial) Autocorrelation and Cross-Correlation Function Estimation
and Plotting</h2><span id='topic+autoplot.acf'></span><span id='topic+ggAcf'></span><span id='topic+ggPacf'></span><span id='topic+ggCcf'></span><span id='topic+autoplot.mpacf'></span><span id='topic+ggtaperedacf'></span><span id='topic+ggtaperedpacf'></span>

<h3>Description</h3>

<p>Produces a ggplot object of their equivalent Acf, Pacf, Ccf, taperedacf and
taperedpacf functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acf'
autoplot(object, ci = 0.95, ...)

ggAcf(
  x,
  lag.max = NULL,
  type = c("correlation", "covariance", "partial"),
  plot = TRUE,
  na.action = na.contiguous,
  demean = TRUE,
  ...
)

ggPacf(
  x,
  lag.max = NULL,
  plot = TRUE,
  na.action = na.contiguous,
  demean = TRUE,
  ...
)

ggCcf(
  x,
  y,
  lag.max = NULL,
  type = c("correlation", "covariance"),
  plot = TRUE,
  na.action = na.contiguous,
  ...
)

## S3 method for class 'mpacf'
autoplot(object, ...)

ggtaperedacf(
  x,
  lag.max = NULL,
  type = c("correlation", "partial"),
  plot = TRUE,
  calc.ci = TRUE,
  level = 95,
  nsim = 100,
  ...
)

ggtaperedpacf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.acf_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;<code>acf</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_ci">ci</code></td>
<td>
<p>coverage probability for confidence interval. Plotting of the
confidence interval is suppressed if ci is zero or negative.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_...">...</code></td>
<td>
<p>Other plotting parameters to affect the plot.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_x">x</code></td>
<td>
<p>a univariate or multivariate (not Ccf) numeric time series object
or a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the acf.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_type">type</code></td>
<td>
<p>character string giving the type of acf to be computed. Allowed
values are &quot;<code>correlation</code>&quot; (the default), &ldquo;<code>covariance</code>&rdquo; or
&ldquo;<code>partial</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the resulting ACF, PACF or
CCF is plotted.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_na.action">na.action</code></td>
<td>
<p>function to handle missing values. Default is
<code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code>.  Useful alternatives are
<code><a href="stats.html#topic+na.pass">na.pass</a></code> and <code><a href="forecast.html#topic+na.interp">na.interp</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_demean">demean</code></td>
<td>
<p>Should covariances be about the sample means?</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_y">y</code></td>
<td>
<p>a univariate numeric time series object or a numeric vector.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_calc.ci">calc.ci</code></td>
<td>
<p>If <code>TRUE</code>, confidence intervals for the ACF/PACF
estimates are calculated.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_level">level</code></td>
<td>
<p>Percentage level used for the confidence intervals.</p>
</td></tr>
<tr><td><code id="autoplot.acf_+3A_nsim">nsim</code></td>
<td>
<p>The number of bootstrap samples used in estimating the
confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>autoplot</code> is given an <code>acf</code> or <code>mpacf</code> object, then an
appropriate ggplot object will be created.
</p>
<p>ggtaperedpacf
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.acf">plot.acf</a></code>, <code><a href="forecast.html#topic+Acf">Acf</a></code>,
<code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="forecast.html#topic+taperedacf">taperedacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
ggAcf(wineind)
wineind %&gt;% Acf(plot=FALSE) %&gt;% autoplot
## Not run: 
wineind %&gt;% taperedacf(plot=FALSE) %&gt;% autoplot
ggtaperedacf(wineind)
ggtaperedpacf(wineind)
## End(Not run)
ggCcf(mdeaths, fdeaths)

</code></pre>

<hr>
<h2 id='autoplot.decomposed.ts'>Plot time series decomposition components using ggplot</h2><span id='topic+autoplot.decomposed.ts'></span><span id='topic+autoplot.stl'></span><span id='topic+autoplot.StructTS'></span><span id='topic+autoplot.seas'></span><span id='topic+autoplot.mstl'></span>

<h3>Description</h3>

<p>Produces a ggplot object of seasonally decomposed time series for objects of
class &ldquo;<code>stl</code>&rdquo; (created with <code><a href="stats.html#topic+stl">stl</a></code>), class
&ldquo;<code>seas</code>&rdquo; (created with <code><a href="seasonal.html#topic+seas">seas</a></code>), or class
&ldquo;<code>decomposed.ts</code>&rdquo; (created with <code><a href="stats.html#topic+decompose">decompose</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomposed.ts'
autoplot(object, labels = NULL, range.bars = NULL, ...)

## S3 method for class 'stl'
autoplot(object, labels = NULL, range.bars = TRUE, ...)

## S3 method for class 'StructTS'
autoplot(object, labels = NULL, range.bars = TRUE, ...)

## S3 method for class 'seas'
autoplot(object, labels = NULL, range.bars = NULL, ...)

## S3 method for class 'mstl'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.decomposed.ts_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;<code>seas</code>&rdquo;, &ldquo;<code>stl</code>&rdquo;, or
&ldquo;<code>decomposed.ts</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="autoplot.decomposed.ts_+3A_labels">labels</code></td>
<td>
<p>Labels to replace &ldquo;seasonal&rdquo;, &ldquo;trend&rdquo;, and
&ldquo;remainder&rdquo;.</p>
</td></tr>
<tr><td><code id="autoplot.decomposed.ts_+3A_range.bars">range.bars</code></td>
<td>
<p>Logical indicating if each plot should have a bar at its
right side representing relative size. If <code>NULL</code>, automatic selection
takes place.</p>
</td></tr>
<tr><td><code id="autoplot.decomposed.ts_+3A_...">...</code></td>
<td>
<p>Other plotting parameters to affect the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="seasonal.html#topic+seas">seas</a></code>, <code><a href="stats.html#topic+stl">stl</a></code>,
<code><a href="stats.html#topic+decompose">decompose</a></code>, <code><a href="stats.html#topic+StructTS">StructTS</a></code>,
<code><a href="stats.html#topic+plot.stl">plot.stl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)
co2 %&gt;%
  decompose() %&gt;%
  autoplot()
nottem %&gt;%
  stl(s.window = "periodic") %&gt;%
  autoplot()
## Not run: 
library(seasonal)
seas(USAccDeaths) %&gt;% autoplot()

## End(Not run)

</code></pre>

<hr>
<h2 id='autoplot.mforecast'>Multivariate forecast plot</h2><span id='topic+autoplot.mforecast'></span><span id='topic+autolayer.mforecast'></span><span id='topic+plot.mforecast'></span>

<h3>Description</h3>

<p>Plots historical data with multivariate forecasts and prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mforecast'
autoplot(object, PI = TRUE, facets = TRUE, colour = FALSE, ...)

## S3 method for class 'mforecast'
autolayer(object, series = NULL, PI = TRUE, ...)

## S3 method for class 'mforecast'
plot(x, main = paste("Forecasts from", unique(x$method)), xlab = "time", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.mforecast_+3A_object">object</code></td>
<td>
<p>Multivariate forecast object of class <code>mforecast</code>. Used
for ggplot graphics (S3 method consistency).</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_pi">PI</code></td>
<td>
<p>If <code>FALSE</code>, confidence intervals will not be plotted, giving
only the forecast line.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_facets">facets</code></td>
<td>
<p>If TRUE, multiple time series will be faceted. If FALSE, each
series will be assigned a colour.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_colour">colour</code></td>
<td>
<p>If TRUE, the time series will be assigned a colour aesthetic</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_...">...</code></td>
<td>
<p>additional arguments to each individual <code>plot</code>.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_series">series</code></td>
<td>
<p>Matches an unidentified forecast layer with a coloured object
on the plot.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_x">x</code></td>
<td>
<p>Multivariate forecast object of class <code>mforecast</code>.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_main">main</code></td>
<td>
<p>Main title. Default is the forecast method. For autoplot,
specify a vector of titles for each plot.</p>
</td></tr>
<tr><td><code id="autoplot.mforecast_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. For autoplot, specify a vector of labels for each
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>autoplot</code> will produce an equivalent plot as a ggplot object.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2018) <em>Forecasting: principles
and practice</em>, 2nd edition, OTexts: Melbourne, Australia.
<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.forecast">plot.forecast</a></code>, <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

lungDeaths &lt;- cbind(mdeaths, fdeaths)
fit &lt;- tslm(lungDeaths ~ trend + season)
fcast &lt;- forecast(fit, h=10)
plot(fcast)
autoplot(fcast)

carPower &lt;- as.matrix(mtcars[,c("qsec","hp")])
carmpg &lt;- mtcars[,"mpg"]
fit &lt;- lm(carPower ~ carmpg)
fcast &lt;- forecast(fit, newdata=data.frame(carmpg=30))
plot(fcast, xlab="Year")
autoplot(fcast, xlab=rep("Year",2))

</code></pre>

<hr>
<h2 id='baggedModel'>Forecasting using a bagged model</h2><span id='topic+baggedModel'></span><span id='topic+print.baggedModel'></span><span id='topic+baggedETS'></span>

<h3>Description</h3>

<p>The bagged model forecasting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baggedModel(y, bootstrapped_series = bld.mbb.bootstrap(y, 100), fn = ets, ...)

baggedETS(y, bootstrapped_series = bld.mbb.bootstrap(y, 100), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baggedModel_+3A_y">y</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="baggedModel_+3A_bootstrapped_series">bootstrapped_series</code></td>
<td>
<p>bootstrapped versions of y.</p>
</td></tr>
<tr><td><code id="baggedModel_+3A_fn">fn</code></td>
<td>
<p>the forecast function to use. Default is <code><a href="forecast.html#topic+ets">ets</a></code>.</p>
</td></tr>
<tr><td><code id="baggedModel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the forecast function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the bagged model forecasting method described in
Bergmeir et al. By default, the <code><a href="forecast.html#topic+ets">ets</a></code> function is applied to all
bootstrapped series. Base models other than <code><a href="forecast.html#topic+ets">ets</a></code> can be given by the
parameter <code>fn</code>. Using the default parameters, the function
<code><a href="forecast.html#topic+bld.mbb.bootstrap">bld.mbb.bootstrap</a></code> is used to calculate the bootstrapped series
with the Box-Cox and Loess-based decomposition (BLD) bootstrap. The function
<code><a href="forecast.html#topic+forecast.baggedModel">forecast.baggedModel</a></code> can then be used to calculate forecasts.
</p>
<p><code>baggedETS</code> is a wrapper for <code>baggedModel</code>, setting <code>fn</code> to &quot;ets&quot;.
This function is included for backwards compatibility only, and may be
deprecated in the future.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;<code>baggedModel</code>&quot;.
</p>
<p>The function <code>print</code> is used to obtain and print a summary of the
results.
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>A list containing the fitted ensemble models.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The function for producing a forecastable model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>bootstrapped_series</code></td>
<td>
<p>The bootstrapped series.</p>
</td></tr>
<tr><td><code>modelargs</code></td>
<td>
<p>The arguments passed through to <code>fn</code>.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts). The
mean of the fitted values is calculated over the ensemble.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Original values minus fitted values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph Bergmeir, Fotios Petropoulos
</p>


<h3>References</h3>

<p>Bergmeir, C., R. J. Hyndman, and J. M. Benitez (2016). Bagging
Exponential Smoothing Methods using STL Decomposition and Box-Cox
Transformation. International Journal of Forecasting 32, 303-312.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- baggedModel(WWWusage)
fcast &lt;- forecast(fit)
plot(fcast)

</code></pre>

<hr>
<h2 id='bats'>BATS model (Exponential smoothing state space model with Box-Cox
transformation, ARMA errors, Trend and Seasonal components)</h2><span id='topic+bats'></span><span id='topic+as.character.bats'></span><span id='topic+print.bats'></span>

<h3>Description</h3>

<p>Fits a BATS model applied to <code>y</code>, as described in De Livera, Hyndman &amp;
Snyder (2011). Parallel processing is used by default to speed up the
computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bats(
  y,
  use.box.cox = NULL,
  use.trend = NULL,
  use.damped.trend = NULL,
  seasonal.periods = NULL,
  use.arma.errors = TRUE,
  use.parallel = length(y) &gt; 1000,
  num.cores = 2,
  bc.lower = 0,
  bc.upper = 1,
  biasadj = FALSE,
  model = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bats_+3A_y">y</code></td>
<td>
<p>The time series to be forecast. Can be <code>numeric</code>, <code>msts</code>
or <code>ts</code>. Only univariate time series are supported.</p>
</td></tr>
<tr><td><code id="bats_+3A_use.box.cox">use.box.cox</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to use the Box-Cox
transformation or not. If <code>NULL</code> then both are tried and the best fit
is selected by AIC.</p>
</td></tr>
<tr><td><code id="bats_+3A_use.trend">use.trend</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include a trend or
not. If <code>NULL</code> then both are tried and the best fit is selected by AIC.</p>
</td></tr>
<tr><td><code id="bats_+3A_use.damped.trend">use.damped.trend</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include a
damping parameter in the trend or not. If <code>NULL</code> then both are tried
and the best fit is selected by AIC.</p>
</td></tr>
<tr><td><code id="bats_+3A_seasonal.periods">seasonal.periods</code></td>
<td>
<p>If <code>y</code> is a numeric then seasonal periods can
be specified with this parameter.</p>
</td></tr>
<tr><td><code id="bats_+3A_use.arma.errors">use.arma.errors</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include ARMA
errors or not. If <code>TRUE</code> the best fit is selected by AIC. If
<code>FALSE</code> then the selection algorithm does not consider ARMA errors.</p>
</td></tr>
<tr><td><code id="bats_+3A_use.parallel">use.parallel</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether or not to use
parallel processing.</p>
</td></tr>
<tr><td><code id="bats_+3A_num.cores">num.cores</code></td>
<td>
<p>The number of parallel processes to be used if using
parallel processing. If <code>NULL</code> then the number of logical cores is
detected and all available cores are used.</p>
</td></tr>
<tr><td><code id="bats_+3A_bc.lower">bc.lower</code></td>
<td>
<p>The lower limit (inclusive) for the Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="bats_+3A_bc.upper">bc.upper</code></td>
<td>
<p>The upper limit (inclusive) for the Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="bats_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If TRUE, point forecasts and fitted values are mean
forecast. Otherwise, these points can be considered the median of the
forecast densities.</p>
</td></tr>
<tr><td><code id="bats_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>bats</code>. If model is passed,
this same model is fitted to <code>y</code> without re-estimating any parameters.</p>
</td></tr>
<tr><td><code id="bats_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>auto.arima</code> when
choose an ARMA(p, q) model for the errors. (Note that xreg will be ignored,
as will any arguments concerning seasonality and differencing, but arguments
controlling the values of p and q will be used.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>bats</code>&quot;. The generic accessor functions
<code>fitted.values</code> and <code>residuals</code> extract useful features of the
value returned by <code>bats</code> and associated functions. The fitted model is
designated BATS(omega, p,q, phi, m1,...mJ) where omega is the Box-Cox
parameter and phi is the damping parameter; the error is modelled as an
ARMA(p,q) process and m1,...,mJ list the seasonal periods used in the model.
</p>


<h3>Author(s)</h3>

<p>Slava Razbash and Rob J Hyndman
</p>


<h3>References</h3>

<p>De Livera, A.M., Hyndman, R.J., &amp; Snyder, R. D. (2011),
Forecasting time series with complex seasonal patterns using exponential
smoothing, <em>Journal of the American Statistical Association</em>,
<b>106</b>(496), 1513-1527.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- bats(USAccDeaths)
plot(forecast(fit))

taylor.fit &lt;- bats(taylor)
plot(forecast(taylor.fit))

## End(Not run)

</code></pre>

<hr>
<h2 id='bizdays'>Number of trading days in each season</h2><span id='topic+bizdays'></span>

<h3>Description</h3>

<p>Returns number of trading days in each month or quarter of the observed time
period in a major financial center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bizdays(x, FinCenter = c("New York", "London", "NERC", "Toronto", "Zurich"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bizdays_+3A_x">x</code></td>
<td>
<p>Monthly or quarterly time series</p>
</td></tr>
<tr><td><code id="bizdays_+3A_fincenter">FinCenter</code></td>
<td>
<p>Major financial center.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for trading days length adjustments. More on how to define &quot;business
days&quot;, please refer to <code><a href="timeDate.html#topic+isBizday">isBizday</a></code>.
</p>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Earo Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monthdays">monthdays</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- ts(rnorm(30), start = c(2013, 2), frequency = 12)
bizdays(x, FinCenter = "New York")
</code></pre>

<hr>
<h2 id='bld.mbb.bootstrap'>Box-Cox and Loess-based decomposition bootstrap.</h2><span id='topic+bld.mbb.bootstrap'></span>

<h3>Description</h3>

<p>Generates bootstrapped versions of a time series using the Box-Cox and
Loess-based decomposition bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bld.mbb.bootstrap(x, num, block_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bld.mbb.bootstrap_+3A_x">x</code></td>
<td>
<p>Original time series.</p>
</td></tr>
<tr><td><code id="bld.mbb.bootstrap_+3A_num">num</code></td>
<td>
<p>Number of bootstrapped versions to generate.</p>
</td></tr>
<tr><td><code id="bld.mbb.bootstrap_+3A_block_size">block_size</code></td>
<td>
<p>Block size for the moving block bootstrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is described in Bergmeir et al. Box-Cox decomposition is
applied, together with STL or Loess (for non-seasonal time series), and the
remainder is bootstrapped using a moving block bootstrap.
</p>


<h3>Value</h3>

<p>A list with bootstrapped versions of the series. The first series in
the list is the original series.
</p>


<h3>Author(s)</h3>

<p>Christoph Bergmeir, Fotios Petropoulos
</p>


<h3>References</h3>

<p>Bergmeir, C., R. J. Hyndman, and J. M. Benitez (2016). Bagging
Exponential Smoothing Methods using STL Decomposition and Box-Cox
Transformation. International Journal of Forecasting 32, 303-312.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+baggedETS">baggedETS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bootstrapped_series &lt;- bld.mbb.bootstrap(WWWusage, 100)

</code></pre>

<hr>
<h2 id='BoxCox'>Box Cox Transformation</h2><span id='topic+BoxCox'></span><span id='topic+InvBoxCox'></span>

<h3>Description</h3>

<p>BoxCox() returns a transformation of the input variable using a Box-Cox
transformation. InvBoxCox() reverses the transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCox(x, lambda)

InvBoxCox(x, lambda, biasadj = FALSE, fvar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxCox_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_lambda">lambda</code></td>
<td>
<p>transformation parameter. If <code>lambda = "auto"</code>, then
the transformation parameter lambda is chosen using BoxCox.lambda (with a lower bound of -0.9)</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_fvar">fvar</code></td>
<td>
<p>Optional parameter required if biasadj=TRUE. Can either be the
forecast variance, or a list containing the interval <code>level</code>, and the
corresponding <code>upper</code> and <code>lower</code> intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Box-Cox transformation (as given by Bickel &amp; Doksum 1981) is given by </p>
<p style="text-align: center;"><code class="reqn">f_\lambda(x) =(sign(x)|x|^\lambda -
1)/\lambda</code>
</p>
<p> if <code class="reqn">\lambda\ne0</code>. For <code class="reqn">\lambda=0</code>,
</p>
<p style="text-align: center;"><code class="reqn">f_0(x)=\log(x)</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as x.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of
transformations. <em>JRSS B</em> <b>26</b> 211&ndash;246.
Bickel, P. J. and Doksum K. A. (1981) An Analysis of Transformations Revisited. <em>JASA</em> <b>76</b> 296-311.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+BoxCox.lambda">BoxCox.lambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lambda &lt;- BoxCox.lambda(lynx)
lynx.fit &lt;- ar(BoxCox(lynx,lambda))
plot(forecast(lynx.fit,h=20,lambda=lambda))

</code></pre>

<hr>
<h2 id='BoxCox.lambda'>Automatic selection of Box Cox transformation parameter</h2><span id='topic+BoxCox.lambda'></span>

<h3>Description</h3>

<p>If <code>method=="guerrero"</code>, Guerrero's (1993) method is used, where lambda
minimizes the coefficient of variation for subseries of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCox.lambda(x, method = c("guerrero", "loglik"), lower = -1, upper = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoxCox.lambda_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="BoxCox.lambda_+3A_method">method</code></td>
<td>
<p>Choose method to be used in calculating lambda.</p>
</td></tr>
<tr><td><code id="BoxCox.lambda_+3A_lower">lower</code></td>
<td>
<p>Lower limit for possible lambda values.</p>
</td></tr>
<tr><td><code id="BoxCox.lambda_+3A_upper">upper</code></td>
<td>
<p>Upper limit for possible lambda values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method=="loglik"</code>, the value of lambda is chosen to maximize the
profile log likelihood of a linear model fitted to <code>x</code>. For
non-seasonal data, a linear time trend is fitted while for seasonal data, a
linear time trend with seasonal dummy variables is used.
</p>


<h3>Value</h3>

<p>a number indicating the Box-Cox transformation parameter.
</p>


<h3>Author(s)</h3>

<p>Leanne Chhay and Rob J Hyndman
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of
transformations. <em>JRSS B</em> <b>26</b> 211&ndash;246.
</p>
<p>Guerrero, V.M. (1993) Time-series analysis supported by power
transformations. <em>Journal of Forecasting</em>, <b>12</b>, 37&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+BoxCox">BoxCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lambda &lt;- BoxCox.lambda(AirPassengers,lower=0)
air.fit &lt;- Arima(AirPassengers, order=c(0,1,1),
                 seasonal=list(order=c(0,1,1),period=12), lambda=lambda)
plot(forecast(air.fit))

</code></pre>

<hr>
<h2 id='checkresiduals'>Check that residuals from a time series model look like white noise</h2><span id='topic+checkresiduals'></span>

<h3>Description</h3>

<p>If <code>plot=TRUE</code>, produces a time plot of the residuals, the
corresponding ACF, and a histogram. If <code>test</code> is not <code>FALSE</code>,
the output from either a Ljung-Box test or Breusch-Godfrey test is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkresiduals(object, lag, test, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkresiduals_+3A_object">object</code></td>
<td>
<p>Either a time series model, a forecast object, or a time
series (assumed to be residuals).</p>
</td></tr>
<tr><td><code id="checkresiduals_+3A_lag">lag</code></td>
<td>
<p>Number of lags to use in the Ljung-Box or Breusch-Godfrey test.
If missing, it is set to <code>min(10,n/5)</code> for non-seasonal data, and
<code>min(2m, n/5)</code> for seasonal data, where <code>n</code> is the length of the series,
and <code>m</code> is the seasonal period of the data. It is further constrained to be
at least <code>df+3</code> where <code>df</code> is the degrees of freedom of the model. This
ensures there are at least 3 degrees of freedom used in the chi-squared test.</p>
</td></tr>
<tr><td><code id="checkresiduals_+3A_test">test</code></td>
<td>
<p>Test to use for serial correlation. By default, if <code>object</code>
is of class <code>lm</code>, then <code>test="BG"</code>. Otherwise, <code>test="LB"</code>.
Setting <code>test=FALSE</code> will prevent the test results being printed.</p>
</td></tr>
<tr><td><code id="checkresiduals_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, will produce the plot.</p>
</td></tr>
<tr><td><code id="checkresiduals_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code><a href="forecast.html#topic+ggtsdisplay">ggtsdisplay</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+ggtsdisplay">ggtsdisplay</a></code>, <code><a href="stats.html#topic+Box.test">Box.test</a></code>,
<code><a href="lmtest.html#topic+bgtest">bgtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- ets(WWWusage)
checkresiduals(fit)

</code></pre>

<hr>
<h2 id='croston'>Forecasts for intermittent demand using Croston's method</h2><span id='topic+croston'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for Croston's forecasts applied to
y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>croston(y, h = 10, alpha = 0.1, x = y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="croston_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="croston_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="croston_+3A_alpha">alpha</code></td>
<td>
<p>Value of alpha. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="croston_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Croston's (1972) method for intermittent demand forecasting, also
described in Shenstone and Hyndman (2005). Croston's method involves using
simple exponential smoothing (SES) on the non-zero elements of the time
series and a separate application of SES to the times between non-zero
elements of the time series. The smoothing parameters of the two
applications of SES are assumed to be equal and are denoted by <code>alpha</code>.
</p>
<p>Note that prediction intervals are not computed as Croston's method has no
underlying stochastic model.
</p>


<h3>Value</h3>

<p>An object of class <code>"forecast"</code> is a list containing at least
the following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model. The first element gives the model used for non-zero demands.
The second element gives the model used for times between non-zero demands.
Both elements are of class <code>forecast</code>.</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the
forecasting method as a character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a
time series</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself
or the time series used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is y minus fitted
values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>croston</code> and
associated functions.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Croston, J. (1972) &quot;Forecasting and stock control for
intermittent demands&quot;, <em>Operational Research Quarterly</em>, <b>23</b>(3),
289-303.
</p>
<p>Shenstone, L., and Hyndman, R.J. (2005) &quot;Stochastic models underlying
Croston's method for intermittent demand forecasting&quot;. <em>Journal of
Forecasting</em>, <b>24</b>, 389-402.
</p>


<h3>See Also</h3>

<p><code><a href="diffobj.html#topic+ses">ses</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rpois(20,lambda=.3)
fcast &lt;- croston(y)
plot(fcast)

</code></pre>

<hr>
<h2 id='CV'>Cross-validation statistic</h2><span id='topic+CV'></span>

<h3>Description</h3>

<p>Computes the leave-one-out cross-validation statistic (the mean of PRESS
&ndash; prediction residual sum of squares), AIC, corrected AIC, BIC and adjusted
R^2 values for a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CV_+3A_obj">obj</code></td>
<td>
<p>output from <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="forecast.html#topic+tslm">tslm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical vector containing CV, AIC, AICc, BIC and AdjR2 values.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- ts(rnorm(120,0,3) + 20*sin(2*pi*(1:120)/12), frequency=12)
fit1 &lt;- tslm(y ~ trend + season)
fit2 &lt;- tslm(y ~ season)
CV(fit1)
CV(fit2)

</code></pre>

<hr>
<h2 id='CVar'>k-fold Cross-Validation applied to an autoregressive model</h2><span id='topic+CVar'></span><span id='topic+print.CVar'></span>

<h3>Description</h3>

<p><code>CVar</code> computes the errors obtained by applying an autoregressive
modelling function to subsets of the time series <code>y</code> using k-fold
cross-validation as described in Bergmeir, Hyndman and Koo (2015). It also
applies a Ljung-Box test to the residuals. If this test is significant
(see returned pvalue), there is serial correlation in the residuals and the
model can be considered to be underfitting the data. In this case, the
cross-validated errors can underestimate the generalization error and should
not be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVar(
  y,
  k = 10,
  FUN = nnetar,
  cvtrace = FALSE,
  blocked = FALSE,
  LBlags = 24,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CVar_+3A_y">y</code></td>
<td>
<p>Univariate time series</p>
</td></tr>
<tr><td><code id="CVar_+3A_k">k</code></td>
<td>
<p>Number of folds to use for cross-validation.</p>
</td></tr>
<tr><td><code id="CVar_+3A_fun">FUN</code></td>
<td>
<p>Function to fit an autoregressive model. Currently, it only works
with the <code><a href="forecast.html#topic+nnetar">nnetar</a></code> function.</p>
</td></tr>
<tr><td><code id="CVar_+3A_cvtrace">cvtrace</code></td>
<td>
<p>Provide progress information.</p>
</td></tr>
<tr><td><code id="CVar_+3A_blocked">blocked</code></td>
<td>
<p>choose folds randomly or as blocks?</p>
</td></tr>
<tr><td><code id="CVar_+3A_lblags">LBlags</code></td>
<td>
<p>lags for the Ljung-Box test, defaults to 24, for yearly series can be set to 20</p>
</td></tr>
<tr><td><code id="CVar_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing information about the model and accuracy for each
fold, plus other summary information computed across folds.
</p>


<h3>Author(s)</h3>

<p>Gabriel Caceres and Rob J Hyndman
</p>


<h3>References</h3>

<p>Bergmeir, C., Hyndman, R.J., Koo, B. (2018) A note on the
validity of cross-validation for evaluating time series prediction.
<em>Computational Statistics &amp; Data Analysis</em>, <b>120</b>, 70-83.
<a href="https://robjhyndman.com/publications/cv-time-series/">https://robjhyndman.com/publications/cv-time-series/</a>.
</p>


<h3>See Also</h3>

<p><a href="forecast.html#topic+CV">CV</a>, <a href="forecast.html#topic+tsCV">tsCV</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
modelcv &lt;- CVar(lynx, k=5, lambda=0.15)
print(modelcv)
print(modelcv$fold1)

library(ggplot2)
autoplot(lynx, series="Data") +
  autolayer(modelcv$testfit, series="Fits") +
  autolayer(modelcv$residuals, series="Residuals")
ggAcf(modelcv$residuals)

</code></pre>

<hr>
<h2 id='dm.test'>Diebold-Mariano test for predictive accuracy</h2><span id='topic+dm.test'></span>

<h3>Description</h3>

<p>The Diebold-Mariano test compares the forecast accuracy of two forecast
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm.test(
  e1,
  e2,
  alternative = c("two.sided", "less", "greater"),
  h = 1,
  power = 2,
  varestimator = c("acf", "bartlett")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm.test_+3A_e1">e1</code></td>
<td>
<p>Forecast errors from method 1.</p>
</td></tr>
<tr><td><code id="dm.test_+3A_e2">e2</code></td>
<td>
<p>Forecast errors from method 2.</p>
</td></tr>
<tr><td><code id="dm.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or
<code>"less"</code>.  You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="dm.test_+3A_h">h</code></td>
<td>
<p>The forecast horizon used in calculating <code>e1</code> and <code>e2</code>.</p>
</td></tr>
<tr><td><code id="dm.test_+3A_power">power</code></td>
<td>
<p>The power used in the loss function. Usually 1 or 2.</p>
</td></tr>
<tr><td><code id="dm.test_+3A_varestimator">varestimator</code></td>
<td>
<p>a character string specifying the long-run variance estimator.
Options are <code>"acf"</code> (default) or <code>"bartlett"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the modified test proposed by Harvey, Leybourne and
Newbold (1997). The null hypothesis is that the two methods have the same
forecast accuracy. For <code>alternative="less"</code>, the alternative hypothesis
is that method 2 is less accurate than method 1. For
<code>alternative="greater"</code>, the alternative hypothesis is that method 2 is
more accurate than method 1. For <code>alternative="two.sided"</code>, the
alternative hypothesis is that method 1 and method 2 have different levels
of accuracy. The long-run variance estimator can either the
auto-correlation estimator <code>varestimator = "acf"</code>, or the estimator based
on Bartlett weights <code>varestimator = "bartlett"</code> which ensures a positive estimate.
Both long-run variance estimators are proposed in Diebold and Mariano (1995).
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following
components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the DM-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the forecast horizon and loss function power used in the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>varestimator</code></td>
<td>
<p>a character string describing the long-run variance estimator.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string with the value &quot;Diebold-Mariano Test&quot;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character vector giving the names of the two error series.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George Athanasopoulos and Kirill Kuroptev
</p>


<h3>References</h3>

<p>Diebold, F.X. and Mariano, R.S. (1995) Comparing predictive
accuracy. <em>Journal of Business and Economic Statistics</em>, <b>13</b>,
253-263.
</p>
<p>Harvey, D., Leybourne, S., &amp; Newbold, P. (1997). Testing the equality of
prediction mean squared errors. <em>International Journal of forecasting</em>,
<b>13</b>(2), 281-291.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test on in-sample one-step forecasts
f1 &lt;- ets(WWWusage)
f2 &lt;- auto.arima(WWWusage)
accuracy(f1)
accuracy(f2)
dm.test(residuals(f1), residuals(f2), h = 1)

# Test on out-of-sample one-step forecasts
f1 &lt;- ets(WWWusage[1:80])
f2 &lt;- auto.arima(WWWusage[1:80])
f1.out &lt;- ets(WWWusage[81:100], model = f1)
f2.out &lt;- Arima(WWWusage[81:100], model = f2)
accuracy(f1.out)
accuracy(f2.out)
dm.test(residuals(f1.out), residuals(f2.out), h = 1)
</code></pre>

<hr>
<h2 id='dshw'>Double-Seasonal Holt-Winters Forecasting</h2><span id='topic+dshw'></span>

<h3>Description</h3>

<p>Returns forecasts using Taylor's (2003) Double-Seasonal Holt-Winters method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dshw(
  y,
  period1 = NULL,
  period2 = NULL,
  h = 2 * max(period1, period2),
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  omega = NULL,
  phi = NULL,
  lambda = NULL,
  biasadj = FALSE,
  armethod = TRUE,
  model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dshw_+3A_y">y</code></td>
<td>
<p>Either an <code><a href="forecast.html#topic+msts">msts</a></code> object with two seasonal periods or a
numeric vector.</p>
</td></tr>
<tr><td><code id="dshw_+3A_period1">period1</code></td>
<td>
<p>Period of the shorter seasonal period. Only used if <code>y</code>
is not an <code><a href="forecast.html#topic+msts">msts</a></code> object.</p>
</td></tr>
<tr><td><code id="dshw_+3A_period2">period2</code></td>
<td>
<p>Period of the longer seasonal period.  Only used if <code>y</code>
is not an <code><a href="forecast.html#topic+msts">msts</a></code> object.</p>
</td></tr>
<tr><td><code id="dshw_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="dshw_+3A_alpha">alpha</code></td>
<td>
<p>Smoothing parameter for the level. If <code>NULL</code>, the
parameter is estimated using least squares.</p>
</td></tr>
<tr><td><code id="dshw_+3A_beta">beta</code></td>
<td>
<p>Smoothing parameter for the slope. If <code>NULL</code>, the parameter
is estimated using least squares.</p>
</td></tr>
<tr><td><code id="dshw_+3A_gamma">gamma</code></td>
<td>
<p>Smoothing parameter for the first seasonal period. If
<code>NULL</code>, the parameter is estimated using least squares.</p>
</td></tr>
<tr><td><code id="dshw_+3A_omega">omega</code></td>
<td>
<p>Smoothing parameter for the second seasonal period. If
<code>NULL</code>, the parameter is estimated using least squares.</p>
</td></tr>
<tr><td><code id="dshw_+3A_phi">phi</code></td>
<td>
<p>Autoregressive parameter. If <code>NULL</code>, the parameter is
estimated using least squares.</p>
</td></tr>
<tr><td><code id="dshw_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="dshw_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="dshw_+3A_armethod">armethod</code></td>
<td>
<p>If TRUE, the forecasts are adjusted using an AR(1) model for
the errors.</p>
</td></tr>
<tr><td><code id="dshw_+3A_model">model</code></td>
<td>
<p>If it's specified, an existing model is applied to a new data
set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taylor's (2003) double-seasonal Holt-Winters method uses additive trend and
multiplicative seasonality, where there are two seasonal components which
are multiplied together. For example, with a series of half-hourly data, one
would set <code>period1=48</code> for the daily period and <code>period2=336</code> for
the weekly period. The smoothing parameter notation used here is different
from that in Taylor (2003); instead it matches that used in Hyndman et al
(2008) and that used for the <code><a href="forecast.html#topic+ets">ets</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot; which is a list that includes the
following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>dshw</code>.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Taylor, J.W. (2003) Short-term electricity demand forecasting
using double seasonal exponential smoothing. <em>Journal of the
Operational Research Society</em>, <b>54</b>, 799-805.
</p>
<p>Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
<em>Forecasting with exponential smoothing: the state space approach</em>,
Springer-Verlag. <a href="http://www.exponentialsmoothing.net">http://www.exponentialsmoothing.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>, <code><a href="forecast.html#topic+ets">ets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fcast &lt;- dshw(taylor)
plot(fcast)

t &lt;- seq(0,5,by=1/20)
x &lt;- exp(sin(2*pi*t) + cos(2*pi*t*4) + rnorm(length(t),0,.1))
fit &lt;- dshw(x,20,5)
plot(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='easter'>Easter holidays in each season</h2><span id='topic+easter'></span>

<h3>Description</h3>

<p>Returns a vector of 0's and 1's or fractional results if Easter spans March
and April in the observed time period. Easter is defined as the days from
Good Friday to Easter Sunday inclusively, plus optionally Easter Monday if
<code>easter.mon=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>easter(x, easter.mon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="easter_+3A_x">x</code></td>
<td>
<p>Monthly or quarterly time series</p>
</td></tr>
<tr><td><code id="easter_+3A_easter.mon">easter.mon</code></td>
<td>
<p>If TRUE, the length of Easter holidays includes Easter
Monday.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for adjusting calendar effects.
</p>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Earo Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
easter(wineind, easter.mon = TRUE)
</code></pre>

<hr>
<h2 id='ets'>Exponential smoothing state space model</h2><span id='topic+ets'></span><span id='topic+print.ets'></span><span id='topic+summary.ets'></span><span id='topic+as.character.ets'></span><span id='topic+coef.ets'></span><span id='topic+tsdiag.ets'></span>

<h3>Description</h3>

<p>Returns ets model applied to <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ets(
  y,
  model = "ZZZ",
  damped = NULL,
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  phi = NULL,
  additive.only = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  lower = c(rep(1e-04, 3), 0.8),
  upper = c(rep(0.9999, 3), 0.98),
  opt.crit = c("lik", "amse", "mse", "sigma", "mae"),
  nmse = 3,
  bounds = c("both", "usual", "admissible"),
  ic = c("aicc", "aic", "bic"),
  restrict = TRUE,
  allow.multiplicative.trend = FALSE,
  use.initial.values = FALSE,
  na.action = c("na.contiguous", "na.interp", "na.fail"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ets_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="ets_+3A_model">model</code></td>
<td>
<p>Usually a three-character string identifying method using the
framework terminology of Hyndman et al. (2002) and Hyndman et al. (2008).
The first letter denotes the error type (&quot;A&quot;, &quot;M&quot; or &quot;Z&quot;); the second letter
denotes the trend type (&quot;N&quot;,&quot;A&quot;,&quot;M&quot; or &quot;Z&quot;); and the third letter denotes
the season type (&quot;N&quot;,&quot;A&quot;,&quot;M&quot; or &quot;Z&quot;). In all cases, &quot;N&quot;=none, &quot;A&quot;=additive,
&quot;M&quot;=multiplicative and &quot;Z&quot;=automatically selected. So, for example, &quot;ANN&quot; is
simple exponential smoothing with additive errors, &quot;MAM&quot; is multiplicative
Holt-Winters' method with multiplicative errors, and so on.
</p>
<p>It is also possible for the model to be of class <code>"ets"</code>, and equal to
the output from a previous call to <code>ets</code>. In this case, the same model
is fitted to <code>y</code> without re-estimating any smoothing parameters. See
also the <code>use.initial.values</code> argument.</p>
</td></tr>
<tr><td><code id="ets_+3A_damped">damped</code></td>
<td>
<p>If TRUE, use a damped trend (either additive or
multiplicative). If NULL, both damped and non-damped trends will be tried
and the best model (according to the information criterion <code>ic</code>)
returned.</p>
</td></tr>
<tr><td><code id="ets_+3A_alpha">alpha</code></td>
<td>
<p>Value of alpha. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_+3A_beta">beta</code></td>
<td>
<p>Value of beta. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_+3A_gamma">gamma</code></td>
<td>
<p>Value of gamma. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_+3A_phi">phi</code></td>
<td>
<p>Value of phi. If NULL, it is estimated.</p>
</td></tr>
<tr><td><code id="ets_+3A_additive.only">additive.only</code></td>
<td>
<p>If TRUE, will only consider additive models. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="ets_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated. When <code>lambda</code> is specified,
<code>additive.only</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ets_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="ets_+3A_lower">lower</code></td>
<td>
<p>Lower bounds for the parameters (alpha, beta, gamma, phi). Ignored if <code>bounds=="admissible"</code>.</p>
</td></tr>
<tr><td><code id="ets_+3A_upper">upper</code></td>
<td>
<p>Upper bounds for the parameters (alpha, beta, gamma, phi). Ignored if <code>bounds=="admissible"</code>.</p>
</td></tr>
<tr><td><code id="ets_+3A_opt.crit">opt.crit</code></td>
<td>
<p>Optimization criterion. One of &quot;mse&quot; (Mean Square Error),
&quot;amse&quot; (Average MSE over first <code>nmse</code> forecast horizons), &quot;sigma&quot;
(Standard deviation of residuals), &quot;mae&quot; (Mean of absolute residuals), or
&quot;lik&quot; (Log-likelihood, the default).</p>
</td></tr>
<tr><td><code id="ets_+3A_nmse">nmse</code></td>
<td>
<p>Number of steps for average multistep MSE (1&lt;=<code>nmse</code>&lt;=30).</p>
</td></tr>
<tr><td><code id="ets_+3A_bounds">bounds</code></td>
<td>
<p>Type of parameter space to impose: <code>"usual" </code> indicates
all parameters must lie between specified lower and upper bounds;
<code>"admissible"</code> indicates parameters must lie in the admissible space;
<code>"both"</code> (default) takes the intersection of these regions.</p>
</td></tr>
<tr><td><code id="ets_+3A_ic">ic</code></td>
<td>
<p>Information criterion to be used in model selection.</p>
</td></tr>
<tr><td><code id="ets_+3A_restrict">restrict</code></td>
<td>
<p>If <code>TRUE</code> (default), the models with infinite variance
will not be allowed.</p>
</td></tr>
<tr><td><code id="ets_+3A_allow.multiplicative.trend">allow.multiplicative.trend</code></td>
<td>
<p>If <code>TRUE</code>, models with multiplicative
trend are allowed when searching for a model. Otherwise, the model space
excludes them. This argument is ignored if a multiplicative trend model is
explicitly requested (e.g., using <code>model="MMN"</code>).</p>
</td></tr>
<tr><td><code id="ets_+3A_use.initial.values">use.initial.values</code></td>
<td>
<p>If <code>TRUE</code> and <code>model</code> is of class
<code>"ets"</code>, then the initial values in the model are also not
re-estimated.</p>
</td></tr>
<tr><td><code id="ets_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contains NA values. By default, the largest contiguous portion of the
time-series will be used.</p>
</td></tr>
<tr><td><code id="ets_+3A_...">...</code></td>
<td>
<p>Other undocumented arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the classification of methods as described in Hyndman et al (2008).
</p>
<p>The methodology is fully automatic. The only required argument for ets is
the time series. The model is chosen automatically if not specified. This
methodology performed extremely well on the M3-competition data. (See
Hyndman, et al, 2002, below.)
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>ets</code>&quot;.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>ets</code> and associated
functions.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Koehler, A.B., Snyder, R.D., and Grose, S. (2002)
&quot;A state space framework for automatic forecasting using exponential
smoothing methods&quot;, <em>International J. Forecasting</em>, <b>18</b>(3),
439&ndash;454.
</p>
<p>Hyndman, R.J., Akram, Md., and Archibald, B. (2008) &quot;The admissible
parameter space for exponential smoothing models&quot;. <em>Annals of
Statistical Mathematics</em>, <b>60</b>(2), 407&ndash;426.
</p>
<p>Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D. (2008)
<em>Forecasting with exponential smoothing: the state space approach</em>,
Springer-Verlag. <a href="http://www.exponentialsmoothing.net">http://www.exponentialsmoothing.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>, <code><a href="forecast.html#topic+rwf">rwf</a></code>,
<code><a href="forecast.html#topic+Arima">Arima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- ets(USAccDeaths)
plot(forecast(fit))

</code></pre>

<hr>
<h2 id='findfrequency'>Find dominant frequency of a time series</h2><span id='topic+findfrequency'></span>

<h3>Description</h3>

<p><code>findfrequency</code> returns the period of the dominant frequency of a time
series. For seasonal data, it will return the seasonal period. For cyclic
data, it will return the average cycle length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findfrequency(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findfrequency_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dominant frequency is determined from a spectral analysis of the time
series. First, a linear trend is removed, then the spectral density function
is estimated from the best fitting autoregressive model (based on the AIC).
If there is a large (possibly local) maximum in the spectral density
function at frequency <code class="reqn">f</code>, then the function will return the period
<code class="reqn">1/f</code> (rounded to the nearest integer). If no such dominant frequency
can be found, the function will return 1.
</p>


<h3>Value</h3>

<p>an integer value
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
findfrequency(USAccDeaths) # Monthly data
findfrequency(taylor) # Half-hourly data
findfrequency(lynx) # Annual data

</code></pre>

<hr>
<h2 id='fitted.ARFIMA'>h-step in-sample forecasts for time series models.</h2><span id='topic+fitted.ARFIMA'></span><span id='topic+fitted.Arima'></span><span id='topic+fitted.forecast_ARIMA'></span><span id='topic+fitted.ar'></span><span id='topic+fitted.bats'></span><span id='topic+fitted.ets'></span><span id='topic+fitted.modelAR'></span><span id='topic+fitted.nnetar'></span><span id='topic+fitted.tbats'></span>

<h3>Description</h3>

<p>Returns h-step forecasts for the data used in fitting the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ARFIMA'
fitted(object, h = 1, ...)

## S3 method for class 'Arima'
fitted(object, h = 1, ...)

## S3 method for class 'ar'
fitted(object, ...)

## S3 method for class 'bats'
fitted(object, h = 1, ...)

## S3 method for class 'ets'
fitted(object, h = 1, ...)

## S3 method for class 'modelAR'
fitted(object, h = 1, ...)

## S3 method for class 'nnetar'
fitted(object, h = 1, ...)

## S3 method for class 'tbats'
fitted(object, h = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ARFIMA_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>Arima</code>&quot;, &quot;<code>bats</code>&quot;,
&quot;<code>tbats</code>&quot;, &quot;<code>ets</code>&quot; or &quot;<code>nnetar</code>&quot;.</p>
</td></tr>
<tr><td><code id="fitted.ARFIMA_+3A_h">h</code></td>
<td>
<p>The number of steps to forecast ahead.</p>
</td></tr>
<tr><td><code id="fitted.ARFIMA_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A time series of the h-step forecasts.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+forecast.Arima">forecast.Arima</a></code>, <code><a href="forecast.html#topic+forecast.bats">forecast.bats</a></code>,
<code><a href="forecast.html#topic+forecast.tbats">forecast.tbats</a></code>, <code><a href="forecast.html#topic+forecast.ets">forecast.ets</a></code>,
<code><a href="forecast.html#topic+forecast.nnetar">forecast.nnetar</a></code>, <code><a href="forecast.html#topic+residuals.Arima">residuals.Arima</a></code>,
<code><a href="forecast.html#topic+residuals.bats">residuals.bats</a></code>, <code><a href="forecast.html#topic+residuals.tbats">residuals.tbats</a></code>,
<code><a href="forecast.html#topic+residuals.ets">residuals.ets</a></code>, <code><a href="forecast.html#topic+residuals.nnetar">residuals.nnetar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- ets(WWWusage)
plot(WWWusage)
lines(fitted(fit), col='red')
lines(fitted(fit, h=2), col='green')
lines(fitted(fit, h=3), col='blue')
legend("topleft", legend=paste("h =",1:3), col=2:4, lty=1)

</code></pre>

<hr>
<h2 id='forecast-package'>forecast: Forecasting Functions for Time Series and Linear Models</h2><span id='topic+forecast-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Methods and tools for displaying and analysing univariate time series forecasts including exponential smoothing via state space models and automatic ARIMA modelling.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rob Hyndman <a href="mailto:Rob.Hyndman@monash.edu">Rob.Hyndman@monash.edu</a> (<a href="https://orcid.org/0000-0002-2140-5352">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> George Athanasopoulos (<a href="https://orcid.org/0000-0002-5389-2802">ORCID</a>)
</p>
</li>
<li><p> Christoph Bergmeir (<a href="https://orcid.org/0000-0002-3665-9021">ORCID</a>)
</p>
</li>
<li><p> Gabriel Caceres (<a href="https://orcid.org/0000-0002-2947-2023">ORCID</a>)
</p>
</li>
<li><p> Leanne Chhay
</p>
</li>
<li><p> Kirill Kuroptev
</p>
</li>
<li><p> Mitchell O'Hara-Wild (<a href="https://orcid.org/0000-0001-6729-7695">ORCID</a>)
</p>
</li>
<li><p> Fotios Petropoulos (<a href="https://orcid.org/0000-0003-3039-4955">ORCID</a>)
</p>
</li>
<li><p> Slava Razbash
</p>
</li>
<li><p> Earo Wang (<a href="https://orcid.org/0000-0001-6448-5260">ORCID</a>)
</p>
</li>
<li><p> Farah Yasmeen (<a href="https://orcid.org/0000-0002-1479-5401">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Federico Garza [contributor]
</p>
</li>
<li><p> Daniele Girolimetto [contributor]
</p>
</li>
<li><p> Ross Ihaka [contributor, copyright holder]
</p>
</li>
<li><p> R Core Team [contributor, copyright holder]
</p>
</li>
<li><p> Daniel Reid [contributor]
</p>
</li>
<li><p> David Shaub [contributor]
</p>
</li>
<li><p> Yuan Tang (<a href="https://orcid.org/0000-0001-5243-233X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Xiaoqian Wang [contributor]
</p>
</li>
<li><p> Zhenyu Zhou [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pkg.robjhyndman.com/forecast/">https://pkg.robjhyndman.com/forecast/</a>
</p>
</li>
<li> <p><a href="https://github.com/robjhyndman/forecast">https://github.com/robjhyndman/forecast</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/robjhyndman/forecast/issues">https://github.com/robjhyndman/forecast/issues</a>
</p>
</li></ul>


<hr>
<h2 id='forecast.baggedModel'>Forecasting using a bagged model</h2><span id='topic+forecast.baggedModel'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for bagged models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggedModel'
forecast(
  object,
  h = ifelse(frequency(object$y) &gt; 1, 2 * frequency(object$y), 10),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.baggedModel_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>baggedModel</code>&quot; resulting from a call to
<code><a href="forecast.html#topic+baggedModel">baggedModel</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.baggedModel_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="forecast.baggedModel_+3A_...">...</code></td>
<td>
<p>Other arguments, passed on to the <code><a href="fabletools.html#topic+forecast">forecast</a></code> function of the original method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals are calculated as min and max values over the point forecasts from
the models in the ensemble. I.e., the intervals are not prediction
intervals, but give an indication of how different the forecasts within the
ensemble are.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>An object of class &quot;<code>forecast</code>&quot; is a list containing at least the
following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself or the
time series used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The external regressors used in fitting (if given).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That
is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph Bergmeir, Fotios Petropoulos
</p>


<h3>References</h3>

<p>Bergmeir, C., R. J. Hyndman, and J. M. Benitez (2016). Bagging
Exponential Smoothing Methods using STL Decomposition and Box-Cox
Transformation. International Journal of Forecasting 32, 303-312.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+baggedModel">baggedModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- baggedModel(WWWusage)
fcast &lt;- forecast(fit)
plot(fcast)

## Not run: 
fit2 &lt;- baggedModel(WWWusage, fn="auto.arima")
fcast2 &lt;- forecast(fit2)
plot(fcast2)
accuracy(fcast2)
## End(Not run)

</code></pre>

<hr>
<h2 id='forecast.bats'>Forecasting using BATS and TBATS models</h2><span id='topic+forecast.bats'></span><span id='topic+forecast.tbats'></span>

<h3>Description</h3>

<p>Forecasts <code>h</code> steps ahead with a BATS model. Prediction intervals are
also produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bats'
forecast(object, h, level = c(80, 95), fan = FALSE, biasadj = NULL, ...)

## S3 method for class 'tbats'
forecast(object, h, level = c(80, 95), fan = FALSE, biasadj = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.bats_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>bats</code>&quot;. Usually the result of a call
to <code><a href="forecast.html#topic+bats">bats</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.bats_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. Default value is twice the
largest seasonal period (for seasonal data) or ten (for non-seasonal data).</p>
</td></tr>
<tr><td><code id="forecast.bats_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.bats_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to <code>seq(51,99,by=3)</code>. This is suitable
for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.bats_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If TRUE, point forecasts and fitted values are mean
forecast. Otherwise, these points can be considered the median of the
forecast densities.</p>
</td></tr>
<tr><td><code id="forecast.bats_+3A_...">...</code></td>
<td>
<p>Other arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.bats</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A copy of the <code>bats</code> object</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr> <tr><td><code>lower</code></td>
<td>
<p>Lower limits for
prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself or the time
series used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted
values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Slava Razbash and Rob J Hyndman
</p>


<h3>References</h3>

<p>De Livera, A.M., Hyndman, R.J., &amp; Snyder, R. D. (2011),
Forecasting time series with complex seasonal patterns using exponential
smoothing, <em>Journal of the American Statistical Association</em>,
<b>106</b>(496), 1513-1527.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+bats">bats</a></code>, <code><a href="forecast.html#topic+tbats">tbats</a></code>,<code><a href="forecast.html#topic+forecast.ets">forecast.ets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- bats(USAccDeaths)
plot(forecast(fit))

taylor.fit &lt;- bats(taylor)
plot(forecast(taylor.fit))

## End(Not run)

</code></pre>

<hr>
<h2 id='forecast.ets'>Forecasting using ETS models</h2><span id='topic+forecast.ets'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate ETS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ets'
forecast(
  object,
  h = ifelse(object$m &gt; 1, 2 * object$m, 10),
  level = c(80, 95),
  fan = FALSE,
  simulate = FALSE,
  bootstrap = FALSE,
  npaths = 5000,
  PI = TRUE,
  lambda = object$lambda,
  biasadj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.ets_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>ets</code>&quot;. Usually the result of a call
to <code><a href="forecast.html#topic+ets">ets</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_simulate">simulate</code></td>
<td>
<p>If TRUE, prediction intervals are produced by simulation rather
than using analytic formulae. Errors are assumed to be normally distributed.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If TRUE, then prediction intervals are produced by simulation using
resampled errors (rather than normally distributed errors).</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_npaths">npaths</code></td>
<td>
<p>Number of sample paths used in computing simulated prediction
intervals.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_pi">PI</code></td>
<td>
<p>If TRUE, prediction intervals are produced, otherwise only point
forecasts are calculated. If <code>PI</code> is FALSE, then <code>level</code>,
<code>fan</code>, <code>simulate</code>, <code>bootstrap</code> and <code>npaths</code> are all
ignored.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.ets_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.ets</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
For models with additive errors, the residuals are x - fitted values. For
models with multiplicative errors, the residuals are equal to x /(fitted
values) - 1.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+ets">ets</a></code>, <code><a href="diffobj.html#topic+ses">ses</a></code>, <code><a href="forecast.html#topic+holt">holt</a></code>,
<code><a href="forecast.html#topic+hw">hw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- ets(USAccDeaths)
plot(forecast(fit,h=48))

</code></pre>

<hr>
<h2 id='forecast.fracdiff'>Forecasting using ARIMA or ARFIMA models</h2><span id='topic+forecast.fracdiff'></span><span id='topic+forecast.Arima'></span><span id='topic+forecast.forecast_ARIMA'></span><span id='topic+forecast.ar'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate ARIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fracdiff'
forecast(
  object,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = object$lambda,
  biasadj = NULL,
  ...
)

## S3 method for class 'Arima'
forecast(
  object,
  h = ifelse(object$arma[5] &gt; 1, 2 * object$arma[5], 10),
  level = c(80, 95),
  fan = FALSE,
  xreg = NULL,
  lambda = object$lambda,
  bootstrap = FALSE,
  npaths = 5000,
  biasadj = NULL,
  ...
)

## S3 method for class 'ar'
forecast(
  object,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  bootstrap = FALSE,
  npaths = 5000,
  biasadj = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.fracdiff_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>Arima</code>&quot;, &quot;<code>ar</code>&quot; or
&quot;<code>fracdiff</code>&quot;. Usually the result of a call to
<code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="forecast.html#topic+arfima">arfima</a></code> or
<code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. If <code>xreg</code> is used, <code>h</code>
is ignored and the number of forecast periods is set to the number of rows
of <code>xreg</code>.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to <code>seq(51,99,by=3)</code>. This is
suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_xreg">xreg</code></td>
<td>
<p>Future values of an regression variables (for class <code>Arima</code>
objects only). A numerical vector or matrix of external regressors; it should not be a data frame.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If <code>TRUE</code>, then prediction intervals computed using
simulation with resampled errors.</p>
</td></tr>
<tr><td><code id="forecast.fracdiff_+3A_npaths">npaths</code></td>
<td>
<p>Number of sample paths used in computing simulated prediction
intervals when <code>bootstrap=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>Arima</code> or <code>ar</code> objects, the function calls
<code><a href="stats.html#topic+predict.Arima">predict.Arima</a></code> or <code><a href="stats.html#topic+predict.ar">predict.ar</a></code> and
constructs an object of class &quot;<code>forecast</code>&quot; from the results. For
<code>fracdiff</code> objects, the calculations are all done within
<code><a href="forecast.html#topic+forecast.fracdiff">forecast.fracdiff</a></code> using the equations given by Peiris and
Perera (1988).
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.Arima</code>.
</p>
<p>An object of class &quot;<code>forecast</code>&quot; is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step
forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Peiris, M. &amp; Perera, B. (1988), On prediction with fractionally
differenced ARIMA models, <em>Journal of Time Series Analysis</em>,
<b>9</b>(3), 215-220.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.Arima">predict.Arima</a></code>,
<code><a href="stats.html#topic+predict.ar">predict.ar</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="stats.html#topic+ar">ar</a></code>,
<code><a href="forecast.html#topic+arfima">arfima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- Arima(WWWusage,c(3,1,0))
plot(forecast(fit))

library(fracdiff)
x &lt;- fracdiff.sim( 100, ma=-.4, d=.3)$series
fit &lt;- arfima(x)
plot(forecast(fit,h=30))

</code></pre>

<hr>
<h2 id='forecast.HoltWinters'>Forecasting using Holt-Winters objects</h2><span id='topic+forecast.HoltWinters'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate Holt-Winters time
series models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HoltWinters'
forecast(
  object,
  h = ifelse(frequency(object$x) &gt; 1, 2 * frequency(object$x), 10),
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.HoltWinters_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>HoltWinters</code>&quot;. Usually the result of
a call to <code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.HoltWinters_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="stats.html#topic+predict.HoltWinters">predict.HoltWinters</a></code> and constructs
an object of class &quot;<code>forecast</code>&quot; from the results.
</p>
<p>It is included for completeness, but the <code><a href="forecast.html#topic+ets">ets</a></code> is recommended
for use instead of <code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by
<code>forecast.HoltWinters</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted
model.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.HoltWinters">predict.HoltWinters</a></code>,
<code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- HoltWinters(WWWusage,gamma=FALSE)
plot(forecast(fit))

</code></pre>

<hr>
<h2 id='forecast.lm'>Forecast a linear model with possible time series components</h2><span id='topic+forecast.lm'></span>

<h3>Description</h3>

<p><code>forecast.lm</code> is used to predict linear models, especially those
involving trend and seasonality components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
forecast(
  object,
  newdata,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = object$lambda,
  biasadj = NULL,
  ts = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.lm_+3A_object">object</code></td>
<td>
<p>Object of class &quot;lm&quot;, usually the result of a call to
<code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="forecast.html#topic+tslm">tslm</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, it is assumed that the only variables are
trend and season, and <code>h</code> forecasts are produced.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. Ignored if <code>newdata</code>
present.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to seq(51,99,by=3). This is suitable
for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_ts">ts</code></td>
<td>
<p>If <code>TRUE</code>, the forecasts will be treated as time series
provided the original data is a time series; the <code>newdata</code> will be
interpreted as related to the subsequent time periods. If <code>FALSE</code>, any
time series attributes of the original data will be ignored.</p>
</td></tr>
<tr><td><code id="forecast.lm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stats.html#topic+predict.lm">predict.lm</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forecast.lm</code> is largely a wrapper for
<code><a href="stats.html#topic+predict.lm">predict.lm</a>()</code> except that it allows variables &quot;trend&quot;
and &quot;season&quot; which are created on the fly from the time series
characteristics of the data. Also, the output is reformatted into a
<code>forecast</code> object.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.lm</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The historical data for
the response variable.</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+tslm">tslm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
fit &lt;- tslm(y ~ trend + season)
plot(forecast(fit, h=20))

</code></pre>

<hr>
<h2 id='forecast.mlm'>Forecast a multiple linear model with possible time series components</h2><span id='topic+forecast.mlm'></span>

<h3>Description</h3>

<p><code>forecast.mlm</code> is used to predict multiple linear models, especially
those involving trend and seasonality components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlm'
forecast(
  object,
  newdata,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = object$lambda,
  biasadj = NULL,
  ts = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.mlm_+3A_object">object</code></td>
<td>
<p>Object of class &quot;mlm&quot;, usually the result of a call to
<code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="forecast.html#topic+tslm">tslm</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, it is assumed that the only variables are
trend and season, and <code>h</code> forecasts are produced.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. Ignored if <code>newdata</code>
present.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to seq(51,99,by=3). This is suitable
for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_ts">ts</code></td>
<td>
<p>If <code>TRUE</code>, the forecasts will be treated as time series
provided the original data is a time series; the <code>newdata</code> will be
interpreted as related to the subsequent time periods. If <code>FALSE</code>, any
time series attributes of the original data will be ignored.</p>
</td></tr>
<tr><td><code id="forecast.mlm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+forecast.lm">forecast.lm</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forecast.mlm</code> is largely a wrapper for
<code><a href="#topic+forecast.lm">forecast.lm</a>()</code> except that it allows forecasts to be
generated on multiple series. Also, the output is reformatted into a
<code>mforecast</code> object.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>mforecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.lm</code>.
</p>
<p>An object of class <code>"mforecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a multivariate time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals of each series</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals of each series</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The historical data for the response variable.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted
values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+tslm">tslm</a></code>, <code><a href="forecast.html#topic+forecast.lm">forecast.lm</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lungDeaths &lt;- cbind(mdeaths, fdeaths)
fit &lt;- tslm(lungDeaths ~ trend + season)
fcast &lt;- forecast(fit, h=10)

carPower &lt;- as.matrix(mtcars[,c("qsec","hp")])
carmpg &lt;- mtcars[,"mpg"]
fit &lt;- lm(carPower ~ carmpg)
fcast &lt;- forecast(fit, newdata=data.frame(carmpg=30))

</code></pre>

<hr>
<h2 id='forecast.modelAR'>Forecasting using user-defined model</h2><span id='topic+forecast.modelAR'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for user-defined
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelAR'
forecast(
  object,
  h = ifelse(object$m &gt; 1, 2 * object$m, 10),
  PI = FALSE,
  level = c(80, 95),
  fan = FALSE,
  xreg = NULL,
  lambda = object$lambda,
  bootstrap = FALSE,
  npaths = 1000,
  innov = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.modelAR_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>modelAR</code>&quot; resulting from a call to
<code><a href="forecast.html#topic+modelAR">modelAR</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. If <code>xreg</code> is used, <code>h</code>
is ignored and the number of forecast periods is set to the number of rows
of <code>xreg</code>.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_pi">PI</code></td>
<td>
<p>If TRUE, prediction intervals are produced, otherwise only point
forecasts are calculated. If <code>PI</code> is FALSE, then <code>level</code>,
<code>fan</code>, <code>bootstrap</code> and <code>npaths</code> are all ignored.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to <code>seq(51,99,by=3)</code>. This is
suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_xreg">xreg</code></td>
<td>
<p>Future values of external regressor variables.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If <code>TRUE</code>, then prediction intervals computed using
simulations with resampled residuals rather than normally distributed
errors. Ignored if <code>innov</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_npaths">npaths</code></td>
<td>
<p>Number of sample paths used in computing simulated prediction
intervals.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_innov">innov</code></td>
<td>
<p>Values to use as innovations for prediction intervals. Must be
a matrix with <code>h</code> rows and <code>npaths</code> columns (vectors are coerced
into a matrix). If present, <code>bootstrap</code> is ignored.</p>
</td></tr>
<tr><td><code id="forecast.modelAR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="forecast.html#topic+simulate.nnetar">simulate.nnetar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction intervals are calculated through simulations and can be slow.
Note that if the model is too complex and overfits the data, the residuals
can be arbitrarily small; if used for prediction interval calculations, they
could lead to misleadingly small values.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.nnetar</code>.
</p>
<p>An object of class &quot;<code>forecast</code>&quot; is a list containing at least the
following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself or the time series
used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The external regressors used in fitting (if given).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Gabriel Caceres
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+nnetar">nnetar</a></code>.
</p>

<hr>
<h2 id='forecast.mts'>Forecasting time series</h2><span id='topic+forecast.mts'></span><span id='topic+mforecast'></span><span id='topic+print.mforecast'></span><span id='topic+summary.mforecast'></span><span id='topic+as.data.frame.mforecast'></span>

<h3>Description</h3>

<p><code>mforecast</code> is a class of objects for forecasting from multivariate
time series or multivariate time series models. The function invokes
particular <em>methods</em> which depend on the class of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mts'
forecast(
  object,
  h = ifelse(frequency(object) &gt; 1, 2 * frequency(object), 10),
  level = c(80, 95),
  fan = FALSE,
  robust = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  find.frequency = FALSE,
  allow.multiplicative.trend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.mts_+3A_object">object</code></td>
<td>
<p>a multivariate time series or multivariate time series model
for which forecasts are required</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_fan">fan</code></td>
<td>
<p>If TRUE, <code>level</code> is set to <code>seq(51,99,by=3)</code>. This is
suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_robust">robust</code></td>
<td>
<p>If TRUE, the function is robust to missing values and outliers
in <code>object</code>. This argument is only valid when <code>object</code> is of class
<code>mts</code>.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_find.frequency">find.frequency</code></td>
<td>
<p>If TRUE, the function determines the appropriate
period, if the data is of unknown period.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_allow.multiplicative.trend">allow.multiplicative.trend</code></td>
<td>
<p>If TRUE, then ETS models with
multiplicative trends are allowed. Otherwise, only additive or no trend ETS
models are permitted.</p>
</td></tr>
<tr><td><code id="forecast.mts_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the forecasts produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, the function <code><a href="forecast.html#topic+forecast.mlm">forecast.mlm</a></code> makes multivariate
forecasts based on the results produced by <code><a href="forecast.html#topic+tslm">tslm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>mforecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the multivariate
forecasts and prediction intervals.
</p>
<p>The generic accessors functions <code>fitted.values</code> and <code>residuals</code>
extract various useful features of the value returned by
<code>forecast$model</code>.
</p>
<p>An object of class <code>"mforecast"</code> is a list usually containing at least
the following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
For models with additive errors, the residuals will be x minus the fitted
values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p>Other functions which return objects of class <code>"mforecast"</code>
are <code><a href="forecast.html#topic+forecast.mlm">forecast.mlm</a></code>, <code>forecast.varest</code>.
</p>

<hr>
<h2 id='forecast.nnetar'>Forecasting using neural network models</h2><span id='topic+forecast.nnetar'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate neural network
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnetar'
forecast(
  object,
  h = ifelse(object$m &gt; 1, 2 * object$m, 10),
  PI = FALSE,
  level = c(80, 95),
  fan = FALSE,
  xreg = NULL,
  lambda = object$lambda,
  bootstrap = FALSE,
  npaths = 1000,
  innov = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.nnetar_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>nnetar</code>&quot; resulting from a call to
<code><a href="forecast.html#topic+nnetar">nnetar</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting. If <code>xreg</code> is used, <code>h</code>
is ignored and the number of forecast periods is set to the number of rows
of <code>xreg</code>.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_pi">PI</code></td>
<td>
<p>If TRUE, prediction intervals are produced, otherwise only point
forecasts are calculated. If <code>PI</code> is FALSE, then <code>level</code>,
<code>fan</code>, <code>bootstrap</code> and <code>npaths</code> are all ignored.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to <code>seq(51,99,by=3)</code>. This is
suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_xreg">xreg</code></td>
<td>
<p>Future values of external regressor variables.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If <code>TRUE</code>, then prediction intervals computed using
simulations with resampled residuals rather than normally distributed
errors. Ignored if <code>innov</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_npaths">npaths</code></td>
<td>
<p>Number of sample paths used in computing simulated prediction
intervals.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_innov">innov</code></td>
<td>
<p>Values to use as innovations for prediction intervals. Must be
a matrix with <code>h</code> rows and <code>npaths</code> columns (vectors are coerced
into a matrix). If present, <code>bootstrap</code> is ignored.</p>
</td></tr>
<tr><td><code id="forecast.nnetar_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="forecast.html#topic+simulate.nnetar">simulate.nnetar</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction intervals are calculated through simulations and can be slow.
Note that if the network is too complex and overfits the data, the residuals
can be arbitrarily small; if used for prediction interval calculations, they
could lead to misleadingly small values. It is possible to use out-of-sample
residuals to ameliorate this, see examples.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.nnetar</code>.
</p>
<p>An object of class &quot;<code>forecast</code>&quot; is a list containing at least the
following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself or the time series
used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The external regressors used in fitting (if given).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Gabriel Caceres
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+nnetar">nnetar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit &amp; forecast model
fit &lt;- nnetar(USAccDeaths, size=2)
fcast &lt;- forecast(fit, h=20)
plot(fcast)

## Not run: 
## Include prediction intervals in forecast
fcast2 &lt;- forecast(fit, h=20, PI=TRUE, npaths=100)
plot(fcast2)

## Set up out-of-sample innovations using cross-validation
fit_cv &lt;- CVar(USAccDeaths,  size=2)
res_sd &lt;- sd(fit_cv$residuals, na.rm=TRUE)
myinnovs &lt;- rnorm(20*100, mean=0, sd=res_sd)
## Forecast using new innovations
fcast3 &lt;- forecast(fit, h=20, PI=TRUE, npaths=100, innov=myinnovs)
plot(fcast3)

## End(Not run)

</code></pre>

<hr>
<h2 id='forecast.stl'>Forecasting using stl objects</h2><span id='topic+forecast.stl'></span><span id='topic+stlm'></span><span id='topic+forecast.stlm'></span><span id='topic+stlf'></span>

<h3>Description</h3>

<p>Forecasts of STL objects are obtained by applying a non-seasonal forecasting
method to the seasonally adjusted data and re-seasonalizing using the last
year of the seasonal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stl'
forecast(
  object,
  method = c("ets", "arima", "naive", "rwdrift"),
  etsmodel = "ZZN",
  forecastfunction = NULL,
  h = frequency(object$time.series) * 2,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = NULL,
  xreg = NULL,
  newxreg = NULL,
  allow.multiplicative.trend = FALSE,
  ...
)

stlm(
  y,
  s.window = 7 + 4 * seq(6),
  robust = FALSE,
  method = c("ets", "arima"),
  modelfunction = NULL,
  model = NULL,
  etsmodel = "ZZN",
  lambda = NULL,
  biasadj = FALSE,
  xreg = NULL,
  allow.multiplicative.trend = FALSE,
  x = y,
  ...
)

## S3 method for class 'stlm'
forecast(
  object,
  h = 2 * object$m,
  level = c(80, 95),
  fan = FALSE,
  lambda = object$lambda,
  biasadj = NULL,
  newxreg = NULL,
  allow.multiplicative.trend = FALSE,
  ...
)

stlf(
  y,
  h = frequency(x) * 2,
  s.window = 7 + 4 * seq(6),
  t.window = NULL,
  robust = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.stl_+3A_object">object</code></td>
<td>
<p>An object of class <code>stl</code> or <code>stlm</code>. Usually the
result of a call to <code><a href="stats.html#topic+stl">stl</a></code> or <code>stlm</code>.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_method">method</code></td>
<td>
<p>Method to use for forecasting the seasonally adjusted series.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_etsmodel">etsmodel</code></td>
<td>
<p>The ets model specification passed to
<code><a href="#topic+ets">ets</a></code>. By default it allows any non-seasonal model. If
<code>method!="ets"</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_forecastfunction">forecastfunction</code></td>
<td>
<p>An alternative way of specifying the function for
forecasting the seasonally adjusted series. If <code>forecastfunction</code> is
not <code>NULL</code>, then <code>method</code> is ignored. Otherwise <code>method</code> is
used to specify the forecasting method to be used.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_fan">fan</code></td>
<td>
<p>If <code>TRUE</code>, level is set to seq(51,99,by=3). This is suitable
for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_xreg">xreg</code></td>
<td>
<p>Historical regressors to be used in
<code><a href="#topic+auto.arima">auto.arima</a>()</code> when <code>method=="arima"</code>.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_newxreg">newxreg</code></td>
<td>
<p>Future regressors to be used in
<code><a href="#topic+forecast.Arima">forecast.Arima</a>()</code>.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_allow.multiplicative.trend">allow.multiplicative.trend</code></td>
<td>
<p>If TRUE, then ETS models with
multiplicative trends are allowed. Otherwise, only additive or no trend ETS
models are permitted.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>forecast.stl</code>,
<code>modelfunction</code> or <code>forecastfunction</code>.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_y">y</code></td>
<td>
<p>A univariate numeric time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_s.window">s.window</code></td>
<td>
<p>Either the character string &ldquo;periodic&rdquo; or the span (in
lags) of the loess window for seasonal extraction.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code>, robust fitting will used in the loess
procedure within <code><a href="stats.html#topic+stl">stl</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_modelfunction">modelfunction</code></td>
<td>
<p>An alternative way of specifying the function for
modelling the seasonally adjusted series. If <code>modelfunction</code> is not
<code>NULL</code>, then <code>method</code> is ignored. Otherwise <code>method</code> is used
to specify the time series model to be used.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>stlm</code>. If a <code>stlm</code>
model is passed, this same model is fitted to y without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="forecast.stl_+3A_t.window">t.window</code></td>
<td>
<p>A number to control the smoothness of the trend. See
<code><a href="stats.html#topic+stl">stl</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stlm</code> takes a time series <code>y</code>, applies an STL decomposition, and
models the seasonally adjusted data using the model passed as
<code>modelfunction</code> or specified using <code>method</code>. It returns an object
that includes the original STL decomposition and a time series model fitted
to the seasonally adjusted data. This object can be passed to the
<code>forecast.stlm</code> for forecasting.
</p>
<p><code>forecast.stlm</code> forecasts the seasonally adjusted data, then
re-seasonalizes the results by adding back the last year of the estimated
seasonal component.
</p>
<p><code>stlf</code> combines <code>stlm</code> and <code>forecast.stlm</code>. It takes a
<code>ts</code> argument, applies an STL decomposition, models the seasonally
adjusted data, reseasonalizes, and returns the forecasts. However, it allows
more general forecasting methods to be specified via
<code>forecastfunction</code>.
</p>
<p><code>forecast.stl</code> is similar to <code>stlf</code> except that it takes the STL
decomposition as the first argument, instead of the time series.
</p>
<p>Note that the prediction intervals ignore the uncertainty associated with
the seasonal component. They are computed using the prediction intervals
from the seasonally adjusted series, which are then reseasonalized using the
last year of the seasonal component. The uncertainty in the seasonal
component is ignored.
</p>
<p>The time series model for the seasonally adjusted data can be specified in
<code>stlm</code> using either <code>method</code> or <code>modelfunction</code>. The
<code>method</code> argument provides a shorthand way of specifying
<code>modelfunction</code> for a few special cases. More generally,
<code>modelfunction</code> can be any function with first argument a <code>ts</code>
object, that returns an object that can be passed to <code><a href="fabletools.html#topic+forecast">forecast</a></code>.
For example, <code>forecastfunction=ar</code> uses the <code><a href="stats.html#topic+ar">ar</a></code> function
for modelling the seasonally adjusted series.
</p>
<p>The forecasting method for the seasonally adjusted data can be specified in
<code>stlf</code> and <code>forecast.stl</code> using either <code>method</code> or
<code>forecastfunction</code>. The <code>method</code> argument provides a shorthand way
of specifying <code>forecastfunction</code> for a few special cases. More
generally, <code>forecastfunction</code> can be any function with first argument a
<code>ts</code> object, and other <code>h</code> and <code>level</code>, which returns an
object of class <code><a href="fabletools.html#topic+forecast">forecast</a></code>. For example,
<code>forecastfunction=thetaf</code> uses the <code><a href="forecast.html#topic+thetaf">thetaf</a></code> function for
forecasting the seasonally adjusted series.
</p>


<h3>Value</h3>

<p><code>stlm</code> returns an object of class <code>stlm</code>. The other
functions return objects of class <code>forecast</code>.
</p>
<p>There are many methods for working with <code><a href="fabletools.html#topic+forecast">forecast</a></code> objects
including <code>summary</code> to obtain and print a summary of the results, while
<code>plot</code> produces a plot of the forecasts and prediction intervals. The
generic accessor functions <code>fitted.values</code> and <code>residuals</code> extract
useful features.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="forecast.html#topic+forecast.ets">forecast.ets</a></code>,
<code><a href="forecast.html#topic+forecast.Arima">forecast.Arima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tsmod &lt;- stlm(USAccDeaths, modelfunction = ar)
plot(forecast(tsmod, h = 36))

decomp &lt;- stl(USAccDeaths, s.window = "periodic")
plot(forecast(decomp))

plot(stlf(AirPassengers, lambda = 0))
</code></pre>

<hr>
<h2 id='forecast.StructTS'>Forecasting using Structural Time Series models</h2><span id='topic+forecast.StructTS'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for univariate structural time
series models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'StructTS'
forecast(
  object,
  h = ifelse(object$coef["epsilon"] &gt; 1e-10, 2 * object$xtsp[3], 10),
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.StructTS_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>StructTS</code>&quot;. Usually the result of a
call to <code><a href="stats.html#topic+StructTS">StructTS</a></code>.</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.StructTS_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>predict.StructTS</code> and constructs an object of
class &quot;<code>forecast</code>&quot; from the results.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>forecast.StructTS</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step
forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+StructTS">StructTS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- StructTS(WWWusage,"level")
plot(forecast(fit))

</code></pre>

<hr>
<h2 id='forecast.ts'>Forecasting time series</h2><span id='topic+forecast.ts'></span><span id='topic+print.forecast'></span><span id='topic+summary.forecast'></span><span id='topic+as.data.frame.forecast'></span><span id='topic+as.ts.forecast'></span><span id='topic+forecast.default'></span>

<h3>Description</h3>

<p><code>forecast</code> is a generic function for forecasting from time series or
time series models. The function invokes particular <em>methods</em> which
depend on the class of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
forecast(
  object,
  h = ifelse(frequency(object) &gt; 1, 2 * frequency(object), 10),
  level = c(80, 95),
  fan = FALSE,
  robust = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  find.frequency = FALSE,
  allow.multiplicative.trend = FALSE,
  model = NULL,
  ...
)

## Default S3 method:
forecast(object, ...)

## S3 method for class 'forecast'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.ts_+3A_object">object</code></td>
<td>
<p>a time series or time series model for which forecasts are
required</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_fan">fan</code></td>
<td>
<p>If TRUE, <code>level</code> is set to <code>seq(51,99,by=3)</code>. This is
suitable for fan plots.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_robust">robust</code></td>
<td>
<p>If TRUE, the function is robust to missing values and outliers
in <code>object</code>. This argument is only valid when <code>object</code> is of class
<code>ts</code>.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_find.frequency">find.frequency</code></td>
<td>
<p>If TRUE, the function determines the appropriate
period, if the data is of unknown period.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_allow.multiplicative.trend">allow.multiplicative.trend</code></td>
<td>
<p>If TRUE, then ETS models with
multiplicative trends are allowed. Otherwise, only additive or no trend ETS
models are permitted.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_model">model</code></td>
<td>
<p>An object describing a time series model; e.g., one of of class
<code>ets</code>, <code>Arima</code>, <code>bats</code>, <code>tbats</code>, or <code>nnetar</code>.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the forecasts produced. If
<code>model=NULL</code>, <code>forecast.ts</code> passes these to <code><a href="forecast.html#topic+ets">ets</a></code> or
<code><a href="forecast.html#topic+stlf">stlf</a></code> depending on the frequency of the time series. If
<code>model</code> is not <code>NULL</code>, the arguments are passed to the relevant
modelling function.</p>
</td></tr>
<tr><td><code id="forecast.ts_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, the function <code><a href="forecast.html#topic+forecast.Arima">forecast.Arima</a></code> makes forecasts based
on the results produced by <code><a href="stats.html#topic+arima">arima</a></code>.
</p>
<p>If <code>model=NULL</code>,the function <code><a href="forecast.html#topic+forecast.ts">forecast.ts</a></code> makes forecasts
using <code><a href="forecast.html#topic+ets">ets</a></code> models (if the data are non-seasonal or the seasonal
period is 12 or less) or <code><a href="forecast.html#topic+stlf">stlf</a></code> (if the seasonal period is 13 or
more).
</p>
<p>If <code>model</code> is not <code>NULL</code>, <code>forecast.ts</code> will apply the
<code>model</code> to the <code>object</code> time series, and then generate forecasts
accordingly.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessors functions <code>fitted.values</code> and <code>residuals</code>
extract various useful features of the value returned by
<code>forecast$model</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list usually containing at least
the following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
For models with additive errors, the residuals will be x minus the fitted
values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p>Other functions which return objects of class <code>"forecast"</code> are
<code><a href="forecast.html#topic+forecast.ets">forecast.ets</a></code>, <code><a href="forecast.html#topic+forecast.Arima">forecast.Arima</a></code>,
<code><a href="forecast.html#topic+forecast.HoltWinters">forecast.HoltWinters</a></code>, <code><a href="forecast.html#topic+forecast.StructTS">forecast.StructTS</a></code>,
<code><a href="forecast.html#topic+meanf">meanf</a></code>, <code><a href="forecast.html#topic+rwf">rwf</a></code>, <code><a href="forecast.html#topic+splinef">splinef</a></code>,
<code><a href="forecast.html#topic+thetaf">thetaf</a></code>, <code><a href="forecast.html#topic+croston">croston</a></code>, <code><a href="diffobj.html#topic+ses">ses</a></code>,
<code><a href="forecast.html#topic+holt">holt</a></code>, <code><a href="forecast.html#topic+hw">hw</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
WWWusage %&gt;% forecast %&gt;% plot
fit &lt;- ets(window(WWWusage, end=60))
fc &lt;- forecast(WWWusage, model=fit)
</code></pre>

<hr>
<h2 id='fourier'>Fourier terms for modelling seasonality</h2><span id='topic+fourier'></span><span id='topic+fourierf'></span>

<h3>Description</h3>

<p><code>fourier</code> returns a matrix containing terms from a Fourier series, up
to order <code>K</code>, suitable for use in <code><a href="forecast.html#topic+Arima">Arima</a></code>,
<code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>, or <code><a href="forecast.html#topic+tslm">tslm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier(x, K, h = NULL)

fourierf(x, K, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourier_+3A_x">x</code></td>
<td>
<p>Seasonal time series: a <code>ts</code> or a <code>msts</code> object</p>
</td></tr>
<tr><td><code id="fourier_+3A_k">K</code></td>
<td>
<p>Maximum order(s) of Fourier terms</p>
</td></tr>
<tr><td><code id="fourier_+3A_h">h</code></td>
<td>
<p>Number of periods ahead to forecast (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fourierf</code> is deprecated, instead use the <code>h</code> argument in
<code>fourier</code>.
</p>
<p>The period of the Fourier terms is determined from the time series
characteristics of <code>x</code>. When <code>h</code> is missing, the length of
<code>x</code> also determines the number of rows for the matrix returned by
<code>fourier</code>. Otherwise, the value of <code>h</code> determines the number of
rows for the matrix returned by <code>fourier</code>, typically used for
forecasting. The values within <code>x</code> are not used.
</p>
<p>Typical use would omit <code>h</code> when generating Fourier terms for training a model
and include <code>h</code> when generating Fourier terms for forecasting.
</p>
<p>When <code>x</code> is a <code>ts</code> object, the value of <code>K</code> should be an
integer and specifies the number of sine and cosine terms to return. Thus,
the matrix returned has <code>2*K</code> columns.
</p>
<p>When <code>x</code> is a <code>msts</code> object, then <code>K</code> should be a vector of
integers specifying the number of sine and cosine terms for each of the
seasonal periods. Then the matrix returned will have <code>2*sum(K)</code>
columns.
</p>


<h3>Value</h3>

<p>Numerical matrix.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+seasonaldummy">seasonaldummy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

# Using Fourier series for a "ts" object
# K is chosen to minimize the AICc
deaths.model  &lt;- auto.arima(USAccDeaths, xreg=fourier(USAccDeaths,K=5), seasonal=FALSE)
deaths.fcast &lt;- forecast(deaths.model, xreg=fourier(USAccDeaths, K=5, h=36))
autoplot(deaths.fcast) + xlab("Year")

# Using Fourier series for a "msts" object
taylor.lm &lt;- tslm(taylor ~ fourier(taylor, K = c(3, 3)))
taylor.fcast &lt;- forecast(taylor.lm,
    data.frame(fourier(taylor, K = c(3, 3), h = 270)))
autoplot(taylor.fcast)

</code></pre>

<hr>
<h2 id='gas'>Australian monthly gas production</h2><span id='topic+gas'></span>

<h3>Description</h3>

<p>Australian monthly gas production: 1956&ndash;1995.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gas
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>Australian Bureau of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(gas)
seasonplot(gas)
tsdisplay(gas)

</code></pre>

<hr>
<h2 id='getResponse'>Get response variable from time series model.</h2><span id='topic+getResponse'></span><span id='topic+getResponse.default'></span><span id='topic+getResponse.lm'></span><span id='topic+getResponse.Arima'></span><span id='topic+getResponse.fracdiff'></span><span id='topic+getResponse.ar'></span><span id='topic+getResponse.tbats'></span><span id='topic+getResponse.bats'></span><span id='topic+getResponse.mforecast'></span><span id='topic+getResponse.baggedModel'></span>

<h3>Description</h3>

<p><code>getResponse</code> is a generic function for extracting the historical data
from a time series model (including <code>Arima</code>, <code>ets</code>, <code>ar</code>,
<code>fracdiff</code>), a linear model of class <code>lm</code>, or a forecast object.
The function invokes particular <em>methods</em> which depend on the class of
the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResponse(object, ...)

## Default S3 method:
getResponse(object, ...)

## S3 method for class 'lm'
getResponse(object, ...)

## S3 method for class 'Arima'
getResponse(object, ...)

## S3 method for class 'fracdiff'
getResponse(object, ...)

## S3 method for class 'ar'
getResponse(object, ...)

## S3 method for class 'tbats'
getResponse(object, ...)

## S3 method for class 'bats'
getResponse(object, ...)

## S3 method for class 'mforecast'
getResponse(object, ...)

## S3 method for class 'baggedModel'
getResponse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResponse_+3A_object">object</code></td>
<td>
<p>a time series model or forecast object.</p>
</td></tr>
<tr><td><code id="getResponse_+3A_...">...</code></td>
<td>
<p>Additional arguments that are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector or a time series object of class <code>ts</code>.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>

<hr>
<h2 id='gghistogram'>Histogram with optional normal and kernel density functions</h2><span id='topic+gghistogram'></span>

<h3>Description</h3>

<p>Plots a histogram and density estimates using ggplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gghistogram(
  x,
  add.normal = FALSE,
  add.kde = FALSE,
  add.rug = TRUE,
  bins,
  boundary = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gghistogram_+3A_x">x</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
<tr><td><code id="gghistogram_+3A_add.normal">add.normal</code></td>
<td>
<p>Add a normal density function for comparison</p>
</td></tr>
<tr><td><code id="gghistogram_+3A_add.kde">add.kde</code></td>
<td>
<p>Add a kernel density estimate for comparison</p>
</td></tr>
<tr><td><code id="gghistogram_+3A_add.rug">add.rug</code></td>
<td>
<p>Add a rug plot on the horizontal axis</p>
</td></tr>
<tr><td><code id="gghistogram_+3A_bins">bins</code></td>
<td>
<p>The number of bins to use for the histogram. Selected by default
using the Friedman-Diaconis rule given by <code><a href="grDevices.html#topic+nclass.FD">nclass.FD</a></code></p>
</td></tr>
<tr><td><code id="gghistogram_+3A_boundary">boundary</code></td>
<td>
<p>A boundary between two bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gghistogram(lynx, add.kde=TRUE)

</code></pre>

<hr>
<h2 id='gglagplot'>Time series lag ggplots</h2><span id='topic+gglagplot'></span><span id='topic+gglagchull'></span>

<h3>Description</h3>

<p>Plots a lag plot using ggplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gglagplot(
  x,
  lags = ifelse(frequency(x) &gt; 9, 16, 9),
  set.lags = 1:lags,
  diag = TRUE,
  diag.col = "gray",
  do.lines = TRUE,
  colour = TRUE,
  continuous = frequency(x) &gt; 12,
  labels = FALSE,
  seasonal = TRUE,
  ...
)

gglagchull(
  x,
  lags = ifelse(frequency(x) &gt; 1, min(12, frequency(x)), 4),
  set.lags = 1:lags,
  diag = TRUE,
  diag.col = "gray",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gglagplot_+3A_x">x</code></td>
<td>
<p>a time series object (type <code>ts</code>).</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_lags">lags</code></td>
<td>
<p>number of lag plots desired, see arg set.lags.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_set.lags">set.lags</code></td>
<td>
<p>vector of positive integers specifying which lags to use.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_diag">diag</code></td>
<td>
<p>logical indicating if the x=y diagonal should be drawn.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_diag.col">diag.col</code></td>
<td>
<p>color to be used for the diagonal if(diag).</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_do.lines">do.lines</code></td>
<td>
<p>if TRUE, lines will be drawn, otherwise points will be
drawn.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_colour">colour</code></td>
<td>
<p>logical indicating if lines should be coloured.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_continuous">continuous</code></td>
<td>
<p>Should the colour scheme for years be continuous or
discrete?</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_labels">labels</code></td>
<td>
<p>logical indicating if labels should be used.</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_seasonal">seasonal</code></td>
<td>
<p>Should the line colour be based on seasonal characteristics
(TRUE), or sequential (FALSE).</p>
</td></tr>
<tr><td><code id="gglagplot_+3A_...">...</code></td>
<td>
<p>Not used (for consistency with lag.plot)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;gglagplot&rdquo; will plot time series against lagged versions of
themselves. Helps visualising 'auto-dependence' even when auto-correlations
vanish.
</p>
<p>&ldquo;gglagchull&rdquo; will layer convex hulls of the lags, layered on a single
plot. This helps visualise the change in 'auto-dependence' as lags increase.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lag.plot">lag.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gglagplot(woolyrnq)
gglagplot(woolyrnq,seasonal=FALSE)

lungDeaths &lt;- cbind(mdeaths, fdeaths)
gglagplot(lungDeaths, lags=2)
gglagchull(lungDeaths, lags=6)

gglagchull(woolyrnq)

</code></pre>

<hr>
<h2 id='ggmonthplot'>Create a seasonal subseries ggplot</h2><span id='topic+ggmonthplot'></span><span id='topic+ggsubseriesplot'></span>

<h3>Description</h3>

<p>Plots a subseries plot using ggplot. Each season is plotted as a separate
mini time series. The blue lines represent the mean of the observations
within each season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggmonthplot(x, labels = NULL, times = time(x), phase = cycle(x), ...)

ggsubseriesplot(x, labels = NULL, times = time(x), phase = cycle(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggmonthplot_+3A_x">x</code></td>
<td>
<p>a time series object (type <code>ts</code>).</p>
</td></tr>
<tr><td><code id="ggmonthplot_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to use for each 'season'</p>
</td></tr>
<tr><td><code id="ggmonthplot_+3A_times">times</code></td>
<td>
<p>A vector of times for each observation</p>
</td></tr>
<tr><td><code id="ggmonthplot_+3A_phase">phase</code></td>
<td>
<p>A vector of seasonal components</p>
</td></tr>
<tr><td><code id="ggmonthplot_+3A_...">...</code></td>
<td>
<p>Not used (for consistency with monthplot)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ggmonthplot</code> function is simply a wrapper for
<code>ggsubseriesplot</code> as a convenience for users familiar with
<code><a href="stats.html#topic+monthplot">monthplot</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+monthplot">monthplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ggsubseriesplot(AirPassengers)
ggsubseriesplot(woolyrnq)

</code></pre>

<hr>
<h2 id='ggseasonplot'>Seasonal plot</h2><span id='topic+ggseasonplot'></span><span id='topic+seasonplot'></span>

<h3>Description</h3>

<p>Plots a seasonal plot as described in Hyndman and Athanasopoulos (2014,
chapter 2). This is like a time plot except that the data are plotted
against the seasons in separate years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggseasonplot(
  x,
  season.labels = NULL,
  year.labels = FALSE,
  year.labels.left = FALSE,
  type = NULL,
  col = NULL,
  continuous = FALSE,
  polar = FALSE,
  labelgap = 0.04,
  ...
)

seasonplot(
  x,
  s,
  season.labels = NULL,
  year.labels = FALSE,
  year.labels.left = FALSE,
  type = "o",
  main,
  xlab = NULL,
  ylab = "",
  col = 1,
  labelgap = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggseasonplot_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_season.labels">season.labels</code></td>
<td>
<p>Labels for each season in the &quot;year&quot;</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_year.labels">year.labels</code></td>
<td>
<p>Logical flag indicating whether labels for each year of
data should be plotted on the right.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_year.labels.left">year.labels.left</code></td>
<td>
<p>Logical flag indicating whether labels for each year
of data should be plotted on the left.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_type">type</code></td>
<td>
<p>plot type (as for <code><a href="graphics.html#topic+plot">plot</a></code>). Not yet
supported for ggseasonplot.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_col">col</code></td>
<td>
<p>Colour</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_continuous">continuous</code></td>
<td>
<p>Should the colour scheme for years be continuous or
discrete?</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_polar">polar</code></td>
<td>
<p>Plot the graph on seasonal coordinates</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_labelgap">labelgap</code></td>
<td>
<p>Distance between year labels and plotted lines</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_s">s</code></td>
<td>
<p>seasonal frequency of x</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="ggseasonplot_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2018) <em>Forecasting: principles
and practice</em>, 2nd edition, OTexts: Melbourne, Australia.
<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+monthplot">monthplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggseasonplot(AirPassengers, col=rainbow(12), year.labels=TRUE)
ggseasonplot(AirPassengers, year.labels=TRUE, continuous=TRUE)

seasonplot(AirPassengers, col=rainbow(12), year.labels=TRUE)

</code></pre>

<hr>
<h2 id='ggtsdisplay'>Time series display</h2><span id='topic+ggtsdisplay'></span><span id='topic+tsdisplay'></span>

<h3>Description</h3>

<p>Plots a time series along with its acf and either its pacf, lagged
scatterplot or spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggtsdisplay(
  x,
  plot.type = c("partial", "histogram", "scatter", "spectrum"),
  points = TRUE,
  smooth = FALSE,
  lag.max,
  na.action = na.contiguous,
  theme = NULL,
  ...
)

tsdisplay(
  x,
  plot.type = c("partial", "histogram", "scatter", "spectrum"),
  points = TRUE,
  ci.type = c("white", "ma"),
  lag.max,
  na.action = na.contiguous,
  main = NULL,
  xlab = "",
  ylab = "",
  pch = 1,
  cex = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggtsdisplay_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_plot.type">plot.type</code></td>
<td>
<p>type of plot to include in lower right corner.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_points">points</code></td>
<td>
<p>logical flag indicating whether to show the individual points
or not in the time plot.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_smooth">smooth</code></td>
<td>
<p>logical flag indicating whether to show a smooth loess curve
superimposed on the time plot.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_lag.max">lag.max</code></td>
<td>
<p>the maximum lag to plot for the acf and pacf. A suitable
value is selected by default if the argument is missing.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_na.action">na.action</code></td>
<td>
<p>function to handle missing values in acf, pacf and spectrum
calculations. The default is <code><a href="stats.html#topic+na.contiguous">na.contiguous</a></code>. Useful
alternatives are <code><a href="stats.html#topic+na.pass">na.pass</a></code> and <code><a href="forecast.html#topic+na.interp">na.interp</a></code>.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_theme">theme</code></td>
<td>
<p>Adds a ggplot element to each plot, typically a theme.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="stats.html#topic+acf">acf</a></code>.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_ci.type">ci.type</code></td>
<td>
<p>type of confidence limits for ACF that is passed to
<code><a href="stats.html#topic+acf">acf</a></code>. Should the confidence limits assume a white noise
input or for lag <code class="reqn">k</code> an MA(<code class="reqn">k-1</code>) input?</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_pch">pch</code></td>
<td>
<p>Plotting character.</p>
</td></tr>
<tr><td><code id="ggtsdisplay_+3A_cex">cex</code></td>
<td>
<p>Character size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggtsdisplay</code> will produce the equivalent plot using ggplot graphics.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2018) <em>Forecasting: principles
and practice</em>, 2nd edition, OTexts: Melbourne, Australia.
<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="forecast.html#topic+Acf">Acf</a></code>,
<code><a href="stats.html#topic+spec.ar">spec.ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggtsdisplay(USAccDeaths, plot.type="scatter", theme=theme_bw())

tsdisplay(diff(WWWusage))
ggtsdisplay(USAccDeaths, plot.type="scatter")

</code></pre>

<hr>
<h2 id='gold'>Daily morning gold prices</h2><span id='topic+gold'></span>

<h3>Description</h3>

<p>Daily morning gold prices in US dollars. 1 January 1985 &ndash; 31 March 1989.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gold
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsdisplay(gold)

</code></pre>

<hr>
<h2 id='is.acf'>Is an object a particular model type?</h2><span id='topic+is.acf'></span><span id='topic+is.Arima'></span><span id='topic+is.baggedModel'></span><span id='topic+is.bats'></span><span id='topic+is.ets'></span><span id='topic+is.modelAR'></span><span id='topic+is.stlm'></span><span id='topic+is.nnetar'></span><span id='topic+is.nnetarmodels'></span>

<h3>Description</h3>

<p>Returns true if the model object is of a particular type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.acf(x)

is.Arima(x)

is.baggedModel(x)

is.bats(x)

is.ets(x)

is.modelAR(x)

is.stlm(x)

is.nnetar(x)

is.nnetarmodels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.acf_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='is.constant'>Is an object constant?</h2><span id='topic+is.constant'></span>

<h3>Description</h3>

<p>Returns true if the object's numerical values do not vary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.constant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.constant_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='is.forecast'>Is an object a particular forecast type?</h2><span id='topic+is.forecast'></span><span id='topic+is.mforecast'></span><span id='topic+is.splineforecast'></span>

<h3>Description</h3>

<p>Returns true if the forecast object is of a particular type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.forecast(x)

is.mforecast(x)

is.splineforecast(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.forecast_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>

<hr>
<h2 id='ma'>Moving-average smoothing</h2><span id='topic+ma'></span>

<h3>Description</h3>

<p><code>ma</code> computes a simple moving average smoother of a given time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma(x, order, centre = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_+3A_x">x</code></td>
<td>
<p>Univariate time series</p>
</td></tr>
<tr><td><code id="ma_+3A_order">order</code></td>
<td>
<p>Order of moving average smoother</p>
</td></tr>
<tr><td><code id="ma_+3A_centre">centre</code></td>
<td>
<p>If TRUE, then the moving average is centred for even orders.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The moving average smoother averages the nearest <code>order</code> periods of
each observation. As neighbouring observations of a time series are likely
to be similar in value, averaging eliminates some of the randomness in the
data, leaving a smooth trend-cycle component. </p>
<p style="text-align: center;"><code class="reqn">\hat{T}_{t} =
\frac{1}{m} \sum_{j=-k}^k
y_{t+j}</code>
</p>
<p> where
<code class="reqn">k=\frac{m-1}{2}</code>
</p>
<p>When an even <code>order</code> is specified, the observations averaged will
include one more observation from the future than the past (k is rounded
up). If centre is TRUE, the value from two moving averages (where k is
rounded up and down respectively) are averaged, centering the moving
average.
</p>


<h3>Value</h3>

<p>Numerical time series object containing the simple moving average
smoothed values.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+decompose">decompose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(wineind)
sm &lt;- ma(wineind,order=12)
lines(sm,col="red")

</code></pre>

<hr>
<h2 id='meanf'>Mean Forecast</h2><span id='topic+meanf'></span>

<h3>Description</h3>

<p>Returns forecasts and prediction intervals for an iid model applied to y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanf(
  y,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  bootstrap = FALSE,
  npaths = 5000,
  x = y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanf_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="meanf_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="meanf_+3A_level">level</code></td>
<td>
<p>Confidence levels for prediction intervals.</p>
</td></tr>
<tr><td><code id="meanf_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="meanf_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="meanf_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="meanf_+3A_bootstrap">bootstrap</code></td>
<td>
<p>If TRUE, use a bootstrap method to compute prediction intervals.
Otherwise, assume a normal distribution.</p>
</td></tr>
<tr><td><code id="meanf_+3A_npaths">npaths</code></td>
<td>
<p>Number of bootstrapped sample paths to use if <code>bootstrap==TRUE</code>.</p>
</td></tr>
<tr><td><code id="meanf_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iid model is </p>
<p style="text-align: center;"><code class="reqn">Y_t=\mu + Z_t</code>
</p>
<p> where <code class="reqn">Z_t</code>
is a normal iid error. Forecasts are given by </p>
<p style="text-align: center;"><code class="reqn">Y_n(h)=\mu</code>
</p>

<p>where <code class="reqn">\mu</code> is estimated by the sample mean.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>meanf</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step
forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+rwf">rwf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nile.fcast &lt;- meanf(Nile, h=10)
plot(nile.fcast)

</code></pre>

<hr>
<h2 id='modelAR'>Time Series Forecasts with a user-defined model</h2><span id='topic+modelAR'></span><span id='topic+print.modelAR'></span>

<h3>Description</h3>

<p>Experimental function to forecast univariate time series with a
user-defined model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelAR(
  y,
  p,
  P = 1,
  FUN,
  predict.FUN,
  xreg = NULL,
  lambda = NULL,
  model = NULL,
  subset = NULL,
  scale.inputs = FALSE,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelAR_+3A_y">y</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_p">p</code></td>
<td>
<p>Embedding dimension for non-seasonal time series. Number of
non-seasonal lags used as inputs. For non-seasonal time series, the default
is the optimal number of lags (according to the AIC) for a linear AR(p)
model. For seasonal time series, the same method is used but applied to
seasonally adjusted data (from an stl decomposition).</p>
</td></tr>
<tr><td><code id="modelAR_+3A_p">P</code></td>
<td>
<p>Number of seasonal lags used as inputs.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_fun">FUN</code></td>
<td>
<p>Function used for model fitting. Must accept argument <code>x</code>
and <code>y</code> for the predictors and response, respectively (<code>formula</code>
object not currently supported).</p>
</td></tr>
<tr><td><code id="modelAR_+3A_predict.fun">predict.FUN</code></td>
<td>
<p>Prediction function used to apply <code>FUN</code> to new data.
Must accept an object of class <code>FUN</code> as its first argument, and a
data frame or matrix of new data for its second argument. Additionally,
it should return fitted values when new data is omitted.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_xreg">xreg</code></td>
<td>
<p>Optionally, a vector or matrix of external regressors, which
must have the same number of rows as <code>y</code>. Must be numeric.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>nnetar</code>. If model is
passed, this same model is fitted to <code>y</code> without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations to be used
in the fit. Can be an integer index vector or a logical vector the same
length as <code>y</code>. All observations are used by default.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_scale.inputs">scale.inputs</code></td>
<td>
<p>If TRUE, inputs are scaled by subtracting the column
means and dividing by their respective standard deviations. If <code>lambda</code>
is not <code>NULL</code>, scaling is applied after Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="modelAR_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>FUN</code> for
<code>modelAR</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an experimental function and only recommended for advanced users.
The selected model is fitted with lagged values of <code>y</code> as
inputs. The inputs are for
lags 1 to <code>p</code>, and lags <code>m</code> to <code>mP</code> where
<code>m=frequency(y)</code>. If <code>xreg</code> is provided, its columns are also
used as inputs. If there are missing values in <code>y</code> or
<code>xreg</code>, the corresponding rows (and any others which depend on them as
lags) are omitted from the fit. The model is trained for one-step
forecasting. Multi-step forecasts are computed recursively.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;<code>modelAR</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>nnetar</code>.
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The external regressors used in fitting (if given).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Gabriel Caceres
</p>

<hr>
<h2 id='monthdays'>Number of days in each season</h2><span id='topic+monthdays'></span>

<h3>Description</h3>

<p>Returns number of days in each month or quarter of the observed time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthdays(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monthdays_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for month length adjustments
</p>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bizdays">bizdays</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(2,1))
plot(ldeaths,xlab="Year",ylab="pounds",
    main="Monthly deaths from lung disease (UK)")
ldeaths.adj &lt;- ldeaths/monthdays(ldeaths)*365.25/12
plot(ldeaths.adj,xlab="Year",ylab="pounds",
    main="Adjusted monthly deaths from lung disease (UK)")

</code></pre>

<hr>
<h2 id='mstl'>Multiple seasonal decomposition</h2><span id='topic+mstl'></span>

<h3>Description</h3>

<p>Decompose a time series into seasonal, trend and remainder components.
Seasonal components are estimated iteratively using STL. Multiple seasonal periods are
allowed. The trend component is computed for the last iteration of STL.
Non-seasonal time series are decomposed into trend and remainder only.
In this case, <code><a href="stats.html#topic+supsmu">supsmu</a></code> is used to estimate the trend.
Optionally, the time series may be Box-Cox transformed before decomposition.
Unlike <code><a href="stats.html#topic+stl">stl</a></code>, <code>mstl</code> is completely automated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstl(x, lambda = NULL, iterate = 2, s.window = 7 + 4 * seq(6), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstl_+3A_x">x</code></td>
<td>
<p>Univariate time series of class <code>msts</code> or <code>ts</code>.</p>
</td></tr>
<tr><td><code id="mstl_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="mstl_+3A_iterate">iterate</code></td>
<td>
<p>Number of iterations to use to refine the seasonal component.</p>
</td></tr>
<tr><td><code id="mstl_+3A_s.window">s.window</code></td>
<td>
<p>Seasonal windows to be used in the  decompositions. If scalar,
the same value is used for all seasonal components. Otherwise, it should be a vector
of the same length as the number of seasonal components (or longer).</p>
</td></tr>
<tr><td><code id="mstl_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code><a href="stats.html#topic+stl">stl</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+supsmu">supsmu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
mstl(taylor) %&gt;% autoplot()
mstl(AirPassengers, lambda = "auto") %&gt;% autoplot()
</code></pre>

<hr>
<h2 id='msts'>Multi-Seasonal Time Series</h2><span id='topic+msts'></span><span id='topic+print.msts'></span><span id='topic+window.msts'></span><span id='topic++60+5B.msts+60'></span>

<h3>Description</h3>

<p>msts is an S3 class for multi seasonal time series objects, intended to be
used for models that support multiple seasonal periods. The msts class
inherits from the ts class and has an additional &quot;msts&quot; attribute which
contains the vector of seasonal periods. All methods that work on a ts
class, should also work on a msts class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msts(data, seasonal.periods, ts.frequency = floor(max(seasonal.periods)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msts_+3A_data">data</code></td>
<td>
<p>A numeric vector, ts object, matrix or data frame. It is
intended that the time series data is univariate, otherwise treated the same
as ts().</p>
</td></tr>
<tr><td><code id="msts_+3A_seasonal.periods">seasonal.periods</code></td>
<td>
<p>A vector of the seasonal periods of the msts.</p>
</td></tr>
<tr><td><code id="msts_+3A_ts.frequency">ts.frequency</code></td>
<td>
<p>The seasonal period that should be used as frequency of
the underlying ts object. The default value is <code>max(seasonal.periods)</code>.</p>
</td></tr>
<tr><td><code id="msts_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the underlying call to <code>ts()</code>. For
example <code>start=c(1987,5)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("msts", "ts")</code>. If there is only one
seasonal period (i.e., <code>length(seasonal.periods)==1</code>), then the object
is of class <code>"ts"</code>.
</p>


<h3>Author(s)</h3>

<p>Slava Razbash and Rob J Hyndman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- msts(taylor, seasonal.periods=c(2*24,2*24*7,2*24*365), start=2000+22/52)
y &lt;- msts(USAccDeaths, seasonal.periods=12, start=1949)

</code></pre>

<hr>
<h2 id='na.interp'>Interpolate missing values in a time series</h2><span id='topic+na.interp'></span>

<h3>Description</h3>

<p>By default, uses linear interpolation for non-seasonal series. For seasonal series, a
robust STL decomposition is first computed. Then a linear interpolation is applied to the
seasonally adjusted data, and the seasonal component is added back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.interp(
  x,
  lambda = NULL,
  linear = (frequency(x) &lt;= 1 | sum(!is.na(x)) &lt;= 2 * frequency(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.interp_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="na.interp_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="na.interp_+3A_linear">linear</code></td>
<td>
<p>Should a linear interpolation be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A more general and flexible approach is available using <code>na.approx</code> in
the <code>zoo</code> package.
</p>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsoutliers">tsoutliers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gold)
plot(na.interp(gold))

</code></pre>

<hr>
<h2 id='ndiffs'>Number of differences required for a stationary series</h2><span id='topic+ndiffs'></span>

<h3>Description</h3>

<p>Functions to estimate the number of differences required to make a given
time series stationary. <code>ndiffs</code> estimates the number of first
differences necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndiffs(
  x,
  alpha = 0.05,
  test = c("kpss", "adf", "pp"),
  type = c("level", "trend"),
  max.d = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndiffs_+3A_x">x</code></td>
<td>
<p>A univariate time series</p>
</td></tr>
<tr><td><code id="ndiffs_+3A_alpha">alpha</code></td>
<td>
<p>Level of the test, possible values range from 0.01 to 0.1.</p>
</td></tr>
<tr><td><code id="ndiffs_+3A_test">test</code></td>
<td>
<p>Type of unit root test to use</p>
</td></tr>
<tr><td><code id="ndiffs_+3A_type">type</code></td>
<td>
<p>Specification of the deterministic component in the regression</p>
</td></tr>
<tr><td><code id="ndiffs_+3A_max.d">max.d</code></td>
<td>
<p>Maximum number of non-seasonal differences allowed</p>
</td></tr>
<tr><td><code id="ndiffs_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to the unit root test</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ndiffs</code> uses a unit root test to determine the number of differences
required for time series <code>x</code> to be made stationary. If
<code>test="kpss"</code>, the KPSS test is used with the null hypothesis that
<code>x</code> has a stationary root against a unit-root alternative. Then the
test returns the least number of differences required to pass the test at
the level <code>alpha</code>. If <code>test="adf"</code>, the Augmented Dickey-Fuller
test is used and if <code>test="pp"</code> the Phillips-Perron test is used. In
both of these cases, the null hypothesis is that <code>x</code> has a unit root
against a stationary root alternative. Then the test returns the least
number of differences required to fail the test at the level <code>alpha</code>.
</p>


<h3>Value</h3>

<p>An integer indicating the number of differences required for stationarity.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman, Slava Razbash &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Dickey DA and Fuller WA (1979), &quot;Distribution of the Estimators for
Autoregressive Time Series with a Unit Root&quot;, <em>Journal of the American
Statistical Association</em> <b>74</b>:427-431.
</p>
<p>Kwiatkowski D, Phillips PCB, Schmidt P and Shin Y (1992) &quot;Testing the Null
Hypothesis of Stationarity against the Alternative of a Unit Root&quot;,
<em>Journal of Econometrics</em> <b>54</b>:159-178.
</p>
<p>Osborn, D.R. (1990) &quot;A survey of seasonality in UK macroeconomic variables&quot;,
<em>International Journal of Forecasting</em>, <b>6</b>:327-336.
</p>
<p>Phillips, P.C.B. and Perron, P. (1988) &quot;Testing for a unit root in time series regression&quot;,
<em>Biometrika</em>, <b>72</b>(2), 335-346.
</p>
<p>Said E and Dickey DA (1984), &quot;Testing for Unit Roots in Autoregressive
Moving Average Models of Unknown Order&quot;, <em>Biometrika</em>
<b>71</b>:599-607.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> and <code><a href="forecast.html#topic+ndiffs">ndiffs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndiffs(WWWusage)
ndiffs(diff(log(AirPassengers), 12))
</code></pre>

<hr>
<h2 id='nnetar'>Neural Network Time Series Forecasts</h2><span id='topic+nnetar'></span><span id='topic+print.nnetar'></span><span id='topic+print.nnetarmodels'></span>

<h3>Description</h3>

<p>Feed-forward neural networks with a single hidden layer and lagged inputs
for forecasting univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnetar(
  y,
  p,
  P = 1,
  size,
  repeats = 20,
  xreg = NULL,
  lambda = NULL,
  model = NULL,
  subset = NULL,
  scale.inputs = TRUE,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnetar_+3A_y">y</code></td>
<td>
<p>A numeric vector or time series of class <code>ts</code>.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_p">p</code></td>
<td>
<p>Embedding dimension for non-seasonal time series. Number of
non-seasonal lags used as inputs. For non-seasonal time series, the default
is the optimal number of lags (according to the AIC) for a linear AR(p)
model. For seasonal time series, the same method is used but applied to
seasonally adjusted data (from an stl decomposition). If set to zero to
indicate that no non-seasonal lags should be included, then P must be at
least 1 and a model with only seasonal lags will be fit.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_p">P</code></td>
<td>
<p>Number of seasonal lags used as inputs.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_size">size</code></td>
<td>
<p>Number of nodes in the hidden layer. Default is half of the
number of input nodes (including external regressors, if given) plus 1.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_repeats">repeats</code></td>
<td>
<p>Number of networks to fit with different random starting
weights. These are then averaged when producing forecasts.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_xreg">xreg</code></td>
<td>
<p>Optionally, a vector or matrix of external regressors, which
must have the same number of rows as <code>y</code>. Must be numeric.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>nnetar</code>. If model is
passed, this same model is fitted to <code>y</code> without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations to be used
in the fit. Can be an integer index vector or a logical vector the same
length as <code>y</code>. All observations are used by default.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_scale.inputs">scale.inputs</code></td>
<td>
<p>If TRUE, inputs are scaled by subtracting the column
means and dividing by their respective standard deviations. If <code>lambda</code>
is not <code>NULL</code>, scaling is applied after Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="nnetar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="nnet.html#topic+nnet">nnet</a></code> for
<code>nnetar</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A feed-forward neural network is fitted with lagged values of <code>y</code> as
inputs and a single hidden layer with <code>size</code> nodes. The inputs are for
lags 1 to <code>p</code>, and lags <code>m</code> to <code>mP</code> where
<code>m=frequency(y)</code>. If <code>xreg</code> is provided, its columns are also
used as inputs. If there are missing values in <code>y</code> or
<code>xreg</code>, the corresponding rows (and any others which depend on them as
lags) are omitted from the fit. A total of <code>repeats</code> networks are
fitted, each with random starting weights. These are then averaged when
computing forecasts. The network is trained for one-step forecasting.
Multi-step forecasts are computed recursively.
</p>
<p>For non-seasonal data, the fitted model is denoted as an NNAR(p,k) model,
where k is the number of hidden nodes. This is analogous to an AR(p) model
but with nonlinear functions. For seasonal data, the fitted model is called
an NNAR(p,P,k)[m] model, which is analogous to an ARIMA(p,0,0)(P,0,0)[m]
model but with nonlinear functions.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;<code>nnetar</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>nnetar</code>.
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code>xreg</code></td>
<td>
<p>The external regressors used in fitting (if given).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman and Gabriel Caceres
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- nnetar(lynx)
fcast &lt;- forecast(fit)
plot(fcast)

## Arguments can be passed to nnet()
fit &lt;- nnetar(lynx, decay=0.5, maxit=150)
plot(forecast(fit))
lines(lynx)

## Fit model to first 100 years of lynx data
fit &lt;- nnetar(window(lynx,end=1920), decay=0.5, maxit=150)
plot(forecast(fit,h=14))
lines(lynx)

## Apply fitted model to later data, including all optional arguments
fit2 &lt;- nnetar(window(lynx,start=1921), model=fit)

</code></pre>

<hr>
<h2 id='nsdiffs'>Number of differences required for a seasonally stationary series</h2><span id='topic+nsdiffs'></span>

<h3>Description</h3>

<p>Functions to estimate the number of differences required to make a given
time series stationary. <code>nsdiffs</code> estimates the number of seasonal differences
necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsdiffs(
  x,
  alpha = 0.05,
  m = frequency(x),
  test = c("seas", "ocsb", "hegy", "ch"),
  max.D = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsdiffs_+3A_x">x</code></td>
<td>
<p>A univariate time series</p>
</td></tr>
<tr><td><code id="nsdiffs_+3A_alpha">alpha</code></td>
<td>
<p>Level of the test, possible values range from 0.01 to 0.1.</p>
</td></tr>
<tr><td><code id="nsdiffs_+3A_m">m</code></td>
<td>
<p>Deprecated. Length of seasonal period</p>
</td></tr>
<tr><td><code id="nsdiffs_+3A_test">test</code></td>
<td>
<p>Type of unit root test to use</p>
</td></tr>
<tr><td><code id="nsdiffs_+3A_max.d">max.D</code></td>
<td>
<p>Maximum number of seasonal differences allowed</p>
</td></tr>
<tr><td><code id="nsdiffs_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to the unit root test</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nsdiffs</code> uses seasonal unit root tests to determine the number of
seasonal differences required for time series <code>x</code> to be made stationary
(possibly with some lag-one differencing as well).
</p>
<p>Several different tests are available:
</p>

<ul>
<li><p> If <code>test="seas"</code> (default), a measure of seasonal strength is used, where differencing is
selected if the seasonal strength (Wang, Smith &amp; Hyndman, 2006) exceeds 0.64
(based on minimizing MASE when forecasting using auto.arima on M3 and M4 data).
</p>
</li>
<li><p> If <code>test="ch"</code>, the Canova-Hansen (1995) test is used
(with null hypothesis of deterministic seasonality)
</p>
</li>
<li><p> If <code>test="hegy"</code>, the Hylleberg, Engle, Granger &amp; Yoo (1990) test is used.
</p>
</li>
<li><p> If <code>test="ocsb"</code>, the Osborn-Chui-Smith-Birchenhall
(1988) test is used (with null hypothesis that a seasonal unit root exists).
</p>
</li></ul>



<h3>Value</h3>

<p>An integer indicating the number of differences required for stationarity.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman, Slava Razbash and Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Wang, X, Smith, KA, Hyndman, RJ (2006) &quot;Characteristic-based clustering
for time series data&quot;, <em>Data Mining and Knowledge Discovery</em>,
<b>13</b>(3), 335-364.
</p>
<p>Osborn DR, Chui APL, Smith J, and Birchenhall CR (1988) &quot;Seasonality and the
order of integration for consumption&quot;, <em>Oxford Bulletin of Economics
and Statistics</em> <b>50</b>(4):361-377.
</p>
<p>Canova F and Hansen BE (1995) &quot;Are Seasonal Patterns Constant
over Time? A Test for Seasonal Stability&quot;, <em>Journal of Business and
Economic Statistics</em> <b>13</b>(3):237-252.
</p>
<p>Hylleberg S, Engle R, Granger C and Yoo B (1990) &quot;Seasonal integration
and cointegration.&quot;, <em>Journal of Econometrics</em> <b>44</b>(1), pp. 215-238.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>, <code><a href="forecast.html#topic+ndiffs">ndiffs</a></code>, <code><a href="forecast.html#topic+ocsb.test">ocsb.test</a></code>, <code><a href="uroot.html#topic+hegy.test">hegy.test</a></code>, and <code><a href="uroot.html#topic+ch.test">ch.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsdiffs(AirPassengers)
</code></pre>

<hr>
<h2 id='ocsb.test'>Osborn, Chui, Smith, and Birchenhall Test for Seasonal Unit Roots</h2><span id='topic+ocsb.test'></span><span id='topic+print.OCSBtest'></span>

<h3>Description</h3>

<p>An implementation of the Osborn, Chui, Smith, and Birchenhall (OCSB) test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocsb.test(x, lag.method = c("fixed", "AIC", "BIC", "AICc"), maxlag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocsb.test_+3A_x">x</code></td>
<td>
<p>a univariate seasonal time series.</p>
</td></tr>
<tr><td><code id="ocsb.test_+3A_lag.method">lag.method</code></td>
<td>
<p>a character specifying the lag order selection method.</p>
</td></tr>
<tr><td><code id="ocsb.test_+3A_maxlag">maxlag</code></td>
<td>
<p>the maximum lag order to be considered by <code>lag.method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regression equation may include lags of the dependent variable. When lag.method = &quot;fixed&quot;, the lag order is fixed to maxlag; otherwise, maxlag is the maximum number of lags considered in a lag selection procedure that minimises the lag.method criterion, which can be AIC or BIC or corrected AIC, AICc, obtained as AIC + (2k(k+1))/(n-k-1), where k is the number of parameters and n is the number of available observations in the model.
</p>
<p>Critical values for the test are based on simulations, which has been smoothed over to produce critical values for all seasonal periods.
</p>


<h3>Value</h3>

<p>ocsb.test returns a list of class &quot;OCSBtest&quot; with the following components:
* statistics the value of the test statistics.
* pvalues the p-values for each test statistics.
* method a character string describing the type of test.
* data.name a character string giving the name of the data.
* fitted.model	the fitted regression model.
</p>


<h3>References</h3>

<p>Osborn DR, Chui APL, Smith J, and Birchenhall CR (1988) &quot;Seasonality and the
order of integration for consumption&quot;, <em>Oxford Bulletin of Economics
and Statistics</em> <b>50</b>(4):361-377.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+nsdiffs">nsdiffs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ocsb.test(AirPassengers)
</code></pre>

<hr>
<h2 id='plot.Arima'>Plot characteristic roots from ARIMA model</h2><span id='topic+plot.Arima'></span><span id='topic+plot.ar'></span><span id='topic+autoplot.Arima'></span><span id='topic+autoplot.ar'></span>

<h3>Description</h3>

<p>Produces a plot of the inverse AR and MA roots of an ARIMA model. Inverse
roots outside the unit circle are shown in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Arima'
plot(
  x,
  type = c("both", "ar", "ma"),
  main,
  xlab = "Real",
  ylab = "Imaginary",
  ...
)

## S3 method for class 'ar'
plot(x, main, xlab = "Real", ylab = "Imaginary", ...)

## S3 method for class 'Arima'
autoplot(object, type = c("both", "ar", "ma"), ...)

## S3 method for class 'ar'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Arima_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;Arima&rdquo; or &ldquo;ar&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_type">type</code></td>
<td>
<p>Determines if both AR and MA roots are plotted, of if just one
set is plotted.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_main">main</code></td>
<td>
<p>Main title. Default is &quot;Inverse AR roots&quot; or &quot;Inverse MA roots&quot;.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_...">...</code></td>
<td>
<p>Other plotting parameters passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Arima_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;Arima&rdquo; or &ldquo;ar&rdquo;. Used for ggplot
graphics (S3 method consistency).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>autoplot</code> will produce an equivalent plot as a ggplot object.
</p>


<h3>Value</h3>

<p>None. Function produces a plot
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="stats.html#topic+ar">ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(ggplot2)

fit &lt;- Arima(WWWusage, order = c(3, 1, 0))
plot(fit)
autoplot(fit)

fit &lt;- Arima(woolyrnq, order = c(2, 0, 0), seasonal = c(2, 1, 1))
plot(fit)
autoplot(fit)

plot(ar.ols(gold[1:61]))
autoplot(ar.ols(gold[1:61]))
</code></pre>

<hr>
<h2 id='plot.bats'>Plot components from BATS model</h2><span id='topic+plot.bats'></span><span id='topic+autoplot.tbats'></span><span id='topic+autoplot.bats'></span><span id='topic+plot.tbats'></span>

<h3>Description</h3>

<p>Produces a plot of the level, slope and seasonal components from a BATS or
TBATS model. The plotted components are Box-Cox transformed using the estimated transformation parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bats'
plot(x, main = "Decomposition by BATS model", ...)

## S3 method for class 'tbats'
autoplot(object, range.bars = FALSE, ...)

## S3 method for class 'bats'
autoplot(object, range.bars = FALSE, ...)

## S3 method for class 'tbats'
plot(x, main = "Decomposition by TBATS model", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bats_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;bats/tbats&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.bats_+3A_main">main</code></td>
<td>
<p>Main title for plot.</p>
</td></tr>
<tr><td><code id="plot.bats_+3A_...">...</code></td>
<td>
<p>Other plotting parameters passed to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bats_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;bats/tbats&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.bats_+3A_range.bars">range.bars</code></td>
<td>
<p>Logical indicating if each plot should have a bar at its
right side representing relative size. If NULL, automatic selection takes
place.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Function produces a plot
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+bats">bats</a></code>,<code><a href="forecast.html#topic+tbats">tbats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- tbats(USAccDeaths)
plot(fit)
autoplot(fit, range.bars = TRUE)
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.ets'>Plot components from ETS model</h2><span id='topic+plot.ets'></span><span id='topic+autoplot.ets'></span>

<h3>Description</h3>

<p>Produces a plot of the level, slope and seasonal components from an ETS
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ets'
plot(x, ...)

## S3 method for class 'ets'
autoplot(object, range.bars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ets_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;ets&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.ets_+3A_...">...</code></td>
<td>
<p>Other plotting parameters to affect the plot.</p>
</td></tr>
<tr><td><code id="plot.ets_+3A_object">object</code></td>
<td>
<p>Object of class &ldquo;ets&rdquo;. Used for ggplot graphics (S3
method consistency).</p>
</td></tr>
<tr><td><code id="plot.ets_+3A_range.bars">range.bars</code></td>
<td>
<p>Logical indicating if each plot should have a bar at its
right side representing relative size. If NULL, automatic selection takes
place.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>autoplot</code> will produce an equivalent plot as a ggplot object.
</p>


<h3>Value</h3>

<p>None. Function produces a plot
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+ets">ets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- ets(USAccDeaths)
plot(fit)
plot(fit,plot.type="single",ylab="",col=1:3)

library(ggplot2)
autoplot(fit)

</code></pre>

<hr>
<h2 id='plot.forecast'>Forecast plot</h2><span id='topic+plot.forecast'></span><span id='topic+autoplot.forecast'></span><span id='topic+autoplot.splineforecast'></span><span id='topic+autolayer.forecast'></span><span id='topic+plot.splineforecast'></span>

<h3>Description</h3>

<p>Plots historical data with forecasts and prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast'
plot(
  x,
  include,
  PI = TRUE,
  showgap = TRUE,
  shaded = TRUE,
  shadebars = (length(x$mean) &lt; 5),
  shadecols = NULL,
  col = 1,
  fcol = 4,
  pi.col = 1,
  pi.lty = 2,
  ylim = NULL,
  main = NULL,
  xlab = "",
  ylab = "",
  type = "l",
  flty = 1,
  flwd = 2,
  ...
)

## S3 method for class 'forecast'
autoplot(
  object,
  include,
  PI = TRUE,
  shadecols = c("#596DD5", "#D5DBFF"),
  fcol = "#0000AA",
  flwd = 0.5,
  ...
)

## S3 method for class 'splineforecast'
autoplot(object, PI = TRUE, ...)

## S3 method for class 'forecast'
autolayer(object, series = NULL, PI = TRUE, showgap = TRUE, ...)

## S3 method for class 'splineforecast'
plot(x, fitcol = 2, type = "o", pch = 19, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.forecast_+3A_x">x</code></td>
<td>
<p>Forecast object produced by <code><a href="fabletools.html#topic+forecast">forecast</a></code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_include">include</code></td>
<td>
<p>number of values from time series to include in plot. Default
is all values.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_pi">PI</code></td>
<td>
<p>Logical flag indicating whether to plot prediction intervals.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_showgap">showgap</code></td>
<td>
<p>If <code>showgap=FALSE</code>, the gap between the historical
observations and the forecasts is removed.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_shaded">shaded</code></td>
<td>
<p>Logical flag indicating whether prediction intervals should be
shaded (<code>TRUE</code>) or lines (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_shadebars">shadebars</code></td>
<td>
<p>Logical flag indicating if prediction intervals should be
plotted as shaded bars (if <code>TRUE</code>) or a shaded polygon (if
<code>FALSE</code>).  Ignored if <code>shaded=FALSE</code>. Bars are plotted by default
if there are fewer than five forecast horizons.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_shadecols">shadecols</code></td>
<td>
<p>Colors for shaded prediction intervals. To get default
colors used prior to v3.26, set <code>shadecols="oldstyle"</code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_col">col</code></td>
<td>
<p>Colour for the data line.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_fcol">fcol</code></td>
<td>
<p>Colour for the forecast line.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_pi.col">pi.col</code></td>
<td>
<p>If <code>shaded=FALSE</code> and <code>PI=TRUE</code>, the prediction
intervals are plotted in this colour.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_pi.lty">pi.lty</code></td>
<td>
<p>If <code>shaded=FALSE</code> and <code>PI=TRUE</code>, the prediction
intervals are plotted using this line type.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_ylim">ylim</code></td>
<td>
<p>Limits on y-axis.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. As for
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_flty">flty</code></td>
<td>
<p>Line type for the forecast line.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_flwd">flwd</code></td>
<td>
<p>Line width for the forecast line.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_...">...</code></td>
<td>
<p>Other plotting parameters to affect the plot.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_object">object</code></td>
<td>
<p>Forecast object produced by <code><a href="fabletools.html#topic+forecast">forecast</a></code>. Used for
ggplot graphics (S3 method consistency).</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_series">series</code></td>
<td>
<p>Matches an unidentified forecast layer with a coloured object
on the plot.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_fitcol">fitcol</code></td>
<td>
<p>Line colour for fitted values.</p>
</td></tr>
<tr><td><code id="plot.forecast_+3A_pch">pch</code></td>
<td>
<p>Plotting character (if <code>type=="p"</code> or <code>type=="o"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>autoplot</code> will produce a ggplot object.
</p>
<p>plot.splineforecast autoplot.splineforecast
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2018) <em>Forecasting: principles
and practice</em>, 2nd edition, OTexts: Melbourne, Australia.
<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

wine.fit &lt;- hw(wineind,h=48)
plot(wine.fit)
autoplot(wine.fit)

fit &lt;- tslm(wineind ~ fourier(wineind,4))
fcast &lt;- forecast(fit, newdata=data.frame(fourier(wineind,4,20)))
autoplot(fcast)

fcast &lt;- splinef(airmiles,h=5)
plot(fcast)
autoplot(fcast)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+forecast'></span><span id='topic+accuracy'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+accuracy">accuracy</a></code>, <code><a href="generics.html#topic+forecast">forecast</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.forecast'>Residuals for various time series models</h2><span id='topic+residuals.forecast'></span><span id='topic+residuals.ar'></span><span id='topic+residuals.Arima'></span><span id='topic+residuals.forecast_ARIMA'></span><span id='topic+residuals.bats'></span><span id='topic+residuals.tbats'></span><span id='topic+residuals.ets'></span><span id='topic+residuals.ARFIMA'></span><span id='topic+residuals.nnetar'></span><span id='topic+residuals.stlm'></span><span id='topic+residuals.tslm'></span>

<h3>Description</h3>

<p>Returns time series of residuals from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecast'
residuals(object, type = c("innovation", "response"), ...)

## S3 method for class 'ar'
residuals(object, type = c("innovation", "response"), ...)

## S3 method for class 'Arima'
residuals(object, type = c("innovation", "response", "regression"), h = 1, ...)

## S3 method for class 'bats'
residuals(object, type = c("innovation", "response"), h = 1, ...)

## S3 method for class 'tbats'
residuals(object, type = c("innovation", "response"), h = 1, ...)

## S3 method for class 'ets'
residuals(object, type = c("innovation", "response"), h = 1, ...)

## S3 method for class 'ARFIMA'
residuals(object, type = c("innovation", "response"), ...)

## S3 method for class 'nnetar'
residuals(object, type = c("innovation", "response"), h = 1, ...)

## S3 method for class 'stlm'
residuals(object, type = c("innovation", "response"), ...)

## S3 method for class 'tslm'
residuals(object, type = c("innovation", "response", "deviance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.forecast_+3A_object">object</code></td>
<td>
<p>An object containing a time series model of class <code>ar</code>,
<code>Arima</code>, <code>bats</code>, <code>ets</code>, <code>arfima</code>, <code>nnetar</code> or
<code>stlm</code>.
If <code>object</code> is of class <code>forecast</code>, then the function will return
<code>object$residuals</code> if it exists, otherwise it returns the differences between
the observations and their fitted values.</p>
</td></tr>
<tr><td><code id="residuals.forecast_+3A_type">type</code></td>
<td>
<p>Type of residual.</p>
</td></tr>
<tr><td><code id="residuals.forecast_+3A_...">...</code></td>
<td>
<p>Other arguments not used.</p>
</td></tr>
<tr><td><code id="residuals.forecast_+3A_h">h</code></td>
<td>
<p>If <code>type='response'</code>, then the fitted values are computed for
<code>h</code>-step forecasts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Innovation residuals correspond to the white noise process that drives the
evolution of the time series model. Response residuals are the difference
between the observations and the fitted values (equivalent to <code>h</code>-step
forecasts). For functions with no <code>h</code> argument, <code>h=1</code>. For
homoscedastic models, the innovation residuals and the response residuals
for <code>h=1</code> are identical. Regression residuals are available for
regression models with ARIMA errors, and are equal to the original data
minus the effect of the regression variables. If there are no regression
variables, the errors will be identical to the original series (possibly
adjusted to have zero mean).  <code>arima.errors</code> is a deprecated function
which is identical to <code>residuals.Arima(object, type="regression")</code>.
For <code>nnetar</code> objects, when <code>type="innovations"</code> and <code>lambda</code> is used, a
matrix of time-series consisting of the residuals from each of the fitted neural networks is returned.
</p>


<h3>Value</h3>

<p>A <code>ts</code> object.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+fitted.Arima">fitted.Arima</a></code>, <code><a href="forecast.html#topic+checkresiduals">checkresiduals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- Arima(lynx,order=c(4,0,0), lambda=0.5)

plot(residuals(fit))
plot(residuals(fit, type='response'))
</code></pre>

<hr>
<h2 id='rwf'>Naive and Random Walk Forecasts</h2><span id='topic+rwf'></span><span id='topic+naive'></span><span id='topic+print.naive'></span><span id='topic+snaive'></span>

<h3>Description</h3>

<p><code>rwf()</code> returns forecasts and prediction intervals for a random walk
with drift model applied to <code>y</code>. This is equivalent to an ARIMA(0,1,0)
model with an optional drift coefficient. <code>naive()</code> is simply a wrapper
to <code>rwf()</code> for simplicity. <code>snaive()</code> returns forecasts and
prediction intervals from an ARIMA(0,0,0)(0,1,0)m model where m is the
seasonal period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwf(
  y,
  h = 10,
  drift = FALSE,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  ...,
  x = y
)

naive(
  y,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  ...,
  x = y
)

snaive(
  y,
  h = 2 * frequency(x),
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  ...,
  x = y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwf_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="rwf_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="rwf_+3A_drift">drift</code></td>
<td>
<p>Logical flag. If TRUE, fits a random walk with drift model.</p>
</td></tr>
<tr><td><code id="rwf_+3A_level">level</code></td>
<td>
<p>Confidence levels for prediction intervals.</p>
</td></tr>
<tr><td><code id="rwf_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="rwf_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="rwf_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="rwf_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the forecasts produced. If
<code>model=NULL</code>, <code>forecast.ts</code> passes these to <code><a href="forecast.html#topic+ets">ets</a></code> or
<code><a href="forecast.html#topic+stlf">stlf</a></code> depending on the frequency of the time series. If
<code>model</code> is not <code>NULL</code>, the arguments are passed to the relevant
modelling function.</p>
</td></tr>
<tr><td><code id="rwf_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random walk with drift model is </p>
<p style="text-align: center;"><code class="reqn">Y_t=c + Y_{t-1} + Z_t</code>
</p>
<p> where <code class="reqn">Z_t</code> is a normal iid error. Forecasts are
given by </p>
<p style="text-align: center;"><code class="reqn">Y_n(h)=ch+Y_n</code>
</p>
<p>. If there is no drift (as in
<code>naive</code>), the drift parameter c=0. Forecast standard errors allow for
uncertainty in estimating the drift parameter (unlike the corresponding
forecasts obtained by fitting an ARIMA model directly).
</p>
<p>The seasonal naive model is </p>
<p style="text-align: center;"><code class="reqn">Y_t= Y_{t-m} + Z_t</code>
</p>

<p>where <code class="reqn">Z_t</code> is a normal iid error.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>naive</code> or
<code>snaive</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step
forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+Arima">Arima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gold.fcast &lt;- rwf(gold[1:60], h=50)
plot(gold.fcast)


plot(naive(gold,h=50),include=200)


plot(snaive(wineind))

</code></pre>

<hr>
<h2 id='seasadj'>Seasonal adjustment</h2><span id='topic+seasadj'></span><span id='topic+seasadj.stl'></span><span id='topic+seasadj.mstl'></span><span id='topic+seasadj.decomposed.ts'></span><span id='topic+seasadj.tbats'></span><span id='topic+seasadj.seas'></span>

<h3>Description</h3>

<p>Returns seasonally adjusted data constructed by removing the seasonal
component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasadj(object, ...)

## S3 method for class 'stl'
seasadj(object, ...)

## S3 method for class 'mstl'
seasadj(object, ...)

## S3 method for class 'decomposed.ts'
seasadj(object, ...)

## S3 method for class 'tbats'
seasadj(object, ...)

## S3 method for class 'seas'
seasadj(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasadj_+3A_object">object</code></td>
<td>
<p>Object created by <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code><a href="stats.html#topic+stl">stl</a></code> or <code><a href="forecast.html#topic+tbats">tbats</a></code>.</p>
</td></tr>
<tr><td><code id="seasadj_+3A_...">...</code></td>
<td>
<p>Other arguments not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Univariate time series.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code><a href="forecast.html#topic+tbats">tbats</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(AirPassengers)
lines(seasadj(decompose(AirPassengers,"multiplicative")),col=4)

</code></pre>

<hr>
<h2 id='seasonal'>Extract components from a time series decomposition</h2><span id='topic+seasonal'></span><span id='topic+trendcycle'></span><span id='topic+remainder'></span>

<h3>Description</h3>

<p>Returns a univariate time series equal to either a seasonal component,
trend-cycle component or remainder component from a time series
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonal(object)

trendcycle(object)

remainder(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonal_+3A_object">object</code></td>
<td>
<p>Object created by <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code><a href="stats.html#topic+stl">stl</a></code> or <code><a href="forecast.html#topic+tbats">tbats</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Univariate time series.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+decompose">decompose</a></code>,
<code><a href="forecast.html#topic+tbats">tbats</a></code>, <code><a href="forecast.html#topic+seasadj">seasadj</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(USAccDeaths)
fit &lt;- stl(USAccDeaths, s.window="periodic")
lines(trendcycle(fit),col="red")

library(ggplot2)
autoplot(cbind(
	    Data=USAccDeaths,
	    Seasonal=seasonal(fit),
  	  Trend=trendcycle(fit),
	    Remainder=remainder(fit)),
    facets=TRUE) +
  ylab("") + xlab("Year")

</code></pre>

<hr>
<h2 id='seasonaldummy'>Seasonal dummy variables</h2><span id='topic+seasonaldummy'></span><span id='topic+seasonaldummyf'></span>

<h3>Description</h3>

<p><code>seasonaldummy</code> returns a matrix of dummy variables suitable for use in
<code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code> or <code><a href="forecast.html#topic+tslm">tslm</a></code>. The
last season is omitted and used as the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonaldummy(x, h = NULL)

seasonaldummyf(x, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonaldummy_+3A_x">x</code></td>
<td>
<p>Seasonal time series: a <code>ts</code> or a <code>msts</code> object</p>
</td></tr>
<tr><td><code id="seasonaldummy_+3A_h">h</code></td>
<td>
<p>Number of periods ahead to forecast (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seasonaldummyf</code> is deprecated, instead use the <code>h</code> argument in
<code>seasonaldummy</code>.
</p>
<p>The number of dummy variables is determined from the time series
characteristics of <code>x</code>. When <code>h</code> is missing, the length of
<code>x</code> also determines the number of rows for the matrix returned by
<code>seasonaldummy</code>. the value of <code>h</code> determines the number of rows
for the matrix returned by <code>seasonaldummy</code>, typically used for
forecasting. The values within <code>x</code> are not used.
</p>


<h3>Value</h3>

<p>Numerical matrix.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+fourier">fourier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(ldeaths)

# Using seasonal dummy variables
month &lt;- seasonaldummy(ldeaths)
deaths.lm  &lt;- tslm(ldeaths ~ month)
tsdisplay(residuals(deaths.lm))
ldeaths.fcast &lt;- forecast(deaths.lm,
    data.frame(month=I(seasonaldummy(ldeaths,36))))
plot(ldeaths.fcast)

# A simpler approach to seasonal dummy variables
deaths.lm  &lt;- tslm(ldeaths ~ season)
ldeaths.fcast &lt;- forecast(deaths.lm, h=36)
plot(ldeaths.fcast)

</code></pre>

<hr>
<h2 id='ses'>Exponential smoothing forecasts</h2><span id='topic+ses'></span><span id='topic+holt'></span><span id='topic+hw'></span>

<h3>Description</h3>

<p>Returns forecasts and other information for exponential smoothing forecasts
applied to <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ses(
  y,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  initial = c("optimal", "simple"),
  alpha = NULL,
  lambda = NULL,
  biasadj = FALSE,
  x = y,
  ...
)

holt(
  y,
  h = 10,
  damped = FALSE,
  level = c(80, 95),
  fan = FALSE,
  initial = c("optimal", "simple"),
  exponential = FALSE,
  alpha = NULL,
  beta = NULL,
  phi = NULL,
  lambda = NULL,
  biasadj = FALSE,
  x = y,
  ...
)

hw(
  y,
  h = 2 * frequency(x),
  seasonal = c("additive", "multiplicative"),
  damped = FALSE,
  level = c(80, 95),
  fan = FALSE,
  initial = c("optimal", "simple"),
  exponential = FALSE,
  alpha = NULL,
  beta = NULL,
  gamma = NULL,
  phi = NULL,
  lambda = NULL,
  biasadj = FALSE,
  x = y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ses_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="ses_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting.</p>
</td></tr>
<tr><td><code id="ses_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="ses_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="ses_+3A_initial">initial</code></td>
<td>
<p>Method used for selecting initial state values. If
<code>optimal</code>, the initial values are optimized along with the smoothing
parameters using <code><a href="forecast.html#topic+ets">ets</a></code>. If <code>simple</code>, the initial values are
set to values obtained using simple calculations on the first few
observations. See Hyndman &amp; Athanasopoulos (2014) for details.</p>
</td></tr>
<tr><td><code id="ses_+3A_alpha">alpha</code></td>
<td>
<p>Value of smoothing parameter for the level. If <code>NULL</code>, it
will be estimated.</p>
</td></tr>
<tr><td><code id="ses_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="ses_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="ses_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
<tr><td><code id="ses_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>forecast.ets</code>.</p>
</td></tr>
<tr><td><code id="ses_+3A_damped">damped</code></td>
<td>
<p>If TRUE, use a damped trend.</p>
</td></tr>
<tr><td><code id="ses_+3A_exponential">exponential</code></td>
<td>
<p>If TRUE, an exponential trend is fitted. Otherwise, the
trend is (locally) linear.</p>
</td></tr>
<tr><td><code id="ses_+3A_beta">beta</code></td>
<td>
<p>Value of smoothing parameter for the trend. If <code>NULL</code>, it
will be estimated.</p>
</td></tr>
<tr><td><code id="ses_+3A_phi">phi</code></td>
<td>
<p>Value of damping parameter if <code>damped=TRUE</code>. If <code>NULL</code>,
it will be estimated.</p>
</td></tr>
<tr><td><code id="ses_+3A_seasonal">seasonal</code></td>
<td>
<p>Type of seasonality in <code>hw</code> model. &quot;additive&quot; or
&quot;multiplicative&quot;</p>
</td></tr>
<tr><td><code id="ses_+3A_gamma">gamma</code></td>
<td>
<p>Value of smoothing parameter for the seasonal component. If
<code>NULL</code>, it will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ses, holt and hw are simply convenient wrapper functions for
<code>forecast(ets(...))</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>ets</code> and associated
functions.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted
model.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Koehler, A.B., Ord, J.K., Snyder, R.D. (2008)
<em>Forecasting with exponential smoothing: the state space approach</em>,
Springer-Verlag: New York. <a href="http://www.exponentialsmoothing.net">http://www.exponentialsmoothing.net</a>.
</p>
<p>Hyndman and Athanasopoulos (2018) <em>Forecasting: principles
and practice</em>, 2nd edition, OTexts: Melbourne, Australia.
<a href="https://otexts.com/fpp2/">https://otexts.com/fpp2/</a>
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+ets">ets</a></code>, <code><a href="stats.html#topic+HoltWinters">HoltWinters</a></code>,
<code><a href="forecast.html#topic+rwf">rwf</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fcast &lt;- holt(airmiles)
plot(fcast)
deaths.fcast &lt;- hw(USAccDeaths,h=48)
plot(deaths.fcast)

</code></pre>

<hr>
<h2 id='simulate.ets'>Simulation from a time series model</h2><span id='topic+simulate.ets'></span><span id='topic+simulate.Arima'></span><span id='topic+simulate.ar'></span><span id='topic+simulate.lagwalk'></span><span id='topic+simulate.fracdiff'></span><span id='topic+simulate.nnetar'></span><span id='topic+simulate.modelAR'></span><span id='topic+simulate.tbats'></span>

<h3>Description</h3>

<p>Returns a time series based on the model object <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ets'
simulate(
  object,
  nsim = length(object$x),
  seed = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  ...
)

## S3 method for class 'Arima'
simulate(
  object,
  nsim = length(object$x),
  seed = NULL,
  xreg = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  lambda = object$lambda,
  ...
)

## S3 method for class 'ar'
simulate(
  object,
  nsim = object$n.used,
  seed = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  ...
)

## S3 method for class 'lagwalk'
simulate(
  object,
  nsim = length(object$x),
  seed = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  lambda = object$lambda,
  ...
)

## S3 method for class 'fracdiff'
simulate(
  object,
  nsim = object$n,
  seed = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  ...
)

## S3 method for class 'nnetar'
simulate(
  object,
  nsim = length(object$x),
  seed = NULL,
  xreg = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  lambda = object$lambda,
  ...
)

## S3 method for class 'modelAR'
simulate(
  object,
  nsim = length(object$x),
  seed = NULL,
  xreg = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  lambda = object$lambda,
  ...
)

## S3 method for class 'tbats'
simulate(
  object,
  nsim = length(object$y),
  seed = NULL,
  future = TRUE,
  bootstrap = FALSE,
  innov = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ets_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>ets</code>&quot;, &quot;<code>Arima</code>&quot;, &quot;<code>ar</code>&quot;
or &quot;<code>nnetar</code>&quot;.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_nsim">nsim</code></td>
<td>
<p>Number of periods for the simulated series. Ignored if either
<code>xreg</code> or <code>innov</code> are not <code>NULL</code>. Otherwise the default is
the length of series used to train model (or 100 if no data found).</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_seed">seed</code></td>
<td>
<p>Either <code>NULL</code> or an integer that will be used in a call to
<code><a href="base.html#topic+set.seed">set.seed</a></code> before simulating the time series. The default,
<code>NULL</code>, will not change the random generator state.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_future">future</code></td>
<td>
<p>Produce sample paths that are future to and conditional on the
data in <code>object</code>. Otherwise simulate unconditionally.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Do simulation using resampled errors rather than normally
distributed errors or errors provided as <code>innov</code>.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_innov">innov</code></td>
<td>
<p>A vector of innovations to use as the error series. Ignored if
<code>bootstrap==TRUE</code>. If not <code>NULL</code>, the value of <code>nsim</code> is set
to length of <code>innov</code>.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_...">...</code></td>
<td>
<p>Other arguments, not currently used.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_xreg">xreg</code></td>
<td>
<p>New values of <code>xreg</code> to be used for forecasting. The value
of <code>nsim</code> is set to the number of rows of <code>xreg</code> if it is not
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate.ets_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>simulate.Arima()</code>, the <code>object</code> should be produced by
<code><a href="forecast.html#topic+Arima">Arima</a></code> or <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>, rather than
<code><a href="stats.html#topic+arima">arima</a></code>. By default, the error series is assumed normally
distributed and generated using <code><a href="stats.html#topic+rnorm">rnorm</a></code>. If <code>innov</code>
is present, it is used instead. If <code>bootstrap=TRUE</code> and
<code>innov=NULL</code>, the residuals are resampled instead.
</p>
<p>When <code>future=TRUE</code>, the sample paths are conditional on the data. When
<code>future=FALSE</code> and the model is stationary, the sample paths do not
depend on the data at all. When <code>future=FALSE</code> and the model is
non-stationary, the location of the sample paths is arbitrary, so they all
start at the value of the first observation.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>ts</code>&quot;.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+ets">ets</a></code>, <code><a href="forecast.html#topic+Arima">Arima</a></code>, <code><a href="forecast.html#topic+auto.arima">auto.arima</a></code>,
<code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="forecast.html#topic+arfima">arfima</a></code>, <code><a href="forecast.html#topic+nnetar">nnetar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- ets(USAccDeaths)
plot(USAccDeaths, xlim = c(1973, 1982))
lines(simulate(fit, 36), col = "red")
</code></pre>

<hr>
<h2 id='sindexf'>Forecast seasonal index</h2><span id='topic+sindexf'></span>

<h3>Description</h3>

<p>Returns vector containing the seasonal index for <code>h</code> future periods. If
the seasonal index is non-periodic, it uses the last values of the index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sindexf(object, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sindexf_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="stats.html#topic+decompose">decompose</a></code> or
<a href="stats.html#topic+stl">stl</a>.</p>
</td></tr>
<tr><td><code id="sindexf_+3A_h">h</code></td>
<td>
<p>Number of periods ahead to forecast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uk.stl &lt;- stl(UKDriverDeaths,"periodic")
uk.sa &lt;- seasadj(uk.stl)
uk.fcast &lt;- holt(uk.sa,36)
seasf &lt;- sindexf(uk.stl,36)
uk.fcast$mean &lt;- uk.fcast$mean + seasf
uk.fcast$lower &lt;- uk.fcast$lower + cbind(seasf,seasf)
uk.fcast$upper &lt;- uk.fcast$upper + cbind(seasf,seasf)
uk.fcast$x &lt;- UKDriverDeaths
plot(uk.fcast,main="Forecasts from Holt's method with seasonal adjustment")

</code></pre>

<hr>
<h2 id='splinef'>Cubic Spline Forecast</h2><span id='topic+splinef'></span>

<h3>Description</h3>

<p>Returns local linear forecasts and prediction intervals using cubic
smoothing splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splinef(
  y,
  h = 10,
  level = c(80, 95),
  fan = FALSE,
  lambda = NULL,
  biasadj = FALSE,
  method = c("gcv", "mle"),
  x = y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splinef_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="splinef_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="splinef_+3A_level">level</code></td>
<td>
<p>Confidence level for prediction intervals.</p>
</td></tr>
<tr><td><code id="splinef_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="splinef_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="splinef_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="splinef_+3A_method">method</code></td>
<td>
<p>Method for selecting the smoothing parameter. If
<code>method="gcv"</code>, the generalized cross-validation method from
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> is used. If <code>method="mle"</code>, the
maximum likelihood method from Hyndman et al (2002) is used.</p>
</td></tr>
<tr><td><code id="splinef_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cubic smoothing spline model is equivalent to an ARIMA(0,2,2) model but
with a restricted parameter space. The advantage of the spline model over
the full ARIMA model is that it provides a smooth historical trend as well
as a linear forecast function. Hyndman, King, Pitrun, and Billah (2002) show
that the forecast performance of the method is hardly affected by the
restricted parameter space.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>splinef</code>.
</p>
<p>An object of class <code>"forecast"</code> containing the following elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the fitted model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a character string</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr> <tr><td><code>lower</code></td>
<td>
<p>Lower limits for
prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper limits for prediction intervals</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>The confidence values associated with the prediction intervals</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series (either <code>object</code> itself or the time
series used to create the model stored as <code>object</code>).</p>
</td></tr>
<tr><td><code>onestepf</code></td>
<td>
<p>One-step forecasts from the fitted model.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Smooth estimates of the fitted trend using all data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model. That is x minus one-step
forecasts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, King, Pitrun and Billah (2005) Local linear forecasts
using cubic smoothing splines. <em>Australian and New Zealand Journal of
Statistics</em>, <b>47</b>(1), 87-99.
<a href="https://robjhyndman.com/publications/splinefcast/">https://robjhyndman.com/publications/splinefcast/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>,
<code><a href="forecast.html#topic+holt">holt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fcast &lt;- splinef(uspop,h=5)
plot(fcast)
summary(fcast)

</code></pre>

<hr>
<h2 id='StatForecast'>Forecast plot</h2><span id='topic+StatForecast'></span><span id='topic+GeomForecast'></span><span id='topic+geom_forecast'></span>

<h3>Description</h3>

<p>Generates forecasts from <code>forecast.ts</code> and adds them to the plot.
Forecasts can be modified via sending forecast specific arguments above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatForecast

GeomForecast

geom_forecast(
  mapping = NULL,
  data = NULL,
  stat = "forecast",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  PI = TRUE,
  showgap = TRUE,
  series = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StatForecast_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot data as
specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot data. All
objects will be fortified to produce a data frame. See <code><a href="ggplot2.html#topic+fortify">fortify</a></code>
for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument, the plot data. The
return value must be a <code>data.frame</code>, and will be used as the layer
data.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_stat">stat</code></td>
<td>
<p>The stat object to use calculate the data.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with a
warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_pi">PI</code></td>
<td>
<p>If <code>FALSE</code>, confidence intervals will not be plotted, giving
only the forecast line.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_showgap">showgap</code></td>
<td>
<p>If <code>showgap=FALSE</code>, the gap between the historical
observations and the forecasts is removed.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_series">series</code></td>
<td>
<p>Matches an unidentified forecast layer with a coloured object
on the plot.</p>
</td></tr>
<tr><td><code id="StatForecast_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="forecast.html#topic+forecast.ts">forecast.ts</a></code>, other
arguments are passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. These are often aesthetics,
used to set an aesthetic to a fixed value, like <code>color = "red"</code> or
<code>alpha = .5</code>. They may also be parameters to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>StatForecast</code> (inherits from <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 3.
</p>
<p>An object of class <code>GeomForecast</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 7.
</p>


<h3>Details</h3>

<p>Multivariate forecasting is supported by having each time series on a
different group.
</p>
<p>You can also pass <code>geom_forecast</code> a <code>forecast</code> object to add it to
the plot.
</p>
<p>The aesthetics required for the forecasting to work includes forecast
observations on the y axis, and the <code>time</code> of the observations on the x
axis. Refer to the examples below. To automatically set up aesthetics, use
<code>autoplot</code>.
</p>


<h3>Value</h3>

<p>A layer for a ggplot graph.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild
</p>


<h3>See Also</h3>

<p><code><a href="fabletools.html#topic+forecast">forecast</a></code>, <code><a href="ggplot2.html#topic+ggproto">ggproto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(ggplot2)
autoplot(USAccDeaths) + geom_forecast()

lungDeaths &lt;- cbind(mdeaths, fdeaths)
autoplot(lungDeaths) + geom_forecast()

# Using fortify.ts
p &lt;- ggplot(aes(x=x, y=y), data=USAccDeaths)
p &lt;- p + geom_line()
p + geom_forecast()

# Without fortify.ts
data &lt;- data.frame(USAccDeaths=as.numeric(USAccDeaths), time=as.numeric(time(USAccDeaths)))
p &lt;- ggplot(aes(x=time, y=USAccDeaths), data=data)
p &lt;- p + geom_line()
p + geom_forecast()

p + geom_forecast(h=60)
p &lt;- ggplot(aes(x=time, y=USAccDeaths), data=data)
p + geom_forecast(level=c(70,98))
p + geom_forecast(level=c(70,98),colour="lightblue")

#Add forecasts to multivariate series with colour groups
lungDeaths &lt;- cbind(mdeaths, fdeaths)
autoplot(lungDeaths) + geom_forecast(forecast(mdeaths), series="mdeaths")

## End(Not run)

</code></pre>

<hr>
<h2 id='subset.ts'>Subsetting a time series</h2><span id='topic+subset.ts'></span><span id='topic+subset.msts'></span>

<h3>Description</h3>

<p>Various types of subsetting of a time series. Allows subsetting by index
values (unlike <code><a href="stats.html#topic+window">window</a></code>). Also allows extraction of the
values of a specific season or subset of seasons in each year. For example,
to extract all values for the month of May from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
subset(
  x,
  subset = NULL,
  month = NULL,
  quarter = NULL,
  season = NULL,
  start = NULL,
  end = NULL,
  ...
)

## S3 method for class 'msts'
subset(x, subset = NULL, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.ts_+3A_x">x</code></td>
<td>
<p>a univariate time series to be subsetted</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_subset">subset</code></td>
<td>
<p>optional logical expression indicating elements to keep;
missing values are taken as false. <code>subset</code> must be the same length as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_month">month</code></td>
<td>
<p>Numeric or character vector of months to retain. Partial
matching on month names used.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_quarter">quarter</code></td>
<td>
<p>Numeric or character vector of quarters to retain.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_season">season</code></td>
<td>
<p>Numeric vector of seasons to retain.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_start">start</code></td>
<td>
<p>Index of start of contiguous subset.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_end">end</code></td>
<td>
<p>Index of end of contiguous subset.</p>
</td></tr>
<tr><td><code id="subset.ts_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If character values for months are used, either upper or lower case may be
used, and partial unambiguous names are acceptable. Possible character
values for quarters are <code>"Q1"</code>, <code>"Q2"</code>, <code>"Q3"</code>, and
<code>"Q4"</code>.
</p>


<h3>Value</h3>

<p>If <code>subset</code> is used, a numeric vector is returned with no ts
attributes. If <code>start</code> and/or <code>end</code> are used, a ts object is
returned consisting of x[start:end], with the appropriate time series
attributes retained. Otherwise, a ts object is returned with frequency equal
to the length of <code>month</code>, <code>quarter</code> or <code>season</code>.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>, <code><a href="stats.html#topic+window">window</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(subset(gas,month="November"))
subset(woolyrnq,quarter=3)
subset(USAccDeaths, start=49)

</code></pre>

<hr>
<h2 id='taylor'>Half-hourly electricity demand</h2><span id='topic+taylor'></span>

<h3>Description</h3>

<p>Half-hourly electricity demand in England and Wales from Monday 5 June 2000
to Sunday 27 August 2000. Discussed in Taylor (2003), and kindly provided by
James W Taylor. Units: Megawatts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taylor
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>James W Taylor
</p>


<h3>References</h3>

<p>Taylor, J.W. (2003) Short-term electricity demand forecasting
using double seasonal exponential smoothing. <em>Journal of the
Operational Research Society</em>, <b>54</b>, 799-805.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(taylor)

</code></pre>

<hr>
<h2 id='tbats'>TBATS model (Exponential smoothing state space model with Box-Cox
transformation, ARMA errors, Trend and Seasonal components)</h2><span id='topic+tbats'></span><span id='topic+as.character.tbats'></span><span id='topic+print.tbats'></span>

<h3>Description</h3>

<p>Fits a TBATS model applied to <code>y</code>, as described in De Livera, Hyndman &amp;
Snyder (2011). Parallel processing is used by default to speed up the
computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbats(
  y,
  use.box.cox = NULL,
  use.trend = NULL,
  use.damped.trend = NULL,
  seasonal.periods = NULL,
  use.arma.errors = TRUE,
  use.parallel = length(y) &gt; 1000,
  num.cores = 2,
  bc.lower = 0,
  bc.upper = 1,
  biasadj = FALSE,
  model = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbats_+3A_y">y</code></td>
<td>
<p>The time series to be forecast. Can be <code>numeric</code>, <code>msts</code>
or <code>ts</code>. Only univariate time series are supported.</p>
</td></tr>
<tr><td><code id="tbats_+3A_use.box.cox">use.box.cox</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to use the Box-Cox
transformation or not. If <code>NULL</code> then both are tried and the best fit
is selected by AIC.</p>
</td></tr>
<tr><td><code id="tbats_+3A_use.trend">use.trend</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include a trend or
not. If <code>NULL</code> then both are tried and the best fit is selected by AIC.</p>
</td></tr>
<tr><td><code id="tbats_+3A_use.damped.trend">use.damped.trend</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include a
damping parameter in the trend or not. If <code>NULL</code> then both are tried
and the best fit is selected by AIC.</p>
</td></tr>
<tr><td><code id="tbats_+3A_seasonal.periods">seasonal.periods</code></td>
<td>
<p>If <code>y</code> is <code>numeric</code> then seasonal periods
can be specified with this parameter.</p>
</td></tr>
<tr><td><code id="tbats_+3A_use.arma.errors">use.arma.errors</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether to include ARMA
errors or not. If <code>TRUE</code> the best fit is selected by AIC. If
<code>FALSE</code> then the selection algorithm does not consider ARMA errors.</p>
</td></tr>
<tr><td><code id="tbats_+3A_use.parallel">use.parallel</code></td>
<td>
<p><code>TRUE/FALSE</code> indicates whether or not to use
parallel processing.</p>
</td></tr>
<tr><td><code id="tbats_+3A_num.cores">num.cores</code></td>
<td>
<p>The number of parallel processes to be used if using
parallel processing. If <code>NULL</code> then the number of logical cores is
detected and all available cores are used.</p>
</td></tr>
<tr><td><code id="tbats_+3A_bc.lower">bc.lower</code></td>
<td>
<p>The lower limit (inclusive) for the Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="tbats_+3A_bc.upper">bc.upper</code></td>
<td>
<p>The upper limit (inclusive) for the Box-Cox transformation.</p>
</td></tr>
<tr><td><code id="tbats_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If TRUE, point forecasts and fitted values are mean
forecast. Otherwise, these points can be considered the median of the
forecast densities.</p>
</td></tr>
<tr><td><code id="tbats_+3A_model">model</code></td>
<td>
<p>Output from a previous call to <code>tbats</code>. If model is
passed, this same model is fitted to <code>y</code> without re-estimating any
parameters.</p>
</td></tr>
<tr><td><code id="tbats_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>auto.arima</code> when
choose an ARMA(p, q) model for the errors. (Note that xreg will be ignored,
as will any arguments concerning seasonality and differencing, but arguments
controlling the values of p and q will be used.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with class <code>c("tbats", "bats")</code>. The generic accessor
functions <code>fitted.values</code> and <code>residuals</code> extract useful features
of the value returned by <code>bats</code> and associated functions. The fitted
model is designated TBATS(omega, p,q, phi, &lt;m1,k1&gt;,...,&lt;mJ,kJ&gt;) where omega
is the Box-Cox parameter and phi is the damping parameter; the error is
modelled as an ARMA(p,q) process and m1,...,mJ list the seasonal periods
used in the model and k1,...,kJ are the corresponding number of Fourier
terms used for each seasonality.
</p>


<h3>Author(s)</h3>

<p>Slava Razbash and Rob J Hyndman
</p>


<h3>References</h3>

<p>De Livera, A.M., Hyndman, R.J., &amp; Snyder, R. D. (2011),
Forecasting time series with complex seasonal patterns using exponential
smoothing, <em>Journal of the American Statistical Association</em>,
<b>106</b>(496), 1513-1527.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+tbats.components">tbats.components</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- tbats(USAccDeaths)
plot(forecast(fit))

taylor.fit &lt;- tbats(taylor)
plot(forecast(taylor.fit))
## End(Not run)

</code></pre>

<hr>
<h2 id='tbats.components'>Extract components of a TBATS model</h2><span id='topic+tbats.components'></span>

<h3>Description</h3>

<p>Extract the level, slope and seasonal components of a TBATS model. The extracted components are Box-Cox transformed using the estimated transformation parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbats.components(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbats.components_+3A_x">x</code></td>
<td>
<p>A tbats object created by <code><a href="forecast.html#topic+tbats">tbats</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multiple time series (<code>mts</code>) object. The first series is the observed time series. The second series is the trend component of the fitted model. Series three onwards are the seasonal components of the fitted model with one time series for each of the seasonal components. All components are transformed using estimated Box-Cox parameter.
</p>


<h3>Author(s)</h3>

<p>Slava Razbash and Rob J Hyndman
</p>


<h3>References</h3>

<p>De Livera, A.M., Hyndman, R.J., &amp; Snyder, R. D. (2011),
Forecasting time series with complex seasonal patterns using exponential
smoothing, <em>Journal of the American Statistical Association</em>,
<b>106</b>(496), 1513-1527.
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+tbats">tbats</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- tbats(USAccDeaths, use.parallel=FALSE)
components &lt;- tbats.components(fit)
plot(components)
## End(Not run)

</code></pre>

<hr>
<h2 id='thetaf'>Theta method forecast</h2><span id='topic+thetaf'></span>

<h3>Description</h3>

<p>Returns forecasts and prediction intervals for a theta method forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaf(
  y,
  h = ifelse(frequency(y) &gt; 1, 2 * frequency(y), 10),
  level = c(80, 95),
  fan = FALSE,
  x = y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaf_+3A_y">y</code></td>
<td>
<p>a numeric vector or time series of class <code>ts</code></p>
</td></tr>
<tr><td><code id="thetaf_+3A_h">h</code></td>
<td>
<p>Number of periods for forecasting</p>
</td></tr>
<tr><td><code id="thetaf_+3A_level">level</code></td>
<td>
<p>Confidence levels for prediction intervals.</p>
</td></tr>
<tr><td><code id="thetaf_+3A_fan">fan</code></td>
<td>
<p>If TRUE, level is set to seq(51,99,by=3). This is suitable for
fan plots.</p>
</td></tr>
<tr><td><code id="thetaf_+3A_x">x</code></td>
<td>
<p>Deprecated. Included for backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theta method of Assimakopoulos and Nikolopoulos (2000) is equivalent to
simple exponential smoothing with drift. This is demonstrated in Hyndman and
Billah (2003).
</p>
<p>The series is tested for seasonality using the test outlined in A&amp;N. If
deemed seasonal, the series is seasonally adjusted using a classical
multiplicative decomposition before applying the theta method. The resulting
forecasts are then reseasonalized.
</p>
<p>Prediction intervals are computed using the underlying state space model.
</p>
<p>More general theta methods are available in the
<code><a href="forecTheta.html#topic+forecTheta">forecTheta</a></code> package.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>forecast</code>&quot;.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results, while the function <code>plot</code> produces a plot of the forecasts and
prediction intervals.
</p>
<p>The generic accessor functions <code>fitted.values</code> and <code>residuals</code>
extract useful features of the value returned by <code>rwf</code>.
</p>
<p>An object of class <code>"forecast"</code> is a list containing at least the
following elements: </p>
<table>
<tr><td><code>model</code></td>
<td>
<p>A list containing information about the
fitted model</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>The name of the forecasting method as a
character string</p>
</td></tr> <tr><td><code>mean</code></td>
<td>
<p>Point forecasts as a time series</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits for prediction intervals</p>
</td></tr> <tr><td><code>upper</code></td>
<td>
<p>Upper
limits for prediction intervals</p>
</td></tr> <tr><td><code>level</code></td>
<td>
<p>The confidence values
associated with the prediction intervals</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>The original time series
(either <code>object</code> itself or the time series used to create the model
stored as <code>object</code>).</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p>Residuals from the fitted model.
That is x minus fitted values.</p>
</td></tr> <tr><td><code>fitted</code></td>
<td>
<p>Fitted values (one-step
forecasts)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Assimakopoulos, V. and Nikolopoulos, K. (2000). The theta model:
a decomposition approach to forecasting. <em>International Journal of
Forecasting</em> <b>16</b>, 521-530.
</p>
<p>Hyndman, R.J., and Billah, B. (2003) Unmasking the Theta method.
<em>International J. Forecasting</em>, <b>19</b>, 287-290.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="forecast.html#topic+meanf">meanf</a></code>, <code><a href="forecast.html#topic+rwf">rwf</a></code>,
<code><a href="diffobj.html#topic+ses">ses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nile.fcast &lt;- thetaf(Nile)
plot(nile.fcast)
</code></pre>

<hr>
<h2 id='tsclean'>Identify and replace outliers and missing values in a time series</h2><span id='topic+tsclean'></span>

<h3>Description</h3>

<p>Uses supsmu for non-seasonal series and a robust STL decomposition for
seasonal series. To estimate missing values and outlier replacements,
linear interpolation is used on the (possibly seasonally adjusted) series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsclean(x, replace.missing = TRUE, iterate = 2, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsclean_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="tsclean_+3A_replace.missing">replace.missing</code></td>
<td>
<p>If TRUE, it not only replaces outliers, but also
interpolates missing values</p>
</td></tr>
<tr><td><code id="tsclean_+3A_iterate">iterate</code></td>
<td>
<p>the number of iterations required</p>
</td></tr>
<tr><td><code id="tsclean_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman (2021) &quot;Detecting time series outliers&quot; <a href="https://robjhyndman.com/hyndsight/tsoutliers/">https://robjhyndman.com/hyndsight/tsoutliers/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na.interp">na.interp</a></code>,
<code><a href="#topic+tsoutliers">tsoutliers</a></code>, <code><a href="stats.html#topic+supsmu">supsmu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cleangold &lt;- tsclean(gold)

</code></pre>

<hr>
<h2 id='tsCV'>Time series cross-validation</h2><span id='topic+tsCV'></span>

<h3>Description</h3>

<p><code>tsCV</code> computes the forecast errors obtained by applying
<code>forecastfunction</code> to subsets of the time series <code>y</code> using a
rolling forecast origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsCV(y, forecastfunction, h = 1, window = NULL, xreg = NULL, initial = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsCV_+3A_y">y</code></td>
<td>
<p>Univariate time series</p>
</td></tr>
<tr><td><code id="tsCV_+3A_forecastfunction">forecastfunction</code></td>
<td>
<p>Function to return an object of class
<code>forecast</code>. Its first argument must be a univariate time series, and it
must have an argument <code>h</code> for the forecast horizon. If exogenous predictors are used,
then it must also have <code>xreg</code> and <code>newxreg</code> arguments corresponding to the
training and test periods.</p>
</td></tr>
<tr><td><code id="tsCV_+3A_h">h</code></td>
<td>
<p>Forecast horizon</p>
</td></tr>
<tr><td><code id="tsCV_+3A_window">window</code></td>
<td>
<p>Length of the rolling window, if NULL, a rolling window will not be used.</p>
</td></tr>
<tr><td><code id="tsCV_+3A_xreg">xreg</code></td>
<td>
<p>Exogeneous predictor variables passed to the forecast function if required.</p>
</td></tr>
<tr><td><code id="tsCV_+3A_initial">initial</code></td>
<td>
<p>Initial period of the time series where no cross-validation is performed.</p>
</td></tr>
<tr><td><code id="tsCV_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code>forecastfunction</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>y</code> contain the time series <code class="reqn">y_1,\dots,y_T</code>. Then
<code>forecastfunction</code> is applied successively to the time series
<code class="reqn">y_1,\dots,y_t</code>, for <code class="reqn">t=1,\dots,T-h</code>, making predictions
<code class="reqn">\hat{y}_{t+h|t}</code>. The errors are given by <code class="reqn">e_{t+h} =
y_{t+h}-\hat{y}_{t+h|t}</code>. If h=1, these are returned as a
vector, <code class="reqn">e_1,\dots,e_T</code>. For h&gt;1, they are returned as a matrix with
the hth column containing errors for forecast horizon h.
The first few errors may be missing as
it may not be possible to apply <code>forecastfunction</code> to very short time
series.
</p>


<h3>Value</h3>

<p>Numerical time series object containing the forecast errors as a vector (if h=1)
and a matrix otherwise. The time index corresponds to the last period of the training
data. The columns correspond to the forecast horizons.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><a href="forecast.html#topic+CV">CV</a>, <a href="forecast.html#topic+CVar">CVar</a>, <a href="forecast.html#topic+residuals.Arima">residuals.Arima</a>, <a href="https://robjhyndman.com/hyndsight/tscv/">https://robjhyndman.com/hyndsight/tscv/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Fit an AR(2) model to each rolling origin subset
far2 &lt;- function(x, h){forecast(Arima(x, order=c(2,0,0)), h=h)}
e &lt;- tsCV(lynx, far2, h=1)

#Fit the same model with a rolling window of length 30
e &lt;- tsCV(lynx, far2, h=1, window=30)

#Example with exogenous predictors
far2_xreg &lt;- function(x, h, xreg, newxreg) {
  forecast(Arima(x, order=c(2,0,0), xreg=xreg), xreg=newxreg)
}

y &lt;- ts(rnorm(50))
xreg &lt;- matrix(rnorm(100),ncol=2)
e &lt;- tsCV(y, far2_xreg, h=3, xreg=xreg)

</code></pre>

<hr>
<h2 id='tslm'>Fit a linear model with time series components</h2><span id='topic+tslm'></span>

<h3>Description</h3>

<p><code>tslm</code> is used to fit linear models to time series including trend and
seasonality components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslm(formula, data, subset, lambda = NULL, biasadj = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tslm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to
that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="tslm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by as.data.frame to a data frame) containing the variables in the model. If
not found in data, the variables are taken from environment(formula),
typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="tslm_+3A_subset">subset</code></td>
<td>
<p>an optional subset containing rows of data to keep. For best
results, pass a logical vector of rows to keep. Also supports
<code><a href="base.html#topic+subset">subset</a>()</code> functions.</p>
</td></tr>
<tr><td><code id="tslm_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
<tr><td><code id="tslm_+3A_biasadj">biasadj</code></td>
<td>
<p>Use adjusted back-transformed mean for Box-Cox
transformations. If transformed data is used to produce forecasts and fitted values,
a regular back transformation will result in median forecasts. If biasadj is TRUE,
an adjustment will be made to produce mean forecasts and fitted values.</p>
</td></tr>
<tr><td><code id="tslm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stats.html#topic+lm">lm</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tslm</code> is largely a wrapper for <code><a href="stats.html#topic+lm">lm</a>()</code> except that
it allows variables &quot;trend&quot; and &quot;season&quot; which are created on the fly from
the time series characteristics of the data. The variable &quot;trend&quot; is a
simple time trend and &quot;season&quot; is a factor indicating the season (e.g., the
month or the quarter depending on the frequency of the data).
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;lm&quot;.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild and Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="forecast.html#topic+forecast.lm">forecast.lm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
fit &lt;- tslm(y ~ trend + season)
plot(forecast(fit, h=20))

</code></pre>

<hr>
<h2 id='tsoutliers'>Identify and replace outliers in a time series</h2><span id='topic+tsoutliers'></span>

<h3>Description</h3>

<p>Uses supsmu for non-seasonal series and a periodic stl decomposition with
seasonal series to identify outliers and estimate their replacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsoutliers(x, iterate = 2, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsoutliers_+3A_x">x</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="tsoutliers_+3A_iterate">iterate</code></td>
<td>
<p>the number of iterations required</p>
</td></tr>
<tr><td><code id="tsoutliers_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter. If <code>lambda="auto"</code>,
then a transformation is automatically selected using <code>BoxCox.lambda</code>.
The transformation is ignored if NULL. Otherwise,
data transformed before model is estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>index</code></td>
<td>
<p>Indicating the index of outlier(s)</p>
</td></tr>
<tr><td><code>replacement</code></td>
<td>
<p>Suggested numeric values to replace identified outliers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman (2021) &quot;Detecting time series outliers&quot; <a href="https://robjhyndman.com/hyndsight/tsoutliers/">https://robjhyndman.com/hyndsight/tsoutliers/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+na.interp">na.interp</a></code>, <code><a href="#topic+tsclean">tsclean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gold)
tsoutliers(gold)

</code></pre>

<hr>
<h2 id='wineind'>Australian total wine sales</h2><span id='topic+wineind'></span>

<h3>Description</h3>

<p>Australian total wine sales by wine makers in bottles &lt;= 1 litre. Jan 1980
&ndash; Aug 1994.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wineind
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>Time Series Data Library. <a href="https://pkg.yangzhuoranyang.com/tsdl/">https://pkg.yangzhuoranyang.com/tsdl/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsdisplay(wineind)

</code></pre>

<hr>
<h2 id='woolyrnq'>Quarterly production of woollen yarn in Australia</h2><span id='topic+woolyrnq'></span>

<h3>Description</h3>

<p>Quarterly production of woollen yarn in Australia: tonnes. Mar 1965 &ndash; Sep
1994.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woolyrnq
</code></pre>


<h3>Format</h3>

<p>Time series data
</p>


<h3>Source</h3>

<p>Time Series Data Library. <a href="https://pkg.yangzhuoranyang.com/tsdl/">https://pkg.yangzhuoranyang.com/tsdl/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tsdisplay(woolyrnq)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
