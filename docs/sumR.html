<!DOCTYPE html><html><head><title>Help for package sumR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sumR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#finiteSum'><p>Calculates the sum of a discrete series with a single maximum for a pre-set</p>
number of evaluations</a></li>
<li><a href='#infiniteSum'><p>Approximates the sum of a positive discrete infinite series with a single</p>
maximum</a></li>
<li><a href='#infiniteSum_batches'><p>Approximates the sum of a positive discrete infinite series with a single</p>
maximum using the batches algorithm</a></li>
<li><a href='#precompiled'><p>List of precompiled functions in the sumR package</p></a></li>
<li><a href='#summed-objects'><p>S3 Class for objects containing iterated summations</p></a></li>
<li><a href='#sumR'><p>sumR: Approximate series withing a desired error margin</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate Summation of Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guido A. Moreira &lt;guidoalber@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Application of theoretical results which ensure that the summation
  of an infinite discrete series is within an arbitrary margin of error of its
  true value. The C code under the hood is shared through header files to allow
  users to sum their own low level functions as well. Based on the paper by
  Braden (1992) &lt;<a href="https://doi.org/10.2307%2F2324995">doi:10.2307/2324995</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 10:39:22 UTC; anthorg</td>
</tr>
<tr>
<td>Author:</td>
<td>Guido A. Moreira <a href="https://orcid.org/0000-0001-7557-0874"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Luiz Max Carvalho <a href="https://orcid.org/0000-0001-5736-5578"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='finiteSum'>Calculates the sum of a discrete series with a single maximum for a pre-set
number of evaluations</h2><span id='topic+finiteSum'></span>

<h3>Description</h3>

<p>A discrete finite series is calculated exactly with no need for
approximations. This can also be used for infinite series approximation with
a pre-determined number of iterations, but this has no guarantee of quality
of approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finiteSum(logFunction, parameters = numeric(), n, n0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finiteSum_+3A_logfunction">logFunction</code></td>
<td>
<p>The function that returns the series value
a<sub>n</sub> in
the log scale. Can either be an <code>R</code> function or a string indicating one
of the precompiled functions. See <code><a href="#topic+precompiled">precompiled()</a></code> for a list of
available functions. If defined in <code>R</code>, the function's definition must
have two arguments. The first argument must be the integer argument
equivalent to <code class="reqn">n</code> in a<sub>n</sub> and
the second must be a vector of numeric parameters.</p>
</td></tr>
<tr><td><code id="finiteSum_+3A_parameters">parameters</code></td>
<td>
<p>A numeric vector with parameters used in logFunction.
Vectorized summation over various parameter values sets is not implemented.
Use <code><a href="base.html#topic+apply">apply()</a></code> or their variants to achieve this.</p>
</td></tr>
<tr><td><code id="finiteSum_+3A_n">n</code></td>
<td>
<p>A single integer positive number indicating the number of iterations
to perform in the function.</p>
</td></tr>
<tr><td><code id="finiteSum_+3A_n0">n0</code></td>
<td>
<p>The sum will be performed for the series starting at this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+summed-objects">summed-objects()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompiled">precompiled()</a></code> provides a list with precompiled functions
that can be used for the summation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sum values from 5 to 100
finiteSum(function(x, p) log(x), numeric(), 100 - 5, 5)
</code></pre>

<hr>
<h2 id='infiniteSum'>Approximates the sum of a positive discrete infinite series with a single
maximum</h2><span id='topic+infiniteSum'></span>

<h3>Description</h3>

<p>For series that pass the ratio test, the approximation is analytically
guaranteed to have an error that is smaller than epsilon. This can
occasionally not happen due to floating point arithmetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infiniteSum(
  logFunction,
  parameters = numeric(),
  logL = NULL,
  alternate = FALSE,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0,
  forceAlgorithm = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infiniteSum_+3A_logfunction">logFunction</code></td>
<td>
<p>The function that returns the series absolute value
|a<sub>n</sub>| in
the log scale. If it is an alternating series, this is defined in
argument <code>alternate</code>. Can either be an <code>R</code> function or a string
indicating one of the precompiled functions. See <code><a href="#topic+precompiled">precompiled()</a></code>
for a list of available functions. If defined in <code>R</code>, the function's
definition must have two arguments. The first argument must be the integer
argument equivalent to <code class="reqn">n</code> in
a<sub>n</sub> and the second must be a vector
of numeric parameters.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_parameters">parameters</code></td>
<td>
<p>A numeric vector with parameters used in <code>logFunction</code>.
Vectorized summation over various parameter values sets is not implemented.
Use <code><a href="base.html#topic+apply">apply()</a></code> or their variants to achieve this.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_logl">logL</code></td>
<td>
<p>The log of the limit value of
a<sub>n+1</sub>/a<sub>n</sub> which
must be smaller than 1, or smaller than 0 in the log scale. Ignored if the
series is alternating, defined with argument <code>alternate</code>. If left as
<code>NULL</code> and <code>logFunction</code> is defined in <code>R</code>, the
<code>batches</code> algorithm with default settings is used. See 'details'.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_alternate">alternate</code></td>
<td>
<p>Either -1, 0 or 1. If 0 (or <code>FALSE</code>), the series is not
alternating and positive. Otherwise, the series is alternating where the
first element's sign is either 1 or -1, as entered in this parameter. If not
0, arguments <code>logL</code> and <code>forceAlgorithm</code> are ignored.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_epsilon">epsilon</code></td>
<td>
<p>The desired error margin for the approximation. See 'details'.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations for the approximation. In
most cases, this number will not be reached unless it is very small. A value
too high is not recommended as an array of this size is reserved in memory
during the algorithm.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_n0">n0</code></td>
<td>
<p>The sum will be approximated for the series starting at this value
for the first parameter of <code>logFunction</code>.</p>
</td></tr>
<tr><td><code id="infiniteSum_+3A_forcealgorithm">forceAlgorithm</code></td>
<td>
<p>A value to control which summation algorithm to use.
Ignored if the series is alternating, defined with argument <code>alternate</code>.
See 'details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximated sum is based on some theoretical results which,
analytically, guarantee that the approximation will be within <code>epsilon</code>
distance to the true value. It is possible that the numerical result fails
to fall in this distance due to floating point arithmetic. The <code>C</code> code
under the hood is being continuously reviewed to minimize this problem. They
seem to occur more often when the series decays very fast to zero or when the
total is a large number.
</p>
<p>For these theoretical results to work, the series must pass the ratio test,
which means that the ratio
a<sub>n+1</sub>/a<sub>n</sub> must
converge to a number <code class="reqn">L &lt; 1</code> when <code class="reqn">n</code> goes to infinity. The log of
<code class="reqn">L</code> should be provided to the function for a better approximation.
This is not necessary in case a precompiled function is used. In this case
the value of <code class="reqn">L</code> is coded into the package.
</p>
<p>Another requirement in the current installment of this function is that the
series must have only a single maximum. This is the case for most discrete
probability distributions and marginalization problems. This limitation
will be addressed in the future.
</p>
<p>There are currently two implemented algorithms that perform the calculations.
The first, called Sum-To-Threshold, sums the series values until the series
values are smaller than <code>epsilon</code>. This is the fastest algorithm, but
it is only guaranteed to provide an approximation within the desired error
margin when <code class="reqn">L &lt; 0.5</code>.
</p>
<p>The second algorithm, called Error bounding pairs is based on a more general
result which works for any <code class="reqn">0 \le L &lt; 1</code>. This algorithm sums the series
until
</p>
|a<sub>n+1</sub>/(1-L) - a<sub>n+1</sub> a<sub>n</sub>/(a<sub>n</sub> - a<sub>n+1</sub>)| < 2 ε.
<p>Then the approximation is the added values of the sum plus
</p>
 0.5 (a<sub>n+1</sub>/(1-L) + a<sub>n+1</sub> a<sub>n</sub>/(a<sub>n</sub> - a<sub>n+1</sub>))
<p>The Error bounding pairs method usually requires less function evaluations
than the Sum-To-Threshold one, however the convergence checking is more
demanding, which means that it is typically slower, albeit slightly. If
<code class="reqn">L = 0</code>, the convergence checking can be reduced and the Error bounding
pairs becomes almost as fast as the Sum-To-Threshold method.
</p>
<p>The third algorithm is called batches method and is used when <code class="reqn">L</code> is
left at <code>NULL</code>. Its use requires some fine tuning, so there is a
standalone function for it called <code><a href="#topic+infiniteSum_batches">infiniteSum_batches()</a></code>. Its use
and functionality can be seen in its own documentation. When called as a
result of this function, default settings are used.
</p>
<p>The <code>forceAlgorithm</code> parameter can be used to
control which algorithm to use. When it is 0, the program automatically
selects the Sum-to-threshold when <code class="reqn">L &lt; 0.5</code> and the Error bounding pairs
when <code class="reqn">0.5 \le L &lt; 1</code>. Method batches is selected when <code class="reqn">L</code> is left
<code>NULL</code>. If <code>forceAlgorithm</code> is set to 1, the Sum-To-Threshold
algorithm is forced. If it is 2, then the Error bounding pairs is forced. A
small note, the Error bounding pairs algorithm can go up to <code>maxIter</code> +
1 function evaluations. This is due to its convergence checking dependence on
a<sub>n+1</sub>. Finally, if the
parameter is set as 3, the batches algorithm is used with default settings.
</p>
<p>If the series is alternating, the Sum-To-Threshold convergence condition on
the series absolute value guarantees the result, regardless of the ratio
limit.
</p>
<p>The function to be summed can be an R function or a string naming the
precompiled function in the package. The list of precompiled functions can
be found in <code><a href="#topic+precompiled">precompiled()</a></code>, and more functions will be added in
time. As is intuitive, using a precompiled function is much faster than using
an <code>R</code> function. In fact, it has been observed to be dozens times faster.
</p>
<p>The advanced user can program their own precompiled functions and use the
package's summation algorithms by linking the appropriate header file. See
the <a href="https://github.com/GuidoAMoreira/sumR">GitHub</a> readme for the a
quick tutorial.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+summed-objects">summed-objects()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompiled">precompiled()</a></code> provides a list with precompiled functions
that can be used for the summation. <code><a href="#topic+infiniteSum_batches">infiniteSum_batches()</a></code> is
an alternate method which does not require knowledge of the <code>logL</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define some function that is known to pass the ratio test.
param &lt;- 0.1
funfun &lt;- function(k, p) return(k * log1p(-p[1]))
result &lt;- infiniteSum(funfun, parameters = param, logL = log1p(-param))

## This series is easy to verify analytically
TrueSum &lt;- -log(param)
TrueSum - result$sum
# Since exp(logL) = 0.9, the Error bounding pairs
# algorithm is used. Notice that it only required
# 2 function evaluations for the approximation, that is
result$n

## A common problem is finding the normalizing constant for the
## Conway-Maxwell-Poisson distribution. It has already been included
## in the precompiled list of functions.
comp_params &lt;- c(lambda = 5, nu = 3)
result &lt;- infiniteSum("COMP", comp_params)
result
</code></pre>

<hr>
<h2 id='infiniteSum_batches'>Approximates the sum of a positive discrete infinite series with a single
maximum using the batches algorithm</h2><span id='topic+infiniteSum_batches'></span><span id='topic+infiniteSum_batches_C'></span>

<h3>Description</h3>

<p>A simple method to perform the summation. It adds the values in batches and
stops when the accumulated batch is smaller than the desired threshold. There
is an implementation purely in <code>R</code> and one in <code>C</code>. The one in R is
usually slightly faster due to vectorized computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infiniteSum_batches(
  logFunction,
  parameters = numeric(),
  batch_size = 40,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0
)

infiniteSum_batches_C(
  logFunction,
  parameters = numeric(),
  batch_size = 40,
  epsilon = 1e-15,
  maxIter = 1e+05,
  n0 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infiniteSum_batches_+3A_logfunction">logFunction</code></td>
<td>
<p>The function that returns the series value
a<sub>n</sub> in
the log scale. Can either be an <code>R</code> function or a string indicating one
of the pre-coded functions. See <code><a href="#topic+precompiled">precompiled()</a></code> for a list of
available functions. If defined in <code>R</code>, the function's definition must
have two arguments. The first argument must be the integer argument
equivalent to <code class="reqn">n</code> in a<sub>n</sub> and
the second must be a vector of numeric parameters.</p>
</td></tr>
<tr><td><code id="infiniteSum_batches_+3A_parameters">parameters</code></td>
<td>
<p>A numeric vector with parameters used in logFunction.
Vectorized summation over various parameter values sets is not implemented.
Use <code><a href="base.html#topic+apply">apply()</a></code> or their variants to achieve this.</p>
</td></tr>
<tr><td><code id="infiniteSum_batches_+3A_batch_size">batch_size</code></td>
<td>
<p>The batch size at which point convergence checking is
performed. The algorithm perform at least twice this number of function
evaluations. See 'details'.</p>
</td></tr>
<tr><td><code id="infiniteSum_batches_+3A_epsilon">epsilon</code></td>
<td>
<p>The desired error margin for the approximation. See 'details'.</p>
</td></tr>
<tr><td><code id="infiniteSum_batches_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations for the approximation. In
most cases, this number will not be reached unless it is very small.</p>
</td></tr>
<tr><td><code id="infiniteSum_batches_+3A_n0">n0</code></td>
<td>
<p>The sum will be approximated for the series starting at this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series a<sub>n</sub> must pass
the ratio convergence test, meaning that the ratio
a<sub>n+1</sub>/a<sub>n</sub> must
converge to a number <code class="reqn">L &lt; 1</code> when <code class="reqn">n</code> goes to infinity.
</p>
<p>The batches algorithm consists of evaluating the function a fixed number of
times for two checkpoints. If the difference between the sum at these
checkpoints is smaller than <code>epsilon</code>, the code stops and the later
checkpoint sum is returned. Else, continue summing until the next checkpoint.
All checkpoints are <code>batch_size</code> long.
</p>
<p>This function's efficiency is reliant on the choice of <code>batch_size</code>.
If it is set too large, the algorithm overshoots the necessary
number of function evaluations too much. If it is set too small, the
algorithm will need to process too many partial summations which slows it
down. However, if they are well calibrated for the series, they can
potentially be very efficient.
</p>
<p>Since the batch sizes are known before the calculations are made,
function evaluations can be vectorized. This is why there are two functions
available. <code>infiniteSum_batches</code> does the calculations at the <code>R</code>
level, while <code>infiniteSum_batches_C</code> interfaces the low level <code>C</code>
code. However, the <code>C</code> code does not use vectorization since it isn't
available on long double precision type, and therefore the <code>R</code> level
function should be faster in most cases.
</p>
<p>Another difference is that the low level code uses double precision for the
calculations. This means that it is less prone to rounding errors. But this
also means that the two functions can sometimes require a different number
of iterations and function evaluations to reach the stop criteria. This
is shown in the examples.
</p>
<p>Another requirement in the current installment of this function is that the
series must have only a single maximum. This is the case for most discrete
probability distributions and marginalization problems. This limitation
will be addressed in the future.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+summed-objects">summed-objects()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precompiled">precompiled()</a></code> provides a list with precompiled functions
that can be used for the summation. <code><a href="#topic+infiniteSum">infiniteSum()</a></code> is a more
efficient algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define some function that is known to pass the ratio test.
param = 0.1
funfun &lt;- function(k, p) return(k * log1p(-p[1]))
result &lt;- infiniteSum_batches(funfun, parameters = param)

## This series is easy to verify analytically
TrueSum = -log(param)
TrueSum - result$sum
# Notice that it required 400 function evaluations for the approximation.
result$n

# If we use the C function, it reaches a lower error, but requires more
# iterations
result_C &lt;- infiniteSum_batches_C(funfun, parameters = param)
TrueSum - result_C$sum
result_C$n

## A common problem is finding the normalizing constant for the
## Conway-Maxwell-Poisson distribution. It has already been included
## in the precompiled list of functions.
comp_params = c(lambda = 5, nu = 3)
result &lt;- infiniteSum_batches("COMP", comp_params)
# With a specifically chosen argument value, the summation can be done with
# fewer iterations. But it is usually hard to know the ideal choice for
# applications beforehand
result$n
infiniteSum_batches("COMP", comp_params, batch_size = 11)$n
# A small batch_size ensures a small number of iterations, but slows the
# method due to multiple checking.
infiniteSum_batches("COMP", comp_params, batch_size = 2)$n
</code></pre>

<hr>
<h2 id='precompiled'>List of precompiled functions in the sumR package</h2><span id='topic+precompiled'></span>

<h3>Description</h3>

<p>More functions are periodically added to this list for convenience and speed.
These functions are all evaluated in the log scale and pass the ratio test,
that is, the limit of
a<sub>n+1</sub>/a<sub>n</sub> as n
goes to infinity is a value <code class="reqn">0 \le L &lt; 1</code>. The value of <code class="reqn">L</code> is
indicated in each entry. It is calculated automatically when the precompiled
functions are used in the summation.
</p>


<h3>Conway-Maxwell-Poisson normalizing constant</h3>

<p>This series is the kernel of the Conway-Maxwell-Poisson distribution, which
generalizes the Poisson and Geometric distributions. Its form is
</p>
<div style='text-align: center;'>a<sub>n</sub> = λ<sup>n</sup> / (n!)<sup>ν</sup></div> 
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">\lambda &gt; 0</code> and <code class="reqn">\nu &gt; 0</code>.
</p>
<p>When <code class="reqn">\nu = 1</code>, this series reduces to the Poisson distribution kernel
and the sum (in the log scale) is known to be <code class="reqn">\lambda</code>. When
<code class="reqn">\nu = 0</code> and <code class="reqn">0 &lt; \lambda &lt; 1</code>, the series reduces to the Geometric
distribution kernel with parameter <code class="reqn">1 - \lambda</code>. The series is known to
sum to <code class="reqn">1</code>. Finally, as <code class="reqn">\nu</code> goes to <code class="reqn">\infty</code> the distribution
approaches a Bernoulli distribution with parameter
<code class="reqn">\lambda / (1 - \lambda)</code>.
</p>
<p>Another known result is when <code class="reqn">\nu = 2</code>, in which case the sum is the
modified Bessel function of the first kind of order 0 evaluated at
<code class="reqn">2\sqrt{\lambda}</code>.
</p>

<ul>
<li><p> String to access the precompiled function: <code>"COMP"</code>.
</p>
</li>
<li><p> parameter vector: <code>c(lambda, nu)</code>.
</p>
</li></ul>



<h3>Double Poisson normalizing constant</h3>

<p>This series is the kernel of the double Poisson distribution, which is a
special case of the double exponential family, which extends it. Its form is
</p>
<p>GP8hIamkYKW8vjk522fKO6UJeQQQJDLi</p>
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">\lambda &gt; 0</code> and <code class="reqn">\phi &gt; 0</code>.
</p>
<p>When <code class="reqn">\phi = 1</code>, this series reduces to the Poisson distribution kernel
and the sum (in the log scale) is known to be 0.
</p>

<ul>
<li><p> String to acccess the precompiled function: <code>"double_poisson"</code>.
</p>
</li>
<li><p> parameter vector: <code>c(mu, phi)</code>
</p>
</li></ul>



<h3>Modified Bessel function of the first kind</h3>

<p>This is the series form solution for the function. There are more time
efficient methods for its evaluation however they don't guarantee good
approximations with large parameters. Its form is
</p>
<p>eIRg2OKn53IgRwNmD9X5651peTXEIwvW-1</p>
<p style="text-align: center;"><code class="reqn">L = 0, log(L) = -\infty,</code>
</p>

<p>for <code class="reqn">x &gt; 0</code> and <code class="reqn">\alpha</code> any real value.
</p>
<p>The modified Bessel function of the second kind can be obtained with
</p>
<div style='text-align: center;'> K<sub>α</sub>(x) = π / 2 (I<sub>-α</sub>(x) - I<sub>α</sub>(x)) / (sin α π)</div> 
<p>where <code class="reqn">I</code> represents the modified function of the first kind and <code class="reqn">K</code>
of the second kind. It is worth remembering the <code><a href="#topic+infiniteSum">infiniteSum()</a></code>
function returns the sum in the log scale, which must be adjusted for the
formula above.
</p>

<ul>
<li><p> String to access the precompiled function: <code>"bessel_I"</code>
</p>
</li>
<li><p> parameter vector: <code>c(x, alpha)</code>
</p>
</li></ul>



<h3>Modified Bessel function of the first kind with log argument</h3>

<p>This is the same function as the one above, except that parameter <code class="reqn">x</code> is
given in the log scale. This is provided for numerical stability. For the
cases where <code>x</code> is not very large, sums using this function and the
above should return the same sum.
</p>

<ul>
<li><p> String to access the precompiled function: <code>"bessel_I_logX"</code>
</p>
</li>
<li><p> parameter vector: <code>c(logx, alpha)</code>
</p>
</li></ul>



<h3>Note</h3>

<p>In some cases, the sum of the series is known in closed form for some
values of the parameters. The package function does not check for these cases
and just performs the approximation. If the exact value is desired by the
user when it is known, they must take responsibility for checking and
providing these values.
</p>
<p>Another important thing to note is that the precompiled functions perform all
calculations with twice the numerical precision than R. Therefore, in some
cases, there might be very small differences in the sum when comparing the
results of the function using the precompiled function and the same function
defined at the R level.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infiniteSum">infiniteSum()</a></code>, <code><a href="#topic+finiteSum">finiteSum()</a></code> and
<code><a href="#topic+infiniteSum_batches">infiniteSum_batches()</a></code>
</p>

<hr>
<h2 id='summed-objects'>S3 Class for objects containing iterated summations</h2><span id='topic+summed-objects'></span><span id='topic+print.summed'></span><span id='topic+as.double.summed'></span>

<h3>Description</h3>

<p>Contains the summations in the log scale. The value can either be an
approximation to an infinite series or a finite sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summed'
print(x, ...)

## S3 method for class 'summed'
as.double(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summed-objects_+3A_x">x</code></td>
<td>
<p>The <code>summed</code> object.</p>
</td></tr>
<tr><td><code id="summed-objects_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>print</code>: The invisible object.
</p>
<p>For <code>as.numeric</code>/<code>as.double</code>: The approximated sum.
</p>


<h3>Elements in the list</h3>


<dl>
<dt><code>sum</code></dt><dd><p>The resulting sum in the log scale.</p>
</dd>
<dt><code>n</code></dt><dd><p>The performed number of iterations. This value represents
the number of series elements evaluations performed during the summation.</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used for the summation.</p>
</dd>
<dt><code>maxReached</code></dt><dd><p><code>TRUE</code> or <code>FALSE</code>. Indicates whether the
maximum iterations was reached.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+infiniteSum">infiniteSum()</a></code>, <code><a href="#topic+infiniteSum_batches">infiniteSum_batches()</a></code> and
<code><a href="#topic+finiteSum">finiteSum()</a></code> for available methods.
</p>

<hr>
<h2 id='sumR'>sumR: Approximate series withing a desired error margin</h2><span id='topic+sumR'></span><span id='topic+sumR-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.jpeg" width="120" alt="logo.jpeg" />
</p>


<h3>Details</h3>

<p>The <span class="pkg">sumR</span> package provides some <code>R</code> functions that allow the
user to approximate the sum of series. It also interfaces the low level
<code>C</code> functions that perform the actual summation, so that other packages
can apply them to their own functions written in <code>C</code> or <code style="white-space: pre;">&#8288;C++&#8288;</code>. The
<a href="https://github.com/GuidoAMoreira/sumR">GitHub</a> page provides a short
tutorial on how to achieve this.
</p>
<p>The underlying code is under frequent revision for improvements in speed,
memory use and precision. As the need to implement other summation algorithms
arise, they will be added.
</p>
<p>The theoretical foundations for the approximations will be submitted to a
peer-reviewed journal shortly.
</p>


<h3>Author(s)</h3>

<p>Authors:
</p>

<ul>
<li><p>Guido A. Moreira
</p>
</li>
<li><p>Luiz Max Carvalho
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
