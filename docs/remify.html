<!DOCTYPE html><html><head><title>Help for package remify</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {remify}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#remify-package'><p>remify: Processing and Transforming Relational Event History Data</p></a></li>
<li><a href='#dim.remify'><p>dim.remify</p></a></li>
<li><a href='#getActorID'><p>getActorID</p></a></li>
<li><a href='#getActorName'><p>getActorName</p></a></li>
<li><a href='#getDyad'><p>getDyad</p></a></li>
<li><a href='#getDyadID'><p>getDyadID</p></a></li>
<li><a href='#getRiskset'><p>getRiskset</p></a></li>
<li><a href='#getTypeID'><p>getTypeID</p></a></li>
<li><a href='#getTypeName'><p>getTypeName</p></a></li>
<li><a href='#plot.remify'><p>plot.remify</p></a></li>
<li><a href='#print.remify'><p>print.remify</p></a></li>
<li><a href='#randomREH'><p>Random Relational Event History</p></a></li>
<li><a href='#randomREHsmall'><p>Random Relational Event History (small)</p></a></li>
<li><a href='#rehshape'><p>Transform processed remify objects to different formats</p></a></li>
<li><a href='#remify'><p>Process a Relational Event History</p></a></li>
<li><a href='#summary.remify'><p>summary.remify</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Processing and Transforming Relational Event History Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giuseppe Arena &lt;g.arena@tilburguniversity.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficiently processes relational event history data and transforms them into formats suitable for other packages. The primary objective of this package is to convert event history data into a format that integrates with the packages in 'remverse' and is compatible with various analytical tools (e.g., computing network statistics, estimating tie-oriented or actor-oriented social network models). Second, it can also transform the data into formats compatible with other packages out of 'remverse'. The package processes the data for two types of temporal social network models: tie-oriented modeling framework (Butts, C., 2008, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>&gt;) and actor-oriented modeling framework (Stadtfeld, C., &amp; Block, P., 2017, &lt;<a href="https://doi.org/10.15195%2Fv4.a14">doi:10.15195/v4.a14</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TilburgNetworkGroup/remify">https://github.com/TilburgNetworkGroup/remify</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TilburgNetworkGroup/remify/issues">https://github.com/TilburgNetworkGroup/remify/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8.3), igraph (&ge; 1.4.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 15:05:25 UTC; giuseppe</td>
</tr>
<tr>
<td>Author:</td>
<td>Giuseppe Arena <a href="https://orcid.org/0000-0001-5204-3326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rumana Lakdawala [ctb],
  Marlyne Meijerink-Bosman [ctb],
  Diana Karimova [ctb],
  Fabio Generoso Vieira [ctb],
  Mahdi Shafiee Kamalabad [ctb],
  Roger Leenders [ctb],
  Joris Mulder [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-16 02:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='remify-package'>remify: Processing and Transforming Relational Event History Data</h2><span id='topic+remify-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Efficiently processes relational event history data and transforms them into formats suitable for other packages. The primary objective of this package is to convert event history data into a format that integrates with the packages in 'remverse' and is compatible with various analytical tools (e.g., computing network statistics, estimating tie-oriented or actor-oriented social network models). Second, it can also transform the data into formats compatible with other packages out of 'remverse'. The package processes the data for two types of temporal social network models: tie-oriented modeling framework (Butts, C., 2008, <a href="https://doi.org/10.1111/j.1467-9531.2008.00203.x">doi:10.1111/j.1467-9531.2008.00203.x</a>) and actor-oriented modeling framework (Stadtfeld, C., &amp; Block, P., 2017, <a href="https://doi.org/10.15195/v4.a14">doi:10.15195/v4.a14</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Giuseppe Arena <a href="mailto:g.arena@tilburguniversity.edu">g.arena@tilburguniversity.edu</a> (<a href="https://orcid.org/0000-0001-5204-3326">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Rumana Lakdawala <a href="mailto:r.j.lakdawala@tilburguniversity.edu">r.j.lakdawala@tilburguniversity.edu</a> [contributor]
</p>
</li>
<li><p> Marlyne Meijerink-Bosman [contributor]
</p>
</li>
<li><p> Diana Karimova <a href="mailto:d.karimova@tilburguniversity.edu">d.karimova@tilburguniversity.edu</a> [contributor]
</p>
</li>
<li><p> Fabio Generoso Vieira <a href="mailto:f.v.generosovieira@tilburguniversity.edu">f.v.generosovieira@tilburguniversity.edu</a> [contributor]
</p>
</li>
<li><p> Mahdi Shafiee Kamalabad <a href="mailto:m.shafieekamalabad@uu.nl">m.shafieekamalabad@uu.nl</a> [contributor]
</p>
</li>
<li><p> Roger Leenders <a href="mailto:r.t.a.j.leenders@tilburguniversity.edu">r.t.a.j.leenders@tilburguniversity.edu</a> [contributor]
</p>
</li>
<li><p> Joris Mulder <a href="mailto:j.mulder3@tilburguniversity.edu">j.mulder3@tilburguniversity.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/TilburgNetworkGroup/remify">https://github.com/TilburgNetworkGroup/remify</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TilburgNetworkGroup/remify/issues">https://github.com/TilburgNetworkGroup/remify/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dim.remify'>dim.remify</h2><span id='topic+dim.remify'></span>

<h3>Description</h3>

<p>A function that returns the dimension of the temporal network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remify'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.remify_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of dimensions of the processed event sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREHsmall'
library(remify)
data(randomREHsmall)
reh &lt;- remify(edgelist = randomREHsmall$edgelist,
              model = "tie")

# dimensions of the processed 'remify' object
dim(reh)

</code></pre>

<hr>
<h2 id='getActorID'>getActorID</h2><span id='topic+getActorID'></span><span id='topic+getActorID.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of actor names returns the corresponding vector of ID's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getActorID(x, actorName = NULL)

## S3 method for class 'remify'
getActorID(x, actorName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getActorID_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getActorID_+3A_actorname">actorName</code></td>
<td>
<p>a vector of actor names. The same names in the input edgelist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>actor ID as integer value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getActorID(remify)</code>: return actor's ID from actor's name
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find actor ID from the actor name
getActorID(x = reh, actorName = c("Francesca","Kayla"))

</code></pre>

<hr>
<h2 id='getActorName'>getActorName</h2><span id='topic+getActorName'></span><span id='topic+getActorName.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of actor ID's returns the corresponding vector of actor (input) names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getActorName(x, actorID = NULL)

## S3 method for class 'remify'
getActorName(x, actorID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getActorName_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getActorName_+3A_actorid">actorID</code></td>
<td>
<p>a vector of actor ID's. The ID value can range between <code>1</code> and <code>N</code> (number of actors in the network).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of actors' names.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getActorName(remify)</code>: return actor's name from actor's ID
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find actor name from actor ID
getActorName(x = reh, actorID = c(1,2,8,12))

</code></pre>

<hr>
<h2 id='getDyad'>getDyad</h2><span id='topic+getDyad'></span><span id='topic+getDyad.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of one or more dyad ID's returns the corresponding dyad composition of &quot;actor1&quot;, &quot;actor2&quot; and &quot;type&quot; (if event types are present). The ID's to supply must range between 1 and D (largest risk set size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDyad(x, dyadID, active = FALSE)

## S3 method for class 'remify'
getDyad(x, dyadID, active = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDyad_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getDyad_+3A_dyadid">dyadID</code></td>
<td>
<p>a vector of one or more dyad ID's, each one ranging from 1 to D (largest risk set size).</p>
</td></tr>
<tr><td><code id="getDyad_+3A_active">active</code></td>
<td>
<p>logical, whether to consider the input <code>dyadID</code> as a vector of ID's of active dyads (<code>active = TRUE</code>) or dyads from the full risk set (<code>active = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with &quot;actor1&quot;, &quot;actor2&quot; and &quot;type&quot; names corresponding to the vector <code>dyadID</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getDyad(remify)</code>: return dyad composition in actor1, actor2 and type from one (or more) dyad ID
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find dyad composition (names of actor1, actor2 and type) from the dyad ID
getDyad(x = reh, dyadID = c(450,239,900))

</code></pre>

<hr>
<h2 id='getDyadID'>getDyadID</h2><span id='topic+getDyadID'></span><span id='topic+getDyadID.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of names as to actor1, actor2 and type returns the corresponding dyad ID. The names to supply are the original input names of the edgelist before the processing via the function <code>remify::remify()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDyadID(x, actor1, actor2, type)

## S3 method for class 'remify'
getDyadID(x, actor1, actor2, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDyadID_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getDyadID_+3A_actor1">actor1</code></td>
<td>
<p>[character] name of actor1.</p>
</td></tr>
<tr><td><code id="getDyadID_+3A_actor2">actor2</code></td>
<td>
<p>[character] name of actor2.</p>
</td></tr>
<tr><td><code id="getDyadID_+3A_type">type</code></td>
<td>
<p>[character] name of type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dyad ID as integer value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getDyadID(remify)</code>: return dyad's ID from dyad's composition
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find dyad ID from dyad composition (names of actor1, actor2 and type)
getDyadID(x = reh, actor1 = "Francesca", actor2 = "Kayla", type = "conflict")

</code></pre>

<hr>
<h2 id='getRiskset'>getRiskset</h2><span id='topic+getRiskset'></span><span id='topic+getRiskset.remify'></span>

<h3>Description</h3>

<p>This function returns the processed risk set changes specified by the input 'omit_dyad'. In such a matrix: value 1 refers to the dyads in the risk set, and 0 otherwise (dyads excluded from the risk set). All the possible risk set modifications are described by row, and the columns identify the dyads. Note: This matrix is the output given by processing the input 'omit_dyad', and the number of rows might be equal to or higher than the number of objects in 'omit_dyad'. This might happen because more than one modification of the risk set defined in the input could overlap over time with others. For more details about how the risk set is processed, see <code>vignette(package="remify",topic="riskset")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRiskset(x)

## S3 method for class 'remify'
getRiskset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRiskset_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of objects describing the processed the risk set.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getRiskset(remify)</code>: manual riskset object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# structure of the processed risk set
str(getRiskset(reh))

</code></pre>

<hr>
<h2 id='getTypeID'>getTypeID</h2><span id='topic+getTypeID'></span><span id='topic+getTypeID.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of type names returns the corresponding vector of ID's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTypeID(x, typeName = NULL)

## S3 method for class 'remify'
getTypeID(x, typeName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTypeID_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getTypeID_+3A_typename">typeName</code></td>
<td>
<p>a vector of type names. The same names in the input edgelist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>type ID as integer value.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getTypeID(remify)</code>: return type's ID from type's name
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find type ID from the type name
getTypeID(x = reh, typeName = c("conflict","cooperation"))

</code></pre>

<hr>
<h2 id='getTypeName'>getTypeName</h2><span id='topic+getTypeName'></span><span id='topic+getTypeName.remify'></span>

<h3>Description</h3>

<p>A function that given a vector of type ID's returns the corresponding vector of type (input) names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTypeName(x, typeID = NULL)

## S3 method for class 'remify'
getTypeName(x, typeID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTypeName_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="getTypeName_+3A_typeid">typeID</code></td>
<td>
<p>a vector of type ID's. The ID value can range between <code>1</code> and <code>C</code> (number of event types in the network).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of types' names.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getTypeName(remify)</code>: return type's name from type's ID
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# find type name from type ID
getTypeName(x = reh, typeID = c(1,3))

</code></pre>

<hr>
<h2 id='plot.remify'>plot.remify</h2><span id='topic+plot.remify'></span>

<h3>Description</h3>

<p>several plots that describe the network of relational events, both for directed and undirected relational events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remify'
plot(
  x,
  which = c(1:5),
  breaks = 15L,
  palette = "Purples",
  n_intervals = 4L,
  rev = TRUE,
  actors = attr(x, "dictionary")$actors$actorName,
  pch.degree = 20,
  igraph.edge.color = "#4daa89",
  igraph.vertex.color = "#5AAFC8",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.remify_+3A_x">x</code></td>
<td>
<p>is a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_which">which</code></td>
<td>
<p>one or more numbers between 1 and 5. Plots described in order: (1) distribution of the inter-event times (histogram), (2) tile plot titled 'activity plot', with in-degree and out-degree activity line plots on the sides (or total-degree on the top side if the network is undirected). Tiles' color is scaled based on the count of the directed (or undirected) dyad, (3) for directed networks two plots of normalized out-degree and in-degree (values ranging in [0,1]) over a set of <code>n_intervals</code> (evenly spaced). For undirected networks one plot of normalized total-degree over the <code>n_intervals</code> (also here values ranging in [0,1]). The normalization is calculated in each interval as the <code>(degree-min(degree))/(max(degree)-min(degree)))</code> for each actor considering minimum and maximum degree (in-, out- or total-) observed in the interval (opacity and size of the points is proportional to the normalized measure), (4) four plots: (i) number of events (# events) per time interval, (ii) proportion of observed dyads (# dyads / x$D) per time interval, (iii) and (iv) (for directed network only) proportion of active senders and receivers per time interval (calculated as # senders/ x$N and # receiver/x$N per interval), (5) two networks: (i) network of events where edges are considered undirected (edges' opacity is proportional to the counts of the undirected events, vertices' opacity is proportional to the total-degree of the actors), (ii) visualization of directed network (edges' opacity is proportional to the counts of the directed events, vertices' opacity is proportional to the in-degree of the actors).</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_breaks">breaks</code></td>
<td>
<p>default is <code>15L</code> and it describes the number of cells of the histogram plot for the inter-event times. It  can be specified in the same way as the argument used by the function <code>graphics::hist()</code> (see ?graphics::hist for more details).</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_palette">palette</code></td>
<td>
<p>a palette from <code>grDevices::hcl.pals()</code> (default is the <code>"Purples"</code> palette).</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_n_intervals">n_intervals</code></td>
<td>
<p>number of time intervals for time plots (default is <code>10</code>).</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_rev">rev</code></td>
<td>
<p>default is TRUE (reverse order of the color specified in <code>palette</code>)</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_actors">actors</code></td>
<td>
<p>default is the set of actors in the network (see <code>attr(x,"dictionary")[["actors"]]</code>). The user can specify a subset of actors on which to run the descriptive plots. If the set contains more than 50 actors, then the function will select the 50 most active actors from the set provided.</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_pch.degree">pch.degree</code></td>
<td>
<p>default is 20. Shape of the points for the degree plots (in-degree, out-degree, total-degree).</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_igraph.edge.color">igraph.edge.color</code></td>
<td>
<p>color of the edges in visualization of the network with vertices and nodes. The user can specify the hex value of a color, the color name or use the function<code>grDevices::rgb()</code> which returns the hex value.</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_igraph.vertex.color">igraph.vertex.color</code></td>
<td>
<p>color of the vertices in visualization of the network with vertices and nodes. The user can specify the hex value of a color, the color name or use the function <code>grDevices::rgb()</code> which returns the hex value.</p>
</td></tr>
<tr><td><code id="plot.remify_+3A_...">...</code></td>
<td>
<p>other graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic plot method
</p>


<h3>Value</h3>

<p>no return value, called for plotting descriptives on the relational event history data.
</p>

<hr>
<h2 id='print.remify'>print.remify</h2><span id='topic+print.remify'></span>

<h3>Description</h3>

<p>print a summary of the event history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remify'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.remify_+3A_x">x</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="print.remify_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>displays the same information provided by the summary method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# processing the random network 'randomREHsmall'
library(remify)
data(randomREHsmall)
reh &lt;- remify(edgelist = randomREHsmall$edgelist,
              model = "tie")

# printing a summary of the processed 'remify' object
print(reh)

</code></pre>

<hr>
<h2 id='randomREH'>Random Relational Event History</h2><span id='topic+randomREH'></span>

<h3>Description</h3>

<p>A randomly generated sequence of relational events with 20 actors and 9915 events. Each event type is associated to one of the three following sentiments: <em>conflict</em>, <em>competition</em> and <em>cooperation</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomREH
</code></pre>


<h3>Format</h3>

<p><code>data(randomREH)</code> will load a list containing following objects:
</p>

<dl>
<dt><code>edgelist</code></dt><dd><p>a <code>data.frame</code> that contains the random sequence of events. Columns of the edgelist are:
</p>

<dl>
<dt><code>time</code></dt><dd><p>the timestamp indicating the time at which each event occurred;</p>
</dd>
<dt><code>actor1</code></dt><dd><p>the name of the actor that generated the relational event;</p>
</dd>
<dt><code>actor2</code></dt><dd><p>the name of the actor that received the relational event;</p>
</dd>
<dt><code>type</code></dt><dd><p>the type of the relational event.</p>
</dd>
</dl>

</dd>
<dt><code>actors</code></dt><dd><p>names of actors interacting in the dynamic network.</p>
</dd>
<dt><code>types</code></dt><dd><p>names of event types observed in the network and describing the sentiment of the interaction (<em>conflict</em>, <em>competition</em> and <em>cooperation</em>).</p>
</dd>
<dt><code>origin</code></dt><dd><p>starting time point (<code>t_0</code>) prior to the first observed event (<code>t_1</code>), the class of this object must be the same as the one of the time column in the edgelist.</p>
</dd>
<dt><code>omit_dyad</code></dt><dd><p>a list where each element describes an alteration of the riskset which takes place at specific time points and for certain actors and/or types.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(randomREH)

# actors names
randomREH$actors

# types names
randomREH$types

# looking into the first modification of the riskset: omit_dyad[[1]]
## the data.frame `dyad` specifies which dyads will be omitted from the riskset 
## (all the dyads that expressed a `conflict` between actor won't be part of the riskset):
randomREH$omit_dyad[[1]]$dyad 

## the vector `time` specifies the time points when this exclusion takes place 
head(randomREH$omit_dyad[[1]]$time) # (printing out only the first 10 time points)

# run the preprocessing function reh() by supplying the loaded objects.
edgelist_reh &lt;- remify(edgelist = randomREH$edgelist,
                    actors = randomREH$actors,
                    types = randomREH$types, 
                    directed = TRUE,
                    ordinal = FALSE,
                    origin = randomREH$origin,
                    omit_dyad = randomREH$omit_dyad,
                    model = "tie")

# `edgelist_reh` is an object of class `reh`
class(edgelist_reh)

# names of objects inside `edgelist_reh`
names(edgelist_reh)

</code></pre>

<hr>
<h2 id='randomREHsmall'>Random Relational Event History (small)</h2><span id='topic+randomREHsmall'></span>

<h3>Description</h3>

<p>A subset from the randomly generated sequence of relational events 'randomREH', with 5 actors and 586 events (without event types).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomREHsmall
</code></pre>


<h3>Format</h3>

<p><code>data(randomREHsmall)</code> will load a list containing following objects:
</p>

<dl>
<dt><code>edgelist</code></dt><dd><p>a <code>data.frame</code> that contains the random sequence of events. Columns of the edgelist are:
</p>

<dl>
<dt><code>time</code></dt><dd><p>the timestamp indicating the time at which each event occurred;</p>
</dd>
<dt><code>actor1</code></dt><dd><p>the name of the actor that generated the relational event;</p>
</dd>
<dt><code>actor2</code></dt><dd><p>the name of the actor that received the relational event;</p>
</dd>
</dl>

</dd>
<dt><code>actors</code></dt><dd><p>names of actors interacting in the dynamic network.</p>
</dd>
<dt><code>origin</code></dt><dd><p>starting time point (<code>t_0</code>) prior to the first observed event (<code>t_1</code>), the class of this object must be the same as the one of the time column in the edgelist.</p>
</dd>
<dt><code>omit_dyad</code></dt><dd><p>a list where each element describes an alteration of the riskset which takes place at specific time points and for certain actors and/or types.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(randomREHsmall)

# actors names
randomREHsmall$actors

# types names
randomREHsmall$types


# run the preprocessing function reh() by supplying the loaded objects.
small_edgelist_reh &lt;- remify(edgelist = randomREHsmall$edgelist,
                    actors = randomREHsmall$actors,
                    directed = TRUE,
                    ordinal = FALSE,
                    origin = randomREHsmall$origin,
                    omit_dyad = randomREHsmall$omit_dyad,
                    model = "tie")

# `small_edgelist_reh` is an object of class `reh`
class(small_edgelist_reh)

# names of objects inside `small_edgelist_reh`
names(small_edgelist_reh)

</code></pre>

<hr>
<h2 id='rehshape'>Transform processed remify objects to different formats</h2><span id='topic+rehshape'></span>

<h3>Description</h3>

<p>A function that transforms a <code>remify</code> object into one of the possible formats that suit external packages. The function can convert, at the moment, the data structure from an object of class <code>remify</code> to a data structure required by the function <code>relevent::rem()</code> or by the function <code>relevent::rem.dyad()</code> from the '<a href="https://CRAN.R-project.org/package=relevent">relevent</a>' package (Butts, C.T. 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rehshape(
  data,
  output_format = c("relevent-rem", "relevent-rem.dyad"),
  ncores = 1L,
  optional_arguments = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rehshape_+3A_data">data</code></td>
<td>
<p>an object of class 'remify' (see function <code>remify::remify()</code>).</p>
</td></tr>
<tr><td><code id="rehshape_+3A_output_format">output_format</code></td>
<td>
<p>a character indicating the output format which the input data has to be converted to. It can assume two values: <code>"relevent-rem"</code> , <code>"relevent-rem.dyad"</code>. Default value is <code>"relevent-rem"</code>.</p>
</td></tr>
<tr><td><code id="rehshape_+3A_ncores">ncores</code></td>
<td>
<p>number of cores used to parallelize internal algorithms</p>
</td></tr>
<tr><td><code id="rehshape_+3A_optional_arguments">optional_arguments</code></td>
<td>
<p>vector of arguments names from relevent::rem or relevent::rem.dyad() that the user might want to process and have in the output object of rehshape (e.g., the pre-computed structures required by relevent::rem.dyad)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class specified in the <code>output_format</code> argument. The output class object 'relevent-rem' contains a list of objects named after the arguments of the function <code>relevent::rem()</code>: 'eventlist' (mandatory), 'supplist' (optional), 'timing'(mandatory). The output class object 'relevent-rem.dyad' contains a list of objects named after the arguments of the function <code>relevent::rem.dyad()</code>: 'edgelist' (mandatory), 'n' (mandatory), 'ordinal'(optional).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREH'
library(remify)
data(randomREH)
reh &lt;- remify(edgelist = randomREH$edgelist,
              model = "tie",
              riskset = "manual",
              omit_dyad = randomREH$omit_dyad)

# convert 'remify' object to output_format = "relevent-rem"
relevent_rem_obj &lt;- rehshape(data = reh, output_format = "relevent-rem")

str(relevent_rem_obj) 

# convert 'remify' object to output_format = "relevent-rem.dyad"
relevent_rem.dyad_obj &lt;- rehshape(data = reh, output_format = "relevent-rem.dyad")

summary(relevent_rem.dyad_obj)

</code></pre>

<hr>
<h2 id='remify'>Process a Relational Event History</h2><span id='topic+remify'></span>

<h3>Description</h3>

<p>A function that processes raw relational event history data and returns a S3 object of class 'remify' which is used as input in other functions inside 'remverse'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remify(
  edgelist,
  directed = TRUE,
  ordinal = FALSE,
  model = c("tie", "actor"),
  actors = NULL,
  types = NULL,
  riskset = c("full", "active", "manual"),
  origin = NULL,
  omit_dyad = NULL,
  ncores = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remify_+3A_edgelist">edgelist</code></td>
<td>
<p>the relational event history. An object of class <code><a href="base.html#topic+data.frame">data.frame</a></code> with first three columns corresponding to time, and actors forming the dyad. The first three columns will be re-named &quot;time&quot;, &quot;actor1&quot;, &quot;actor2&quot; (where, for directed networks, &quot;actor1&quot; corresponds to the sender and &quot;actor2&quot; to the receiver of the relational event). Optional columns that can be supplied are: 'type' and 'weight'. If one or both exist in <code>edgelist</code>, they have to be named accordingly.</p>
</td></tr>
<tr><td><code id="remify_+3A_directed">directed</code></td>
<td>
<p>logical value indicating whether events are directed (<code>TRUE</code>) or undirected (<code>FALSE</code>). (default value is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="remify_+3A_ordinal">ordinal</code></td>
<td>
<p>logical value indicating whether only the order of events matters in the model (<code>TRUE</code>) or also the waiting time must be considered in the model (<code>FALSE</code>). (default value is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="remify_+3A_model">model</code></td>
<td>
<p>can be &quot;tie&quot; or &quot;actor&quot; oriented modeling. This argument plays a fundamental role when <code>omit_dyad</code> is supplied. Indeed, when actor-oriented modeling, the dynamic risk set will consist of two risk sets objects (senders' and dyads' risk sets). In the tie-oriented model the function will return a dynamic risk set referred at a dyad-level.</p>
</td></tr>
<tr><td><code id="remify_+3A_actors">actors</code></td>
<td>
<p>[<em>optional</em>] character vector of actors' names that may be observed interacting in the network. If <code>NULL</code> (default), actors' names will be taken from the input edgelist.</p>
</td></tr>
<tr><td><code id="remify_+3A_types">types</code></td>
<td>
<p>[<em>optional</em>] character vector of event types that may occur in the network. If <code>NULL</code> (default), types' names will be taken from the input edgelist.</p>
</td></tr>
<tr><td><code id="remify_+3A_riskset">riskset</code></td>
<td>
<p>[<em>optional</em>] character value indicating the type of risk set to process: <code>riskset = "full"</code> (default) consists of all the possible dyadic events given the number of actors (and the number of event types) and it mantains the same structure over time. <code>riskset = "active"</code> considers at risk only the observed dyads and it mantains the same structure over time. <code>riskset = "manual"</code>, allows the risk set to have a structure that is user-defined, and it is based on the instructions supplied via the argument <code>omit_dyad</code>. This type of risk set allows for time-varying risk set, in which, for instance, subset of actors can interact only at specific time windows, or events of a specific type (sentiment) can't be observed within time intervals that are defined by the user.</p>
</td></tr>
<tr><td><code id="remify_+3A_origin">origin</code></td>
<td>
<p>[<em>optional</em>] starting time point of the observaton period (default is <code>NULL</code>). If it is supplied, it must have the same class of the 'time' column in the input <code>edgelist</code>.</p>
</td></tr>
<tr><td><code id="remify_+3A_omit_dyad">omit_dyad</code></td>
<td>
<p>[<em>optional</em>] list of lists. Each list refers to one risk set modification and must have two objects: a first object named 'time', that is a vector of two values defining the first and last time point of the time window where to apply the change to the risk set and a second object, named 'dyad', which is a <code><a href="base.html#topic+data.frame">data.frame</a></code> where dyads to be removed are supplied in the format <code>actor1,actor2,type</code> (by row). The <code>NA</code> value can be used to remove multiple objects from the risk set at once with one risk set modification list (see Details).</p>
</td></tr>
<tr><td><code id="remify_+3A_ncores">ncores</code></td>
<td>
<p>[<em>optional</em>] number of cores used in the parallelization of the processing functions. (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>omit_dyad</code>, the <code>NA</code> value can be used to remove multiple objects from the risk set at once with one risk set modification list. For example, to remove all events with sender equal to actor “A” add a list with two objects <code>time = c(NA, NA)</code> and <code>dyad = data.frame(actor1 = A, actor2 = NA, type = NA)</code> to the <code>omit_dyad</code> list. For more details about
</p>


<h3>Value</h3>

<p>'remify' S3 object, list of: number of events ('M'), number of actors ('N'), number of event types (if present, 'C'), number of dyads ('D', and also 'activeD' if 'riskset=&quot;active&quot;'), vector of inter-event times (waiting times between two subsequent events), processed input edgelist as 'data.frame', processed 'omit_dyad' object as 'list'. The function returns also several attributes that make efficient the processing of the data for future analysis. For more details about the function, input arguments, output, attributes and methods, please read <code>vignette(package="remify",topic="remify")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load package and random network 'randomREH'
library(remify)
data(randomREH)

# first events in the sequence
head(randomREH$edgelist)

# actor's names
randomREH$actors

# event type's names
randomREH$types

# start time of the study (origin)
randomREH$origin

# list of changes of the risk set: each one is a list of:
# 'time' (indicating the time window where to apply the risk set reduction)
# 'dyad' (a data.frame describing the dyads to remove from the risk set 
# during the time window specified in 'time')
str(randomREH$omit_dyad)

# -------------------------------------- #
#  processing for tie-oriented modeling  #
# -------------------------------------- #

tie_randomREH &lt;- remify(edgelist = randomREH$edgelist,
       directed = TRUE,
       ordinal = FALSE,
       model = "tie",
       actors = randomREH$actors,
       types = randomREH$types,
       riskset = "manual",
       origin = randomREH$origin,
       omit_dyad = randomREH$omit_dyad)

# summary
summary(tie_randomREH)

# dimensions of the processed network
dim(tie_randomREH)

# Which ID is assigned to the actors with names "Francesca" and "Kayla"?
getActorID(x = tie_randomREH, actorName = c("Francesca","Kayla"))

# Which ID is assigned to the event type "conflict"?
getTypeID(x = tie_randomREH, typeName = "conflict")

# Find dyad composition (names of actor1, actor2 and type) from the dyad ID: c(1,380,760,1140)
getDyad(x = tie_randomREH, dyadID = c(1,380,760,1140))

# visualize descriptive measures of relational event data
# plot(x = tie_randomREH)

# -------------------------------------- #
# processing for actor-oriented modeling #
# -------------------------------------- #

# loading network 'randomREHsmall'
data(randomREHsmall)

# processing small random network
actor_randomREH &lt;- remify(edgelist = randomREHsmall$edgelist,
       directed = TRUE,
       ordinal = FALSE,
       model = "actor",
       actors = randomREHsmall$actors,
       origin = randomREHsmall$origin)
       
# summary
summary(actor_randomREH)

# dimensions of the processed network
dim(actor_randomREH)

# ------------------------------------ #
# for more information about remify()  #
# check: vignette(package="remify")    #
# ------------------------------------ #
 
</code></pre>

<hr>
<h2 id='summary.remify'>summary.remify</h2><span id='topic+summary.remify'></span>

<h3>Description</h3>

<p>A function that returns a easy-to-read summary of the main characteristics as to the processed relational event sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remify'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.remify_+3A_object">object</code></td>
<td>
<p>a <code>remify</code> object.</p>
</td></tr>
<tr><td><code id="summary.remify_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints out the main characteristics of the processed relational event sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# processing the random network 'randomREHsmall'
library(remify)
data(randomREHsmall)
reh &lt;- remify(edgelist = randomREHsmall$edgelist,
              model = "tie")

# printing a summary of the processed 'remify' object
summary(reh)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
