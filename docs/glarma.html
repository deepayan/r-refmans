<!DOCTYPE html><html><head><title>Help for package glarma</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glarma}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Asthma'><p>Daily Presentations of Asthma at Campbelltown Hospital</p></a></li>
<li><a href='#coef.glarma'><p>Extract GLARMA Model Coefficients</p></a></li>
<li><a href='#DriverDeaths'><p>Single Vehicle Nighttime Driver Deaths in Utah</p></a></li>
<li><a href='#extractAIC.glarma'><p>Extract AIC from a GLARMA Model</p></a></li>
<li><a href='#fitted.glarma'><p>Extract GLARMA Model Fitted Values</p></a></li>
<li><a href='#forecast'>
<p>Forecasting GLARMA time series</p></a></li>
<li><a href='#glarma'><p>Generalized Linear Autoregressive Moving Average Models with</p>
Various Distributions</a></li>
<li><a href='#initial'><p>Initial Parameter Generator for GLARMA from GLM</p></a></li>
<li><a href='#likTests'>
<p>Likelihood Ratio Test and Wald Test for <code>GLARMA</code> Fit</p></a></li>
<li><a href='#logLik.glarma'><p>Extract Log-Likelihood from GLARMA Models</p></a></li>
<li><a href='#model.frame.glarma'><p>Extracting the Model Frame of the GLARMA Model</p></a></li>
<li><a href='#mySolve'><p>Matrix Inversion of the Hessian of the Log-Likelihood</p></a></li>
<li><a href='#nobs.glarma'><p>Extract the Number of Observations from a GLARMA Model Fit</p></a></li>
<li><a href='#normRandPIT'>
<p>Random normal probability integral transformation</p></a></li>
<li><a href='#OxBoatRace'><p>Oxford-Cambridge Boat Race</p></a></li>
<li><a href='#paramGen'><p>Parameter Generators</p></a></li>
<li><a href='#PIT'><p>Non-randomized Probability Integral Transformation</p></a></li>
<li><a href='#plot.glarma'><p>Plot Diagnostics for a <code>glarma</code> Object</p></a></li>
<li><a href='#plotPIT'>
<p>PIT Plots for a <code>glarma</code> Object</p></a></li>
<li><a href='#Polio'><p>Cases of Poliomyelitis in the U.S.</p></a></li>
<li><a href='#residuals.glarma'><p>Extract GLARMA Model Residuals</p></a></li>
<li><a href='#RobberyConvict'>
<p>Court Convictions for Armed Robbery in New South Wales</p></a></li>
<li><a href='#summary.glarma'><p>Summarize GLARMA Fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Autoregressive Moving Average Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-07</td>
</tr>
<tr>
<td>Author:</td>
<td>William T.M. Dunsmuir &lt;w.dunsmuir@unsw.edu.au&gt;, Cenanning Li
	&lt;cli113@aucklanduni.ac.nz&gt;, and David J. Scott
	&lt;d.scott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"William T.M. Dunsmuir" &lt;w.dunsmuir@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, knitr, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided for estimation, testing, diagnostic checking and forecasting of generalized linear autoregressive moving average (GLARMA) models for discrete valued time series with regression variables.  These are a class of observation driven non-linear non-Gaussian state space models. The state vector consists of a linear regression component plus an observation driven component consisting of an autoregressive-moving average (ARMA) filter of past predictive residuals. Currently three distributions (Poisson, negative binomial and binomial) can be used for the response series. Three options (Pearson, score-type and unscaled) for the residuals in the observation driven component are available. Estimation is via maximum likelihood (conditional on initializing values for the ARMA process) optimized using Fisher scoring or Newton Raphson iterative methods. Likelihood ratio and Wald tests for the observation driven component allow testing for serial dependence in generalized linear model settings. Graphical diagnostics including model fits, autocorrelation functions and probability integral transform residuals are included in the package. Several standard data sets are included in the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-07 03:40:49 UTC; dsco036</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-07 04:26:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='Asthma'>Daily Presentations of Asthma at Campbelltown Hospital</h2><span id='topic+Asthma'></span>

<h3>Description</h3>

<p>The data arose from a single hospital (at Campbelltown) as part of a
larger (ongoing) study into the relationship between atmospheric
pollution and the number of asthma cases presenting themselves to
various emergency departments in local hospitals in the South West
region of Sydney, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Asthma)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">

  [, 1]</td><td style="text-align: left;"> Count </td><td style="text-align: left;"> Daily counts of asthma at Campbelltown
  Hospital.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 2]</td><td style="text-align: left;"> Intercept </td><td style="text-align: left;"> A vector of ones, providing the intercept in
  the model.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 3]</td><td style="text-align: left;"> Sunday </td><td style="text-align: left;"> Takes value one for Sundays, otherwise
  zero.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 4]</td><td style="text-align: left;"> Monday </td><td style="text-align: left;"> Takes value one for Mondays, otherwise
  zero.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 5]</td><td style="text-align: left;"> CosAnnual </td><td style="text-align: left;"> cos((2*pi*t)/365), annual cosine term.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 6]</td><td style="text-align: left;"> SinAnnual </td><td style="text-align: left;"> sin((2*pi*t)/365), annual sine term.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 7]</td><td style="text-align: left;"> H7 </td><td style="text-align: left;"> Scaled lagged and smoothed humidity variable. </td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 8]</td><td style="text-align: left;"> NO2max </td><td style="text-align: left;"> Maximum daily nitrogen dioxide.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 9:16] </td><td style="text-align: left;"> T1.1990 - T2.1993 </td><td style="text-align: left;"> Smooth shapes to capture school
  terms in each year.</td>
</tr>
<tr>
 <td style="text-align: right;">

 </td>
</tr>

</table>



<h3>Source</h3>

<p>Davis, Richard A and Dunsmuir, William TM and Streett, Sarah B (2003)
Observation-driven models for Poisson counts. <em>Biometrika</em>,
<b>90</b>, 777&ndash;790.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with asthma data
data(Asthma)
y &lt;- Asthma[,1]
X &lt;- as.matrix(Asthma[,2:16])

## Model in Davis, Dunsmuir and Streett (2003)

## MA(7) specification - see Davis, Dunsmuir and Streett (2003)

## Pearson Residuals, Fisher Scoring
glarmamod &lt;- glarma(y, X, thetaLags = 7, type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

likTests(glarmamod)
plot.glarma(glarmamod)

## Not run: 
## Example is specified as \dontrun because it takes too long
## for package inclusion on CRAN

## Pearson Residuals, Newton Raphson, Negative Binomial
## Initial value of the shape parameter take to be zero
glarmamod &lt;- glarma(y, X, thetaLags = 7, type = "NegBin", method = "NR",
                    residuals = "Pearson", alphaInit = 0,
                    maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

likTests(glarmamod)
plot.glarma(glarmamod)

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.glarma'>Extract GLARMA Model Coefficients</h2><span id='topic+coef.glarma'></span><span id='topic+coefficients.glarma'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts GLARMA model coefficients
from objects returned by modeling functions. <code>coefficients</code> is an alias
for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
coef(object, types = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="coef.glarma_+3A_types">types</code></td>
<td>
<p>Character; which coefficients to extract, either
<code>ARMA</code>), <code>beta</code>, <code>NB</code> or <code>all</code>. The default is
<code>all</code>.</p>
</td></tr>
<tr><td><code id="coef.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>This is an S3 generic function. <code>coef</code> or <code>coefficients</code>
return the requested coefficients from the object of class
<code>"glarma"</code>. By changing the argument <code>type</code>, either the ARMA
coefficients (<code>ARMA</code>), regression coefficients (<code>beta</code>) or
all coefficients are returned. In the case of negative binomial
counts, the negative binomial coefficient <code class="reqn">\alpha</code> is also
returned if type is <code>all</code>, or if type is <code>NB</code>. The default
is <code>all</code>.
</p>


<h3>Value</h3>

 
<p><code>ARMA</code> coefficients, <code>beta</code> coefficients, <code>NB</code>
coefficients or all of these three types of coefficients are extracted
from the <code>glarma</code> model object <code>object</code>.
</p>
<p>A named numeric vector or list of named numeric vectors is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.glarma">fitted.glarma</a></code> and <code><a href="#topic+residuals.glarma">residuals.glarma</a></code> for
related methods;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Polio)
Y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(Y, X, thetaLags = c(1, 2, 5), type = "Poi",
                    method = "FS", residuals= "Pearson",
                    maxit = 100, grad = 1e-6)

coef(glarmamod, type = "ARMA")
coef(glarmamod, type = "beta")
coef(glarmamod, type = "all")
</code></pre>

<hr>
<h2 id='DriverDeaths'>Single Vehicle Nighttime Driver Deaths in Utah</h2><span id='topic+DriverDeaths'></span>

<h3>Description</h3>

<p>This data set gives the number of single vehicle nighttime
driver deaths in the state of Utah by month over the period August
1980 to July 1986, along with observations on a number of possible
predictors. The aim of the study from which it was taken was to
investigate the effect of the lowering of the legal blood alcohol
concentration (BAC) while driving, from 0.1 to 0.08 units, and the
simultaneous introduction of administrative license revocation. The
time period for the observations is centred on the month of the
intervention, August 1983.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DriverDeaths)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">

  [, 1]</td><td style="text-align: left;"> Deaths </td><td style="text-align: left;"> Number of single vehicle nighttime driver deaths
  monthly.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 2]</td><td style="text-align: left;"> Intercept </td><td style="text-align: left;"> A vector of ones, providing the intercept in
  the model.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 3]</td><td style="text-align: left;"> ReducedBAC </td><td style="text-align: left;"> Indicator of before or after lowering of
  legal blood alcohol level.0 for months prior to August 1983, 1 for
  months on or after August 1983.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 4]</td><td style="text-align: left;"> FriSat </td><td style="text-align: left;"> Number of Friday and Saturday nights in the month.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 5]</td><td style="text-align: left;"> lnOMVDRate </td><td style="text-align: left;"> Log of the number of other motor vehicle
  deaths per 100,000 of population.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 6]</td><td style="text-align: left;"> Population </td><td style="text-align: left;"> Adult population of the State of Utah.</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Source</h3>

<p>Debra H. Bernat, William T.M. Dunsmuir, and Alexander C. Wagenaar (2004)
Effects of lowering the legal BAC to 0.08 on single-vehicle-nighttime
fatal traffic crashes in 19 jurisdictions. <em>Accident Analysis
&amp; Prevention</em>, <b>36</b>, 1089&ndash;1097.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Model number of deaths
data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Offset included
glarmamodOffset &lt;- glarma(y, X, offset = log(Population/100000),
                          phiLags = c(12),
                          type = "Poi", method = "FS",
                          residuals = "Pearson", maxit = 100, grad = 1e-6)
print(summary(glarmamodOffset))
par(mfrow =c(3,2))
plot(glarmamodOffset)


### No offset included
glarmamodNoOffset &lt;- glarma(y, X, phiLags = c(12),
                            type = "Poi", method = "FS",
                            residuals = "Pearson", maxit = 100, grad = 1e-6)
print(summary(glarmamodNoOffset))
par(mfrow=c(3,2))
plot(glarmamodNoOffset)
</code></pre>

<hr>
<h2 id='extractAIC.glarma'>Extract AIC from a GLARMA Model</h2><span id='topic+extractAIC.glarma'></span>

<h3>Description</h3>

<p><code>extractAIC</code> method for class <code>"glarma"</code>. Used to
extract AIC from a <code>glarma</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
extractAIC(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAIC.glarma_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call to
<code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="extractAIC.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC extracted from <code>object</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.glarma">coef.glarma</a></code>, <code><a href="#topic+residuals.glarma">residuals.glarma</a></code>,
<code><a href="#topic+glarma">glarma</a></code>.
</p>

<hr>
<h2 id='fitted.glarma'>Extract GLARMA Model Fitted Values</h2><span id='topic+fitted.glarma'></span><span id='topic+fitted.values.glarma'></span>

<h3>Description</h3>

<p><code>fitted</code>  method for class <code>"glarma"</code>. <code>fitted.values</code>
is an alias for <code>fitted</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a
call to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic function. <code>fitted</code> or <code>fitted.values</code>
return the required fitted values from an object of class
<code>"glarma"</code>.
</p>


<h3>Value</h3>

<p>Fitted values <code>mu</code> extracted from the object <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.glarma">coef.glarma</a></code>, <code><a href="#topic+residuals.glarma">residuals.glarma</a></code>,
<code><a href="#topic+glarma">glarma</a></code>.
</p>

<hr>
<h2 id='forecast'>
Forecasting GLARMA time series
</h2><span id='topic+forecast'></span><span id='topic+forecast.glarma'></span>

<h3>Description</h3>

<p><code>forecast</code> is a generic function for forecasting time series or
time series models. The function invokes particular <em>methods</em> which
depend on the class of the first argument.
</p>
<p>Currently the only method provided by the package is for objects of
class <code>"glarma"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
forecast(object, ...)
## S3 method for class 'glarma'
forecast(object, n.ahead = 1, newdata = 0,
         newoffset = 0, newm = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_+3A_object">object</code></td>
<td>
<p>An object of class &quot;glarma&quot; obtained from a call to
<code>glarma</code> </p>
</td></tr>
<tr><td><code id="forecast_+3A_n.ahead">n.ahead</code></td>
<td>
<p>The number of periods ahead to be forecast.</p>
</td></tr>
<tr><td><code id="forecast_+3A_newdata">newdata</code></td>
<td>
<p>The model matrix <code class="reqn">X</code> comprising the values of the
predictors for the times for which the series is to be predicted.  </p>
</td></tr>
<tr><td><code id="forecast_+3A_newoffset">newoffset</code></td>
<td>
<p>A vector containing the values of the offset for the
times for which the series is to be predicted.  </p>
</td></tr>
<tr><td><code id="forecast_+3A_newm">newm</code></td>
<td>
<p>A vector containing the number of trials when forecasting
binomial or binary time series. Defaults to the binary case. </p>
</td></tr>
<tr><td><code id="forecast_+3A_...">...</code></td>
<td>
<p>Further arguments for the call, currently unused.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only one forecasting method is currently provided, for objects of
class &quot;glarma&quot;. This produces an object of class &quot;glarmaForecast&quot;.
</p>
<p>When forecasting one step ahead, the values in the matrix
<code>newdata</code> (and <code>offset</code> if there is an offset) in the GLARMA
model are used along with the regression coefficients in the model to
obtain the predicted value of <code class="reqn">\eta</code>, the regression
component of the state variable <code class="reqn">W</code>. The predicted value of the
ARMA component of the state variable is then added to this value to
give the predicted value of <code class="reqn">W</code>.
</p>
<p>When further predictions are required, since no data is available to
calculate the predicted value of the state variable, an observation is
generated from the predicted distribution and the methodology for one
step ahead is then used on this generated data. This process is
repeated until predictions are obtained for the required number of
time periods (specified by <code>n.ahead</code>). Note that the value of
<code>n.ahead</code> must equal the row dimension of <code>newdata</code> and if
they are specified, of <code>newoffset</code> and <code>newm</code>.
</p>
<p>For completeness a randomly generated value of the time series is
produced even for one step-ahead prediction.
</p>
<p>Note that the forecasted time series returned as the component
<code>fitted</code> is then a randomly generated sample path for the
predicted time series. If a sample of such paths is produced by
repeated calls to <code>forecast</code> then sample predicted distributions
can be obtained for the forecast series.
</p>
<p>In the case of binary or binomial time series in addition to values of
the predictors in the regression component of the state variable and
the values of any offset, the numbers of trials for the binomially
distributed future observations are required. This information should
be provided in the argument <code>newm</code>. If not, the number of trials
defaults to 1, which is the case of binary responses.
</p>


<h3>Value</h3>

<p><code>forecast</code> currently has no default method.
</p>
<p>When <code>object</code> is of class <code>"glarma"</code>, <code>forecast</code>
returns an object of class <code>"glarmaForecast"</code> with components:
</p>
<table>
<tr><td><code>eta</code></td>
<td>
<p>the forecast values of the regression component of the
state variable</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the forecast values of the state variable <code class="reqn">W</code></p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the conditional mean <code class="reqn">\mu_t</code></p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the simulated series based on the fitted model</p>
</td></tr>
<tr><td><code>n.ahead</code></td>
<td>
<p>the number of steps ahead for which the forecasts were
requested in the call to <code>forecast</code></p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>the model matrix <code class="reqn">X</code> comprising the values of the
predictors for the times for which the series is to be predicted</p>
</td></tr>
<tr><td><code>newoffset</code></td>
<td>
<p>the vector containing the values of the offset for
the times for which the series is to be predicted</p>
</td></tr>
<tr><td><code>newm</code></td>
<td>
<p>the vector giving the number of trials when forecasting
binomial or binary time series</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the <code>"glarma"</code> object from the call to
<code>forecast</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt; and
&quot;David J Scott&quot; &lt;d.scott@auckland.ac.nz&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(zoo)
### Model number of deaths
data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Offset included
glarmamod &lt;- glarma(y, X, offset = log(Population/100000),
                    phiLags = c(12),
                    thetaLags = c(1),
                    type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
print(summary(glarmamod))

XT1 &lt;- matrix(X[72,], nrow = 1)
offsetT1 &lt;- log(Population/100000)[72]

mu &lt;- forecast(glarmamod, 1, XT1, offsetT1)$mu
print(mu)


### Save some values
allX &lt;- X
allFits &lt;- fitted(glarmamod)
ally &lt;- y

### Look at a succession of forecasts
### Using actual values in forecasts
forecasts &lt;- numeric(72)
for (i in (62:71)){
    y &lt;- DriverDeaths[1:i, "Deaths"]
    X &lt;- as.matrix(DriverDeaths[1:i, 2:5])
    Population &lt;- DriverDeaths[1:i, "Population"]

    ## Offset included
    glarmamod &lt;- glarma(y, X, offset = log(Population/100000),
                        phiLags = c(12),
                        thetaLags = c(1),
                        type = "Poi", method = "FS",
                        residuals = "Pearson", maxit = 100, grad = 1e-6)
    XT1 &lt;- matrix(allX[i + 1, ], nrow = 1)
    offsetT1 &lt;- log(DriverDeaths$Population[i + 1]/100000)
    mu &lt;- forecast(glarmamod, 1, XT1, offsetT1)$mu
    if (i == 62){
        forecasts[1:62] &lt;- fitted(glarmamod)
    }
    forecasts[i+1] &lt;- mu
}
par(mfrow = c(1,1))
forecasts &lt;- ts(forecasts[63:72], start = c(1985, 10), deltat = 1/12)
fitted &lt;- ts(allFits, start = c(1980, 8), deltat = 1/12)
obs &lt;- ts(DriverDeaths$Deaths, start = c(1980, 8), deltat = 1/12)
plot(obs, ylab = "Driver Deaths", lty = 2,
     main = "Single Vehicle Nighttime Driver Deaths in Utah")
points(obs)
lines(fitted, lwd = 2)
lines(forecasts, col = "red")
par(xpd = NA)
graph.param &lt;-
    legend("top",
           legend = c("observations",expression(estimated~mu[t]),
                      expression(predicted~mu[t])),
           ncol = 3,
           cex = 0.7,
           bty = "n", plot = FALSE)
legend(graph.param$rect$left,
       graph.param$rect$top + graph.param$rect$h,
       legend = c("observations", expression(estimated~mu[t]),
                  expression(predicted~mu[t])),
       col = c("black","black","red"),
       lwd = c(1,2,1), lty = c(2,1,1),
       pch = c(1, NA_integer_, NA_integer_),
       ncol = 3,
       cex = 0.7,
       bty = "n",
       text.font = 4)
par(xpd = FALSE)

### Generate a sample of Y values 2 steps ahead and examine the distribution
data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Fit the glarma model to the first 70 observations
glarmamod &lt;- glarma(y[1:70], X[1:70, ],
                    offset = log(Population/100000)[1:70],
                    phiLags = c(12),
                    thetaLags = c(1),
                    type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)

nObs &lt;- NROW(X)
n.ahead &lt;- 2
### Specify the X matrix and offset for the times where predictions
### are required
XT1 &lt;- as.matrix(X[(nObs - n.ahead + 1):nObs, ])
offsetT1 &lt;- log(Population/100000)[(nObs - n.ahead + 1):nObs]
nSims &lt;- 500
forecastY &lt;- matrix(ncol = n.ahead, nrow = nSims)
forecastMu &lt;- matrix(ncol = n.ahead, nrow = nSims)

### Generate sample predicted values
for(i in 1:nSims){
    temp &lt;-  forecast(glarmamod, n.ahead, XT1, offsetT1)
    forecastY[i, ] &lt;- temp$Y
    forecastMu[i, ] &lt;- temp$mu
}
### Examine distribution of sample of Y values n.ahead
table(forecastY[, 2])
par(mfrow = c(2,1))
barplot(table(forecastY[, 2]),
        main = "Barplot of Sample Y Values 2 Steps Ahead")
hist(forecastY[, 2], xlab = "Sample Y values",
     breaks=seq(0,max(forecastY[, 2])),
     main = "Histogram of Sample Y Values 2 Steps Ahead\nwith 0.025 and 0.975 Quantiles")
abline(v = quantile(forecastY[, 2], c(0.025, 0.975)), col = "red")

</code></pre>

<hr>
<h2 id='glarma'>Generalized Linear Autoregressive Moving Average Models with
Various Distributions</h2><span id='topic+glarma'></span><span id='topic+glarmaPoissonPearson'></span><span id='topic+glarmaPoissonScore'></span><span id='topic+glarmaBinomialIdentity'></span><span id='topic+glarmaBinomialPearson'></span><span id='topic+glarmaBinomialScore'></span><span id='topic+glarmaNegBinPearson'></span><span id='topic+glarmaNegBinScore'></span><span id='topic+print.glarma'></span>

<h3>Description</h3>

<p>The function <code>glarma</code> is used to fit generalized linear
autoregressive moving average models with various distributions
(Poisson, binomial, negative binomial) using either Pearson residuals
or score residuals, and for the binomial distribution, identity
residuals. It also estimates the parameters of the GLARMA model with
various distributions by using Fisher scoring or Newton-Raphson
iteration.
</p>
<p>For Poisson and negative binomial response distributions the log link
is currently used. For binomial responses the logit link is currently
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glarma(y, X, offset = NULL, type = "Poi", method = "FS", residuals = "Pearson",
       phiLags,  thetaLags, phiInit, thetaInit, beta, alphaInit,
       alpha = 1, maxit = 30, grad = 2.22e-16)

glarmaPoissonPearson(y, X, offset = NULL, delta, phiLags, thetaLags,
                     method =  "FS")

glarmaPoissonScore(y, X, offset = NULL, delta, phiLags, thetaLags,
                   method =  "FS")

glarmaBinomialIdentity(y, X, offset = NULL, delta, phiLags, thetaLags,
                       method =  "FS")

glarmaBinomialPearson(y, X, offset = NULL, delta, phiLags, thetaLags,
                      method =  "FS")

glarmaBinomialScore(y, X, offset = NULL, delta, phiLags, thetaLags,
                    method =  "FS")

glarmaNegBinPearson(y, X, offset = NULL, delta, phiLags, thetaLags,
                    method =  "FS")

glarmaNegBinScore(y, X, offset = NULL, delta, phiLags, thetaLags,
                  method =  "FS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glarma_+3A_y">y</code></td>
<td>
<p>Numeric vector; the response variable. If the
response variable is for the model with the binomial
distribution, it should be a n by 2 matrix, one column is the
number of successes and another is the number of failures.</p>
</td></tr>
<tr><td><code id="glarma_+3A_x">X</code></td>
<td>
<p>Matrix; the explanatory variables. A vector of ones should be
added to the data matrix as the first column for the <code>beta</code> of
the intercept.</p>
</td></tr>
<tr><td><code id="glarma_+3A_offset">offset</code></td>
<td>
<p>Either <code>NULL</code> or a numeric vector of length equal
to the number of cases. Used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="glarma_+3A_beta">beta</code></td>
<td>
<p>Numeric vector; initial values of the regression
coefficients.</p>
</td></tr>
<tr><td><code id="glarma_+3A_philags">phiLags</code></td>
<td>
<p>Numeric vector; AR orders.</p>
</td></tr>
<tr><td><code id="glarma_+3A_phiinit">phiInit</code></td>
<td>
<p>Numeric vector; initial values for the corresponding
AR orders.</p>
</td></tr>
<tr><td><code id="glarma_+3A_thetalags">thetaLags</code></td>
<td>
<p>Numeric vector; MA orders.</p>
</td></tr>
<tr><td><code id="glarma_+3A_thetainit">thetaInit</code></td>
<td>
<p>Numeric vector; initial values for the corresponding
MA orders.</p>
</td></tr>
<tr><td><code id="glarma_+3A_delta">delta</code></td>
<td>
<p>Numeric vector; initial values of the parameters for the
GLARMA estimation procedure. It is a combination of the parameters of
<code>beta</code>, the AR terms and the MA terms.</p>
</td></tr>
<tr><td><code id="glarma_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; an optional initial shape parameter for
<code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.</p>
</td></tr>
<tr><td><code id="glarma_+3A_alphainit">alphaInit</code></td>
<td>
<p>Numeric; an initial shape parameter for
<code>glarma</code> for negative binomial counts.</p>
</td></tr>
<tr><td><code id="glarma_+3A_type">type</code></td>
<td>
<p>Character; the count distribution. Possible values are
<code>"Poi"</code> (Poisson), <code>"Bin"</code> (binomial) and <code>"NegBin"</code>
(negative binomial). The default is the
Poisson distribution.</p>
</td></tr>
<tr><td><code id="glarma_+3A_method">method</code></td>
<td>
<p>Character; method of iteration to be used. Possible
values are <code>"FS"</code> (Fisher scoring), and <code>"NR"</code>
(Newton-Raphson). The default is to use Fisher scoring to estimate
the parameters of a GLARMA model.</p>
</td></tr>
<tr><td><code id="glarma_+3A_residuals">residuals</code></td>
<td>
<p>Character; the type of residuals to be used. Possible
values are <code>"Pearson"</code> and <code>"Score"</code>, and for the binomial
distribution <code>"Identity"</code> is also allowed. The default is to
use Pearson residuals.</p>
</td></tr>
<tr><td><code id="glarma_+3A_maxit">maxit</code></td>
<td>
<p>Numeric; the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="glarma_+3A_grad">grad</code></td>
<td>
<p>Numeric; the tolerance for recognizing numbers, which
are smaller than the specified tolerance, as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>glarma</code> are specified symbolically. A typical model
has the form <code>y</code> (response), <code>X</code> (terms) where <code>y</code> is
the count or factor reponse vector, <code>X</code> is a series of terms
which specifies a linear predictor for the response. It should be noted
that the first column of <code>X</code> should be a vector of 1s as the
intercept in the model. Four initial parameters that need to be
estimated are combined into <code class="reqn">\delta = (\beta, \phi, \theta,
  \alpha)</code>, where <code class="reqn">\alpha</code>
is an optional parameter to accomodate the negative binomial
model. Note that in the function <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> from the
package <span class="pkg">MASS</span>, this parameter is called <code>theta</code>.
</p>
<p>For Poisson and negative binomial response distributions the log link
is currently used. For binomial responses the logit link is currently
used.
</p>
<p>The generalized linear autoregressive moving average models are
computed as follows.
</p>
<p>The linear predictor for the response is
</p>
<p style="text-align: center;"><code class="reqn">\log{\mu_t} = W_t = X_t^T\beta + \mbox{offset} + Z_t.</code>
</p>

<p>The infinite moving average from the linear predictor is
</p>
<p style="text-align: center;"><code class="reqn">Z_t = \sum_{i=1}^\infty \gamma_i e_{t-i}.</code>
</p>

<p>This infinite moving average, is computed using the autoregressive
moving average recursions
</p>
<p style="text-align: center;"><code class="reqn">Z_t = \phi_1 (Z_{t-1} + e_{t-1}) + ... +%
              \phi_p (Z_{t-p} + e_{t-p}) + \theta_1 e_{t-1}%
	      + ... + \theta_q e_{t-q}</code>
</p>

<p>where <code class="reqn">p</code> and <code class="reqn">q</code> are the orders of <code class="reqn">\phi</code>
and <code class="reqn">\theta</code> respectively and the non-zero lags of the vectors
<code>phi</code> and <code>theta</code> may be specified by the user via the
arguments <code>phiLag</code> and <code>thetaLag</code>.
</p>
<p>There are two types of residuals which may be used in each
recursion, Pearson residuals or score residuals, and in addition,
for the binomial distribution, identity residuals may be used. The
infinite moving average, <code class="reqn">Z_t</code>, depends on the type of
residuals used, as do the final parameters obtained from the
filter. Standardisation of past observed counts is necessary to
avoid instability, therefore the user should choose the appropriate
type of residuals depending on the situation.
</p>
<p>The method of estimation for parameters implemented in the function
aims to maximise the log likelihood by an iterative method commencing
from suitably chosen initial values for the parameters. Starting from
initial values <code class="reqn">\hat\delta^{(0)}</code> for the vector of
parameters updates are obtained using the iterations
</p>
<p style="text-align: center;"><code class="reqn">\hat{\delta}^{(k+1)}=\hat{\delta}^{(k)}+\Omega(\hat{\delta}^{(k)}%
)\frac{\partial l(\hat{\delta}^{(k)})}{\partial\delta}</code>
</p>

<p>where <code class="reqn">\Omega (\hat\delta^{(k)})</code> is some
suitably chosen matrix.
</p>
<p>Iterations continue for <code class="reqn">k\geq1</code> until convergence is
reached or the number of iterations <code class="reqn">k</code> reaches a user specified
upper limit on maximum iterations in which case they will stop. The
convergence criterion used in our implementation is that based on
<code class="reqn">\eta</code>, the maximum of absolute values of the first
derivatives.
</p>
<p>When <code class="reqn">\eta</code> is less than a user specified value <code>grad</code>
the iterations stop. There are two methods of optimization of the
likelihood, Newton-Raphson and Fisher scoring. The method used is
specified by the argument <code>method</code>. It should be noticed that if
the initial value for parameters are not chosen well, the
optimization of the likelihood might fail to converge. Care is needed
when fitting mixed ARMA specifications because there is potential for
the AR and MA parameters to be non-identifiable if the orders <code class="reqn">p</code> and
<code class="reqn">q</code> are too large. Lack of identifiability manifests itself in the
algorithm to optimize the likelihood failing to converge and/or the
hessian being singular&mdash;check the warning messages and convergence
error codes.
</p>


<h3>Value</h3>

<p>The function <code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="#topic+summary.glarma">summary.glarma</a></code>)
can be used to obtain or print a summary of the results.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+coef">coef</a></code> (i.e.,
<code><a href="#topic+coef.glarma">coef.glarma</a></code>), <code><a href="stats.html#topic+logLik">logLik</a></code> (i.e.,
<code><a href="#topic+logLik.glarma">logLik.glarma</a></code>), <code><a href="stats.html#topic+fitted">fitted</a></code> (i.e.,
<code><a href="#topic+fitted.glarma">fitted.glarma</a></code>), <code><a href="stats.html#topic+residuals">residuals</a></code> (i.e.,
<code><a href="#topic+residuals.glarma">residuals.glarma</a></code>), <code><a href="stats.html#topic+nobs">nobs</a></code> (i.e.,
<code><a href="#topic+nobs.glarma">nobs.glarma</a></code>), <code><a href="stats.html#topic+model.frame">model.frame</a></code> (i.e.,
<code><a href="#topic+model.frame.glarma">model.frame.glarma</a></code>) and <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> (i.e.,
<code><a href="#topic+extractAIC.glarma">extractAIC.glarma</a></code>) can be used to extract various useful
features of the value returned by <code>glarma</code>.
</p>
<p><code>glarma</code> returns an object of class &quot;glarma&quot; with components:
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>a vector of coefficients for <code>beta</code>, <code>AR</code> and
<code>MA</code>.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the loglikelihood of the specific distribution.</p>
</td></tr>
<tr><td><code>logLikDeriv</code></td>
<td>
<p>the derivative of the loglikelhood of the specified
distribution.</p>
</td></tr>
<tr><td><code>logLikDeriv2</code></td>
<td>
<p>the second derivative of the loglikelihood of the
specified distribution.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the estimated linear predictor.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the GLARMA estimated mean.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the GLARMA fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the type specified.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the estimated covariance matrix of the maximum
likelihood estimators.</p>
</td></tr>
<tr><td><code>phiLags</code></td>
<td>
<p>vector of AR orders.</p>
</td></tr>
<tr><td><code>thetaLags</code></td>
<td>
<p>vector of MA orders.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the number of columns in the model matrix.</p>
</td></tr>
<tr><td><code>pq</code></td>
<td>
<p>the number of <code>phiLags</code> plus the number of
<code>thetaLags</code>.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the deviance from the initial GLM fit.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the degrees of freedom from the initial GLM fit.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the <code class="reqn">y</code> vector used in the GLARMA model.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset, <code>NULL</code> if there is no offset.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the distribution of the counts.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method of iteration used.</p>
</td></tr>
<tr><td><code>residType</code></td>
<td>
<p>the type of the residuals returned.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>errCode</code></td>
<td>
<p>the error code; 0 indicating successful convergence of
the iteration method, 1 indicating failure.</p>
</td></tr>
<tr><td><code>WError</code></td>
<td>
<p>error code for finiteness of <code class="reqn">W</code>; 0 indicating all
values of <code class="reqn">W</code> are finite, 1 indicating at least one infinite
value.</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum of the absolute value of the gradient.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>A version of Akaike's An Information Criterion, minus
twice the maximized log-likelihood plus twice the number of
parameters, computed by the aic component of the family. For
binomial and Poisson families the dispersion is fixed at one and the
number of parameters is the number of coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The original GLARMA routine for Poisson responses was developed in
collaboration with Richard A. Davis and Ying Wang. The binomial
response version was developed with the assistance of Haolan Lu. The
extension to negative binomial response was carried out by Bo
Wang. Daniel Drescher contributed to the initial structure of the
software used as the basis of the package.
</p>
<p>The main author of the package is  &quot;William T.M. Dunsmuir&quot;
&lt;w.dunsmuir@unsw.edu.au&gt;. Package development was carried out by
Cenanning Li supervised by David J. Scott.
</p>


<h3>References</h3>

<p>Dunsmuir, William T. M. and Scott, David J. (2015) The <span class="pkg">glarma</span> Package
for Observation-Driven Time Series Regression of Counts.
<em>Journal of Statistical Software</em>, <b>67(7)</b>, 1&ndash;36.
<a href="http://dx.doi.org/10.18637/jss.v067.i07">http://dx.doi.org/10.18637/jss.v067.i07</a>
</p>


<h3>See Also</h3>

<p>Additional examples may be found in <code><a href="#topic+Asthma">Asthma</a></code>,
<code><a href="#topic+OxBoatRace">OxBoatRace</a></code>, <code><a href="#topic+RobberyConvict">RobberyConvict</a></code>, and
<code><a href="#topic+DriverDeaths">DriverDeaths</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Davis, Dunsmuir Wang (1999)
## MA(1,2,5), Pearson Residuals, Fisher Scoring
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(y, X, thetaLags = c(1,2,5), type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

## Score Type (GAS) Residuals, Fisher Scoring
glarmamod &lt;- glarma(y, X, thetaLags = c(1,2,5), type = "Poi", method = "FS",
                    residuals = "Score", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

## Score Type (GAS)  Residuals, Newton Raphson
## Note: Newton Raphson fails to converge from GLM initial estimates.
## Setting up the initial estimates by ourselves
init.delta &lt;- glarmamod$delta
beta &lt;- init.delta[1:6]
thetaInit &lt;- init.delta[7:9]

glarmamod &lt;- glarma(y, X, beta = beta, thetaLags = c(1, 2, 5),
                    thetaInit = thetaInit, type ="Poi", method = "NR",
                    residuals = "Score", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

## AR(1,5), Pearson Residuals, Fisher Scoring
glarmamod &lt;- glarma(y, X, phiLags = c(1, 5), type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)



</code></pre>

<hr>
<h2 id='initial'>Initial Parameter Generator for GLARMA from GLM</h2><span id='topic+initial'></span>

<h3>Description</h3>

<p>Function used to generate initial values of parameters for the
GLARMA model from <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial(y, X, offset = NULL, type = "Poi", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initial_+3A_y">y</code></td>
<td>
<p>Numeric vector; response variable.</p>
</td></tr>
<tr><td><code id="initial_+3A_x">X</code></td>
<td>
<p>Matrix; explanatory variables. A vector of ones should be
added to the data matrix as the first column for the
<code class="reqn">\beta</code> of the intercept.</p>
</td></tr>
<tr><td><code id="initial_+3A_offset">offset</code></td>
<td>
<p>Either <code>NULL</code> or a numeric vector of length equal
to the number of cases. Used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>  
<tr><td><code id="initial_+3A_type">type</code></td>
<td>
<p>Character; the distribution of the counts.</p>
</td></tr>
<tr><td><code id="initial_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; an optional initial value for the
<code>theta</code> parameter in the negative binomial distribution; the
default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates and returns the initial parameters for the GLARMA model
under the specified distribution by fitting a generalized linear
model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>A named numeric vector of initial coefficients.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>If requested, the <code class="reqn">y</code> vector used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If requested, the model matrix.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The <code>theta</code> parameter in the negative binomial
distribution returned by <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.  <code>NULL</code> if any
other distribution is used.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The distribution of the counts in the GLARMA model.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Null deviance of the GLM with the same regression
structure as the GLARMA model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Null degrees of freedom of the GLM with the same
regression structure as the GLARMA model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Using the polio data
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])

glmMod &lt;- initial(y, X, type = "Poi", alpha=1)
str(glmMod)
head(glmMod)
</code></pre>

<hr>
<h2 id='likTests'>
Likelihood Ratio Test and Wald Test for <code>GLARMA</code> Fit
</h2><span id='topic+likTests'></span><span id='topic+likeTests'></span><span id='topic+print.likTests'></span>

<h3>Description</h3>

<p>Function to carry out the likelihood ratio and Wald tests of serial
dependence when the alternative is a GLARMA process.  This function
takes a <code>"glarma"</code> object and uses its attributes to set up a GLM
fit that matches the GLARMA model regression structure.  This is done
to ensure that the GLM object is the null hypothesis for testing
against the <code>"glarma"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likTests(object)
likeTests(object)
## S3 method for class 'likTests'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likTests_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call to
<code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="likTests_+3A_x">x</code></td>
<td>
<p>An object of class <code>"likTests"</code>, a result of a call to
<code>likTests</code></p>
</td></tr>
<tr><td><code id="likTests_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function carries out the likelihood ratio and Wald tests
for comparing the null model and the alternative model.
</p>
<p><code>likeTests</code> is an alias for <code>likTests</code>.
</p>


<h3>Value</h3>

<p><code>likTests</code> returns an object of class <code>"likTests"</code>. A matrix is
shown with the statistics and p-value for each test. The significance
stars alongside help to identify any probabilities less than 0.05 or
0.01.
</p>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(y, X, thetaLags = c(1,2,5), type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 2.22e-16)
likTests(glarmamod)
likeTests(glarmamod)
</code></pre>

<hr>
<h2 id='logLik.glarma'>Extract Log-Likelihood from GLARMA Models</h2><span id='topic+logLik.glarma'></span>

<h3>Description</h3>

<p><code>logLik</code> is a generic function which extracts the GLARMA model
log-likelihood from objects returned by modeling functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
logLik(object, deriv, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, a result of a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.glarma_+3A_deriv">deriv</code></td>
<td>
<p>Numeric; either &quot;0&quot;, &quot;1&quot;
or &quot;2&quot;. It is used to choose and extract the log-likehood, its
derivative or its second derivative respectively from the
<code>"glarma"</code> object. The default is &quot;0&quot;.</p>
</td></tr>
<tr><td><code id="logLik.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic function. <code>logLik</code> returns the
log-likelihood, its derivative, or its second derivative from the
object of class <code>glarma</code> based on the value of the argument
<code>deriv</code>. &quot;0&quot; is for the log-likelihood, &quot;1&quot; is for the first
derivative of log-likelihood and &quot;2&quot; is for the second derivative of
the log-likelihood.
</p>


<h3>Value</h3>

<p>The log-likelihood, the derivative of the log-likelihood or the second
derivative of the log-likelihood extracted from the GLARMA model
object <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.glarma">coef.glarma</a></code>, <code><a href="#topic+residuals.glarma">residuals.glarma</a></code>,
<code><a href="#topic+fitted.glarma">fitted.glarma</a></code>, <code><a href="#topic+glarma">glarma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Polio)
Y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(Y, X, thetaLags = c(1, 2, 5), type = "Poi", method ="FS",
                    residuals = "Pearson", maxit = 100 , grad = 1e-6)

logLik(glarmamod, deriv = 0)
logLik(glarmamod, deriv = 1)
logLik(glarmamod, deriv = 2)
</code></pre>

<hr>
<h2 id='model.frame.glarma'>Extracting the Model Frame of the GLARMA Model</h2><span id='topic+model.frame.glarma'></span>

<h3>Description</h3>

<p><code>model.frame</code> (a generic function) and its methods return a
data frame with the variables that are used in the
<code><a href="#topic+glarma">glarma</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.glarma_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>glarma</code>, obtained from a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an S3 generic function. It extracts the response variable
vector and the matrix of the explanatory variables from the object of
class <code>"glarma"</code>, and combines them as a data frame.
</p>


<h3>Value</h3>

<p>A data frame with the variables used in the fitted
<code><a href="#topic+glarma">glarma</a></code> model.
</p>


<h3>Author(s)</h3>

<p>Cenanning Li &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.glarma">coef.glarma</a></code>, <code><a href="#topic+residuals.glarma">residuals.glarma</a></code>,
<code><a href="#topic+fitted.glarma">fitted.glarma</a></code>, <code><a href="#topic+glarma">glarma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Polio)
print(y &lt;- Polio[, 2])
X &lt;- as.matrix(Polio[, 3:8])
str(X)
head(X)


glarmamod &lt;- glarma(y, X, thetaLags = c(1, 2, 5), type = "Poi",
                    method = "FS", residuals = "Pearson",
                    maxit = 100, grad = 1e-6)

str(model.frame(glarmamod))
head(model.frame(glarmamod))
</code></pre>

<hr>
<h2 id='mySolve'>Matrix Inversion of the Hessian of the Log-Likelihood</h2><span id='topic+mySolve'></span>

<h3>Description</h3>

<p>Inverts the second derivative matrix of the log-likelihood to obtain
the estimated covariance matrix of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mySolve(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mySolve_+3A_a">A</code></td>
<td>
<p>Matrix; the negative second derivative of the
log-likelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mySolve</code> attempts to invert its matrix argument. If the matrix
supplied is not invertible, <code>ErrCode</code> is set to 1.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Ainv</code></td>
<td>
<p>inverse of the negative second derivative of the
loglikelihood. If the inverse is unable to be obtained,
returns the original negative second derivative of the
log-likelihood.</p>
</td></tr>
<tr><td><code>ErrCode</code></td>
<td>
<p>Numeric; 0 if the inverse can be found, 1 if not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Using the polio data
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])

## Construct the vectors of phi lags and theta lags
theta.lags &lt;- c(1, 2, 5)
phi.lags &lt;- rep(0, 0)
## Construct the initial delta vector
delta &lt;- c("Intcpt" = 0.2069383, "Trend" = -4.7986615 ,
           "CosAnnual" = -0.1487333, "SinAnnual" = -0.5318768,
           "CosSemiAnnual" = 0.1690998, "SinSemiAnnual" = -0.4321435,
           "theta_1" = 0, "theta_2"= 0, "theta_5"= 0 )

## Calculate the second derivative of the loglikelihood
glarmamod &lt;- glarmaPoissonPearson(y, X, delta = delta, phiLags = phi.lags,
                           thetaLags = theta.lags, method = "FS")

## estimate the covariance matrix of the estimators from the second
## derivative of the loglikelihood
mySolve(-glarmamod$ll.dd)
</code></pre>

<hr>
<h2 id='nobs.glarma'>Extract the Number of Observations from a GLARMA Model Fit</h2><span id='topic+nobs.glarma'></span>

<h3>Description</h3>

<p>An accessor function used to extract the number of observations from a
<code>"glarma"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="nobs.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations extracted from the object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.glarma">coef.glarma</a></code>, <code><a href="#topic+residuals.glarma">residuals.glarma</a></code>,
<code><a href="#topic+fitted.glarma">fitted.glarma</a></code>, <code><a href="#topic+glarma">glarma</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Davis, Dunsmuir Wang (1999)
## MA(1,2,5), Pearson Residuals, Fisher Scoring
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(y, X, thetaLags = c(1,2,5), type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 2.22e-16)

nobs(glarmamod)
</code></pre>

<hr>
<h2 id='normRandPIT'>
Random normal probability integral transformation
</h2><span id='topic+normRandPIT'></span>

<h3>Description</h3>

<p>Function to create the normalized conditional (randomized) quantile
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normRandPIT(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normRandPIT_+3A_object">object</code></td>
<td>
<p>an object of class &quot;glarma&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+glarmaPredProb">glarmaPredProb</a></code> produces the non-randomized
probability integral transformation (PIT). It returns estimates of the
cumulative predictive probabilities as upper and lower bounds of a
collection of intervals. If the model is correct, a histogram drawn
using these estimated probabilities should resemble a histogram
obtained from a sample from the uniform distribution. This function
aims to produce observations which instead resemble a sample from a
normal distribution. Such a sample can then be examined by the usual
tools for checking normality, such as histograms, Q-Q normal plots and
for checking independence, autocorrelation and partial autocorrelation
plots, and associated portmanteau statistics.
</p>
<p>For each of the intervals produced by <code><a href="#topic+glarmaPredProb">glarmaPredProb</a></code>, a
random uniform observation is generated, which is then converted to a
normal observation by applying the inverse standard normal
distribution function (that is <code><a href="stats.html#topic+qnorm">qnorm</a></code>). The vector of
these values is returned by the function in the list element
<code>rt</code>. In addition non-random observations which should appear
similar to a sample from a normal distribution are obtained by
applying <code>qnorm</code> to the mid-points of the predictive distribution
intervals. The vector of these values is returned by the function in
the list element <code>rtMid</code>.
</p>


<h3>Value</h3>

<p>A list consisting of two elements:
</p>
<table>
<tr><td><code>rt</code></td>
<td>
<p>the normalized conditional (randomized) quantile residuals</p>
</td></tr>
<tr><td><code>rtMid</code></td>
<td>
<p>the midpoints of the predictive probability intervals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt; and
&quot;David J Scott&quot; &lt;d.scott@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Berkowitz, J. (2001) Testing density forecasts, with applications to
risk management. <em>Journal of Business \&amp; Economic Statistics</em>,
<b>19</b>, 465&ndash;474.
</p>
<p>Dunn, Peter K. and Smyth, Gordon K. (1996) Randomized quantile
residuals. <em>Journal of Computational and Graphical Statistics</em>,
<b>5</b>, 236&ndash;244.
</p>


<h3>See Also</h3>

<p>See also as <code><a href="#topic+glarmaPredProb">glarmaPredProb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DriverDeaths)
y &lt;- DriverDeaths[, "Deaths"]
X &lt;- as.matrix(DriverDeaths[, 2:5])
Population &lt;- DriverDeaths[, "Population"]

### Offset included
glarmamodOffset &lt;- glarma(y, X, offset = log(Population/100000),
                          phiLags = c(12),
                          type = "Poi", method = "FS",
                          residuals = "Pearson", maxit = 100, grad = 1e-6)
rt &lt;- normRandPIT(glarmamodOffset)$rt
par(mfrow = c(2,2))
hist(rt, main = "Histogram of Randomized Residuals",
     xlab = expression(r[t]))
box()
qqnorm(rt, main = "Q-Q Plot of  Randomized Residuals" )
abline(0, 1, lty = 2)
acf(rt, main = "ACF of Randomized Residuals")
pacf(rt, main = "PACF of Randomized Residuals")
</code></pre>

<hr>
<h2 id='OxBoatRace'>Oxford-Cambridge Boat Race</h2><span id='topic+OxBoatRace'></span>

<h3>Description</h3>

<p>Results of the boat race between Oxford and Cambridge from
1829&ndash;2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OxBoatRace)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">

  [, 1]</td><td style="text-align: left;"> Year </td><td style="text-align: left;"> Year in which the race occurred. Some years are
  missing when the race was not run.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 2]</td><td style="text-align: left;"> Intercept </td><td style="text-align: left;"> A vector of ones, providing the intercept in
  the model.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 3]</td><td style="text-align: left;"> Camwin </td><td style="text-align: left;"> A binary response, zero for an Oxford win, one
  for a Cambridge win.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 4]</td><td style="text-align: left;"> WinnerWeight </td><td style="text-align: left;"> Weight of winning team's crew.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 5]</td><td style="text-align: left;"> LoserWeight </td><td style="text-align: left;"> Weight of losing team's crew.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 6]</td><td style="text-align: left;"> Diff </td><td style="text-align: left;"> Difference between winning team's weight and
  losing team's weight.</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Source</h3>

<p>Klingenberg, Bernhard (2008) Regression models for binary time series
with gaps. <em>Computational Statistics &amp; Data Analysis</em>,
<b>52</b>, 4076&ndash;4090.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with Oxford-Cambridge Boat Race
data(OxBoatRace)

y1 &lt;- OxBoatRace$Camwin
n1 &lt;- rep(1, length(OxBoatRace$Year))
Y &lt;- cbind(y1, n1 - y1)
X &lt;- cbind(OxBoatRace$Intercept, OxBoatRace$Diff)
colnames(X) &lt;- c("Intercept", "Weight Diff")

oxcamglm &lt;- glm(Y ~ Diff + I(Diff^2),
                data = OxBoatRace,
                family = binomial(link = "logit"), x = TRUE)
summary(oxcamglm)

X &lt;- oxcamglm$x

glarmamod &lt;- glarma(Y, X, thetaLags = c(1, 2), type = "Bin", method = "NR",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)

summary(glarmamod)
likTests(glarmamod)

## Plot Probability of Cambridge win versus Cambridge Weight advantage:
beta &lt;- coef(glarmamod, "beta")
par(mfrow = c(1, 1))
plot(OxBoatRace$Diff, 1 / (1 + exp(-(beta[1] + beta[2] * OxBoatRace$Diff +
                                       beta[3] * OxBoatRace$Diff^2))),
     ylab = "Prob", xlab = "Weight Diff")
title("Probability of Cambridge win \n versus Cambridge weight advantage")

## Residuals and fit plots
par(mfrow=c(3, 2))
plot.glarma(glarmamod)
</code></pre>

<hr>
<h2 id='paramGen'>Parameter Generators</h2><span id='topic+paramGen'></span><span id='topic+deltaGen'></span><span id='topic+thetaGen'></span><span id='topic+phiGen'></span>

<h3>Description</h3>

<p>Functions which use the arguments of a <code><a href="#topic+glarma">glarma</a></code> call to
generate the initial <code>delta</code>, <code>theta</code> and <code>phi</code>
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaGen(y, X, offset = NULL, phiInit, thetaInit, type, alpha,
         beta, alphaInit)
thetaGen(thetaLags, thetaInit)
phiGen(phiLags, phiInit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramGen_+3A_y">y</code></td>
<td>
<p>Numeric vector; response variable.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_x">X</code></td>
<td>
<p>Matrix; the explanatory variables. A vector of ones should be
added to the data matrix as the first column for the <code>beta</code> of
the intercept.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_offset">offset</code></td>
<td>
<p>Either <code>NULL</code> or a numeric vector of length equal
to the number of cases. Used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_phiinit">phiInit</code></td>
<td>
<p>Numeric vector; initial values for the
corresponding AR orders.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_thetainit">thetaInit</code></td>
<td>
<p>Numeric vector; initial values for the
corresponding orders.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_type">type</code></td>
<td>
<p>Character; the count distribution. The default is the
Poisson distribution.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_beta">beta</code></td>
<td>
<p>Numeric vector; initial values of the parameters of
variables. It is for the user to construct the specific <code>delta</code>
by themselves.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; an optional initial <code>theta</code> parameter for
<code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_alphainit">alphaInit</code></td>
<td>
<p>Numeric; an initial <code>theta</code> parameter for
<code>glarma</code> for negative binomial counts.</p>
</td></tr>
<tr><td><code id="paramGen_+3A_thetalags">thetaLags</code></td>
<td>
<p>Numeric vector; MA orders</p>
</td></tr>
<tr><td><code id="paramGen_+3A_philags">phiLags</code></td>
<td>
<p>Numeric vector; AR orders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>thetaGen</code> and <code>phiGen</code> functions take the arguments,
<code>thetaLags</code>, <code>phiLags</code>, <code>thetaInit</code> and <code>phiInit</code>,
in a <code><a href="#topic+glarma">glarma</a></code> call to generate and return the initial
<code>theta</code> and <code>phi</code> vectors with orders corresponding to their
names. Then the <code>deltaGen</code> function uses the values returned by
<code>thetaGen</code>, <code>phiGen</code> and other arguments in the
<code><a href="#topic+glarma">glarma</a></code> call to generate and return the initial
<code>delta</code> vector with correct names.
</p>


<h3>Value</h3>

<p><code>thetaGen</code> returns a list containing <code>thetaLags</code> and
<code>thetaInit</code>. <code>thetaInit</code> is the initial <code>theta</code> vector
with its corresponding MA orders as its names.
</p>
<p><code>phiGen</code> returns a list containing <code>phiLags</code> and
<code>phiInit</code>. <code>phiInit</code> is the initial <code>phi</code> vector
with its corresponding MA orders as its names.
</p>
<p><code>deltaGen</code> returns a named vector giving the values of
<code>beta</code>, <code>phiInit</code>, <code>thetaInit</code> plus <code>alpha</code> in the
negative binomial case.
</p>


<h3>Author(s)</h3>

<p>&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt; and
&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Using the polio data
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])

## generate the theta vector
theta.lags &lt;- c(1, 2, 5)
theta.init &lt;- c(0.0, 0.0, 0.0)

theta &lt;- thetaGen(theta.lags, theta.init)
print(thetaLags &lt;- theta[[1]])
print(theta.init &lt;- theta[[2]])

## generate the vector of phi
phi.lags &lt;- rep(0, 0)
phi.init &lt;- rep(0, 0)
phi &lt;- phiGen(phi.lags, phi.init)
print(phiLags &lt;- phi[[1]])
print(phi.init &lt;- phi[[2]])

## generate the delta vector
delta &lt;- deltaGen(y = y, X = X, phiInit = phi.init,
                  thetaInit = theta.init, type = "Poi",
                  alpha = 1)
delta
</code></pre>

<hr>
<h2 id='PIT'>Non-randomized Probability Integral Transformation</h2><span id='topic+glarmaPredProb'></span><span id='topic+glarmaPIT'></span>

<h3>Description</h3>

<p>Functions to produce the non-randomized probability integral
transform (PIT) to check the adequacy of the distributional assumption of
the GLARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glarmaPredProb(object)
glarmaPIT(object, bins = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PIT_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a
call to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="PIT_+3A_bins">bins</code></td>
<td>
<p>Numeric; the number of bins used in the
PIT.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used for the assessment of predictive distributions
in discrete data. They obtain the predictive probabilities
and the probability integral transformation for a fitted GLARMA
model.
</p>


<h3>Value</h3>

<p><code>glarmaPredProb</code> returns a list with values:
</p>
<table>
<tr><td><code>upper</code></td>
<td>
<p>the predictive cumulative probabilities used
as the upper bound for computing the non-randomized PIT.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the predictive cumulative probabilities used
as the lower bound for computing the non-randomized PIT.</p>
</td></tr>
</table>
<p><code>glarmaPIT</code> returns a list with values:
</p>
<table>
<tr><td><code>upper</code></td>
<td>
<p>the predictive cumulative probabilities used
as the upper bound for computing the non-randomized PIT.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>the predictive cumulative probabilities used
as the lower bound for computing the non-randomized PIT.</p>
</td></tr>
<tr><td><code>conditionalPIT</code></td>
<td>
<p>the conditional probability integral
transformation given the observed counts.</p>
</td></tr>
<tr><td><code>PIT</code></td>
<td>
<p>the probability integral transformation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;David J. Scott&quot; &lt;d.scott@auckland.ac.nz&gt; and
&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>References</h3>

<p>Czado, Claudia and Gneiting, Tilmann and Held, Leonhard (2009)
Predictive model assessment for count data. <em>Biometrics</em>,
<b>65</b>, 1254&ndash;1261.
</p>
<p>Jung, Robert.C and Tremayne, A.R (2011) Useful models for time series
of counts or simply wrong ones? <em>Advances in Statistical
Analysis</em>, <b>95</b>, 59&ndash;91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Davis, Dunsmuir Wang (1999)
## MA(1,2,5), Pearson Residuals, Fisher Scoring
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(y, X, thetaLags = c(1,2,5), type = "Poi", method = "FS",
                    residuals = "Pearson", maxit = 100, grad = 2.22e-16)
glarmaPredProb(glarmamod)
glarmaPIT(glarmamod)
</code></pre>

<hr>
<h2 id='plot.glarma'>Plot Diagnostics for a <code>glarma</code> Object</h2><span id='topic+plot.glarma'></span>

<h3>Description</h3>

<p>Ten plots (selectable by <code>which</code>) are currently available: a
time series plot with observed values of the dependent variable, fixed
effects fit, and GLARMA fit; an ACF plot of residuals; a plot
of residuals against time; a normal Q-Q plot; the PIT histogram;
a uniform Q-Q plot for the PIT; a histogram of the normal randomized
residuals; a Q-Q plot of the normal randomized residuals; a plot of
the autocorrelation of the normal randomized residuals; and a plot of
the partial autocorrelation of the normal randomized residuals. By
default, six plots are provided, numbers 1, 3, 5, 7, 8 and 9 from this
list of plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
plot(x, which = c(1L,3L,5L,7L,8L,9L), fits = 1L:3L,
     ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(),
     lwdObs = 1, lwdFixed = 1, lwdGLARMA = 1,
     colObs = "black", colFixed = "blue", colGLARMA = "red",
     ltyObs = 2, ltyFixed = 1, ltyGLARMA = 1,
     pchObs = 1, legend = TRUE, residPlotType = "h", bins = 10,
     line = TRUE, colLine = "red", colHist = "royal blue",
     lwdLine = 2, colPIT1 = "red", colPIT2 = "black",
     ltyPIT1 = 1, ltyPIT2 = 2, typePIT = "l", 
     ltyQQ = 2, colQQ = "black", titles, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.glarma_+3A_x">x</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call to
<code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_which">which</code></td>
<td>
<p>Numeric; if a subset of the plots is required, specify a
subset of the numbers 1:10. 1 is the time series plot with observed
values of the dependent variable, fixed effects fit, and GLARMA
fit. 2 is the ACF plot of residuals. 3 is a plot of residuals
against time. 4 is the normal Q-Q plot. 5 is the PIT histogram. 6
is the uniform Q-Q plot for the PIT. 7 is the histogram of the normal
randomized residuals. 8 is the Q-Q plot of the normal randomized
residuals. 9 is the autocorrelation of the normal randomized
residuals. 10 is the partial autocorrelation of the normal randomized
residuals. By default, plots 1, 3, 5, 7, 8 and 9 are provided.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_fits">fits</code></td>
<td>
<p>Numeric; if a subset of fits on the time series plot is
required, specify a subset of the numbers 1:3. 1 is the observed
values of the dependent variable, 2 is the fixed effects fit, and 3 is
GLARMA fit. By default, all fits are provided.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before each
plot, see <code><a href="graphics.html#topic+par">par</a>(ask = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_lwdobs">lwdObs</code></td>
<td>
<p>Numeric; the line widths for lines of the observed values
of the dependent variable appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_lwdfixed">lwdFixed</code></td>
<td>
<p>Numeric; the line widths for lines of the fixed
effects fit appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_lwdglarma">lwdGLARMA</code></td>
<td>
<p>Numeric; the line widths for lines of GLARMA
fit appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltyobs">ltyObs</code></td>
<td>
<p>An integer or character string; the line types for the
line of the observed data of the dependent variable appearing in the
time series plot, see <code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltyfixed">ltyFixed</code></td>
<td>
<p>An integer or character string; the line types for the
line of the fixed effects fit appearing in the time series plot, see
<code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltyglarma">ltyGLARMA</code></td>
<td>
<p>An integer or character string; the line types for the
line of GLARMA fit appearing in the time series plot, see
<code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_pchobs">pchObs</code></td>
<td>
<p>Numeric; the point type for the point of the observed
data of the dependent variable appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colobs">colObs</code></td>
<td>
<p>Numeric or character; the colour of lines or points of
the observed data of the dependent variable appearing in the time
series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colfixed">colFixed</code></td>
<td>
<p>Numeric or character; the colour of lines of the
fixed effects fit appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colglarma">colGLARMA</code></td>
<td>
<p>Numeric or character; the colour of lines of
GLARMA fit appearing in the time series plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_legend">legend</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the legend for the fits in the
time series plot would be shown. By default, it would be shown.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_residplottype">residPlotType</code></td>
<td>
<p>A 1-character string giving the type of plot
desired. The following values are possible, for details, see
<code><a href="base.html#topic+plot">plot</a></code>: &quot;<code>p</code>&quot; for points, &quot;<code>l</code>&quot; for lines,
&quot;<code>b</code>&quot; for both points and lines, &quot;<code>c</code>&quot; for empty points
joined by lines, &quot;<code>o</code>&quot; for overplotted points and lines,
&quot;<code>s</code>&quot; and &quot;<code>S</code>&quot; for stair steps and &quot;<code>h</code>&quot; for
histogram-like vertical lines. Finally, &quot;<code>n</code>&quot; does not produce
any points or lines.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_bins">bins</code></td>
<td>
<p>Numeric; the number of bins shown in the PIT histogram and
of the number of breaks in the histogram of the normal randomized
residuals. By default, it is 10.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_line">line</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the line for displaying the
standard uniform distribution will be shown for the purpose of
comparison. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colline">colLine</code></td>
<td>
<p>Numeric or character; the colour of the line for
comparison in the PIT histogram.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_lwdline">lwdLine</code></td>
<td>
<p>Numeric; the line widths for the comparison line in
the PIT histogram.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colhist">colHist</code></td>
<td>
<p>Numeric or character; the colour of the histogram for
the PIT, and of the histogram of the normal randomized residuals.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colpit1">colPIT1</code></td>
<td>
<p>Numeric or character; the colour of the sample uniform
Q-Q plot in the PIT.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colpit2">colPIT2</code></td>
<td>
<p>Numeric or character; the colour of the theoretical
uniform Q-Q plot in the PIT.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltypit1">ltyPIT1</code></td>
<td>
<p>An integer or character string; the line types for the
sample uniform Q-Q plot in the PIT, see <code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltypit2">ltyPIT2</code></td>
<td>
<p>An integer or character string; the line types for the
theoretical uniform Q-Q plot in the PIT, see <code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_typepit">typePIT</code></td>
<td>
<p>A 1-character string; the type of plot for the sample
uniform Q-Q plot in the PIT.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_ltyqq">ltyQQ</code></td>
<td>
<p>An integer or character string; the line type for the
normal Q-Q plot of the normal randomized residuals, see
<code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_colqq">colQQ</code></td>
<td>
<p>Numeric or character; the colour of the line in the normal 
Q-Q plot of the normal randomized residuals.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_titles">titles</code></td>
<td>
<p>A list of the same length as <code>which</code>. For any
elements which are <code>NULL</code>, useful titles will be created for the
corresponding plot.</p>
</td></tr>
<tr><td><code id="plot.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> and
<code><a href="stats.html#topic+plot.ts">plot.ts</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.glarma</code> is an S3 generic function for objects of class
<code>glarma</code>.
</p>
<p>The plots in this method display the fixed effects fit, GLARMA fit and
various types of residuals for the GLARMA fit under the Poisson
distribution, the binomial distribution or the negative binomial
distribution, plus a number of plots of the randomized residuals (see
<code><a href="#topic+normRandPIT">normRandPIT</a></code> for details of the randomized residuals). In
all, ten plots can be produced. The observed values of the dependent
variable shown in the time series plot are mainly used to compare with
the two fits.
</p>
<p>The fixed effects fit is calculated from <code class="reqn">\eta</code>, the
multiplication of the data matrix <code>X</code> and <code class="reqn">\beta</code>
coefficients in GLARMA model. In contrast, the GLARMA fit is
calculated from <code class="reqn">W</code>, the product of the data matrix <code>X</code>
and <code class="reqn">\delta</code> in the GLARMA model, which is the combination
of both the <code class="reqn">\beta</code> and ARMA coefficients, and is also
called the state variable of the series.
</p>
<p>There are some major differences for computing the fixed effects fit
from <code class="reqn">\eta</code> and the GLARMA fit from <code class="reqn">W</code> under
different distributions.
</p>
<p>Under the Poisson distribution and negative binomial distribution,
</p>
<p style="text-align: center;"><code class="reqn">\mathsf{fit}_{\mathsf{fixed}} = \exp{\eta}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mathsf{fit}_{\mathsf{glarma}} = \exp{W}.</code>
</p>

<p>Under the binomial distribution,
</p>
<p style="text-align: center;"><code class="reqn">\mathsf{fit}_{\mathsf{fixed}} = \frac{1}{(1+e^{-\eta})}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mathsf{fit}_{\mathsf{glarma}} = \frac{1}{(1+e^{-W})}.</code>
</p>

<p>The residuals are calculated from the observed data and GLARMA
fit. The exact computation for the residuals depends on the type
of residuals used. The details are given in
<code><a href="#topic+glarma">glarma</a></code>. The ACF plot, the residuals against time and
the normal Q-Q plot are all based on these residuals. Further details
about those three plots are passed to <code><a href="stats.html#topic+acf">acf</a></code> and
<code><a href="stats.html#topic+qqnorm">qqnorm</a></code>.
</p>
<p>There are four plots based on the randomized residuals calculated
using <code><a href="#topic+normRandPIT">normRandPIT</a></code>. These are a histogram, a Q-Q plot,
an autocorrelation plot and a partial autocorrelation plot.
</p>
<p>The number of plots to be shown in the window depends on the value of
the graphical parameter <code>mfrow</code> (or <code>mfcol</code>). If the
displayed window is set to be large enough to show all ten plots,
they will be shown at one time. Otherwise, the required number of
plots will appear each time in the displayed window, and the user
will need to enter <code>return</code> to see subsequent plots. By default,
six plots are produced.
</p>
<p>For the time series plot in the function, the fit displayed is
specified by the argument <code>fits</code>. The legend will be shown if
<code>legend</code> is <code>TRUE</code>. It will appear under the title
of the time series plot. Also the legend and the title will alter
automatically according to the fits shown in the plot.
</p>


<h3>Author(s)</h3>

<p>&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="stats.html#topic+acf">acf</a></code>,
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="#topic+normRandPIT">normRandPIT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### A example from Davis, Dunsmuir Wang (1999)
## MA(1,2,5), Pearson Residuals, Fisher Scoring
data(Polio)
y &lt;- Polio[, 2]
X &lt;- as.matrix(Polio[, 3:8])
glarmamod &lt;- glarma(y, X, thetaLags = c(1, 2, 5), type = "Poi",method = "FS",
                    residuals = "Pearson", maxit = 100 , grad = 1e-6)

## The default plots are shown
plot(glarmamod)

## The plots used only to compared GLARMA fit and the observed data
plot(glarmamod, which = 1L, fits = c(1, 3))
</code></pre>

<hr>
<h2 id='plotPIT'>
PIT Plots for a <code>glarma</code> Object
</h2><span id='topic+histPIT'></span><span id='topic+qqPIT'></span>

<h3>Description</h3>

<p>Two plots for the non-randomized PIT are currently available for
checking the distributional assumption of the fitted GLARMA model: the
PIT histogram, and the uniform Q-Q plot for PIT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histPIT(object, bins = 10, line = TRUE, colLine = "red",
        colHist = "royal blue", lwdLine = 2, main = NULL, ...)
qqPIT(object, bins = 10, col1 = "red", col2 = "black",
      lty1 = 1, lty2 = 2, type = "l", main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPIT_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a
call to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_bins">bins</code></td>
<td>
<p>Numeric; the number of bins shown in the PIT
histogram or the PIT Q-Q plot. By default, it is 10.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_line">line</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the line for displaying the
standard uniform distribution will be shown for the purpose of
comparison. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_colline">colLine</code></td>
<td>
<p>Numeric or character; the colour of the line for
comparison in PIT histogram.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_lwdline">lwdLine</code></td>
<td>
<p>Numeric; the line widths for the comparison line in
PIT histogram.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_colhist">colHist</code></td>
<td>
<p>Numeric or character; the colour of the histogram for
PIT.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_col1">col1</code></td>
<td>
<p>Numeric or character; the colour of the sample uniform
Q-Q plot in PIT.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_col2">col2</code></td>
<td>
<p>Numeric or character; the colour of the theoretical
uniform Q-Q plot in PIT.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_lty1">lty1</code></td>
<td>
<p>An integer or character string; the line types for the
sample uniform Q-Q plot in PIT, see <code><a href="graphics.html#topic+par">par</a>(lty = .)</code>.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_lty2">lty2</code></td>
<td>
<p>An integer or character string; the line types for the
theoretical uniform Q-Q plot in PIT, see <code><a href="graphics.html#topic+par">par</a>(lty =
    .)</code>.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_type">type</code></td>
<td>
<p>A 1-character string; the type of plot for the sample
uniform Q-Q plot in PIT.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_main">main</code></td>
<td>
<p>A character string giving a title. For each plot the
default provides a useful title.</p>
</td></tr>
<tr><td><code id="plotPIT_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
and <code><a href="stats.html#topic+plot.ts">plot.ts</a></code>.</p>
</td></tr>  </table>


<h3>Details</h3>

<p>The histogram and the Q-Q plot are used to compare the fitted profile
with <b>U</b>(0, 1). If they match relatively well, it means the
distributional assumption is satisfied.
</p>


<h3>Author(s)</h3>

<p>&quot;David J. Scott&quot; &lt;d.scott@auckland.ac.nz&gt; and
&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>References</h3>

<p>Czado, Claudia and Gneiting, Tilmann and Held, Leonhard (2009)
Predictive model assessment for count data. <em>Biometrics</em>,
<b>65</b>, 1254&ndash;1261.
</p>
<p>Jung, Robert.C and Tremayne, A.R (2011) Useful models for time series
of counts or simply wrong ones? <em>AStA Advances in Statistical
Analysis</em>, <b>95</b>, 59&ndash;91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(plot.glarma)
</code></pre>

<hr>
<h2 id='Polio'>Cases of Poliomyelitis in the U.S.</h2><span id='topic+Polio'></span>

<h3>Description</h3>

<p>This data set gives the monthly number of cases of poliomyelitis in
the U.S. for the years 1970&ndash;1983 as reported by the Center for
Disease Control. The polio data frame has 168 rows and 8 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Polio)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
  [, 1]</td><td style="text-align: left;"> Cases </td><td style="text-align: left;"> monthly number of cases of poliomyelitis.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 2]</td><td style="text-align: left;"> Intcpt </td><td style="text-align: left;"> a vector of ones, providing the intercept in
   the model.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 3]</td><td style="text-align: left;"> Trend </td><td style="text-align: left;"> a linear trend.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 4]</td><td style="text-align: left;"> CosAnnual </td><td style="text-align: left;"> cosine harmonics at periods of 12.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 5]</td><td style="text-align: left;"> SinAnnual </td><td style="text-align: left;"> sine harmonics at periods of 12.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 6]</td><td style="text-align: left;"> CosSemiAnnual </td><td style="text-align: left;"> cosine harmonics at periods of 6.</td>
</tr>
<tr>
 <td style="text-align: right;">
  [, 7]</td><td style="text-align: left;"> SinSemiAnnual </td><td style="text-align: left;"> sine harmonics at periods of 6.</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Zeger, S.L (1988) A regression model for time series of
counts. <em>Biometrika</em>, <b>75</b>, 621&ndash;629.
</p>

<hr>
<h2 id='residuals.glarma'>Extract GLARMA Model Residuals</h2><span id='topic+residuals.glarma'></span><span id='topic+resid.glarma'></span>

<h3>Description</h3>

<p><code>residuals</code> is a generic function which extracts model residuals
from objects returned by the modeling function
<code><a href="#topic+glarma">glarma</a></code>. <code>resid</code> is an alias for <code>residuals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, a result of a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals extracted from the object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt; and
&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefficients.glarma">coefficients.glarma</a></code>, <code><a href="#topic+fitted.glarma">fitted.glarma</a></code>,
<code><a href="#topic+glarma">glarma</a></code>.
</p>

<hr>
<h2 id='RobberyConvict'>
Court Convictions for Armed Robbery in New South Wales
</h2><span id='topic+RobberyConvict'></span>

<h3>Description</h3>

<p>Monthly counts of charges laid and convictions made in Local Courts
and Higher Court in armed robbery in New South Wales from 1995&ndash;2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RobberyConvict)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">

  [, 1]</td><td style="text-align: left;"> Date </td><td style="text-align: left;"> Date in month/year format.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 2]</td><td style="text-align: left;"> Incpt </td><td style="text-align: left;"> A vector of ones, providing the intercept in the
  model.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 3]</td><td style="text-align: left;"> Trend </td><td style="text-align: left;"> Scaled time trend.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 4]</td><td style="text-align: left;"> Step.2001 </td><td style="text-align: left;"> Unit step change from 2001 onwards.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 5]</td><td style="text-align: left;"> Trend.2001 </td><td style="text-align: left;"> Change in trend term from 2001 onwards.</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 6]</td><td style="text-align: left;"> HC.N </td><td style="text-align: left;"> Monthly number of cases for robbery (Higher
  Court).</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 7]</td><td style="text-align: left;"> HC.Y </td><td style="text-align: left;"> Monthly number of convictions for robbery
  (Higher court).</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 8]</td><td style="text-align: left;"> HC.P </td><td style="text-align: left;"> Proportion of convictions to charges for robbery
  (Higher court).</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 9]</td><td style="text-align: left;"> LC.N </td><td style="text-align: left;"> Monthly number of cases for robbery (Lower
  court).</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 10]</td><td style="text-align: left;"> LC.Y </td><td style="text-align: left;"> Monthly number of convictions for robbery
  (Lower court).</td>
</tr>
<tr>
 <td style="text-align: right;">

  [, 11]</td><td style="text-align: left;"> LC.P </td><td style="text-align: left;"> Proportion of convictions to charges for
  robbery (Lower court).</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Source</h3>

<p>Dunsmuir, William TM, Tran, Cuong, and Weatherburn, Don (2008)
<em>Assessing the Impact of Mandatory DNA Testing of Prison Inmates
in NSW on Clearance, Charge and Conviction Rates for Selected Crime
Categories.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with Robbery Convictions
data(RobberyConvict)
datalen &lt;- dim(RobberyConvict)[1]
monthmat &lt;- matrix(0, nrow = datalen, ncol = 12)
dimnames(monthmat) &lt;- list(NULL, c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
months &lt;- unique(months(strptime(RobberyConvict$Date, format = "%m/%d/%Y"),
                        abbreviate=TRUE))


for (j in 1:12) {
  monthmat[months(strptime(RobberyConvict$Date,  "%m/%d/%Y"),
                  abbreviate = TRUE) == months[j], j] &lt;-1
}

RobberyConvict &lt;- cbind(rep(1, datalen), RobberyConvict, monthmat)
rm(monthmat)

## LOWER COURT ROBBERY
y1 &lt;- RobberyConvict$LC.Y
n1 &lt;- RobberyConvict$LC.N

Y &lt;- cbind(y1, n1-y1)

glm.LCRobbery &lt;- glm(Y ~ Step.2001 +
                        I(Feb + Mar + Apr + May + Jun + Jul) +
                        I(Aug + Sep + Oct + Nov + Dec),
                     data = RobberyConvict, family = binomial(link = logit),
                     na.action = na.omit, x = TRUE)

summary(glm.LCRobbery, corr = FALSE)

X &lt;- glm.LCRobbery$x


## Newton Raphson
glarmamod &lt;- glarma(Y, X, phiLags = c(1), type = "Bin", method = "NR",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)

## LRT, Wald tests.
likTests(glarmamod)

## Residuals and Fit Plots
plot.glarma(glarmamod)


## HIGHER COURT ROBBERY
y1 &lt;- RobberyConvict$HC.Y
n1 &lt;- RobberyConvict$HC.N

Y &lt;- cbind(y1, n1-y1)

glm.HCRobbery &lt;- glm(Y ~ Trend + Trend.2001 +
                       I(Feb + Mar + Apr + May + Jun) + Dec,
                     data = RobberyConvict, family = binomial(link = logit),
                     na.action = na.omit, x = TRUE)

summary(glm.HCRobbery,corr = FALSE)

X &lt;- glm.HCRobbery$x


## Newton Raphson
glarmamod &lt;- glarma(Y, X, phiLags = c(1, 2, 3), type = "Bin", method = "NR",
                    residuals = "Pearson", maxit = 100, grad = 1e-6)
glarmamod
summary(glarmamod)


## LRT, Wald tests.
likTests(glarmamod)

## Residuals and Fit Plots
plot.glarma(glarmamod)
</code></pre>

<hr>
<h2 id='summary.glarma'>Summarize GLARMA Fit</h2><span id='topic+summary.glarma'></span><span id='topic+print.summary.glarma'></span><span id='topic+glarmaModelEstimates'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>glarma</code> and functions to
generate the estimates for this <code>summary</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glarma'
summary(object, tests = TRUE, ...)
## S3 method for class 'summary.glarma'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
glarmaModelEstimates(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.glarma_+3A_object">object</code></td>
<td>
<p>An object of class <code>"glarma"</code>, obtained from a call
to <code><a href="#topic+glarma">glarma</a></code>.</p>
</td></tr>
<tr><td><code id="summary.glarma_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.glarma"</code>, obtained from a
call to <code>summary.glarma</code>.</p>
</td></tr>
<tr><td><code id="summary.glarma_+3A_digits">digits</code></td>
<td>
<p>Numeric; minimum number of significant digits to be used
for most numbers.</p>
</td></tr>
<tr><td><code id="summary.glarma_+3A_tests">tests</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the likelihood-ratio test and
the Wald test are shown in the summary. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.glarma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.glarma</code> returns an object of class
<code>"summary.glarma"</code>, a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the component from <code>object</code></p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>null deviance of the GLM with the same regression
structure as the GLARMA model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>null degrees of freedom of the GLM with the same
regression structure as the GLARMA model.</p>
</td></tr>
<tr><td><code>phi.lags</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>theta.lags</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>pq</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance of the fitted model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the degrees of freedom of the fitted model.</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>methods</code></td>
<td>
<p>vector specifying the count distribution of the
GLARMA model, the iteration method and the type of residual used.</p>
</td></tr>
<tr><td><code>tests</code></td>
<td>
<p>whether tests were asked for.</p>
</td></tr>
<tr><td><code>likTests</code></td>
<td>
<p>if <code>tests</code> is <code>TRUE</code>, the result of a call
to <code>likTests</code>, <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>coefficients1</code></td>
<td>
<p>the matrix of beta coefficients, standard
errors, z-ratio and p-values.</p>
</td></tr>
<tr><td><code>coefficients2</code></td>
<td>
<p>the matrix of ARMA coefficients, standard
errors, z-ratio and p-values.</p>
</td></tr>
<tr><td><code>coefficients3</code></td>
<td>
<p>when the count distribution is negative binomial,
a matrix with 1 row, giving the negative binomial parameter, its
standard error, z-ratio and p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>&quot;William T.M. Dunsmuir&quot; &lt;w.dunsmuir@unsw.edu.au&gt; and
&quot;Cenanning Li&quot; &lt;cli113@aucklanduni.ac.nz&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glarma">glarma</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For examples see example(glarma)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
