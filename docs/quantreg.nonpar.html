<!DOCTYPE html><html><head><title>Help for package quantreg.nonpar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quantreg.nonpar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ddpoly'>
<p>Compute Second Derivative of Orthogonal Polynomials</p></a></li>
<li><a href='#dpoly'>
<p>Compute Derivative of Orthogonal Polynomials</p></a></li>
<li><a href='#formulaDeriv'>
<p>Derivative of Right Hand Side of Formula</p></a></li>
<li><a href='#gaus'>
<p>Gaussian Process Inference for NPQR</p></a></li>
<li><a href='#gbootstrap'>
<p>Gradient Bootstrap Inference for NPQR</p></a></li>
<li><a href='#india'>
<p>Childhood Malnutrition in India</p></a></li>
<li><a href='#load.sum'>
<p>Appropriate Summary Statistics for Factors, Ordered Factors, and Numeric Variables</p></a></li>
<li><a href='#msqrt'>
<p>Square Root of Matrix by Spectral Decomposition</p></a></li>
<li><a href='#no.process'>
<p>Estimation for NPQR with No Inference</p></a></li>
<li><a href='#npqr'>
<p>Nonparametric Series Quantile Regression</p></a></li>
<li><a href='#pivotal'>
<p>Pivotal Process Inference for NPQR</p></a></li>
<li><a href='#poly.wrap'>
<p>Orthogonal Polynomial Wrapper</p></a></li>
<li><a href='#quantreg.nonpar-package'>
<p>Nonparametric Series Quantile Regression</p></a></li>
<li><a href='#removeI'>
<p>Remove I() Tags From Formula</p></a></li>
<li><a href='#wbootstrap'>
<p>Weighted Bootstrap Inference for NPQR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Series Quantile Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-03-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Fernandez-Val &lt;ivanf@bu.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), quantreg, mnormt, fda, Rearrangement</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the nonparametric quantile regression method developed by Belloni, Chernozhukov, and Fernandez-Val (2011) to partially linear quantile models. Provides point estimates of the conditional quantile function and its derivatives based on series approximations to the nonparametric part of the model. Provides pointwise and uniform confidence intervals using analytic and resampling methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-01 01:04:28 UTC; clairepeyser</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-01 14:26:39</td>
</tr>
</table>
<hr>
<h2 id='ddpoly'>
Compute Second Derivative of Orthogonal Polynomials
</h2><span id='topic+ddpoly'></span>

<h3>Description</h3>

<p>Returns or evaluates the second derivatives of orthogonal polynomials of degree 1 to <code>degree</code> over the specified set of points <code>x</code>: the polynomials are all orthogonal to the constant polynomial of degree 0. Alternatively, evaluates the second derivatives of raw polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddpoly(x, ..., degree = 1, coefs = NULL, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddpoly_+3A_x">x</code></td>
<td>

<p>a numeric vector at which to evaluate the polynomial. <code>x</code> can also be a matrix. Missing values are not allowed in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="ddpoly_+3A_...">...</code></td>
<td>

<p>further vectors.
</p>
</td></tr>
<tr><td><code id="ddpoly_+3A_degree">degree</code></td>
<td>

<p>the degree of the polynomial. Must be less than the number of unique points if <code>raw = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ddpoly_+3A_coefs">coefs</code></td>
<td>

<p>for prediction, coefficients from a previous fit.
</p>
</td></tr>
<tr><td><code id="ddpoly_+3A_raw">raw</code></td>
<td>

<p>if true, use raw and not orthogonal polynomials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with rows corresponding to points in <code>x</code> and columns corresponding to the degree, with attributes <code>"degree"</code> specifying the degrees of the columns (prior to taking the derivatives) and (unless <code>raw = TRUE</code>) <code>"coefs"</code> which contains the centering and normalization constants used in constructing the orthogonal polynomials. The matrix has been given class <code>c("poly","matrix")</code>.
</p>


<h3>Note</h3>

<p>Both the code and the description of <code>ddpoly</code> borrow heavily from the <code>poly</code> command in the <code>stats</code> package.
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Chambers, J.M. and Hastie, T.J. (1992) Statistical Models in S. Wadsworth &amp; Brooks/Cole.
Kennedy, W.J. Jr and Gentle, J.E. (1980) Statistical Computing. Marcel Dekker.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="#topic+dpoly">dpoly</a></code>
</p>

<hr>
<h2 id='dpoly'>
Compute Derivative of Orthogonal Polynomials
</h2><span id='topic+dpoly'></span>

<h3>Description</h3>

<p>Returns or evaluates the first derivatives of orthogonal polynomials of degree 1 to <code>degree</code> over the specified set of points <code>x</code>: the polynomials are all orthogonal to the constant polynomial of degree 0. Alternatively, evaluates the first derivatives of raw polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoly(x, ..., degree = 1, coefs = NULL, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpoly_+3A_x">x</code></td>
<td>

<p>a numeric vector at which to evaluate the polynomial. <code>x</code> can also be a matrix. Missing values are not allowed in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="dpoly_+3A_...">...</code></td>
<td>

<p>further vectors.
</p>
</td></tr>
<tr><td><code id="dpoly_+3A_degree">degree</code></td>
<td>

<p>the degree of the polynomial. Must be less than the number of unique points if <code>raw = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="dpoly_+3A_coefs">coefs</code></td>
<td>

<p>for prediction, coefficients from a previous fit.
</p>
</td></tr>
<tr><td><code id="dpoly_+3A_raw">raw</code></td>
<td>

<p>if true, use raw and not orthogonal polynomials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with rows corresponding to points in <code>x</code> and columns corresponding to the degree, with attributes <code>"degree"</code> specifying the degrees of the columns (prior to taking the derivative) and (unless <code>raw = TRUE</code>) <code>"coefs"</code> which contains the centering and normalization constants used in constructing the orthogonal polynomials. The matrix has been given class <code>c("poly","matrix")</code>.
</p>


<h3>Note</h3>

<p>Both the code and the description of <code>dpoly</code> borrow heavily from the <code>poly</code> command in the <code>stats</code> package.
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Chambers, J.M. and Hastie, T.J. (1992) Statistical Models in S. Wadsworth &amp; Brooks/Cole.
Kennedy, W.J. Jr and Gentle, J.E. (1980) Statistical Computing. Marcel Dekker.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="#topic+ddpoly">ddpoly</a></code>
</p>

<hr>
<h2 id='formulaDeriv'>
Derivative of Right Hand Side of Formula
</h2><span id='topic+formulaDeriv'></span>

<h3>Description</h3>

<p>Takes the symbolic derivative (or multiple derivatives) of the right hand side of a formula and returns a matrix with the derivative evaluated at each observation in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulaDeriv(inFormula, derivVar, data, nDerivs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formulaDeriv_+3A_informula">inFormula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="formulaDeriv_+3A_derivvar">derivVar</code></td>
<td>

<p>a character object giving the name of the variable with respect to which the derivative will be taken.
</p>
</td></tr>
<tr><td><code id="formulaDeriv_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> and <code>derivVar</code> arguments.
</p>
</td></tr>
<tr><td><code id="formulaDeriv_+3A_nderivs">nDerivs</code></td>
<td>

<p>an integer: the number of derivatives to be taken.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>formulaDeriv</code> returns a matrix whose dimensions are the number of observations in <code>data</code> and the number of variables on the right hand side of <code>formula</code>. Each row is the derivative of <code>formula</code> evaluated at the corresponding observation in <code>data</code>
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='gaus'>
Gaussian Process Inference for NPQR
</h2><span id='topic+gaus'></span>

<h3>Description</h3>

<p>A method for the generic function <code><a href="#topic+npqr">npqr</a></code>. It computes, via a Gaussian method, the t-statistic used to conduct inference in nonparametric series quantile regression models, as well as outputting confidence intervals and hypothesis test p-values at a user-specified level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaus(data = data, B = B, taus, formula, basis = NULL, alpha=0.05, 
	var, load, rearrange=F, rearrange.vars="quantile", uniform=F, 
	se="unconditional", average = T, nderivs = 1, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaus_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_b">B</code></td>
<td>

<p>the number of simulations to be performed.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_taus">taus</code></td>
<td>

<p>a numerical vector, whose entries are strictly between 0 and 1, containing the quantile indexes  of interest for the quantile effects.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_basis">basis</code></td>
<td>

<p>either a basis generated using the <code>fda</code> package of type &quot;bspline&quot; or &quot;fourier&quot;, a factor variable, or an orthogonal polynomial basis generated using the <code>poly</code> command. This basis is the series regressor to be added to <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_alpha">alpha</code></td>
<td>

<p>a real number between 0 and 1: the desired significance level (e.g., 0.05).
</p>
</td></tr>
<tr><td><code id="gaus_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="gaus_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized prior to performing inference (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="gaus_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_uniform">uniform</code></td>
<td>

<p>a boolean specifying whether inference will be uniform across observations and quantiles or done in a pointwise manner.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_se">se</code></td>
<td>

<p>either &quot;conditional&quot; or &quot;unconditional&quot;. Specifies whether standard errors, for pivotal and gaussian processes, will be conditional on the sample or not.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_nderivs">nderivs</code></td>
<td>

<p>the number of derivatives of the conditional quantile function upon which inference should be performed.
</p>
</td></tr>
<tr><td><code id="gaus_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gaus</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>qfits</code></td>
<td>
<p>a list whose length is equal to the length of <code>taus</code>. Each element is an <code>rq.object</code> returned by <code>rq</code> for the corresponding quantile.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>an array containing the two-sided confidence interval for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper bounds of the confidence interval, respectively.</p>
</td></tr>
<tr><td><code>CI.oneSided</code></td>
<td>
<p>an array containing the one-sided confidence bounds for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper confidence bounds, respectively.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a matrix containing estimated standard errors for the quantile regression point estimates for each pair of loading vectors and <code>taus</code>.  Depending on user selections, these may be conditional on the sample or unconditional. The array is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a vector containing the p-values for hypothesis tests of three null hypotheses. First, that theta(tau,w) &lt;= 0 for all (tau,w) pairs, where theta is the quantity of interest (e.g., the derivative of the function at each quantile and at each observation). Second, that theta(tau,w) &gt;= 0 for all (tau,w) pairs. Third, that theta(tau,w) = 0 for all (tau,w) pairs.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which inference was performed and over which hypothesis tests were conducted. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv:1105.6154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='gbootstrap'>
Gradient Bootstrap Inference for NPQR
</h2><span id='topic+gbootstrap'></span>

<h3>Description</h3>

<p>A method for the generic function <code><a href="#topic+npqr">npqr</a></code>. It computes, via a gradient bootstrap method, the t-statistic used to conduct inference in nonparametric series quantile regression models, as well as outputting confidence intervals and hypothesis test p-values at a user-specified level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbootstrap(data = data, B = B, taus, formula, basis = NULL, alpha = 0.05, 
	var, load, rearrange=F, rearrange.vars="quantile", uniform=F, 
	average=T, nderivs=1, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbootstrap_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_b">B</code></td>
<td>

<p>the number of bootstrap repetitions to be performed.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_taus">taus</code></td>
<td>

<p>a numerical vector, whose entries are strictly between 0 and 1, containing the quantile indexes  of interest.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_basis">basis</code></td>
<td>

<p>either a basis generated using the <code>fda</code> package of type &quot;bspline&quot; or &quot;fourier&quot;, a factor variable, or an orthogonal polynomial basis generated using the <code>poly</code> command. This basis is the series regressor to be added to <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_alpha">alpha</code></td>
<td>

<p>a real number between 0 and 1: the desired significance level (e.g., 0.05).
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized prior to performing inference (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_uniform">uniform</code></td>
<td>

<p>a boolean specifying whether inference will be uniform across observations and quantiles or done in a pointwise manner.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_nderivs">nderivs</code></td>
<td>

<p>the number of derivatives of the conditional quantile function upon which inference should be performed.
</p>
</td></tr>
<tr><td><code id="gbootstrap_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gbootstrap</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>qfits</code></td>
<td>
<p>a list whose length is equal to the length of <code>taus</code>. Each element is an <code>rq.object</code> returned by <code>rq</code> for the corresponding quantile.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>an array containing the two-sided confidence interval for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper bounds of the confidence interval, respectively.</p>
</td></tr>
<tr><td><code>CI.oneSided</code></td>
<td>
<p>an array containing the one-sided confidence bounds for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper confidence bounds, respectively.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a matrix containing estimated standard errors for the quantile regression point estimates for each pair of loading vectors and <code>taus</code>.  The array is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a vector containing the p-values for hypothesis tests of three null hypotheses. First, that theta(tau,w) &lt;= 0 for all (tau,w) pairs, where theta is the quantity of interest (e.g., the derivative of the function at each quantile and at each observation). Second, that theta(tau,w) &gt;= 0 for all (tau,w) pairs. Third, that theta(tau,w) = 0 for all (tau,w) pairs.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which inference was performed and over which hypothesis tests were conducted. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv:1105.6154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='india'>
Childhood Malnutrition in India
</h2><span id='topic+india'></span>

<h3>Description</h3>

<p>Demographic and Health Survey data on childhood nutrition in India.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(india)</code></pre>


<h3>Format</h3>

<p>A data frame with 37623 observations on the following 21 variables.
</p>

<dl>
<dt><code>cheight</code></dt><dd><p>child's height (centimeters); a numeric vector</p>
</dd>
<dt><code>cage</code></dt><dd><p>child's age (months); a numeric vector</p>
</dd>
<dt><code>breastfeeding</code></dt><dd><p>duration of breastfeeding (months); a numeric vector</p>
</dd>
<dt><code>csex</code></dt><dd><p>child's sex; a factor with levels <code>male</code> <code>female</code></p>
</dd>
<dt><code>ctwin</code></dt><dd><p>whether or not child is a twin; a factor with levels <code>single birth</code> <code>twin</code></p>
</dd>
<dt><code>cbirthorder</code></dt><dd><p>birth order of the child; a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code></p>
</dd>
<dt><code>mbmi</code></dt><dd><p>mother's BMI (kilograms per meter squared); a numeric vector</p>
</dd>
<dt><code>mage</code></dt><dd><p>mother's age (years); a numeric vector</p>
</dd>
<dt><code>medu</code></dt><dd><p>mother's years of education; a numeric vector</p>
</dd>
<dt><code>edupartner</code></dt><dd><p>father's years of education; a numeric vector</p>
</dd>
<dt><code>munemployed</code></dt><dd><p>mother's employment status; a factor variable with levels <code>unemployed</code> <code>employed</code></p>
</dd>
<dt><code>mreligion</code></dt><dd><p>mother's religion; a factor variable with levels <code>christian</code> <code>hindu</code> <code>muslim</code> <code>other</code> <code>sikh</code></p>
</dd>
<dt><code>mresidence</code></dt><dd><p>mother's residential classification; a factor with levels <code>urban</code> <code>rural</code></p>
</dd>
<dt><code>wealth</code></dt><dd><p>mother's relative wealth; a factor with levels <code>poorest</code> <code>poorer</code> <code>middle</code> <code>richer</code> <code>richest</code></p>
</dd>
<dt><code>electricity</code></dt><dd><p>electricity access; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>radio</code></dt><dd><p>radio ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>television</code></dt><dd><p>television ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>refrigerator</code></dt><dd><p>refrigerator ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>bicycle</code></dt><dd><p>bicycle ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>motorcycle</code></dt><dd><p>motorcycle ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>car</code></dt><dd><p>car ownership; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.econ.uiuc.edu/~roger/research/bandaids/india.Rda
</p>


<h3>References</h3>

<p>Koenker, R. (2011), &quot;Additive models for quantile regression: Model selection and confidence bandaids,&quot; Brazilian Journal of Probability and Statistics 25(3), pp. 239-262.
</p>

<hr>
<h2 id='load.sum'>
Appropriate Summary Statistics for Factors, Ordered Factors, and Numeric Variables
</h2><span id='topic+load.sum'></span>

<h3>Description</h3>

<p>Returns the medians of a vector of ordered factor variables, the modes of a vector of unordered factor variables, and the means of a vector of numeric variables.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.sum(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.sum_+3A_vec">vec</code></td>
<td>

<p>A vector of ordered factor variables, a vector of unordered factor variables, or a vector of numeric variables.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>load.sum</code> returns the medians of a vector of ordered factor variables, the mode of a vector of unordered factor variables, and the mean of a vector of numeric variables.
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='msqrt'>
Square Root of Matrix by Spectral Decomposition
</h2><span id='topic+msqrt'></span>

<h3>Description</h3>

<p>Obtains the square root of a symmetric matrix by spectral decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msqrt(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msqrt_+3A_a">a</code></td>
<td>

<p>a matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>msqrt</code> returns the square root of a symmetric matrix, obtained via spectral decomposition
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='no.process'>
Estimation for NPQR with No Inference
</h2><span id='topic+no.process'></span>

<h3>Description</h3>

<p>A method for the generic function <code><a href="#topic+npqr">npqr</a></code>. It computes the quantile regression fits without performing inference</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.process(data = data, taus, formula, basis = NULL, 
	var, load, rearrange=F, rearrange.vars="quantile", 
	average=T, nderivs=1, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no.process_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_taus">taus</code></td>
<td>

<p>a numerical vector, whose entries are strictly between 0 and 1, containing the quantile indexes  of interest.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_basis">basis</code></td>
<td>

<p>either a basis generated using the <code>fda</code> package of type &quot;bspline&quot; or &quot;fourier&quot;, a factor variable, or an orthogonal polynomial basis generated using the <code>poly</code> command. This basis is the series regressor to be added to <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="no.process_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="no.process_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_nderivs">nderivs</code></td>
<td>

<p>the number of derivatives of the conditional quantile function upon which point estimates should be generated.
</p>
</td></tr>
<tr><td><code id="no.process_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>no.process</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>qfits</code></td>
<td>
<p>a list whose length is equal to the length of <code>taus</code>. Each element is an <code>rq.object</code> returned by <code>rq</code> for the corresponding quantile.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which point estimates were generated. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv:1105.6154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='npqr'>
Nonparametric Series Quantile Regression
</h2><span id='topic+npqr'></span>

<h3>Description</h3>

<p>Implements the nonparametric quantile regression methods developed by Belloni, Chernozhukov, and Fernandez-Val (2011) to partially linear quantile models, <code class="reqn">Y=g(w,u)+v'\gamma(u)</code>, <code class="reqn">u|v,w~U[0,1]</code>. Provides point estimates of the conditional quantile function and its derivatives based on series approximations to the nonparametric part of the model, <code class="reqn">g(w,u)</code>, approximated by <code class="reqn">Z(w)'\beta(u)</code>. Provides pointwise and uniform confidence intervals using analytic and resampling methods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>npqr(formula, data, basis = NULL, var, taus = c(0.25, 0.5, 0.75), 
	print.taus = NULL, B = 200, nderivs = 1, average = T, 
	load = NULL, alpha = 0.05, process = "pivotal", rearrange = F, 
	rearrange.vars="quantile", uniform = F, se = "unconditional", 
	printOutput = T, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npqr_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> and <code>var</code> arguments.  Observations in <code>data</code> used to construct the loading vector (either manually or automatically) will be hereafter referred to as w.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_basis">basis</code></td>
<td>

<p>a nonparametric basis object (created with the package <code>fda</code>), an orthogonal polynomial basis of class <code>"poly"</code>, or a factor variable that will be used to estimate the effect of <code>var</code>.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_taus">taus</code></td>
<td>

<p>a vector of quantiles of interest.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_print.taus">print.taus</code></td>
<td>

<p>a vector of quantiles (which must be a subset of <code>taus</code>), estimates for which will be printed as output.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_b">B</code></td>
<td>

<p>the number of simulations (for the pivotal and gaussian methods) or bootstrap repetitions (for the weighted bootstrap and gradient bootstrap methods) to be performed.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_nderivs">nderivs</code></td>
<td>

<p>if <code>load</code> is not input, the number of derivatives of the conditional quantile function upon which inference should be performed.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="npqr_+3A_alpha">alpha</code></td>
<td>

<p>a real number between 0 and 1: the desired significance level (e.g., 0.05).
</p>
</td></tr>
<tr><td><code id="npqr_+3A_process">process</code></td>
<td>

<p>either &quot;pivotal&quot;, &quot;gaussian&quot;, &quot;wbootstrap&quot;, &quot;gbootstrap&quot;, or &quot;none&quot;: specifies the process used to estimate confidence intervals and p-values of hypothesis tests (or, if <code>process = "none"</code>, specifies that inference should not be performed).
</p>
</td></tr>
<tr><td><code id="npqr_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized prior to performing inference (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="npqr_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_uniform">uniform</code></td>
<td>

<p>a boolean specifying whether inference will be done uniformly across observations and quantiles or in a pointwise manner.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_se">se</code></td>
<td>

<p>either &quot;conditional&quot; or &quot;unconditional&quot;. Specifies whether standard errors, for pivotal and gaussian methods, will be conditional on the sample or not.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_printoutput">printOutput</code></td>
<td>

<p>a boolean specifying whether or not output will be printed.
</p>
</td></tr>
<tr><td><code id="npqr_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loading vector may be specified in one of two ways: it may be input manually with <code>load</code>. If <code>load</code> is not specified, the loading vector will be calculated automatically using <code>average</code> and <code>nderivs</code> as parameters.
</p>
<p>Note that derivatives calculated automatically will always be with respect to the nonparametric variable of interest, <code>var</code>. This means that, for example, if <code>var=logprice</code>, where <code>logprice</code> is the natural logarithm of price, then the derivative will be taken with respect to <code>logprice</code>, not with respect to <code>price</code>.  Specification of <code>var</code> will not admit mathematical functions such as <code>log</code>.  Specification of <code>formula</code> will admit some functions (e.g., <code>log</code>, multiplication of covariates, interaction of covariates). However, formula will not admit some formula operators; in particular, factor variables must be saved as new variables prior to entry into formula. See the vignette for more information.
</p>


<h3>Value</h3>

<p>returns a list of results
</p>
<table>
<tr><td><code>CI</code></td>
<td>
<p>an array containing the two-sided confidence interval for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper bounds of the confidence interval, respectively.</p>
</td></tr>
<tr><td><code>CI.oneSided</code></td>
<td>
<p>an array containing the one-sided confidence bounds for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper confidence bounds, respectively.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the conditional quantile function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a matrix containing estimated standard errors for the point estimates for each pair of loading vectors and <code>taus</code>.  Depending on user selections, these may be conditional on the sample or unconditional. The array is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a vector containing the p-values for hypothesis tests of three null hypotheses. First, that theta(tau,w) &lt;= 0 for all (tau,w) pairs, where theta is the quantity of interest (e.g., the derivative of the function at each quantile and at each observation). Second, that theta(tau,w) &gt;= 0 for all (tau,w) pairs. Third, that theta(tau,w) = 0 for all (tau,w) pairs.</p>
</td></tr>
<tr><td><code>taus</code></td>
<td>
<p>This is the input vector of quantile indexes.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list of length equal to the number of <code>taus</code> specified.  Each element of the list contains the coefficients from the nonparametric quantile regression performed at the corresponding <code>taus</code>.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which inference was performed and over which hypothesis tests were conducted. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv: 1105:6154.
</p>
<p>Koenker, R. (2011), &quot;Additive models for quantile regression: Model selection and confidence bandaids,&quot; Brazilian Journal of Probability and Statistics 25(3), pp. 239-262.
</p>
<p>Koenker, R. and G. Bassett (1978): &quot;Regression Quantiles,&quot; Econometrica 46, pp. 33-50.
</p>
<p>Ramsay, J.O., Wickham, H., Graves, S., and G. Hooker (2013), &quot;fda: Functional Data Analysis,&quot; R package version 2.3.6, http://CRAN.R-project.org/package=fda
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq">rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(india)

## Subset the data for speed
india.subset&lt;-india[1:1000,]

formula=cheight~mbmi+breastfeeding+mage+medu+edupartner
  
basis.bsp &lt;- create.bspline.basis(breaks=quantile(india$cage,c(0:10)/10))
  
n=length(india$cage)
B=500
alpha=.95
taus=c(1:24)/25
print.taus=c(1:4)/5

## Inference on average growth rate

piv.bsp &lt;- npqr(formula=formula, data=india.subset, basis=basis.bsp, 
	var="cage", taus=taus, print.taus=print.taus, B=B, nderivs=1, 
	average=1, alpha=alpha, process="pivotal", rearrange=FALSE, 
	uniform=TRUE, se="unconditional", printOutput=TRUE, method="fn")

yrange&lt;-range(piv.bsp$CI)
xrange&lt;-c(0,1)
plot(xrange,yrange,type="n",xlab="",ylab="Average Growth (cm/month)")
lines(piv.bsp$taus,piv.bsp$point.est)
lines(piv.bsp$taus,piv.bsp$CI[1,,1],col="blue")
lines(piv.bsp$taus,piv.bsp$CI[1,,2],col="blue")
title("Average Growth Rate")

## Estimation on average growth acceleration with no inference

piv.bsp.secondderiv &lt;- npqr(formula=formula, data=india.subset, 
	basis=basis.bsp, var="cage", taus=taus, print.taus=print.taus, 
	B=B, nderivs=2, average=0, alpha=alpha, process="none", 
	se="conditional", rearrange=FALSE, printOutput=FALSE, method="fn")

xsurf&lt;-as.vector(piv.bsp.secondderiv$taus)
ysurf&lt;-as.vector(piv.bsp.secondderiv$var.unique)
zsurf&lt;-t(piv.bsp.secondderiv$point.est)

persp(xsurf, ysurf, zsurf, xlab="Quantile", ylab="Age (months)",
	zlab="Growth Acceleration", ticktype="detailed", phi=30, 
	theta=120, d=5, col="green", shade=0.75, main="Growth Acceleration")

</code></pre>

<hr>
<h2 id='pivotal'>
Pivotal Process Inference for NPQR
</h2><span id='topic+pivotal'></span>

<h3>Description</h3>

<p>A method for the generic function <code><a href="#topic+npqr">npqr</a></code>. It computes, via a pivotal method, the t-statistic used to conduct inference in nonparametric series quantile regression models, as well as outputting confidence intervals and hypothesis test p-values at a user-specified level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivotal(data=data, B=B, taus, formula, basis = NULL, alpha=0.05, 
	var, load, rearrange=F, rearrange.vars="quantile", uniform=F, 
	se="unconditional", average=T, nderivs=1, method="fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivotal_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_b">B</code></td>
<td>

<p>the number of simulations to be performed.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_taus">taus</code></td>
<td>

<p>a numerical vector, whose entries are strictly between 0 and 1, containing the quantile indexes  of interest.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_basis">basis</code></td>
<td>

<p>either a basis generated using the <code>fda</code> package of type &quot;bspline&quot; or &quot;fourier&quot;, a factor variable, or an orthogonal polynomial basis generated using the <code>poly</code> command. This basis is the series regressor to be added to <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_alpha">alpha</code></td>
<td>

<p>a real number between 0 and 1: the desired significance level (e.g., 0.05).
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized prior to performing inference (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_uniform">uniform</code></td>
<td>

<p>a boolean specifying whether inference will be uniform across observations and quantiles or done in a pointwise manner.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_se">se</code></td>
<td>

<p>either &quot;conditional&quot; or &quot;unconditional&quot;. Specifies whether standard errors, for pivotal and gaussian processes, will be conditional on the sample or not.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_nderivs">nderivs</code></td>
<td>

<p>the number of derivatives of the conditional quantile function upon which inference should be performed.
</p>
</td></tr>
<tr><td><code id="pivotal_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pivotal</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>qfits</code></td>
<td>
<p>a list whose length is equal to the length of <code>taus</code>. Each element is an <code>rq.object</code> returned by <code>rq</code> for the corresponding quantile.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>an array containing the two-sided confidence interval for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper bounds of the confidence interval, respectively.</p>
</td></tr>
<tr><td><code>CI.oneSided</code></td>
<td>
<p>an array containing the one-sided confidence bounds for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper confidence bounds, respectively.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a matrix containing estimated standard errors for the quantile regression point estimates for each pair of loading vectors and <code>taus</code>.  Depending on user selections, these may be conditional on the sample or unconditional. The array is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a vector containing the p-values for hypothesis tests of three null hypotheses. First, that theta(tau,w) &lt;= 0 for all (tau,w) pairs, where theta is the quantity of interest (e.g., the derivative of the function at each quantile and at each observation). Second, that theta(tau,w) &gt;= 0 for all (tau,w) pairs. Third, that theta(tau,w) = 0 for all (tau,w) pairs.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which inference was performed and over which hypothesis tests were conducted. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv:1105.6154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

<hr>
<h2 id='poly.wrap'>
Orthogonal Polynomial Wrapper
</h2><span id='topic+poly.wrap'></span>

<h3>Description</h3>

<p>A wrapper for <code>poly</code>, <code>dpoly</code>, and <code>ddpoly</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly.wrap(x, degree = 1, coefs = NULL, nderivs = 1, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly.wrap_+3A_x">x</code></td>
<td>

<p>a numeric vector at which to evaluate the polynomial. <code>x</code> can also be a matrix. Missing values are not allowed in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="poly.wrap_+3A_degree">degree</code></td>
<td>

<p>the degree of the polynomial. Must be less than the number of unique points if <code>raw = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="poly.wrap_+3A_coefs">coefs</code></td>
<td>

<p>for prediction, coefficients from a previous fit.
</p>
</td></tr>
<tr><td><code id="poly.wrap_+3A_nderivs">nderivs</code></td>
<td>

<p>allowable values are 0, 1, and 2. If <code>nderivs = 0</code>, all other arguments are passed to <code>poly</code>. If <code>nderivs = 1</code>, all other arguments are passed to <code>dpoly</code>. If <code>nderivs = 2</code>, all other arguments are passed to <code>ddpoly</code>.
</p>
</td></tr>
<tr><td><code id="poly.wrap_+3A_raw">raw</code></td>
<td>

<p>if true, use raw and not orthogonal polynomials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>poly.wrap</code> returns the value returned by <code>poly</code>, <code>dpoly</code>, or <code>ddpoly</code>, depending on the value of <code>nderivs</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="#topic+dpoly">dpoly</a></code>, <code><a href="#topic+ddpoly">ddpoly</a></code>
</p>

<hr>
<h2 id='quantreg.nonpar-package'>
Nonparametric Series Quantile Regression
</h2><span id='topic+quantreg.nonpar-package'></span><span id='topic+quantreg.nonpar'></span>

<h3>Description</h3>

<p>Implements the nonparametric quantile regression methods developed by Belloni, Chernozhukov, and Fernandez-Val (2011) to partially linear quantile models. Provides point estimates of the conditional quantile function and its derivatives based on series approximations to the nonparametric part of the model. Provides pointwise and uniform confidence intervals using analytic and resampling methods.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> quantreg.nonpar</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-11-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package is used to generate point estimates and uniform and pointwise confidence intervals in nonparametric series quantile regression models. One may use <code><a href="#topic+npqr">npqr</a></code> to generate such estimates and confidence intervals and test hypotheses on the conditional quantile function and its derivatives.
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val 
</p>
<p>Maintainer: Ivan Fernandez-Val &lt;ivanf@bu.edu&gt;
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv: 1105:6154.
</p>
<p>Koenker, R. (2011), &quot;Additive models for quantile regression: Model selection and confidence bandaids,&quot; Brazilian Journal of Probability and Statistics 25(3), pp. 239-262.
</p>
<p>Koenker, R. and G. Bassett (1978): &quot;Regression Quantiles,&quot; Econometrica 46, pp. 33-50.
</p>
<p>Ramsay, J.O., Wickham, H., Graves, S., and G. Hooker (2013), &quot;fda: Functional Data Analysis,&quot; R package version 2.3.6, http://CRAN.R-project.org/package=fda
</p>

<hr>
<h2 id='removeI'>
Remove I() Tags From Formula
</h2><span id='topic+removeI'></span>

<h3>Description</h3>

<p>Remove I() tags from a formula. Used in the process of computing the symbolic derivative of the right hand side of a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeI(inString)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeI_+3A_instring">inString</code></td>
<td>

<p>a character object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>removeI</code> returns a character object identical to <code>inString</code> but with any I() tags removed
</p>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>See Also</h3>

<p><code><a href="#topic+formulaDeriv">formulaDeriv</a></code>
</p>

<hr>
<h2 id='wbootstrap'>
Weighted Bootstrap Inference for NPQR
</h2><span id='topic+wbootstrap'></span>

<h3>Description</h3>

<p>A method for the generic function <code><a href="#topic+npqr">npqr</a></code>. It computes, via a weighted bootstrap method, the t-statistic used to conduct inference in nonparametric series quantile regression models, as well as outputting confidence intervals and hypothesis test p-values at a user-specified level.</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbootstrap(data = data, B = B, taus, formula, basis = NULL, alpha=0.05, 
	var, load, rearrange=F, rearrange.vars="quantile", uniform=F, 
	average=T, nderivs=1, method = "fn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wbootstrap_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_b">B</code></td>
<td>

<p>the number of bootstrap repetitions to be performed.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_taus">taus</code></td>
<td>

<p>a numerical vector, whose entries are strictly between 0 and 1, containing the quantile indexes  of interest.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response Y on the left of a ~ operator, and the covariate terms, separated by + operators on the right, not including the regressor whose effect is to be estimated nonparametrically. Operators such as '*', ':', 'log()', and 'I()' are allowable. However, factor variables should be constructed prior to entry in the formula: the 'factor()' operator is not allowable.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_basis">basis</code></td>
<td>

<p>either a basis generated using the <code>fda</code> package of type &quot;bspline&quot; or &quot;fourier&quot;, a factor variable, or an orthogonal polynomial basis generated using the <code>poly</code> command. This basis is the series regressor to be added to <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_alpha">alpha</code></td>
<td>

<p>a real number between 0 and 1: the desired significance level (e.g., 0.05).
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_var">var</code></td>
<td>

<p>a column name within <code>data</code> whose values will be used, in combination with <code>basis</code>, to create the vectors used in the nonparametric part of the model.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_load">load</code></td>
<td>

<p>optional manual input of loading vector (or matrix of loading vectors) that will be used as data points at which inference will be performed and over which hypothesis tests will be conducted. Each vector of <code>load</code> should be input as the concatenation of vectors whose entries correspond to the entries of <code class="reqn">v</code> and <code class="reqn">Z(w)</code>, respectively (for example, the average values of each variable for the parametric part of the model, <code class="reqn">v</code>, and a specific point for the nonparametric part of the model, <code class="reqn">Z(w)</code>).
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_rearrange">rearrange</code></td>
<td>

<p>a boolean specifiying whether estimates will be monotonized prior to performing inference (requires that <code>average=FALSE</code> and <code>nderivs=0</code>).
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_rearrange.vars">rearrange.vars</code></td>
<td>

<p>if <code>rearrange = TRUE</code>, specifies whether monotonization will occur over &quot;quantile&quot;, &quot;var&quot; (the variable of interest), or &quot;both&quot;.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_uniform">uniform</code></td>
<td>

<p>a boolean specifying whether inference will be uniform across observations and quantiles or done in a pointwise manner.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_average">average</code></td>
<td>

<p>if <code>load</code> is not input, if <code>average=TRUE</code>, specifies that inference should be performed on the average value of a derivative (as specified by <code>nderivs</code>) of the conditional quantile function (inference cannot be performed when <code>average=TRUE</code> and <code>nderivs=0</code>). If <code>average=FALSE</code>, inference will be run at each unique value of the variable of interest in the dataset.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_nderivs">nderivs</code></td>
<td>

<p>the number of derivatives of the function itself upon which inference should be performed.
</p>
</td></tr>
<tr><td><code id="wbootstrap_+3A_method">method</code></td>
<td>

<p>method to be implemented in quantile regressions: passed to function <code>rq</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wbootstrap</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>qfits</code></td>
<td>
<p>a list whose length is equal to the length of <code>taus</code>. Each element is an <code>rq.object</code> returned by <code>rq</code> for the corresponding quantile.</p>
</td></tr>
<tr><td><code>point.est</code></td>
<td>
<p>a matrix containing the point estimates of interest (e.g., the average derivative of the function) for each pair of loading vectors and <code>taus</code>.  The matrix is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>var.unique</code></td>
<td>
<p>a vector containing all values of the covariate of interest with no repeated values.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>an array containing the two-sided confidence interval for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper bounds of the confidence interval, respectively.</p>
</td></tr>
<tr><td><code>CI.oneSided</code></td>
<td>
<p>an array containing the one-sided confidence bounds for each pair of loading vectors and <code>taus</code>.  The array is j by i by 2, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified. The final dimension  indexes the lower and upper confidence bounds, respectively.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>a matrix containing estimated standard errors for the point estimates for each pair of loading vectors and <code>taus</code>.  Depending on user selections, these may be conditional on the sample or unconditional. The array is j by i, where j is the number of loading vectors specified (i.e., the number of observations in the dataset if <code>average=FALSE</code> and 1 if <code>average=TRUE</code>) and i is the number of <code>taus</code> specified.</p>
</td></tr>
<tr><td><code>pvalues</code></td>
<td>
<p>a vector containing the p-values for hypothesis tests of three null hypotheses. First, that theta(tau,w) &lt;= 0 for all (tau,w) pairs, where theta is the quantity of interest (e.g., the derivative of the function at each quantile and at each observation). Second, that theta(tau,w) &gt;= 0 for all (tau,w) pairs. Third, that theta(tau,w) = 0 for all (tau,w) pairs.</p>
</td></tr>
<tr><td><code>load</code></td>
<td>
<p>the loading vector or matrix of loading vectors used as data points at which inference was performed and over which hypothesis tests were conducted. If <code>load</code> was not input by the user, <code>load</code> is generated based on <code>average</code> and <code>nderivs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Lipsitz, Alexandre Belloni, Victor Chernozhukov, Ivan Fernandez-Val
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., and I. Fernandez-Val (2011), &quot;Conditional quantile processes based on series or many regressors,&quot; arXiv:1105.6154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npqr">npqr</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
