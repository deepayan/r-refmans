<!DOCTYPE html><html lang="en"><head><title>Help for package mgm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mgm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mgm-package'>
<p>Estimating Time-Varying k-order Mixed Graphical Models</p></a></li>
<li><a href='#bwSelect'>
<p>Select optimal bandwidth for time-varying MGMs and mVAR Models</p></a></li>
<li><a href='#condition'>
<p>Computes mgm object conditional on a set of variables</p></a></li>
<li><a href='#datasets'><p>Example Datasets in the mgm Package</p></a></li>
<li><a href='#FactorGraph'>
<p>Draws a factor graph of a (time-varying) MGM</p></a></li>
<li><a href='#mgm'>
<p>Estimating Mixed Graphical Models</p></a></li>
<li><a href='#mgm-internal'><p>Internal mgm functions</p></a></li>
<li><a href='#mgmsampler'>
<p>Sample from k-order Mixed Graphical Model</p></a></li>
<li><a href='#mvar'>
<p>Estimating mixed Vector Autoregressive Model (mVAR)</p></a></li>
<li><a href='#mvarsampler'>
<p>Sampling from a mixed VAR model</p></a></li>
<li><a href='#plotRes'>
<p>Plot summary of resampled sampling distributions</p></a></li>
<li><a href='#predict.mgm'>
<p>Compute predictions from mgm model objects</p></a></li>
<li><a href='#print.int'>
<p>Print method for int objects</p></a></li>
<li><a href='#print.mgm'>
<p>Print method for mgm objects</p></a></li>
<li><a href='#resample'>
<p>Resampling scheme for mgm objects</p></a></li>
<li><a href='#showInteraction'>
<p>Retrieving details of interactions</p></a></li>
<li><a href='#tvmgm'>
<p>Estimating time-varying Mixed Graphical Models</p></a></li>
<li><a href='#tvmgmsampler'>
<p>Sample from time-varying k-order Mixed Graphical Model</p></a></li>
<li><a href='#tvmvar'>
<p>Estimating time-varying Mixed Vector Autoregressive Model (mVAR)</p></a></li>
<li><a href='#tvmvarsampler'>
<p>Sampling from a time-varying mixed VAR model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Time-Varying k-Order Mixed Graphical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-15</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-16</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Haslbeck  &lt;jonashaslbeck@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of k-Order time-varying Mixed Graphical Models and mixed VAR(p) models via elastic-net regularized neighborhood regression. For details see Haslbeck &amp; Waldorp (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v093.i08">doi:10.18637/jss.v093.i08</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.jstatsoft.org/article/view/v093i08">https://www.jstatsoft.org/article/view/v093i08</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmbh/mgm/issues">https://github.com/jmbh/mgm/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, stringr, Hmisc, qgraph, gtools</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-16 12:04:49 UTC; jona</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Haslbeck [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-16 12:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='mgm-package'>
Estimating Time-Varying k-order Mixed Graphical Models
</h2><span id='topic+mgm-package'></span>

<h3>Description</h3>

<p>Estimation of time-varying Mixed Graphical models and mixed VAR models via elastic-net regularized neighborhood regression.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck
</p>
<p>Maintainer: &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>
<p>Loh, P. L., &amp; Wainwright, M. J. (2013). Structure estimation for discrete graphical models: Generalized covariance matrices and their inverses. The Annals of Statistics, 41(6), 3022-3049.
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G., &amp; Liu, Z. (2014). Mixed graphical models via exponential families. In Proceedings of the Seventeenth International Conference on Artificial Intelligence and Statistics (pp. 1042-1050).
</p>

<hr>
<h2 id='bwSelect'>
Select optimal bandwidth for time-varying MGMs and mVAR Models
</h2><span id='topic+bwSelect'></span>

<h3>Description</h3>

<p>Selects the bandwidth parameter with lowest out of sample prediction error for MGMs and mVAR Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwSelect(data, type, level, bwSeq, bwFolds,
         bwFoldsize, modeltype, pbar, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bwSelect_+3A_data">data</code></td>
<td>

<p>A n x p data matrix.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_bwseq">bwSeq</code></td>
<td>

<p>A sequence with candidate bandwidth values (0, s] with s &lt; Inf. Note that the bandwidth is applied relative to the unit time interval [0,1] and hence a banwidth of &gt; 2 corresponds roughly to equal weights for all time points and hence gives similar estimates as the stationary model estimated via <code>mvar()</code>.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_bwfolds">bwFolds</code></td>
<td>

<p>The number of folds (see details below).
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_bwfoldsize">bwFoldsize</code></td>
<td>

<p>The size of each fold (see details below).
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_modeltype">modeltype</code></td>
<td>

<p>If <code>modeltype = "mvar"</code> model, the optimal bandwidth parameter for a <code>tvmvar()</code> model is selected. If <code>modeltype = "mgm"</code> model, the optimal bandwidth parameter for a <code>tvmgm()</code> model is selected. Additional arguments to <code>tvmvar()</code> or <code>tvmgm()</code> can be passed via the <code>...</code> argument.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_pbar">pbar</code></td>
<td>

<p>If TRUE a progress bar is shown. Defaults to <code>pbar = "TRUE"</code>.
</p>
</td></tr>
<tr><td><code id="bwSelect_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>tvmgm</code> or <code>tvmvar</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a cross-validation scheme that is specified by <code>bwFolds</code> and <code>bwFoldsize</code>. In the first fold, the test set is defined by an equally spaced sequence between [1,  n - <code>bwFolds</code>] of length <code>bwFoldsize</code>. In the second fold, the test set is defined by an equally spaced sequence between [2, n - <code>bwFolds</code> + 1] of length <code>bwFoldsize</code>, etc. . Note that if <code>bwFoldsize</code> = n / <code>bwFolds</code>, this procedure is equal to <code>bwFolds</code>-fold cross valildation. However, full cross validation is computationally very expensive and a single split in test/training set by setting <code>bwFolds = 1</code> is sufficient in many situations. The procedure selects the bandwidth with the lowest prediction error, averaged over variables and time points in the test set.
</p>
<p><code>bwSelect</code> computes the absolute error (continuous) or 0/1-loss (categorical) for each time point in the test set defined by <code>bwFoldsize</code> as described in the previous paragraph for every fold specified in <code>bwFolds</code>, separately for each variable. The computed errors are returned in different levels of aggregation in the output list (see below). Note that continuous variables are scaled (centered and divided by their standard deviation), hence the absolute error and 0/1-loss are roughly on the scale scale.
</p>
<p>Note that selecting the bandwidth with the EBIC is no alternative. This is because the EBIC always selects the intercept model with the lowest bandwidth.  The reason is that the unregularized intercept closely models the noise in the data and hence the penalty sets all other parameters to zero. This problem is solved by using out of sample prediction error in the cross validation scheme.
</p>


<h3>Value</h3>

<p>The function returns a list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments. If <code>saveData = TRUE</code>, it also contains the data.
</p>
</td></tr>
<tr><td><code>bwModels</code></td>
<td>

<p>Contains the models estimated at the time points in the tests set. For details see <code>tvmvar</code> or <code>tvmgm</code>.
</p>
</td></tr>
<tr><td><code>fullErrorFolds</code></td>
<td>

<p>List with number of entries equal to the length of <code>bwSeq</code> entries. Each entry contains a list with <code>bwFolds</code> entries. Each of those entries contains a contains a <code>bwFoldsize</code> times p matrix of out of sample prediction errors.
</p>
</td></tr>
<tr><td><code>fullError</code></td>
<td>

<p>The same as <code>fullErrorFolds</code> but pooled over folds.
</p>
</td></tr>
<tr><td><code>meanError</code></td>
<td>

<p>List with number of entries equal to the length of <code>bwSeq</code> entries. Each entry contains the average prediction error over variables and time points in the test set.
</p>
</td></tr>
<tr><td><code>testsets</code></td>
<td>

<p>List with <code>bwFolds</code> entries, which contain the rows of the test sample for each fold.
</p>
</td></tr>
<tr><td><code>zeroweights</code></td>
<td>

<p>List with <code>bwFolds</code> entries, which contains the observation weights used to fit the model at the <code>bwFoldsize</code> time points.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Barber, R. F., &amp; Drton, M. (2015). High-dimensional Ising model selection with Bayesian information criteria. Electronic Journal of Statistics, 9(1), 567-607.
</p>
<p>Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. In Advances in neural information processing systems (pp. 604-612).
</p>
<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## A) bwSelect for tvmgm() 

# A.1) Generate noise data set
p &lt;- 5
n &lt;- 100
data_n &lt;- matrix(rnorm(p*n), nrow=100)
head(data_n)

type &lt;- c("c", "c", rep("g", 3))
level &lt;- c(2, 2, 1, 1, 1)
x1 &lt;- data_n[,1]
x2 &lt;- data_n[,2]
data_n[x1&gt;0,1] &lt;- 1
data_n[x1&lt;0,1] &lt;- 0
data_n[x2&gt;0,2] &lt;- 1
data_n[x2&lt;0,2] &lt;- 0

head(data_n)

# A.2) Estimate optimal bandwidth parameter

bwobj_mgm &lt;- bwSelect(data = data_n,
                      type = type,
                      level = level,
                      bwSeq = seq(0.05, 1, length=3),
                      bwFolds = 1,
                      bwFoldsize = 3,
                      modeltype = "mgm",
                      k = 3,
                      pbar = TRUE,
                      overparameterize = TRUE)


print.mgm(bwobj_mgm)



## B) bwSelect for tvmVar() 

# B.1) Generate noise data set

p &lt;- 5
n &lt;- 100
data_n &lt;- matrix(rnorm(p*n), nrow=100)
head(data_n)

type &lt;- c("c", "c", rep("g", 3))
level &lt;- c(2, 2, 1, 1, 1)
x1 &lt;- data_n[,1]
x2 &lt;- data_n[,2]
data_n[x1&gt;0,1] &lt;- 1
data_n[x1&lt;0,1] &lt;- 0
data_n[x2&gt;0,2] &lt;- 1
data_n[x2&lt;0,2] &lt;- 0

head(data_n)

# B.2) Estimate optimal bandwidth parameter

bwobj_mvar &lt;- bwSelect(data = data_n,
                       type = type,
                       level = level,
                       bwSeq = seq(0.05, 1, length=3),
                       bwFolds = 1,
                       bwFoldsize = 3,
                       modeltype = "mvar",
                       lags = 1:3,
                       pbar = TRUE,
                       overparameterize = TRUE)


print.mgm(bwobj_mvar)

# For more examples see https://github.com/jmbh/mgmDocumentation



## End(Not run)

</code></pre>

<hr>
<h2 id='condition'>
Computes mgm object conditional on a set of variables
</h2><span id='topic+condition'></span>

<h3>Description</h3>

<p>The function takes an mgm object and a set of variables fixed to given values as input and returns the conditional mgm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition(object, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condition_+3A_object">object</code></td>
<td>

<p>An mgm object, the output of the <code>mgm()</code> function.
</p>
</td></tr>
<tr><td><code id="condition_+3A_values">values</code></td>
<td>

<p>A list, where the entry name indicates the column number of the variable that should be fixed, and the entry value indicates the value to which the corresponding variable should be fixed. See below for an example.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new conditional object still contains the variables that were fixed, however, they are not related to any of the random variables anymore. We kept the variables in the object to avoid confusion with variable labels and plotting. Also note that <code>mgm()</code> by default scales all Gaussian variables to mean=0, sd=1. Thus, fixed values should be selected based on the scaled version of variables.
</p>


<h3>Value</h3>

<p>The function returns an mgm object that is conditional on the provided values. The new mgm object can again be used as input in <code>predict()</code>, <code>print()</code>, <code>showInteraction()</code>, etc.. Note that <code>mgm()</code> by default standardizes variables to mean=0, SD=1. Therefore, also the values one conditions on should be chosen on the scaled version of the variable to avoid extrapolating out of the dataset.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J., &amp; Waldorp, L. J. (2019). mgm: Estimating time-varying mixed graphical models in high-dimensional data. arXiv preprint arXiv:1510.06871.
</p>


<h3>See Also</h3>

<p><code>mgm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# --- Create Mixture of two Gaussians ---

set.seed(1)
n &lt;- 500
library(MASS)

# Component A
Sigma_a &lt;- diag(2)
Sigma_a[1, 2] &lt;- Sigma_a[2, 1] &lt;- .5
Xa &lt;- mvrnorm(n = n, mu = rep(0, 2), Sigma = Sigma_a)

# Component B
Sigma_b &lt;- diag(2)
Sigma_b[1, 2] &lt;- Sigma_b[2, 1] &lt;- 0
Xb &lt;- mvrnorm(n = n, mu = rep(0, 2), Sigma = Sigma_b)

data &lt;- cbind(rbind(Xa, Xb), c(rep(0, n), rep(1, n)))
colnames(data) &lt;- c("x1", "x2", "x3")


# --- Fit MGM ---

# with mgm
mgm_obj &lt;- mgm(data = data, 
               type = c("g","g","c"), 
               level = c(1, 1, 2), 
               moderator = c(3), 
               lambdaSel = "EBIC")

# --- Condition on / fix values of variable 3 ---

# Fix x3=0
mgm_obj_x3.0 &lt;- condition(object = mgm_obj, 
                          values = list("3"=0))
mgm_obj_x3.0$pairwise$wadj

# Fix x3=1
mgm_obj_x3.1 &lt;- condition(object = mgm_obj, 
                          values = list("3"=1))
mgm_obj_x3.1$pairwise$wadj


## End(Not run)

</code></pre>

<hr>
<h2 id='datasets'>Example Datasets in the mgm Package</h2><span id='topic+datasets'></span><span id='topic+autism_data'></span><span id='topic+autism_data_large'></span><span id='topic+restingstate_data'></span><span id='topic+fruitfly_data'></span><span id='topic+symptom_data'></span><span id='topic+Fried2015'></span><span id='topic+PTSD_data'></span><span id='topic+mgm_data'></span><span id='topic+mvar_data'></span><span id='topic+modnw'></span><span id='topic+B5MS'></span><span id='topic+msq_p5'></span><span id='topic+msq_p3'></span><span id='topic+dataGD'></span>

<h3>Description</h3>

<p>The autism dataset (and its short version) are taken from Deserno et al. (2016).
</p>
<p>The restingstate fMRI data are taken from Schmittmann et al. (2015).
</p>
<p>The gene expression data across the life span of the fruit fly are taken from Gibberd &amp; Nelson (2017), who took a subset of the data first presented by Arbeitman et al. (2002).
</p>
<p>The symptom data of the single individual diagnosed with major depression is described in Kossakowski et al. (2017).
</p>
<p>The PTSD data is taken from McNally et al. (2015).
</p>
<p>The dataset <code>mgm_data</code> is generated by example code shown in ?mgmsampler, and <code>mvar_data</code> is generated by example code shown in ?mvarsampler.
</p>
<p>The dataset <code>Fried2015</code> contains 515 cases of the 11 depression symptoms measured by the CES-D and is taken from Fried et al. 2015.
</p>
<p>The dataset <code>B5MS</code> contains the mean scores across subscales (48 items each) for the Big Five personality traits. The dataset is taken from the <code>qgraph</code> package (Epskamp, et al., 2012) and was first used in Dolan et al. (2009).
</p>
<p>The dataset <code>dataGD</code> contains 4 continuous variables and 3 categorical variables that are generated from a mixed DAG. This dataset is useful to illustrate estimating group differences in MGMs using moderation.
</p>
<p>All datasets are loaded automatically. All real data sets come as a list including the data and additional information (names of variables, types of variables, time stamps for time series data, etc.)
</p>


<h3>References</h3>

<p>Deserno, M. K., Borsboom, D., Begeer, S., &amp; Geurts, H. M. (2016). Multicausal systems ask for multicausal approaches: A network perspective on subjective well-being in individuals with autism spectrum disorder. Autism.
</p>
<p>Dolan, C. V., Oort, F. J., Stoel, R. D., &amp; Wicherts, J. M. (2009). Testing measurement invariance in the target rotated multigroup exploratory factor model. Structural Equation Modeling, 16(2), 295-314.
</p>
<p>Epskamp, S., Cramer, A. O., Waldorp, L. J., Schmittmann, V. D., &amp; Borsboom, D. (2012). qgraph: Network visualizations of relationships in psychometric data. Journal of Statistical Software, 48(4), 1-18.
</p>
<p>Schmittmann, V. D., Jahfari, S., Borsboom, D., Savi, A. O., &amp; Waldorp, L. J. (2015). Making large-scale networks from fMRI data. PloS one, 10(9), e0129074.
</p>
<p>Gibberd, A. J., &amp; Nelson, J. D. (2017). Regularized Estimation of Piecewise Constant Gaussian Graphical Models: The Group-Fused Graphical Lasso. Journal of Computational and Graphical Statistics, (just-accepted).
</p>
<p>Arbeitman, M. N., Furlong, E. E., Imam, F., Johnson, E., Null, B. H., Baker, B. S., ... &amp; White, K. P. (2002). Gene expression during the life cycle of Drosophila melanogaster. Science, 297(5590), 2270-2275.
</p>
<p>Kossakowski, J., Groot, P., Haslbeck, J., Borsboom, D., &amp; Whichers, M. (2017). Data from &quot;Critical Slowing Down as a Personalized Early Warning Signal for Depression&quot;. Journal of Open Psychology Data, 5(1).
</p>
<p>McNally, R. J., Robinaugh, D. J., Wu, G. W., Wang, L., Deserno, M. K., &amp; Borsboom, D. (2015). Mental disorders as causal systems a network approach to posttraumatic stress disorder. Clinical Psychological Science, 3(6), 836-849.
</p>
<p>Fried, E. I., Bockting, C., Arjadi, R., Borsboom, D., Amshoff, M., Cramer, A. O., ... &amp; Stroebe, M. (2015). From loss to loneliness: The relationship between bereavement and depressive symptoms. Journal of abnormal psychology, 124(2), 256.
</p>

<hr>
<h2 id='FactorGraph'>
Draws a factor graph of a (time-varying) MGM
</h2><span id='topic+FactorGraph'></span>

<h3>Description</h3>

<p>Wrapper function around qgraph() that draws factor graphs for (time-varying) MGMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FactorGraph(object, labels, PairwiseAsEdge = FALSE, 
            Nodewise = FALSE, DoNotPlot = FALSE, 
            FactorLabels = TRUE, colors, shapes,
            shapeSizes = c(8, 4), estpoint = NULL, 
            negDashed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FactorGraph_+3A_object">object</code></td>
<td>

<p>The output object of <code>mgm()</code> or <code>tvmgm()</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_labels">labels</code></td>
<td>

<p>A character vector of (variable) node labels.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_pairwiseasedge">PairwiseAsEdge</code></td>
<td>

<p>If <code>TRUE</code>, pairwise interactions are not displayed as factors but as simple edges between nodes. Defaults to <code>PairwiseAsEdge = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_nodewise">Nodewise</code></td>
<td>

<p>If <code>TRUE</code>, the estimates from the individual nodewise regressions are displayed as a directed edge towards the node on which the respective nodewise regression was performed. This is useful to identify model misspecification (e.g. moderation effects / interaction parameters with largely different values across nodewise regressions). Defaults to <code>Nodewise = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_donotplot">DoNotPlot</code></td>
<td>

<p>If <code>DoNotPlot = TRUE</code> no factorgraph is plotted. This way the computed factor graph can be obtained without plotting. Defaults to <code>DoNotPlot = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_factorlabels">FactorLabels</code></td>
<td>

<p>If <code>FactorLabels = TRUE</code> the factors are labeled by their order. If <code>FactorLabels = FALSE</code> no label is shown. Defaults to <code>FactorLabels = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_colors">colors</code></td>
<td>

<p>A character vector of colors for nodes and factors. The first color is for variable-nodes, the second for 2-way interactions, the third for 3-way interactions, etc. Defaults to <code>colors = c("white", "tomato", "lightblue", "orange")</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_shapes">shapes</code></td>
<td>

<p>A character vector of shapes for for nodes and factors. The first shape is for variable-nodes, the second for 2-way interactions, the third for 3-way interactions, etc. Defaults to <code>shapes = c("circle", "square", "triangle", "diamond")</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_shapesizes">shapeSizes</code></td>
<td>

<p>A numeric vector of length two indicating the size of shapes for nodes and factors. Defaults to <code>shapeSizes = c(8, 4)</code>.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_estpoint">estpoint</code></td>
<td>

<p>An integer indicating the estimation point to display if the output object of a time-varying MGM is provided. 
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_negdashed">negDashed</code></td>
<td>

<p>If <code>negDashed = TRUE</code>, edges with negative sign are dashed.
</p>
</td></tr>
<tr><td><code id="FactorGraph_+3A_...">...</code></td>
<td>

<p>Arguments passed to qgraph.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FactorGraph()</code> is a wrapper around <code>qgraph()</code> from the qgraph package. Therefore all arguments of <code>qgraph()</code> are available and can be provided as additional arguments.
</p>
<p>To make time-varying factor graphs comparable across estimation points, the factor graph of each estimation point includes all factors that are estimated nonzero at least at one estimation point.
</p>


<h3>Value</h3>

<p>Plots the factor graph and returns a list including the arguments used to plot the factor graph using qgraph().
</p>
<p>Specifically, a list is returned including:  <code>graph</code> contains a weighted adjacency matrix of a (bipartide) factor graph. If p is the number of variables and E the number of interactions (factors) in the model, this matrix has dimensions (p+E) x (p+E). The factor graph is furter specified by the following objects: <code>signs</code> is a matrix of the same dimensions as <code>graph</code> that indicates the sign of each interaction, if defined (see <code>pairwise</code> above). <code>edgecolor</code> is a matrix with the same dimension as <code>graph</code> that provides edge colors depending on the sign as above. <code>order</code> is a (p+E) vector indicating the order of interaction. The first p entries are set to zero. <code>qgraph</code> contains the qgraph object created while plotting.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>mgm()</code>, <code>tvmgm()</code>, <code>qgraph()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

# Fit MGM with pairwise &amp; threeway interactions to Autism Dataset
fit_k3 &lt;- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 3, 
              overparameterize = TRUE,
              lambdaSel = "EBIC", 
              lambdaGam = .5) 

# List of estimated interactions
fit_k3$interactions$indicator

FactorGraph(object = fit_k3, 
            PairwiseAsEdge = FALSE, 
            DoNotPlot = FALSE, 
            labels = 1:7, 
            layout="circle")

# For more examples see https://github.com/jmbh/mgmDocumentation

## End(Not run)

</code></pre>

<hr>
<h2 id='mgm'>
Estimating Mixed Graphical Models
</h2><span id='topic+mgm'></span><span id='topic+mgmfit'></span>

<h3>Description</h3>

<p>Function to estimate k-degree Mixed Graphical Models via nodewise regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgm(data, type, level, regularize, lambdaSeq, lambdaSel, 
    lambdaFolds, lambdaGam, alphaSeq, alphaSel, alphaFolds, 
    alphaGam, k, moderators, ruleReg, weights, threshold, method, 
    binarySign, scale, verbatim, pbar, warnings, saveModels, 
    saveData, overparameterize, thresholdCat, signInfo, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgm_+3A_data">data</code></td>
<td>

<p>n x p data matrix
</p>
</td></tr>
<tr><td><code id="mgm_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_regularize">regularize</code></td>
<td>

<p>Logical indicating whether regularization is applied. If <code>regularize = FALSE</code>, all arguments relating to the specification are overwritten and all regularization parameters are set to 0. This also sets <code>threshold = "none"</code>. Defaults to <code>regularize = TRUE</code>. Note that the multinomial parameterization used by the <code>glmnet</code> package used within <code>mgm</code> is only guaranteed to be uniquely identified with regularization.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_lambdaseq">lambdaSeq</code></td>
<td>

<p>A sequence of lambdas that should be searched (see also <code>lambdaSel</code>). Defaults to <code>NULL</code>, which uses the  <code>glmnet</code> default to select a lambda candidate sequence (recommended). See <code>?glmnet</code> for details.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_lambdasel">lambdaSel</code></td>
<td>

<p>Specifies the procedure for selecting the tuning parameter controlling the Lq-penalization. The two options are cross validation &quot;CV&quot; and the Extended Bayesian Information Criterion (EBIC) &quot;EBIC&quot;. The EBIC performs well in selecting sparse graphs (see Barber and Drton, 2010 and Foygel and Drton, 2014). Note that when also searching the alpha parameter in the elastic net penalty, cross validation should be preferred, as the parameter vector will not necessarily be sparse anymore. The EBIC tends to be a bit more conservative than CV (see Haslbeck and Waldorp, 2016). CV can sometimes not be performed with categorical variables, because <code>glmnet</code> requires at least 2 events of each category of each categorical variable in each training-fold. Defaults to <code>lambdaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_lambdafolds">lambdaFolds</code></td>
<td>

<p>Number of folds in cross validation if <code>lambdaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_lambdagam">lambdaGam</code></td>
<td>

<p>Hyperparameter gamma in the EBIC if <code>lambdaSel = "EBIC"</code>. Defaults to <code>lambdaGam = .25</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_alphaseq">alphaSeq</code></td>
<td>

<p>A sequence of alpha parameters for the elastic net penality in [0,1] that should be searched (see also <code>alphaSel</code>). Defaults to <code>alphaSeq = 1</code>, which means that the lasso is being used. <code>alphaSeq = 0</code> corresponds to an L2-penalty (Ridge regression). For details see Friedman, Hastie and Tibshirani (2010).
</p>
</td></tr>
<tr><td><code id="mgm_+3A_alphasel">alphaSel</code></td>
<td>

<p>Specifies the procedure for selecting the alpha parameter in the elastic net penalty. The two options are cross validation &quot;CV&quot; and the Extended Bayesian Information Criterion (EBIC) &quot;EBIC&quot;. The EBIC performs well in selecting sparse graphs (see Barber and Drton, 2010 and Foygel and Drton, 2014). Note that when also searching the alpha parameter in the elastic net penalty, cross validation should be preferred, as the parameter vector will not necessarily be sparse anymore. The EBIC tends to be a bit more conservative than CV (see Haslbeck and Waldorp, 2016). CV can sometimes not be performed with categorical variables, because <code>glmnet</code> requires at least 2 events of each category of each categorical variable in each training-fold. Defaults to <code>alphaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_alphafolds">alphaFolds</code></td>
<td>

<p>Number of folds in cross validation if <code>alphaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_alphagam">alphaGam</code></td>
<td>

<p>Hyperparameter gamma in the EBIC if <code>alphaSel = "EBIC"</code>. Defaults to <code>alphaGam = .25</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_k">k</code></td>
<td>

<p>Order up until including which interactions are included in the model. <code>k = 2</code> means that all pairwise interactions are included, <code>k = 3</code> means that all pairwise and all three-way interactions are included, etc. In previous versions of mgm the order of interactions was specified by the parameter d, the largest size or a neighborhood. Note that k = d + 1.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_moderators">moderators</code></td>
<td>

<p>Integer vector with elements in <code>1:p</code>, specifying moderation effects to be included in the model. For instance, <code>moderators = c(4)</code> includes all linear moderation effects of variable 4. This is equivalent to including all 3-way interactions that include variable 4. Note that <code>moderators = 1:p</code> gives the same model as setting <code>k = 3</code> (see previous argument). Alternatively, a specific set of moderators can be specified via a M x 3 matrix, where M is the number of moderation effects. For example, <code>moderators = matrix(1:3, nrow=1)</code> adds (only) the 3-way interaction 1-2-3 to the model. 
</p>
</td></tr>
<tr><td><code id="mgm_+3A_rulereg">ruleReg</code></td>
<td>

<p>Rule used to combine estimates from neighborhood regression. E.g. for pairwise interactions, two estimates (one from regressing A on B and one from B on A) have to combined in one edge parameter. <code>ruleReg = "AND"</code> requires all estimates to be nonzero in order to set the edge to be present. <code>ruleReg = "OR"</code> requires at least one estiamte to be nonzero in order to set the edge to be present. For higher order interactions, <code>k</code> estimate have to be combined with this rule.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_weights">weights</code></td>
<td>

<p>A n vector with weights for observations.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_threshold">threshold</code></td>
<td>

<p>A threshold below which edge-weights are put to zero. This is done in order to guarantee a lower bound on the false-positive rate. <code>threshold = "LW"</code> refers to the threshold in Loh and Wainwright (2013), which was used in all previous versions of mgm. <code>threshold = "HW"</code> refers to the threshold in Haslbeck and Waldorp (2016). If <code>threshold = "none"</code> no thresholding is applied.  Defaults to <code>threshold = "LW"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_method">method</code></td>
<td>

<p>Estimation method, currently only <code>method = "glm"</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_binarysign">binarySign</code></td>
<td>

<p>If <code>binarySign = TRUE</code>, a sign for the interaction within binary nodes and between binary and continuous nodes is provided in the output. Note that in this case the two categories of the binary variables have to be coded in <code>{0,1}</code>. This is to ensure that the interpretation of the sign is unambigous: a positive sign of a parameter means that increasing the associated predictor results in a higher probability for category 1.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_scale">scale</code></td>
<td>

<p>If <code>scale = TRUE</code>, all Gaussian nodes (specified by <code>"g"</code> in <code>type</code>) are centered and divided by their standard deviation. Scaling is recommended, because otherwise the penalization of a parameter depends on the variance of the associated predictor. Defaults to <code>scale = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_verbatim">verbatim</code></td>
<td>

<p>If <code>verbatim = TRUE</code>, no warnings and no progress bar is shown. Defaults to <code>verbatim = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code>, a progress bar is shown. Defaults to <code>pbar = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_warnings">warnings</code></td>
<td>

<p>If <code>warnings = TRUE</code>, no warnigns are returned. Defaults to <code>warnings = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_savemodels">saveModels</code></td>
<td>

<p>If <code>saveModels = FALSE</code>, only information about the weighted adjacency matrix, and if k &gt; 2 about the factor graph is provided in the output list. If <code>saveModels = TRUE</code>, all fitted parameters are additionally returned.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_savedata">saveData</code></td>
<td>

<p>If <code>saveData = TRUE</code>, the data is saved in the output list. Defaults to <code>saveData = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_overparameterize">overparameterize</code></td>
<td>

<p>If <code>overparameterize = TRUE</code>, <code>mgm()</code> uses over-parameterized design-matrices for each neighborhood regression; this means that an interaction between two categorical variables with m and s categories is parameterized by m*s parameters. If <code>overparameterize = FALSE</code> the standard parameterization (in <code>glmnet</code>) with m*(s-1) parameters is used, where the first category of the predicting variable serves as reference category. If all variables are continuous both parameterizations are the same. Note that the default is set to <code>overparameterize = FALSE</code>, to be consistent with the previous mgm versions. However when the goal is to seperate pairwise interactions from 3-way (or higher) interactions, then the overparameterized version is advantageous. See the examples below for an illustration. Note that we can estimate the model despite the colinear columns in the design matrix because we use penalized regression.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_thresholdcat">thresholdCat</code></td>
<td>

<p>If <code>thresholdCat = FALSE</code>, the thresholds of categorical variables are set to zero. Defaults to <code>thresholdCat = TRUE</code> for which the thresholds are esimated.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_signinfo">signInfo</code></td>
<td>

<p>If <code>signInfo = TRUE</code>, a message is shown in the console, indicating that the sign of estimates is stored separately. Defaults to <code>signInfo = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mgm_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mgm()</code> estimates an exponential mixed graphical model as introduced in Yang and colleagies (2014). Note that MGMs are not normalizable for all parameter values. See Chen, Witten &amp; Shojaie (2015) for an overview of when pairwise MGMs are normalizable. To our best knowledge, for MGMs with interactions of order &gt; 2 that include non-categorical variables, the conditions for normalizablity are unknown.
</p>


<h3>Value</h3>

<p>The function returns a list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments. If <code>saveData = TRUE</code>, it also contains the data
</p>
</td></tr>
<tr><td><code>pairwise</code></td>
<td>

<p>Contains a list with all information about estimated pairwise interactions. <code>wadj</code> contains the p x p weighted adjacency matrix, if p is the number of variables in the network. <code>signs</code> has the same dimensions as <code>wadj</code> and contains the signs for the entries of <code>wadj</code>: 1 indicates a positive sign, -1 a negative sign and 0 an undefined sign. A sign is undefined if an edge is a function of more than one parameter. This is the case for interactions involving a categorical variable with more than 2 categories. <code>edgecolor</code> also has the same dimensions as <code>wadj</code> contains a color for each edge, depending on <code>signs</code>. It is provided for more convenient plotting. If only pairwise interactions are modeled (<code>d = 1</code>), <code>wadj</code> contains all conditional independence relations. The matrices <code>edgecolor_cb</code> contain a color blind friendly color scheme. <code>edge_lty</code> contains a matrix with 1s for positive/undefined signs and 2s for negative signes, which can be used as input to the <code>lty</code> argument in <code>qgraph()</code> in order to plot edges with negative sign as dashed lines.
</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>

<p>A list with three entries that relate each interaction in the model to all its parameters. This is different to the output provided in <code>factorgraph</code>, where one value is assigned to each interaction. <code>indicator</code> contains a list with k-1 entries, one for each order of modeled interaction, which contain the estimated (nonzero) interactions. <code>weightsAgg</code> contains a list with k-1 entries, which in turn contain R lists, where R is the number of interactions (and rows in the corresponding list entry in<code>indicator</code>) that were estimated (nonzero) in the given entry. Each of these entries contains the mean of the absolute values of all parameters involved in this interaction. <code>weights</code> has the same structure as <code>weightsAgg</code>, but does contain all parameters involved in the interaction instead of the mean of their absolute values. <code>signs</code> has the same structure as <code>weightsAgg</code>/<code>weights</code> and provides the sign of the interaction, if defined.
</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>

<p>A list with p entries, which contain the intercept/thresholds for each node in the network. In case a given node is categorical with m categories, there are m thresholds for this variable.
</p>
</td></tr>
<tr><td><code>nodemodels</code></td>
<td>

<p>A list with p <code>glmnet()</code> models, from which all above output is computed. Also contains the coefficients <code>models</code> for the selected lambda and the applied tau threshold <code>tau</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Barber, R. F., &amp; Drton, M. (2015). High-dimensional Ising model selection with Bayesian information criteria. Electronic Journal of Statistics, 9(1), 567-607.
</p>
<p>Chen S, Witten DM &amp; Shojaie (2015). Selection and estimation for mixed graphical models. Biometrika, 102(1), 47.
</p>
<p>Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. In Advances in neural information processing systems (pp. 604-612).
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2010). Regularization paths for generalized linear models via coordinate descent. Journal of statistical software, 33(1), 1.
</p>
<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>
<p>Loh, P. L., &amp; Wainwright, M. J. (2012, December). Structure estimation for discrete graphical models: Generalized covariance matrices and their inverses. In NIPS (pp. 2096-2104).
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G. I., &amp; Liu, Z. (2014, April). Mixed Graphical Models via Exponential Families. In AISTATS (Vol. 2012, pp. 1042-1050).
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2010). Regularization paths for generalized linear models via coordinate descent. Journal of statistical software, 33(1), 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## We fit a pairwise and 3-order MGM to the mixed Autism dataset (?autism_data)

# 1) Fit Pairwise MGM

# Call mgm()
fit_k2 &lt;- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 2) # ad most pairwise interacitons

# Weighted adjacency matrix
fit_k2$pairwise$wadj

# Visualize using qgraph()
library(qgraph)
qgraph(fit_k2$pairwise$wadj,
       edge.color = fit_k2$pairwise$edgecolor,
       layout = "spring",
       labels =  autism_data$colnames)


# 2) Fit MGM with pairwise &amp; three-way interactions
fit_k3 &lt;- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 3) # include all interactions up to including order 3

# List of estimated interactions
fit_k3$interactions$indicator

# 3) Plot Factor Graph 
FactorGraph(object = fit_k3, 
            PairwiseAsEdge = FALSE, 
            labels = autism_data$colnames)

# 4) Predict values
pred_obj &lt;- predict(fit_k3, autism_data$data)

head(pred_obj$predicted) # first six rows of predicted values
pred_obj$errors # Nodewise errors


## Here we illustrate why we need to overparameterize the design matrix to 
## recover higher order interactions including categorical variables

# 1) Define Graph (one 3-way interaction between 3 binary variables)

# a) General Graph Info
type = c("c", "c", "c")
level = c(2, 2, 2)
# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- NULL # no pairwise interactions
factors[[2]] &lt;- matrix(c(1,2,3), ncol=3, byrow = T) # one 3-way interaction
interactions &lt;- list()
interactions[[1]] &lt;- NULL
interactions[[2]] &lt;- vector("list", length = 1)
# threeway interaction no1
interactions[[2]][[1]] &lt;- array(0, dim = c(level[1], level[2], level[3]))
theta &lt;- .7
interactions[[2]][[1]][1, 1, 1] &lt;- theta  #weight theta for conf (1,1,1), weight 0 for all others
# c) Define Thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- c(0, 0)
thresholds[[2]] &lt;- c(0, 0)
thresholds[[3]] &lt;- c(0, 0)


# 2) Sample from Graph
iter &lt;- 1
set.seed(iter)
N &lt;- 2000
d_iter &lt;- mgmsampler(factors = factors,
                     interactions = interactions,
                     thresholds = thresholds,
                     type = type,
                     level = level,
                     N = N,
                     nIter = 50,
                     pbar = TRUE)


# 3.1) Estimate order 3 MGM using standard parameterization
d_est_stand &lt;- mgm(data = d_iter$data,
                   type = type,
                   level = level,
                   k = 3,
                   lambdaSel = "CV",
                   ruleReg = "AND",
                   pbar = TRUE, 
                   overparameterize = FALSE, 
                   signInfo = FALSE)

# We look at the nodewise regression for node 1 (same for all)
coefs_stand &lt;- d_est_stand$nodemodels[[1]]$model
coefs_stand 
# We see that nonzero-zero pattern of parameter vector does not allow us to infer whether 
# interactions are present or not


# 3.2) Estimate order 3 MGM using overparameterization
d_est_over &lt;- mgm(data = d_iter$data,
                  type = type,
                  level = level,
                  k = 3,
                  lambdaSel = "CV",
                  ruleReg = "AND",
                  pbar = TRUE, 
                  overparameterize = TRUE, 
                  signInfo = FALSE)

# We look at the nodewise regression for node 1 (same for all)
coefs_over &lt;- d_est_over$nodemodels[[1]]$model
coefs_over # recovers exactly the 3-way interaction


# For more examples see https://github.com/jmbh/mgmDocumentation




## End(Not run)


</code></pre>

<hr>
<h2 id='mgm-internal'>Internal mgm functions</h2><span id='topic+DrawFG'></span><span id='topic+DrawFGtv'></span><span id='topic+FlagSymmetric'></span><span id='topic+bwSelPredict'></span><span id='topic+calcLL'></span><span id='topic+calcNeighbors'></span><span id='topic+glmnetRequirements'></span><span id='topic+lagData'></span><span id='topic+nodeEst'></span><span id='topic+ModelMatrix'></span><span id='topic+ModelMatrix_standard'></span>

<h3>Description</h3>

<p>Internal mgm functions.</p>


<h3>Details</h3>

<p>These are internal functions.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck</p>

<hr>
<h2 id='mgmsampler'>
Sample from k-order Mixed Graphical Model
</h2><span id='topic+mgmsampler'></span>

<h3>Description</h3>

<p>Generates samples from a k-order Mixed Graphical Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgmsampler(factors, interactions, thresholds, sds, type,
           level, N, nIter = 250, pbar = TRUE, 
           divWarning = 10^3, returnChains = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgmsampler_+3A_factors">factors</code></td>
<td>

<p>This object indicates which interactions are present in the model.  It is a list in which the first entry corresponds to 2-way interactions, the second entry corresponds to 3-way interactions, etc. and the kth entry to the k+1-way interaction. Each entry contains a matrix with dimensions order x number of interaction of given order. Each row in the matrix indicates an interaction, e.g. (1, 3, 7, 9) in the matrix in list entry three indicates a 4-way interaction between the variables 1, 3, 7 and 9.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_interactions">interactions</code></td>
<td>

<p>This object specifies the parameters associated to the interactions specified in <code>factors</code>. Corresponding to the structure in <code>factors</code>, this object is a list, where the kth entry corresponds to k+1-way interactions. Each list entry contains another list, with entries equal to the number of rows in the corresponding matrix in <code>factors</code>. Each of these list entries (for a fixed k) contains a k-dimensional array that specifies the parameters of the given k-order interaction. For instance, if we have a 3-way interaction (1, 2, 3) and all variables are binary, we have a 2 x 2 x 2 array specifiying the parameters for each of the 2^3 = 8 possible configurations. If all variables are continuous, we have a 1 x 1 x 1 array, so the interaction is specified by a single parameter. See the examples below for an illustration.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_thresholds">thresholds</code></td>
<td>

<p>A list with p entries corresponding to p variables in the model. Each entry contains a vector indicating the threshold for each category (for categorical variables) or a numeric value indicating the threshold/intercept (for continuous variables).
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_sds">sds</code></td>
<td>

<p>A numeric vector with p entries, specifying the variances of Gaussian variables. If variables 6 and 13 are Gaussians, then the corresponding entries of <code>sds</code> have to contain the corresponding variances. Other entries are ignored.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_type">type</code></td>
<td>

<p>p character vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; of each variable.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_level">level</code></td>
<td>

<p>p integer vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_n">N</code></td>
<td>

<p>Number of samples that should be drawn from the distribution.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_niter">nIter</code></td>
<td>

<p>Number of iterations in the Gibbs sampler until a sample is drawn.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code> a progress bar is shown. Defaults to <code>pbar = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_divwarning">divWarning</code></td>
<td>

<p><code>mgmsampler()</code> returns a warning message if the absolute value of a continuous variable the chain of the gibbs sampler is larger than <code>divWarning</code>. To our best knowledge there is no theory yet defining a parameter space that ensures a proper probability density and hence a converging chain. Defaults to <code>divWarning = 10^3</code>.
</p>
</td></tr>
<tr><td><code id="mgmsampler_+3A_returnchains">returnChains</code></td>
<td>

<p>If <code>returnChains = TRUE</code>, the sampler provides the entire chain of the Gibbs sampler, for each sampled case. Can be used to check convergence of the Gibbs sampler. Defaults to <code>returnChains = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use a Gibbs sampler to sample from the join distribution introduced by Yang and colleageus (2014). Note that the contraints on the parameter space necessary to ensure that the joint distribution is normalizable are to our best knowledge unknown. Yang and colleagues (2014) give these constraints for a number of simple pairwise models. In practice, an &quot;improper joint density&quot; will lead to a sampling process that approaches infinity, and hence <code>mgmsampler()</code> will return <code>Inf</code> / <code>-Inf</code> values.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments.
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>The N x p data matrix of sampled values
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J., &amp; Waldorp, L. J. (2018). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. arXiv preprint arXiv:1510.06871.
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G. I., &amp; Liu, Z. (2014, April). Mixed Graphical Models via Exponential Families. In AISTATS (Vol. 2012, pp. 1042-1050).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# --------- Example 1: p = 10 dimensional Gaussian ---------

# ----- 1) Specify Model -----

# a) General Graph Info
p &lt;- 10 # number of variables
type = rep("g", p) # type of variables
level = rep(1, 10) # number of categories for each variable (1 = convention for continuous)

# b) Define interactions
factors &lt;- list()
factors[[1]] &lt;- matrix(c(1,2,
                         1,3,
                         4,5,
                         7,8), ncol=2, byrow = T) # 4 pairwise interactions
interactions &lt;- list()
interactions[[1]] &lt;- vector("list", length = 4)

# all pairwise interactions have value .5
for(i in 1:4) interactions[[1]][[i]] &lt;- array(.5, dim=c(1, 1))

# c) Define Thresholds
thresholds &lt;- vector("list", length = p)
thresholds &lt;- lapply(thresholds, function(x) 0 ) # all means are zero

# d) Define Variances
sds &lt;- rep(1, p) # All variances equal to 1


# ----- 2) Sample cases -----

data &lt;- mgmsampler(factors = factors,
                   interactions = interactions,
                   thresholds = thresholds,
                   sds = sds,
                   type = type,
                   level = level,
                   N = 500,
                   nIter = 100,
                   pbar = TRUE)


# ----- 3) Recover model from sampled cases -----

set.seed(1)
mgm_obj &lt;- mgm(data = data$data,
               type = type,
               level = level,
               k = 2,
               lambdaSel = "EBIC",
               lambdaGam = 0.25)

mgm_obj$interactions$indicator # worked!



# --------- Example 2: p = 3 Binary model with one 3-way interaction ---------

# ----- 1) Specify Model -----

# a) General Graph Info
type = c("c", "c", "c")
level = c(2, 2, 2)

# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- NULL # no pairwise interactions
factors[[2]] &lt;- matrix(c(1,2,3), ncol=3, byrow = T) # one 3-way interaction

interactions &lt;- list()
interactions[[1]] &lt;- NULL
interactions[[2]] &lt;- vector("list", length = 1)
# threeway interaction no1
interactions[[2]][[1]] &lt;- array(0, dim = c(level[1], level[2], level[3]))
theta &lt;- 2
interactions[[2]][[1]][1, 1, 1] &lt;- theta # fill in nonzero entries
# thus: high probability for the case that x1 = x2 = x3 = 1

# c) Define Thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- rep(0, level[1])
thresholds[[2]] &lt;- rep(0, level[2])
thresholds[[3]] &lt;- rep(0, level[3])


# ----- 2) Sample cases -----

set.seed(1)
dlist &lt;- mgmsampler(factors = factors,
                    interactions = interactions,
                    thresholds = thresholds,
                    type = type,
                    level = level,
                    N = 500,
                    nIter = 100,
                    pbar = TRUE)


# ----- 3) Check: Contingency Table -----

dat &lt;- dlist$data
table(dat[,1], dat[,2], dat[,3]) # this is what we expected


# ----- 4) Recover model from sampled cases -----

mgm_obj &lt;- mgm(data = dlist$data,
               type = type,
               level = level,
               k = 3,
               lambdaSel = "EBIC",
               lambdaGam = 0.25, 
               overparameterize = TRUE)

mgm_obj$interactions$indicator # recovered, plus small spurious pairwise 1-2


# --------- Example 3: p = 5 Mixed Graphical Model with two 3-way interaction ---------

# ----- 1) Specify Model -----

# a) General Graph Info
type = c("g", "c", "c", "g")
level = c(1, 3, 5, 1)
# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- NULL # no pairwise interactions
factors[[2]] &lt;- matrix(c(1,2,3,
                         2,3,4), ncol=3, byrow = T) # no pairwise interactions
interactions &lt;- list()
interactions[[1]] &lt;- NULL
interactions[[2]] &lt;- vector("list", length = 2)
# 3-way interaction no1
interactions[[2]][[1]] &lt;- array(0, dim = c(level[1], level[2], level[3]))
interactions[[2]][[1]][,,1:3] &lt;- rep(.8, 3) # fill in nonzero entries
# 3-way interaction no2
interactions[[2]][[2]] &lt;- array(0, dim = c(level[2], level[3], level[4]))
interactions[[2]][[2]][1,1,] &lt;- .3
interactions[[2]][[2]][2,2,] &lt;- .3
interactions[[2]][[2]][3,3,] &lt;- .3
# c) Define Thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- 0
thresholds[[2]] &lt;- rep(0, level[2])
thresholds[[3]] &lt;- rep(0, level[3])
thresholds[[4]] &lt;- 0
# d) Define Variances
sds &lt;- rep(.1, length(type))


# ----- 2) Sample cases -----

set.seed(1)
data &lt;- mgmsampler(factors = factors,
                   interactions = interactions,
                   thresholds = thresholds,
                   sds = sds,
                   type = type,
                   level = level,
                   N = 500,
                   nIter = 100,
                   pbar = TRUE)


# ----- 3) Check: Conditional Means -----

# We condition on the categorical variables and check whether
# the conditional means match what we expect from the model:

dat &lt;- data$data

# Check interaction 1
mean(dat[dat[,2] == 1 &amp; dat[,3] == 1, 1]) # (compare with interactions[[2]][[1]])
mean(dat[dat[,2] == 1 &amp; dat[,3] == 5, 1])
# first mean higher, ok!

# Check interaction 2
mean(dat[dat[,2] == 1 &amp; dat[,3] == 1, 4]) # (compare with interactions[[2]][[2]])
mean(dat[dat[,2] == 1 &amp; dat[,3] == 2, 4])
# first mean higher, ok!



## End(Not run)

</code></pre>

<hr>
<h2 id='mvar'>
Estimating mixed Vector Autoregressive Model (mVAR)
</h2><span id='topic+mvar'></span><span id='topic+var.mgm'></span>

<h3>Description</h3>

<p>Estimates mixed Vector Autoregressive Model (mVAR) via elastic-net regularized Generalized Linear Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvar(data, type, level, regularize, lambdaSeq, lambdaSel, 
     lambdaFolds, lambdaGam, alphaSeq, alphaSel, alphaFolds, 
     alphaGam, lags, consec, beepvar, dayvar, weights, threshold, 
     method, binarySign,scale, verbatim, pbar, warnings, saveModels, 
     saveData, overparameterize, thresholdCat, signInfo, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvar_+3A_data">data</code></td>
<td>

<p>n x p data matrix.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>. <code>"g"</code> for Gaussian, <code>"p"</code> for Poisson, <code>"c"</code> for categorical.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_regularize">regularize</code></td>
<td>

<p>Logical indicating whether regularization is applied. If <code>regularize = FALSE</code>, all arguments relating to the specification are overwritten and all regularization parameters are set to <code>0</code>. This also sets <code>threshold = "none"</code>. Defaults to <code>regularize = TRUE</code>. Note that the multinomial parameterization used by the <code>glmnet</code> package used within <code>mgm</code> is only guaranteed to be uniquely identified with regularization.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_lambdaseq">lambdaSeq</code></td>
<td>

<p>A sequence of lambdas that should be searched (see also <code>lambdaSel</code>). Defaults to <code>NULL</code>, which uses the  <code>glmnet</code> default to select a lambda candidate sequence (recommended). See <code>?glmnet</code> for details.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_lambdasel">lambdaSel</code></td>
<td>

<p>Specifies the procedure for selecting the tuning parameter controlling the Lq-penalization. The two options are cross validation &quot;CV&quot; and the Extended Bayesian Information Criterion (EBIC) &quot;EBIC&quot;. The EBIC performs well in selecting sparse graphs (see Barber and Drton, 2010 and Foygel and Drton, 2014). Note that when also searching the alpha parameter in the elastic net penalty, cross validation should be preferred, as the parameter vector will not necessarily be sparse anymore. The EBIC tends to be a bit more conservative than CV (see Haslbeck and Waldorp, 2016). CV can sometimes not be performed with categorical variables, because <code>glmnet</code> requires at least 2 events of each category of each categorical variable in each training-fold. Defaults to <code>lambdaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_lambdafolds">lambdaFolds</code></td>
<td>

<p>Number of folds in cross validation if <code>lambdaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_lambdagam">lambdaGam</code></td>
<td>

<p>Hyperparameter gamma in the EBIC if <code>lambdaSel = "EBIC"</code>. Defaults to <code>lambdaGam = .25</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_alphaseq">alphaSeq</code></td>
<td>

<p>A sequence of alpha parameters for the elastic net penality in [0,1] that should be searched (see also <code>alphaSel</code>). Defaults to <code>alphaSeq = 1</code>, which means that the lasso is being used. <code>alphaSeq = 0</code> corresponds to an L2-penalty (Ridge regression). For details see Friedman, Hastie and Tibshirani (2010).
</p>
</td></tr>
<tr><td><code id="mvar_+3A_alphasel">alphaSel</code></td>
<td>

<p>Specifies the procedure for selecting the alpha parameter in the elastic net penalty. The two options are cross validation &quot;CV&quot; and the Extended Bayesian Information Criterion (EBIC) &quot;EBIC&quot;. The EBIC performs well in selecting sparse graphs (see Barber and Drton, 2010 and Foygel and Drton, 2014). Note that when also searching the alpha parameter in the elastic net penalty, cross validation should be preferred, as the parameter vector will not necessarily be sparse anymore. The EBIC tends to be a bit more conservative than CV (see Haslbeck and Waldorp, 2016). CV can sometimes not be performed with categorical variables, because <code>glmnet</code> requires at least 2 events of each category of each categorical variable in each training-fold. Defaults to <code>alphaSel = "CV"</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_alphafolds">alphaFolds</code></td>
<td>

<p>Number of folds in cross validation if <code>alphaSel = "CV"</code>
</p>
</td></tr>
<tr><td><code id="mvar_+3A_alphagam">alphaGam</code></td>
<td>

<p>Hyperparameter gamma in the EBIC if <code>alphaSel = "EBIC"</code>. Defaults to <code>alphaGam = .25</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_lags">lags</code></td>
<td>

<p>Vector of positive integers indicating the lags included in the mVAR model (e.g. 1:3 or c(1,3,5))
</p>
</td></tr>
<tr><td><code id="mvar_+3A_consec">consec</code></td>
<td>

<p>An integer vector of length n, indicating the consecutiveness of measurement points of the rows in <code>data</code>. This means that rows for which the necessary (defined by the specified VAR model) measurements at previous time points are not available are excluded from the analysis. For instance, for a VAR model with lag 1 a consec vector of <code>consec = c(1,2,3,5)</code> would mean that the fourth row is excluded from the analysis, since no measurement 5-1=4 is available (next to the first row, for which also no previous measurement can be available). This is useful in many applications in which measurements are missing randomly or due to the design of the data collection (for example, respondents only respond during the hours they are awake). The &quot;trimmed&quot; dataset is returned in <code>call$data_lagged</code> if <code>saveData = TRUE</code>. Defaults to <code>consec = NULL</code>, which assumes that all measurements are consecutive, i.e. <code>consec = 1:n</code>. In this case only the first <code>max(lags)</code> lags are excluded to obtain the VAR design matrix.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_beepvar">beepvar</code></td>
<td>
<p>Together with the argument <code>dayvar</code>, this argument is an alternative to the <code>consec</code> argument (see above) to specify the consecutiveness of measurements. This is tailored to experience sampling method (ESM) studies, where the consectutiveness is defined by the number of notification on a given day (<code>beepvar</code>) and the given day (<code>dayvar</code>).
</p>
</td></tr>
<tr><td><code id="mvar_+3A_dayvar">dayvar</code></td>
<td>
<p>See <code>beepvar</code>.</p>
</td></tr>
<tr><td><code id="mvar_+3A_weights">weights</code></td>
<td>

<p>A vector with n - max(lags) entries, indicating the weight for each observation. The mVAR design matrix has with n - max(lags) rows, because the first row must be predictable by the highest lag. The weights have to be on the scale [0, n - max(lags) ].
</p>
</td></tr>
<tr><td><code id="mvar_+3A_threshold">threshold</code></td>
<td>

<p>A threshold below which edge-weights are put to zero. This is done in order to guarantee a lower bound on the false-positive rate. <code>threshold = "LW"</code> refers to the threshold in Loh and Wainwright (2013), which was used in all previous versions of mgm. <code>threshold = "HW"</code> refers to the threshold in Haslbeck and Waldorp (2016). If <code>threshold = "none"</code> no thresholding is applied.  Defaults to <code>threshold = "LW"</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_method">method</code></td>
<td>

<p>Estimation method, currently only <code>method = "glm"</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_binarysign">binarySign</code></td>
<td>

<p>If <code>binarySign = TRUE</code>, a sign for the interaction within binary nodes and between binary and continuous nodes is provided in the output. Note that in this case the two categories of the binary variables have to be coded in <code>{0,1}</code>. This is to ensure that the interpretation of the sign is unambigous: a positive sign of a parameter means that increasing the associated predictor results in a higher probability for category 1.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_scale">scale</code></td>
<td>

<p>If <code>scale = TRUE</code>, all Gaussian nodes (specified by <code>"g"</code> in the <code>type</code> argument) are centered and divided by their standard deviation. Scaling is recommended, because otherwise the penalization of a parameter depends on the variance of the associated predictor.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_verbatim">verbatim</code></td>
<td>

<p>If <code>verbatim = TRUE</code>, no warnings and no progress bar is shown. Defaults to <code>verbatim = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code>, a progress bar is shown. Defaults to <code>pbar = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_warnings">warnings</code></td>
<td>

<p>If <code>warnings = TRUE</code>, no warnigns are returned. Defaults to <code>warnings = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_savemodels">saveModels</code></td>
<td>

<p>If <code>saveModels = FALSE</code>, only information about the weighted adjacency matrix, and if d &gt; 1 about the factor graph is provided in the output list. If <code>saveModels = TRUE</code>, all fitted parameters are additionally returned.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_savedata">saveData</code></td>
<td>

<p>If <code>saveData = TRUE</code>, the data is saved in the output list. Defaults to <code>saveData = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_overparameterize">overparameterize</code></td>
<td>

<p>If <code>overparameterize = TRUE</code>, <code>mgm()</code> uses over-parameterized design-matrices for each neighborhood regression; this means that a cross-lagged effect between two categorical variables with m and s categories is parameterized by m*s parameters. If <code>overparameterize = FALSE</code> the standard parameterization (in <code>glmnet</code>) with m*(s-1) parameters is used, where the first category of the predicting variable serves as reference category. If all variables are continuous both parameterizations are the same. The default is set to <code>overparameterize = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_thresholdcat">thresholdCat</code></td>
<td>

<p>If <code>thresholdCat = FALSE</code>, the thresholds of categorical variables are set to zero. Defaults to <code>thresholdCat = TRUE</code> for which the thresholds are esimated.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_signinfo">signInfo</code></td>
<td>

<p>If <code>signInfo = TRUE</code>, a message is shown in the console, indicating that the sign of estimates is stored separately. Defaults to <code>signInfo = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mvar_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Haslbeck and Waldorp (2018) for details about how the mixed VAR model is estimated.
</p>


<h3>Value</h3>

<p>The function returns a list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments. If <code>saveData = TRUE</code>, it also contains the data.
</p>
</td></tr>
<tr><td><code>wadj</code></td>
<td>

<p>A p x p x n_lags array, in which rows are predicted by columns, i.e. entry <code>wadj[1, 2, 4]</code> corresponds to the parameter(s) of variable 2 at time point t predicting variable 1 at time point t - z, where z is the fourth specified lag in <code>lags</code> and n_lags is the number of specified lags in <code>lags</code>. For interactions that involve more than two parameters (e.g. always for categorical variables with more than 2 categories), we take the arithmetic mean of the absolute value of all parameters. The full set of estimated parameters is saved in <code>rawlags</code> (see below).
</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>

<p>A p x p x n_lags array, specifying the signs corresponding to the entries of <code>wadj</code> (if defined), where n_lags is the number of specified lags in <code>lags</code>. 1/-1 indicate positive and negative relationships, respectively. 0 indicates that no sign is defined, which is the case for interactions that involve a categorical variable where an interaction can have more than one parameter. If <code>binarySign = TRUE</code>, a sign is calculated for interactions between binary variables and binary and continuous variables, where the interaction is still defined by one parameter and hence a sign can be specified. <code>NA</code> indicates that the corresponding parameter in <code>wadj</code> is zero.
</p>
</td></tr>
<tr><td><code>edgecolor</code></td>
<td>

<p>A p x p x n_lags array of colors indicating the sign of each parameter. This array contains the same information is <code>signs</code> and is included for convenient plotting.
</p>
</td></tr>
<tr><td><code>rawlags</code></td>
<td>

<p>List with entries equal to the number of specified lags in <code>lags</code>. Each entry is a nested list, with each p entries: the first level indicates the predicted variable, the second level the predictor variable. In case of categorical variables, interactions have more than one parameter.
</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>

<p>A list with p entries, which contain the intercept/thresholds for each node. In case a given node is categorical with m categories, there are m thresholds for this variable.
</p>
</td></tr>
<tr><td><code>nodemodels</code></td>
<td>

<p>A list with p <code>glmnet()</code> models, from which all above output is computed. Also contains the coefficients <code>models</code> for the selected lambda and the applied tau threshold <code>tau</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Barber, R. F., &amp; Drton, M. (2015). High-dimensional Ising model selection with Bayesian information criteria. Electronic Journal of Statistics, 9(1), 567-607.
</p>
<p>Foygel, R., &amp; Drton, M. (2010). Extended Bayesian information criteria for Gaussian graphical models. In Advances in neural information processing systems (pp. 604-612).
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2010). Regularization paths for generalized linear models via coordinate descent. Journal of statistical software, 33(1), 1.
</p>
<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>
<p>Loh, P. L., &amp; Wainwright, M. J. (2012, December). Structure estimation for discrete graphical models: Generalized covariance matrices and their inverses. In NIPS (pp. 2096-2104).
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G. I., &amp; Liu, Z. (2014, April). Mixed Graphical Models via Exponential Families. In AISTATS (Vol. 2012, pp. 1042-1050).
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2010). Regularization paths for generalized linear models via coordinate descent. Journal of statistical software, 33(1), 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## We generate data from a mixed VAR model and then recover the model using mvar()

# 1) Define mVAR model
p &lt;- 6 # Six variables
type &lt;- c("c", "c", "c", "c", "g", "g") # 4 categorical, 2 gaussians
level &lt;- c(2, 2, 4, 4, 1, 1) # 2 categoricals with m=2, 2 categoricals with m=4, two continuous
max_level &lt;- max(level)

lags &lt;- c(1, 3, 9) # include lagged effects of order 1, 3, 9
n_lags &lt;- length(lags)

# Specify thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- rep(0, level[1])
thresholds[[2]] &lt;- rep(0, level[2])
thresholds[[3]] &lt;- rep(0, level[3])
thresholds[[4]] &lt;- rep(0, level[4])
thresholds[[5]] &lt;- rep(0, level[5])
thresholds[[6]] &lt;- rep(0, level[6])

# Specify standard deviations for the Gaussians
sds &lt;- rep(NULL, p)
sds[5:6] &lt;- 1

# Create coefficient array
coefarray &lt;- array(0, dim=c(p, p, max_level, max_level, n_lags))

# a.1) interaction between continuous 5&lt;-6, lag=3
coefarray[5, 6, 1, 1, 2] &lt;- .4
# a.2) interaction between 1&lt;-3, lag=1
m1 &lt;- matrix(0, nrow=level[2], ncol=level[4])
m1[1,1:2] &lt;- 1
m1[2,3:4] &lt;- 1
coefarray[1, 3, 1:level[2], 1:level[4], 1] &lt;- m1
# a.3) interaction between 1&lt;-5, lag=9
coefarray[1, 5, 1:level[1], 1:level[5], 3] &lt;- c(0, 1)


# 2) Sample
set.seed(1)
dlist &lt;- mvarsampler(coefarray = coefarray,
                     lags = lags,
                     thresholds = thresholds,
                     sds = sds,
                     type = type,
                     level = level,
                     N = 200,
                     pbar = TRUE)

# 3) Recover
set.seed(1)
mvar_obj &lt;- mvar(data = dlist$data,
                 type = type,
                 level = level,
                 lambdaSel = "CV",
                 lags = c(1, 3, 9),
                 signInfo = FALSE,
                 overparameterize = F)

# Did we recover the true parameters?
mvar_obj$wadj[5, 6, 2] # cross-lagged effect of 6 on 2 over lag lags[2]
mvar_obj$wadj[1, 3, 1] # cross-lagged effect of 3 on 1 over lag lags[1]
mvar_obj$wadj[1, 5, 3] # cross-lagged effect of 1 on 5 over lag lags[3]

# How to get the exact parameter estimates?
# Example: the full parameters for the crossed-lagged interaction of 2 on 1 over lag lags[1]
mvar_obj$rawlags[[1]][[1]][[2]] 

# 4) Predict / Compute nodewise Error
pred_mvar &lt;- predict.mgm(mvar_obj, dlist$data)

head(pred_mvar$predicted) # first 6 rows of predicted values
pred_mvar$errors # Nodewise errors

# For more examples see https://github.com/jmbh/mgmDocumentation


## End(Not run)

</code></pre>

<hr>
<h2 id='mvarsampler'>
Sampling from a mixed VAR model
</h2><span id='topic+mvarsampler'></span>

<h3>Description</h3>

<p>Function to sample from a mixed VAR (mVAR) model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvarsampler(coefarray, lags, thresholds, 
            sds, type, level, N, pbar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvarsampler_+3A_coefarray">coefarray</code></td>
<td>

<p>A p x p x max(level) x max(level) x n_lags array, where p are the number of variables, level is the input argument <code>level</code> and n_lags is the number of specified lags in <code>lags</code>, so n_lags = length(n_lags). The first four dimensions specify the parameters involved in the cross-lagged effects of the lag specified in the 5th dimension. I.e. coefarray[5, 6, 1, 1, 3] indicates the cross-lagged effect of variable 6 on variable 5 (if both are continuous), for the third lag specified in <code>lags</code>. If variable 1 and 3 are categorical with m = 2 and  = 4 categories, respectively, then coefarray[1, 3, 1:2, 1:4, 1] indicates the m*s=8 parameters specifying this interaction for the first lag specified in <code>lags</code>. See the examples below for an illustration.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_lags">lags</code></td>
<td>

<p>A vector indicating the lags in the mVAR model. E.g. <code>lags = c(1, 4, 9)</code> specifies lags of order 1, 3, 9. The number of specified lags has to match the 5th dimension in <code>coefarray</code>.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_thresholds">thresholds</code></td>
<td>

<p>A list with p entries, each consisting of a vector indicating a threshold for each category of the given variable. For continuous variable, the vector has length 1.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_sds">sds</code></td>
<td>

<p>A vector of length p indicating the standard deviations of the included Gaussian nodes. If non-Gaussian variables are included in the mVAR model, the corresponding entries are ignored.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_n">N</code></td>
<td>

<p>The number of samples to be drawn from the specified mVAR model.
</p>
</td></tr>
<tr><td><code id="mvarsampler_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code>, a progress bar is shown.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We sample from the mVAR model by separately sampling from its corresponding p conditional distributions.
</p>


<h3>Value</h3>

<p>A list with two entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The sampled n x p data matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## Generate data from mixed VAR model using mvarsampler() and recover model using mvar()

# 1) Define mVAR model

p &lt;- 6 # Six variables
type &lt;- c("c", "c", "c", "c", "g", "g") # 4 categorical, 2 gaussians
level &lt;- c(2, 2, 4, 4, 1, 1) # 2 categoricals with m=2, 2 categoricals with m=4, two continuous
max_level &lt;- max(level)

lags &lt;- c(1, 3, 9) # include lagged effects of order 1, 3, 9
n_lags &lt;- length(lags)

# Specify thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- rep(0, level[1])
thresholds[[2]] &lt;- rep(0, level[2])
thresholds[[3]] &lt;- rep(0, level[3])
thresholds[[4]] &lt;- rep(0, level[4])
thresholds[[5]] &lt;- rep(0, level[5])
thresholds[[6]] &lt;- rep(0, level[6])

# Specify standard deviations for the Gaussians
sds &lt;- rep(NULL, p)
sds[5:6] &lt;- 1

# Create coefficient array
coefarray &lt;- array(0, dim=c(p, p, max_level, max_level, n_lags))

# a.1) interaction between continuous 5&lt;-6, lag=3
coefarray[5, 6, 1, 1, 2] &lt;- .4
# a.2) interaction between 1&lt;-3, lag=1
m1 &lt;- matrix(0, nrow=level[2], ncol=level[4])
m1[1,1:2] &lt;- 1
m1[2,3:4] &lt;- 1
coefarray[1, 3, 1:level[2], 1:level[4], 1] &lt;- m1
# a.3) interaction between 1&lt;-5, lag=9
coefarray[1, 5, 1:level[1], 1:level[5], 3] &lt;- c(0, 1)


# 2) Sample
set.seed(1)
dlist &lt;- mvarsampler(coefarray = coefarray,
                     lags = lags,
                     thresholds = thresholds,
                     sds = sds,
                     type = type,
                     level = level,
                     N = 200,
                     pbar = TRUE)

# 3) Recover
set.seed(1)
mvar_obj &lt;- mvar(data = dlist$data,
                 type = type,
                 level = level,
                 lambdaSel = "CV",
                 lags = c(1, 3, 9),
                 signInfo = FALSE,
                 overparameterize = F)

# Did we recover the true parameters?
mvar_obj$wadj[5, 6, 2] # cross-lagged effect of 6 on 5 over lag lags[2]
mvar_obj$wadj[1, 3, 1] # cross-lagged effect of 3 on 1 over lag lags[1]
mvar_obj$wadj[1, 5, 3] # cross-lagged effect of 1 on 5 over lag lags[3]


# For more examples see https://github.com/jmbh/mgmDocumentation



## End(Not run)

</code></pre>

<hr>
<h2 id='plotRes'>
Plot summary of resampled sampling distributions
</h2><span id='topic+plotRes'></span>

<h3>Description</h3>

<p>Plots a summary of sampling distributions resampled with the resample() function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRes(object, quantiles = c(.05, .95), labels = NULL, 
        decreasing = TRUE, cut = NULL, cex.label = 0.75, 
        lwd.qtl = 2, cex.mean = 0.55, cex.bg = 2.7, 
        axis.ticks = c(-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1), 
        axis.ticks.mod = NULL, layout.width.labels = .2,
        layout.gap.pw.mod = .15, table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRes_+3A_object">object</code></td>
<td>

<p>An output object from the <code>resample()</code> function.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_quantiles">quantiles</code></td>
<td>

<p>A numerical vector of length two, specifying the desired lower/upper quantiles. Defaults to <code>quantiles = c(.05, .95)</code>.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_labels">labels</code></td>
<td>

<p>A character vector of length p, containing the label of each variable, where p is the number of variables.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_decreasing">decreasing</code></td>
<td>

<p>If <code>TRUE</code> (default), the edges are ordered by the arithmetic mean of the sampling distribution in decreasing order. If <code>FALSE</code> they are ordered in increasing order.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_cut">cut</code></td>
<td>

<p>A sequence of integers, specifying which edges are represented. For instance, if <code>decreasing = TRUE</code> and <code>cut = 1:10</code>, summaries for the 10 edges with the largest parameter estimate are displayed. The cut argument can also be used to present the boostrapped CIs in several figures.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_cex.label">cex.label</code></td>
<td>

<p>Text size of the labels.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_lwd.qtl">lwd.qtl</code></td>
<td>

<p>Line width of line indicating the upper/lower quantiles.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_cex.mean">cex.mean</code></td>
<td>

<p>Text size of the number indicating the proportion of the estimates whose absolute value is larger than zero.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_cex.bg">cex.bg</code></td>
<td>

<p>Size of the white background of the number indicating the proportion of the estimates whose absolute value is larger than zero.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_axis.ticks">axis.ticks</code></td>
<td>

<p>A numeric vector indicating the axis ticks and labels for the x-axis.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_axis.ticks.mod">axis.ticks.mod</code></td>
<td>

<p>A numeric vector indicating the axis ticks and labels for the x-axis for moderation effects. If <code>axis.ticks.mod=NULL</code>, the values from <code>axis.ticks</code> for pairwise interactions are used.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_layout.width.labels">layout.width.labels</code></td>
<td>

<p>A positive numeric value which specifies the width of the left-hand-side legend relative to the width of the data panel (or data panels, in case of a moderator model), which have width = 1. Defaults to <code>layout.width.labels = 0.2</code>.</p>
</td></tr>
<tr><td><code id="plotRes_+3A_layout.gap.pw.mod">layout.gap.pw.mod</code></td>
<td>

<p>A positive numeric value which specifies the width of the gap between the stability of pairwise effects and moderation effects. Defaults to <code>layout.gap.pw.mod = 0.15</code>.
</p>
</td></tr>
<tr><td><code id="plotRes_+3A_table">table</code></td>
<td>

<p>If <code>table = TRUE</code>, the output is presented as a table instead of a figure. Defaults to <code>table = FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only supports summaries for resampled <code>mgm()</code> objects, and moderated MGMs with a single moderator.
</p>


<h3>Value</h3>

<p>Plots a figure that shows summaries of the resampled sampling distribution for (a set of) all edge parameters. These include the mean, a specified upper and lower quantile and the proportion of parameter estimates whose absolute value is larger than zero.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>resample()</code>, <code>mgm()</code>, <code>mvar()</code>, <code>tvmgm()</code>, <code>tvmar()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Fit initial model
fit_aut &lt;- mgm(data = as.matrix(autism_data$data),
               type = autism_data$type,
               level = autism_data$lev,
               k = 2)


# Fit bootstrapped models
res_aut &lt;- resample(object = fit_aut, 
                    data = as.matrix(autism_data$data), 
                    nB = 10) # should be more in real applications 

# Plot Summary
plotRes(object = res_aut,
        quantiles = c(.05, .95), 
        labels = NULL, 
        axis.ticks = c(-.25, 0, .25, .5, .75))

  
## End(Not run)
</code></pre>

<hr>
<h2 id='predict.mgm'>
Compute predictions from mgm model objects
</h2><span id='topic+predict.mgm'></span>

<h3>Description</h3>

<p>Computes predictions and prediction errors from a mgm model-object (<code>mgm</code>, <code>mvar</code>, <code>tvmgm</code> or <code>tvmvar</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgm'
predict(object, data, errorCon, errorCat, 
        tvMethod, consec, beepvar, dayvar, errordecimals=3, 
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mgm_+3A_object">object</code></td>
<td>

<p>An mgm model object (the output of one of the functions <code>mgm()</code>, <code>mvar()</code>, <code>tvmgm()</code> or <code>tvmvar()</code>)
</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_data">data</code></td>
<td>

<p>A n x p data matrix with the same structure (number of variables p and types of variables) as the data used to fit the model.
</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_errorcon">errorCon</code></td>
<td>

<p>Either a character vector specifying the types of nodewise errors that should be computed, where the two provided error functions for continuous varaibles are <code>errorCon = "RMSE"</code>, the Root Mean Squared Error, and <code>errorCon = "R2"</code>, the proportion of explained variance. The default is <code>errorCon = c("RMSE" "R2")</code>.
</p>
<p>Alternatively, <code>errorCon</code> can be a list, where each list entry is a custom error function of the form <code>foo(true, pred)</code>, where <code>true</code> and <code>pred</code> are the arguments for the vectors of true and predicted values, respectively.  If predictions are made for a time-varying model and <code>tvMethod = "weighted"</code>, the weighted R2 or RMSE are computed. If a custom function is used, an additional argument for the weights has to be provided: <code>foo(true, pred, weights)</code>. Note that custom error functios can also be combined with the buildt-in functions, i.e. <code>errorCon = list("RMSE", "CustomError"=foo)</code>.</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_errorcat">errorCat</code></td>
<td>

<p>Either a character vector specifying the types of nodewise errors that should be computed, where the two provided error functions for categorical variables are <code>errorCat = "CC"</code>, the proportion of correct classification (accuracy) and <code>errorCat = "nCC"</code>, the proportion of correct classification normalized by the marginal distribution of the variable at hand. Specifically, nCC = (CC - norm_constant) / (1 - norm_constant), where norm_constant is the highest relative frequency across categories. Another provided error is &quot;CCmarg&quot; which returns the accuracy of the intercept/marginal model. The default is to return all types of errors <code>errorCon = c("CC" "nCC", "CCmarg")</code>.
</p>
<p>Alternatively, <code>errorCat</code> can be a list, where each list entry is a custom error function of the form <code>foo(true, pred)</code>, where <code>true</code> and <code>pred</code> are the arguments for the vectors of true and predicted values, respectively.  If predictions are made for a time-varying model and <code>tvMethod = "weighted"</code>, the weighted R2 or RMSE are computed. If a custom function is used, an additional argument for the weights has to be provided: <code>foo(true, pred, weights)</code>. Note that custom error functios can also be combined with the buildt-in functions, i.e. <code>errorCon = list("nCC", "CustomError"=foo)</code>.</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_tvmethod">tvMethod</code></td>
<td>

<p>Specifies how predictions and errors are computed for time-varying models: <code>tvMethod = "weighted"</code> computes errors by computing a weighted error over all cases in the time series at each estimation point specified in <code>estpoints</code> in <code>tvmgm()</code> or <code>tvmvar()</code>. The weighting corresponds to the weighting used for estimation (see <code>?tvmgm</code> or <code>?tvmvar</code>). <code>tvMethod = "closestModel"</code> determines for each time point the closest model and uses that model for prediction. See Details below for a more detailed explanation.
</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_consec">consec</code></td>
<td>
<p>Only relevant for (time-varying) mVAR models. An integer vector of length <code>nrow(data)</code>, indicating the sequence of measurement points in a time series. This is only relevant for mVAR models and time series with unequal time intervals. Defaults to <code>consec = NULL</code>, which assumes equal time intervals. <code>consec</code> is ignored if a <code>mgm</code> or <code>tvmgm</code> object is provided to <code>predict.mgm()</code>. For details see <code>?mvar</code>.</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_beepvar">beepvar</code></td>
<td>
<p>Together with the argument <code>dayvar</code>, this argument is an alternative to the <code>consec</code> argument (see above) to specify the consecutiveness of measurements. This is tailored to ecological momentary assessment (EMA) studies, where the consectutiveness is defined by the number of notification on a given day (<code>beepvar</code>) and the given day (<code>dayvar</code>).
</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_dayvar">dayvar</code></td>
<td>
<p>See <code>beepvar</code>.</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_errordecimals">errordecimals</code></td>
<td>
<p>Number of decimals to which predictability / prediction error values are rounded. Defaults to <code>errordecimals = 3</code>.</p>
</td></tr>
<tr><td><code id="predict.mgm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nodewise errors in time-varying models can be computed in two different ways: first, one computes the predicted value for each of the N cases in the time series for all models (estimated at different estimation points, see <code>?tvmgm</code> or <code>?tvmvar</code>). Then the error of each of the N cases for each of the models is weighted by the weight that has been used to estimate a given model at its estimation point. This means that the error of a data point close to the end of a time-series gets a high weight for models estimated in the end of the time-series and a low weight for models estimated in the beginning of the time series.
</p>
<p>Second, we determine for each case in the time-series the closest estmation point, and use the model estimated at that estimation point to make predictions for that case.
</p>
<p>Note that the error function normalized accuracy (nCC) is negative if the full model performs worse than the intercept model. This can happen if the model overfits the data.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments.
</p>
</td></tr>
<tr><td><code>predicted</code></td>
<td>

<p>A n x p matrix with predicted values, matching the dimension of the true values in <code>true</code>.
</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>

<p>A list with p entries corresponding to p nodes in the data. If a variable is categorical, the corresponding entry contains a n x k matrix with predicted probabilities, where k is the number of categories of the categorical variable. If a variable is continuous, the corresponding entry is empty.
</p>
</td></tr>
<tr><td><code>true</code></td>
<td>

<p>Contains the true values. For <code>mgm</code> and <code>tvmgm</code> objects these are equal to the data provided via <code>data</code>. For <code>mvar</code> and <code>tvmvar</code> objects, these are equal to the rows that can be predicted in a VAR model, depending on the largest specified lag and (if specified) the <code>consec</code> argument. 
</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>

<p>A matrix containing the all types of errors specified via <code>errorCon</code> and <code>errorCat</code>, for each variable. If <code>tvMethod = "weighted"</code>, the matrix becomes an array, with an additional dimension for the estimation point.
</p>
</td></tr>
<tr><td><code>tverrors</code></td>
<td>

<p>If <code>tvMethod = "weighted"</code>, this list entry contains a list with errors of the format of <code>errors</code>, separately for each estimation point. The errors are computed from predictions of the model at the given estimation points and weighted by the weight-vector at that estimation point. If <code>tvMethod = "closestModel"</code>, this entry is empty.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# See examples in ?mgm, ?tvmgm, ?mvar and ?tvmvar.

## End(Not run)

</code></pre>

<hr>
<h2 id='print.int'>
Print method for int objects
</h2><span id='topic+print.int'></span>

<h3>Description</h3>

<p>Returns basic information about objects created with showInteraction()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'int'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.int_+3A_x">x</code></td>
<td>

<p>The output object of showInteraction().
</p>
</td></tr>
<tr><td><code id="print.int_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes basic information about the object in the console.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>

<hr>
<h2 id='print.mgm'>
Print method for mgm objects
</h2><span id='topic+print.mgm'></span>

<h3>Description</h3>

<p>Returns basic information about fit objects, prediction objects and bandwidth-selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgm'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mgm_+3A_x">x</code></td>
<td>

<p>The output object of <code>mgm()</code>, <code>mvar()</code>, <code>tvmgm()</code>, <code>tvmvar()</code>, <code>predict.mgm()</code> or <code>bwSelect()</code>.
</p>
</td></tr>
<tr><td><code id="print.mgm_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes basic information about the object in the console.
</p>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>

<hr>
<h2 id='resample'>
Resampling scheme for mgm objects
</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Fits mgm model types (mgm, mvar, tvmgm, tvmvar) to a specified number of bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(object, data, nB, blocks, quantiles, 
         pbar, verbatim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_object">object</code></td>
<td>

<p>An mgm model object, the output of mgm(), tvmgm(), mvar(), tvmvar(). The model specifications for all fitted models are taken from this model object.
</p>
</td></tr>
<tr><td><code id="resample_+3A_data">data</code></td>
<td>

<p>The n x p data matrix.
</p>
</td></tr>
<tr><td><code id="resample_+3A_nb">nB</code></td>
<td>

<p>The number of bootstrap samples.
</p>
</td></tr>
<tr><td><code id="resample_+3A_blocks">blocks</code></td>
<td>

<p>The number of blocks for the block bootstrap used for time-varying models.
</p>
</td></tr>
<tr><td><code id="resample_+3A_quantiles">quantiles</code></td>
<td>

<p>A vector with two values in [0, 1], specifying quantiles computed on the bootstrapped sampling distributions. Defaults to <code>quantiles = c(.05, .95)</code>
</p>
</td></tr>
<tr><td><code id="resample_+3A_pbar">pbar</code></td>
<td>

<p>If <code>TRUE</code>, a progress bar is shown. Defaults to <code>pbar = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="resample_+3A_verbatim">verbatim</code></td>
<td>

<p>If <code>TRUE</code>, the seed of the current bootstrap sample is printed in the console. Useful to exclude zero-variance bootstrap samples in datasets with low variance.
</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>resample()</code> fits a model specified via the <code>object</code> argument to <code>nB</code> bootstrap samples obtained from the orginial dataset. For stationary models (mgm() and mvar()) objects, we use the standard bootstrap. For time-varying models (tvmgm() and tvmvar()) we use the block bootstrap.
</p>
<p>For mvar models, <code>bootParameters</code> is a p x p x nlags x nB array, where p is the number of variables, nlags is the number of specified lags, and nB is the number of bootstrap samples. Thus <code>bootParameters[7, 3, 2, ]</code> returns the bootstrapped sampling distribution of the lagged effect from variable 3 on 7 for the 2nd specified lag. See also <code>?mvar</code>.
</p>
<p>For tvmar models, <code>bootParameters</code> is a p x p x nlags x nestpoints x nB array, analogously to mvar models. nestpoints is the number of specified estpoints. See also <code>?tvmvar</code>.
</p>
<p>Resampling is currently only supported for pairwise MGMs (<code>k = 2</code>). For mgms, <code>bootParameters</code> is a p x p x nB array. For tvmgms, <code>bootParameters</code> is a p x p x nestpoint x nB array.
</p>
<p>The seeds for the bootstrap samples are randomly sampled. For MGMs, the seeds are resampled until there are nB bootstrap samples on which an MGM can be estimated. This resampling has been implemented, because especially for small data sets, one can obtain bootstrap samples in which one or several variables have zero variance. For the other model classes, an informative error is returned in case the respective model cannot be estimated on one or more of the bootstrap samples.
</p>


<h3>Value</h3>

<p>The output consists of a list with the entries
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>Contains the function call.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>A list with <code>nB</code> entries, containing the models fit to the bootstrapped sampels.</p>
</td></tr>
<tr><td><code>bootParameters</code></td>
<td>
<p>Contains all the bootstrapped sampling distribution of all parameters. The dimension of this object depends on the type of model. Specifically, this object has the same dimension as the main  parameter output of the corresponding estimation function, with one dimension added for the bootstrap iterations. See &quot;Details&quot; above.
</p>
</td></tr>
<tr><td><code>bootQuantiles</code></td>
<td>
<p>Contains the specified quantiles of the bootstrapped sampling distribution for each parameter. Has the same structure as <code>bootParameters</code>. See &quot;Details&quot; above. </p>
</td></tr>
<tr><td><code>Times</code></td>
<td>
<p>Returns the running time for each bootstrap model in seconds.</p>
</td></tr>
<tr><td><code>totalTime</code></td>
<td>
<p>Returns the running time for all bootstrap models together in seconds.</p>
</td></tr>
<tr><td><code>seeds</code></td>
<td>
<p><code>nB</code> integers indicating the seeds used to sample the <code>nB</code> bootstrap samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


# 1) Fit mgm to example dataset (true edges: 1-4, 2-3, 1-2)
mgm_obj &lt;- mgm(data = mgm_data$data, 
               type = c('g', 'c', 'c', 'g'),
               level = c(1, 2, 4, 1),
               k = 2, 
               lambdaSel = 'CV', 
               threshold = 'none')

# 2) Take 50 bootstrap samples using resample()
res_obj &lt;- resample(object = mgm_obj, 
                    data = mgm_data$data,
                    nB = 50)

# 3) Plot histogram of bootstrapped sampling distribution of edge 1-4
hist(res_obj$bootParameters[1, 4, ], 
     main = "", 
     xlab = "Parameter Estimate")

# 4) Plot summary of all sampling distributions
plotRes(object = res_obj, 
        quantiles = c(0.05, .95))


# For more examples see https://github.com/jmbh/mgmDocumentation




## End(Not run)


</code></pre>

<hr>
<h2 id='showInteraction'>
Retrieving details of interactions
</h2><span id='topic+showInteraction'></span>

<h3>Description</h3>

<p>Retrieves details of a specified interaction from mgm model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showInteraction(object, int)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showInteraction_+3A_object">object</code></td>
<td>

<p>The output of one of the estimation functions <code>mgm()</code>, <code>tvmgm()</code>, <code>mvar()</code>, <code>tvmvar()</code>.
</p>
</td></tr>
<tr><td><code id="showInteraction_+3A_int">int</code></td>
<td>

<p>An integer vector specifying the interaction. For mVAR models, this vector has length 2. For MGMs the vector can be larger to request details of interaction of order &gt; 2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the function only returns details of pairwise interactions from output objects of <code>mgm()</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>variables</code></td>
<td>
<p>Integer vector returning the variables specified via the argument <code>int</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character vector returning the type of the specified variables variables</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Integer vector returning the number of levels of the specified variables variables</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of length equal to the order k of the specified interaction. The entries contain the set of parameters obtained from the nodewise regressions on the k variables. Depending on the type of the variables in the interaction, these sets can obtain one or several parameters. For details see <code>?mgm</code> or Haslbeck &amp; Waldorp (2017).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>See Also</h3>

<p><code>mgm</code>, <code>tvmgm</code>, <code>mvar</code>, <code>tvmvar</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## We fit a pairwise and 3-order MGM to the mixed Autism dataset (?autism_data)

# 1) Fit Pairwise MGM

# Call mgm()
fit_d2 &lt;- mgm(data = autism_data$data,
              type = autism_data$type,
              level = autism_data$lev,
              k = 2) # ad most pairwise interacitons

# Weighted adjacency matrix
fit_d2$pairwise$wadj # for instance, we see there is an interaction 1-2

# 2) Look at details of interaction 1-2
showInteraction(object = fit_d2, 
                int = c(1, 2))

# For more examples see https://github.com/jmbh/mgmDocumentation


## End(Not run)


</code></pre>

<hr>
<h2 id='tvmgm'>
Estimating time-varying Mixed Graphical Models
</h2><span id='topic+tvmgm'></span><span id='topic+tv.mgmfit'></span>

<h3>Description</h3>

<p>Estimates time-varying k-order Mixed Graphical Models (MGMs) via elastic-net regularized kernel smoothed Generalized Linear Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvmgm(data, type, level, timepoints, estpoints, bandwidth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvmgm_+3A_data">data</code></td>
<td>

<p>n x p data matrix.
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>: &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_timepoints">timepoints</code></td>
<td>

<p>A strictly increasing numeric vector of length <code>nrow(data)</code> indicating the time points of the measurements in <code>data</code>. If <code>timepoints</code> is not specified, it is assumed that the time points are equally spaced. For details, see Haslbeck and Waldorp (2018).
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_estpoints">estpoints</code></td>
<td>

<p>Vector indicating estimation points on the unit interval [0, 1] (the provided time scale is normalized interally to [0,1]).
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_bandwidth">bandwidth</code></td>
<td>

<p>We use a gaussian density on the unit time-interval [0,1] to determine the weights for each observation at each estimated time point. The bandwidth specifies the standard deviation the Gaussian density. To get some intuition, which bandwidth results in the combination of how many data close in time one can plot Gaussians on [0,1] for different bandwidths. The bandwidth can also be selected in a data driven way using the function (see <code>bwSelect</code>).
</p>
</td></tr>
<tr><td><code id="tvmgm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>mgm</code>, specifying the MGM. See <code>?mgm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a sequence of MGMs at the time points specified at the locations specified via <code>estpoints</code>. <code>tvmgm()</code> is a wrapper around <code>mgm()</code> and estimates a series of MGM with different weightings which are defined by the estimation locations in <code>estpoints</code> and the bandwidth parameter specified in <code>bandwidth</code>. For details see Haslbeck and Waldorp (2018).
</p>
<p>Note that MGMs are not normalizable for all parameter values. See Chen, Witten &amp; Shojaie (2015) for an overview of when pairwise MGMs are normalizable. To our best knowledge, for MGMs with interactions of order &gt; 2 that include non-categorical variables, the conditions for normalizablity are unknown.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments. If <code>saveData = TRUE</code>, it also contains the data.
</p>
</td></tr>
<tr><td><code>pairwise</code></td>
<td>

<p>Contains a list with all information about estimated pairwise interactions. <code>wadj</code> contains a p x p x estpoints array containing the weighted adjacency matrix for each estimation point specified in <code>estpoints</code>, if p is the number of variables in the network. <code>signs</code> has the same dimensions as <code>wadj</code> and contains the signs for the entries of <code>wadj</code>: 1 indicates a positive sign, -1 a negative sign and 0 an undefined sign. A sign is undefined if an edge is a function of more than one parameter. This is the case for interactions involving a categorical variable with more than 2 categories. <code>edgecolor</code> also has the same dimensions as <code>wadj</code> contains a color for each edge, depending on <code>signs</code>. It is provided for more convenient plotting. If only pairwise interactions are modeled (<code>k = 2</code>), <code>wadj</code> contains all conditional independence relations.
</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>

<p>Contains a list with one entry for each estimation point specified in <code>estpoints</code>; each entry is a list with three entries that relate each interaction in the model to all its parameters. <code>indicator</code> contains a list with k-1 entries, one for each order of modeled interaction, which contain the estimated (nonzero) interactions. <code>weights</code> contains a list with k-1 entries, which in turn contain R lists, where R is the number of interactions (and rows in the corresponding list entry in<code>indicator</code>) that were estimated (nonzero) in the given entry. <code>signs</code> has the same structure as <code>weights</code> and provides the sign of the interaction, if defined.
</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>

<p>Contains a list with one entry for each estimation point specified in <code>estpoints</code>; each entry is a list with p entries, which contain the intercept/thresholds for each node in the network. In case a given node is categorical with m categories, there are m thresholds for this variable (one for each category).
</p>
</td></tr>
<tr><td><code>tvmodels</code></td>
<td>

<p>Contains the MGM model estimated by <code>mgm()</code> at each time point specified via <code>estpoints</code>. See <code>?mgm</code> for a detailed description of this output.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Chen S, Witten DM &amp; Shojaie (2015). Selection and estimation for mixed graphical models. Biometrika, 102(1), 47.
</p>
<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G. I., &amp; Liu, Z. (2014, April). Mixed Graphical Models via Exponential Families. In AISTATS (Vol. 2012, pp. 1042-1050).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## We specify a time-varying MGM and recover it using tvmgm()

# 1) Specify Model

# a) Define Graph
p &lt;- 6
type = c("c", "c", "g", "g", "p", "p")
level = c(2, 3, 1, 1, 1, 1)
n_timepoints &lt;- 1000

# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- matrix(c(1,2,
                         2,3,
                         3,4), ncol=2, byrow = T)  # no pairwise interactions
factors[[2]] &lt;- matrix(c(1,2,3,
                         2,3,4), ncol=3, byrow = T) # one 3-way interaction

interactions &lt;- list()
interactions[[1]] &lt;- vector("list", length = 3)
interactions[[2]] &lt;- vector("list", length = 2)
# 3 2-way interactions
interactions[[1]][[1]] &lt;- array(0, dim = c(level[1], level[2], n_timepoints))
interactions[[1]][[2]] &lt;- array(0, dim = c(level[2], level[3], n_timepoints))
interactions[[1]][[3]] &lt;- array(0, dim = c(level[3], level[4], n_timepoints))
# 2 3-way interactions
interactions[[2]][[1]] &lt;- array(0, dim = c(level[1], level[2], level[3], n_timepoints))
interactions[[2]][[2]] &lt;- array(0, dim = c(level[2], level[3], level[4], n_timepoints))
theta &lt;- .3
interactions[[1]][[1]][1, 1, ] &lt;- theta
interactions[[1]][[2]][1, 1, ] &lt;- theta
interactions[[1]][[3]][1, 1, ] &lt;- seq(0, theta, length = n_timepoints)
interactions[[2]][[1]][1, 1, 1, ] &lt;- theta
interactions[[2]][[2]][1, 1, 1, ] &lt;- theta
# c) Define Thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- matrix(0, nrow = n_timepoints, ncol= level[1])
thresholds[[2]] &lt;- matrix(0, nrow = n_timepoints, ncol= level[2])
thresholds[[3]] &lt;- matrix(0, nrow = n_timepoints, ncol= level[3])
thresholds[[4]] &lt;- matrix(0, nrow = n_timepoints, ncol= level[4])
thresholds[[5]] &lt;- matrix(.1, nrow = n_timepoints, ncol= level[5])
thresholds[[6]] &lt;- matrix(.1, nrow = n_timepoints, ncol= level[6])
# d) define sds
sds &lt;- matrix(.2, ncol=p, nrow=n_timepoints)

# 2) Sample Data
set.seed(1)
d_iter &lt;- tvmgmsampler(factors = factors,
                       interactions = interactions,
                       thresholds = thresholds,
                       sds = sds,
                       type = type,
                       level = level,
                       nIter = 100,
                       pbar = TRUE)

data &lt;- d_iter$data
head(data)
# delete inf rows:
ind_finite &lt;- apply(data, 1, function(x) if(all(is.finite(x))) TRUE else FALSE)
table(ind_finite) # all fine for this setup &amp; seed
# in case of inf values (no theory on how to keep k-order MGM well-defined)
data &lt;- data[ind_finite, ] 


# 3) Recover
mgm_c_cv &lt;- tvmgm(data = data,
                  type = type,
                  level = level,
                  k = 3,
                  estpoints = seq(0, 1, length=10),
                  bandwidth = .1,
                  lambdaSel = "CV",
                  ruleReg = "AND",
                  pbar = TRUE,
                  overparameterize = T,
                  signInfo = FALSE)

# Look at time-varying pairwise parameter 3-4
mgm_c_cv$pairwise$wadj[3,4,] # recovers increase

# 4) Predict values / compute nodewise Errors
pred_mgm_cv_w &lt;- predict.mgm(mgm_c_cv,
                             data = data,
                             tvMethod = "weighted")
pred_mgm_cv_cM &lt;- predict.mgm(mgm_c_cv,
                              data = data,
                              tvMethod = "closestModel")

pred_mgm_cv_w$errors
pred_mgm_cv_cM$errors # Pretty similar!


# For more examples see https://github.com/jmbh/mgmDocumentation


## End(Not run)

</code></pre>

<hr>
<h2 id='tvmgmsampler'>
Sample from time-varying k-order Mixed Graphical Model
</h2><span id='topic+tvmgmsampler'></span>

<h3>Description</h3>

<p>Generates samples from a time-varying k-order Mixed Graphical Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvmgmsampler(factors, interactions, thresholds, sds, type,
             level, nIter = 250, pbar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvmgmsampler_+3A_factors">factors</code></td>
<td>

<p>The same object as <code>factors</code> in <code>mgmsampler()</code>. An interaction is specified in <code>factors</code> if it should be nonzero at least at one time point in the time series. The values of each parameter at each time point is specified via <code>interactions</code>.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_interactions">interactions</code></td>
<td>

<p>The same object as <code>factors</code> in <code>mgmsampler()</code>, except that each array indicating the parameters of an interaction has an additional (the last) dimension, indicating time. Corresponding to the time vector in <code>factors</code>, the time vector has to be a sequence of integers {1, 2, ..., N}. For an illustration see the examples below.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_thresholds">thresholds</code></td>
<td>

<p>A list with p entries for p variables, each of which contains a N x m matrix. The columns contain the m thresholds for m categories (for continuous variables m = 1 and the entry contains the threshold/intercept). The rows indicate how the thresholds change over time.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_sds">sds</code></td>
<td>

<p>N x p matrix indicating the standard deviations of Gaussians specified in <code>type</code> for {1, ..., N} time points. Entries not referring to Gaussians are ignored.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_type">type</code></td>
<td>

<p>p character vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; of each variable.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_level">level</code></td>
<td>

<p>p integer vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_niter">nIter</code></td>
<td>

<p>Number of iterations in the Gibbs sampler until a sample is drawn.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code> a progress bar is shown. Defaults to <code>pbar = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="tvmgmsampler_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tvmgmsampler</code> is a wrapper function around <code>mgmsampler</code>. Its input is the same as for <code>mgmsampler</code>, except that each object has an additional dimension for time. The number of time points is specified via entries in the additional time dimension.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments.
</p>
</td></tr>
<tr><td><code>data</code></td>
<td>

<p>The N x p data matrix of sampled values
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>
<p>Yang, E., Baker, Y., Ravikumar, P., Allen, G. I., &amp; Liu, Z. (2014, April). Mixed Graphical Models via Exponential Families. In AISTATS (Vol. 2012, pp. 1042-1050).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

# --------- Example 1: p = 4 dimensional Gaussian ---------

# ----- 1) Specify Model -----

# a) General Graph Info
type = c("g", "g", "g", "g") # Four Gaussians
level = c(1, 1, 1, 1)
n_timepoints = 500 #  Number of time points

# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- array(NA, dim=c(2, 2)) # two pairwise interactions
factors[[1]][1, 1:2] &lt;- c(3,4)
factors[[1]][2, 1:2] &lt;- c(1,2)

# Two parameters, one linearly increasing from 0 to 0.8, another one lin decreasing from 0.8 to 0
interactions &lt;- list()
interactions[[1]] &lt;- vector("list", length = 2)
interactions[[1]][[1]] &lt;- array(0, dim = c(level[1], level[2], n_timepoints))
interactions[[1]][[1]][1,1, ] &lt;- seq(.8, 0, length = n_timepoints)
interactions[[1]][[2]] &lt;- array(0, dim = c(level[1], level[2], n_timepoints))
interactions[[1]][[2]][1,1, ] &lt;- seq(0, .8, length = n_timepoints)

# c) Define Thresholds
thresholds &lt;- vector("list", length = 4)
thresholds &lt;- lapply(thresholds, function(x) matrix(0, ncol = level[1], nrow = n_timepoints))

# d) Define Standard deviations
sds &lt;- matrix(1, ncol = length(type), nrow = n_timepoints) # constant across variables and time


# ----- 2) Sample cases -----

set.seed(1)
dlist &lt;- tvmgmsampler(factors = factors,
                      interactions = interactions,
                      thresholds = thresholds,
                      sds = sds,
                      type = type,
                      level = level,
                      nIter = 75,
                      pbar = TRUE)


# ----- 3) Recover model from sampled cases -----

set.seed(1)
tvmgm_obj &lt;- tvmgm(data = dlist$data,
                   type = type,
                   level = level,
                   estpoints = seq(0, 1, length = 15),
                   bandwidth = .2,
                   k = 2,
                   lambdaSel = "CV",
                   ruleReg = "AND")

# How well did we recover those two time-varying parameters?
plot(tvmgm_obj$pairwise$wadj[3,4,], type="l", ylim=c(0,.8))
lines(tvmgm_obj$pairwise$wadj[1,2,], type="l", col="red")
# Looks quite good


# --------- Example 2: p = 5 binary; one 3-way interaction ---------

# ----- 1) Specify Model -----

# a) General Graph Info
p &lt;- 5 # number of variables
type = rep("c", p) # all categorical
level = rep(2, p) # all binary
n_timepoints &lt;- 1000

# b) Define Interaction
factors &lt;- list()
factors[[1]] &lt;- NULL # no pairwise interactions
factors[[2]] &lt;- array(NA, dim = c(1,3)) # one 3-way interaction
factors[[2]][1, 1:3] &lt;- c(1, 2, 3)

interactions &lt;- list()
interactions[[1]] &lt;- NULL # no pairwise interactions
interactions[[2]] &lt;- vector("list", length = 1)  # one 3-way interaction
# 3-way interaction no1
interactions[[2]][[1]] &lt;- array(0, dim = c(level[1], level[2], level[3], n_timepoints))
theta &lt;- 2
interactions[[2]][[1]][1, 1, 1, ] &lt;- seq(0, 2, length = n_timepoints) # fill in nonzero entries

# c) Define Thresholds
thresholds &lt;- list()
for(i in 1:p) thresholds[[i]] &lt;- matrix(0, nrow = n_timepoints, ncol = level[i])


# ----- 2) Sample cases -----

set.seed(1)
dlist &lt;- tvmgmsampler(factors = factors,
                      interactions = interactions,
                      thresholds = thresholds,
                      type = type,
                      level = level,
                      nIter = 150,
                      pbar = TRUE)


# ----- 3) Check Marginals -----

dat &lt;- dlist$data[1:round(n_timepoints/2),]
table(dat[,1], dat[,2], dat[,3])

dat &lt;- dlist$data[round(n_timepoints/2):n_timepoints,]
table(dat[,1], dat[,2], dat[,3])

# Observation: much stronger effect in second hald of the time-series,
# which is what we expect


# ----- 4) Recover model from sampled cases -----

set.seed(1)
tvmgm_obj &lt;- tvmgm(data = dlist$data,
                   type = type,
                   level = level,
                   estpoints = seq(0, 1, length = 15),
                   bandwidth = .2,
                   k = 3,
                   lambdaSel = "CV",
                   ruleReg = "AND")

tvmgm_obj$interactions$indicator
# Seems very difficult to recover this time-varying 3-way binary interaction
# See also the corresponding problems in the examples of ?mgmsampler


# For more examples see https://github.com/jmbh/mgmDocumentation



## End(Not run)


</code></pre>

<hr>
<h2 id='tvmvar'>
Estimating time-varying Mixed Vector Autoregressive Model (mVAR)
</h2><span id='topic+tvmvar'></span><span id='topic+tv_var.mgm'></span>

<h3>Description</h3>

<p>Estimates time-varying Mixed Vector Autoregressive Model (mVAR) via elastic-net regularized kernel smoothed Generalized Linear Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvmvar(data, type, level, timepoints, estpoints, bandwidth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvmvar_+3A_data">data</code></td>
<td>

<p>n x p data matrix.
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>: &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_timepoints">timepoints</code></td>
<td>

<p>A strictly increasing numeric vector of length <code>nrow(data)</code> indicating time points for the measurements in <code>data</code>. If <code>timepoints</code> is not specified, it is assumed that the time points are equally spaced. For details, see Haslbeck and Waldorp (2018).
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_estpoints">estpoints</code></td>
<td>

<p>Vector indicating estimation points on interval [0, 1]. Note that we define this unit interval on the entire time series. This also includes measurements that are excluded because not enough previous measurements are available to fit the model. This ensures that the a model estimated at, for example, estimation point 0.15 is actually estimated on data close to data points around this time point. See Haslbeck and Waldorp (2018) Section 2.5 and 3.4 for a detailed description.
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_bandwidth">bandwidth</code></td>
<td>

<p>We use a gaussian density on the unit time-interval [0,1] to determine the weights for each observation at each estimated time point. The bandwidth specifies the standard deviation the Gaussian density. To get some intuition, which bandwidth results in the combination of how many data close in time one can plot Gaussians on [0,1] for different bandwidths. The bandwidth can also be selected in a data driven way using the function (see <code>bwSelect</code>).
</p>
</td></tr>
<tr><td><code id="tvmvar_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>mvar</code>, specifying how each single model should be estimated. See <code>?mvar</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a sequence of mVAR models at the time points specified at the locations specified via <code>estpoints</code>. <code>tvmvar()</code> is a wrapper around <code>mvar()</code> and estimates a series of MGM with different weightings which are defined by the estimation locations in <code>estpoints</code> and the banwdith parameter specified in <code>bandwidth</code>. For details see Haslbeck and Waldorp (2018)
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>

<p>Contains all provided input arguments. If <code>saveData = TRUE</code>, it also contains the data.
</p>
</td></tr>
<tr><td><code>wadj</code></td>
<td>

<p>A p x p x n_lags x S array, where n_lags is the number of specified lags in <code>lags</code> (see <code>?mvar</code>) and S is the number of estimation points specified in <code>estpoints</code>. For instance, wadj[1, 2, 1, 10] is the cross-lagged predicting variable 1 at time point t by variable 2 at time point t - z, where z is specified by the first lag specified in <code>lags</code> (see <code>?mvar</code>), in the model estimated at estimation point 10.</p>
</td></tr>
<tr><td><code>signs</code></td>
<td>
<p> Has the same structure as <code>wadj</code> and specifies the signs corresponding to the parameters in <code>wadj</code>, if defined. 1/-1 indicate positive and negative relationships, respectively. 0 indicates that no sign is defined, which is the case for interactions that involve a categorical variable where an interaction can have more than one parameter. If <code>binarySign = TRUE</code>, a sign is calculated for interactions between binary variables and binary and continuous variables, where the interaction is still defined by one parameter and hence a sign can be specified. <code>NA</code> indicates that the corresponding parameter in <code>wadj</code> is zero. See also <code>?mvar</code>.
</p>
</td></tr>
<tr><td><code>intercepts</code></td>
<td>

<p>A list with S entries, where S is the number of estimated time points. Each entry of that list contains a list p entries with the intercept/thresholds for each node in the network. In case a given node is categorical with m categories, there are m thresholds for this variable.
</p>
</td></tr>
<tr><td><code>tvmodels</code></td>
<td>

<p>Contains the mVAR model estimated by <code>mvar()</code> at each time point specified via <code>estpoints</code>. See <code>?mvar</code> for a detailed description of this output.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


## We set up the same model as in the example of mvar(), but
## specify one time-varying parameter, and try to recover it with
## tvmvar()

# a) Specify time-varying VAR model

p &lt;- 6 # Six variables
type &lt;- c("c", "c", "c", "c", "g", "g") # 4 categorical, 2 gaussians
level &lt;- c(2, 2, 4, 4, 1, 1) # 2 categoricals with 2 categories, 2 with 5
max_level &lt;- max(level)
n_timepoints &lt;- 4000

lags &lt;- c(1, 3, 9) # include lagged effects of order 1, 3, 9
n_lags &lt;- length(lags)

# Specify thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- matrix(0, ncol=level[1], nrow=n_timepoints)
thresholds[[2]] &lt;- matrix(0, ncol=level[2], nrow=n_timepoints)
thresholds[[3]] &lt;- matrix(0, ncol=level[3], nrow=n_timepoints)
thresholds[[4]] &lt;- matrix(0, ncol=level[4], nrow=n_timepoints)
thresholds[[5]] &lt;- matrix(0, ncol=level[5], nrow=n_timepoints)
thresholds[[6]] &lt;- matrix(0, ncol=level[6], nrow=n_timepoints)

# Specify standard deviations for the Gaussians
sds &lt;- matrix(NA, ncol=p, nrow=n_timepoints)
sds[, 5:6] &lt;- 1

# Create coefficient array
coefarray &lt;- array(0, dim=c(p, p, max_level, max_level, n_lags, n_timepoints))

# a.1) interaction between continuous 5&lt;-6, lag=3
coefarray[5, 6, 1, 1, 2, ] &lt;- seq(0, .4, length = n_timepoints) # only time-varying parameter
# a.2) interaction between 1&lt;-3, lag=1
m1 &lt;- matrix(0, nrow=level[2], ncol=level[4])
m1[1,1:2] &lt;- 1
m1[2,3:4] &lt;- 1
coefarray[1, 3, 1:level[2], 1:level[4], 1, ] &lt;- m1 # constant across time
# a.3) interaction between 1&lt;-5, lag=9
coefarray[1, 5, 1:level[1], 1:level[5], 3, ] &lt;- c(0, 1) # constant across time


# b) Sample
set.seed(1)
dlist &lt;- tvmvarsampler(coefarray = coefarray,
                       lags = lags,
                       thresholds = thresholds,
                       sds = sds,
                       type = type,
                       level = level,
                       pbar = TRUE)

# c.1) Recover: stationary
set.seed(1)
mvar_obj &lt;- mvar(data = dlist$data,
                 type = type,
                 level = level,
                 lambdaSel = "CV",
                 lags = c(1, 3, 9),
                 signInfo = FALSE)

# Did we recover the true parameters?
mvar_obj$wadj[5, 6, 2] # cross-lagged effect of 6 on 5 over lag lags[2] (lag 3)
mvar_obj$wadj[1, 3, 1] # cross-lagged effect of 3 on 1 over lag lags[1] (lag 1)
mvar_obj$wadj[1, 5, 3] # cross-lagged effect of 1 on 5 over lag lags[3] (lag 9)


# c.2) Recover: time-varying
set.seed(1)
mvar_obj &lt;- tvmvar(data = dlist$data,
                   type = type,
                   level = level,
                   estpoints = seq(0, 1, length=10),
                   bandwidth = .15,
                   lambdaSel = "CV",
                   lags = c(1, 3, 9),
                   signInfo = FALSE)

# Did we recover the true parameters?
mvar_obj$wadj[5, 6, 2, ] # true sort of recovered
mvar_obj$wadj[1, 3, 1, ] # yes
mvar_obj$wadj[1, 5, 3, ] # yes

# Plotting parameter estimates over time
plot(mvar_obj$wadj[5, 6, 2, ], 
     type="l", ylim=c(-.2,.7), 
     lwd=2, ylab="Parameter value", xlab="Estimation points")
lines(mvar_obj$wadj[1, 3, 1, ], col="red", lwd=2)
lines(mvar_obj$wadj[1, 5, 3, ], col="blue", lwd=2)
legend("bottomright", c("5 &lt;-- 6", "1 &lt;-- 3", "1 &lt;-- 5"), 
       lwd = c(2,2,2), col=c("black", "red", "blue"))


# d) Predict values / compute nodewise error

mvar_pred_w &lt;- predict.mgm(object=mvar_obj,
                           data=dlist$data,
                           tvMethod = "weighted")

mvar_pred_cM &lt;- predict.mgm(object=mvar_obj,
                            data=dlist$data,
                            tvMethod = "closestModel")

mvar_pred_w$errors
mvar_pred_cM$errors

# For more examples see https://github.com/jmbh/mgmDocumentation



## End(Not run)

</code></pre>

<hr>
<h2 id='tvmvarsampler'>
Sampling from a time-varying mixed VAR model
</h2><span id='topic+tvmvarsampler'></span>

<h3>Description</h3>

<p>Function to sample from a time-varying mixed VAR (mVAR) model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvmvarsampler(coefarray, lags, thresholds,
              sds, type, level, pbar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvmvarsampler_+3A_coefarray">coefarray</code></td>
<td>

<p>A p x p x max(level) x max(level) x n_lags x N array, where p are the number of variables, level is the input argument <code>level</code> and n_lags is the number of specified lags in <code>lags</code>, so n_lags = length(n_lags), and N is the number of time points in the time series. The first four dimensions specify the parameters involved in the cross-lagged effects of the lag specified in the 5th dimension. I.e. coefarray[5, 6, 1, 1, 3, 100] indicates the cross-lagged effect of variable 6 on variable 5 (if both are continuous), for the third lag specified in <code>lags</code> at time point 100. If variable 1 and 3 are categorical with m = 2 and  = 4 categories, respectively, then coefarray[1, 3, 1:2, 1:4, 1, 250] indicates the m*s=8 parameters specifying this interaction for the first lag specified in <code>lags</code> at time point 250. See the examples below for an illustration.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_lags">lags</code></td>
<td>

<p>A vector indicating the lags in the mVAR model. E.g. <code>lags = c(1, 4, 9)</code> specifies lags of order 1, 3, 9. The number of specified lags has to match the 5th dimension in <code>coefarray</code>.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_thresholds">thresholds</code></td>
<td>

<p>A list with p entries, each consisting of a matrix indicating a threshold for each category of the given variable (column) and time point (row). For continuous variable, the matrix has 1 column.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_sds">sds</code></td>
<td>

<p>A N x p matrix specifying the standard deviation of Gaussian variables (columns) at each time point (rows)If non-Gaussian variables are included in the mVAR model, the corresponding columns are ignored.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_type">type</code></td>
<td>

<p>p vector indicating the type of variable for each column in <code>data</code>. &quot;g&quot; for Gaussian, &quot;p&quot; for Poisson, &quot;c&quot; for categorical.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_level">level</code></td>
<td>

<p>p vector indicating the number of categories of each variable. For continuous variables set to 1.
</p>
</td></tr>
<tr><td><code id="tvmvarsampler_+3A_pbar">pbar</code></td>
<td>

<p>If <code>pbar = TRUE</code>, a progress bar is shown.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We sample from the mVAR model by separately sampling from its corresponding p conditional distributions.
</p>


<h3>Value</h3>

<p>A list with two entries:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The sampled n x p data matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonas Haslbeck &lt;jonashaslbeck@gmail.com&gt;
</p>


<h3>References</h3>

<p>Haslbeck, J. M. B., &amp; Waldorp, L. J. (2020). mgm: Estimating time-varying Mixed Graphical Models in high-dimensional Data. Journal of Statistical Software, 93(8), pp. 1-46. DOI: 10.18637/jss.v093.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

## We specify a tvmvar model, sample from it and recover it

# a) Set up time-varying mvar model

p &lt;- 6 # Six variables
type &lt;- c("c", "c", "c", "c", "g", "g") # 4 categorical, 2 gaussians
level &lt;- c(2, 2, 4, 4, 1, 1) # 2 categoricals with 2 categories, 2 with 5
max_level &lt;- max(level)

lags &lt;- c(1, 3, 9) # include lagged effects of order 1, 3, 9
n_lags &lt;- length(lags)

N &lt;- 5000

# Specify thresholds
thresholds &lt;- list()
thresholds[[1]] &lt;- matrix(0, ncol=2, nrow=N)
thresholds[[2]] &lt;- matrix(0, ncol=2, nrow=N)
thresholds[[3]] &lt;- matrix(0, ncol=4, nrow=N)
thresholds[[4]] &lt;- matrix(0, ncol=4, nrow=N)
thresholds[[5]] &lt;- matrix(0, ncol=1, nrow=N)
thresholds[[6]] &lt;- matrix(0, ncol=1, nrow=N)

# Specify standard deviations for the Gaussians
sds &lt;- matrix(NA, ncol=6, nrow=N)
sds[,5:6] &lt;- 1

# Create coefficient array
coefarray &lt;- array(0, dim=c(p, p, max_level, max_level, n_lags, N))

# a.1) interaction between continuous 5&lt;-6, lag=3
coefarray[5, 6, 1, 1, 2, ] &lt;- c(rep(.5, N/2), rep(0, N/2))
# a.2) interaction between 1&lt;-3, lag=1
m1 &lt;- matrix(0, nrow=level[2], ncol=level[4])
m1[1, 1:2] &lt;- 1
m1[2, 3:4] &lt;- 1
coefarray[1, 3, 1:level[2], 1:level[4], 1, ] &lt;- m1
# a.3) interaction between 1&lt;-5, lag=9
coefarray[1, 5, 1:level[1], 1:level[5], 3, ] &lt;- c(0, 1)

dim(coefarray)


# b) Sample
set.seed(1)
dlist &lt;- tvmvarsampler(coefarray = coefarray,
                       lags = lags,
                       thresholds = thresholds,
                       sds = sds,
                       type = type,
                       level = level,
                       pbar = TRUE)


# c) Recover: time-varying mVAR model
set.seed(1)
tvmvar_obj &lt;- tvmvar(data = dlist$data,
                     type = type,
                     level = level,
                     lambdaSel = "CV",
                     lags = c(1, 3, 9),
                     estpoints = seq(0, 1, length=10),
                     bandwidth = .05)

tvmvar_obj$wadj[5, 6, 2, ] # parameter goes down, as specified
tvmvar_obj$wadj[1, 3, 1, ]
tvmvar_obj$wadj[1, 5, 3, ]

# For more examples see https://github.com/jmbh/mgmDocumentation


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
