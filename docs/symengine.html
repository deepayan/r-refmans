<!DOCTYPE html><html><head><title>Help for package symengine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {symengine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+3D+3D+2CBasic+2CBasic-method'><p>Bindings for Operators and Math Functions</p></a></li>
<li><a href='#as.character+2CBasic-method'><p>Some Conversion Methods</p></a></li>
<li><a href='#as.matrix.DenseMatrix'><p>Methods Related to DenseMatrix</p></a></li>
<li><a href='#cbind.SymEngineDataType'><p>Joining DenseMatrix</p></a></li>
<li><a href='#codegen'><p>Code Generation</p></a></li>
<li><a href='#D+2CSymEngineDataType-method'><p>Derivatives of a Symbolic Expression</p></a></li>
<li><a href='#det'><p>Calculate the Determinant of DenseMatrix</p></a></li>
<li><a href='#DoubleVisitor'><p>Double Visitor</p></a></li>
<li><a href='#dxdt'><p>Solve System of Ordinary Differential Equations</p></a></li>
<li><a href='#evalf'><p>Evaluating a SymEngine Object</p></a></li>
<li><a href='#expand'><p>Expand a Symbolic Expression</p></a></li>
<li><a href='#Function'><p>Create a FunctionSymbol</p></a></li>
<li><a href='#get_type'><p>Get Information about Basic Object</p></a></li>
<li><a href='#lambdify'><p>Convert A Basic/VecBasic Object to R Function</p></a></li>
<li><a href='#LCM'><p>Some Special Math Functions</p></a></li>
<li><a href='#length+2CVecBasic-method'><p>Methods Related to VecBasic</p></a></li>
<li><a href='#Matrix'><p>DenseMatrix Constructor</p></a></li>
<li><a href='#S'><p>Converting R object to Basic</p></a></li>
<li><a href='#solve'><p>Solve Symbolic Equations</p></a></li>
<li><a href='#subs'><p>Substitute Expressions in SymEngine Objects</p></a></li>
<li><a href='#symengine'><p>symengine: R interface to SymEngine C++ library for symbolic computation</p></a></li>
<li><a href='#symengine_version'><p>Information about SymEngine Library</p></a></li>
<li><a href='#t'><p>Transpose (as) a DenseMatrix</p></a></li>
<li><a href='#use_vars'><p>Initializing Variables</p></a></li>
<li><a href='#Vector'><p>Symbolic Vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to the 'SymEngine' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides an R interface to 'SymEngine' <a href="https://github.com/symengine/">https://github.com/symengine/</a>,
    a standalone 'C++' library for fast symbolic manipulation. The package has functionalities
    for symbolic computation like calculating exact mathematical expressions, solving
    systems of linear equations and code generation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, pracma, odeintr, testthat (&ge; 2.1.0), knitr,
rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, cmake, gmp, mpfr</td>
</tr>
<tr>
<td>SystemRequirementsNote:</td>
<td>gmp (deb package: libgmp-dev, rpm package:
gmp-devel), mpfr (deb package: libmpfr-dev, rpm package:
mpfr-devel)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/symengine/symengine.R">https://github.com/symengine/symengine.R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/symengine/symengine.R/issues">https://github.com/symengine/symengine.R/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://Marlin-Na.github.io/drat">https://Marlin-Na.github.io/drat</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The R package bundles the 'SymEngine' library source and its
subcomponents under 'src/upstream' directory. See file
COPYRIGHTS for retained copyright notices as a relicensing and
redistribution requirement.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'basic-getinfo.R' 'classes.R' 'basic.R'
'codegen.R' 'double_visitor.R' 'dxdt.R' 'function_symbol.R'
'knitr.R' 'lambdify.R' 'language_conversion.R' 'matrix.R'
'misc.R' 'ops.R' 'solve.R' 'summary.R' 'symbolic_array.R'
'symengine.R' 'symengine_info.R' 'utils-subset.R' 'vector.R'
'zzz.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-25 11:22:05 UTC; jma1</td>
</tr>
<tr>
<td>Author:</td>
<td>Jialin Ma [cre, aut],
  Isuru Fernando [aut],
  Xin Chen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jialin Ma &lt;marlin@inventati.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+3D+3D+2CBasic+2CBasic-method'>Bindings for Operators and Math Functions</h2><span id='topic++3D+3D+2CBasic+2CBasic-method'></span><span id='topic++21+3D+2CBasic+2CBasic-method'></span><span id='topic+Arith+2CSymEngineDataType+2CSymEngineDataType-method'></span><span id='topic+Arith+2CSymEngineDataType+2Cvector-method'></span><span id='topic+Arith+2Cvector+2CSymEngineDataType-method'></span><span id='topic+-+2CSymEngineDataType+2Cmissing-method'></span><span id='topic++2B+2CSymEngineDataType+2Cmissing-method'></span><span id='topic++25+2A+25+2CDenseMatrix+2CDenseMatrix-method'></span><span id='topic++25+2A+25+2CVecBasic+2CVecBasic-method'></span><span id='topic++25+2A+25+2CDenseMatrix+2CVecBasic-method'></span><span id='topic++25+2A+25+2CDenseMatrix+2Cvector-method'></span><span id='topic++25+2A+25+2CVecBasic+2CDenseMatrix-method'></span><span id='topic++25+2A+25+2Cvector+2CDenseMatrix-method'></span><span id='topic+Math+2CSymEngineDataType-method'></span><span id='topic+sinpi+2CSymEngineDataType-method'></span><span id='topic+cospi+2CSymEngineDataType-method'></span><span id='topic+tanpi+2CSymEngineDataType-method'></span><span id='topic+log+2CSymEngineDataType-method'></span><span id='topic+log2+2CSymEngineDataType-method'></span><span id='topic+log10+2CSymEngineDataType-method'></span><span id='topic+log1p+2CSymEngineDataType-method'></span><span id='topic+expm1+2CSymEngineDataType-method'></span><span id='topic+sum+2CSymEngineDataType-method'></span><span id='topic+prod+2CSymEngineDataType-method'></span>

<h3>Description</h3>

<p>These are S4 methods defined for <code>Basic</code>, <code>VecBasic</code>
and <code>DenseMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Basic,Basic'
e1 == e2

## S4 method for signature 'Basic,Basic'
e1 != e2

## S4 method for signature 'SymEngineDataType,SymEngineDataType'
Arith(e1, e2)

## S4 method for signature 'SymEngineDataType,vector'
Arith(e1, e2)

## S4 method for signature 'vector,SymEngineDataType'
Arith(e1, e2)

## S4 method for signature 'SymEngineDataType,missing'
e1 - e2

## S4 method for signature 'SymEngineDataType,missing'
e1 + e2

## S4 method for signature 'DenseMatrix,DenseMatrix'
x %*% y

## S4 method for signature 'VecBasic,VecBasic'
x %*% y

## S4 method for signature 'DenseMatrix,VecBasic'
x %*% y

## S4 method for signature 'DenseMatrix,vector'
x %*% y

## S4 method for signature 'VecBasic,DenseMatrix'
x %*% y

## S4 method for signature 'vector,DenseMatrix'
x %*% y

## S4 method for signature 'SymEngineDataType'
Math(x)

## S4 method for signature 'SymEngineDataType'
sinpi(x)

## S4 method for signature 'SymEngineDataType'
cospi(x)

## S4 method for signature 'SymEngineDataType'
tanpi(x)

## S4 method for signature 'SymEngineDataType'
log(x, base)

## S4 method for signature 'SymEngineDataType'
log2(x)

## S4 method for signature 'SymEngineDataType'
log10(x)

## S4 method for signature 'SymEngineDataType'
log1p(x)

## S4 method for signature 'SymEngineDataType'
expm1(x)

## S4 method for signature 'SymEngineDataType'
sum(x, ..., na.rm = FALSE)

## S4 method for signature 'SymEngineDataType'
prod(x, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_e1">e1</code>, <code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_e2">e2</code>, <code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_x">x</code>, <code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_y">y</code>, <code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_base">base</code>, <code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_...">...</code></td>
<td>
<p>Objects.</p>
</td></tr>
<tr><td><code id="+2B3D+2B3D+2B2CBasic+2B2CBasic-method_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>==</code> and <code>!=</code> will return a logical vector. Other
functions will return a <code>Basic</code>, <code>VecBasic</code> or <code>DenseMatrix</code>.
</p>

<hr>
<h2 id='as.character+2CBasic-method'>Some Conversion Methods</h2><span id='topic+as.character+2CBasic-method'></span><span id='topic+as.numeric+2CBasic-method'></span><span id='topic+as.integer+2CBasic-method'></span><span id='topic+as.character+2CVecBasic-method'></span><span id='topic+as.numeric+2CVecBasic-method'></span><span id='topic+as.integer+2CVecBasic-method'></span><span id='topic+as.language'></span><span id='topic+as.language+2CBasic-method'></span>

<h3>Description</h3>

<p>Miscellaneous S4 methods defined for converting a <code>Basic</code> or
<code>VecBasic</code> object to R number/string/language object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Basic'
as.character(x)

## S4 method for signature 'Basic'
as.numeric(x)

## S4 method for signature 'Basic'
as.integer(x)

## S4 method for signature 'VecBasic'
as.character(x)

## S4 method for signature 'VecBasic'
as.numeric(x)

## S4 method for signature 'VecBasic'
as.integer(x)

as.language(x)

## S4 method for signature 'Basic'
as.language(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character+2B2CBasic-method_+3A_x">x</code></td>
<td>
<p>The object to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as default methods of these generics. <code>as.language()</code>
may return <code>symbol</code>, <code>integer</code>, <code>double</code> or <code>call</code>.
</p>

<hr>
<h2 id='as.matrix.DenseMatrix'>Methods Related to DenseMatrix</h2><span id='topic+as.matrix.DenseMatrix'></span><span id='topic+dim+2CDenseMatrix-method'></span><span id='topic+dim+3C-+2CDenseMatrix-method'></span><span id='topic+dim+3C-+2CVecBasic-method'></span><span id='topic+dim+3C-+2CBasic-method'></span><span id='topic+dimnames+3C-+2CDenseMatrix-method'></span><span id='topic+dimnames+2CDenseMatrix-method'></span><span id='topic+length+2CDenseMatrix-method'></span><span id='topic++5B+5B+2CDenseMatrix+2CANY-method'></span><span id='topic++5B+5B+3C-+2CDenseMatrix-method'></span><span id='topic++5B+2CDenseMatrix-method'></span><span id='topic++5B+3C-+2CDenseMatrix-method'></span>

<h3>Description</h3>

<p>These are miscellaneous S3/S4 methods defined for <code>DenseMatrix</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DenseMatrix'
as.matrix(x, ...)

## S4 method for signature 'DenseMatrix'
dim(x)

## S4 replacement method for signature 'DenseMatrix'
dim(x) &lt;- value

## S4 replacement method for signature 'VecBasic'
dim(x) &lt;- value

## S4 replacement method for signature 'Basic'
dim(x) &lt;- value

## S4 replacement method for signature 'DenseMatrix'
dimnames(x) &lt;- value

## S4 method for signature 'DenseMatrix'
dimnames(x)

## S4 method for signature 'DenseMatrix'
length(x)

## S4 method for signature 'DenseMatrix,ANY'
x[[i, j, ...]]

## S4 replacement method for signature 'DenseMatrix'
x[[i, j, ...]] &lt;- value

## S4 method for signature 'DenseMatrix'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'DenseMatrix'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.DenseMatrix_+3A_x">x</code></td>
<td>
<p>A DenseMatrix object.</p>
</td></tr>
<tr><td><code id="as.matrix.DenseMatrix_+3A_i">i</code>, <code id="as.matrix.DenseMatrix_+3A_j">j</code>, <code id="as.matrix.DenseMatrix_+3A_value">value</code>, <code id="as.matrix.DenseMatrix_+3A_...">...</code>, <code id="as.matrix.DenseMatrix_+3A_drop">drop</code></td>
<td>
<p>Arguments for subsetting, assignment or replacing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same or similar with the generics of these methods.
</p>

<hr>
<h2 id='cbind.SymEngineDataType'>Joining DenseMatrix</h2><span id='topic+cbind.SymEngineDataType'></span><span id='topic+rbind.SymEngineDataType'></span>

<h3>Description</h3>

<p>S3 methods of <code>cbind</code> and <code>rbind</code> defined for
<code>DenseMatrix</code> and <code>VecBasic</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SymEngineDataType'
cbind(..., deparse.level)

## S3 method for class 'SymEngineDataType'
rbind(..., deparse.level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.SymEngineDataType_+3A_...">...</code></td>
<td>
<p>DenseMatrix, VecBasic or R objects.</p>
</td></tr>
<tr><td><code id="cbind.SymEngineDataType_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DenseMatrix</code> S4 object.
</p>

<hr>
<h2 id='codegen'>Code Generation</h2><span id='topic+codegen'></span>

<h3>Description</h3>

<p>Generate C/MathML/LaTeX/JavaScript code string from a <code>Basic</code>
or <code>VecBasic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codegen(x, type = c("ccode", "mathml", "latex", "jscode"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codegen_+3A_x">x</code></td>
<td>
<p>A Basic or a VecBasic object.</p>
</td></tr>
<tr><td><code id="codegen_+3A_type">type</code></td>
<td>
<p>One of &quot;ccode&quot;, &quot;mathml&quot;, &quot;latex&quot; and &quot;jscode&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='D+2CSymEngineDataType-method'>Derivatives of a Symbolic Expression</h2><span id='topic+D+2CSymEngineDataType-method'></span>

<h3>Description</h3>

<p>S4 method of <code>D</code> defined for <code>Basic</code>. It returns
the derivative of <code>expr</code> with regards to <code>name</code>.
<code>name</code> may be missing if there is only one symbol in
<code>expr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SymEngineDataType'
D(expr, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D+2B2CSymEngineDataType-method_+3A_expr">expr</code></td>
<td>
<p>A Basic object.</p>
</td></tr>
<tr><td><code id="D+2B2CSymEngineDataType-method_+3A_name">name</code></td>
<td>
<p>A character vector or a Basic object of type Symbol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same type as <code>expr</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- S(~ exp(x))
D(expr) == expr
expr &lt;- S(~ x^2 + 2*x + 1)
D(expr)
</code></pre>

<hr>
<h2 id='det'>Calculate the Determinant of DenseMatrix</h2><span id='topic+det'></span><span id='topic+det+2CDenseMatrix-method'></span>

<h3>Description</h3>

<p>S4 method of <code>det</code> defined for <code>DenseMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det(x, ...)

## S4 method for signature 'DenseMatrix'
det(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_+3A_x">x</code></td>
<td>
<p>A DenseMatrix object.</p>
</td></tr>
<tr><td><code id="det_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Basic</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- Matrix(LETTERS[1:9], 3)
det(mat)
</code></pre>

<hr>
<h2 id='DoubleVisitor'>Double Visitor</h2><span id='topic+DoubleVisitor'></span><span id='topic+visitor_call'></span>

<h3>Description</h3>

<p>Construct <code>DoubleVisitor</code> object from <code>Basic</code> or <code>VecBasic</code>
and use it to numerically evaluate symbolic expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleVisitor(
  exprs,
  args,
  perform_cse = TRUE,
  llvm_opt_level = if (symengine_have_component("llvm")) 3L else -1L
)

visitor_call(visitor, input, do_transpose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleVisitor_+3A_exprs">exprs</code></td>
<td>
<p>A Basic object or a VecBasic object to be evaluated.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_args">args</code></td>
<td>
<p>A VecBasic object indicating order of input arguments. Can be missing.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_perform_cse">perform_cse</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_llvm_opt_level">llvm_opt_level</code></td>
<td>
<p>Integer. If negative, it will return a <code>LambdaDoubleVisitor</code>,
otherwise it will return a <code>LLVMDoubleVisitor</code> with the specified optimization level.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_visitor">visitor</code></td>
<td>
<p>A DoubleVisitor object.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_input">input</code></td>
<td>
<p>A numeric matrix. Each row is input value for one argument.</p>
</td></tr>
<tr><td><code id="DoubleVisitor_+3A_do_transpose">do_transpose</code></td>
<td>
<p>Boolean. Matters when <code>exprs</code> is a VecBasic.
If true, output will have each column for one symbolic expression, otherwise
each row for one symbolic expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DoubleVisitor</code> constructs the visitor and visitor itself is callable.
<code>visitor_call</code> is the low level function to call the visitor with input.
</p>


<h3>Value</h3>

<p><code>DoubleVisitor</code> returns a callable <code>LambdaDoubleVisitor</code> or
<code>LLVMDoubleVisitor</code>. <code>visitor_call</code> returns a numeric vector or matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambdify">lambdify</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- S("a")
b &lt;- S("b")
c &lt;- S("c")
vec &lt;- c(log(a), log(a)/log(b) + c)
func &lt;- DoubleVisitor(vec, args = c(a, b, c))
args(func)

## Use closure
func(a = 1:10, b = 10:1, c = 1.43)

## Use visitor_call
input &lt;- rbind(a = 1:10, b = 10:1, c = 1.43)
visitor_call(func, input, do_transpose = TRUE)
</code></pre>

<hr>
<h2 id='dxdt'>Solve System of Ordinary Differential Equations</h2><span id='topic+dxdt'></span><span id='topic++3D+3D+2CDxdtOdeConstructor+2CANY-method'></span><span id='topic+ODESystem'></span><span id='topic+predict+2CODESystem-method'></span>

<h3>Description</h3>

<p>This is a wrapper of the <code>odeintr</code> R package using
symengine objects to specify the ODE system and C code
generation functionality from symengine to generate the
C++ source. The <code>dxdt</code> function and defined <code>==</code> S4 method
allow one to intuitively specify the ODE system with symengine
objects. The <code>ODESystem</code> will generate C++ source
and compile on the fly with Rcpp. Then <code>predict</code> can be used to get
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dxdt(x)

## S4 method for signature 'DxdtOdeConstructor,ANY'
e1 == e2

ODESystem(
  odesys,
  ...,
  method = "rk5_i",
  atol = 1e-06,
  rtol = 1e-06,
  compile = TRUE
)

## S4 method for signature 'ODESystem'
predict(object, init, duration, step_size = 1, start = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dxdt_+3A_x">x</code></td>
<td>
<p>A SymEngine Basic object of type Symbol or a R object
that will be converted to <code>Symbol(x)</code>.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_e1">e1</code></td>
<td>
<p>A DxdtOdeConstructor S4 object which can be returned by 'dxdt'.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_e2">e2</code></td>
<td>
<p>A Basic object or an R object that will be converted to 'S(e2)'.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_odesys">odesys</code>, <code id="dxdt_+3A_...">...</code></td>
<td>
<p>DxdtOde S4 objects that can be returned with
'dxdt(x) == rhs'. Or 'odesys' can be a list of DxdtOde S4 objects
when there is no dot arguments.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_method">method</code>, <code id="dxdt_+3A_atol">atol</code>, <code id="dxdt_+3A_rtol">rtol</code></td>
<td>
<p>Passed to 'odeintr::compile_sys'.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_compile">compile</code></td>
<td>
<p>Logical, whether to compile the C++ source. Useful if
you only want to obtain the code.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_object">object</code></td>
<td>
<p>A ODESystem S4 object.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_init">init</code></td>
<td>
<p>A numeric vector specifying the initial conditions. It can
be named with the variable names or it can be unnamed but in the
same of order of equations.</p>
</td></tr>
<tr><td><code id="dxdt_+3A_duration">duration</code>, <code id="dxdt_+3A_step_size">step_size</code>, <code id="dxdt_+3A_start">start</code></td>
<td>
<p>Passed to the function generated by
'odeintr::compile_sys'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dxdt</code> returns a DxdtOdeConstructor S4 object.
</p>
<p>S4 method of '==' for &quot;DxdtOdeConstructor&quot; returns a DxdtOde S4 object.
</p>
<p>'ODESystem' returns a ODESystem S4 object.
</p>
<p>'predict' returns a dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A differential equation specified with dxdt and ==
x &lt;- Symbol("x")
eq &lt;- dxdt(x) == 1/exp(x)
print(eq)
## Not run: 
## Lorenz system
use_vars(x, y, z)
sigma &lt;- 10
rho &lt;- 28
beta &lt;- 8/3
lorenz_sys &lt;- ODESystem(
    dxdt(x) == sigma * (y - x),
    dxdt(y) == (rho - z) * x - y,
    dxdt(z) == - beta * z + x * y
)
res &lt;- predict(
    lorenz_sys, init = c(x = 1, y = 1, z = 1), duration = 100, step_size = 0.001
)
plot(res[, c(2, 4)], type = 'l', col = "steelblue", main = "Lorenz Attractor")

## End(Not run)
</code></pre>

<hr>
<h2 id='evalf'>Evaluating a SymEngine Object</h2><span id='topic+evalf'></span>

<h3>Description</h3>

<p>This function will evaluate a SymEngine object to its &quot;numerical&quot; form
with given precision. User may further use <code>as.double()</code> to convert
to R value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalf(expr, bits = 53L, complex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalf_+3A_expr">expr</code></td>
<td>
<p>A SymEngine object.</p>
</td></tr>
<tr><td><code id="evalf_+3A_bits">bits</code></td>
<td>
<p>The precision.</p>
</td></tr>
<tr><td><code id="evalf_+3A_complex">complex</code></td>
<td>
<p>Whether or not to be evaluated as a complex number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same type as <code>expr</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- Constant("pi")
evalf(expr)
as.double(evalf(expr)) == pi
</code></pre>

<hr>
<h2 id='expand'>Expand a Symbolic Expression</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>This function takes a SymEngine object and return
its expanded form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p>A Basic/VecBasic/DenseMatrix S4 object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same type as input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- S(~ (x + y) ^ 3)
expand(expr)
</code></pre>

<hr>
<h2 id='Function'>Create a FunctionSymbol</h2><span id='topic+Function'></span><span id='topic+FunctionSymbol'></span>

<h3>Description</h3>

<p><code>FunctionSymbol</code> creates a Basic object with type <code>FunctionSymbol</code>.
<code>Function</code> returns a generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Function(name)

FunctionSymbol(name, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Function_+3A_name">name</code></td>
<td>
<p>Name of the function symbol</p>
</td></tr>
<tr><td><code id="Function_+3A_args">args</code></td>
<td>
<p>Dependent symbols</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FunctionSymbol</code> returns a <code>Basic</code>. <code>Function</code> returns
a function that will return a <code>Basic</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+S">S</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- Function("f")
a &lt;- Symbol("a")
b &lt;- Symbol("b")
f(a, b)
e &lt;- f(a, f(a + b))
D(e, a)
FunctionSymbol("f", c(a,b))
</code></pre>

<hr>
<h2 id='get_type'>Get Information about Basic Object</h2><span id='topic+get_type'></span><span id='topic+get_args'></span><span id='topic+get_hash'></span><span id='topic+get_str'></span><span id='topic+free_symbols'></span><span id='topic+function_symbols'></span><span id='topic+get_name'></span><span id='topic+get_prec'></span>

<h3>Description</h3>

<p>These functions are used to access the underlying properties of a
<code>Basic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type(x)

get_args(x)

get_hash(x)

get_str(x)

free_symbols(x)

function_symbols(x)

get_name(x)

get_prec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_+3A_x">x</code></td>
<td>
<p>A Basic object.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>get_type</dt><dd><p>Return the internal type</p>
</dd>
<dt>get_args</dt><dd><p>Return the internal arguments of a Basic object as a VecBasic</p>
</dd>
<dt>get_hash</dt><dd><p>Return the hash as a string</p>
</dd>
<dt>get_str</dt><dd><p>Return the string representation of the Basic object</p>
</dd>
<dt>free_symbols</dt><dd><p>Return free symbols in an expression</p>
</dd>
<dt>function_symbols</dt><dd><p>Return function symbols in an expression</p>
</dd>
<dt>get_name</dt><dd><p>Return name of a Basic object of type FunctionSymbol</p>
</dd>
<dt>get_prec</dt><dd><p>Return precision of a Basic object of type RealMPFR</p>
</dd>
</dl>



<h3>Value</h3>


<ul>
<li> <p><code>get_type()</code>, <code>get_hash()</code>, <code>get_str()</code>, <code>get_name()</code>
return a string.
</p>
</li>
<li> <p><code>get_args()</code>, <code>free_symbols()</code>, <code>function_symbols()</code>
return a <code>VecBasic</code> S4 object.
</p>
</li>
<li> <p><code>get_prec()</code> returns an integer.
</p>
</li></ul>


<hr>
<h2 id='lambdify'>Convert A Basic/VecBasic Object to R Function</h2><span id='topic+lambdify'></span><span id='topic+as.function.BasicOrVecBasic'></span>

<h3>Description</h3>

<p>These functions currently use <code><a href="#topic+DoubleVisitor">DoubleVisitor</a></code> to
convert a Basic/VecBasic object to a <code>DoubleVisitor</code> which
essentially is a S4 class extending R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdify(x, args, backend = c("auto", "lambda", "llvm"), perform_cse = TRUE)

## S3 method for class 'BasicOrVecBasic'
as.function(x, args, backend = "auto", perform_cse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdify_+3A_x">x</code></td>
<td>
<p>A Basic object or a VecBasic object.</p>
</td></tr>
<tr><td><code id="lambdify_+3A_args">args</code></td>
<td>
<p>A VecBasic object specifying the arguments of the resulted function.
It will be passed to <code><a href="#topic+DoubleVisitor">DoubleVisitor</a></code> and can be missing.</p>
</td></tr>
<tr><td><code id="lambdify_+3A_backend">backend</code></td>
<td>
<p>One of &quot;auto&quot;, &quot;lambda&quot; and &quot;llvm&quot;. If &quot;auto&quot;, 
<code>getOption("lambdify.backend")</code> will be used to determine the value. If that
option is not set, it will be determined based on <code>symengine_have_component("llvm")</code>.</p>
</td></tr>
<tr><td><code id="lambdify_+3A_perform_cse">perform_cse</code></td>
<td>
<p>Passed to <code><a href="#topic+DoubleVisitor">DoubleVisitor</a></code>.</p>
</td></tr>
<tr><td><code id="lambdify_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DoubleVisitor</code> S4 object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DoubleVisitor">DoubleVisitor</a></code>
</p>

<hr>
<h2 id='LCM'>Some Special Math Functions</h2><span id='topic+LCM'></span><span id='topic+GCD'></span><span id='topic+nextprime'></span><span id='topic+factorial'></span><span id='topic+factorial+2CSymEngineDataType-method'></span><span id='topic+choose'></span><span id='topic+choose+2CSymEngineDataType-method'></span><span id='topic+zeta'></span><span id='topic+lambertw'></span><span id='topic+dirichlet_eta'></span><span id='topic+erf'></span><span id='topic+erfc'></span><span id='topic+atan2+2CSymEngineDataType+2CSymEngineDataType-method'></span><span id='topic+kronecker_delta'></span><span id='topic+lowergamma'></span><span id='topic+uppergamma'></span><span id='topic+beta+2CSymEngineDataType+2CSymEngineDataType-method'></span><span id='topic+psigamma+2CSymEngineDataType-method'></span><span id='topic+digamma+2CSymEngineDataType-method'></span><span id='topic+trigamma+2CSymEngineDataType-method'></span>

<h3>Description</h3>

<p>These are some special mathematical functions and functions
related to number theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCM(a, b)

GCD(a, b)

nextprime(a)

factorial(x)

## S4 method for signature 'SymEngineDataType'
factorial(x)

choose(n, k)

## S4 method for signature 'SymEngineDataType'
choose(n, k)

zeta(a)

lambertw(a)

dirichlet_eta(a)

erf(a)

erfc(a)

## S4 method for signature 'SymEngineDataType,SymEngineDataType'
atan2(y, x)

kronecker_delta(x, y)

lowergamma(x, a)

uppergamma(x, a)

## S4 method for signature 'SymEngineDataType,SymEngineDataType'
beta(a, b)

## S4 method for signature 'SymEngineDataType'
psigamma(x, deriv = 0L)

## S4 method for signature 'SymEngineDataType'
digamma(x)

## S4 method for signature 'SymEngineDataType'
trigamma(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LCM_+3A_a">a</code>, <code id="LCM_+3A_b">b</code>, <code id="LCM_+3A_x">x</code>, <code id="LCM_+3A_y">y</code>, <code id="LCM_+3A_n">n</code>, <code id="LCM_+3A_k">k</code>, <code id="LCM_+3A_deriv">deriv</code></td>
<td>
<p>SymEngine objects (<code>Basic</code>/<code>VecBasic</code>/<code>DenseMatrix</code>).
Some functions require Integer type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same type as input.
</p>

<hr>
<h2 id='length+2CVecBasic-method'>Methods Related to VecBasic</h2><span id='topic+length+2CVecBasic-method'></span><span id='topic+rep.VecBasic'></span><span id='topic+rep.Basic'></span><span id='topic+unique.VecBasic'></span><span id='topic+c+2CBasicOrVecBasic-method'></span><span id='topic++5B+5B+2CVecBasic+2Cnumeric-method'></span><span id='topic++5B+2CVecBasic-method'></span><span id='topic++5B+5B+3C-+2CVecBasic-method'></span><span id='topic++5B+3C-+2CVecBasic-method'></span>

<h3>Description</h3>

<p>Miscellaneous S4 methods defined for <code>VecBasic</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VecBasic'
length(x)

## S3 method for class 'VecBasic'
rep(x, ...)

## S3 method for class 'Basic'
rep(x, ...)

## S3 method for class 'VecBasic'
unique(x, ...)

## S4 method for signature 'BasicOrVecBasic'
c(x, ...)

## S4 method for signature 'VecBasic,numeric'
x[[i, j, ...]]

## S4 method for signature 'VecBasic'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'VecBasic'
x[[i]] &lt;- value

## S4 replacement method for signature 'VecBasic'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CVecBasic-method_+3A_x">x</code></td>
<td>
<p>Basic object or Vecbasic object.</p>
</td></tr>
<tr><td><code id="length+2B2CVecBasic-method_+3A_i">i</code>, <code id="length+2B2CVecBasic-method_+3A_j">j</code>, <code id="length+2B2CVecBasic-method_+3A_...">...</code>, <code id="length+2B2CVecBasic-method_+3A_drop">drop</code>, <code id="length+2B2CVecBasic-method_+3A_value">value</code></td>
<td>
<p>Arguments for subsetting or replacing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same or similar to the generics.
</p>

<hr>
<h2 id='Matrix'>DenseMatrix Constructor</h2><span id='topic+Matrix'></span>

<h3>Description</h3>

<p>This function constructs a symbolic matrix (<code>DenseMatrix</code> S4 object)
with a similar interface with R's <code>matrix</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix(data, nrow = 1L, ncol = 1L, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix_+3A_data">data</code></td>
<td>
<p>A R object.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_nrow">nrow</code>, <code id="Matrix_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_byrow">byrow</code></td>
<td>
<p>Boolean value. Whether the data should be filled by row or by column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DenseMatrix</code> S4 object.
</p>

<hr>
<h2 id='S'>Converting R object to Basic</h2><span id='topic+S'></span><span id='topic+Basic'></span><span id='topic+Symbol'></span><span id='topic+Constant'></span><span id='topic+Real'></span>

<h3>Description</h3>

<p>'S' and 'Basic' converts a R object to a Basic object. 'Symbol', 'Real' and 'Constant'
construct a Basic object with type &quot;Symbol&quot;, &quot;RealDouble&quot;/&quot;RealMPFR&quot;
and &quot;Constant&quot;, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S(x)

Basic(x)

Symbol(x)

Constant(x)

Real(x, prec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_+3A_x">x</code></td>
<td>
<p>A R object.</p>
</td></tr>
<tr><td><code id="S_+3A_prec">prec</code></td>
<td>
<p>If supplied, the argument will be parsed as a Basic object of type 
RealMPFR.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For double vector, 'S' will check whether it is a whole number &ndash; if true,
it will be converted to a Integer type. If this behavior is not desired,
you can use 'Basic' or 'as(x, &quot;Basic&quot;)'.
</p>


<h3>Value</h3>

<p>A <code>Basic</code> S4 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S("(x + y)^2")
S(~ (x + y)^2)
S(NaN)
S(42)
Basic(42)
as(42, "Basic")
pi &lt;- Constant("pi")
evalf(pi)
if (symengine_have_component("mpfr"))
    evalf(pi, 300)
Real(42)
if (symengine_have_component("mpfr"))
    Real(42, prec = 140)
</code></pre>

<hr>
<h2 id='solve'>Solve Symbolic Equations</h2><span id='topic+solve'></span><span id='topic+solve+2CDenseMatrix-method'></span><span id='topic+solve+2CVecBasic-method'></span><span id='topic+solve+2CBasic-method'></span>

<h3>Description</h3>

<p>Solve system of symbolic equations or solve a polynomial equation.
Depending on types of arguments, it supports different modes.
See Details and Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve(a, b, ...)

## S4 method for signature 'DenseMatrix'
solve(a, b, ...)

## S4 method for signature 'VecBasic'
solve(a, b, ...)

## S4 method for signature 'Basic'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_+3A_a">a</code>, <code id="solve_+3A_b">b</code></td>
<td>
<p>Objects, see details.</p>
</td></tr>
<tr><td><code id="solve_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>solve</code> is a generic function dispatched on the class of the first argument.
</p>

<ul>
<li>
<p>If <code>a</code> is a (square) DenseMatrix, it solves the equation
<code>a %*% x = b</code> for <code>x</code>. (similar to <code>solve.default()</code>)

</p>
</li>
<li>
<p>If <code>a</code> is a DenseMatrix and <code>b</code> is missing, <code>b</code> is
taken to be an identity matrix and <code>solve</code> will return the
inverse of <code>a</code>. (similar to <code>solve.default()</code>)

</p>
</li>
<li>
<p>If <code>a</code> is a VecBasic, it solves the system of linear equations
represented by <code>a</code> with regards to symbols represented in <code>b</code>.

</p>
</li>
<li>
<p>If <code>a</code> is a Basic, it solves the polynomial equation represented by
a with regards to the symbol represented in <code>b</code>.

</p>
</li></ul>



<h3>Value</h3>

<p>A <code>VecBasic</code> or <code>DenseMatrix</code> S4 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Inverse of a symbolic matrix
mat &lt;- Matrix(c("A", "B", "C", "D"), 2)
solve(mat)

## Solve a %*% x == b
a &lt;- Matrix(c("a11", "a21", "a12", "a22"), 2) # a is a 2x2 matrix
b &lt;- Vector("b1", "b2")                       # b is a length 2 vector
solve(a, b)                                   # Solution of x (2x1 matrix)

## Solve the system of linear equations represented by a with regards to
## symbols in b
a &lt;- Vector(~ -2*x + y - 4,  # A system of linear equations
            ~  3*x + y - 9)
b &lt;- Vector(~x, ~y)          # Symbols to solve (x and y)
solve(a, b)                  # Solution of x and y
</code></pre>

<hr>
<h2 id='subs'>Substitute Expressions in SymEngine Objects</h2><span id='topic+subs'></span>

<h3>Description</h3>

<p>This function will substitute <code>expr</code> with pairs of
values in the dot arguments. The length of dot arguments must
be a even number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subs_+3A_expr">expr</code></td>
<td>
<p>A <code>Basic</code> S4 object.</p>
</td></tr>
<tr><td><code id="subs_+3A_...">...</code></td>
<td>
<p>Pairs of Basic objects or values can be converted to <code>Basic</code>.
In the order of &quot;from1, to1, from2, to2, ...&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same type as <code>expr</code>.
</p>

<hr>
<h2 id='symengine'>symengine: R interface to SymEngine C++ library for symbolic computation</h2><span id='topic+symengine'></span>

<h3>Description</h3>

<p><code>symengine</code> is a R package for symbolic computation.
</p>


<h3>Details</h3>

<p><a href="https://github.com/symengine/">SymEngine library</a> is a standalone fast symbolic
manipulation library written in C++. It allows computation over mathematical expressions
in a way which is similar to the traditional manual computations of mathematicians and
scientists. The R interface of the library tries to provide a user-friendly way to do
symbolic computation in R and can be integrated into other packages to help solve related
tasks. The design of the package is somehow similar to the <a href="https://www.sympy.org">SymPy</a>
package in Python. Unlike some other computer algebra systems, it does not invent its own
language or domain specific language but uses R language to manipulate the symbolic
expressions.
</p>
<p><code>symengine</code> uses the S4 dispatch system extensively to differentiate between calculation
over normal R objects and symengine objects. For example, the semantics of <code>sin</code> in
<code style="white-space: pre;">&#8288;expr &lt;- Symbol("x"); sin(expr)&#8288;</code> is different from the <code>sin</code> used over normal R numbers.
</p>


<h3>Basic class</h3>

<p><code>Basic</code> is simply a S4 class holding a pointer representing a symbolic expression
in symengine. <code>Basic</code> objects have the same S4 class but can have different
C-level representations which can be accessed via <code><a href="#topic+get_type">get_type()</a></code>.
For example, <code>Basic(~ 1/2)</code> will have &quot;Rational&quot; type and <code>Basic(1/2)</code> will have
&quot;RealDouble&quot; type.
</p>
<p>A <code>Basic</code> object will also have a list of associated sub-components
which can be accessed via <code><a href="#topic+get_args">get_args()</a></code>. For example, <code>(expr &lt;- S("x") * 3L * S("a"))</code>
will have type &quot;Mul&quot;, and <code>as.list(get_args(expr))</code> will show the three factors of
the multiplication.
</p>
<p>A <code>Basic</code> object can be constructed via <code><a href="#topic+Basic">Basic()</a></code>, <code><a href="#topic+S">S()</a></code>, <code><a href="#topic+Symbol">Symbol()</a></code>, <code><a href="#topic+Constant">Constant()</a></code> or
<code><a href="#topic+Real">Real()</a></code>.
</p>


<h3>VecBasic and DenseMatrix class</h3>

<p>VecBasic and DenseMatrix are S4 classes representing a symbolic vector or matrix.
They can be constructed with <code><a href="#topic+Vector">Vector()</a></code>, <code><a href="#topic+V">V()</a></code>, <code><a href="#topic+Matrix">Matrix()</a></code>, <code>c()</code>, <code>rbind()</code>
or <code>cbind()</code>. For example the following code will construct a 2x3 matrix.
</p>
<div class="sourceCode"><pre>vec &lt;- Vector("a", "b")
cbind(vec, vec^2L, c(S("c"), S("d")))
</pre></div>
<p>The following functions are expected to work naturally with VecBasic and DenseMatrix
classes.
</p>

<ul>
<li> <p><code>[</code>, <code>[[</code>, <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code> and <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> for subsetting and assignment.
</p>
</li>
<li> <p><code>dim()</code>, <code style="white-space: pre;">&#8288;dim&lt;-&#8288;</code>, <code>length()</code>, <code>t()</code>, <code>det()</code>, <code>rbind()</code>, <code>cbind()</code>, <code>c()</code>, <code>rep()</code>
</p>
</li>
<li> <p><code>%*%</code> for matrix multiplication
</p>
</li>
<li> <p><code>solve(a, b)</code>: solve <code>a %*% x = b</code> where <code>a</code> is a square DenseMatrix and
<code>b</code> is a VecBasic/DenseMatrix.
</p>
</li>
<li> <p><code>solve(a)</code>: find the inverse of <code>a</code> where <code>a</code> is a square DenseMatrix.
</p>
</li>
<li> <p><code>solve(a, b)</code>: solve system of linear equations represented by <code>a</code> (VecBasic) with
regards to symbols in <code>b</code> (VecBasic).
</p>
</li></ul>

<p>Further, the R functions that work on Basic objects (e.g. <code>sin</code>) are expected work
on VecBasic and DenseMatrix objects as well in a vectorized manner.
</p>


<h3>Function bindings</h3>

<p>The following is a (incomplete) list of functions that are expected to work with
symengine objects. Note that these functions can also be used inside a formula or
R language objects and passed to <a href="#topic+S">S</a> or <a href="#topic+Basic">Basic</a> or <a href="#topic+Vector">Vector</a> to construct symengine
objects. For example <code>S(~ sin(x) + 1)</code> and <code>S(quote(sin(x) + 1))</code>.
</p>

<ul>
<li> <p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>
</p>
</li>
<li> <p><code>abs</code>, <code>sqrt</code>, <code>exp</code>, <code>expm1</code>, <code>log</code>, <code>log10</code>, <code>log2</code>, <code>log1p</code>
</p>
</li>
<li> <p><code>cos</code>, <code>cosh</code>, <code>sin</code>, <code>sinh</code>, <code>tan</code>, <code>tanh</code>, <code>acos</code>, <code>acosh</code>, <code>asin</code>, <code>asinh</code>, <code>atan</code>, <code>atanh</code>
</p>
</li>
<li> <p><code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>, <code>gamma</code>, <code>lgamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>lambertw</code>, <code>zeta</code>, <code>dirichlet_eta</code>, <code>erf</code>, <code>erfc</code>
</p>
</li>
<li> <p><code>atan2</code>, <code>kronecker_delta</code>, <code>lowergamma</code>, <code>uppergamma</code>, <code>psigamma</code>, <code>beta</code>
</p>
</li></ul>


<hr>
<h2 id='symengine_version'>Information about SymEngine Library</h2><span id='topic+symengine_version'></span><span id='topic+symengine_ascii_art'></span><span id='topic+symengine_have_component'></span><span id='topic+symengine_compilation_notes'></span>

<h3>Description</h3>

<p>Functions to get symengine logo, version and external libraries built with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symengine_version()

symengine_ascii_art()

symengine_have_component(
  which = c("mpfr", "flint", "arb", "mpc", "ecm", "primesieve", "piranha", "boost",
    "pthread", "llvm")
)

symengine_compilation_notes()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symengine_version_+3A_which">which</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector.
</p>

<hr>
<h2 id='t'>Transpose (as) a DenseMatrix</h2><span id='topic+t'></span><span id='topic+t+2CBasic-method'></span><span id='topic+t+2CVecBasic-method'></span><span id='topic+t+2CDenseMatrix-method'></span>

<h3>Description</h3>

<p>S4 methods of <code>t</code> defined for <code>Basic</code>, <code>VecBasic</code>
and <code>DenseMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t(x)

## S4 method for signature 'Basic'
t(x)

## S4 method for signature 'VecBasic'
t(x)

## S4 method for signature 'DenseMatrix'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_+3A_x">x</code></td>
<td>
<p>A SymEngine object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DenseMatrix</code> S4 object.
</p>

<hr>
<h2 id='use_vars'>Initializing Variables</h2><span id='topic+use_vars'></span>

<h3>Description</h3>

<p>This is a convenient way to initialize variables and assign them in the given
environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_vars(..., .env = parent.frame(), .quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_vars_+3A_...">...</code></td>
<td>
<p>All the arguments will be quoted and parsed, if a argument is named,
the name will be used as the name of variable to assign, otherwise the
argument can only be a symbol.</p>
</td></tr>
<tr><td><code id="use_vars_+3A_.env">.env</code></td>
<td>
<p>Environment to assign.</p>
</td></tr>
<tr><td><code id="use_vars_+3A_.quiet">.quiet</code></td>
<td>
<p>Whether to supress the message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a list of assigned variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use_vars(x, y, expr = "a + b", p = 3.14)
p * x + y
expand(expr^2L)
rm(x, y, expr, p)
</code></pre>

<hr>
<h2 id='Vector'>Symbolic Vector</h2><span id='topic+Vector'></span><span id='topic+V'></span>

<h3>Description</h3>

<p>A symbolic vector is represented by <code>VecBasic</code> S4 class.
<code>Vector</code> and <code>V</code> are constructors of <code>VecBasic</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vector(x, ...)

V(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vector_+3A_x">x</code>, <code id="Vector_+3A_...">...</code></td>
<td>
<p>R objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are some differences between <code>Vector</code> and <code>V</code>.
</p>

<ul>
<li>
<p>For double values, <code>V</code> will check whether they are
whole number, and convert them to integer if so.
<code>Vector</code> will not.

</p>
</li>
<li>
<p><code>V</code> does not accept &quot;non-scalar&quot; arguments,
like <code>Vector(c(1,2,3))</code>.

</p>
</li></ul>



<h3>Value</h3>

<p>A <code>VecBasic</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- S("a")
b &lt;- S("b")
Vector(a, b, a + b, 42L)
Vector(list(a, b, 42L))

Vector(1,2,a)
V(1,2,a)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
