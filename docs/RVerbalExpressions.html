<!DOCTYPE html><html><head><title>Help for package RVerbalExpressions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RVerbalExpressions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#rx'><p>Constructs a Verbal Expression</p></a></li>
<li><a href='#rx_alnum'><p>Match alphanumeric characters.</p></a></li>
<li><a href='#rx_alpha'><p>Match alphabetic characters.</p></a></li>
<li><a href='#rx_any_of'><p>Match any of these characters exactly once.</p></a></li>
<li><a href='#rx_anything'><p>Match any character(s) any (including zero) number of times.</p></a></li>
<li><a href='#rx_anything_but'><p>Match any character(s) except these any (including zero) number of times.</p></a></li>
<li><a href='#rx_avoid_prefix'><p>Negative lookaround functions</p></a></li>
<li><a href='#rx_begin_capture'><p>Begin a capture group.</p></a></li>
<li><a href='#rx_digit'><p>Match a digit (0–9).</p></a></li>
<li><a href='#rx_either_of'><p>Alternatively, match either expression.</p></a></li>
<li><a href='#rx_end_capture'><p>End a capture group.</p></a></li>
<li><a href='#rx_end_of_line'><p>Match the expression only if it appears till the end of the line.</p></a></li>
<li><a href='#rx_find'><p>Match an expression.</p></a></li>
<li><a href='#rx_line_break'><p>Match a line break.</p></a></li>
<li><a href='#rx_lowercase'><p>Match lower case letters.</p></a></li>
<li><a href='#rx_maybe'><p>Optionally match an expression.</p></a></li>
<li><a href='#rx_multiple'><p>Match the previous group any number of times.</p></a></li>
<li><a href='#rx_none_or_more'><p>Match the previous stuff zero or many times.</p></a></li>
<li><a href='#rx_not'><p>Ensure that the parameter does not follow.</p></a></li>
<li><a href='#rx_one_or_more'><p>Match the previous stuff one or more times.</p></a></li>
<li><a href='#rx_punctuation'><p>Match punctuation characters.</p></a></li>
<li><a href='#rx_range'><p>Match any character within the range defined by the parameters.</p></a></li>
<li><a href='#rx_seek_prefix'><p>Positive lookaround functions</p></a></li>
<li><a href='#rx_something'><p>Match any character(s) at least once.</p></a></li>
<li><a href='#rx_something_but'><p>Match any character(s) except these at least once.</p></a></li>
<li><a href='#rx_space'><p>Match a space character.</p></a></li>
<li><a href='#rx_start_of_line'><p>Match the expression only if it appears from beginning of line.</p></a></li>
<li><a href='#rx_tab'><p>Match a tab character.</p></a></li>
<li><a href='#rx_uppercase'><p>Match upper case letters.</p></a></li>
<li><a href='#rx_whitespace'><p>Match a whitespace character.</p></a></li>
<li><a href='#rx_with_any_case'><p>Control case-insensitive matching.</p></a></li>
<li><a href='#rx_word'><p>Match a word.</p></a></li>
<li><a href='#rx_word_char'><p>Match a word character.</p></a></li>
<li><a href='#rx_word_edge'><p>Find beginning or end of a word.</p></a></li>
<li><a href='#sanitize'><p>Escape characters expected special by regex engines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Regular Expressions Easily</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Build regular expressions using grammar and functionality inspired 
    by <a href="https://github.com/VerbalExpressions">https://github.com/VerbalExpressions</a>. Usage of the %&gt;% is encouraged to
    build expressions in a chain-like fashion.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr, stringr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/VerbalExpressions/RVerbalExpressions">https://github.com/VerbalExpressions/RVerbalExpressions</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/VerbalExpressions/RVerbalExpressions/issues">https://github.com/VerbalExpressions/RVerbalExpressions/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 16:36:14 UTC; tlittlef</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Littlefield <a href="https://orcid.org/0000-0002-6020-1125"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dmytro Perepolkin <a href="https://orcid.org/0000-0001-8558-6183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Littlefield &lt;tylurp1@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 22:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='rx'>Constructs a Verbal Expression</h2><span id='topic+rx'></span>

<h3>Description</h3>

<p>Add this to the beginning of every verbal expression chain. This
simply returns an empty character vector so that the next step in the chain
can provide a value without explicitly writing <code>value = "blah"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>rx()

# this
rx() %&gt;%
  rx_find("cat") %&gt;%
  rx_anything() %&gt;%
  rx_find("dog")

# instead of
rx_find(value = "cat") %&gt;%
  rx_anything() %&gt;%
  rx_find("dog")
</code></pre>

<hr>
<h2 id='rx_alnum'>Match alphanumeric characters.</h2><span id='topic+rx_alnum'></span>

<h3>Description</h3>

<p>Matches both letters (case insensitive) and numbers (a through
z and 0 through 9).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_alnum(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_alnum_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_alnum_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
alphanumeric characters). Use <code>TRUE</code> to <em>not</em> match alphanumeric
characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_alnum()
rx_alnum(inverse = TRUE)

# create an expression
x &lt;- rx_alnum()

# create input
string &lt;- "Apple 1!"

# extract match
regmatches(string, gregexpr(x, string))
</code></pre>

<hr>
<h2 id='rx_alpha'>Match alphabetic characters.</h2><span id='topic+rx_alpha'></span>

<h3>Description</h3>

<p>Matches letters (case insensitive) only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_alpha(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_alpha_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_alpha_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
alphabetic characters). Use <code>TRUE</code> to <em>not</em> match alphabetic
characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_alpha()
rx_alpha(inverse = TRUE)

# create an expression
x &lt;- rx_alpha()

# create input
string &lt;- "Apple 1!"

# extract match
regmatches(string, gregexpr(x, string))
</code></pre>

<hr>
<h2 id='rx_any_of'>Match any of these characters exactly once.</h2><span id='topic+rx_any_of'></span>

<h3>Description</h3>

<p>Constructs a <em>character class</em>, sometimes called a
<em>character set</em>. With this particular expression, you can tell the
regex engine to match only one out of several characters. It does this by
simply placing the characters you want to match between square brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_any_of(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_any_of_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_any_of_+3A_value">value</code></td>
<td>
<p>Expression to optionally match</p>
</td></tr>
</table>


<h3>References</h3>

<p>Character class: <a href="https://www.regular-expressions.info/charclass.html">https://www.regular-expressions.info/charclass.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_any_of(value = "abc")

# create an expression
x &lt;- rx_any_of(value = "abc")

grepl(x, "c") # should be true
grepl(x, "d") # should be false

y &lt;- rx() %&gt;%
  rx_find("gr") %&gt;%
  rx_any_of("ae") %&gt;%
  rx_find("y")

regmatches("gray", regexec(y, "gray"))[[1]]
regmatches("grey", regexec(y, "grey"))[[1]]

</code></pre>

<hr>
<h2 id='rx_anything'>Match any character(s) any (including zero) number of times.</h2><span id='topic+rx_anything'></span>

<h3>Description</h3>

<p>This expression will match everything except line breaks using
the <em>dot</em> and the <em>star</em>. The Dot <code>.</code> is a
<em>metacharacter</em> and the Star <code>*</code> is a <em>quantifier</em>. When
combined the expression is considered greedy because it will match everything
(except line breaks) 0 or more times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_anything(.data = NULL, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_anything_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_anything_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code>
matching stops after the first match, <code>greedy</code> continues searching until
end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dot: <a href="https://www.regular-expressions.info/dot.html">https://www.regular-expressions.info/dot.html</a>
</p>
<p>Star Quantifier: <a href="https://www.regular-expressions.info/repeat.html">https://www.regular-expressions.info/repeat.html</a>
</p>
<p>Greedy and Lazy Quantifiers: <a href="https://www.regular-expressions.info/repeat.html#greedy">https://www.regular-expressions.info/repeat.html#greedy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_anything()
rx_anything(mode = "lazy")

x &lt;- rx() %&gt;%
  rx_start_of_line() %&gt;%
  rx_anything() %&gt;%
  rx_end_of_line()

grepl(x, "anything!")     # this should be true
grepl(rx_anything(), "")  # this should be true
grepl(rx_something(), "") # this should be false

</code></pre>

<hr>
<h2 id='rx_anything_but'>Match any character(s) except these any (including zero) number of times.</h2><span id='topic+rx_anything_but'></span>

<h3>Description</h3>

<p>This expression will match everything except whatever characters
the user specifies in the <code>value</code> parameter. It does this by adding a
caret symbol <code>^</code> at the beginning of a character set <code>[]</code>. Typing
a caret after the opening square bracket negates the character class. The
result is that the character class matches any character that is not in the
character class. Unlike the dot, negated character classes also match
(invisible) line break characters. If you don't want a negated character
class to match line breaks, you need to include the line break characters in
the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_anything_but(.data = NULL, value, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_anything_but_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_anything_but_+3A_value">value</code></td>
<td>
<p>Characters to not match</p>
</td></tr>
<tr><td><code id="rx_anything_but_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code> matching stops after the first match, <code>greedy</code> continues
searching until end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Character Class: <a href="https://www.regular-expressions.info/charclass.html">https://www.regular-expressions.info/charclass.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_anything_but(value = "abc")

</code></pre>

<hr>
<h2 id='rx_avoid_prefix'>Negative lookaround functions</h2><span id='topic+rx_avoid_prefix'></span><span id='topic+rx_avoid_suffix'></span>

<h3>Description</h3>

<p>This function facilitates matching by providing negative assurances for surrounding symbols/groups of symbols.
It allows for building expressions that are dependent on context of occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_avoid_prefix(.data = NULL, value)

rx_avoid_suffix(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_avoid_prefix_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_avoid_prefix_+3A_value">value</code></td>
<td>
<p>Exact expression to match</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># matches any number of digits, but not preceded by "USD"
rx() %&gt;%
  rx_avoid_prefix('USD') %&gt;%
  rx_digit() %&gt;%
  rx_one_or_more()

#matches a digit, but not followed by " dollars"
rx() %&gt;%
  rx_digit() %&gt;%
  rx_avoid_suffix(' dollars')

</code></pre>

<hr>
<h2 id='rx_begin_capture'>Begin a capture group.</h2><span id='topic+rx_begin_capture'></span>

<h3>Description</h3>

<p>Begin a capture group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_begin_capture(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_begin_capture_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Capture groups are used to extract data from within the regular
expression match for further processing.
</p>

<hr>
<h2 id='rx_digit'>Match a digit (0–9).</h2><span id='topic+rx_digit'></span>

<h3>Description</h3>

<p>The function <code>rx_digit()</code>looks for tabs with the following
expression: <code>%%d</code> and matches single digit. Plural version matches
specified number of digits <code>n</code> (equivalent to <code>rx_digit() %&gt;% rx_count(n)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_digit(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_digit_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_digit_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
digit characters). Use <code>TRUE</code> to <em>not</em> match digit characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_digit()
rx_digit(inverse = TRUE)

# create an expression
x &lt;- rx_digit()

# create input
string &lt;- "1 apple"

# extract match
regmatches(string, regexpr(x, string))
</code></pre>

<hr>
<h2 id='rx_either_of'>Alternatively, match either expression.</h2><span id='topic+rx_either_of'></span>

<h3>Description</h3>

<p>Expression to match instead. If both expressions exists, both
will be returned. This just adds the vertical bar <code>|</code> often called an
<em>alternator</em> which allows the user to find this <em>or</em> that, or both!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_either_of(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_either_of_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_either_of_+3A_...">...</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rx() %&gt;%
  rx_either_of("cat", "dog") %&gt;%
  rx_space() %&gt;%
  rx_find("food")

string &lt;- c("dog food", "cat food", "fish food")

grep(x, string, value = TRUE)
</code></pre>

<hr>
<h2 id='rx_end_capture'>End a capture group.</h2><span id='topic+rx_end_capture'></span>

<h3>Description</h3>

<p>End a capture group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_end_capture(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_end_capture_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Capture groups are used to extract data from within the regular
expression match for further processing.
</p>

<hr>
<h2 id='rx_end_of_line'>Match the expression only if it appears till the end of the line.</h2><span id='topic+rx_end_of_line'></span>

<h3>Description</h3>

<p>Control whether to match the expression only if it appears till
the end of the line. Basically, append a <code>$</code> to the end of the
expression. The dollar sign is considered an <em>anchor</em> and matches the
position of characters. It can be used to &quot;anchor&quot; the regex match at a
certain position, in this case the dollar sign matches right after the last
character in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_end_of_line(.data = NULL, enable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_end_of_line_+3A_.data">.data</code></td>
<td>
<p>Expression to match, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_end_of_line_+3A_enable">enable</code></td>
<td>
<p>Whether to enable this behavior, defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Anchors: <a href="https://www.regular-expressions.info/anchors.html">https://www.regular-expressions.info/anchors.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_end_of_line(enable = TRUE)
rx_end_of_line(enable = FALSE)
rx_end_of_line("abc", enable = TRUE)

# create expression
x &lt;- rx() %&gt;%
  rx_start_of_line(FALSE) %&gt;%
  rx_find("apple") %&gt;%
  rx_end_of_line()

grepl(x, "apples") # should be false
grepl(x, "apple")  # should be true

</code></pre>

<hr>
<h2 id='rx_find'>Match an expression.</h2><span id='topic+rx_find'></span>

<h3>Description</h3>

<p>Identify a specific pattern exactly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_find(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_find_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_find_+3A_value">value</code></td>
<td>
<p>Exact expression to match</p>
</td></tr>
</table>


<h3>References</h3>

<p>Capturing group: <a href="https://www.regular-expressions.info/brackets.html">https://www.regular-expressions.info/brackets.html</a>
</p>
<p>Stack Overflow: <a href="https://stackoverflow.com/questions/3512471">https://stackoverflow.com/questions/3512471</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_find(value = "apple")

# create expression
x &lt;- rx_find(value = "apples")

grepl(x, "apple")  # should be false
grepl(x, "apples") # should be true

</code></pre>

<hr>
<h2 id='rx_line_break'>Match a line break.</h2><span id='topic+rx_line_break'></span>

<h3>Description</h3>

<p>This expression looks for line breaks, both Unix and Windows
style by using the appropriate <em>non printable characters</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_line_break(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_line_break_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Unix style: <a href="https://codepoints.net/U+000A">https://codepoints.net/U+000A</a>
</p>
<p>Windows style: <a href="https://codepoints.net/U+000D">https://codepoints.net/U+000D</a>
</p>
<p>Non printable character: <a href="https://www.regular-expressions.info/nonprint.html">https://www.regular-expressions.info/nonprint.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_line_break()

# create an expression
x &lt;- rx_line_break()

# create input
string &lt;- "foo\nbar"

# extract match
regmatches(string, regexpr(x, string))

</code></pre>

<hr>
<h2 id='rx_lowercase'>Match lower case letters.</h2><span id='topic+rx_lowercase'></span>

<h3>Description</h3>

<p>Matches lower case letters only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_lowercase(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_lowercase_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_lowercase_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
lower case). Use <code>TRUE</code> to <em>not</em> match lower case.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_lowercase()
rx_lowercase(inverse = TRUE)

# create an expression
x &lt;- rx_lowercase()
y &lt;- rx_lowercase(inverse = TRUE)

# create input
string &lt;- "Apple 1!"

# extract match
regmatches(string, gregexpr(x, string))
regmatches(string, gregexpr(y, string))
</code></pre>

<hr>
<h2 id='rx_maybe'>Optionally match an expression.</h2><span id='topic+rx_maybe'></span>

<h3>Description</h3>

<p>This expression uses a <em>quantifier</em> <code>?</code> to optionally
match things. Specifically, the question mark makes the preceding token in
the regular expression optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_maybe(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_maybe_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_maybe_+3A_value">value</code></td>
<td>
<p>Expression to optionally match</p>
</td></tr>
</table>


<h3>References</h3>

<p>Quantifiers: <a href="https://www.regular-expressions.info/optional.html">https://www.regular-expressions.info/optional.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_maybe(value = "abc")

# create expression
x &lt;- rx() %&gt;%
  rx_start_of_line() %&gt;%
  rx_maybe("abc") %&gt;%
  rx_end_of_line(enable = FALSE)

grepl(x, "xyz") # should be true

</code></pre>

<hr>
<h2 id='rx_multiple'>Match the previous group any number of times.</h2><span id='topic+rx_multiple'></span>

<h3>Description</h3>

<p>Match the previous group any number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_multiple(.data = NULL, value = NULL, min = NULL, max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_multiple_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_multiple_+3A_value">value</code></td>
<td>
<p>Item to match</p>
</td></tr>
<tr><td><code id="rx_multiple_+3A_min">min</code></td>
<td>
<p>Minimum number of times it should be present</p>
</td></tr>
<tr><td><code id="rx_multiple_+3A_max">max</code></td>
<td>
<p>Maximum number of times it should be present</p>
</td></tr>
</table>

<hr>
<h2 id='rx_none_or_more'>Match the previous stuff zero or many times.</h2><span id='topic+rx_none_or_more'></span>

<h3>Description</h3>

<p>This function simply adds a * to the end of the expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_none_or_more(.data = NULL, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_none_or_more_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_none_or_more_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code> matching stops after the first match, <code>greedy</code> continues
searching until end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_none_or_more()

# create an expression
x &lt;- rx() %&gt;%
  rx_find("a") %&gt;%
  rx_none_or_more()

# create input
input &lt;- "aaa"

# extract match
regmatches(input, regexpr(x, input))
</code></pre>

<hr>
<h2 id='rx_not'>Ensure that the parameter does not follow.</h2><span id='topic+rx_not'></span>

<h3>Description</h3>

<p>This expression uses a <em>negative lookahead</em> to ensure the
value given does not follow the previous verbal expression,
<code>perl = TRUE</code> is required. For example, if you were to look for the
letter <em>q</em> but not the letter <em>u</em> you might translate this to,
&quot;find the letter q everytime the letter u does <em>not</em> come after it&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_not(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_not_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_not_+3A_value">value</code></td>
<td>
<p>Value to ensure absence of</p>
</td></tr>
</table>


<h3>References</h3>

<p>Negative lookahead: <a href="https://www.regular-expressions.info/lookaround.html">https://www.regular-expressions.info/lookaround.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_not(value = "FEB-28")

# construct expression
x &lt;- rx() %&gt;%
  rx_start_of_line() %&gt;%
  rx_find('FEB-29') %&gt;%
  rx_not("FEB-28")

# create a string
string &lt;- c("FEB-29-2017", "FEB-28-2017")

# extract matches, perl = TRUE is required for negative lookahead
regmatches(string, regexpr(x, string, perl = TRUE))

# another example
rx() %&gt;%
  rx_find("q") %&gt;%
  rx_not("u") %&gt;%
  grepl(x = c("qu", "qa", "qq", "q", "q u"), perl = TRUE)

</code></pre>

<hr>
<h2 id='rx_one_or_more'>Match the previous stuff one or more times.</h2><span id='topic+rx_one_or_more'></span>

<h3>Description</h3>

<p>This function simply adds a + to the end of the expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_one_or_more(.data = NULL, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_one_or_more_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_one_or_more_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code> matching stops after the first match, <code>greedy</code> continues
searching until end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_one_or_more()

# create an expression
x &lt;- rx() %&gt;%
  rx_find("a") %&gt;%
  rx_one_or_more()

# create input
input &lt;- "aaa"

# extract match
regmatches(input, regexpr(x, input))
</code></pre>

<hr>
<h2 id='rx_punctuation'>Match punctuation characters.</h2><span id='topic+rx_punctuation'></span>

<h3>Description</h3>

<p>Matches punctuation characters only:
<code>! \" # $ % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ _ ` { | } ~</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_punctuation(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_punctuation_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_punctuation_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
punctuation). Use <code>TRUE</code> to <em>not</em> match punctuation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_punctuation()
rx_punctuation(inverse = TRUE)

# create an expression
x &lt;- rx_punctuation()

# create input
string &lt;- 'Apple 1!'

# extract match
regmatches(string, gregexpr(x, string))

# dont extract punctuation
y &lt;- rx_punctuation(inverse = TRUE)
regmatches(string, gregexpr(y, string))
</code></pre>

<hr>
<h2 id='rx_range'>Match any character within the range defined by the parameters.</h2><span id='topic+rx_range'></span>

<h3>Description</h3>

<p>Value parameter will be interpreted as pairs. For example,
<code>range(c('a', 'z', '0', '9'))</code> will be interpreted to mean any
character within the ranges a–z (ascii x–y) or 0–9 (ascii x–y). The method
expects an even number of parameters; unpaired parameters are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_range(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_range_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_range_+3A_value">value</code></td>
<td>
<p>Range of characters. The method expects an even number of
parameters; unpaired parameters are ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_range(value = c('1', '3'))

# create an expression
x &lt;- rx_range(value = c('1', '3'))

grepl(x, "2") # should be true
grepl(x, "4") # should be false
</code></pre>

<hr>
<h2 id='rx_seek_prefix'>Positive lookaround functions</h2><span id='topic+rx_seek_prefix'></span><span id='topic+rx_seek_suffix'></span>

<h3>Description</h3>

<p>This function facilitates matching by providing assurances for surrounding symbols/groups of symbols.
It allows for building expressions that are dependent on context of occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_seek_prefix(.data = NULL, value)

rx_seek_suffix(.data = NULL, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_seek_prefix_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_seek_prefix_+3A_value">value</code></td>
<td>
<p>Exact expression to match</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># this will match anything between square brackets
rx() %&gt;%
  rx_seek_prefix("[") %&gt;%
  rx_anything("lazy") %&gt;%
  rx_seek_suffix(']')

</code></pre>

<hr>
<h2 id='rx_something'>Match any character(s) at least once.</h2><span id='topic+rx_something'></span>

<h3>Description</h3>

<p>This expression is almost identical to <code>rx_anything()</code>
with one major exception, a <code>+</code> is used instead of a <code>*</code>. This
means <code>rx_something()</code> expects <em>something</em> whereas
<code>anything()</code> expects <em>anything</em> including... nothing!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_something(.data = NULL, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_something_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_something_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code> matching stops after the first match, <code>greedy</code> continues
searching until end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Metacharacters: <a href="https://www.regular-expressions.info/characters.html#special">https://www.regular-expressions.info/characters.html#special</a>
</p>
<p>Greedy and Lazy Quantifiers: <a href="https://www.regular-expressions.info/repeat.html#greedy">https://www.regular-expressions.info/repeat.html#greedy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_something()

# construct an expression
x &lt;- rx_something()

grepl(x, "something!")   # this should be true
grepl(x, "")             # this should be false
grepl(rx_anything(), "") # this should be true

</code></pre>

<hr>
<h2 id='rx_something_but'>Match any character(s) except these at least once.</h2><span id='topic+rx_something_but'></span>

<h3>Description</h3>

<p>This expression is almost identical to <code>rx_anything_but()</code>
with one major exception, a <code>+</code> is used instead of a <code>*</code>. This
means <code>rx_something_but()</code> expects <em>something</em> whereas
<code>rx_anything_but()</code> expects <em>anything</em> including... nothing!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_something_but(.data = NULL, value, mode = "greedy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_something_but_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_something_but_+3A_value">value</code></td>
<td>
<p>Expression to optionally match</p>
</td></tr>
<tr><td><code id="rx_something_but_+3A_mode">mode</code></td>
<td>
<p>Matching mode (<code>greedy</code> (default) or<code>lazy</code>). <code>Lazy</code> matching stops after the first match, <code>greedy</code> continues
searching until end of the string and then back-tracks to the last match.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Metacharacters: <a href="https://www.regular-expressions.info/characters.html#special">https://www.regular-expressions.info/characters.html#special</a>
</p>
<p>Greedy and Lazy Quantifiers: <a href="https://www.regular-expressions.info/repeat.html#greedy">https://www.regular-expressions.info/repeat.html#greedy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_something_but(value = "abc")

# create an expression
x &lt;- rx_something_but(value = "python")

grepl(x, "R")  # should be true
grepl(x, "py") # should be false

</code></pre>

<hr>
<h2 id='rx_space'>Match a space character.</h2><span id='topic+rx_space'></span>

<h3>Description</h3>

<p>Matches a space character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_space(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_space_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_space_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
space). Use <code>TRUE</code> to <em>not</em> match space.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># match space, default
rx_space()

# dont match space
rx_space(inverse = TRUE)

# create an expression
x &lt;- rx_space()

# create input
string &lt;- "1 apple\t"

# extract match
regmatches(string, regexpr(x, string))

# extract no whitespace by inverting behavior
y &lt;- rx_space(inverse = TRUE)
regmatches(string, gregexpr(y, string))
</code></pre>

<hr>
<h2 id='rx_start_of_line'>Match the expression only if it appears from beginning of line.</h2><span id='topic+rx_start_of_line'></span>

<h3>Description</h3>

<p>Control whether to match the expression only if it appears from
the beginning of the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_start_of_line(.data = NULL, enable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_start_of_line_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_start_of_line_+3A_enable">enable</code></td>
<td>
<p>Whether to enable this behavior, defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_start_of_line(enable = TRUE)
rx_start_of_line(enable = FALSE)

# create expression
x &lt;- rx() %&gt;%
  rx_start_of_line() %&gt;%
  rx_find("apple")

grepl(x, "pineapple") # should be false
grepl(x, "apple")     # should be true
</code></pre>

<hr>
<h2 id='rx_tab'>Match a tab character.</h2><span id='topic+rx_tab'></span>

<h3>Description</h3>

<p>Match a tab character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_tab(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_tab_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_tab_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
tabs). Use <code>TRUE</code> to <em>not</em> match tabs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is looks for tabs with the following
expression: <code>\t</code>
</p>

<ol>
<li><p> Tab character: <a href="https://codepoints.net/U+0009">https://codepoints.net/U+0009</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>rx_tab()
rx_tab(inverse = TRUE)

# create an expression
x &lt;- rx_tab()

# create input
string &lt;- "foo\tbar"

# extract match
regmatches(string, regexpr(x, string))
</code></pre>

<hr>
<h2 id='rx_uppercase'>Match upper case letters.</h2><span id='topic+rx_uppercase'></span>

<h3>Description</h3>

<p>Matches upper case letters only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_uppercase(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_uppercase_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_uppercase_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
upper case). Use <code>TRUE</code> to <em>not</em> match upper case.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_uppercase()
rx_uppercase(inverse = TRUE)

# create an expression
x &lt;- rx_uppercase()
y &lt;- rx_uppercase(inverse = TRUE)

# create input
string &lt;- "Apple 1!"

# extract match
regmatches(string, gregexpr(x, string))
regmatches(string, gregexpr(y, string))
</code></pre>

<hr>
<h2 id='rx_whitespace'>Match a whitespace character.</h2><span id='topic+rx_whitespace'></span>

<h3>Description</h3>

<p>Match a whitespace character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_whitespace(.data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_whitespace_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
<tr><td><code id="rx_whitespace_+3A_inverse">inverse</code></td>
<td>
<p>Invert match behavior, defaults to <code>FALSE</code> (match
whitespace). Use <code>TRUE</code> to <em>not</em> match whitespace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Match a whitespace character (one of space, tab, carriage return,
new line, vertical tab and form feed).
</p>

<ol>
<li><p> space: <a href="https://codepoints.net/U+0020">https://codepoints.net/U+0020</a>
</p>
</li>
<li><p> tab: <a href="https://codepoints.net/U+0009">https://codepoints.net/U+0009</a>
</p>
</li>
<li><p> carriage return: <a href="https://codepoints.net/U+000D">https://codepoints.net/U+000D</a>
</p>
</li>
<li><p> new line: <a href="https://codepoints.net/U+000">https://codepoints.net/U+000</a>
</p>
</li>
<li><p> vertical tab: <a href="https://codepoints.net/U+000B">https://codepoints.net/U+000B</a>
</p>
</li>
<li><p> form feed: <a href="https://codepoints.net/U+000C">https://codepoints.net/U+000C</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># match whitespace, default
rx_whitespace()

# dont match whitespace
rx_whitespace(inverse = TRUE)

# create an expression
x &lt;- rx_whitespace()

# create input
string &lt;- "1 apple"

# extract match
regmatches(string, regexpr(x, string))

# extract no whitespace by inverting behavior
y &lt;- rx_whitespace(inverse = TRUE)
regmatches(string, gregexpr(y, string))
</code></pre>

<hr>
<h2 id='rx_with_any_case'>Control case-insensitive matching.</h2><span id='topic+rx_with_any_case'></span>

<h3>Description</h3>

<p>Control case-insensitive matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_with_any_case(.data = NULL, enable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_with_any_case_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
<tr><td><code id="rx_with_any_case_+3A_enable">enable</code></td>
<td>
<p>Whether to enable this behavior</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to adding or removing the i modifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rx_with_any_case()

# case insensitive
x &lt;- rx() %&gt;%
  rx_find("abc") %&gt;%
  rx_with_any_case()

# case sensitive
y &lt;- rx() %&gt;%
  rx_find("abc") %&gt;%
  rx_with_any_case(enable = FALSE)

grepl(x, "ABC") # should be true
grepl(y, "ABC") # should be false
</code></pre>

<hr>
<h2 id='rx_word'>Match a word.</h2><span id='topic+rx_word'></span>

<h3>Description</h3>

<p>Match a word—a string of word characters (a–z, A–Z, 0–9 or _).
This function is looks for tabs with the following expression: <code>\w+</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_word(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_word_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_word()

# create an expression
x &lt;- rx_word()

# create inputs
string1 &lt;- "foo_bar"
string2 &lt;- "foo-bar"

# extract matches
regmatches(string1, regexpr(x, string1))
regmatches(string2, regexpr(x, string2)) # doesn't match -
</code></pre>

<hr>
<h2 id='rx_word_char'>Match a word character.</h2><span id='topic+rx_word_char'></span>

<h3>Description</h3>

<p>Match a word character (a–z, A–Z, 0–9 or _).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_word_char(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_word_char_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code> %&gt;% </code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_word_char()

# Same as rx_word()
x &lt;- rx_word_char() %&gt;%
 rx_one_or_more()

</code></pre>

<hr>
<h2 id='rx_word_edge'>Find beginning or end of a word.</h2><span id='topic+rx_word_edge'></span>

<h3>Description</h3>

<p>Match beginning or end of a word—a string consisting of of word
characters (a–z, A–Z, 0–9 or _).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx_word_edge(.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rx_word_edge_+3A_.data">.data</code></td>
<td>
<p>Expression to append, typically pulled from the pipe <code>%&gt;%</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rx_word_edge()

x &lt;- rx() %&gt;%
 rx_word_edge() %&gt;%
 rx_alpha() %&gt;%
 rx_one_or_more() %&gt;%
 rx_word_edge()

# create inputs
string1 &lt;- "foobar"
string2 &lt;- "foo 23a bar"

# matches 'foobar'
regmatches(string1, regexpr(x, string1))
# matches 'foo' and 'bar' separately
regmatches(string2, gregexpr(x, string2))
</code></pre>

<hr>
<h2 id='sanitize'>Escape characters expected special by regex engines</h2><span id='topic+sanitize'></span>

<h3>Description</h3>

<p>Takes a string and escapes all characters considered special by
the regex engine. This is used internally when you add a string to the
<code>value</code> parameter in most of the available functions. It is exported
and usable externally for users that want to escape all special characters
in their desired match. The following special characters are escaped
<code>. | * ? + ( ) { } ^ $ \ : = [ ]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_+3A_x">x</code></td>
<td>
<p>String to sanitize</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sanitize("^")
sanitize("^+")
sanitize("^+?")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
