<!DOCTYPE html><html lang="en"><head><title>Help for package DHARMa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DHARMa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DHARMa-package'><p>DHARMa: Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models</p></a></li>
<li><a href='#benchmarkRuntime'><p>Benchmark runtimes of several functions</p></a></li>
<li><a href='#checkDots'><p>Check dot operator</p></a></li>
<li><a href='#checkModel'><p>Check if the fitted model is supported by DHARMa</p></a></li>
<li><a href='#checkSimulations'><p>Check simulated data</p></a></li>
<li><a href='#createData'><p>Simulate test data</p></a></li>
<li><a href='#createDHARMa'><p>Create a DHARMa object from hand-coded simulations or Bayesian posterior predictive simulations.</p></a></li>
<li><a href='#DHARMa.ecdf'><p>Modified ECDF function.</p></a></li>
<li><a href='#ensureDHARMa'><p>Ensures that an object is of class DHARMa</p></a></li>
<li><a href='#ensurePredictor'><p>Ensures the existence of a valid predictor to plot residuals against</p></a></li>
<li><a href='#getFamily'><p>Get model family</p></a></li>
<li><a href='#getFitted'><p>Get fitted/predicted values</p></a></li>
<li><a href='#getFixedEffects'><p>Extract fixed effects of a supported model</p></a></li>
<li><a href='#getObservedResponse'><p>Get model response</p></a></li>
<li><a href='#getPearsonResiduals'><p>Get Pearson residuals</p></a></li>
<li><a href='#getPossibleModels'><p>get possible models</p></a></li>
<li><a href='#getQuantile'><p>Calculate Residual Quantiles</p></a></li>
<li><a href='#getRandomState'><p>Record and restore a random state</p></a></li>
<li><a href='#getRefit'><p>Get model refit</p></a></li>
<li><a href='#getResiduals'><p>Get model residuals</p></a></li>
<li><a href='#getSimulations'><p>Get model simulations</p></a></li>
<li><a href='#hist.DHARMa'><p>Histogram of DHARMa residuals</p></a></li>
<li><a href='#hurricanes'><p>Hurricanes</p></a></li>
<li><a href='#outliers'><p>Return outliers</p></a></li>
<li><a href='#plot.DHARMa'><p>DHARMa standard residual plots</p></a></li>
<li><a href='#plot.DHARMaBenchmark'><p>Plots DHARMa benchmarks</p></a></li>
<li><a href='#plotConventionalResiduals'><p>Conventional residual plot</p></a></li>
<li><a href='#plotQQunif'><p>Quantile-quantile plot for a uniform distribution</p></a></li>
<li><a href='#plotResiduals'><p>Generic res ~ pred scatter plot with spline or quantile regression on top</p></a></li>
<li><a href='#plotSimulatedResiduals'><p>DHARMa standard residual plots</p></a></li>
<li><a href='#print.DHARMa'><p>Print simulated residuals</p></a></li>
<li><a href='#recalculateResiduals'><p>Recalculate residuals with grouping</p></a></li>
<li><a href='#residuals.DHARMa'><p>Return residuals of a DHARMa simulation</p></a></li>
<li><a href='#runBenchmarks'><p>Benchmark calculations</p></a></li>
<li><a href='#simulateLRT'><p>Simulated likelihood ratio tests for (generalized) linear mixed models</p></a></li>
<li><a href='#simulateResiduals'><p>Create simulated residuals</p></a></li>
<li><a href='#testCategorical'><p>Test for categorical dependencies</p></a></li>
<li><a href='#testDispersion'><p>DHARMa dispersion tests</p></a></li>
<li><a href='#testGeneric'><p>Test for a generic summary statistic based on simulated data</p></a></li>
<li><a href='#testOutliers'><p>Test for outliers</p></a></li>
<li><a href='#testOverdispersion'><p>Simulated overdisperstion tests</p></a></li>
<li><a href='#testOverdispersionParametric'><p>Parametric overdisperstion tests</p></a></li>
<li><a href='#testPDistribution'><p>Plot distribution of p-values.</p></a></li>
<li><a href='#testPhylogeneticAutocorrelation'><p>Test for phylogenetic autocorrelation</p></a></li>
<li><a href='#testQuantiles'><p>Test for quantiles</p></a></li>
<li><a href='#testResiduals'><p>DHARMa general residual test</p></a></li>
<li><a href='#testSimulatedResiduals'><p>Residual tests</p></a></li>
<li><a href='#testSpatialAutocorrelation'><p>Test for distance-based spatial (or similar type) autocorrelation</p></a></li>
<li><a href='#testTemporalAutocorrelation'><p>Test for temporal autocorrelation</p></a></li>
<li><a href='#testUniformity'><p>Test for overall uniformity</p></a></li>
<li><a href='#testZeroInflation'><p>Tests for zero-inflation</p></a></li>
<li><a href='#transformQuantiles'><p>Transform quantiles to pdf (deprecated)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Residual Diagnostics for Hierarchical (Multi-Level / Mixed)
Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-16</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'DHARMa' package uses a simulation-based approach to create
    readily interpretable scaled (quantile) residuals for fitted (generalized) linear mixed
    models. Currently supported are linear and generalized linear (mixed) models from 'lme4'
    (classes 'lmerMod', 'glmerMod'), 'glmmTMB', 'GLMMadaptive', and 'spaMM'; phylogenetic 
    linear models from 'phylolm' (classes 'phylolm' and 'phyloglm'); generalized additive 
    models ('gam' from 'mgcv'); 'glm' (including 'negbin' from 'MASS', but excluding quasi-distributions) and
    'lm' model classes. Moreover, externally created simulations, e.g. posterior predictive simulations
    from Bayesian software such as 'JAGS', 'STAN', or 'BUGS' can be processed as well.
    The resulting residuals are standardized to values between 0 and 1 and can be interpreted
    as intuitively as residuals from a linear regression. The package also provides a number of
    plot and test functions for typical model misspecification problems, such as
    over/underdispersion, zero-inflation, and residual spatial, phylogenetic and temporal autocorrelation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, grDevices, Matrix, parallel, gap,
lmtest, ape, qgam (&ge; 1.3.2), lme4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0), rmarkdown, KernSmooth, sfsmisc,
MASS, mgcv, mgcViz (&ge; 0.1.9), spaMM (&ge; 3.2.0), GLMMadaptive,
glmmTMB (&ge; 1.1.2.3), phylolm (&ge; 2.6.5)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>phyr, rstan, rjags, BayesianTools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://florianhartig.github.io/DHARMa/">http://florianhartig.github.io/DHARMa/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/florianhartig/DHARMa/issues">https://github.com/florianhartig/DHARMa/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 17:47:16 UTC; melinaleite</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Hartig <a href="https://orcid.org/0000-0002-6255-9059"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lukas Lohse [ctb],
  Melina de Souza leite [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Hartig &lt;florian.hartig@biologie.uni-regensburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-18 11:10:22 UTC</td>
</tr>
</table>
<hr>
<h2 id='DHARMa-package'>DHARMa: Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models</h2><span id='topic+DHARMa'></span><span id='topic+DHARMa-package'></span>

<h3>Description</h3>

<p>The 'DHARMa' package uses a simulation-based approach to create readily interpretable scaled (quantile) residuals for fitted (generalized) linear mixed models. Currently supported are linear and generalized linear (mixed) models from 'lme4' (classes 'lmerMod', 'glmerMod'), 'glmmTMB', 'GLMMadaptive', and 'spaMM'; phylogenetic linear models from 'phylolm' (classes 'phylolm' and 'phyloglm'); generalized additive models ('gam' from 'mgcv'); 'glm' (including 'negbin' from 'MASS', but excluding quasi-distributions) and 'lm' model classes. Moreover, externally created simulations, e.g. posterior predictive simulations from Bayesian software such as 'JAGS', 'STAN', or 'BUGS' can be processed as well. The resulting residuals are standardized to values between 0 and 1 and can be interpreted as intuitively as residuals from a linear regression. The package also provides a number of plot and test functions for typical model misspecification problems, such as over/underdispersion, zero-inflation, and residual spatial, phylogenetic and temporal autocorrelation.
</p>


<h3>Details</h3>

<p>To get started with the package, look at the vignette and start with <a href="#topic+simulateResiduals">simulateResiduals</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Hartig <a href="mailto:florian.hartig@biologie.uni-regensburg.de">florian.hartig@biologie.uni-regensburg.de</a> (<a href="https://orcid.org/0000-0002-6255-9059">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Lukas Lohse [contributor]
</p>
</li>
<li><p> Melina de Souza leite [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>vignette(&quot;DHARMa&quot;, package=&quot;DHARMa&quot;)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://florianhartig.github.io/DHARMa/">http://florianhartig.github.io/DHARMa/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/florianhartig/DHARMa/issues">https://github.com/florianhartig/DHARMa/issues</a>
</p>
</li></ul>


<hr>
<h2 id='benchmarkRuntime'>Benchmark runtimes of several functions</h2><span id='topic+benchmarkRuntime'></span>

<h3>Description</h3>

<p>Benchmark runtimes of several functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkRuntime(createModel, evaluationFunctions, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkRuntime_+3A_createmodel">createModel</code></td>
<td>
<p>a function that creates and returns a fitted model.</p>
</td></tr>
<tr><td><code id="benchmarkRuntime_+3A_evaluationfunctions">evaluationFunctions</code></td>
<td>
<p>a list of functions that are to be evaluated on the fitted models.</p>
</td></tr>
<tr><td><code id="benchmarkRuntime_+3A_n">n</code></td>
<td>
<p>number of replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a small helper function designed to benchmark runtimes of several operations that are to be performed on a list of fitted models. In the example, this is used to benchmark the runtimes of several DHARMa tests.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
createModel = function(){
  testData = createData(family = poisson(), overdispersion = 1,
                        randomEffectVariance = 0)
  fittedModel &lt;- glm(observedResponse ~ Environment1, data = testData, family = poisson())
  return(fittedModel)
}

a = function(m){
  testUniformity(m, plot = FALSE)$p.value
}

b = function(m){
  testDispersion(m, plot = FALSE)$p.value
}

c = function(m){
  testDispersion(m, plot = FALSE, type = "PearsonChisq")$p.value
}


evaluationFunctions = list(a,b, c)

benchmarkRuntime(createModel, evaluationFunctions, 2)
</code></pre>

<hr>
<h2 id='checkDots'>Check dot operator</h2><span id='topic+checkDots'></span>

<h3>Description</h3>

<p>Check dot operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDots(name, default, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDots_+3A_name">name</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="checkDots_+3A_default">default</code></td>
<td>
<p>variable default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>modified from https://github.com/lcolladotor/dots
</p>

<hr>
<h2 id='checkModel'>Check if the fitted model is supported by DHARMa</h2><span id='topic+checkModel'></span>

<h3>Description</h3>

<p>The function checks if the fitted model is supported by DHARMa, and if there are other issues that could create problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkModel(fittedModel, stop = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkModel_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="checkModel_+3A_stop">stop</code></td>
<td>
<p>whether to throw an error if the model is not supported by DHARMa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function os to check if the fitted model class is supported by DHARMa. The function additionally checks for properties of the fitted model that could create problems for calculating residuals or working with the resuls in DHARMa.
</p>

<hr>
<h2 id='checkSimulations'>Check simulated data</h2><span id='topic+checkSimulations'></span>

<h3>Description</h3>

<p>The function checks if the simulated data seems fine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSimulations(simulatedResponse, nObs, nSim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSimulations_+3A_simulatedresponse">simulatedResponse</code></td>
<td>
<p>the simulated response</p>
</td></tr>
<tr><td><code id="checkSimulations_+3A_nobs">nObs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="checkSimulations_+3A_nsim">nSim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
</table>

<hr>
<h2 id='createData'>Simulate test data</h2><span id='topic+createData'></span>

<h3>Description</h3>

<p>This function creates synthetic dataset with various problems such as overdispersion, zero-inflation, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createData(sampleSize = 100, intercept = 0, fixedEffects = 1,
  quadraticFixedEffects = NULL, numGroups = 10, randomEffectVariance = 1,
  overdispersion = 0, family = poisson(), scale = 1, cor = 0,
  roundPoissonVariance = NULL, pZeroInflation = 0, binomialTrials = 1,
  temporalAutocorrelation = 0, spatialAutocorrelation = 0,
  factorResponse = FALSE, replicates = 1, hasNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createData_+3A_samplesize">sampleSize</code></td>
<td>
<p>sample size of the dataset.</p>
</td></tr>
<tr><td><code id="createData_+3A_intercept">intercept</code></td>
<td>
<p>intercept (linear scale).</p>
</td></tr>
<tr><td><code id="createData_+3A_fixedeffects">fixedEffects</code></td>
<td>
<p>vector of fixed effects (linear scale).</p>
</td></tr>
<tr><td><code id="createData_+3A_quadraticfixedeffects">quadraticFixedEffects</code></td>
<td>
<p>vector of quadratic fixed effects (linear scale).</p>
</td></tr>
<tr><td><code id="createData_+3A_numgroups">numGroups</code></td>
<td>
<p>number of groups for the random effect.</p>
</td></tr>
<tr><td><code id="createData_+3A_randomeffectvariance">randomEffectVariance</code></td>
<td>
<p>variance of the random effect (intercept).</p>
</td></tr>
<tr><td><code id="createData_+3A_overdispersion">overdispersion</code></td>
<td>
<p>if this is a numeric value, it will be used as the sd of a random normal variate that is added to the linear predictor. Alternatively, a random function can be provided that takes as input the linear predictor.</p>
</td></tr>
<tr><td><code id="createData_+3A_family">family</code></td>
<td>
<p>family.</p>
</td></tr>
<tr><td><code id="createData_+3A_scale">scale</code></td>
<td>
<p>scale if the distribution has a scale (e.g. sd for the Gaussian)</p>
</td></tr>
<tr><td><code id="createData_+3A_cor">cor</code></td>
<td>
<p>correlation between predictors.</p>
</td></tr>
<tr><td><code id="createData_+3A_roundpoissonvariance">roundPoissonVariance</code></td>
<td>
<p>if set, this creates a uniform noise on the possion response. The aim of this is to create heteroscedasticity.</p>
</td></tr>
<tr><td><code id="createData_+3A_pzeroinflation">pZeroInflation</code></td>
<td>
<p>probability to set any data point to zero.</p>
</td></tr>
<tr><td><code id="createData_+3A_binomialtrials">binomialTrials</code></td>
<td>
<p>Number of trials for the binomial. Only active if family == binomial.</p>
</td></tr>
<tr><td><code id="createData_+3A_temporalautocorrelation">temporalAutocorrelation</code></td>
<td>
<p>strength of temporalAutocorrelation.</p>
</td></tr>
<tr><td><code id="createData_+3A_spatialautocorrelation">spatialAutocorrelation</code></td>
<td>
<p>strength of spatial Autocorrelation.</p>
</td></tr>
<tr><td><code id="createData_+3A_factorresponse">factorResponse</code></td>
<td>
<p>should the response be transformed to a factor (inteded to be used for 0/1 data).</p>
</td></tr>
<tr><td><code id="createData_+3A_replicates">replicates</code></td>
<td>
<p>number of datasets to create.</p>
</td></tr>
<tr><td><code id="createData_+3A_hasna">hasNA</code></td>
<td>
<p>should an NA be added to the environmental predictor (for test purposes).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 500, intercept = 2, fixedEffects = c(1), 
  overdispersion = 0, family = poisson(), quadraticFixedEffects = c(-3), 
  randomEffectVariance = 0)

par(mfrow = c(1,2))
plot(testData$Environment1, testData$observedResponse)
hist(testData$observedResponse)

# with zero-inflation

testData = createData(sampleSize = 500, intercept = 2, fixedEffects = c(1), 
  overdispersion = 0, family = poisson(), quadraticFixedEffects = c(-3), 
  randomEffectVariance = 0, pZeroInflation = 0.6)

par(mfrow = c(1,2))
plot(testData$Environment1, testData$observedResponse)
hist(testData$observedResponse)

# binomial with multiple trials

testData = createData(sampleSize = 40, intercept = 2, fixedEffects = c(1), 
                      overdispersion = 0, family = binomial(), quadraticFixedEffects = c(-3), 
                      randomEffectVariance = 0, binomialTrials = 20)

plot(observedResponse1 / observedResponse0 ~ Environment1, data = testData, ylab = "Proportion 1")


# spatial / temporal correlation

testData = createData(sampleSize = 100, family = poisson(), spatialAutocorrelation = 3, 
                      temporalAutocorrelation = 3)

plot(log(observedResponse) ~ time, data = testData)
plot(log(observedResponse) ~ x, data = testData)
</code></pre>

<hr>
<h2 id='createDHARMa'>Create a DHARMa object from hand-coded simulations or Bayesian posterior predictive simulations.</h2><span id='topic+createDHARMa'></span>

<h3>Description</h3>

<p>Create a DHARMa object from hand-coded simulations or Bayesian posterior predictive simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDHARMa(simulatedResponse, observedResponse,
  fittedPredictedResponse = NULL, integerResponse = FALSE, seed = 123,
  method = c("PIT", "traditional"), rotation = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createDHARMa_+3A_simulatedresponse">simulatedResponse</code></td>
<td>
<p>matrix of observations simulated from the fitted model - row index for observations and colum index for simulations.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_observedresponse">observedResponse</code></td>
<td>
<p>true observations.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_fittedpredictedresponse">fittedPredictedResponse</code></td>
<td>
<p>optional fitted predicted response. For Bayesian posterior predictive simulations, using the median posterior prediction as fittedPredictedResponse is recommended. If not provided, the mean simulatedResponse will be used.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_integerresponse">integerResponse</code></td>
<td>
<p>if T, noise will be added at to the residuals to maintain a uniform expectations for integer responses (such as Poisson or Binomial). Unlike in <a href="#topic+simulateResiduals">simulateResiduals</a>, the nature of the data is not automatically detected, so this MUST be set by the user appropriately.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_seed">seed</code></td>
<td>
<p>the random seed to be used within DHARMa. The default setting, recommended for most users, is keep the random seed on a fixed value 123. This means that you will always get the same randomization and thus teh same result when running the same code. NULL = no new seed is set, but previous random state will be restored after simulation. FALSE = no seed is set, and random state will not be restored. The latter two options are only recommended for simulation experiments. See vignette for details.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_method">method</code></td>
<td>
<p>the quantile randomization method used. The two options implemented at the moment are probability integral transform (PIT-) residuals (current default), and the &quot;traditional&quot; randomization procedure, that was used in DHARMa until version 0.3.0. For details, see <a href="#topic+getQuantile">getQuantile</a>.</p>
</td></tr>
<tr><td><code id="createDHARMa_+3A_rotation">rotation</code></td>
<td>
<p>optional rotation of the residual space to remove residual autocorrelation. See details in <a href="#topic+simulateResiduals">simulateResiduals</a>, section <em>residual auto-correlation</em> for an extended explanation, and <a href="#topic+getQuantile">getQuantile</a> for syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of this function is to convert simulated residuals (e.g. from a point estimate, or Bayesian p-values) to a DHARMa object, to make use of the plotting / test functions in DHARMa.
</p>


<h3>Note</h3>

<p>Either scaled residuals or (simulatedResponse AND observed response) have to be provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## READING IN HAND-CODED SIMULATIONS

testData = createData(sampleSize = 50, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1, data = testData, family = "poisson")

# in DHARMA, using the simulate.glm function of glm 
sims = simulateResiduals(fittedModel)
plot(sims, quantreg = FALSE)

# Doing the same with a handcoded simulate function. 
# of course this code will only work with a 1-par glm model
simulateMyfit &lt;- function(n=10, fittedModel){
  int = coef(fittedModel)[1]
  slo = coef(fittedModel)[2]
  pred = exp(int + slo * testData$Environment1)
  predSim = replicate(n, rpois(length(pred), pred))
  return(predSim)
}

sims = simulateMyfit(250, fittedModel)

dharmaRes &lt;- createDHARMa(simulatedResponse = sims, 
                          observedResponse = testData$observedResponse, 
                          fittedPredictedResponse = predict(fittedModel, type = "response"), 
                          integer = TRUE)
plot(dharmaRes, quantreg = FALSE)
</code></pre>

<hr>
<h2 id='DHARMa.ecdf'>Modified ECDF function.</h2><span id='topic+DHARMa.ecdf'></span>

<h3>Description</h3>

<p>Modified ECDF function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DHARMa.ecdf(x)
</code></pre>


<h3>Details</h3>

<p>Ensures symmetric ECDF (standard ECDF is &lt;), and that 0 / 1 values are only produced if the data is strictly &lt; &gt; than the observed data.
</p>

<hr>
<h2 id='ensureDHARMa'>Ensures that an object is of class DHARMa</h2><span id='topic+ensureDHARMa'></span>

<h3>Description</h3>

<p>Ensures that an object is of class DHARMa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensureDHARMa(simulationOutput, convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensureDHARMa_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>a DHARMa simulation output or an object that can be converted into a DHARMa simulation output</p>
</td></tr>
<tr><td><code id="ensureDHARMa_+3A_convert">convert</code></td>
<td>
<p>if TRUE, attempts to convert model + numeric to DHARMa, if &quot;Model&quot;, converts only supported models to DHARMa</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The
</p>


<h3>Value</h3>

<p>an object of class DHARMa
</p>

<hr>
<h2 id='ensurePredictor'>Ensures the existence of a valid predictor to plot residuals against</h2><span id='topic+ensurePredictor'></span>

<h3>Description</h3>

<p>Ensures the existence of a valid predictor to plot residuals against
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensurePredictor(simulationOutput, predictor = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensurePredictor_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>A DHARMa simulation output or an object that can be converted into a DHARMa simulation output.</p>
</td></tr>
<tr><td><code id="ensurePredictor_+3A_predictor">predictor</code></td>
<td>
<p>An optional predictor. If no predictor is provided, will try to extract the fitted value.</p>
</td></tr>
</table>

<hr>
<h2 id='getFamily'>Get model family</h2><span id='topic+getFamily'></span><span id='topic+getFamily.default'></span><span id='topic+getFamily.phylolm'></span><span id='topic+getFamily.phyloglm'></span>

<h3>Description</h3>

<p>Wrapper to get the family of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFamily(object, ...)

## Default S3 method:
getFamily(object, ...)

## S3 method for class 'phylolm'
getFamily(object, ...)

## S3 method for class 'phyloglm'
getFamily(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFamily_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getFamily_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>, <a href="#topic+getFitted">getFitted</a>
</p>

<hr>
<h2 id='getFitted'>Get fitted/predicted values</h2><span id='topic+getFitted'></span><span id='topic+getFitted.default'></span><span id='topic+getFitted.gam'></span><span id='topic+getFitted.HLfit'></span><span id='topic+getFitted.MixMod'></span><span id='topic+getFitted.phylolm'></span><span id='topic+getFitted.phyloglm'></span>

<h3>Description</h3>

<p>Wrapper to get the fitted/predicted response of model at the response scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFitted(object, ...)

## Default S3 method:
getFitted(object, ...)

## S3 method for class 'gam'
getFitted(object, ...)

## S3 method for class 'HLfit'
getFitted(object, ...)

## S3 method for class 'MixMod'
getFitted(object, ...)

## S3 method for class 'phylolm'
getFitted(object, ...)

## S3 method for class 'phyloglm'
getFitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFitted_+3A_object">object</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="getFitted_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on, usually to the simulate function of the respective model class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this wrapper is to standardize extract the fitted values, which is implemented via predict(model, type = &quot;response&quot;) for most model classes.
</p>
<p>If you implement this function for a new model class, you should include an option to modifying which random effects (REs) are included in the predictions. If this option is not available, it is essential that predictions are provided marginally/unconditionally, i.e. without the RE estimates (because of https://github.com/florianhartig/DHARMa/issues/43), which corresponds to re-form = ~0 in lme4.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getFixedEffects'>Extract fixed effects of a supported model</h2><span id='topic+getFixedEffects'></span><span id='topic+getFixedEffects.default'></span><span id='topic+getFixedEffects.MixMod'></span>

<h3>Description</h3>

<p>A wrapper to extract fixed effects of a supported model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFixedEffects(object, ...)

## Default S3 method:
getFixedEffects(object, ...)

## S3 method for class 'MixMod'
getFixedEffects(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFixedEffects_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getFixedEffects_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFitted">getFitted</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getObservedResponse'>Get model response</h2><span id='topic+getObservedResponse'></span><span id='topic+getObservedResponse.default'></span><span id='topic+getObservedResponse.HLfit'></span><span id='topic+getObservedResponse.phylolm'></span><span id='topic+getObservedResponse.phyloglm'></span>

<h3>Description</h3>

<p>Extract the response of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObservedResponse(object, ...)

## Default S3 method:
getObservedResponse(object, ...)

## S3 method for class 'HLfit'
getObservedResponse(object, ...)

## S3 method for class 'phylolm'
getObservedResponse(object, ...)

## S3 method for class 'phyloglm'
getObservedResponse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getObservedResponse_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getObservedResponse_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to safely extract the observed response (dependent variable) of the fitted model classes.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getRefit">getRefit</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>, <a href="#topic+getFitted">getFitted</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getPearsonResiduals'>Get Pearson residuals</h2><span id='topic+getPearsonResiduals'></span><span id='topic+getPearsonResiduals.default'></span><span id='topic+getPearsonResiduals.gam'></span>

<h3>Description</h3>

<p>Wrapper to get the Pearson residuals of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPearsonResiduals(object, ...)

## Default S3 method:
getPearsonResiduals(object, ...)

## S3 method for class 'gam'
getPearsonResiduals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPearsonResiduals_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getPearsonResiduals_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on, usually to the residual function of the respective model class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this wrapper is to extract the Pearson residuals of a fitted model.
</p>
<p>This needed to be adopted because for some reason, mgcv uses the argument &quot;scaled.pearson&quot; for what most packags define as &quot;pearson&quot;. See comments in ?residuals.gam.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>, <a href="#topic+getFitted">getFitted</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getPossibleModels'>get possible models</h2><span id='topic+getPossibleModels'></span>

<h3>Description</h3>

<p>returns a list of supported model classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPossibleModels()
</code></pre>

<hr>
<h2 id='getQuantile'>Calculate Residual Quantiles</h2><span id='topic+getQuantile'></span>

<h3>Description</h3>

<p>Calculates residual quantiles from a given simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantile(simulations, observed, integerResponse, method = c("PIT",
  "traditional"), rotation = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getQuantile_+3A_simulations">simulations</code></td>
<td>
<p>A matrix with simulations from a fitted model. Rows = observations, columns = replicate simulations.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_observed">observed</code></td>
<td>
<p>A vector with the observed data.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_integerresponse">integerResponse</code></td>
<td>
<p>Is the response integer-valued? Only has an effect for method = &quot;traditional&quot;.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_method">method</code></td>
<td>
<p>The quantile randomization method used. See details.</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_rotation">rotation</code></td>
<td>
<p>Optional rotation of the residuals. You can either provide as a known or estimated covariance matrix (e.g. when fitting an AR1 model), or use the argument &quot;estimated&quot;, in which case the residual covariance will be approximated by simulations. See comments in details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates residual quantiles from the simulated data. For continuous distributions, this will simply be the value of the ecdf.
</p>
<p><strong>Randomization procedure for discrete data</strong>
</p>
<p>For discrete data, there are two options implemented.
</p>
<p>The current default (available since DHARMa 0.3.1) are probability integral transform (PIT-) residuals (Smith, 1985; Dunn &amp; Smyth, 1996; see also Warton, et al., 2017).
</p>
<p>Before DHARMa 0.3.1, a different randomization procedure was used, in which the a U(-0.5, 0.5) distribution was added on observations and simulations for discrete distributions. For a completely discrete distribution, the two procedures should deliver equivalent results, but the second method has the disadvantage that (a) one has to know if the distribution is discrete (DHARMa tries to recognize this automatically), and (b) that it leads to inefficiencies for some distributions such as the Tweedie, which are partly continuous, partly discrete
(see e.g. <a href="https://github.com/florianhartig/DHARMa/issues/168">issue #168</a> on DHARMa GitHub page).
</p>
<p><strong>Rotation (optional)</strong>
</p>
<p>The getQuantile function includes an additional option to rotate residuals prior to calculating the quantile residuals. This option should ONLY be used when the fitted model includes a particular residuals covariance structure, such as an AR1 or a spatial or phylogenetic CAR model.
</p>
<p>For these models, residuals calculated from unconditional simulations will include the specified covariance structure, which will trigger e.g. temporal autocorrelation tests and can inflate type I errors of other tests. The idea of the rotation is to rotate the residual space according to the covariance structure of the fitted model, such that the rotated residuals are conditional independent (provided the fitted model is correct).
</p>
<p>If the residual covariance of the fitted model at the response scale can be extracted (e.g. when fitting gls type models), it would be best to extract it and provide this covariance matrix to the rotation option. If that is not the case, providing the argument &quot;estimated&quot; to rotation will estimate the covariance from the data simulated by the model. This is probably without alternative for GLMMs, where the covariance at the response scale is likely not known / provided, but note, that this approximation will tend to have considerable error and may be slow to compute for high-dimensional data. If you try to estimate the rotation from simulations, you should set n as high as possible! See <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a> for a practical example.
</p>
<p>The rotation of residuals implemented here is similar to the Variogram.lme() and Variongram.gls() functions in nlme package using the argument resType = &quot;normalized&quot;.
</p>


<h3>References</h3>

<p>Smith, J. Q. &quot;Diagnostic checks of non-standard time series models.&quot; Journal of Forecasting 4.3 (1985): 283-291.
</p>
<p>Dunn, P.K., &amp; Smyth, G.K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics 5, 236-244.
</p>
<p>Warton, David I., Loïc Thibaut, and Yi Alice Wang. &quot;The PIT-trap—A “model-free” bootstrap procedure for inference about regression models with discrete, multivariate responses.&quot; PloS one 12.7 (2017).
</p>

<hr>
<h2 id='getRandomState'>Record and restore a random state</h2><span id='topic+getRandomState'></span>

<h3>Description</h3>

<p>The aim of this function is to record, manipulate and restore a random state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRandomState(seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRandomState_+3A_seed">seed</code></td>
<td>
<p>seed argument to set.seed(), typically a number. Additional options: NULL = no seed is set, but return includes function for restoring random seed. F = function does nothing, i.e. neither seed is changed, nor does the returned function do anything.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for two (not mutually exclusive tasks):
</p>
<p>a) record the current random state.
</p>
<p>b) change the current random state in a way that the previous state can be restored.
</p>


<h3>Value</h3>

<p>A list with various infos about the random state that after function execution, as well as a function to restore the previous state before the function execution.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(13)
runif(1)

# testing the function in standard settings
currentSeed = .Random.seed
x = getRandomState(123)
runif(1)
x$restoreCurrent()
all(.Random.seed == currentSeed)

# if no seed was set in env, this will also be restored

rm(.Random.seed) # now, there is no random seed
x = getRandomState(123)
exists(".Random.seed")  # TRUE
runif(1)
x$restoreCurrent()
exists(".Random.seed") # False
runif(1) # re-create a seed

# with seed = false 
currentSeed = .Random.seed
x = getRandomState(FALSE)
runif(1)
x$restoreCurrent()
all(.Random.seed == currentSeed)

# with seed = NULL 
currentSeed = .Random.seed
x = getRandomState(NULL)
runif(1)
x$restoreCurrent()
all(.Random.seed == currentSeed)
</code></pre>

<hr>
<h2 id='getRefit'>Get model refit</h2><span id='topic+getRefit'></span><span id='topic+getRefit.default'></span><span id='topic+getRefit.lm'></span><span id='topic+getRefit.glmmTMB'></span><span id='topic+getRefit.HLfit'></span><span id='topic+getRefit.MixMod'></span><span id='topic+getRefit.phylolm'></span><span id='topic+getRefit.phyloglm'></span>

<h3>Description</h3>

<p>Wrapper to refit a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRefit(object, newresp, ...)

## Default S3 method:
getRefit(object, newresp, ...)

## S3 method for class 'lm'
getRefit(object, newresp, ...)

## S3 method for class 'glmmTMB'
getRefit(object, newresp, ...)

## S3 method for class 'HLfit'
getRefit(object, newresp, ...)

## S3 method for class 'MixMod'
getRefit(object, newresp, ...)

## S3 method for class 'phylolm'
getRefit(object, newresp, ...)

## S3 method for class 'phyloglm'
getRefit(object, newresp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRefit_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getRefit_+3A_newresp">newresp</code></td>
<td>
<p>the new response that should be used to refit the model.</p>
</td></tr>
<tr><td><code id="getRefit_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to the refit or update class that is used to refit the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this wrapper is to standardize the refit of a model. The behavior of this function depends on the supplied model. When available, it uses the refit method, otherwise it will use update. For glmmTMB: since version 1.0, glmmTMB has a refit function, but this didn't work, so I switched back to this implementation, which is a hack based on the update function.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getResiduals'>Get model residuals</h2><span id='topic+getResiduals'></span><span id='topic+getResiduals.default'></span><span id='topic+getResiduals.MixMod'></span>

<h3>Description</h3>

<p>Wrapper to get the residuals of a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResiduals(object, ...)

## Default S3 method:
getResiduals(object, ...)

## S3 method for class 'MixMod'
getResiduals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getResiduals_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getResiduals_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on, usually to the residual function of the respective model class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this wrapper is to standardize the extraction of model residuals. Similar to some other functions, a key question is whether to calculate those conditional or unconditional on the fitted Random Effects.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getSimulations">getSimulations</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>, <a href="#topic+getFitted">getFitted</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='getSimulations'>Get model simulations</h2><span id='topic+getSimulations'></span><span id='topic+getSimulations.default'></span><span id='topic+getSimulations.negbin'></span><span id='topic+getSimulations.gam'></span><span id='topic+getSimulations.lmerMod'></span><span id='topic+getSimulations.glmmTMB'></span><span id='topic+getSimulations.HLfit'></span><span id='topic+getSimulations.MixMod'></span><span id='topic+getSimulations.phylolm'></span><span id='topic+getSimulations.phyloglm'></span>

<h3>Description</h3>

<p>Wrapper to simulate from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSimulations(object, nsim = 1, type = c("normal", "refit"), ...)

## Default S3 method:
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'negbin'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'gam'
getSimulations(object, nsim = 1, type = c("normal", "refit"),
  mgcViz = TRUE, ...)

## S3 method for class 'lmerMod'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'glmmTMB'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'HLfit'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'MixMod'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'phylolm'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)

## S3 method for class 'phyloglm'
getSimulations(object, nsim = 1, type = c("normal",
  "refit"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSimulations_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="getSimulations_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="getSimulations_+3A_type">type</code></td>
<td>
<p>if simulations should be prepared for getQuantile or for refit.</p>
</td></tr>
<tr><td><code id="getSimulations_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on, usually to the simulate function of the respective model class.</p>
</td></tr>
<tr><td><code id="getSimulations_+3A_mgcviz">mgcViz</code></td>
<td>
<p>whether simulations should be created with mgcViz (if mgcViz is available)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to wrap or implement the simulate function of different model classes and thus return simulations from fitted models in a standardized way.
</p>
<p>Note: GLMM and other regression packages often differ in how simulations are produced, and which parameters can be used to modify this behavior.
</p>
<p>One important difference is how to modifiy which hierarchical levels are held constant, and which are re-simulated. In lme4, this is controlled by the re.form argument (see <a href="lme4.html#topic+simulate.merMod">lme4::simulate.merMod</a>). In glmmTMB, the package version 1.1.10 has a temporary solution to simulate conditional to all random effects (see <a href="glmmTMB.html#topic+set_simcodes">glmmTMB::set_simcodes</a> val = &quot;fix&quot;, and issue <a href="https://github.com/glmmTMB/glmmTMB/issues/888">#888</a> in glmmTMB GitHub repository. For other packages, please consult the help.
</p>
<p>If the model was fit with weights and the respective model class does not include the weights in the simulations, getSimulations will throw a warning. The background is if weights are used on the likelihood directly, then what is fitted is effectively a pseudo likelihood, and there is no way to directly simulate from the specified likelihood. Whether or not residuals can be used in this case depends very much on what is tested and how weights are used. I'm sorry to say that it is hard to give a general recommendation, you have to consult someone that understands how weights are processed in the respective model class.
</p>


<h3>Value</h3>

<p>A matrix with simulations.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+getObservedResponse">getObservedResponse</a>, <a href="#topic+getRefit">getRefit</a>, <a href="#topic+getFixedEffects">getFixedEffects</a>, <a href="#topic+getFitted">getFitted</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 400, family = gaussian())

fittedModel &lt;- lm(observedResponse ~ Environment1 , data = testData)

# response that was used to fit the model
getObservedResponse(fittedModel)

# predictions of the model for these points
getFitted(fittedModel)

# extract simulations from the model as matrix
getSimulations(fittedModel, nsim = 2)

# extract simulations from the model for refit (often requires different structure)
x = getSimulations(fittedModel, nsim = 2, type = "refit")

getRefit(fittedModel, x[[1]])

getRefit(fittedModel, getObservedResponse(fittedModel))
</code></pre>

<hr>
<h2 id='hist.DHARMa'>Histogram of DHARMa residuals</h2><span id='topic+hist.DHARMa'></span>

<h3>Description</h3>

<p>The function produces a histogram from a DHARMa output. Outliers are marked red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DHARMa'
hist(x, breaks = seq(-0.02, 1.02, len = 53),
  col = c(.Options$DHARMaSignalColor, rep("lightgrey", 50),
  .Options$DHARMaSignalColor), main = "Hist of DHARMa residuals",
  xlab = "Residuals (outliers are marked red)", cex.main = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist.DHARMa_+3A_x">x</code></td>
<td>
<p>A DHARMa simulation output (class DHARMa)</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_breaks">breaks</code></td>
<td>
<p>Breaks for hist() function.</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_col">col</code></td>
<td>
<p>Color for histogram bars.</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_xlab">xlab</code></td>
<td>
<p>Plot x-axis label.</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_cex.main">cex.main</code></td>
<td>
<p>Plot cex.main.</p>
</td></tr>
<tr><td><code id="hist.DHARMa_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to hist().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls hist() to create a histogram of the scaled residuals. Outliers are marked red as default but it can be changed by setting <code>options(DHARMaSignalColor = "red")</code> to a different color. See <code>getOption("DHARMaSignalColor")</code> for the current setting.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotSimulatedResiduals">plotSimulatedResiduals</a>, <a href="#topic+plotResiduals">plotResiduals</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 200, family = poisson(), 
                      randomEffectVariance = 1, numGroups = 10)
fittedModel &lt;- glm(observedResponse ~ Environment1, 
                   family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

######### main plotting function #############

# for all functions, quantreg = T will be more
# informative, but slower

plot(simulationOutput, quantreg = FALSE)

#############  Distribution  ######################

plotQQunif(simulationOutput = simulationOutput, 
           testDispersion = FALSE,
           testUniformity = FALSE,
           testOutliers = FALSE)

hist(simulationOutput )

#############  residual plots  ###############

# rank transformation, using a simulationOutput
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE)

# smooth scatter plot - usually used for large datasets, default for n &gt; 10000
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE, smoothScatter = TRUE)

# residual vs predictors, using explicit values for pred, residual 
plotResiduals(simulationOutput, form = testData$Environment1, 
              quantreg = FALSE)

# if pred is a factor, or if asFactor = TRUE, will produce a boxplot
plotResiduals(simulationOutput, form = testData$group)

# to diagnose overdispersion and heteroskedasticity it can be useful to 
# display residuals as absolute deviation from the expected mean 0.5
plotResiduals(simulationOutput, absoluteDeviation = TRUE, quantreg = FALSE)

# All these options can also be provided to the main plotting function

# If you want to plot summaries per group, use
simulationOutput = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput, quantreg = FALSE) 
# we see one residual point per RE


</code></pre>

<hr>
<h2 id='hurricanes'>Hurricanes</h2><span id='topic+hurricanes'></span>

<h3>Description</h3>

<p>A data set on hurricane strength and fatalities in the US between 1950 and 2012. The data originates from the study by Jung et al., PNAS, 2014, who claim that the masculinity / femininity of a hurricane name has a causal effect on fatalities, presumably through a different perception of danger caused by the names.
</p>


<h3>Format</h3>

<p>A 'data.frame': 92 obs. of  14 variables
</p>

<dl>
<dt>Year</dt><dd><p>Year of the hurricane (1950-2012) </p>
</dd>
<dt>Name</dt><dd><p>Name of the hurricane </p>
</dd>
<dt>MasFem</dt><dd><p>Masculinity-femininity rating of the hurricane's name in the range 1 = very masculine, 11 = very feminine.</p>
</dd>
<dt>MinPressure_before</dt><dd><p>Minimum air pressure (909-1002).</p>
</dd>
<dt>Minpressure_Updated_2014</dt><dd><p>Updated minimum air pressure (909-1003).</p>
</dd>
<dt>Gender_MF</dt><dd><p>Binary gender categorization based on MasFem (male = 0, female = 1).</p>
</dd>
<dt>Category</dt><dd><p>Strength of the hurricane in categories (1:7). (1 = not at all, 7 = very intense).</p>
</dd>
<dt>alldeaths</dt><dd><p>Human deaths occured (1:256).</p>
</dd>
<dt>NDAM</dt><dd><p>Normalized damage in millions (1:75.000). The raw (dollar) amounts of property damage caused by hurricanes were obtained, and the unadjusted dollar amounts were normalized to 2013 monetary values by adjusting them to inflation, wealth and population density.</p>
</dd>
<dt>Elapsed_Yrs</dt><dd><p>Elapsed years since the occurrence of hurricanes (1:63).</p>
</dd>
<dt>Source</dt><dd><p>MWR/wikipedia ()</p>
</dd>
<dt>ZMasFem</dt><dd><p>Scaled (MasFem)</p>
</dd>
<dt>ZMinPressure_A</dt><dd><p>Scaled (Minpressure_Updated_2014)</p>
</dd>
<dt>ZNDAM</dt><dd><p>Scaled (NDAM)</p>
</dd>
</dl>
<p>...

</p>


<h3>References</h3>

<p>Jung, K., Shavitt, S., Viswanathan, M., &amp; Hilbe, J. M. (2014). Female hurricanes are deadlier than male hurricanes. Proceedings of the National Academy of Sciences, 111(24), 8782-8787.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loading hurricanes dataset

library(DHARMa)

data(hurricanes)
str(hurricanes)

# this is the model fit by Jung et al.
library(glmmTMB)
originalModelGAM = glmmTMB(alldeaths ~ scale(MasFem) *
                             (scale(Minpressure_Updated_2014) + scale(NDAM)),
                           data = hurricanes, family = nbinom2)

# no significant deviation in the general DHARMa plot
res &lt;- simulateResiduals(originalModelGAM)
plot(res)

# but residuals ~ NDAM looks funny, which was pointed 
# out by Bob O'Hara in a blog post after publication of the paper
plotResiduals(res, hurricanes$NDAM)

# we also find temporal autocorrelation
res2 = recalculateResiduals(res, group = hurricanes$Year)
testTemporalAutocorrelation(res2, time = unique(hurricanes$Year))

# task: try to address these issues - in many instances, this will 
# make the MasFem predictor n.s.

## End(Not run)
</code></pre>

<hr>
<h2 id='outliers'>Return outliers</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p>Returns the outliers of a DHARMa object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(object, lowerQuantile = 0, upperQuantile = 1,
  return = c("index", "logical"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outliers_+3A_object">object</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a>.</p>
</td></tr>
<tr><td><code id="outliers_+3A_lowerquantile">lowerQuantile</code></td>
<td>
<p>lower threshold for outliers. Default is zero = outside simulation envelope.</p>
</td></tr>
<tr><td><code id="outliers_+3A_upperquantile">upperQuantile</code></td>
<td>
<p>upper threshold for outliers. Default is 1 = outside simulation envelope.</p>
</td></tr>
<tr><td><code id="outliers_+3A_return">return</code></td>
<td>
<p>wheter to return an indices of outliers or a logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First of all, note that the standard definition of outlier in the DHARMa plots and outlier tests is an observation that is outside the simulation envelope. How far outside that is depends a lot on how many simulations you do. If you have 100 data points and to 100 simulations, you would expect to have one &quot;outlier&quot; on average, even with a perfectly fitting model. This is in fact what the outlier test tests.
</p>
<p>Thus, keep in mind that for a small number of simulations, outliers are mostly a technical term: these are points that are outside our simulations, but we don't know how far away they are.
</p>
<p>If you are seriously interested in HOW FAR outside the expected distribution a data point is, you should increase the number of simulations in <a href="#topic+simulateResiduals">simulateResiduals</a> to be sure to get the tail of the data distribution correctly. In this case, it may make sense to adjust lowerQuantile and upperQuantile, e.g. to 0.025, 0.975, which would define outliers as values outside the central 95% of the distribution.
</p>
<p>Also, note that outliers are particularly concerning if they have a strong influence on the model fit. One could test the influence, for example, by removing them from the data, or by some meausures of leverage, e.g. generalisations for Cook's distance as in Pinho, L. G. B., Nobre, J. S., &amp; Singer, J. M. (2015). Cook’s distance for generalized linear mixed models. Computational Statistics &amp; Data Analysis, 82, 126–136. doi:10.1016/j.csda.2014.08.008. At the moment, however, no such function is provided in DHARMa.
</p>

<hr>
<h2 id='plot.DHARMa'>DHARMa standard residual plots</h2><span id='topic+plot.DHARMa'></span>

<h3>Description</h3>

<p>This S3 function creates standard plots for the simulated residuals contained in an object of class DHARMa, using <a href="#topic+plotQQunif">plotQQunif</a> (left panel) and <a href="#topic+plotResiduals">plotResiduals</a> (right panel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DHARMa'
plot(x, title = "DHARMa residual", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.DHARMa_+3A_x">x</code></td>
<td>
<p>An object of class DHARMa with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a>.</p>
</td></tr>
<tr><td><code id="plot.DHARMa_+3A_title">title</code></td>
<td>
<p>The title for both panels (plotted via mtext, outer = TRUE).</p>
</td></tr>
<tr><td><code id="plot.DHARMa_+3A_...">...</code></td>
<td>
<p>Further options for <a href="#topic+plotResiduals">plotResiduals</a>. Consider in particular parameters quantreg, rank and asFactor. xlab, ylab and main cannot be changed when using plot.DHARMa, but can be changed when using <a href="#topic+plotResiduals">plotResiduals</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a plot with two panels. The left panel is a uniform qq plot (calling <a href="#topic+plotQQunif">plotQQunif</a>), and the right panel shows residuals against predicted values (calling <a href="#topic+plotResiduals">plotResiduals</a>), with outliers highlighted in red (default color but see Note).
</p>
<p>Very briefly, we would expect that a correctly specified model shows:
</p>
<p>a) a straight 1-1 line, as well as non-significance of the displayed tests in the qq-plot (left) -&gt; evidence for an the correct overall residual distribution (for more details on the interpretation of this plot, see <a href="#topic+plotQQunif">plotQQunif</a>)
</p>
<p>b) visual homogeneity of residuals in both vertical and horizontal direction, as well as n.s. of quantile tests in the res ~ predictor plot (for more details on the interpretation of this plot, see <a href="#topic+plotResiduals">plotResiduals</a>)
</p>
<p>Deviations from these expectations can be interpreted similar to a linear regression. See the vignette for detailed examples.
</p>
<p>Note that, unlike <a href="#topic+plotResiduals">plotResiduals</a>, plot.DHARMa command uses the default rank = T.
</p>


<h3>Note</h3>

<p>The color for highlighting outliers and significant tests can be changed by setting <code>options(DHARMaSignalColor = "red")</code> to a different color. See <code>getOption("DHARMaSignalColor")</code> for the current setting. This is convenient for a color-blind friendly display, since red and black are difficult for some people to separate.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotResiduals">plotResiduals</a>, <a href="#topic+plotQQunif">plotQQunif</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 200, family = poisson(), 
                      randomEffectVariance = 1, numGroups = 10)
fittedModel &lt;- glm(observedResponse ~ Environment1, 
                   family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

######### main plotting function #############

# for all functions, quantreg = T will be more
# informative, but slower

plot(simulationOutput, quantreg = FALSE)

#############  Distribution  ######################

plotQQunif(simulationOutput = simulationOutput, 
           testDispersion = FALSE,
           testUniformity = FALSE,
           testOutliers = FALSE)

hist(simulationOutput )

#############  residual plots  ###############

# rank transformation, using a simulationOutput
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE)

# smooth scatter plot - usually used for large datasets, default for n &gt; 10000
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE, smoothScatter = TRUE)

# residual vs predictors, using explicit values for pred, residual 
plotResiduals(simulationOutput, form = testData$Environment1, 
              quantreg = FALSE)

# if pred is a factor, or if asFactor = TRUE, will produce a boxplot
plotResiduals(simulationOutput, form = testData$group)

# to diagnose overdispersion and heteroskedasticity it can be useful to 
# display residuals as absolute deviation from the expected mean 0.5
plotResiduals(simulationOutput, absoluteDeviation = TRUE, quantreg = FALSE)

# All these options can also be provided to the main plotting function

# If you want to plot summaries per group, use
simulationOutput = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput, quantreg = FALSE) 
# we see one residual point per RE


</code></pre>

<hr>
<h2 id='plot.DHARMaBenchmark'>Plots DHARMa benchmarks</h2><span id='topic+plot.DHARMaBenchmark'></span>

<h3>Description</h3>

<p>The function plots the result of an object of class DHARMaBenchmark, created by <a href="#topic+runBenchmarks">runBenchmarks</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DHARMaBenchmark'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.DHARMaBenchmark_+3A_x">x</code></td>
<td>
<p>object of class DHARMaBenchmark, created by <a href="#topic+runBenchmarks">runBenchmarks</a>.</p>
</td></tr>
<tr><td><code id="plot.DHARMaBenchmark_+3A_...">...</code></td>
<td>
<p>parameters to pass to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will create two types of plots, depending on whether the run contains only a single value (or no value) of the control parameter, or whether a vector of control values is provided:
</p>
<p>If a single or no value of the control parameter is provided, the function will create box plots of the estimated p-values, with the number of significant p-values plotted to the left.
</p>
<p>If a control parameter is provided, the function will plot the proportion of significant p-values against the control parameter, with 95% CIs based based on the performed replicates displayed as confidence bands.
</p>


<h3>See Also</h3>

<p><a href="#topic+runBenchmarks">runBenchmarks</a>
</p>

<hr>
<h2 id='plotConventionalResiduals'>Conventional residual plot</h2><span id='topic+plotConventionalResiduals'></span>

<h3>Description</h3>

<p>Convenience function to draw conventional residual plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConventionalResiduals(fittedModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConventionalResiduals_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
</table>

<hr>
<h2 id='plotQQunif'>Quantile-quantile plot for a uniform distribution</h2><span id='topic+plotQQunif'></span>

<h3>Description</h3>

<p>The function produces a uniform quantile-quantile plot from a DHARMa output. Optionally, tests for uniformity, outliers and dispersion can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQQunif(simulationOutput, testUniformity = TRUE, testOutliers = TRUE,
  testDispersion = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotQQunif_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>A DHARMa simulation output (class DHARMa).</p>
</td></tr>
<tr><td><code id="plotQQunif_+3A_testuniformity">testUniformity</code></td>
<td>
<p>If T, the function <a href="#topic+testUniformity">testUniformity</a> will be called and the result will be added to the plot.</p>
</td></tr>
<tr><td><code id="plotQQunif_+3A_testoutliers">testOutliers</code></td>
<td>
<p>If T, the function <a href="#topic+testOutliers">testOutliers</a> will be called and the result will be added to the plot.</p>
</td></tr>
<tr><td><code id="plotQQunif_+3A_testdispersion">testDispersion</code></td>
<td>
<p>If T, the function <a href="#topic+testDispersion">testDispersion</a> will be called and the result will be added to the plot.</p>
</td></tr>
<tr><td><code id="plotQQunif_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <a href="gap.html#topic+qqunif">gap::qqunif</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls qqunif() from the R package gap to create a quantile-quantile plot for a uniform distribution, and overlays tests for particular distributional problems as specified.
When tests are displayed, significant p-values are highlighted in the color red by default. This can be changed by setting <code>options(DHARMaSignalColor = "red")</code> to a different color. See <code>getOption("DHARMaSignalColor")</code> for the current setting.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotSimulatedResiduals">plotSimulatedResiduals</a>, <a href="#topic+plotResiduals">plotResiduals</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 200, family = poisson(), 
                      randomEffectVariance = 1, numGroups = 10)
fittedModel &lt;- glm(observedResponse ~ Environment1, 
                   family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

######### main plotting function #############

# for all functions, quantreg = T will be more
# informative, but slower

plot(simulationOutput, quantreg = FALSE)

#############  Distribution  ######################

plotQQunif(simulationOutput = simulationOutput, 
           testDispersion = FALSE,
           testUniformity = FALSE,
           testOutliers = FALSE)

hist(simulationOutput )

#############  residual plots  ###############

# rank transformation, using a simulationOutput
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE)

# smooth scatter plot - usually used for large datasets, default for n &gt; 10000
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE, smoothScatter = TRUE)

# residual vs predictors, using explicit values for pred, residual 
plotResiduals(simulationOutput, form = testData$Environment1, 
              quantreg = FALSE)

# if pred is a factor, or if asFactor = TRUE, will produce a boxplot
plotResiduals(simulationOutput, form = testData$group)

# to diagnose overdispersion and heteroskedasticity it can be useful to 
# display residuals as absolute deviation from the expected mean 0.5
plotResiduals(simulationOutput, absoluteDeviation = TRUE, quantreg = FALSE)

# All these options can also be provided to the main plotting function

# If you want to plot summaries per group, use
simulationOutput = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput, quantreg = FALSE) 
# we see one residual point per RE


</code></pre>

<hr>
<h2 id='plotResiduals'>Generic res ~ pred scatter plot with spline or quantile regression on top</h2><span id='topic+plotResiduals'></span>

<h3>Description</h3>

<p>The function creates a generic residual plot with either spline or quantile regression to highlight patterns in the residuals. Outliers are highlighted in red by default (but see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResiduals(simulationOutput, form = NULL, quantreg = NULL,
  rank = TRUE, asFactor = NULL, smoothScatter = NULL,
  quantiles = c(0.25, 0.5, 0.75), absoluteDeviation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotResiduals_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>An object, usually a DHARMa object, from which residual values can be extracted. Alternatively, a vector with residuals or a fitted model can be provided, which will then be transformed into a DHARMa object.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_form">form</code></td>
<td>
<p>Optional predictor against which the residuals should be plotted. Default is to used the predicted(simulationOutput).</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_quantreg">quantreg</code></td>
<td>
<p>Whether to perform a quantile regression based on <a href="#topic+testQuantiles">testQuantiles</a> or a smooth spline around the mean. Default NULL chooses T for nObs &lt; 2000, and F otherwise.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_rank">rank</code></td>
<td>
<p>If T, the values provided in form will be rank transformed. This will usually make patterns easier to spot visually, especially if the distribution of the predictor is skewed. If form is a factor, this has no effect.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_asfactor">asFactor</code></td>
<td>
<p>Should a numeric predictor provided in form be treated as a factor. Default is to choose this for &lt; 10 unique values, as long as enough predictions are available to draw a boxplot.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_smoothscatter">smoothScatter</code></td>
<td>
<p>if T, a smooth scatter plot will plotted instead of a normal scatter plot. This makes sense when the number of residuals is very large. Default NULL chooses T for nObs &gt; 10000, and F otherwise.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_quantiles">quantiles</code></td>
<td>
<p>For a quantile regression, which quantiles should be plotted. Default is 0.25, 0.5, 0.75.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_absolutedeviation">absoluteDeviation</code></td>
<td>
<p>If T, switch from displaying normal quantile residuals to absolute deviation from the mean expectation of 0.5 (calculated as 2 * abs(res - 0.5)). The purpose of this is to test explicitly for heteroskedasticity, see details.</p>
</td></tr>
<tr><td><code id="plotResiduals_+3A_...">...</code></td>
<td>
<p>Additional arguments to plot / boxplot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots residuals against a predictor (by default against the fitted value, extracted from the DHARMa object, or any other predictor).
</p>
<p>Outliers are highlighted in red as default (for information on definition and interpretation of outliers, see <a href="#topic+testOutliers">testOutliers</a>). This can be changed by setting <code>options(DHARMaSignalColor = "red")</code> to a different color. See <code>getOption("DHARMaSignalColor")</code> for the current setting.
</p>
<p>To provide a visual aid for detecting deviations from uniformity in the y-direction, the plot function calculates an (optional) quantile regression of the residuals, by default for the 0.25, 0.5 and 0.75 quantiles. Since the residuals should be uniformly distributed for a correctly specified model, the theoretical expectations for these regressions are straight lines at 0.25, 0.5 and 0.75, shown as dashed black lines on the plot. However, even for a perfect model, some deviation from these expectations is to be expected by chance, especially if the sample size is small. The function therefore tests whether the deviation of the fitted quantile regression from the expectation is significant, using <a href="#topic+testQuantiles">testQuantiles</a>. If so, the significant quantile regression is highlighted in red (as default) and a warning is displayed in the plot.
</p>
<p>Overdispersion typically manifests itself as Q1 (0.25) deviating towards 0 and Q3 (0.75) deviating towards 1. Heteroskedasticity manifests itself as non-parallel quantile lines. To diagnose heteroskedasticity and overdispersion, it can be helpful to additionally plot the absolute deviation of the residuals from the mean expectation of 0.5, using the option absoluteDeviation = T. In this case, we would again expect Q1-Q3 quantile lines at 0.25, 0.5, 0.75, but greater dispersion (also locally in the case of heteroskedasticity) always manifests itself in deviations towards 1.
</p>
<p>The quantile regression can take some time to calculate, especially for larger data sets. For this reason, quantreg = F can be set to generate a smooth spline instead. This is the default for n &gt; 2000.
</p>
<p>If form is a factor, a boxplot will be plotted instead of a scatter plot. The distribution for each factor level should be uniformly distributed, so the box should go from 0.25 to 0.75, with the median line at 0.5 (within-group). To test if deviations from those expecations are significant, KS-tests per group and a Levene test for homogeneity of variances is performed. See <a href="#topic+testCategorical">testCategorical</a> for details.
</p>


<h3>Value</h3>

<p>If quantile tests are performed, the function returns them invisibly.
</p>


<h3>Note</h3>

<p>If nObs &gt; 10000, the scatter plot is replaced by graphics::smoothScatter
</p>
<p>#' @note The color for highlighting outliers and quantile lines/splines with significant tests can be changed by setting <code>options(DHARMaSignalColor = "red")</code> to a different color. See <code>getOption("DHARMaSignalColor")</code> for the current setting. This is convenient for a color-blind friendly display, since red and black are difficult for some people to separate.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotQQunif">plotQQunif</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testOutliers">testOutliers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 200, family = poisson(), 
                      randomEffectVariance = 1, numGroups = 10)
fittedModel &lt;- glm(observedResponse ~ Environment1, 
                   family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

######### main plotting function #############

# for all functions, quantreg = T will be more
# informative, but slower

plot(simulationOutput, quantreg = FALSE)

#############  Distribution  ######################

plotQQunif(simulationOutput = simulationOutput, 
           testDispersion = FALSE,
           testUniformity = FALSE,
           testOutliers = FALSE)

hist(simulationOutput )

#############  residual plots  ###############

# rank transformation, using a simulationOutput
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE)

# smooth scatter plot - usually used for large datasets, default for n &gt; 10000
plotResiduals(simulationOutput, rank = TRUE, quantreg = FALSE, smoothScatter = TRUE)

# residual vs predictors, using explicit values for pred, residual 
plotResiduals(simulationOutput, form = testData$Environment1, 
              quantreg = FALSE)

# if pred is a factor, or if asFactor = TRUE, will produce a boxplot
plotResiduals(simulationOutput, form = testData$group)

# to diagnose overdispersion and heteroskedasticity it can be useful to 
# display residuals as absolute deviation from the expected mean 0.5
plotResiduals(simulationOutput, absoluteDeviation = TRUE, quantreg = FALSE)

# All these options can also be provided to the main plotting function

# If you want to plot summaries per group, use
simulationOutput = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput, quantreg = FALSE) 
# we see one residual point per RE


</code></pre>

<hr>
<h2 id='plotSimulatedResiduals'>DHARMa standard residual plots</h2><span id='topic+plotSimulatedResiduals'></span>

<h3>Description</h3>

<p>DEPRECATED, use plot() instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSimulatedResiduals(simulationOutput, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSimulatedResiduals_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a></p>
</td></tr>
<tr><td><code id="plotSimulatedResiduals_+3A_...">...</code></td>
<td>
<p>further options for <a href="#topic+plotResiduals">plotResiduals</a>. Consider in particular parameters quantreg, rank and asFactor. xlab, ylab and main cannot be changed when using plotSimulatedResiduals, but can be changed when using plotResiduals.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is deprecated. Use <a href="#topic+plot.DHARMa">plot.DHARMa</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+plotResiduals">plotResiduals</a>, <a href="#topic+plotQQunif">plotQQunif</a>
</p>

<hr>
<h2 id='print.DHARMa'>Print simulated residuals</h2><span id='topic+print.DHARMa'></span>

<h3>Description</h3>

<p>Print simulated residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DHARMa'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DHARMa_+3A_x">x</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a>.</p>
</td></tr>
<tr><td><code id="print.DHARMa_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='recalculateResiduals'>Recalculate residuals with grouping</h2><span id='topic+recalculateResiduals'></span>

<h3>Description</h3>

<p>The purpose of this function is to recalculate scaled residuals per group, based on the simulations done by <a href="#topic+simulateResiduals">simulateResiduals</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalculateResiduals(simulationOutput, group = NULL, aggregateBy = sum,
  sel = NULL, seed = 123, method = c("PIT", "traditional"),
  rotation = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recalculateResiduals_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a>.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_group">group</code></td>
<td>
<p>group of each data point.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_aggregateby">aggregateBy</code></td>
<td>
<p>function for the aggregation. Default is sum. This should only be changed if you know what you are doing. Note in particular that the expected residual distribution might not be flat any more if you choose general functions, such as sd etc.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_sel">sel</code></td>
<td>
<p>an optional vector for selecting the data to be aggregated.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_seed">seed</code></td>
<td>
<p>the random seed to be used within DHARMa. The default setting, recommended for most users, is keep the random seed on a fixed value 123. This means that you will always get the same randomization and thus teh same result when running the same code. NULL = no new seed is set, but previous random state will be restored after simulation. FALSE = no seed is set, and random state will not be restored. The latter two options are only recommended for simulation experiments. See vignette for details.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_method">method</code></td>
<td>
<p>the quantile randomization method used. The two options implemented at the moment are probability integral transform (PIT-) residuals (current default), and the &quot;traditional&quot; randomization procedure, that was used in DHARMa until version 0.3.0. For details, see <a href="#topic+getQuantile">getQuantile</a>.</p>
</td></tr>
<tr><td><code id="recalculateResiduals_+3A_rotation">rotation</code></td>
<td>
<p>optional rotation of the residual space to remove residual autocorrelation. See details in <a href="#topic+simulateResiduals">simulateResiduals</a>, section <em>residual auto-correlation</em> for an extended explanation, and <a href="#topic+getQuantile">getQuantile</a> for syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function aggregates the observed and simulated data per group according to the function provided by the aggregateBy option. DHARMa residuals are then calculated exactly as for a single data point (see <a href="#topic+getQuantile">getQuantile</a> for details).
</p>


<h3>Value</h3>

<p>an object of class DHARMa, similar to what is returned by <a href="#topic+simulateResiduals">simulateResiduals</a>, but with additional outputs for the new grouped calculations. Note that the relevant outputs are 2x in the object, the first is the grouped calculations (which is returned by $name access), and later another time, under identical name, the original output. Moreover, there is a function 'aggregateByGroup', which can be used to aggregate predictor variables in the same way as the variables calculated here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lme4)

testData = createData(sampleSize = 100, overdispersion = 0.5, family = poisson())
fittedModel &lt;- glmer(observedResponse ~ Environment1 + (1|group), 
                     family = "poisson", data = testData)

simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# standard plot 
plot(simulationOutput)

# one of the possible test, for other options see ?testResiduals / vignette
testDispersion(simulationOutput)

# the calculated residuals can be accessed via 
residuals(simulationOutput)

# transform residuals to other pdf, see ?residuals.DHARMa for details
residuals(simulationOutput, quantileFunction = qnorm, outlierValues = c(-7,7))

# get residuals that are outside the simulation envelope
outliers(simulationOutput)

# calculating aggregated residuals per group
simulationOutput2 = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput2, quantreg = FALSE)

# calculating residuals only for subset of the data
simulationOutput3 = recalculateResiduals(simulationOutput, sel = testData$group == 1 )
plot(simulationOutput3, quantreg = FALSE)
</code></pre>

<hr>
<h2 id='residuals.DHARMa'>Return residuals of a DHARMa simulation</h2><span id='topic+residuals.DHARMa'></span>

<h3>Description</h3>

<p>Return residuals of a DHARMa simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DHARMa'
residuals(object, quantileFunction = NULL,
  outlierValues = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.DHARMa_+3A_object">object</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a></p>
</td></tr>
<tr><td><code id="residuals.DHARMa_+3A_quantilefunction">quantileFunction</code></td>
<td>
<p>optional - a quantile function to transform the uniform 0/1 scaling of DHARMa to another distribution</p>
</td></tr>
<tr><td><code id="residuals.DHARMa_+3A_outliervalues">outlierValues</code></td>
<td>
<p>if a quantile function with infinite support (such as dnorm) is used, residuals that are 0/1 are mapped to -Inf / Inf. outlierValues allows to convert -Inf / Inf values to an optional min / max value.</p>
</td></tr>
<tr><td><code id="residuals.DHARMa_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function accesses the slot $scaledResiduals in a fitted DHARMa object, and optionally transforms the standard DHARMa quantile residuals (which have a uniform distribution) to a particular pdf.
</p>


<h3>Note</h3>

<p>some of the papers on simulated quantile residuals transforming the residuals (which are natively uniform) back to a normal distribution. I presume this is because of the larger familiarity of most users with normal residuals. Personally, I never considered this desirable, for the reasons explained in https://github.com/florianhartig/DHARMa/issues/39, but with this function, I wanted to give users the option to plot normal residuals if they so wish.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lme4)

testData = createData(sampleSize = 100, overdispersion = 0.5, family = poisson())
fittedModel &lt;- glmer(observedResponse ~ Environment1 + (1|group), 
                     family = "poisson", data = testData)

simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# standard plot 
plot(simulationOutput)

# one of the possible test, for other options see ?testResiduals / vignette
testDispersion(simulationOutput)

# the calculated residuals can be accessed via 
residuals(simulationOutput)

# transform residuals to other pdf, see ?residuals.DHARMa for details
residuals(simulationOutput, quantileFunction = qnorm, outlierValues = c(-7,7))

# get residuals that are outside the simulation envelope
outliers(simulationOutput)

# calculating aggregated residuals per group
simulationOutput2 = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput2, quantreg = FALSE)

# calculating residuals only for subset of the data
simulationOutput3 = recalculateResiduals(simulationOutput, sel = testData$group == 1 )
plot(simulationOutput3, quantreg = FALSE)
</code></pre>

<hr>
<h2 id='runBenchmarks'>Benchmark calculations</h2><span id='topic+runBenchmarks'></span>

<h3>Description</h3>

<p>This function runs statistical benchmarks, including Power / Type I error simulations for an arbitrary test with a control parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runBenchmarks(calculateStatistics, controlValues = NULL, nRep = 10,
  alpha = 0.05, parallel = FALSE, exportGlobal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runBenchmarks_+3A_calculatestatistics">calculateStatistics</code></td>
<td>
<p>the statistics to be benchmarked. Should return one value, or a vector of values. If controlValues are given, must accept a parameter control</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_controlvalues">controlValues</code></td>
<td>
<p>optionally, a vector with a control parameter (e.g. to vary the strength of a problem the test should be specific to). See help for an example</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_nrep">nRep</code></td>
<td>
<p>number of replicates per level of the controlValues</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_parallel">parallel</code></td>
<td>
<p>whether to use parallel computations. Possible values are F, T (sets the cores automatically to number of available cores -1), or an integer number for the number of cores that should be used for the cluster</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_exportglobal">exportGlobal</code></td>
<td>
<p>whether the global environment should be exported to the parallel nodes. This will use more memory. Set to true only if you function calculate statistics depends on other functions or global variables.</p>
</td></tr>
<tr><td><code id="runBenchmarks_+3A_...">...</code></td>
<td>
<p>additional parameters to calculateStatistics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object with list structure of class DHARMaBenchmark. Contains an entry simulations with a matrix of simulations, and an entry summaries with an list of summaries (significant (T/F), mean, p-value for KS-test uniformity). Can be plotted with <a href="#topic+plot.DHARMaBenchmark">plot.DHARMaBenchmark</a>
</p>


<h3>Note</h3>

<p>The benchmark function in DHARMa are intended for development purposes, and for users that want to test / confirm the properties of functions in DHARMa. If you are running an applied data analysis, they are probably of little use.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.DHARMaBenchmark">plot.DHARMaBenchmark</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a function that will run a simulation and return a number of statistics, typically p-values
returnStatistics &lt;- function(control = 0){
  testData = createData(sampleSize = 20, family = poisson(), overdispersion = control,
                        randomEffectVariance = 0)
  fittedModel &lt;- glm(observedResponse ~ Environment1, data = testData, family = poisson())
  res &lt;- simulateResiduals(fittedModel = fittedModel, n = 250)
  out &lt;- c(testUniformity(res, plot = FALSE)$p.value, testDispersion(res, plot = FALSE)$p.value)
  return(out)
}

# testing a single return
returnStatistics()

# running benchmark for a fixed simulation, increase nRep for sensible results
out = runBenchmarks(returnStatistics, nRep = 5)

# plotting results depend on whether a vector or a single value is provided for control
plot(out)

## Not run: 

# running benchmark with varying control values
out = runBenchmarks(returnStatistics, controlValues = c(0,0.5,1), nRep = 100)
plot(out)

# running benchmark can be done using parallel cores
out = runBenchmarks(returnStatistics, nRep = 100, parallel = TRUE)
out = runBenchmarks(returnStatistics, controlValues = c(0,0.5,1), nRep = 10, parallel = TRUE)

# Alternative plot function using vioplot, provides nicer pictures

plot.DHARMaBenchmark &lt;- function(x, ...){

  if(length(x$controlValues)== 1){
    vioplot::vioplot(x$simulations[,x$nSummaries:1], las = 2, horizontal = TRUE, side = "right",
                     areaEqual = FALSE,
                     main = "p distribution under H0",
                     ylim = c(-0.15,1), ...)
    abline(v = 1, lty = 2)
    abline(v = c(0.05, 0), lty = 2, col = "red")
    text(-0.1, x$nSummaries:1, labels = x$summaries$propSignificant[-1])

  }else{
    res = x$summaries$propSignificant
    matplot(res$controlValues, res[,-1], type = "l",
            main = "Power analysis", ylab = "Power", ...)
    legend("bottomright", colnames(res[,-1]),
            col = 1:x$nSummaries, lty = 1:x$nSummaries, lwd = 2)

  }
}


## End(Not run)
</code></pre>

<hr>
<h2 id='simulateLRT'>Simulated likelihood ratio tests for (generalized) linear mixed models</h2><span id='topic+simulateLRT'></span>

<h3>Description</h3>

<p>This function uses the DHARMa model wrappers to generate simulated likelihood ratio tests (LRTs) for (generalized) linear mixed models based on a parametric bootstrap. The motivation for using a simulated LRT rather than a standard ANOVA or AIC for model selection in mixed models is that df for mixed models are not clearly defined, thus standard ANOVA based on Chi2 statistics or AIC are unreliable, in particular for models with large contributions of REs to the likelihood.
</p>
<p>Interpretation of the results as in a normal LRT: the null hypothesis is that m0 is correct, the tests checks if the increase in likelihood of m1 is higher than expected, using data simulated from m0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateLRT(m0, m1, n = 250, seed = 123, plot = TRUE,
  suppressWarnings = TRUE, saveModels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateLRT_+3A_m0">m0</code></td>
<td>
<p>null Model.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_m1">m1</code></td>
<td>
<p>alternative Model.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_n">n</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_seed">seed</code></td>
<td>
<p>random seed.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_plot">plot</code></td>
<td>
<p>whether null distribution should be plotted.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>whether to suppress warnings that occur during refitting the models to simulated data. See details for explanations.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_savemodels">saveModels</code></td>
<td>
<p>Whether to save refitted models.</p>
</td></tr>
<tr><td><code id="simulateLRT_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to the simulate function of the model object. See <a href="#topic+getSimulations">getSimulations</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs a simulated LRT, which works as follows:
</p>

<ol>
<li><p> H0: Model 1 is correct.
</p>
</li>
<li><p> Our test statistic is the log LRT of M1/M2. Empirical value will always be &gt; 1 because in a nested setting, the more complex model cannot have a worse likelihood.
</p>
</li>
<li><p> To generate an expected distribution of the test statistic under H0, we simulate new response data under M0, refit M0 and M1 on this data, and calculate the LRs.
</p>
</li>
<li><p> Based on this, calculate p-values etc. in the usual way.
</p>
</li></ol>

<p>About warnings: warnings such as &quot;boundary (singular) fit: see ?isSingular&quot; will likely occur in this function and are not necessarily the sign of a problem. lme4 warns if RE variances are fit to zero. This is desired / likely in this case, however, because we are simulating data with zero RE variances. Therefore, warnings are turned off per default. For diagnostic reasons, you can turn warnings on, and possibly also inspect fitted models via the parameter saveModels to see if there are any other problems in the re-fitted models.
</p>
<p>Data simulations are performed by <a href="#topic+getSimulations">getSimulations</a>, which is a wrapper for the respective model functions. The default for all packages, wherever possible, is to generate marginal simulations (meaning that REs are re-simulated as well). I see no sensible reason to change this, but if you want to and if supported by the respective regression package, you could do so by supplying the necessary arguments via ...
</p>


<h3>Note</h3>

<p>The logic of an LRT assumes that m0 is nested in m1, which guarantees that the L(M1) &gt; L(M0). The function does not explicitly check if models are nested and will work as long as data can be simulated from M0 that can be refit with M) and M1; however, I would strongly advice against using this for non-nested models unless you have a good statistical reason for doing so.
</p>
<p>Also, note that LRTs may be unreliable when fit with REML or some other kind of penalized / restricted ML. Therefore, you should fit model with ML for use in this function.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(DHARMa)
library(lme4)

# create test data
set.seed(123)
dat &lt;- createData(sampleSize = 200, randomEffectVariance = 1)

# define Null and alternative model (should be nested)
m1 = glmer(observedResponse ~ Environment1 + (1|group), data = dat, family = "poisson")
m0 = glm(observedResponse ~ Environment1 , data = dat, family = "poisson")

## Not run: 
# run LRT - n should be increased to at least 250 for a real study
out = simulateLRT(m0, m1, n = 10)

# To inspect warnings thrown during the refits:
out = simulateLRT(m0, m1, saveModels = TRUE, suppressWarnings = FALSE, n = 10)
summary(out$saveModels[[2]]$refittedM1) # RE SD = 0, no problem
# If there are warnings that seem problematic, 
# could try changing the optimizer or iterations

## End(Not run)
</code></pre>

<hr>
<h2 id='simulateResiduals'>Create simulated residuals</h2><span id='topic+simulateResiduals'></span>

<h3>Description</h3>

<p>The function creates scaled residuals by simulating from the fitted model. Residuals can be extracted with <a href="#topic+residuals.DHARMa">residuals.DHARMa</a>. See <a href="#topic+testResiduals">testResiduals</a> for an overview of residual tests, <a href="#topic+plot.DHARMa">plot.DHARMa</a> for an overview of available plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateResiduals(fittedModel, n = 250, refit = FALSE,
  integerResponse = NULL, plot = FALSE, seed = 123, method = c("PIT",
  "traditional"), rotation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateResiduals_+3A_fittedmodel">fittedModel</code></td>
<td>
<p>A fitted model of a class supported by DHARMa.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_n">n</code></td>
<td>
<p>Number of simulations. The smaller the number, the higher the stochastic error on the residuals. Also, for very small n, discretization artefacts can influence the tests. Default is 250, which is a relatively safe value. You can consider increasing to 1000 to stabilize the simulated values.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_refit">refit</code></td>
<td>
<p>If FALSE, new data will be simulated and scaled residuals will be created by comparing observed data with new data. If TRUE, the model will be refitted on the simulated data (parametric bootstrap), and scaled residuals will be created by comparing observed with refitted residuals.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_integerresponse">integerResponse</code></td>
<td>
<p>If TRUE, noise will be added at to the residuals to maintain a uniform expectations for integer responses (such as Poisson or Binomial). Usually, the model will automatically detect the appropriate setting, so there is no need to adjust this setting.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_plot">plot</code></td>
<td>
<p>If TRUE, <a href="#topic+plotResiduals">plotResiduals</a> will be directly run after the residuals have been calculated.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_seed">seed</code></td>
<td>
<p>The random seed to be used within DHARMa. The default setting, recommended for most users, is keep the random seed on a fixed value 123. This means that you will always get the same randomization and thus the same result when running the same code. If NULL, no new seed is set, but previous random state will be restored after simulation. If FALSE, no seed is set, and random state will not be restored. The latter two options are only recommended for simulation experiments. See vignette for details.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_method">method</code></td>
<td>
<p>For refit = FALSE, the quantile randomization method is used. The two options implemented at the moment are probability integral transform (PIT-) residuals (current default), and the &quot;traditional&quot; randomization procedure, that was used in DHARMa until version 0.3.0. refit = T will always use &quot;traditional&quot;, respectively of the value of method. For details, see <a href="#topic+getQuantile">getQuantile</a>.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_rotation">rotation</code></td>
<td>
<p>Optional rotation of the residual space prior to calculating the quantile residuals. The main purpose of this is to account for residual covariance as created by temporal, spatial or phylogenetic autocorrelation. See details below, section <em>residual autocorrelation</em> as well as the help of <a href="#topic+getQuantile">getQuantile</a> and, for a practical example, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>.</p>
</td></tr>
<tr><td><code id="simulateResiduals_+3A_...">...</code></td>
<td>
<p>Further parameters to pass on to the simulate function of the model object. An important use of this is to specify whether simulations should be conditional on the current random effect estimates, e.g. via re.form. Note that not all models support syntax to specify conditional or unconditional simulations. See details and <a href="#topic+getSimulations">getSimulations</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a number of important considerations when simulating from a more complex (hierarchical) model:
</p>
<p><strong>Re-simulating random effects / hierarchical structure</strong>: in a hierarchical model, we have several stochastic processes aligned on top of each other. Specifically, in a GLMM, we have a lower level stochastic process (random effect), whose result enters into a higher level (e.g. Poisson distribution). For other hierarchical models such as state-space models, similar considerations apply.
</p>
<p>In such a situation, we have to decide if we want to re-simulate all stochastic levels, or only a subset of those. For example, in a GLMM, it is common to only simulate the last stochastic level (e.g. Poisson) conditional on the fitted random effects. This is often referred to as a conditional simulation. For controlling how many levels should be re-simulated, the simulateResidual function allows to pass on parameters to the simulate function of the fitted model object. Please refer to the help of the different simulate functions (e.g. ?simulate.merMod) for details. For merMod (lme4) model objects, the relevant parameters are parameters are use.u and re.form. For glmmTMB model objects, the package version 1.1.10 has a temporary solution to simulate conditional to all random effects (see <a href="glmmTMB.html#topic+set_simcodes">glmmTMB::set_simcodes</a> val = &quot;fix&quot;, and issue <a href="https://github.com/glmmTMB/glmmTMB/issues/888">#888</a> in glmmTMB GitHub repository.
</p>
<p>If the model is correctly specified, the simulated residuals should be flat regardless how many hierarchical levels we re-simulate. The most thorough procedure would therefore be to test all possible options. If testing only one option, I would recommend to re-simulate all levels, because this essentially tests the model structure as a whole. This is the default setting in the DHARMa package. A potential drawback is that re-simulating the lower-level random effects creates more variability, which may reduce power for detecting problems in the upper-level stochastic processes. In particular dispersion tests may produce different results when switching from conditional to unconditional simulations, and often the conditional simulation is more sensitive.
</p>
<p><strong>Refitting or not</strong>: a third issue is how residuals are calculated. simulateResiduals has two options that are controlled by the refit parameter:
</p>

<ol>
<li><p> if refit = FALSE (default), new data is simulated from the fitted model, and residuals are calculated by comparing the observed data to the new data.
</p>
</li>
<li><p> if refit = TRUE, a parametric bootstrap is performed, meaning that the model is refit on the new data, and residuals are created by comparing observed residuals against refitted residuals. I advise against using this method per default (see more comments in the vignette), unless you are really sure that you need it.
</p>
</li></ol>

<p><strong>Residuals per group</strong>: In many situations, it can be useful to look at residuals per group, e.g. to see how much the model over / underpredicts per plot, year or subject. To do this, use <a href="#topic+recalculateResiduals">recalculateResiduals</a>, together with a grouping variable (see also help).
</p>
<p><strong>Transformation to other distributions</strong>: DHARMa calculates residuals for which the theoretical expectation (assuming a correctly specified model) is uniform. To transform this residuals to another distribution (e.g. so that a correctly specified model will have normal residuals) see <a href="#topic+residuals.DHARMa">residuals.DHARMa</a>.
</p>
<p><strong>Integer responses</strong>: this is only relevant if method = &quot;traditional&quot;, in which case it activates the randomization of the residuals. Usually, this does not need to be changed, as DHARMa will try to automatically check if the fitted model has an integer or discrete distribution via the family argument. However, in some cases the family does not allow to uniquely identify the distribution type. For example, a tweedie distribution can be interger or continuous. Therefore, DHARMa will additionally check the simulation results for repeated values, and will change the distribution type if repeated values are found (a message is displayed in this case).
</p>
<p><strong>Residual autocorrelation</strong>: a common problem is residual autocorrelation. Spatial, temporal and phylogenetic autocorrelation can be tested with <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a> and <a href="#topic+testPhylogeneticAutocorrelation">testPhylogeneticAutocorrelation</a>. If simulations are unconditional, residual correlations will be maintained, even if the autocorrelation is addressed by an appropriate CAR structure. This may be a problem, because autocorrelation may create apparently systematic patterns in plots or tests such as <a href="#topic+testUniformity">testUniformity</a>. To reduce this problem, either simulate conditional on fitted correlated REs, or rotate residuals via the rotation parameter (the latter will likely only work in approximately linear models). See <a href="#topic+getQuantile">getQuantile</a> for details on the rotation.
</p>


<h3>Value</h3>

<p>An S3 class of type &quot;DHARMa&quot;. Implemented S3 functions include <a href="#topic+plot.DHARMa">plot.DHARMa</a>, <a href="#topic+print.DHARMa">print.DHARMa</a> and <a href="#topic+residuals.DHARMa">residuals.DHARMa</a>. For other functions that can be used on a DHARMa object, see section &quot;See Also&quot; below.
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+plotResiduals">plotResiduals</a>, <a href="#topic+recalculateResiduals">recalculateResiduals</a>, <a href="#topic+outliers">outliers</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lme4)

testData = createData(sampleSize = 100, overdispersion = 0.5, family = poisson())
fittedModel &lt;- glmer(observedResponse ~ Environment1 + (1|group), 
                     family = "poisson", data = testData)

simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# standard plot 
plot(simulationOutput)

# one of the possible test, for other options see ?testResiduals / vignette
testDispersion(simulationOutput)

# the calculated residuals can be accessed via 
residuals(simulationOutput)

# transform residuals to other pdf, see ?residuals.DHARMa for details
residuals(simulationOutput, quantileFunction = qnorm, outlierValues = c(-7,7))

# get residuals that are outside the simulation envelope
outliers(simulationOutput)

# calculating aggregated residuals per group
simulationOutput2 = recalculateResiduals(simulationOutput, group = testData$group)
plot(simulationOutput2, quantreg = FALSE)

# calculating residuals only for subset of the data
simulationOutput3 = recalculateResiduals(simulationOutput, sel = testData$group == 1 )
plot(simulationOutput3, quantreg = FALSE)
</code></pre>

<hr>
<h2 id='testCategorical'>Test for categorical dependencies</h2><span id='topic+testCategorical'></span>

<h3>Description</h3>

<p>This function tests if there are probles in a res ~ group structure. It performs two tests: test for within-group uniformity, and test for between-group homogeneity of variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCategorical(simulationOutput, catPred, quantiles = c(0.25, 0.5, 0.75),
  plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testCategorical_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testCategorical_+3A_catpred">catPred</code></td>
<td>
<p>a categorical predictor with the same dimensions as the residuals in simulationOutput</p>
</td></tr>
<tr><td><code id="testCategorical_+3A_quantiles">quantiles</code></td>
<td>
<p>whether to draw the quantile lines.</p>
</td></tr>
<tr><td><code id="testCategorical_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the function will create an additional plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function tests for two common problems: are residuals within each group distributed according to model assumptions, and is the variance between group heterogeneous.
</p>
<p>The test for within-group uniformity is performed via multipe KS-tests, with adjustment of p-values for multiple testing. If the plot is drawn, problematic groups are highlighted in red, and a corresponding message is displayed in the plot.
</p>
<p>The test for homogeneity of variances is done with a Levene test. A significant p-value means that group variances are not constant. In this case, you should consider modelling variances, e.g. via ~dispformula in glmmTMB.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# the plot function shows 2 plots and runs 4 tests
# i) KS test i) Dispersion test iii) Outlier test iv) quantile test
plot(simulationOutput, quantreg = TRUE)

# testResiduals tests distribution, dispersion and outliers
testResiduals(simulationOutput)

####### Individual tests #######

# KS test for correct distribution of residuals
testUniformity(simulationOutput)

# KS test for correct distribution within and between groups
testCategorical(simulationOutput, testData$group)

# Dispersion test - for details see ?testDispersion
testDispersion(simulationOutput) # tests under and overdispersion

# Outlier test (number of observations outside simulation envelope)
# Use type = "boostrap" for exact values, see ?testOutliers
testOutliers(simulationOutput, type = "binomial")

# testing zero inflation
testZeroInflation(simulationOutput)

# testing generic summaries
countOnes &lt;- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes) # 1-inflation
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # 1-deficit

means &lt;- function(x) mean(x) # testing if mean prediction fits
testGeneric(simulationOutput, summary = means)

spread &lt;- function(x) sd(x) # testing if mean sd fits
testGeneric(simulationOutput, summary = spread)
</code></pre>

<hr>
<h2 id='testDispersion'>DHARMa dispersion tests</h2><span id='topic+testDispersion'></span>

<h3>Description</h3>

<p>This function performs simulation-based tests for over/underdispersion. If type = &quot;DHARMa&quot; (default and recommended), simulation-based dispersion tests are performed. Their behavior differs depending on whether simulations are done with refit = F, or refit = T, and whether data is simulated conditional (e.g. re.form ~0 in lme4) (see below). If type = &quot;PearsonChisq&quot;, a chi2 test on Pearson residuals is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDispersion(simulationOutput, alternative = c("two.sided", "greater",
  "less"), plot = T, type = c("DHARMa", "PearsonChisq"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testDispersion_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testDispersion_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis. Greater corresponds to testing only for overdispersion. It is recommended to keep the default setting (testing for both over and underdispersion)</p>
</td></tr>
<tr><td><code id="testDispersion_+3A_plot">plot</code></td>
<td>
<p>whether to provide a plot for the results</p>
</td></tr>
<tr><td><code id="testDispersion_+3A_type">type</code></td>
<td>
<p>which test to run. Default is DHARMa, other options are PearsonChisq (see details)</p>
</td></tr>
<tr><td><code id="testDispersion_+3A_...">...</code></td>
<td>
<p>arguments to pass on to <a href="#topic+testGeneric">testGeneric</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Over / underdispersion means that the observed data is more / less dispersed than expected under the fitted model. There is no unique way to test for dispersion problems, and there are a number of different dispersion tests implemented in various R packages.
</p>
<p>The testDispersion function implements several dispersion tests:
</p>
<p><strong>Simulation-based dispersion tests (type == &quot;DHARMa&quot;)</strong>
</p>
<p>If type = &quot;DHARMa&quot; (default and recommended), simulation-based dispersion tests are performed. Their behavior differs depending on whether simulations are done with refit = F, or refit = T
</p>
<p>#' <strong>Important:</strong> for either refit = T or F, the results of type = &quot;DHARMa&quot; dispersion test will differ depending on whether simulations are done conditional (= conditional on fitted random effects) or unconditional (= REs are re-simulated). How to change between conditional or unconditional simulations is discussed in <a href="#topic+simulateResiduals">simulateResiduals</a>. The general default in DHARMa is to use unconditional simulations, because this has advantages in other situations, but dispersion tests for models with strong REs specifically may increase substantially in power / sensitivity when switching to conditional simulations. I therefore recommend checking dispersion with conditional simulations if supported by the used regression package.
</p>
<p>If refit = F, the function uses <a href="#topic+testGeneric">testGeneric</a> to compare the variance of the observed raw residuals (i.e. var(observed - predicted), displayed as a red line) against the variance of the simulated residuals (i.e. var(simulated - predicted), histogram). The variances are scaled to the mean simulated variance. A significant ratio &gt; 1 indicates overdispersion, a significant ratio &lt; 1 underdispersion.
</p>
<p>If refit = T, the function compares the approximate deviance (via squared pearson residuals) with the same quantity from the models refitted with simulated data. Applying this is much slower than the previous alternative. Given the computational cost, I would suggest that most users will be satisfied with the standard dispersion test.
</p>
<p>** Analytical dispersion tests (type == &quot;PearsonChisq&quot;)**
</p>
<p>This is the test described in https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#overdispersion, identical to performance::check_overdispersion. Works only if the fitted model provides df.residual and Pearson residuals.
</p>
<p>The test statistics is biased to lower values under quite general conditions, and will therefore tend to test significant for underdispersion. It is recommended to use this test only for overdispersion, i.e. use alternative == &quot;greater&quot;. Also, obviously, it requires that Pearson residuals are available for the chosen model, which will not be the case for all models / packages.
</p>


<h3>Note</h3>

<p>For particular model classes / situations, there may be more powerful and thus preferable over the DHARMa test. The advantage of the DHARMa test is that it directly targets the spread of the data (unless other tests such as dispersion/df, which essentially measure fit and may thus be triggered by problems other than dispersion as well), and it makes practically no assumptions about the fitted model, other than the availability of simulations.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lme4)
set.seed(123)

testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 1)
fittedModel &lt;- glmer(observedResponse ~ Environment1 + (1|group), 
                     family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# default DHARMa dispersion test - simulation-based 
testDispersion(simulationOutput) 
testDispersion(simulationOutput, alternative = "less", plot = FALSE) # only underdispersion
testDispersion(simulationOutput, alternative = "greater", plot = FALSE) # only oversispersion

# for mixed models, the test is usually more powerful if residuals are calculated 
# conditional on fitted REs
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel, re.form = NULL)
testDispersion(simulationOutput)

# DHARMa also implements the popular Pearson-chisq test that is also on the glmmWiki by Ben Bolker
# The issue with this test is that it requires the df of the model, which are not well defined
# for GLMMs. It is biased towards underdispersion, with bias getting larger with the number 
# of RE groups. In doubt, only test for overdispersion
testDispersion(simulationOutput, type = "PearsonChisq", alternative = "greater")

# if refit = TRUE, a different test on simulated Pearson residuals will calculated (see help)
simulationOutput2 &lt;- simulateResiduals(fittedModel = fittedModel, refit = TRUE, seed = 12, n = 20)
testDispersion(simulationOutput2)

# often useful to test dispersion per group (in particular for binomial data, see vignette)
simulationOutputAggregated = recalculateResiduals(simulationOutput2, group = testData$group)
testDispersion(simulationOutputAggregated)




</code></pre>

<hr>
<h2 id='testGeneric'>Test for a generic summary statistic based on simulated data</h2><span id='topic+testGeneric'></span>

<h3>Description</h3>

<p>This function tests if a user-defined summary differs when applied to simulated / observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGeneric(simulationOutput, summary, alternative = c("two.sided",
  "greater", "less"), plot = T,
  methodName = "DHARMa generic simulation test")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testGeneric_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testGeneric_+3A_summary">summary</code></td>
<td>
<p>a function that can be applied to simulated / observed data. See examples below</p>
</td></tr>
<tr><td><code id="testGeneric_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis</p>
</td></tr>
<tr><td><code id="testGeneric_+3A_plot">plot</code></td>
<td>
<p>whether to plot the simulated summary</p>
</td></tr>
<tr><td><code id="testGeneric_+3A_methodname">methodName</code></td>
<td>
<p>name of the test (will be used in plot)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a user-defined summary to the simulated/observed data of a DHARMa object and then performs a hypothesis test using the ratio Obs / Sim as the test statistic.
</p>
<p>The summary is applied directly to the data and not to the residuals, but it can easily be remodeled to apply summaries to the residuals by simply defining something like f = function(x) summary (x - predictions), as done in <a href="#topic+testDispersion">testDispersion</a>
</p>


<h3>Note</h3>

<p>The summary function you specify will be applied to the data as it appears in your fitted model, which may not always be what you want.
</p>
<p>As an example, consider the case where we want to test for n-inflation in k/n data. If you provide your data via cbind (k, n-k), you have to test for n-inflation, but if you provide your data via k/n and weights = n, you should test for 1-inflation. When in doubt, check how the data is represented internally in model.frame(model) or via simulate(model).
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# the plot function shows 2 plots and runs 4 tests
# i) KS test i) Dispersion test iii) Outlier test iv) quantile test
plot(simulationOutput, quantreg = TRUE)

# testResiduals tests distribution, dispersion and outliers
testResiduals(simulationOutput)

####### Individual tests #######

# KS test for correct distribution of residuals
testUniformity(simulationOutput)

# KS test for correct distribution within and between groups
testCategorical(simulationOutput, testData$group)

# Dispersion test - for details see ?testDispersion
testDispersion(simulationOutput) # tests under and overdispersion

# Outlier test (number of observations outside simulation envelope)
# Use type = "boostrap" for exact values, see ?testOutliers
testOutliers(simulationOutput, type = "binomial")

# testing zero inflation
testZeroInflation(simulationOutput)

# testing generic summaries
countOnes &lt;- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes) # 1-inflation
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # 1-deficit

means &lt;- function(x) mean(x) # testing if mean prediction fits
testGeneric(simulationOutput, summary = means)

spread &lt;- function(x) sd(x) # testing if mean sd fits
testGeneric(simulationOutput, summary = spread)
</code></pre>

<hr>
<h2 id='testOutliers'>Test for outliers</h2><span id='topic+testOutliers'></span>

<h3>Description</h3>

<p>This function tests if the number of observations outside the simulatio envelope are larger or smaller than expected
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testOutliers(simulationOutput, alternative = c("two.sided", "greater",
  "less"), margin = c("both", "upper", "lower"), type = c("default",
  "bootstrap", "binomial"), nBoot = 100, plot = TRUE,
  plotBoostrap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testOutliers_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; (default) compared to the simulated null hypothesis</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_margin">margin</code></td>
<td>
<p>whether to test for outliers only at the lower, only at the upper, or both sides (default) of the simulated data distribution</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_type">type</code></td>
<td>
<p>either default, bootstrap or binomial. See details</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_nboot">nBoot</code></td>
<td>
<p>number of boostrap replicates. Only used ot type = &quot;bootstrap&quot;</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the function will create an additional plot</p>
</td></tr>
<tr><td><code id="testOutliers_+3A_plotboostrap">plotBoostrap</code></td>
<td>
<p>if plot should be produced of outlier frequencies calculated under the bootstrap</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DHARMa residuals are created by simulating from the fitted model, and comparing the simulated values to the observed data. It can occur that all simulated values are higher or smaller than the observed data, in which case they get the residual value of 0 and 1, respectively. I refer to these values as simulation outliers, or simply outliers.
</p>
<p>Because no data was simulated in the range of the observed value, we don't know &quot;how strongly&quot; these values deviate from the model expectation, so the term &quot;outlier&quot; should be used with a grain of salt. It is not a judgment about the magnitude of the residual deviation, but simply a dichotomous sign that we are outside the simulated range. Moreover, the number of outliers will decrease as we increase the number of simulations.
</p>
<p>To test if the outliers are a concern, testOutliers implements 2 options (bootstrap, binomial), which can be chosen via the parameter &quot;type&quot;. The third option (default) chooses bootstrap for integer-valued distribubtions with nObs &lt; 500, and else binomial.
</p>
<p>The binomial test considers that under the null hypothesis that the model is correct, and for continuous distributions (i.e. data and the model distribution are identical and continous), the probability that a given observation is higher than all simulations is 1/(nSim +1), and binomial distributed. The testOutlier function can test this null hypothesis via type = &quot;binomial&quot;. In principle, it would be nice if we could extend this idea to integer-valued distributions, which are randomized via the PIT procedure (see <a href="#topic+simulateResiduals">simulateResiduals</a>), the rate of &quot;true&quot; outliers is more difficult to calculate, and in general not 1/(nSim +1). The testOutlier function implements a small tweak that calculates the rate of residuals that are closer than 1/(nSim+1) to the 0/1 border, which roughly occur at a rate of nData /(nSim +1). This approximate value, however, is generally not exact, and may be particularly off non-bounded integer-valued distributions (such as Poisson or Negative Binomial).
</p>
<p>For this reason, the testOutlier function implements an alternative procedure that uses the bootstrap to generate a simulation-based expectation for the outliers. It is recommended to use the bootstrap for integer-valued distributions (and integer-valued only, because it has no advantage for continuous distributions, ideally with reasonably high values of nSim and nBoot (I recommend at least 1000 for both). Because of the high runtime, however, this option is switched off for type = default when nObs &gt; 500.
</p>
<p>Both binomial or bootstrap generate a null expectation, and then test for an excess or lack of outliers. Per default, testOutliers() looks for both, so if you get a significant p-value, you have to check if you have to many or too few outliers. An excess of outliers is to be interpreted as too many values outside the simulation envelope. This could be caused by overdispersion, or by what we classically call outliers. A lack of outliers would be caused, for example, by underdispersion.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>

<hr>
<h2 id='testOverdispersion'>Simulated overdisperstion tests</h2><span id='topic+testOverdispersion'></span>

<h3>Description</h3>

<p>Simulated overdisperstion tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testOverdispersion(simulationOutput, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testOverdispersion_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa with simulated quantile residuals, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa</p>
</td></tr>
<tr><td><code id="testOverdispersion_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="#topic+testDispersion">testDispersion</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated, switch your code to using the <a href="#topic+testDispersion">testDispersion</a> function
</p>

<hr>
<h2 id='testOverdispersionParametric'>Parametric overdisperstion tests</h2><span id='topic+testOverdispersionParametric'></span>

<h3>Description</h3>

<p>Parametric overdisperstion tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testOverdispersionParametric(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testOverdispersionParametric_+3A_...">...</code></td>
<td>
<p>arguments will be ignored, the parametric tests is no longer recommend</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated, switch your code to using the <a href="#topic+testDispersion">testDispersion</a> function.
</p>

<hr>
<h2 id='testPDistribution'>Plot distribution of p-values.</h2><span id='topic+testPDistribution'></span>

<h3>Description</h3>

<p>Plot distribution of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPDistribution(x, plot = TRUE,
  main = "p distribution \n expected is flat at 1", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testPDistribution_+3A_x">x</code></td>
<td>
<p>vector of p values.</p>
</td></tr>
<tr><td><code id="testPDistribution_+3A_plot">plot</code></td>
<td>
<p>should the values be plotted.</p>
</td></tr>
<tr><td><code id="testPDistribution_+3A_main">main</code></td>
<td>
<p>title for the plot.</p>
</td></tr>
<tr><td><code id="testPDistribution_+3A_...">...</code></td>
<td>
<p>additional arguments to hist.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='testPhylogeneticAutocorrelation'>Test for phylogenetic autocorrelation</h2><span id='topic+testPhylogeneticAutocorrelation'></span>

<h3>Description</h3>

<p>This function performs a Moran's I test for phylogenetic autocorrelation on the calculated quantile residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPhylogeneticAutocorrelation(simulationOutput, tree,
  alternative = c("two.sided", "greater", "less"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testPhylogeneticAutocorrelation_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or via <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testPhylogeneticAutocorrelation_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object.</p>
</td></tr>
<tr><td><code id="testPhylogeneticAutocorrelation_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis of no phylogenetic correlation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs Moran.I test from the package ape on the DHARMa residuals, based on the phylogenetic distance matrix internally created from the provided tree. For custom distance matrices, you can use <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>.
</p>


<h3>Note</h3>

<p>Standard DHARMa simulations from models with (temporal / spatial / phylogenetic) conditional autoregressive terms will still have the respective temporal / spatial / phylogenetic correlation in the DHARMa residuals, unless the package you are using is modelling the autoregressive terms as explicit REs and is able to simulate conditional on the fitted REs. This has two consequences:
</p>

<ol>
<li><p> If you check the residuals for such a model, they will still show significant autocorrelation, even if the model fully accounts for this structure.
</p>
</li>
<li><p> Because the DHARMa residuals for such a model are not statistically independent any more, other tests (e.g. dispersion, uniformity) may have inflated type I error, i.e. you will have a higher likelihood of spurious residual problems.
</p>
</li></ol>

<p>There are three (non-exclusive) routes to address these issues when working with spatial / temporal / phylogenetic autoregressive models:
</p>

<ol>
<li><p> Simulate conditional on the fitted CAR structures (see conditional simulations in the help of <a href="#topic+simulateResiduals">simulateResiduals</a>).
</p>
</li>
<li><p> Rotate simulations prior to residual calculations (see parameter rotation in <a href="#topic+simulateResiduals">simulateResiduals</a>).
</p>
</li>
<li><p> Use custom tests / plots that explicitly compare the correlation structure in the simulated data to the correlation structure in the observed data.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

  library(DHARMa)
  library(phylolm)

  set.seed(123)
  tre = rcoal(60)
  b0 = 0; b1 = 1;
  x &lt;- runif(length(tre$tip.label), 0, 1)
  y &lt;- b0 + b1*x +
    rTrait(n = 1, phy = tre,model="BM",
           parameters = list(ancestral.state = 0, sigma2 = 10))
  dat = data.frame(trait = y, pred = x)

  fit = lm(trait ~ pred, data = dat)
  res = simulateResiduals(fit, plot = T)

  testPhylogeneticAutocorrelation(res, tree = tre)


  fit = phylolm(trait ~ pred, data = dat, phy = tre, model = "BM")
  summary(fit)

  # phylogenetic autocorrelation still present in residuals
  res = simulateResiduals(fit, plot = T)

  # with "rotation" the residual autcorrelation is gone, see ?simulateResiduals.
  res = simulateResiduals(fit, plot = T, rotation = "estimated")


## End(Not run)
</code></pre>

<hr>
<h2 id='testQuantiles'>Test for quantiles</h2><span id='topic+testQuantiles'></span>

<h3>Description</h3>

<p>This function tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testQuantiles(simulationOutput, predictor = NULL, quantiles = c(0.25, 0.5,
  0.75), plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testQuantiles_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testQuantiles_+3A_predictor">predictor</code></td>
<td>
<p>an optional predictor variable to be used, instead of the predicted response (default)</p>
</td></tr>
<tr><td><code id="testQuantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>the quantiles to be tested</p>
</td></tr>
<tr><td><code id="testQuantiles_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the function will create an additional plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits quantile regressions (via package qgam) on the residuals, and compares their location to the expected location (because of the uniform distributionm, the expected location is 0.5 for the 0.5 quantile).
</p>
<p>A significant p-value for the splines means the fitted spline deviates from a flat line at the expected location (p-values of intercept and spline are combined via Benjamini &amp; Hochberg adjustment to control the FDR)
</p>
<p>The p-values of the splines are combined into a total p-value via Benjamini &amp; Hochberg adjustment to control the FDR.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 200, overdispersion = 0.0, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1, family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# run the quantile test
x = testQuantiles(simulationOutput)
x # the test shows a combined p-value, corrected for multiple testing

## Not run: 
# accessing results of the test
x$pvals # pvalues for the individual quantiles
x$qgamFits # access the fitted quantile regression 
summary(x$qgamFits[[1]]) # summary of the first fitted quantile

# possible to test user-defined quantiles
testQuantiles(simulationOutput, quantiles = c(0.7))

#  example with missing environmental predictor
fittedModel &lt;- glm(observedResponse ~ 1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)
testQuantiles(simulationOutput, predictor = testData$Environment1)

plot(simulationOutput)
plotResiduals(simulationOutput)

## End(Not run)

</code></pre>

<hr>
<h2 id='testResiduals'>DHARMa general residual test</h2><span id='topic+testResiduals'></span>

<h3>Description</h3>

<p>Calls uniformity, dispersion and outliers tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testResiduals(simulationOutput, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testResiduals_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testResiduals_+3A_plot">plot</code></td>
<td>
<p>if TRUE, plots functions of the tests are called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the various test functions implemented in DHARMa. Currently, this function calls the functions <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testDispersion">testDispersion</a>, and <a href="#topic+testOutliers">testOutliers</a>. All other tests (see list below) have to be called by hand.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# the plot function shows 2 plots and runs 4 tests
# i) KS test i) Dispersion test iii) Outlier test iv) quantile test
plot(simulationOutput, quantreg = TRUE)

# testResiduals tests distribution, dispersion and outliers
testResiduals(simulationOutput)

####### Individual tests #######

# KS test for correct distribution of residuals
testUniformity(simulationOutput)

# KS test for correct distribution within and between groups
testCategorical(simulationOutput, testData$group)

# Dispersion test - for details see ?testDispersion
testDispersion(simulationOutput) # tests under and overdispersion

# Outlier test (number of observations outside simulation envelope)
# Use type = "boostrap" for exact values, see ?testOutliers
testOutliers(simulationOutput, type = "binomial")

# testing zero inflation
testZeroInflation(simulationOutput)

# testing generic summaries
countOnes &lt;- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes) # 1-inflation
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # 1-deficit

means &lt;- function(x) mean(x) # testing if mean prediction fits
testGeneric(simulationOutput, summary = means)

spread &lt;- function(x) sd(x) # testing if mean sd fits
testGeneric(simulationOutput, summary = spread)
</code></pre>

<hr>
<h2 id='testSimulatedResiduals'>Residual tests</h2><span id='topic+testSimulatedResiduals'></span>

<h3>Description</h3>

<p>Residual tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSimulatedResiduals(simulationOutput)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testSimulatedResiduals_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated, switch your code to using the <a href="#topic+testResiduals">testResiduals</a> function
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='testSpatialAutocorrelation'>Test for distance-based spatial (or similar type) autocorrelation</h2><span id='topic+testSpatialAutocorrelation'></span>

<h3>Description</h3>

<p>This function performs a Moran's I test for distance-based spatial (or similar type) autocorrelation on the calculated quantile residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSpatialAutocorrelation(simulationOutput, x = NULL, y = NULL,
  distMat = NULL, alternative = c("two.sided", "greater", "less"),
  plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testSpatialAutocorrelation_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>An object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or via <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testSpatialAutocorrelation_+3A_x">x</code></td>
<td>
<p>The x coordinate, in the same order as the data points. Must be specified unless distMat is provided.</p>
</td></tr>
<tr><td><code id="testSpatialAutocorrelation_+3A_y">y</code></td>
<td>
<p>The y coordinate, in the same order as the data points. Must be specified unless distMat is provided.</p>
</td></tr>
<tr><td><code id="testSpatialAutocorrelation_+3A_distmat">distMat</code></td>
<td>
<p>Optional distance matrix. If not provided, euclidean distances based on x and y will be calculated. See details for explanation.</p>
</td></tr>
<tr><td><code id="testSpatialAutocorrelation_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis.</p>
</td></tr>
<tr><td><code id="testSpatialAutocorrelation_+3A_plot">plot</code></td>
<td>
<p>If T, and if x and y is provided, plot the output (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs Moran.I test from the package ape on the DHARMa residuals. If a distance matrix (distMat) is provided, calculations will be based on this distance matrix, and x,y coordinates will only used for the plotting (if provided). If distMat is not provided, the function will calculate the euclidean distances between x,y coordinates, and test Moran.I based on these distances.
</p>
<p>If plot = T, a plot will be produced showing each residual with at its x,y position, colored according to the residual value. Residuals with 0.5 are colored white, everything below 0.5 is colored increasinly red, everything above 0.5 is colored increasingly blue.
</p>
<p>Testing for spatial autocorrelation requires unique x,y values - if you have several observations per location, either use the <a href="#topic+recalculateResiduals">recalculateResiduals</a> function to aggregate residuals per location, or extract the residuals from the fitted object, and plot / test each of them independently for spatially repeated subgroups (a typical scenario would repeated spatial observation, in which case one could plot / test each time step separately for temporal autocorrelation). Note that the latter must be done by hand, outside <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>.
</p>


<h3>Note</h3>

<p>Standard DHARMa simulations from models with (temporal / spatial / phylogenetic) conditional autoregressive terms will still have the respective temporal / spatial / phylogenetic correlation in the DHARMa residuals, unless the package you are using is modelling the autoregressive terms as explicit REs and is able to simulate conditional on the fitted REs. This has two consequences:
</p>

<ol>
<li><p> If you check the residuals for such a model, they will still show significant autocorrelation, even if the model fully accounts for this structure.
</p>
</li>
<li><p> Because the DHARMa residuals for such a model are not statistically independent any more, other tests (e.g. dispersion, uniformity) may have inflated type I error, i.e. you will have a higher likelihood of spurious residual problems.
</p>
</li></ol>

<p>There are three (non-exclusive) routes to address these issues when working with spatial / temporal / phylogenetic / other autoregressive models:
</p>

<ol>
<li><p> Simulate conditional on the fitted CAR structures (see conditional simulations in the help of <a href="#topic+simulateResiduals">simulateResiduals</a>).
</p>
</li>
<li><p> Rotate simulations prior to residual calculations (see parameter rotation in <a href="#topic+simulateResiduals">simulateResiduals</a>).
</p>
</li>
<li><p> Use custom tests / plots that explicitly compare the correlation structure in the simulated data to the correlation structure in the observed data.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 40, family = gaussian())
fittedModel &lt;- lm(observedResponse ~ Environment1, data = testData)
res = simulateResiduals(fittedModel)

# Standard use
testSpatialAutocorrelation(res, x =  testData$x, y = testData$y)

# Alternatively, one can provide a distance matrix
dM = as.matrix(dist(cbind(testData$x, testData$y)))
testSpatialAutocorrelation(res, distMat = dM)

# You could add a spatial variogram via
# library(gstat)
# dat = data.frame(res = residuals(res), x = testData$x, y = testData$y)
# coordinates(dat) = ~x+y
# vario = variogram(res~1, data = dat, alpha=c(0,45,90,135))
# plot(vario, ylim = c(-1,1))

# if there are multiple observations with the same x values,
# create first ar group with unique values for each location
# then aggregate the residuals per location, and calculate
# spatial autocorrelation on the new group

# modifying x, y, so that we have the same location per group
# just for completeness
testData$x = as.numeric(testData$group)
testData$y = as.numeric(testData$group)

# calculating x, y positions per group
groupLocations = aggregate(testData[, 6:7], list(testData$group), mean)

# calculating residuals per group
res2 = recalculateResiduals(res, group = testData$group)

# running the spatial test on grouped residuals
testSpatialAutocorrelation(res2, groupLocations$x, groupLocations$y)

# careful when using REs to account for spatially clustered (but not grouped)
# data. this originates from https://github.com/florianhartig/DHARMa/issues/81

# Assume our data is divided into clusters, where observations are close together
# but not at the same point, and we suspect that observations in clusters are
# autocorrelated

clusters = 100
subsamples = 10
size = clusters * subsamples

testData = createData(sampleSize = size, family = gaussian(), numGroups = clusters )
testData$x  = rnorm(clusters)[testData$group] + rnorm(size, sd = 0.01)
testData$y  = rnorm(clusters)[testData$group] + rnorm(size, sd = 0.01)

# It's a good idea to use a RE to take out the cluster effects. This accounts
# for the autocorrelation within clusters

library(lme4)
fittedModel &lt;- lmer(observedResponse ~ Environment1 + (1|group), data = testData)

# DHARMa default is to re-simulate REs - this means spatial pattern remains
# because residuals are still clustered

res = simulateResiduals(fittedModel)
testSpatialAutocorrelation(res, x =  testData$x, y = testData$y)

# However, it should disappear if you just calculate an aggregate residuals per cluster
# Because at least how the data are simulated, cluster are spatially independent

res2 = recalculateResiduals(res, group = testData$group)
testSpatialAutocorrelation(res2,
                           x =  aggregate(testData$x, list(testData$group), mean)$x,
                           y = aggregate(testData$y, list(testData$group), mean)$x)

# For lme4, it's also possible to simulated residuals conditional on fitted
# REs (re.form). Conditional on the fitted REs (i.e. accounting for the clusters)
# the residuals should now be indepdendent. The remaining RSA we see here is
# probably due to the RE shrinkage

res = simulateResiduals(fittedModel, re.form = NULL)
testSpatialAutocorrelation(res, x =  testData$x, y = testData$y)


</code></pre>

<hr>
<h2 id='testTemporalAutocorrelation'>Test for temporal autocorrelation</h2><span id='topic+testTemporalAutocorrelation'></span>

<h3>Description</h3>

<p>This function performs a standard test for temporal autocorrelation on the simulated residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testTemporalAutocorrelation(simulationOutput, time,
  alternative = c("two.sided", "greater", "less"), plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testTemporalAutocorrelation_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testTemporalAutocorrelation_+3A_time">time</code></td>
<td>
<p>the time, in the same order as the data points.</p>
</td></tr>
<tr><td><code id="testTemporalAutocorrelation_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis</p>
</td></tr>
<tr><td><code id="testTemporalAutocorrelation_+3A_plot">plot</code></td>
<td>
<p>whether to plot output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs a Durbin-Watson test on the uniformly scaled residuals, and plots the residuals against time. The DB test was originally be designed for normal residuals. In simulations, I didn't see a problem with this setting though. The alternative is to transform the uniform residuals to normal residuals and perform the DB test on those.
</p>
<p>Testing for temporal autocorrelation requires unique time values - if you have several observations per time value, either use <a href="#topic+recalculateResiduals">recalculateResiduals</a> function to aggregate residuals per time step, or extract the residuals from the fitted object, and plot / test each of them independently for temporally repeated subgroups (typical choices would be location / subject etc.). Note that the latter must be done by hand, outside testTemporalAutocorrelation.
</p>


<h3>Note</h3>

<p>Standard DHARMa simulations from models with (temporal / spatial / phylogenetic) conditional autoregressive terms will still have the respective temporal / spatial / phylogenetic correlation in the DHARMa residuals, unless the package you are using is modelling the autoregressive terms as explicit REs and is able to simulate conditional on the fitted REs. This has two consequences
</p>

<ol>
<li><p> If you check the residuals for such a model, they will still show significant autocorrelation, even if the model fully accounts for this structure.
</p>
</li>
<li><p> Because the DHARMa residuals for such a model are not statistically independent any more, other tests (e.g. dispersion, uniformity) may have inflated type I error, i.e. you will have a higher likelihood of spurious residual problems.
</p>
</li></ol>

<p>There are three (non-exclusive) routes to address these issues when working with spatial / temporal / other autoregressive models:
</p>

<ol>
<li><p> Simulate conditional on the fitted CAR structures (see conditional simulations in the help of <a href="#topic+simulateResiduals">simulateResiduals</a>)
</p>
</li>
<li><p> Rotate simulations prior to residual calculations (see parameter rotation in <a href="#topic+simulateResiduals">simulateResiduals</a>)
</p>
</li>
<li><p> Use custom tests / plots that explicitly compare the correlation structure in the simulated data to the correlation structure in the observed data.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 40, family = gaussian(), 
                      randomEffectVariance = 0)
fittedModel &lt;- lm(observedResponse ~ Environment1, data = testData)
res = simulateResiduals(fittedModel)

# Standard use
testTemporalAutocorrelation(res, time =  testData$time)

# If you have several observations per time step, e.g. 
# because you have several locations, you will have to 
# aggregate

timeSeries1 = createData(sampleSize = 40, family = gaussian(), 
                         randomEffectVariance = 0)
timeSeries1$location = 1
timeSeries2 = createData(sampleSize = 40, family = gaussian(), 
                         randomEffectVariance = 0)
timeSeries2$location = 2
testData = rbind(timeSeries1, timeSeries2)

fittedModel &lt;- lm(observedResponse ~ Environment1, data = testData)
res = simulateResiduals(fittedModel)

# Will not work because several residuals per time
# testTemporalAutocorrelation(res, time = testData$time)

# aggregating residuals by time
res = recalculateResiduals(res, group = testData$time)
testTemporalAutocorrelation(res, time = unique(testData$time))

# testing only subgroup location 1, could do same with loc 2
res = recalculateResiduals(res, sel = testData$location == 1)
testTemporalAutocorrelation(res, time = unique(testData$time))

# example to demonstrate problems with strong temporal correlations and
# how to possibly remove them by rotating residuals
# note that if your model allows to condition on estimated REs, this may 
# be preferable!

## Not run: 

  set.seed(123)
  
  # Gaussian error 
  
  # Create AR data with 5 observations per time point
  n &lt;- 100                                              
  x &lt;- MASS::mvrnorm(mu = rep(0,n),
                     Sigma = .9 ^ as.matrix(dist(1:n)) )   
  y &lt;- rep(x, each = 5) + 0.2 * rnorm(5*n)                       
  times &lt;- factor(rep(1:n, each = 5), levels=1:n)
  levels(times)
  group &lt;- factor(rep(1,n*5))
  dat0 &lt;- data.frame(y,times,group)
  
  # fit model / would be similar for nlme::gls and similar models
  model = glmmTMB(y ~ ar1(times + 0 | group), data=dat0)
  
  # Note that standard residuals still show problems because of autocorrelation
  res &lt;- simulateResiduals(model)
  plot(res)
  
  # The reason is that most (if not all) autoregressive models treat the 
  # autocorrelated error as random, i.e. the autocorrelated error structure
  # is not used for making predictions. If you then make predictions based
  # on the fixed effects and calculate residuals, the autocorrelation in the 
  # residuals remains. We can see this if we again calculate the auto-
  # correlation test
  
  res2 &lt;- recalculateResiduals(res, group=dat0$times) 
  testTemporalAutocorrelation(res2, time = 1:length(res2$scaledResiduals))
  
  # so, how can we check then if the current model correctly removed the
  # autocorrelation?
  
  # Option 1: rotate the residuals in the direction of the autocorrelation
  # to make the independent. Note that this only works perfectly for gls
  # type models as nonlinear link function make the residuals covariance
  # different from a multivariate normal distribution 
  
  # this can be either done by extracting estimated AR1 covariance
  cov &lt;- VarCorr(model)
  cov &lt;- cov$cond$group # extract covariance matrix of REs

  # grouped according to times, rotated with estimated Cov - how all fine!
  res3 &lt;- recalculateResiduals(res, group=dat0$times, rotation=cov) 
  plot(res3)
  testTemporalAutocorrelation(res3, time = 1:length(res2$scaledResiduals))
  
  # alternatively, you can let DHARMa estimate the covariance from the
  # simulations 
  
  res4 &lt;- recalculateResiduals(res, group=dat0$times, rotation="estimated") 
  plot(res4)
  testTemporalAutocorrelation(res3, time = 1:length(res2$scaledResiduals))
  
  # Alternatively, in glmmTMB, we can condition on the estimated correlated 
  # residuals. Unfortunately, in this case, we will have to do simulations by
  # hand as glmmTMB does not allow to simulate conditional on a fitted
  # correlation structure
 
  # re.form = NULL creates predictions conditional on the fitted temporally
  # autocorreated REs
  pred = predict(model, re.form = NULL) 
  
  # now we simulate data, conditional on the autocorrelation part, with the 
  # uncorrelated residual error
  simulations = sapply(1:250, function(i) rnorm(length(pred), 
                                                pred, 
                                                summary(model)$sigma))
  res5 = createDHARMa(simulations, dat0$y, pred)
  plot(res5)
  
  res5b &lt;- recalculateResiduals(res5, group=dat0$times) 
  testTemporalAutocorrelation(res5b, time = 1:length(res5b$scaledResiduals))

  # Poisson error 
  # note that for GLMMs, covariances will be estimated at the scale of the 
  # linear predictor, while residual covariance will be at the responses scale
  # and thus further distorted by the link. Thus, for GLMMs with a nonlinear
  # link, there will be no exact rotation for a given covariance structure
  
  set.seed(123)
  
  # Create AR data with 5 observations per time point
  n &lt;- 100                                              
  x &lt;- MASS::mvrnorm(mu = rep(0,n),
                     Sigma = .9 ^ as.matrix(dist(1:n)) )   
  y &lt;- rpois(n = n*5, lambda = exp(rep(x, each = 5)))                     
  times &lt;- factor(rep(1:n, each = 5), levels=1:n)
  levels(times)
  group &lt;- factor(rep(1,n*5))
  dat0 &lt;- data.frame(y,times,group)
  
  # fit model
  model = glmmTMB(y ~ ar1(times + 0 | group), data=dat0, family = poisson)
  
  res &lt;- simulateResiduals(model)

  # grouped according to times, unrotated
  res2 &lt;- recalculateResiduals(res, group=dat0$times) 
  testTemporalAutocorrelation(res2, time = 1:length(res2$scaledResiduals))
  
  # grouped according to times, rotated with estimated Cov - problems remain
  cov &lt;- VarCorr(model)
  cov &lt;- cov$cond$group # extract covariance matrix of REs
  res3 &lt;- recalculateResiduals(res, group=dat0$times, rotation=cov) 
  testTemporalAutocorrelation(res3, time = 1:length(res2$scaledResiduals))

  # grouped according to times, rotated with covariance estimated from residual 
  # simulations at the response scale
  res4 &lt;- recalculateResiduals(res, group=dat0$times, rotation="estimated") 
  testTemporalAutocorrelation(res4, time = 1:length(res2$scaledResiduals))


## End(Not run)
</code></pre>

<hr>
<h2 id='testUniformity'>Test for overall uniformity</h2><span id='topic+testUniformity'></span>

<h3>Description</h3>

<p>This function tests the overall uniformity of the simulated residuals in a DHARMa object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testUniformity(simulationOutput, alternative = c("two.sided", "less",
  "greater"), plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testUniformity_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testUniformity_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying whether the test should test if observations are &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot; compared to the simulated null hypothesis. See <a href="stats.html#topic+ks.test">stats::ks.test</a> for details</p>
</td></tr>
<tr><td><code id="testUniformity_+3A_plot">plot</code></td>
<td>
<p>if TRUE, plots calls <a href="#topic+plotQQunif">plotQQunif</a> as well</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function applies a <a href="stats.html#topic+ks.test">stats::ks.test</a> for uniformity on the simulated residuals.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# the plot function shows 2 plots and runs 4 tests
# i) KS test i) Dispersion test iii) Outlier test iv) quantile test
plot(simulationOutput, quantreg = TRUE)

# testResiduals tests distribution, dispersion and outliers
testResiduals(simulationOutput)

####### Individual tests #######

# KS test for correct distribution of residuals
testUniformity(simulationOutput)

# KS test for correct distribution within and between groups
testCategorical(simulationOutput, testData$group)

# Dispersion test - for details see ?testDispersion
testDispersion(simulationOutput) # tests under and overdispersion

# Outlier test (number of observations outside simulation envelope)
# Use type = "boostrap" for exact values, see ?testOutliers
testOutliers(simulationOutput, type = "binomial")

# testing zero inflation
testZeroInflation(simulationOutput)

# testing generic summaries
countOnes &lt;- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes) # 1-inflation
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # 1-deficit

means &lt;- function(x) mean(x) # testing if mean prediction fits
testGeneric(simulationOutput, summary = means)

spread &lt;- function(x) sd(x) # testing if mean sd fits
testGeneric(simulationOutput, summary = spread)
</code></pre>

<hr>
<h2 id='testZeroInflation'>Tests for zero-inflation</h2><span id='topic+testZeroInflation'></span>

<h3>Description</h3>

<p>This function compares the observed number of zeros with the zeros expected from simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testZeroInflation(simulationOutput, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testZeroInflation_+3A_simulationoutput">simulationOutput</code></td>
<td>
<p>an object of class DHARMa, either created via <a href="#topic+simulateResiduals">simulateResiduals</a> for supported models or by <a href="#topic+createDHARMa">createDHARMa</a> for simulations created outside DHARMa, or a supported model. Providing a supported model directly is discouraged, because simulation settings cannot be changed in this case.</p>
</td></tr>
<tr><td><code id="testZeroInflation_+3A_...">...</code></td>
<td>
<p>further arguments to <a href="#topic+testGeneric">testGeneric</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero-inflation means that the observed data contain more zeros than would be expected under the fitted model. Zero-inflation must always be accessed with respect to a particular model, so the mere fact that there are many zeros in the observed data is not an indication of zero-inflation, see Warton, D. I. (2005). Many zeros does not mean zero inflation: comparing the goodness-of-fit of parametric models to multivariate abundance data. Environmetrics 16(3), 275-289.
</p>
<p>The testZeroInflation function simulates new datasets from the fitted model and compares this null distribution (gray histogram in the plot) with the observed values (red line in the plot). Technically, it is a wrapper for <a href="#topic+testGeneric">testGeneric</a>, with the summary argument set to function(x) sum(x == 0). The test statistic is the ratio of observed to simulated zeros. A value &lt; 1 means that the observed data have fewer zeros than expected, a value &gt; 1 means that they have more zeros than expected (aka zero inflation). By default, the function tests both sides, so it would also test for fewer zeros than expected.
</p>


<h3>Note</h3>

<p>Zero-inflation can occur for a number of reasons other than an underlying data generating process corresponding to a ZIP model. Vice versa, it is very well possible that no zero-inflation will be observed when fitting models to data derived from a ZIP process. The latter is due to the fact that excess zeros can often be explained by other model parameters, such as the theta parameter in the negative binomial.
</p>
<p>For this reason, results of the zero-inflation test should be interpreted as a residual pattern that can have many reasons, not as a decision criterion for whether or not to fit a ZIP model. To decide whether to add a ZIP term, I would advise relying on appropriate model selection techniques such as AIC, BIC, WAIC, Bayes factor, or LRT. Note that these tests are often not reliable in GLMMs because it is difficult to determine the df spent by the different models. The <a href="#topic+simulateLRT">simulateLRT</a> function in DHARMa provides a nonparametric alternative to obtain p-values for LRT is nested models with unknown df.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><a href="#topic+testResiduals">testResiduals</a>, <a href="#topic+testUniformity">testUniformity</a>, <a href="#topic+testOutliers">testOutliers</a>, <a href="#topic+testDispersion">testDispersion</a>, <a href="#topic+testZeroInflation">testZeroInflation</a>, <a href="#topic+testGeneric">testGeneric</a>, <a href="#topic+testTemporalAutocorrelation">testTemporalAutocorrelation</a>, <a href="#topic+testSpatialAutocorrelation">testSpatialAutocorrelation</a>, <a href="#topic+testQuantiles">testQuantiles</a>, <a href="#topic+testCategorical">testCategorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testData = createData(sampleSize = 100, overdispersion = 0.5, randomEffectVariance = 0)
fittedModel &lt;- glm(observedResponse ~ Environment1 , family = "poisson", data = testData)
simulationOutput &lt;- simulateResiduals(fittedModel = fittedModel)

# the plot function shows 2 plots and runs 4 tests
# i) KS test i) Dispersion test iii) Outlier test iv) quantile test
plot(simulationOutput, quantreg = TRUE)

# testResiduals tests distribution, dispersion and outliers
testResiduals(simulationOutput)

####### Individual tests #######

# KS test for correct distribution of residuals
testUniformity(simulationOutput)

# KS test for correct distribution within and between groups
testCategorical(simulationOutput, testData$group)

# Dispersion test - for details see ?testDispersion
testDispersion(simulationOutput) # tests under and overdispersion

# Outlier test (number of observations outside simulation envelope)
# Use type = "boostrap" for exact values, see ?testOutliers
testOutliers(simulationOutput, type = "binomial")

# testing zero inflation
testZeroInflation(simulationOutput)

# testing generic summaries
countOnes &lt;- function(x) sum(x == 1)  # testing for number of 1s
testGeneric(simulationOutput, summary = countOnes) # 1-inflation
testGeneric(simulationOutput, summary = countOnes, alternative = "less") # 1-deficit

means &lt;- function(x) mean(x) # testing if mean prediction fits
testGeneric(simulationOutput, summary = means)

spread &lt;- function(x) sd(x) # testing if mean sd fits
testGeneric(simulationOutput, summary = spread)
</code></pre>

<hr>
<h2 id='transformQuantiles'>Transform quantiles to pdf (deprecated)</h2><span id='topic+transformQuantiles'></span>

<h3>Description</h3>

<p>The purpose of this function was to transform the DHARMa quantile residuals (which have a uniform distribution) to a particular pdf. Since DHARMa 0.3.0, this functionality is integrated in the <a href="#topic+residuals.DHARMa">residuals.DHARMa</a> function. Please switch to using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformQuantiles(res, quantileFunction = qnorm, outlierValue = 7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformQuantiles_+3A_res">res</code></td>
<td>
<p>an object with simulated residuals created by <a href="#topic+simulateResiduals">simulateResiduals</a></p>
</td></tr>
<tr><td><code id="transformQuantiles_+3A_quantilefunction">quantileFunction</code></td>
<td>
<p>optional - a quantile function to transform the uniform 0/1 scaling of DHARMa to another distribution</p>
</td></tr>
<tr><td><code id="transformQuantiles_+3A_outliervalue">outlierValue</code></td>
<td>
<p>if a quantile function with infinite support (such as dnorm) is used, residuals that are 0/1 are mapped to -Inf / Inf. outlierValues allows to convert -Inf / Inf values to an optional min / max value.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
